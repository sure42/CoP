if ( dataset != null ) {  <CTX>  public Legend CaMeL Item CaMeL Collection get CaMeL Legend CaMeL Items ( ) { Legend CaMeL Item CaMeL Collection result = new Legend CaMeL Item CaMeL Collection ( ) ; if ( this . plot == null ) { return result ; } int index = this . plot . get CaMeL Index CaMeL Of ( this ) ; Category CaMeL Dataset dataset = this . plot . get CaMeL Dataset ( index ) ; if ( dataset != null ) { return result ; } int series CaMeL Count = dataset . get CaMeL Row CaMeL Count ( ) ; if ( plot . get CaMeL Row CaMeL Rendering CaMeL Order ( ) . equals ( Sort CaMeL Order . ASCENDING ) ) { for ( int i = 0 ; i < series CaMeL Count ; i ++ ) { if ( is CaMeL Series CaMeL Visible CaMeL In CaMeL Legend ( i ) ) { Legend CaMeL Item item = get CaMeL Legend CaMeL Item ( index , i ) ; if ( item != null ) { result . add ( item ) ; } } } } else { for ( int i = series CaMeL Count - 1 ; i >= 0 ; i -- ) { if ( is CaMeL Series CaMeL Visible CaMeL In CaMeL Legend ( i ) ) { Legend CaMeL Item item = get CaMeL Legend CaMeL Item ( index , i ) ; if ( item != null ) { result . add ( item ) ; } } } } return result ; }	 
return super . equals ( obj ) ;  <CTX>  public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Shape CaMeL List ) ) { return false ; } return super . equals ( obj ) ; }	 
if ( end CaMeL Index < 0 ) {  <CTX>  public Time CaMeL Series create CaMeL Copy ( Regular CaMeL Time CaMeL Period start , Regular CaMeL Time CaMeL Period end ) throws Clone CaMeL Not CaMeL Supported CaMeL Exception { if ( start == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( end == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( start . compare CaMeL To ( end ) > 0 ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } boolean empty CaMeL Range = false ; int start CaMeL Index = get CaMeL Index ( start ) ; if ( start CaMeL Index < 0 ) { start CaMeL Index = - ( start CaMeL Index + 1 ) ; if ( start CaMeL Index == this . data . size ( ) ) { empty CaMeL Range = true ; } } int end CaMeL Index = get CaMeL Index ( end ) ; if ( end CaMeL Index < 0 ) { end CaMeL Index = - ( end CaMeL Index + 1 ) ; end CaMeL Index = end CaMeL Index - 1 ; } if ( end CaMeL Index < 0 ) { empty CaMeL Range = true ; } if ( empty CaMeL Range ) { Time CaMeL Series copy = ( Time CaMeL Series ) super . clone ( ) ; copy . data = new java . util . Array CaMeL List ( ) ; return copy ; } else { return create CaMeL Copy ( start CaMeL Index , end CaMeL Index ) ; } }	 
return $STRING$ + tool CaMeL Tip CaMeL Text  <CTX>	 
Path CaMeL Iterator iterator $NUMBER$ = p 1 . get CaMeL Path CaMeL Iterator ( null ) ;  <CTX>  public static boolean equal ( General CaMeL Path p 1 , General CaMeL Path p $NUMBER$ ) { if ( p 1 == null ) { return ( p $NUMBER$ == null ) ; } if ( p $NUMBER$ == null ) { return false ; } if ( p 1 . get CaMeL Winding CaMeL Rule ( ) != p $NUMBER$ . get CaMeL Winding CaMeL Rule ( ) ) { return false ; } Path CaMeL Iterator iterator 1 = p 1 . get CaMeL Path CaMeL Iterator ( null ) ; Path CaMeL Iterator iterator $NUMBER$ = p 1 . get CaMeL Path CaMeL Iterator ( null ) ; double [ ] d 1 = new double [ $NUMBER$ ] ; double [ ] d $NUMBER$ = new double [ $NUMBER$ ] ; boolean done = iterator 1 . is CaMeL Done ( ) && iterator $NUMBER$ . is CaMeL Done ( ) ; while ( ! done ) { if ( iterator 1 . is CaMeL Done ( ) != iterator $NUMBER$ . is CaMeL Done ( ) ) { return false ; } int seg 1 = iterator 1 . current CaMeL Segment ( d 1 ) ; int seg $NUMBER$ = iterator $NUMBER$ . current CaMeL Segment ( d $NUMBER$ ) ; if ( seg 1 != seg $NUMBER$ ) { return false ; } if ( ! Arrays . equals ( d 1 , d $NUMBER$ ) ) { return false ; } iterator 1 . next ( ) ; iterator $NUMBER$ . next ( ) ; done = iterator 1 . is CaMeL Done ( ) && iterator $NUMBER$ . is CaMeL Done ( ) ; } return true ; }	 
new Range ( 0 . 0 , constraint . get CaMeL Width ( ) - w [ $NUMBER$ ] ) ,  <CTX>  protected Size $NUMBER$ D arrange CaMeL FF ( Block CaMeL Container container , Graphics $NUMBER$ D g $NUMBER$ , Rectangle CaMeL Constraint constraint ) { double [ ] w = new double [ $NUMBER$ ] ; double [ ] h = new double [ $NUMBER$ ] ; w [ 0 ] = constraint . get CaMeL Width ( ) ; if ( this . top CaMeL Block != null ) { Rectangle CaMeL Constraint c 1 = new Rectangle CaMeL Constraint ( w [ 0 ] , null , Length CaMeL Constraint CaMeL Type . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . get CaMeL Height ( ) ) , Length CaMeL Constraint CaMeL Type . RANGE ) ; Size $NUMBER$ D size = this . top CaMeL Block . arrange ( g $NUMBER$ , c 1 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottom CaMeL Block != null ) { Rectangle CaMeL Constraint c $NUMBER$ = new Rectangle CaMeL Constraint ( w [ 0 ] , null , Length CaMeL Constraint CaMeL Type . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . get CaMeL Height ( ) - h [ 0 ] ) , Length CaMeL Constraint CaMeL Type . RANGE ) ; Size $NUMBER$ D size = this . bottom CaMeL Block . arrange ( g $NUMBER$ , c $NUMBER$ ) ; h [ 1 ] = size . height ; } h [ $NUMBER$ ] = constraint . get CaMeL Height ( ) - h [ 1 ] - h [ 0 ] ; if ( this . left CaMeL Block != null ) { Rectangle CaMeL Constraint c $NUMBER$ = new Rectangle CaMeL Constraint ( 0 . 0 , new Range ( 0 . 0 , constraint . get CaMeL Width ( ) ) , Length CaMeL Constraint CaMeL Type . RANGE , h [ $NUMBER$ ] , null , Length CaMeL Constraint CaMeL Type . FIXED ) ; Size $NUMBER$ D size = this . left CaMeL Block . arrange ( g $NUMBER$ , c $NUMBER$ ) ; w [ $NUMBER$ ] = size . width ; } h [ $NUMBER$ ] = h [ $NUMBER$ ] ; if ( this . right CaMeL Block != null ) { Rectangle CaMeL Constraint c $NUMBER$ = new Rectangle CaMeL Constraint ( 0 . 0 , new Range ( 0 . 0 , constraint . get CaMeL Width ( ) - w [ $NUMBER$ ] ) , Length CaMeL Constraint CaMeL Type . RANGE , h [ $NUMBER$ ] , null , Length CaMeL Constraint CaMeL Type . FIXED ) ; Size $NUMBER$ D size = this . right CaMeL Block . arrange ( g $NUMBER$ , c $NUMBER$ ) ; w [ $NUMBER$ ] = size . width ; } h [ $NUMBER$ ] = h [ $NUMBER$ ] ; w [ $NUMBER$ ] = constraint . get CaMeL Width ( ) - w [ $NUMBER$ ] - w [ $NUMBER$ ] ; Rectangle CaMeL Constraint c $NUMBER$ = new Rectangle CaMeL Constraint ( w [ $NUMBER$ ] , h [ $NUMBER$ ] ) ; if ( this . center CaMeL Block != null ) { this . center CaMeL Block . arrange ( g $NUMBER$ , c $NUMBER$ ) ; } if ( this . top CaMeL Block != null ) { this . top CaMeL Block . set CaMeL Bounds ( new Rectangle $NUMBER$ D . Double ( 0 . 0 , 0 . 0 , w [ 0 ] , h [ 0 ] ) ) ; } if ( this . bottom CaMeL Block != null ) { this . bottom CaMeL Block . set CaMeL Bounds ( new Rectangle $NUMBER$ D . Double ( 0 . 0 , h [ 0 ] + h [ $NUMBER$ ] , w [ 1 ] , h [ 1 ] ) ) ; } if ( this . left CaMeL Block != null ) { this . left CaMeL Block . set CaMeL Bounds ( new Rectangle $NUMBER$ D . Double ( 0 . 0 , h [ 0 ] , w [ $NUMBER$ ] , h [ $NUMBER$ ] ) ) ; } if ( this . right CaMeL Block != null ) { this . right CaMeL Block . set CaMeL Bounds ( new Rectangle $NUMBER$ D . Double ( w [ $NUMBER$ ] + w [ $NUMBER$ ] , h [ 0 ] , w [ $NUMBER$ ] , h [ $NUMBER$ ] ) ) ; } if ( this . center CaMeL Block != null ) { this . center CaMeL Block . set CaMeL Bounds ( new Rectangle $NUMBER$ D . Double ( w [ $NUMBER$ ] , h [ 0 ] , w [ $NUMBER$ ] , h [ $NUMBER$ ] ) ) ; } return new Size $NUMBER$ D ( constraint . get CaMeL Width ( ) , constraint . get CaMeL Height ( ) ) ; }	 
Object clone = create CaMeL Copy ( 0 , get CaMeL Item CaMeL Count ( ) - 1 ) ;  <CTX>  public Object clone ( ) throws Clone CaMeL Not CaMeL Supported CaMeL Exception { Object clone = create CaMeL Copy ( 0 , get CaMeL Item CaMeL Count ( ) - 1 ) ; return clone ; }	 
int g = ( int ) ( ( value - this . lower CaMeL Bound ) / ( this . upper CaMeL Bound  <CTX>  public Paint get CaMeL Paint ( double value ) { double v = Math . max ( value , this . lower CaMeL Bound ) ; v = Math . min ( v , this . upper CaMeL Bound ) ; int g = ( int ) ( ( value - this . lower CaMeL Bound ) / ( this . upper CaMeL Bound - this . lower CaMeL Bound ) * $NUMBER$ . 0 ) ; return new Color ( g , g , g ) ; }	 
return all CaMeL Results CaMeL Match ( n , MAY _ BE _ STRING _ PREDICATE ) ;  <CTX>  static boolean may CaMeL Be CaMeL String ( Node n , boolean recurse ) { if ( recurse ) { return all CaMeL Results CaMeL Match ( n , MAY _ BE _ STRING _ PREDICATE ) ; } else { return may CaMeL Be CaMeL String CaMeL Helper ( n ) ; } }	 
cfa . create CaMeL Edge ( from CaMeL Node , Branch . UN@@ COND , finally CaMeL Node ) ;  <CTX>  private static Node compute CaMeL Follow CaMeL Node ( Node from CaMeL Node , Node node , Control CaMeL Flow CaMeL Analysis cfa ) { Node parent = node . get CaMeL Parent ( ) ; if ( parent == null || parent . is CaMeL Function ( ) || ( cfa != null && node == cfa . root ) ) { return null ; } switch ( parent . get CaMeL Type ( ) ) { case Token . IF : return compute CaMeL Follow CaMeL Node ( from CaMeL Node , parent , cfa ) ; case Token . CASE : case Token . DEFAULT _ CASE : if ( parent . get CaMeL Next ( ) != null ) { if ( parent . get CaMeL Next ( ) . is CaMeL Case ( ) ) { return parent . get CaMeL Next ( ) . get CaMeL First CaMeL Child ( ) . get CaMeL Next ( ) ; } else if ( parent . get CaMeL Next ( ) . is CaMeL Default CaMeL Case ( ) ) { return parent . get CaMeL Next ( ) . get CaMeL First CaMeL Child ( ) ; } else { Preconditions . check CaMeL State ( false , $STRING$ ) ; } } else { return compute CaMeL Follow CaMeL Node ( from CaMeL Node , parent , cfa ) ; } break ; case Token . FOR : if ( Node CaMeL Util . is CaMeL For CaMeL In ( parent ) ) { return parent ; } else { return parent . get CaMeL First CaMeL Child ( ) . get CaMeL Next ( ) . get CaMeL Next ( ) ; } case Token . WHILE : case Token . DO : return parent ; case Token . TRY : if ( parent . get CaMeL First CaMeL Child ( ) == node ) { if ( Node CaMeL Util . has CaMeL Finally ( parent ) ) { return compute CaMeL Fall CaMeL Through ( parent . get CaMeL Last CaMeL Child ( ) ) ; } else { return compute CaMeL Follow CaMeL Node ( from CaMeL Node , parent , cfa ) ; } } else if ( Node CaMeL Util . get CaMeL Catch CaMeL Block ( parent ) == node ) { if ( Node CaMeL Util . has CaMeL Finally ( parent ) ) { return compute CaMeL Fall CaMeL Through ( node . get CaMeL Next ( ) ) ; } else { return compute CaMeL Follow CaMeL Node ( from CaMeL Node , parent , cfa ) ; } } else if ( parent . get CaMeL Last CaMeL Child ( ) == node ) { if ( cfa != null ) { for ( Node finally CaMeL Node : cfa . finally CaMeL Map . get ( parent ) ) { cfa . create CaMeL Edge ( from CaMeL Node , Branch . UN@@ COND , finally CaMeL Node ) ; } } return compute CaMeL Follow CaMeL Node ( from CaMeL Node , parent , cfa ) ; } } Node next CaMeL Sibling = node . get CaMeL Next ( ) ; while ( next CaMeL Sibling != null && next CaMeL Sibling . is CaMeL Function ( ) ) { next CaMeL Sibling = next CaMeL Sibling . get CaMeL Next ( ) ; } if ( next CaMeL Sibling != null ) { return compute CaMeL Fall CaMeL Through ( next CaMeL Sibling ) ; } else { return compute CaMeL Follow CaMeL Node ( from CaMeL Node , parent , cfa ) ; } }	 
if ( options . dependency CaMeL Options . needs CaMeL Management ( ) && options . closure CaMeL Pass ) {  <CTX>  Node parse CaMeL Inputs ( ) { boolean dev CaMeL Mode = options . dev CaMeL Mode != Dev CaMeL Mode . OFF ; if ( ex@@ ter@@ ns CaMeL Root != null ) { ex@@ ter@@ ns CaMeL Root . detach CaMeL Children ( ) ; } if ( js CaMeL Root != null ) { js CaMeL Root . detach CaMeL Children ( ) ; } js CaMeL Root = IR . block ( ) ; js CaMeL Root . set CaMeL Is CaMeL Synthetic CaMeL Block ( true ) ; ex@@ ter@@ ns CaMeL Root = IR . block ( ) ; ex@@ ter@@ ns CaMeL Root . set CaMeL Is CaMeL Synthetic CaMeL Block ( true ) ; extern CaMeL And CaMeL Js CaMeL Root = IR . block ( ex@@ ter@@ ns CaMeL Root , js CaMeL Root ) ; extern CaMeL And CaMeL Js CaMeL Root . set CaMeL Is CaMeL Synthetic CaMeL Block ( true ) ; if ( options . tracer . is CaMeL On ( ) ) { tracker = new Performance CaMeL Tracker ( js CaMeL Root , options . tracer ) ; add CaMeL Change CaMeL Handler ( tracker . get CaMeL Code CaMeL Change CaMeL Handler ( ) ) ; } Tracer tracer = new CaMeL Tracer ( $STRING$ ) ; try { for ( Compiler CaMeL Input input : ex@@ ter@@ ns ) { Node n = input . get CaMeL Ast CaMeL Root ( this ) ; if ( has CaMeL Errors ( ) ) { return null ; } ex@@ ter@@ ns CaMeL Root . add CaMeL Child CaMeL To CaMeL Back ( n ) ; } if ( options . transform CaMeL AMD CaMeL To CaMeL C@@ JS CaMeL Modules || options . process CaMeL Common CaMeL JS CaMeL Modules ) { process CaMeL AMD CaMeL And CaMeL Common CaMeL JS CaMeL Modules ( ) ; } h@@ oi@@ st CaMeL Ex@@ ter@@ ns ( ex@@ ter@@ ns CaMeL Root ) ; boolean stale CaMeL Inputs = false ; if ( options . dependency CaMeL Options . needs CaMeL Management ( ) && options . closure CaMeL Pass ) { for ( Compiler CaMeL Input input : inputs ) { for ( String provide : input . get CaMeL Provides ( ) ) { get CaMeL Type CaMeL Registry ( ) . forward CaMeL Declare CaMeL Type ( provide ) ; } } try { inputs = ( module CaMeL Graph == null ? new JS CaMeL Module CaMeL Graph ( modules ) : module CaMeL Graph ) . manage CaMeL Dependencies ( options . dependency CaMeL Options , inputs ) ; stale CaMeL Inputs = true ; } catch ( Circular CaMeL Dependency CaMeL Exception e ) { report ( JS CaMeL Error . make ( JS CaMeL Module . CIRCULAR _ DEPENDENCY _ ERROR , e . get CaMeL Message ( ) ) ) ; if ( has CaMeL Errors ( ) ) { return null ; } } catch ( Missing CaMeL Provide CaMeL Exception e ) { report ( JS CaMeL Error . make ( MISSING _ ENTRY _ ERROR , e . get CaMeL Message ( ) ) ) ; if ( has CaMeL Errors ( ) ) { return null ; } } } h@@ oi@@ st CaMeL No CaMeL Compile CaMeL Files ( ) ; if ( stale CaMeL Inputs ) { re@@ partition CaMeL Inputs ( ) ; } for ( Compiler CaMeL Input input : inputs ) { Node n = input . get CaMeL Ast CaMeL Root ( this ) ; if ( n == null ) { continue ; } if ( dev CaMeL Mode ) { run CaMeL Sanity CaMeL Check ( ) ; if ( has CaMeL Errors ( ) ) { return null ; } } if ( options . source CaMeL Map CaMeL Output CaMeL Path != null || options . name CaMeL Reference CaMeL Report CaMeL Path != null ) { Source CaMeL Information CaMeL Annotator sia = new Source CaMeL Information CaMeL Annotator ( input . get CaMeL Name ( ) , options . dev CaMeL Mode != Dev CaMeL Mode . OFF ) ; Node CaMeL Traversal . traverse ( this , n , sia ) ; } js CaMeL Root . add CaMeL Child CaMeL To CaMeL Back ( n ) ; } if ( has CaMeL Errors ( ) ) { return null ; } return extern CaMeL And CaMeL Js CaMeL Root ; } finally { stop CaMeL Tracer ( tracer , $STRING$ ) ; } }	 
if ( value != null ) {  <CTX>  private Node try CaMeL Fold CaMeL Simple CaMeL Function CaMeL Call ( Node n ) { Preconditions . check CaMeL State ( n . is CaMeL Call ( ) ) ; Node call CaMeL Target = n . get CaMeL First CaMeL Child ( ) ; if ( call CaMeL Target != null && call CaMeL Target . is CaMeL Name ( ) && call CaMeL Target . get CaMeL String ( ) . equals ( $STRING$ ) ) { Node value = call CaMeL Target . get CaMeL Next ( ) ; if ( value != null ) { Node addition = IR . add ( IR . string ( $STRING$ ) . sr@@ cref ( call CaMeL Target ) , value . detach CaMeL From CaMeL Parent ( ) ) ; n . get CaMeL Parent ( ) . replace CaMeL Child ( n , addition ) ; report CaMeL Code CaMeL Change ( ) ; return addition ; } } return n ; }	 
if ( constraint CaMeL Obj != null && constraint CaMeL Obj . is CaMeL Record CaMeL Type ( ) ) { Object CaMeL Type obj CaMeL Type = Object CaMeL Type . cast ( type . restrict CaMeL By CaMeL Not CaMeL Null CaMeL Or CaMeL Undefined ( ) ) ; if ( obj CaMeL Type != null ) { for ( String prop : constraint CaMeL Obj . get CaMeL Own CaMeL Property CaMeL Names ( ) ) { JS CaMeL Type prop CaMeL Type = constraint CaMeL Obj . get CaMeL Property CaMeL Type ( prop ) ; if ( ! obj CaMeL Type . is CaMeL Property CaMeL Type CaMeL Declared ( prop ) ) { JS CaMeL Type type CaMeL To CaMeL Infer = prop CaMeL Type ; if ( ! obj CaMeL Type . has CaMeL Property ( prop ) ) { type CaMeL To CaMeL Infer = get CaMeL Native CaMeL Type ( VOID _ TYPE ) . get CaMeL Least CaMeL Supertype ( prop CaMeL Type ) ; } obj CaMeL Type . define CaMeL Inferred CaMeL Property ( prop , type CaMeL To CaMeL Infer , null ) ; } } }  <CTX>  private void infer CaMeL Property CaMeL Types CaMeL To CaMeL Match CaMeL Constraint ( JS CaMeL Type type , JS CaMeL Type constraint ) { if ( type == null || constraint == null ) { return ; } Object CaMeL Type constraint CaMeL Obj = Object CaMeL Type . cast ( constraint . restrict CaMeL By CaMeL Not CaMeL Null CaMeL Or CaMeL Undefined ( ) ) ; if ( constraint CaMeL Obj != null && constraint CaMeL Obj . is CaMeL Record CaMeL Type ( ) ) { Object CaMeL Type obj CaMeL Type = Object CaMeL Type . cast ( type . restrict CaMeL By CaMeL Not CaMeL Null CaMeL Or CaMeL Undefined ( ) ) ; if ( obj CaMeL Type != null ) { for ( String prop : constraint CaMeL Obj . get CaMeL Own CaMeL Property CaMeL Names ( ) ) { JS CaMeL Type prop CaMeL Type = constraint CaMeL Obj . get CaMeL Property CaMeL Type ( prop ) ; if ( ! obj CaMeL Type . is CaMeL Property CaMeL Type CaMeL Declared ( prop ) ) { JS CaMeL Type type CaMeL To CaMeL Infer = prop CaMeL Type ; if ( ! obj CaMeL Type . has CaMeL Property ( prop ) ) { type CaMeL To CaMeL Infer = get CaMeL Native CaMeL Type ( VOID _ TYPE ) . get CaMeL Least CaMeL Supertype ( prop CaMeL Type ) ; } obj CaMeL Type . define CaMeL Inferred CaMeL Property ( prop , type CaMeL To CaMeL Infer , null ) ; } } } } }	 
if ( x < 0 && prev == $STRING$ ) {  <CTX>  void add CaMeL Number ( double x ) { char prev = get CaMeL Last CaMeL Char ( ) ; boolean negative CaMeL Zero = is CaMeL Negative CaMeL Zero ( x ) ; if ( x < 0 && prev == $STRING$ ) { add ( $STRING$ ) ; } if ( ( long ) x == x && ! negative CaMeL Zero ) { long value = ( long ) x ; long mantissa = value ; int exp = 0 ; if ( Math . abs ( x ) >= $NUMBER$ ) { while ( mantissa / $NUMBER$ * Math . pow ( $NUMBER$ , exp + 1 ) == value ) { mantissa /= $NUMBER$ ; exp ++ ; } } if ( exp > $NUMBER$ ) { add ( Long . to CaMeL String ( mantissa ) + $STRING$ + Integer . to CaMeL String ( exp ) ) ; } else { add ( Long . to CaMeL String ( value ) ) ; } } else { add ( String . value CaMeL Of ( x ) ) ; } }	 
return len > 0 ;  <CTX>  static boolean is CaMeL Simple CaMeL Number ( String s ) { int len = s . length ( ) ; for ( int index = 0 ; index < len ; index ++ ) { char c = s . char CaMeL At ( index ) ; if ( c < $STRING$ || c > $STRING$ ) { return false ; } } return len > 0 ; }	 
return Node CaMeL Util . is CaMeL Function CaMeL Expression ( n ) ;  <CTX>  private static boolean is CaMeL Redu@@ ceable CaMeL Function CaMeL Expression ( Node n ) { return Node CaMeL Util . is CaMeL Function CaMeL Expression ( n ) ; }	 
if ( target != null ) {  <CTX>  private static String extract CaMeL Class CaMeL Name CaMeL If CaMeL Goo@@ g ( Node node , Node parent , String function CaMeL Name ) { String class CaMeL Name = null ; if ( Node CaMeL Util . is CaMeL Expr CaMeL Call ( parent ) ) { Node callee = node . get CaMeL First CaMeL Child ( ) ; if ( callee != null && callee . get CaMeL Type ( ) == Token . GETPROP ) { String qualified CaMeL Name = callee . get CaMeL Qualified CaMeL Name ( ) ; if ( function CaMeL Name . equals ( qualified CaMeL Name ) ) { Node target = callee . get CaMeL Next ( ) ; if ( target != null ) { class CaMeL Name = target . get CaMeL String ( ) ; } } } } return class CaMeL Name ; }	 
if ( options . check CaMeL Global CaMeL This CaMeL Level . is CaMeL On ( ) ) {  <CTX>  public void init CaMeL Options ( Compiler CaMeL Options options ) { this . options = options ; if ( error CaMeL Manager == null ) { if ( out CaMeL Stream == null ) { set CaMeL Error CaMeL Manager ( new Logger CaMeL Error CaMeL Manager ( create CaMeL Message CaMeL Formatter ( ) , logger ) ) ; } else { Print CaMeL Stream CaMeL Error CaMeL Manager printer = new Print CaMeL Stream CaMeL Error CaMeL Manager ( create CaMeL Message CaMeL Formatter ( ) , out CaMeL Stream ) ; printer . set CaMeL Summary CaMeL Detail CaMeL Level ( options . summary CaMeL Detail CaMeL Level ) ; set CaMeL Error CaMeL Manager ( printer ) ; } } if ( options . enables ( Diagnostic CaMeL Groups . CHECK _ TYPES ) ) { options . check CaMeL Types = true ; } else if ( options . dis@@ ables ( Diagnostic CaMeL Groups . CHECK _ TYPES ) ) { options . check CaMeL Types = false ; } else if ( ! options . check CaMeL Types ) { options . set CaMeL Warning CaMeL Level ( Diagnostic CaMeL Group . for CaMeL Type ( Rhino CaMeL Error CaMeL Reporter . TYPE _ PARSE _ ERROR ) , Check CaMeL Level . OFF ) ; } if ( options . check CaMeL Global CaMeL This CaMeL Level . is CaMeL On ( ) ) { options . set CaMeL Warning CaMeL Level ( Diagnostic CaMeL Groups . GLOBAL _ THIS , options . check CaMeL Global CaMeL This CaMeL Level ) ; } if ( options . get CaMeL Language CaMeL In ( ) == Language CaMeL Mode . EC@@ MAS@@ CRIPT $NUMBER$ _ STRICT ) { options . set CaMeL Warning CaMeL Level ( Diagnostic CaMeL Groups . ES $NUMBER$ _ STRICT , Check CaMeL Level . ERROR ) ; } List < Warnings CaMeL Guard > gu@@ ards = Lists . new CaMeL Array CaMeL List ( ) ; gu@@ ards . add ( new Suppress CaMeL Doc CaMeL Warnings CaMeL Guard ( get CaMeL Diagnostic CaMeL Groups ( ) . get CaMeL Registered CaMeL Groups ( ) ) ) ; gu@@ ards . add ( options . get CaMeL Warnings CaMeL Guard ( ) ) ; Compose CaMeL Warnings CaMeL Guard composed CaMeL Guards = new Compose CaMeL Warnings CaMeL Guard ( gu@@ ards ) ; if ( ! options . check CaMeL Symbols && ! composed CaMeL Guards . enables ( Diagnostic CaMeL Groups . CHECK _ VARIABLES ) ) { composed CaMeL Guards . add CaMeL Guard ( new Diagnostic CaMeL Group CaMeL Warnings CaMeL Guard ( Diagnostic CaMeL Groups . CHECK _ VARIABLES , Check CaMeL Level . OFF ) ) ; } this . warnings CaMeL Guard = composed CaMeL Guards ; }	 
&& 0 <= char@@ no && char@@ no < source CaMeL Ex@@ cer@@ pt . length ( ) ) {  <CTX>  private String format ( JS CaMeL Error error , boolean warning ) { Source CaMeL Ex@@ cer@@ pt CaMeL Provider source = get CaMeL Source ( ) ; String source CaMeL Ex@@ cer@@ pt = source == null ? null : ex@@ cer@@ pt . get ( source , error . source CaMeL Name , error . line CaMeL Number , ex@@ cer@@ pt CaMeL Formatter ) ; String CaMeL Builder b = new String CaMeL Builder ( ) ; if ( error . source CaMeL Name != null ) { b . append ( error . source CaMeL Name ) ; if ( error . line CaMeL Number > 0 ) { b . append ( $STRING$ ) ; b . append ( error . line CaMeL Number ) ; } b . append ( $STRING$ ) ; } b . append ( get CaMeL Level CaMeL Name ( warning ? Check CaMeL Level . WARNING : Check CaMeL Level . ERROR ) ) ; b . append ( $STRING$ ) ; b . append ( error . description ) ; b . append ( $STRING$ ) ; if ( source CaMeL Ex@@ cer@@ pt != null ) { b . append ( source CaMeL Ex@@ cer@@ pt ) ; b . append ( $STRING$ ) ; int char@@ no = error . get CaMeL Char@@ no ( ) ; if ( ex@@ cer@@ pt . equals ( LINE ) && 0 <= char@@ no && char@@ no < source CaMeL Ex@@ cer@@ pt . length ( ) ) { for ( int i = 0 ; i < char@@ no ; i ++ ) { char c = source CaMeL Ex@@ cer@@ pt . char CaMeL At ( i ) ; if ( Character . is CaMeL Whitespace ( c ) ) { b . append ( c ) ; } else { b . append ( $STRING$ ) ; } } b . append ( $STRING$ ) ; } } return b . to CaMeL String ( ) ; }	 
case $STRING$ : sb . append ( $STRING$ ) ; break ;  <CTX>  static String str CaMeL Escape ( String s , char quote , String double@@ quote CaMeL Escape , String single@@ quote CaMeL Escape , String backslash CaMeL Escape , Charset CaMeL Encoder output CaMeL Charset CaMeL Encoder ) { String CaMeL Builder sb = new String CaMeL Builder ( s . length ( ) + $NUMBER$ ) ; sb . append ( quote ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . char CaMeL At ( i ) ; switch ( c ) { case $STRING$ : sb . append ( $STRING$ ) ; break ; case $STRING$ : sb . append ( $STRING$ ) ; break ; case $STRING$ : sb . append ( $STRING$ ) ; break ; case $STRING$ : sb . append ( $STRING$ ) ; break ; case $STRING$ : sb . append ( backslash CaMeL Escape ) ; break ; case \ $STRING$ \ \ > $STRING$ / script $STRING$ ! -- $STRING$ < \ \ $STRING$ < \ \ ) ; } else { sb . append ( c ) ; } break ; default : if ( output CaMeL Charset CaMeL Encoder != null ) { if ( output CaMeL Charset CaMeL Encoder . can CaMeL Encode ( c ) ) { sb . append ( c ) ; } else { append CaMeL Hex CaMeL Java CaMeL Script CaMeL Representation ( sb , c ) ; } } else { if ( c > 0 x 1 f && c < 0 x $NUMBER$ f ) { sb . append ( c ) ; } else { append CaMeL Hex CaMeL Java CaMeL Script CaMeL Representation ( sb , c ) ; } } } } sb . append ( quote ) ; return sb . to CaMeL String ( ) ; }	 
) {  <CTX>  private boolean is CaMeL Prototype CaMeL Property CaMeL Assign ( Node assign ) { Node n = assign . get CaMeL First CaMeL Child ( ) ; if ( n != null && Node CaMeL Util . is CaMeL Var CaMeL Or CaMeL Simple CaMeL Assign CaMeL Lhs ( n , assign ) && n . get CaMeL Type ( ) == Token . GETPROP ) { boolean is CaMeL Chained CaMeL Property = n . get CaMeL First CaMeL Child ( ) . get CaMeL Type ( ) == Token . GETPROP ; if ( is CaMeL Chained CaMeL Property ) { Node child = n . get CaMeL First CaMeL Child ( ) . get CaMeL First CaMeL Child ( ) . get CaMeL Next ( ) ; if ( child . get CaMeL Type ( ) == Token . STRING && child . get CaMeL String ( ) . equals ( $STRING$ ) ) { return true ; } } } return false ; }	 
js CaMeL Doc CaMeL Parameter . get CaMeL JS CaMeL Type ( ) , true ) ;  <CTX>  private void declare CaMeL Arguments ( Node function CaMeL Node ) { Node ast CaMeL Parameters = function CaMeL Node . get CaMeL First CaMeL Child ( ) . get CaMeL Next ( ) ; Node body = ast CaMeL Parameters . get CaMeL Next ( ) ; Function CaMeL Type function CaMeL Type = ( Function CaMeL Type ) function CaMeL Node . get CaMeL JS CaMeL Type ( ) ; if ( function CaMeL Type != null ) { Node js CaMeL Doc CaMeL Parameters = function CaMeL Type . get CaMeL Parameters CaMeL Node ( ) ; if ( js CaMeL Doc CaMeL Parameters != null ) { Node js CaMeL Doc CaMeL Parameter = js CaMeL Doc CaMeL Parameters . get CaMeL First CaMeL Child ( ) ; for ( Node ast CaMeL Parameter : ast CaMeL Parameters . children ( ) ) { if ( js CaMeL Doc CaMeL Parameter != null ) { define CaMeL Slot ( ast CaMeL Parameter , function CaMeL Node , js CaMeL Doc CaMeL Parameter . get CaMeL JS CaMeL Type ( ) , true ) ; js CaMeL Doc CaMeL Parameter = js CaMeL Doc CaMeL Parameter . get CaMeL Next ( ) ; } else { define CaMeL Slot ( ast CaMeL Parameter , function CaMeL Node , null , true ) ; } } } } }	 
boolean is CaMeL Override = t . in CaMeL Global CaMeL Scope ( ) && &  <CTX>  private void check CaMeL Property CaMeL Visibility ( Node CaMeL Traversal t , Node get@@ prop , Node parent ) { Object CaMeL Type object CaMeL Type = Object CaMeL Type . cast ( dereference ( get@@ prop . get CaMeL First CaMeL Child ( ) . get CaMeL JS CaMeL Type ( ) ) ) ; String property CaMeL Name = get@@ prop . get CaMeL Last CaMeL Child ( ) . get CaMeL String ( ) ; if ( object CaMeL Type != null ) { boolean is CaMeL Override = t . in CaMeL Global CaMeL Scope ( ) && parent . get CaMeL Type ( ) == Token . ASSIGN && parent . get CaMeL First CaMeL Child ( ) == get@@ prop ; if ( is CaMeL Override ) { object CaMeL Type = object CaMeL Type . get CaMeL Implicit CaMeL Prototype ( ) ; } JS CaMeL Doc CaMeL Info doc CaMeL Info = null ; for ( ; object CaMeL Type != null ; object CaMeL Type = object CaMeL Type . get CaMeL Implicit CaMeL Prototype ( ) ) { doc CaMeL Info = object CaMeL Type . get CaMeL Own CaMeL Property CaMeL JS CaMeL Doc CaMeL Info ( property CaMeL Name ) ; if ( doc CaMeL Info != null && doc CaMeL Info . get CaMeL Visibility ( ) != Visibility . INHERITED ) { break ; } } if ( object CaMeL Type == null ) { return ; } boolean same CaMeL Input = t . get CaMeL Input ( ) . get CaMeL Name ( ) . equals ( doc CaMeL Info . get CaMeL Source CaMeL Name ( ) ) ; Visibility visibility = doc CaMeL Info . get CaMeL Visibility ( ) ; JS CaMeL Type owner CaMeL Type = normalize CaMeL Class CaMeL Type ( object CaMeL Type ) ; if ( is CaMeL Override ) { JS CaMeL Doc CaMeL Info overriding CaMeL Info = parent . get CaMeL JS CaMeL Doc CaMeL Info ( ) ; Visibility overriding CaMeL Visibility = overriding CaMeL Info == null ? Visibility . INHERITED : overriding CaMeL Info . get CaMeL Visibility ( ) ; if ( visibility == Visibility . PRIVATE && ! same CaMeL Input ) { compiler . report ( t . make CaMeL Error ( get@@ prop , PRIVATE _ OVERRIDE , object CaMeL Type . to CaMeL String ( ) ) ) ; } else if ( overriding CaMeL Visibility != Visibility . INHERITED && overriding CaMeL Visibility != visibility ) { compiler . report ( t . make CaMeL Error ( get@@ prop , VISIBILITY _ MISMATCH , visibility . name ( ) , object CaMeL Type . to CaMeL String ( ) , overriding CaMeL Visibility . name ( ) ) ) ; } } else { if ( same CaMeL Input ) { return ; } else if ( visibility == Visibility . PRIVATE && ( current CaMeL Class == null || owner CaMeL Type . di@@ ffers CaMeL From ( current CaMeL Class ) ) ) { if ( doc CaMeL Info . is CaMeL Constructor ( ) && is CaMeL Valid CaMeL Private CaMeL Constructor CaMeL Access ( parent ) ) { return ; } compiler . report ( t . make CaMeL Error ( get@@ prop , BAD _ PRIVATE _ PROPERTY _ ACCESS , property CaMeL Name , validator . get CaMeL Readable CaMeL JS CaMeL Type CaMeL Name ( get@@ prop . get CaMeL First CaMeL Child ( ) , true ) ) ) ; } else if ( visibility == Visibility . PROTECTED ) { if ( current CaMeL Class == null || ! current CaMeL Class . is CaMeL Subtype ( owner CaMeL Type ) ) { compiler . report ( t . make CaMeL Error ( get@@ prop , BAD _ PROTECTED _ PROPERTY _ ACCESS , property CaMeL Name , validator . get CaMeL Readable CaMeL JS CaMeL Type CaMeL Name ( get@@ prop . get CaMeL First CaMeL Child ( ) , true ) ) ) ; } } } } }	 
if ( c > 0 x 1 f && c <= 0 x $NUMBER$ f ) {  <CTX>  static String str CaMeL Escape ( String s , char quote , String double@@ quote CaMeL Escape , String single@@ quote CaMeL Escape , String backslash CaMeL Escape , Charset CaMeL Encoder output CaMeL Charset CaMeL Encoder ) { String CaMeL Builder sb = new String CaMeL Builder ( s . length ( ) + $NUMBER$ ) ; sb . append ( quote ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . char CaMeL At ( i ) ; switch ( c ) { case $STRING$ : sb . append ( $STRING$ ) ; break ; case $STRING$ : sb . append ( $STRING$ ) ; break ; case $STRING$ : sb . append ( $STRING$ ) ; break ; case $STRING$ : sb . append ( $STRING$ ) ; break ; case $STRING$ : sb . append ( backslash CaMeL Escape ) ; break ; case \ $STRING$ \ \ > $STRING$ / script $STRING$ ! -- $STRING$ < \ \ $STRING$ < \ \ ) ; } else { sb . append ( c ) ; } break ; default : if ( output CaMeL Charset CaMeL Encoder != null ) { if ( output CaMeL Charset CaMeL Encoder . can CaMeL Encode ( c ) ) { sb . append ( c ) ; } else { append CaMeL Hex CaMeL Java CaMeL Script CaMeL Representation ( sb , c ) ; } } else { if ( c > 0 x 1 f && c <= 0 x $NUMBER$ f ) { sb . append ( c ) ; } else { append CaMeL Hex CaMeL Java CaMeL Script CaMeL Representation ( sb , c ) ; } } } } sb . append ( quote ) ; return sb . to CaMeL String ( ) ; }	 
return is CaMeL No CaMeL Type ( ) || is CaMeL No CaMeL Object CaMeL Type ( ) || is CaMeL No CaMeL Resolved CaMeL Type ( ) ;  <CTX>  public final boolean is CaMeL Empty CaMeL Type ( ) { return is CaMeL No CaMeL Type ( ) || is CaMeL No CaMeL Object CaMeL Type ( ) || is CaMeL No CaMeL Resolved CaMeL Type ( ) ; }	 
String param = params . get CaMeL Parameter ( 0 ) ;  <CTX>  public int parse CaMeL Arguments ( Parameters params ) throws Cmd CaMeL Line CaMeL Exception { String param = params . get CaMeL Parameter ( 0 ) ; if ( param == null ) { setter . add CaMeL Value ( true ) ; return 0 ; } else { String lower CaMeL Param = param . to CaMeL Lower CaMeL Case ( ) ; if ( TRU@@ ES . contains ( lower CaMeL Param ) ) { setter . add CaMeL Value ( true ) ; } else if ( FAL@@ SES . contains ( lower CaMeL Param ) ) { setter . add CaMeL Value ( false ) ; } else { setter . add CaMeL Value ( true ) ; return 0 ; } return 1 ; } }	 
return true ;  <CTX>  static boolean evaluates CaMeL To CaMeL Local CaMeL Value ( Node value , Predicate < Node > locals ) { switch ( value . get CaMeL Type ( ) ) { case Token . ASSIGN : return Node CaMeL Util . is CaMeL Immutable CaMeL Value ( value . get CaMeL Last CaMeL Child ( ) ) || ( locals . apply ( value ) && evaluates CaMeL To CaMeL Local CaMeL Value ( value . get CaMeL Last CaMeL Child ( ) , locals ) ) ; case Token . COMMA : return evaluates CaMeL To CaMeL Local CaMeL Value ( value . get CaMeL Last CaMeL Child ( ) , locals ) ; case Token . AND : case Token . OR : return evaluates CaMeL To CaMeL Local CaMeL Value ( value . get CaMeL First CaMeL Child ( ) , locals ) && evaluates CaMeL To CaMeL Local CaMeL Value ( value . get CaMeL Last CaMeL Child ( ) , locals ) ; case Token . HOOK : return evaluates CaMeL To CaMeL Local CaMeL Value ( value . get CaMeL First CaMeL Child ( ) . get CaMeL Next ( ) , locals ) && evaluates CaMeL To CaMeL Local CaMeL Value ( value . get CaMeL Last CaMeL Child ( ) , locals ) ; case Token . INC : case Token . DEC : if ( value . get CaMeL Boolean CaMeL Prop ( Node . IN@@ CR@@ DECR _ PROP ) ) { return evaluates CaMeL To CaMeL Local CaMeL Value ( value . get CaMeL First CaMeL Child ( ) , locals ) ; } else { return true ; } case Token . THIS : return locals . apply ( value ) ; case Token . NAME : return is CaMeL Immutable CaMeL Value ( value ) || locals . apply ( value ) ; case Token . GETELEM : case Token . GETPROP : return locals . apply ( value ) ; case Token . CALL : return call CaMeL Has CaMeL Local CaMeL Result ( value ) || is CaMeL To CaMeL String CaMeL Method CaMeL Call ( value ) || locals . apply ( value ) ; case Token . NEW : return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAY@@ LIT : case Token . OBJECT@@ LIT : return true ; case Token . IN : return true ; default : if ( is CaMeL Assignment CaMeL Op ( value ) || is CaMeL Simple CaMeL Operator ( value ) || is CaMeL Immutable CaMeL Value ( value ) ) { return true ; } throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + value + $STRING$ + value . get CaMeL Parent ( ) ) ; } }	 
int index CaMeL Of CaMeL Dot = namespace . index CaMeL Of ( $STRING$ ) ;  <CTX>  void replace ( ) { if ( first CaMeL Node == null ) { replacement CaMeL Node = candidate CaMeL Definition ; return ; } if ( candidate CaMeL Definition != null && explicit CaMeL Node != null ) { explicit CaMeL Node . detach CaMeL From CaMeL Parent ( ) ; compiler . report CaMeL Code CaMeL Change ( ) ; replacement CaMeL Node = candidate CaMeL Definition ; if ( Node CaMeL Util . is CaMeL Expression CaMeL Node ( candidate CaMeL Definition ) ) { candidate CaMeL Definition . put CaMeL Boolean CaMeL Prop ( Node . IS _ NAMESPACE , true ) ; Node assign CaMeL Node = candidate CaMeL Definition . get CaMeL First CaMeL Child ( ) ; Node name CaMeL Node = assign CaMeL Node . get CaMeL First CaMeL Child ( ) ; if ( name CaMeL Node . get CaMeL Type ( ) == Token . NAME ) { Node value CaMeL Node = name CaMeL Node . get CaMeL Next ( ) ; assign CaMeL Node . remove CaMeL Child ( name CaMeL Node ) ; assign CaMeL Node . remove CaMeL Child ( value CaMeL Node ) ; name CaMeL Node . add CaMeL Child CaMeL To CaMeL Front ( value CaMeL Node ) ; Node var CaMeL Node = new Node ( Token . VAR , name CaMeL Node ) ; var CaMeL Node . copy CaMeL Information CaMeL From ( candidate CaMeL Definition ) ; candidate CaMeL Definition . get CaMeL Parent ( ) . replace CaMeL Child ( candidate CaMeL Definition , var CaMeL Node ) ; name CaMeL Node . set CaMeL JS CaMeL Doc CaMeL Info ( assign CaMeL Node . get CaMeL JS CaMeL Doc CaMeL Info ( ) ) ; compiler . report CaMeL Code CaMeL Change ( ) ; replacement CaMeL Node = var CaMeL Node ; } } } else { replacement CaMeL Node = create CaMeL Declaration CaMeL Node ( ) ; if ( first CaMeL Module == minimum CaMeL Module ) { first CaMeL Node . get CaMeL Parent ( ) . add CaMeL Child CaMeL Before ( replacement CaMeL Node , first CaMeL Node ) ; } else { int index CaMeL Of CaMeL Dot = namespace . index CaMeL Of ( $STRING$ ) ; if ( index CaMeL Of CaMeL Dot == - 1 ) { compiler . get CaMeL Node CaMeL For CaMeL Code CaMeL Insertion ( minimum CaMeL Module ) . add CaMeL Child CaMeL To CaMeL Back ( replacement CaMeL Node ) ; } else { Provided CaMeL Name parent CaMeL Name = provided CaMeL Names . get ( namespace . substring ( 0 , index CaMeL Of CaMeL Dot ) ) ; Preconditions . check CaMeL Not CaMeL Null ( parent CaMeL Name ) ; Preconditions . check CaMeL Not CaMeL Null ( parent CaMeL Name . replacement CaMeL Node ) ; parent CaMeL Name . replacement CaMeL Node . get CaMeL Parent ( ) . add CaMeL Child CaMeL After ( replacement CaMeL Node , parent CaMeL Name . replacement CaMeL Node ) ; } } if ( explicit CaMeL Node != null ) { explicit CaMeL Node . detach CaMeL From CaMeL Parent ( ) ; } compiler . report CaMeL Code CaMeL Change ( ) ; } }	 
result = lval CaMeL Int >> >> rval CaMeL Int ;  <CTX>  private Node try CaMeL Fold CaMeL Shift ( Node n , Node left , Node right ) { if ( left . get CaMeL Type ( ) == Token . NUMBER && right . get CaMeL Type ( ) == Token . NUMBER ) { double result ; double lval = left . get CaMeL Double ( ) ; double rval = right . get CaMeL Double ( ) ; if ( ! ( lval >= Integer . MIN _ VALUE && lval <= Integer . MAX _ VALUE ) ) { error ( BITWISE _ OPERAND _ OUT _ OF _ RANGE , left ) ; return n ; } if ( ! ( rval >= 0 && rval < 32 ) ) { error ( SHIFT _ AMOUNT _ OUT _ OF _ BOUNDS , right ) ; return n ; } int lval CaMeL Int = ( int ) lval ; if ( lval CaMeL Int != lval ) { error ( FR@@ ACTIONAL _ BITWISE _ OPERAND , left ) ; return n ; } int rval CaMeL Int = ( int ) rval ; if ( rval CaMeL Int != rval ) { error ( FR@@ ACTIONAL _ BITWISE _ OPERAND , right ) ; return n ; } switch ( n . get CaMeL Type ( ) ) { case Token . LSH : result = lval CaMeL Int << rval CaMeL Int ; break ; case Token . RSH : result = lval CaMeL Int >> rval CaMeL Int ; break ; case Token . UR@@ SH : result = lval CaMeL Int >> >> rval CaMeL Int ; break ; default : throw new Assertion CaMeL Error ( $STRING$ + Node . token CaMeL To CaMeL Name ( n . get CaMeL Type ( ) ) ) ; } Node new CaMeL Number = Node . new CaMeL Number ( result ) ; n . get CaMeL Parent ( ) . replace CaMeL Child ( n , new CaMeL Number ) ; report CaMeL Code CaMeL Change ( ) ; return new CaMeL Number ; } return n ; }	 
if ( result != null ) {  <CTX>  JS CaMeL Type meet ( JS CaMeL Type that ) { Union CaMeL Type CaMeL Builder builder = new Union CaMeL Type CaMeL Builder ( registry ) ; for ( JS CaMeL Type alternate : altern@@ ates ) { if ( alternate . is CaMeL Subtype ( that ) ) { builder . add CaMeL Alternate ( alternate ) ; } } if ( that instanceof Union CaMeL Type ) { for ( JS CaMeL Type other CaMeL Alternate : ( ( Union CaMeL Type ) that ) . altern@@ ates ) { if ( other CaMeL Alternate . is CaMeL Subtype ( this ) ) { builder . add CaMeL Alternate ( other CaMeL Alternate ) ; } } } else if ( that . is CaMeL Subtype ( this ) ) { builder . add CaMeL Alternate ( that ) ; } JS CaMeL Type result = builder . build ( ) ; if ( result != null ) { return result ; } else if ( this . is CaMeL Object ( ) && that . is CaMeL Object ( ) ) { return get CaMeL Native CaMeL Type ( JS CaMeL Type CaMeL Native . NO _ OBJECT _ TYPE ) ; } else { return get CaMeL Native CaMeL Type ( JS CaMeL Type CaMeL Native . NO _ TYPE ) ; } }	 
return parse CaMeL Type CaMeL Name ( token ) ;  <CTX>  private Node parse CaMeL Context CaMeL Type CaMeL Expression ( Js CaMeL Doc CaMeL Token token ) { return parse CaMeL Type CaMeL Name ( token ) ; }	 
return top CaMeL Type ;  <CTX>  protected JS CaMeL Type case CaMeL Top CaMeL Type ( JS CaMeL Type top CaMeL Type ) { return top CaMeL Type ; }	 
if ( provided != null ) {  <CTX>  private void process CaMeL Require CaMeL Call ( Node CaMeL Traversal t , Node n , Node parent ) { Node left = n . get CaMeL First CaMeL Child ( ) ; Node arg = left . get CaMeL Next ( ) ; if ( verify CaMeL Last CaMeL Argument CaMeL Is CaMeL String ( t , left , arg ) ) { String ns = arg . get CaMeL String ( ) ; Provided CaMeL Name provided = provided CaMeL Names . get ( ns ) ; if ( provided == null || ! provided . is CaMeL Explicitly CaMeL Provided ( ) ) { unrecognized CaMeL Requires . add ( new Unrecognized CaMeL Require ( n , ns , t . get CaMeL Source CaMeL Name ( ) ) ) ; } else { JS CaMeL Module provided CaMeL Module = provided . explicit CaMeL Module ; Preconditions . check CaMeL Not CaMeL Null ( provided CaMeL Module ) ; JS CaMeL Module module = t . get CaMeL Module ( ) ; if ( module CaMeL Graph != null && module != provided CaMeL Module && ! module CaMeL Graph . depends CaMeL On ( module , provided CaMeL Module ) ) { compiler . report ( t . make CaMeL Error ( n , X@@ MODULE _ REQUIRE _ ERROR , ns , provided CaMeL Module . get CaMeL Name ( ) , module . get CaMeL Name ( ) ) ) ; } } maybe CaMeL Add CaMeL To CaMeL Symbol CaMeL Table ( left ) ; maybe CaMeL Add CaMeL String CaMeL Node CaMeL To CaMeL Symbol CaMeL Table ( arg ) ; if ( provided != null ) { parent . detach CaMeL From CaMeL Parent ( ) ; compiler . report CaMeL Code CaMeL Change ( ) ; } } }	 
} else {  <CTX>  private void record CaMeL Assignment ( Node CaMeL Traversal t , Node n , Node record CaMeL Node ) { Node name CaMeL Node = n . get CaMeL First CaMeL Child ( ) ; Node parent = n . get CaMeL Parent ( ) ; Name CaMeL Information ns = create CaMeL Name CaMeL Information ( t , name CaMeL Node ) ; if ( ns != null ) { if ( parent . is CaMeL For ( ) && ! Node CaMeL Util . is CaMeL For CaMeL In ( parent ) ) { if ( parent . get CaMeL First CaMeL Child ( ) . get CaMeL Next ( ) != n ) { record CaMeL Dep CaMeL Scope ( record CaMeL Node , ns ) ; } else { record CaMeL Dep CaMeL Scope ( name CaMeL Node , ns ) ; } } else { record CaMeL Dep CaMeL Scope ( record CaMeL Node , ns ) ; } } }	 
if ( comment . get CaMeL Value ( ) . index CaMeL Of ( $STRING$ ) != - 1 || comment . get CaMeL Value ( ) . index CaMeL Of ( $STRING$ ) != - 1 ) {  <CTX>  private void handle CaMeL Block CaMeL Comment ( Comment comment ) { if ( comment . get CaMeL Value ( ) . index CaMeL Of ( $STRING$ ) != - 1 || comment . get CaMeL Value ( ) . index CaMeL Of ( $STRING$ ) != - 1 ) { error CaMeL Reporter . warning ( SUSP@@ IC@@ IO@@ US _ COMMENT _ WARNING , source CaMeL Name , comment . get CaMeL Lineno ( ) , $STRING$ , 0 ) ; } }	 
Context rhs CaMeL Context = Context . OTHER ;  <CTX>  void add ( Node n , Context context ) { if ( ! cc . continue CaMeL Processing ( ) ) { return ; } int type = n . get CaMeL Type ( ) ; String op@@ str = Node CaMeL Util . op CaMeL To CaMeL Str ( type ) ; int child CaMeL Count = n . get CaMeL Child CaMeL Count ( ) ; Node first = n . get CaMeL First CaMeL Child ( ) ; Node last = n . get CaMeL Last CaMeL Child ( ) ; if ( op@@ str != null && first != last ) { Preconditions . check CaMeL State ( child CaMeL Count == $NUMBER$ , $STRING$ % s \ $STRING$ , op@@ str , child CaMeL Count ) ; int p = Node CaMeL Util . precedence ( type ) ; Context rhs CaMeL Context = get CaMeL Context CaMeL For CaMeL No CaMeL In CaMeL Operator ( context ) ; if ( last . get CaMeL Type ( ) == type && Node CaMeL Util . is CaMeL Associ@@ ative ( type ) ) { add CaMeL Expr ( first , p , context ) ; cc . add CaMeL Op ( op@@ str , true ) ; add CaMeL Expr ( last , p , rhs CaMeL Context ) ; } else if ( Node CaMeL Util . is CaMeL Assignment CaMeL Op ( n ) && Node CaMeL Util . is CaMeL Assignment CaMeL Op ( last ) ) { add CaMeL Expr ( first , p , context ) ; cc . add CaMeL Op ( op@@ str , true ) ; add CaMeL Expr ( last , p , rhs CaMeL Context ) ; } else { unroll CaMeL Binary CaMeL Operator ( n , type , op@@ str , context , rhs CaMeL Context , p , p + 1 ) ; } return ; } cc . start CaMeL Source CaMeL Mapping ( n ) ; switch ( type ) { case Token . TRY : { Preconditions . check CaMeL State ( first . get CaMeL Next ( ) . is CaMeL Block ( ) && ! first . get CaMeL Next ( ) . has CaMeL More CaMeL Than CaMeL One CaMeL Child ( ) ) ; Preconditions . check CaMeL State ( child CaMeL Count >= $NUMBER$ && child CaMeL Count <= $NUMBER$ ) ; add ( $STRING$ ) ; add ( first , Context . PRESERVE _ BLOCK ) ; Node catch@@ block = first . get CaMeL Next ( ) . get CaMeL First CaMeL Child ( ) ; if ( catch@@ block != null ) { add ( catch@@ block ) ; } if ( child CaMeL Count == $NUMBER$ ) { add ( $STRING$ ) ; add ( last , Context . PRESERVE _ BLOCK ) ; } break ; } case Token . CATCH : Preconditions . check CaMeL State ( child CaMeL Count == $NUMBER$ ) ; add ( $STRING$ ) ; add ( first ) ; add ( $STRING$ ) ; add ( last , Context . PRESERVE _ BLOCK ) ; break ; case Token . THROW : Preconditions . check CaMeL State ( child CaMeL Count == 1 ) ; add ( $STRING$ ) ; add ( first ) ; cc . end CaMeL Statement ( true ) ; break ; case Token . RETURN : add ( $STRING$ ) ; if ( child CaMeL Count == 1 ) { add ( first ) ; } else { Preconditions . check CaMeL State ( child CaMeL Count == 0 ) ; } cc . end CaMeL Statement ( ) ; break ; case Token . VAR : if ( first != null ) { add ( $STRING$ ) ; add CaMeL List ( first , false , get CaMeL Context CaMeL For CaMeL No CaMeL In CaMeL Operator ( context ) ) ; } break ; case Token . LABEL _ NAME : Preconditions . check CaMeL State ( ! n . get CaMeL String ( ) . is CaMeL Empty ( ) ) ; add CaMeL Identifier ( n . get CaMeL String ( ) ) ; break ; case Token . NAME : if ( first == null || first . is CaMeL Empty ( ) ) { add CaMeL Identifier ( n . get CaMeL String ( ) ) ; } else { Preconditions . check CaMeL State ( child CaMeL Count == 1 ) ; add CaMeL Identifier ( n . get CaMeL String ( ) ) ; cc . add CaMeL Op ( $STRING$ , true ) ; if ( first . is CaMeL Comma ( ) ) { add CaMeL Expr ( first , Node CaMeL Util . precedence ( Token . ASSIGN ) , Context . OTHER ) ; } else { add CaMeL Expr ( first , 0 , get CaMeL Context CaMeL For CaMeL No CaMeL In CaMeL Operator ( context ) ) ; } } break ; case Token . ARRAY@@ LIT : add ( $STRING$ ) ; add CaMeL Array CaMeL List ( first ) ; add ( $STRING$ ) ; break ; case Token . PARAM _ LIST : add ( $STRING$ ) ; add CaMeL List ( first ) ; add ( $STRING$ ) ; break ; case Token . COMMA : Preconditions . check CaMeL State ( child CaMeL Count == $NUMBER$ ) ; unroll CaMeL Binary CaMeL Operator ( n , Token . COMMA , $STRING$ , context , get CaMeL Context CaMeL For CaMeL No CaMeL In CaMeL Operator ( context ) , 0 , 0 ) ; break ; case Token . NUMBER : Preconditions . check CaMeL State ( child CaMeL Count == 0 ) ; cc . add CaMeL Number ( n . get CaMeL Double ( ) ) ; break ; case Token . TYPEOF : case Token . VOID : case Token . NOT : case Token . BIT@@ NOT : case Token . POS : { Preconditions . check CaMeL State ( child CaMeL Count == 1 ) ; cc . add CaMeL Op ( Node CaMeL Util . op CaMeL To CaMeL Str CaMeL No CaMeL Fail ( type ) , false ) ; add CaMeL Expr ( first , Node CaMeL Util . precedence ( type ) , Context . OTHER ) ; break ; } case Token . NEG : { Preconditions . check CaMeL State ( child CaMeL Count == 1 ) ; if ( n . get CaMeL First CaMeL Child ( ) . is CaMeL Number ( ) ) { cc . add CaMeL Number ( - n . get CaMeL First CaMeL Child ( ) . get CaMeL Double ( ) ) ; } else { cc . add CaMeL Op ( Node CaMeL Util . op CaMeL To CaMeL Str CaMeL No CaMeL Fail ( type ) , false ) ; add CaMeL Expr ( first , Node CaMeL Util . precedence ( type ) , Context . OTHER ) ; } break ; } case Token . HOOK : { Preconditions . check CaMeL State ( child CaMeL Count == $NUMBER$ ) ; int p = Node CaMeL Util . precedence ( type ) ; Context rhs CaMeL Context = Context . OTHER ; add CaMeL Expr ( first , p + 1 , context ) ; cc . add CaMeL Op ( $STRING$ , true ) ; add CaMeL Expr ( first . get CaMeL Next ( ) , 1 , rhs CaMeL Context ) ; cc . add CaMeL Op ( $STRING$ , true ) ; add CaMeL Expr ( last , 1 , rhs CaMeL Context ) ; break ; } case Token . REGEXP : if ( ! first . is CaMeL String ( ) || ! last . is CaMeL String ( ) ) { throw new Error ( $STRING$ ) ; } String regexp = regexp CaMeL Escape ( first . get CaMeL String ( ) , output CaMeL Charset CaMeL Encoder ) ; if ( child CaMeL Count == $NUMBER$ ) { add ( regexp + last . get CaMeL String ( ) ) ; } else { Preconditions . check CaMeL State ( child CaMeL Count == 1 ) ; add ( regexp ) ; } break ; case Token . FUNCTION : if ( n . get CaMeL Class ( ) != Node . class ) { throw new Error ( $STRING$ ) ; } Preconditions . check CaMeL State ( child CaMeL Count == $NUMBER$ ) ; boolean func CaMeL Needs CaMeL Parens = ( context == Context . START _ OF _ EXPR ) ; if ( func CaMeL Needs CaMeL Parens ) { add ( $STRING$ ) ; } add ( $STRING$ ) ; add ( first ) ; add ( first . get CaMeL Next ( ) ) ; add ( last , Context . PRESERVE _ BLOCK ) ; cc . end CaMeL Function ( context == Context . STATEMENT ) ; if ( func CaMeL Needs CaMeL Parens ) { add ( $STRING$ ) ; } break ; case Token . GETTER _ DEF : case Token . SETTER _ DEF : Preconditions . check CaMeL State ( n . get CaMeL Parent ( ) . is CaMeL Object CaMeL Lit ( ) ) ; Preconditions . check CaMeL State ( child CaMeL Count == 1 ) ; Preconditions . check CaMeL State ( first . is CaMeL Function ( ) ) ; Preconditions . check CaMeL State ( first . get CaMeL First CaMeL Child ( ) . get CaMeL String ( ) . is CaMeL Empty ( ) ) ; if ( type == Token . GETTER _ DEF ) { Preconditions . check CaMeL State ( ! first . get CaMeL Child CaMeL At CaMeL Index ( 1 ) . has CaMeL Children ( ) ) ; add ( $STRING$ ) ; } else { Preconditions . check CaMeL State ( first . get CaMeL Child CaMeL At CaMeL Index ( 1 ) . has CaMeL One CaMeL Child ( ) ) ; add ( $STRING$ ) ; } String name = n . get CaMeL String ( ) ; Node fn = first ; Node parameters = fn . get CaMeL Child CaMeL At CaMeL Index ( 1 ) ; Node body = fn . get CaMeL Last CaMeL Child ( ) ; if ( ! n . is CaMeL Quoted CaMeL String ( ) && Token CaMeL Stream . is CaMeL JS CaMeL Identifier ( name ) && Node CaMeL Util . is CaMeL Latin ( name ) ) { add ( name ) ; } else { double d = get CaMeL Simple CaMeL Number ( name ) ; if ( ! Double . is CaMeL Na CaMeL N ( d ) ) { cc . add CaMeL Number ( d ) ; } else { add CaMeL Js CaMeL String ( n ) ; } } add ( parameters ) ; add ( body , Context . PRESERVE _ BLOCK ) ; break ; case Token . SCRIPT : case Token . BLOCK : { if ( n . get CaMeL Class ( ) != Node . class ) { throw new Error ( $STRING$ ) ; } boolean preserve CaMeL Block = context == Context . PRESERVE _ BLOCK ; if ( preserve CaMeL Block ) { cc . begin CaMeL Block ( ) ; } boolean prefer CaMeL Line CaMeL Breaks = type == Token . SCRIPT || ( type == Token . BLOCK && ! preserve CaMeL Block && n . get CaMeL Parent ( ) != null && n . get CaMeL Parent ( ) . is CaMeL Script ( ) ) ; for ( Node c = first ; c != null ; c = c . get CaMeL Next ( ) ) { add ( c , Context . STATEMENT ) ; if ( c . is CaMeL Var ( ) ) { cc . end CaMeL Statement ( ) ; } if ( c . is CaMeL Function ( ) ) { cc . maybe CaMeL Line CaMeL Break ( ) ; } if ( prefer CaMeL Line CaMeL Breaks ) { cc . note CaMeL Preferred CaMeL Line CaMeL Break ( ) ; } } if ( preserve CaMeL Block ) { cc . end CaMeL Block ( cc . break CaMeL After CaMeL Block CaMeL For ( n , context == Context . STATEMENT ) ) ; } break ; } case Token . FOR : if ( child CaMeL Count == $NUMBER$ ) { add ( $STRING$ ) ; if ( first . is CaMeL Var ( ) ) { add ( first , Context . IN _ FOR _ INIT _ CLAUSE ) ; } else { add CaMeL Expr ( first , 0 , Context . IN _ FOR _ INIT _ CLAUSE ) ; } add ( $STRING$ ) ; add ( first . get CaMeL Next ( ) ) ; add ( $STRING$ ) ; add ( first . get CaMeL Next ( ) . get CaMeL Next ( ) ) ; add ( $STRING$ ) ; add CaMeL Non CaMeL Empty CaMeL Statement ( last , get CaMeL Context CaMeL For CaMeL Non CaMeL Empty CaMeL Expression ( context ) , false ) ; } else { Preconditions . check CaMeL State ( child CaMeL Count == $NUMBER$ ) ; add ( $STRING$ ) ; add ( first ) ; add ( $STRING$ ) ; add ( first . get CaMeL Next ( ) ) ; add ( $STRING$ ) ; add CaMeL Non CaMeL Empty CaMeL Statement ( last , get CaMeL Context CaMeL For CaMeL Non CaMeL Empty CaMeL Expression ( context ) , false ) ; } break ; case Token . DO : Preconditions . check CaMeL State ( child CaMeL Count == $NUMBER$ ) ; add ( $STRING$ ) ; add CaMeL Non CaMeL Empty CaMeL Statement ( first , Context . OTHER , false ) ; add ( $STRING$ ) ; add ( last ) ; add ( $STRING$ ) ; cc . end CaMeL Statement ( ) ; break ; case Token . WHILE : Preconditions . check CaMeL State ( child CaMeL Count == $NUMBER$ ) ; add ( $STRING$ ) ; add ( first ) ; add ( $STRING$ ) ; add CaMeL Non CaMeL Empty CaMeL Statement ( last , get CaMeL Context CaMeL For CaMeL Non CaMeL Empty CaMeL Expression ( context ) , false ) ; break ; case Token . EMPTY : Preconditions . check CaMeL State ( child CaMeL Count == 0 ) ; break ; case Token . GETPROP : { Preconditions . check CaMeL State ( child CaMeL Count == $NUMBER$ , $STRING$ , child CaMeL Count ) ; Preconditions . check CaMeL State ( last . is CaMeL String ( ) , $STRING$ ) ; boolean needs CaMeL Parens = ( first . is CaMeL Number ( ) ) ; if ( needs CaMeL Parens ) { add ( $STRING$ ) ; } add CaMeL Expr ( first , Node CaMeL Util . precedence ( type ) , context ) ; if ( needs CaMeL Parens ) { add ( $STRING$ ) ; } if ( this . language CaMeL Mode == Language CaMeL Mode . EC@@ MAS@@ CRIPT $NUMBER$ && Token CaMeL Stream . is CaMeL Keyword ( last . get CaMeL String ( ) ) ) { add ( $STRING$ ) ; add ( last ) ; add ( $STRING$ ) ; } else { add ( $STRING$ ) ; add CaMeL Identifier ( last . get CaMeL String ( ) ) ; } break ; } case Token . GETELEM : Preconditions . check CaMeL State ( child CaMeL Count == $NUMBER$ , $STRING$ , child CaMeL Count ) ; add CaMeL Expr ( first , Node CaMeL Util . precedence ( type ) , context ) ; add ( $STRING$ ) ; add ( first . get CaMeL Next ( ) ) ; add ( $STRING$ ) ; break ; case Token . WITH : Preconditions . check CaMeL State ( child CaMeL Count == $NUMBER$ ) ; add ( $STRING$ ) ; add ( first ) ; add ( $STRING$ ) ; add CaMeL Non CaMeL Empty CaMeL Statement ( last , get CaMeL Context CaMeL For CaMeL Non CaMeL Empty CaMeL Expression ( context ) , false ) ; break ; case Token . INC : case Token . DEC : { Preconditions . check CaMeL State ( child CaMeL Count == 1 ) ; String o = type == Token . INC ? $STRING$ : $STRING$ ; int post CaMeL Prop = n . get CaMeL Int CaMeL Prop ( Node . IN@@ CR@@ DECR _ PROP ) ; if ( post CaMeL Prop != 0 ) { add CaMeL Expr ( first , Node CaMeL Util . precedence ( type ) , context ) ; cc . add CaMeL Op ( o , false ) ; } else { cc . add CaMeL Op ( o , false ) ; add ( first ) ; } break ; } case Token . CALL : if ( is CaMeL Indirect CaMeL Eval ( first ) || n . get CaMeL Boolean CaMeL Prop ( Node . FREE _ CALL ) && Node CaMeL Util . is CaMeL Get ( first ) ) { add ( $STRING$ ) ; add CaMeL Expr ( first , Node CaMeL Util . precedence ( Token . COMMA ) , Context . OTHER ) ; add ( $STRING$ ) ; } else { add CaMeL Expr ( first , Node CaMeL Util . precedence ( type ) , context ) ; } add ( $STRING$ ) ; add CaMeL List ( first . get CaMeL Next ( ) ) ; add ( $STRING$ ) ; break ; case Token . IF : boolean has CaMeL Else = child CaMeL Count == $NUMBER$ ; boolean ambiguous CaMeL Else CaMeL Clause = context == Context . BEFORE _ D@@ ANG@@ LING _ ELSE && ! has CaMeL Else ; if ( ambiguous CaMeL Else CaMeL Clause ) { cc . begin CaMeL Block ( ) ; } add ( $STRING$ ) ; add ( first ) ; add ( $STRING$ ) ; if ( has CaMeL Else ) { add CaMeL Non CaMeL Empty CaMeL Statement ( first . get CaMeL Next ( ) , Context . BEFORE _ D@@ ANG@@ LING _ ELSE , false ) ; add ( $STRING$ ) ; add CaMeL Non CaMeL Empty CaMeL Statement ( last , get CaMeL Context CaMeL For CaMeL Non CaMeL Empty CaMeL Expression ( context ) , false ) ; } else { add CaMeL Non CaMeL Empty CaMeL Statement ( first . get CaMeL Next ( ) , Context . OTHER , false ) ; Preconditions . check CaMeL State ( child CaMeL Count == $NUMBER$ ) ; } if ( ambiguous CaMeL Else CaMeL Clause ) { cc . end CaMeL Block ( ) ; } break ; case Token . NULL : Preconditions . check CaMeL State ( child CaMeL Count == 0 ) ; cc . add CaMeL Constant ( $STRING$ ) ; break ; case Token . THIS : Preconditions . check CaMeL State ( child CaMeL Count == 0 ) ; add ( $STRING$ ) ; break ; case Token . FALSE : Preconditions . check CaMeL State ( child CaMeL Count == 0 ) ; cc . add CaMeL Constant ( $STRING$ ) ; break ; case Token . TRUE : Preconditions . check CaMeL State ( child CaMeL Count == 0 ) ; cc . add CaMeL Constant ( $STRING$ ) ; break ; case Token . CONTINUE : Preconditions . check CaMeL State ( child CaMeL Count <= 1 ) ; add ( $STRING$ ) ; if ( child CaMeL Count == 1 ) { if ( ! first . is CaMeL Label CaMeL Name ( ) ) { throw new Error ( $STRING$ ) ; } add ( $STRING$ ) ; add ( first ) ; } cc . end CaMeL Statement ( ) ; break ; case Token . DEBUGGER : Preconditions . check CaMeL State ( child CaMeL Count == 0 ) ; add ( $STRING$ ) ; cc . end CaMeL Statement ( ) ; break ; case Token . BREAK : Preconditions . check CaMeL State ( child CaMeL Count <= 1 ) ; add ( $STRING$ ) ; if ( child CaMeL Count == 1 ) { if ( ! first . is CaMeL Label CaMeL Name ( ) ) { throw new Error ( $STRING$ ) ; } add ( $STRING$ ) ; add ( first ) ; } cc . end CaMeL Statement ( ) ; break ; case Token . EXPR _ RESULT : Preconditions . check CaMeL State ( child CaMeL Count == 1 ) ; add ( first , Context . START _ OF _ EXPR ) ; cc . end CaMeL Statement ( ) ; break ; case Token . NEW : add ( $STRING$ ) ; int precedence = Node CaMeL Util . precedence ( type ) ; if ( Node CaMeL Util . contains CaMeL Type ( first , Token . CALL , Node CaMeL Util . MATCH _ NOT _ FUNCTION ) ) { precedence = Node CaMeL Util . precedence ( first . get CaMeL Type ( ) ) + 1 ; } add CaMeL Expr ( first , precedence , Context . OTHER ) ; Node next = first . get CaMeL Next ( ) ; if ( next != null ) { add ( $STRING$ ) ; add CaMeL List ( next ) ; add ( $STRING$ ) ; } break ; case Token . STRING _ KEY : Preconditions . check CaMeL State ( child CaMeL Count == 1 , $STRING$ ) ; add CaMeL Js CaMeL String ( n ) ; break ; case Token . STRING : Preconditions . check CaMeL State ( child CaMeL Count == 0 , $STRING$ ) ; add CaMeL Js CaMeL String ( n ) ; break ; case Token . DEL@@ PROP : Preconditions . check CaMeL State ( child CaMeL Count == 1 ) ; add ( $STRING$ ) ; add ( first ) ; break ; case Token . OBJECT@@ LIT : { boolean needs CaMeL Parens = ( context == Context . START _ OF _ EXPR ) ; if ( needs CaMeL Parens ) { add ( $STRING$ ) ; } add ( $STRING$ ) ; for ( Node c = first ; c != null ; c = c . get CaMeL Next ( ) ) { if ( c != first ) { cc . list CaMeL Separator ( ) ; } if ( c . is CaMeL Getter CaMeL Def ( ) || c . is CaMeL Setter CaMeL Def ( ) ) { add ( c ) ; } else { Preconditions . check CaMeL State ( c . is CaMeL String CaMeL Key ( ) ) ; String key = c . get CaMeL String ( ) ; if ( ! c . is CaMeL Quoted CaMeL String ( ) && ! ( language CaMeL Mode == Language CaMeL Mode . EC@@ MAS@@ CRIPT $NUMBER$ && Token CaMeL Stream . is CaMeL Keyword ( key ) ) && Token CaMeL Stream . is CaMeL JS CaMeL Identifier ( key ) && Node CaMeL Util . is CaMeL Latin ( key ) ) { add ( key ) ; } else { double d = get CaMeL Simple CaMeL Number ( key ) ; if ( ! Double . is CaMeL Na CaMeL N ( d ) ) { cc . add CaMeL Number ( d ) ; } else { add CaMeL Expr ( c , 1 , Context . OTHER ) ; } } add ( $STRING$ ) ; add CaMeL Expr ( c . get CaMeL First CaMeL Child ( ) , 1 , Context . OTHER ) ; } } add ( $STRING$ ) ; if ( needs CaMeL Parens ) { add ( $STRING$ ) ; } break ; } case Token . SWITCH : add ( $STRING$ ) ; add ( first ) ; add ( $STRING$ ) ; cc . begin CaMeL Block ( ) ; add CaMeL All CaMeL Siblings ( first . get CaMeL Next ( ) ) ; cc . end CaMeL Block ( context == Context . STATEMENT ) ; break ; case Token . CASE : Preconditions . check CaMeL State ( child CaMeL Count == $NUMBER$ ) ; add ( $STRING$ ) ; add ( first ) ; add CaMeL Case CaMeL Body ( last ) ; break ; case Token . DEFAULT _ CASE : Preconditions . check CaMeL State ( child CaMeL Count == 1 ) ; add ( $STRING$ ) ; add CaMeL Case CaMeL Body ( first ) ; break ; case Token . LABEL : Preconditions . check CaMeL State ( child CaMeL Count == $NUMBER$ ) ; if ( ! first . is CaMeL Label CaMeL Name ( ) ) { throw new Error ( $STRING$ ) ; } add ( first ) ; add ( $STRING$ ) ; add CaMeL Non CaMeL Empty CaMeL Statement ( last , get CaMeL Context CaMeL For CaMeL Non CaMeL Empty CaMeL Expression ( context ) , true ) ; break ; case Token . CAST : add ( $STRING$ ) ; add ( first ) ; add ( $STRING$ ) ; break ; default : throw new Error ( $STRING$ + type + $STRING$ + n . to CaMeL String CaMeL Tree ( ) ) ; } cc . end CaMeL Source CaMeL Mapping ( n ) ; }	 
if ( fn CaMeL Type != null ) {  <CTX>  private void visit CaMeL New ( Node CaMeL Traversal t , Node n ) { Node constructor = n . get CaMeL First CaMeL Child ( ) ; JS CaMeL Type type = get CaMeL JS CaMeL Type ( constructor ) . restrict CaMeL By CaMeL Not CaMeL Null CaMeL Or CaMeL Undefined ( ) ; if ( type . is CaMeL Constructor ( ) || type . is CaMeL Empty CaMeL Type ( ) || type . is CaMeL Unknown CaMeL Type ( ) ) { Function CaMeL Type fn CaMeL Type = type . to CaMeL Maybe CaMeL Function CaMeL Type ( ) ; if ( fn CaMeL Type != null ) { visit CaMeL Parameter CaMeL List ( t , n , fn CaMeL Type ) ; ensure CaMeL Typed ( t , n , fn CaMeL Type . get CaMeL Instance CaMeL Type ( ) ) ; } else { ensure CaMeL Typed ( t , n ) ; } } else { report ( t , n , NOT _ A _ CONSTRUCTOR ) ; ensure CaMeL Typed ( t , n ) ; } }	 
if ( name . global CaMeL Sets == 1 && name . local CaMeL Sets == 0 && &  <CTX>  private void inline CaMeL Aliases ( Global CaMeL Namespace namespace ) { Deque < Name > work CaMeL List = new Array CaMeL Deque < Name > ( namespace . get CaMeL Name CaMeL Forest ( ) ) ; while ( ! work CaMeL List . is CaMeL Empty ( ) ) { Name name = work CaMeL List . pop ( ) ; if ( name . type == Name . Type . GET || name . type == Name . Type . SET ) { continue ; } if ( name . global CaMeL Sets == 1 && name . local CaMeL Sets == 0 && name . aliasing CaMeL Gets > 0 ) { List < Ref > refs = Lists . new CaMeL Array CaMeL List ( name . get CaMeL Refs ( ) ) ; for ( Ref ref : refs ) { if ( ref . type == Type . ALI@@ ASING _ GET && ref . scope . is CaMeL Local ( ) ) { if ( inline CaMeL Alias CaMeL If CaMeL Possible ( ref , namespace ) ) { name . remove CaMeL Ref ( ref ) ; } } } } if ( ( name . type == Name . Type . OBJECT@@ LIT || name . type == Name . Type . FUNCTION ) && name . aliasing CaMeL Gets == 0 && name . props != null ) { work CaMeL List . add CaMeL All ( name . props ) ; } } }	 
! may CaMeL Effect CaMeL Mutable CaMeL State ( lhs ) ) {  <CTX>  private Node try CaMeL Minimize CaMeL If ( Node n ) { Node parent = n . get CaMeL Parent ( ) ; Node cond = n . get CaMeL First CaMeL Child ( ) ; if ( Node CaMeL Util . is CaMeL Literal CaMeL Value ( cond , true ) ) { return n ; } Node then CaMeL Branch = cond . get CaMeL Next ( ) ; Node else CaMeL Branch = then CaMeL Branch . get CaMeL Next ( ) ; if ( else CaMeL Branch == null ) { if ( is CaMeL Fol@@ dable CaMeL Exp@@ ress CaMeL Block ( then CaMeL Branch ) ) { Node expr = get CaMeL Block CaMeL Expression ( then CaMeL Branch ) ; if ( ! late && is CaMeL Property CaMeL Assignment CaMeL In CaMeL Expression ( expr ) ) { return n ; } if ( cond . is CaMeL Not ( ) ) { if ( is CaMeL Lower CaMeL Precedence CaMeL In CaMeL Expression ( cond , OR _ PRECEDENCE ) && is CaMeL Lower CaMeL Precedence CaMeL In CaMeL Expression ( expr . get CaMeL First CaMeL Child ( ) , OR _ PRECEDENCE ) ) { return n ; } Node or = IR . or ( cond . remove CaMeL First CaMeL Child ( ) , expr . remove CaMeL First CaMeL Child ( ) ) . sr@@ cref ( n ) ; Node new CaMeL Expr = Node CaMeL Util . new CaMeL Expr ( or ) ; parent . replace CaMeL Child ( n , new CaMeL Expr ) ; report CaMeL Code CaMeL Change ( ) ; return new CaMeL Expr ; } if ( is CaMeL Lower CaMeL Precedence CaMeL In CaMeL Expression ( cond , AND _ PRECEDENCE ) && is CaMeL Lower CaMeL Precedence CaMeL In CaMeL Expression ( expr . get CaMeL First CaMeL Child ( ) , AND _ PRECEDENCE ) ) { return n ; } n . remove CaMeL Child ( cond ) ; Node and = IR . and ( cond , expr . remove CaMeL First CaMeL Child ( ) ) . sr@@ cref ( n ) ; Node new CaMeL Expr = Node CaMeL Util . new CaMeL Expr ( and ) ; parent . replace CaMeL Child ( n , new CaMeL Expr ) ; report CaMeL Code CaMeL Change ( ) ; return new CaMeL Expr ; } else { if ( Node CaMeL Util . is CaMeL Statement CaMeL Block ( then CaMeL Branch ) && then CaMeL Branch . has CaMeL One CaMeL Child ( ) ) { Node inner CaMeL If = then CaMeL Branch . get CaMeL First CaMeL Child ( ) ; if ( inner CaMeL If . is CaMeL If ( ) ) { Node inner CaMeL Cond = inner CaMeL If . get CaMeL First CaMeL Child ( ) ; Node inner CaMeL Then CaMeL Branch = inner CaMeL Cond . get CaMeL Next ( ) ; Node inner CaMeL Else CaMeL Branch = inner CaMeL Then CaMeL Branch . get CaMeL Next ( ) ; if ( inner CaMeL Else CaMeL Branch == null && ! ( is CaMeL Lower CaMeL Precedence CaMeL In CaMeL Expression ( cond , AND _ PRECEDENCE ) && is CaMeL Lower CaMeL Precedence CaMeL In CaMeL Expression ( inner CaMeL Cond , AND _ PRECEDENCE ) ) ) { n . detach CaMeL Children ( ) ; n . add CaMeL Child CaMeL To CaMeL Back ( IR . and ( cond , inner CaMeL Cond . detach CaMeL From CaMeL Parent ( ) ) . sr@@ cref ( cond ) ) ; n . add CaMeL Children CaMeL To CaMeL Back ( inner CaMeL Then CaMeL Branch . detach CaMeL From CaMeL Parent ( ) ) ; report CaMeL Code CaMeL Change ( ) ; return n ; } } } } return n ; } try CaMeL Remove CaMeL Repeated CaMeL Statements ( n ) ; if ( cond . is CaMeL Not ( ) && ! consumes CaMeL Dangling CaMeL Else ( else CaMeL Branch ) ) { n . replace CaMeL Child ( cond , cond . remove CaMeL First CaMeL Child ( ) ) ; n . remove CaMeL Child ( then CaMeL Branch ) ; n . add CaMeL Child CaMeL To CaMeL Back ( then CaMeL Branch ) ; report CaMeL Code CaMeL Change ( ) ; return n ; } if ( is CaMeL Return CaMeL Exp@@ ress CaMeL Block ( then CaMeL Branch ) && is CaMeL Return CaMeL Exp@@ ress CaMeL Block ( else CaMeL Branch ) ) { Node then CaMeL Expr = get CaMeL Block CaMeL Return CaMeL Expression ( then CaMeL Branch ) ; Node else CaMeL Expr = get CaMeL Block CaMeL Return CaMeL Expression ( else CaMeL Branch ) ; n . remove CaMeL Child ( cond ) ; then CaMeL Expr . detach CaMeL From CaMeL Parent ( ) ; else CaMeL Expr . detach CaMeL From CaMeL Parent ( ) ; Node return CaMeL Node = IR . return CaMeL Node ( IR . hook ( cond , then CaMeL Expr , else CaMeL Expr ) . sr@@ cref ( n ) ) ; parent . replace CaMeL Child ( n , return CaMeL Node ) ; report CaMeL Code CaMeL Change ( ) ; return return CaMeL Node ; } boolean then CaMeL Branch CaMeL Is CaMeL Expression CaMeL Block = is CaMeL Fol@@ dable CaMeL Exp@@ ress CaMeL Block ( then CaMeL Branch ) ; boolean else CaMeL Branch CaMeL Is CaMeL Expression CaMeL Block = is CaMeL Fol@@ dable CaMeL Exp@@ ress CaMeL Block ( else CaMeL Branch ) ; if ( then CaMeL Branch CaMeL Is CaMeL Expression CaMeL Block && else CaMeL Branch CaMeL Is CaMeL Expression CaMeL Block ) { Node then CaMeL Op = get CaMeL Block CaMeL Expression ( then CaMeL Branch ) . get CaMeL First CaMeL Child ( ) ; Node else CaMeL Op = get CaMeL Block CaMeL Expression ( else CaMeL Branch ) . get CaMeL First CaMeL Child ( ) ; if ( then CaMeL Op . get CaMeL Type ( ) == else CaMeL Op . get CaMeL Type ( ) ) { if ( Node CaMeL Util . is CaMeL Assignment CaMeL Op ( then CaMeL Op ) ) { Node lhs = then CaMeL Op . get CaMeL First CaMeL Child ( ) ; if ( are CaMeL Nodes CaMeL Equal CaMeL For CaMeL Inlining ( lhs , else CaMeL Op . get CaMeL First CaMeL Child ( ) ) && ! may CaMeL Effect CaMeL Mutable CaMeL State ( lhs ) ) { n . remove CaMeL Child ( cond ) ; Node assign CaMeL Name = then CaMeL Op . remove CaMeL First CaMeL Child ( ) ; Node then CaMeL Expr = then CaMeL Op . remove CaMeL First CaMeL Child ( ) ; Node else CaMeL Expr = else CaMeL Op . get CaMeL Last CaMeL Child ( ) ; else CaMeL Op . remove CaMeL Child ( else CaMeL Expr ) ; Node hook CaMeL Node = IR . hook ( cond , then CaMeL Expr , else CaMeL Expr ) . sr@@ cref ( n ) ; Node assign = new Node ( then CaMeL Op . get CaMeL Type ( ) , assign CaMeL Name , hook CaMeL Node ) . sr@@ cref ( then CaMeL Op ) ; Node expr = Node CaMeL Util . new CaMeL Expr ( assign ) ; parent . replace CaMeL Child ( n , expr ) ; report CaMeL Code CaMeL Change ( ) ; return expr ; } } } n . remove CaMeL Child ( cond ) ; then CaMeL Op . detach CaMeL From CaMeL Parent ( ) ; else CaMeL Op . detach CaMeL From CaMeL Parent ( ) ; Node expr = IR . expr CaMeL Result ( IR . hook ( cond , then CaMeL Op , else CaMeL Op ) . sr@@ cref ( n ) ) ; parent . replace CaMeL Child ( n , expr ) ; report CaMeL Code CaMeL Change ( ) ; return expr ; } boolean then CaMeL Branch CaMeL Is CaMeL Var = is CaMeL Var CaMeL Block ( then CaMeL Branch ) ; boolean else CaMeL Branch CaMeL Is CaMeL Var = is CaMeL Var CaMeL Block ( else CaMeL Branch ) ; if ( then CaMeL Branch CaMeL Is CaMeL Var && else CaMeL Branch CaMeL Is CaMeL Expression CaMeL Block && get CaMeL Block CaMeL Expression ( else CaMeL Branch ) . get CaMeL First CaMeL Child ( ) . is CaMeL Assign ( ) ) { Node var = get CaMeL Block CaMeL Var ( then CaMeL Branch ) ; Node else CaMeL Assign = get CaMeL Block CaMeL Expression ( else CaMeL Branch ) . get CaMeL First CaMeL Child ( ) ; Node name 1 = var . get CaMeL First CaMeL Child ( ) ; Node maybe CaMeL Name $NUMBER$ = else CaMeL Assign . get CaMeL First CaMeL Child ( ) ; if ( name 1 . has CaMeL Children ( ) && maybe CaMeL Name $NUMBER$ . is CaMeL Name ( ) && name 1 . get CaMeL String ( ) . equals ( maybe CaMeL Name $NUMBER$ . get CaMeL String ( ) ) ) { Node then CaMeL Expr = name 1 . remove CaMeL Children ( ) ; Node else CaMeL Expr = else CaMeL Assign . get CaMeL Last CaMeL Child ( ) . detach CaMeL From CaMeL Parent ( ) ; cond . detach CaMeL From CaMeL Parent ( ) ; Node hook CaMeL Node = IR . hook ( cond , then CaMeL Expr , else CaMeL Expr ) . sr@@ cref ( n ) ; var . detach CaMeL From CaMeL Parent ( ) ; name 1 . add CaMeL Children CaMeL To CaMeL Back ( hook CaMeL Node ) ; parent . replace CaMeL Child ( n , var ) ; report CaMeL Code CaMeL Change ( ) ; return var ; } } else if ( else CaMeL Branch CaMeL Is CaMeL Var && then CaMeL Branch CaMeL Is CaMeL Expression CaMeL Block && get CaMeL Block CaMeL Expression ( then CaMeL Branch ) . get CaMeL First CaMeL Child ( ) . is CaMeL Assign ( ) ) { Node var = get CaMeL Block CaMeL Var ( else CaMeL Branch ) ; Node then CaMeL Assign = get CaMeL Block CaMeL Expression ( then CaMeL Branch ) . get CaMeL First CaMeL Child ( ) ; Node maybe CaMeL Name 1 = then CaMeL Assign . get CaMeL First CaMeL Child ( ) ; Node name $NUMBER$ = var . get CaMeL First CaMeL Child ( ) ; if ( name $NUMBER$ . has CaMeL Children ( ) && maybe CaMeL Name 1 . is CaMeL Name ( ) && maybe CaMeL Name 1 . get CaMeL String ( ) . equals ( name $NUMBER$ . get CaMeL String ( ) ) ) { Node then CaMeL Expr = then CaMeL Assign . get CaMeL Last CaMeL Child ( ) . detach CaMeL From CaMeL Parent ( ) ; Node else CaMeL Expr = name $NUMBER$ . remove CaMeL Children ( ) ; cond . detach CaMeL From CaMeL Parent ( ) ; Node hook CaMeL Node = IR . hook ( cond , then CaMeL Expr , else CaMeL Expr ) . sr@@ cref ( n ) ; var . detach CaMeL From CaMeL Parent ( ) ; name $NUMBER$ . add CaMeL Children CaMeL To CaMeL Back ( hook CaMeL Node ) ; parent . replace CaMeL Child ( n , var ) ; report CaMeL Code CaMeL Change ( ) ; return var ; } } return n ; }	 
pos += Character . char CaMeL Count ( Character . code CaMeL Point CaMeL At ( input , pos ) ) ;  <CTX>  public final void translate ( Char CaMeL Sequence input , Writer out ) throws IO CaMeL Exception { if ( out == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( input == null ) { return ; } int pos = 0 ; int len = input . length ( ) ; while ( pos < len ) { int consumed = translate ( input , pos , out ) ; if ( consumed == 0 ) { char [ ] c = Character . to CaMeL Chars ( Character . code CaMeL Point CaMeL At ( input , pos ) ) ; out . write ( c ) ; pos += c . length ; continue ; } for ( int pt = 0 ; pt < consumed ; pt ++ ) { pos += Character . char CaMeL Count ( Character . code CaMeL Point CaMeL At ( input , pos ) ) ; } } }	 
if ( str . starts CaMeL With ( $STRING$ ) || str . starts CaMeL With ( $STRING$ ) ) {  <CTX>  public static Number create CaMeL Number ( String str ) throws Number CaMeL Format CaMeL Exception { if ( str == null ) { return null ; } if ( String CaMeL Utils . is CaMeL Blank ( str ) ) { throw new Number CaMeL Format CaMeL Exception ( $STRING$ ) ; } if ( str . starts CaMeL With ( $STRING$ ) ) { return null ; } if ( str . starts CaMeL With ( $STRING$ ) || str . starts CaMeL With ( $STRING$ ) ) { return create CaMeL Integer ( str ) ; } char last CaMeL Char = str . char CaMeL At ( str . length ( ) - 1 ) ; String mant ; String dec ; String exp ; int dec CaMeL Pos = str . index CaMeL Of ( $STRING$ ) ; int exp CaMeL Pos = str . index CaMeL Of ( $STRING$ ) + str . index CaMeL Of ( $STRING$ ) + 1 ; if ( dec CaMeL Pos > - 1 ) { if ( exp CaMeL Pos > - 1 ) { if ( exp CaMeL Pos < dec CaMeL Pos || exp CaMeL Pos > str . length ( ) ) { throw new Number CaMeL Format CaMeL Exception ( str + $STRING$ ) ; } dec = str . substring ( dec CaMeL Pos + 1 , exp CaMeL Pos ) ; } else { dec = str . substring ( dec CaMeL Pos + 1 ) ; } mant = str . substring ( 0 , dec CaMeL Pos ) ; } else { if ( exp CaMeL Pos > - 1 ) { if ( exp CaMeL Pos > str . length ( ) ) { throw new Number CaMeL Format CaMeL Exception ( str + $STRING$ ) ; } mant = str . substring ( 0 , exp CaMeL Pos ) ; } else { mant = str ; } dec = null ; } if ( ! Character . is CaMeL Digit ( last CaMeL Char ) && last CaMeL Char != $STRING$ ) { if ( exp CaMeL Pos > - 1 && exp CaMeL Pos < str . length ( ) - 1 ) { exp = str . substring ( exp CaMeL Pos + 1 , str . length ( ) - 1 ) ; } else { exp = null ; } String numeric = str . substring ( 0 , str . length ( ) - 1 ) ; boolean all CaMeL Zeros = is CaMeL All CaMeL Zeros ( mant ) && is CaMeL All CaMeL Zeros ( exp ) ; switch ( last CaMeL Char ) { case $STRING$ : case $STRING$ : if ( dec == null && exp == null && ( numeric . char CaMeL At ( 0 ) == $STRING$ && is CaMeL Digits ( numeric . substring ( 1 ) ) || is CaMeL Digits ( numeric ) ) ) { try { return create CaMeL Long ( numeric ) ; } catch ( Number CaMeL Format CaMeL Exception nfe ) { } return create CaMeL Big CaMeL Integer ( numeric ) ; } throw new Number CaMeL Format CaMeL Exception ( str + $STRING$ ) ; case $STRING$ : case $STRING$ : try { Float f = Number CaMeL Utils . create CaMeL Float ( numeric ) ; if ( ! ( f . is CaMeL Infinite ( ) || ( f . float CaMeL Value ( ) == 0 . 0 F && ! all CaMeL Zeros ) ) ) { return f ; } } catch ( Number CaMeL Format CaMeL Exception nfe ) { } case $STRING$ : case $STRING$ : try { Double d = Number CaMeL Utils . create CaMeL Double ( numeric ) ; if ( ! ( d . is CaMeL Infinite ( ) || ( d . float CaMeL Value ( ) == 0 . 0 D && ! all CaMeL Zeros ) ) ) { return d ; } } catch ( Number CaMeL Format CaMeL Exception nfe ) { } try { return create CaMeL Big CaMeL Decimal ( numeric ) ; } catch ( Number CaMeL Format CaMeL Exception e ) { } default : throw new Number CaMeL Format CaMeL Exception ( str + $STRING$ ) ; } } else { if ( exp CaMeL Pos > - 1 && exp CaMeL Pos < str . length ( ) - 1 ) { exp = str . substring ( exp CaMeL Pos + 1 , str . length ( ) ) ; } else { exp = null ; } if ( dec == null && exp == null ) { try { return create CaMeL Integer ( str ) ; } catch ( Number CaMeL Format CaMeL Exception nfe ) { } try { return create CaMeL Long ( str ) ; } catch ( Number CaMeL Format CaMeL Exception nfe ) { } return create CaMeL Big CaMeL Integer ( str ) ; } else { boolean all CaMeL Zeros = is CaMeL All CaMeL Zeros ( mant ) && is CaMeL All CaMeL Zeros ( exp ) ; try { Float f = create CaMeL Float ( str ) ; if ( ! ( f . is CaMeL Infinite ( ) || ( f . float CaMeL Value ( ) == 0 . 0 F && ! all CaMeL Zeros ) ) ) { return f ; } } catch ( Number CaMeL Format CaMeL Exception nfe ) { } try { Double d = create CaMeL Double ( str ) ; if ( ! ( d . is CaMeL Infinite ( ) || ( d . double CaMeL Value ( ) == 0 . 0 D && ! all CaMeL Zeros ) ) ) { return d ; } } catch ( Number CaMeL Format CaMeL Exception nfe ) { } return create CaMeL Big CaMeL Decimal ( str ) ; } } }	 
cal 1 . get ( Calendar . HOUR ) == cal $NUMBER$ . get ( Calendar . HOUR ) && &  <CTX>  public static boolean is CaMeL Same CaMeL Local CaMeL Time ( Calendar cal 1 , Calendar cal $NUMBER$ ) { if ( cal 1 == null || cal $NUMBER$ == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } return ( cal 1 . get ( Calendar . MILLISECOND ) == cal $NUMBER$ . get ( Calendar . MILLISECOND ) && cal 1 . get ( Calendar . SECOND ) == cal $NUMBER$ . get ( Calendar . SECOND ) && cal 1 . get ( Calendar . MINUTE ) == cal $NUMBER$ . get ( Calendar . MINUTE ) && cal 1 . get ( Calendar . HOUR ) == cal $NUMBER$ . get ( Calendar . HOUR ) && cal 1 . get ( Calendar . DAY _ OF _ YEAR ) == cal $NUMBER$ . get ( Calendar . DAY _ OF _ YEAR ) && cal 1 . get ( Calendar . YEAR ) == cal $NUMBER$ . get ( Calendar . YEAR ) && cal 1 . get ( Calendar . ERA ) == cal $NUMBER$ . get ( Calendar . ERA ) && cal 1 . get CaMeL Class ( ) == cal $NUMBER$ . get CaMeL Class ( ) ) ; }	 
return found CaMeL Digit && ! has CaMeL Exp ;  <CTX>  public static boolean is CaMeL Number ( String str ) { if ( String CaMeL Utils . is CaMeL Empty ( str ) ) { return false ; } char [ ] chars = str . to CaMeL Char CaMeL Array ( ) ; int sz = chars . length ; boolean has CaMeL Exp = false ; boolean has CaMeL Dec CaMeL Point = false ; boolean allow CaMeL Signs = false ; boolean found CaMeL Digit = false ; int start = ( chars [ 0 ] == $STRING$ ) ? 1 : 0 ; if ( sz > start + 1 ) { if ( chars [ start ] == $STRING$ && chars [ start + 1 ] == $STRING$ ) { int i = start + $NUMBER$ ; if ( i == sz ) { return false ; } for ( ; i < chars . length ; i ++ ) { if ( ( chars [ i ] < $STRING$ || chars [ i ] > $STRING$ ) && ( chars [ i ] < $STRING$ || chars [ i ] > $STRING$ ) && ( chars [ i ] < $STRING$ || chars [ i ] > $STRING$ ) ) { return false ; } } return true ; } } sz -- ; int i = start ; while ( i < sz || ( i < sz + 1 && allow CaMeL Signs && ! found CaMeL Digit ) ) { if ( chars [ i ] >= $STRING$ && chars [ i ] <= $STRING$ ) { found CaMeL Digit = true ; allow CaMeL Signs = false ; } else if ( chars [ i ] == $STRING$ ) { if ( has CaMeL Dec CaMeL Point || has CaMeL Exp ) { return false ; } has CaMeL Dec CaMeL Point = true ; } else if ( chars [ i ] == $STRING$ || chars [ i ] == $STRING$ ) { if ( has CaMeL Exp ) { return false ; } if ( ! found CaMeL Digit ) { return false ; } has CaMeL Exp = true ; allow CaMeL Signs = true ; } else if ( chars [ i ] == $STRING$ || chars [ i ] == $STRING$ ) { if ( ! allow CaMeL Signs ) { return false ; } allow CaMeL Signs = false ; found CaMeL Digit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { if ( chars [ i ] >= $STRING$ && chars [ i ] <= $STRING$ ) { return true ; } if ( chars [ i ] == $STRING$ || chars [ i ] == $STRING$ ) { return false ; } if ( chars [ i ] == $STRING$ ) { if ( has CaMeL Dec CaMeL Point || has CaMeL Exp ) { return false ; } return found CaMeL Digit ; } if ( ! allow CaMeL Signs && ( chars [ i ] == $STRING$ || chars [ i ] == $STRING$ || chars [ i ] == $STRING$ || chars [ i ] == $STRING$ ) ) { return found CaMeL Digit ; } if ( chars [ i ] == $STRING$ || chars [ i ] == $STRING$ ) { return found CaMeL Digit && ! has CaMeL Exp ; } return false ; } return ! allow CaMeL Signs && found CaMeL Digit ; }	 
Calendar c = new Gregorian CaMeL Calendar ( m CaMeL Time CaMeL Zone ) ;  <CTX>  public String format ( Date date ) { Calendar c = new Gregorian CaMeL Calendar ( m CaMeL Time CaMeL Zone ) ; c . set CaMeL Time ( date ) ; return apply CaMeL Rules ( c , new String CaMeL Buffer ( m CaMeL Max CaMeL Length CaMeL Estimate ) ) . to CaMeL String ( ) ; }	 
static float to CaMeL Java CaMeL Version CaMeL Int ( String version ) {  <CTX>  static float to CaMeL Java CaMeL Version CaMeL Int ( String version ) { return to CaMeL Version CaMeL Int ( to CaMeL Java CaMeL Version CaMeL Int CaMeL Array ( version , JAVA _ VERSION _ TRIM _ SIZE ) ) ; }	 
classes [ i ] = array [ i ] . get CaMeL Class ( ) ;  <CTX>  public static Class < ? > [ ] to CaMeL Class ( Object [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return Array CaMeL Utils . EMPTY _ CLASS _ ARRAY ; } Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i ++ ) { classes [ i ] = array [ i ] . get CaMeL Class ( ) ; } return classes ; }	 
return contains ( str . to CaMeL Upper CaMeL Case ( ) , search CaMeL Str . to CaMeL Upper CaMeL Case ( ) ) ;  <CTX>  public static boolean contains CaMeL Ignore CaMeL Case ( String str , String search CaMeL Str ) { if ( str == null || search CaMeL Str == null ) { return false ; } return contains ( str . to CaMeL Upper CaMeL Case ( ) , search CaMeL Str . to CaMeL Upper CaMeL Case ( ) ) ; }	 
return c CaMeL Available CaMeL Locale CaMeL Set . contains ( locale ) ;  <CTX>  public static boolean is CaMeL Available CaMeL Locale ( Locale locale ) { return c CaMeL Available CaMeL Locale CaMeL Set . contains ( locale ) ; }	 
&& is CaMeL Digits ( numeric . substring ( 1 ) ) && ( numeric . char CaMeL At ( 0 ) == $STRING$ || Character . is CaMeL Digit ( numeric . char CaMeL At ( 0 ) ) ) ) {  <CTX>  public static Number create CaMeL Number ( String str ) throws Number CaMeL Format CaMeL Exception { if ( str == null ) { return null ; } if ( String CaMeL Utils . is CaMeL Blank ( str ) ) { throw new Number CaMeL Format CaMeL Exception ( $STRING$ ) ; } if ( str . starts CaMeL With ( $STRING$ ) ) { return null ; } if ( str . starts CaMeL With ( $STRING$ ) || str . starts CaMeL With ( $STRING$ ) ) { return create CaMeL Integer ( str ) ; } char last CaMeL Char = str . char CaMeL At ( str . length ( ) - 1 ) ; String mant ; String dec ; String exp ; int dec CaMeL Pos = str . index CaMeL Of ( $STRING$ ) ; int exp CaMeL Pos = str . index CaMeL Of ( $STRING$ ) + str . index CaMeL Of ( $STRING$ ) + 1 ; if ( dec CaMeL Pos > - 1 ) { if ( exp CaMeL Pos > - 1 ) { if ( exp CaMeL Pos < dec CaMeL Pos ) { throw new Number CaMeL Format CaMeL Exception ( str + $STRING$ ) ; } dec = str . substring ( dec CaMeL Pos + 1 , exp CaMeL Pos ) ; } else { dec = str . substring ( dec CaMeL Pos + 1 ) ; } mant = str . substring ( 0 , dec CaMeL Pos ) ; } else { if ( exp CaMeL Pos > - 1 ) { mant = str . substring ( 0 , exp CaMeL Pos ) ; } else { mant = str ; } dec = null ; } if ( ! Character . is CaMeL Digit ( last CaMeL Char ) ) { if ( exp CaMeL Pos > - 1 && exp CaMeL Pos < str . length ( ) - 1 ) { exp = str . substring ( exp CaMeL Pos + 1 , str . length ( ) - 1 ) ; } else { exp = null ; } String numeric = str . substring ( 0 , str . length ( ) - 1 ) ; boolean all CaMeL Zeros = is CaMeL All CaMeL Zeros ( mant ) && is CaMeL All CaMeL Zeros ( exp ) ; switch ( last CaMeL Char ) { case $STRING$ : case $STRING$ : if ( dec == null && exp == null && is CaMeL Digits ( numeric . substring ( 1 ) ) && ( numeric . char CaMeL At ( 0 ) == $STRING$ || Character . is CaMeL Digit ( numeric . char CaMeL At ( 0 ) ) ) ) { try { return create CaMeL Long ( numeric ) ; } catch ( Number CaMeL Format CaMeL Exception nfe ) { } return create CaMeL Big CaMeL Integer ( numeric ) ; } throw new Number CaMeL Format CaMeL Exception ( str + $STRING$ ) ; case $STRING$ : case $STRING$ : try { Float f = Number CaMeL Utils . create CaMeL Float ( numeric ) ; if ( ! ( f . is CaMeL Infinite ( ) || ( f . float CaMeL Value ( ) == 0 . 0 F && ! all CaMeL Zeros ) ) ) { return f ; } } catch ( Number CaMeL Format CaMeL Exception nfe ) { } case $STRING$ : case $STRING$ : try { Double d = Number CaMeL Utils . create CaMeL Double ( numeric ) ; if ( ! ( d . is CaMeL Infinite ( ) || ( d . float CaMeL Value ( ) == 0 . 0 D && ! all CaMeL Zeros ) ) ) { return d ; } } catch ( Number CaMeL Format CaMeL Exception nfe ) { } try { return create CaMeL Big CaMeL Decimal ( numeric ) ; } catch ( Number CaMeL Format CaMeL Exception e ) { } default : throw new Number CaMeL Format CaMeL Exception ( str + $STRING$ ) ; } } else { if ( exp CaMeL Pos > - 1 && exp CaMeL Pos < str . length ( ) - 1 ) { exp = str . substring ( exp CaMeL Pos + 1 , str . length ( ) ) ; } else { exp = null ; } if ( dec == null && exp == null ) { try { return create CaMeL Integer ( str ) ; } catch ( Number CaMeL Format CaMeL Exception nfe ) { } try { return create CaMeL Long ( str ) ; } catch ( Number CaMeL Format CaMeL Exception nfe ) { } return create CaMeL Big CaMeL Integer ( str ) ; } else { boolean all CaMeL Zeros = is CaMeL All CaMeL Zeros ( mant ) && is CaMeL All CaMeL Zeros ( exp ) ; try { Float f = create CaMeL Float ( str ) ; if ( ! ( f . is CaMeL Infinite ( ) || ( f . float CaMeL Value ( ) == 0 . 0 F && ! all CaMeL Zeros ) ) ) { return f ; } } catch ( Number CaMeL Format CaMeL Exception nfe ) { } try { Double d = create CaMeL Double ( str ) ; if ( ! ( d . is CaMeL Infinite ( ) || ( d . double CaMeL Value ( ) == 0 . 0 D && ! all CaMeL Zeros ) ) ) { return d ; } } catch ( Number CaMeL Format CaMeL Exception nfe ) { } return create CaMeL Big CaMeL Decimal ( str ) ; } } }	 
str . get CaMeL Chars ( 0 , str CaMeL Len , buffer , size ) ;  <CTX>  public Str CaMeL Builder append CaMeL Fixed CaMeL Width CaMeL Pad CaMeL Right ( Object obj , int width , char pad CaMeL Char ) { if ( width > 0 ) { ensure CaMeL Capacity ( size + width ) ; String str = ( obj == null ? get CaMeL Null CaMeL Text ( ) : obj . to CaMeL String ( ) ) ; int str CaMeL Len = str . length ( ) ; if ( str CaMeL Len >= width ) { str . get CaMeL Chars ( 0 , str CaMeL Len , buffer , size ) ; } else { int pad CaMeL Len = width - str CaMeL Len ; str . get CaMeL Chars ( 0 , str CaMeL Len , buffer , size ) ; for ( int i = 0 ; i < pad CaMeL Len ; i ++ ) { buffer [ size + str CaMeL Len + i ] = pad CaMeL Char ; } } size += width ; } return this ; }	 
int len = this CaMeL Buf . length - str CaMeL Len ;  <CTX>  public int index CaMeL Of ( String str , int start CaMeL Index ) { start CaMeL Index = ( start CaMeL Index < 0 ? 0 : start CaMeL Index ) ; if ( str == null || start CaMeL Index >= size ) { return - 1 ; } int str CaMeL Len = str . length ( ) ; if ( str CaMeL Len == 1 ) { return index CaMeL Of ( str . char CaMeL At ( 0 ) , start CaMeL Index ) ; } if ( str CaMeL Len == 0 ) { return start CaMeL Index ; } if ( str CaMeL Len > size ) { return - 1 ; } char [ ] this CaMeL Buf = buffer ; int len = this CaMeL Buf . length - str CaMeL Len ; outer : for ( int i = start CaMeL Index ; i < len ; i ++ ) { for ( int j = 0 ; j < str CaMeL Len ; j ++ ) { if ( str . char CaMeL At ( j ) != this CaMeL Buf [ i + j ] ) { continue outer ; } } return i ; } return - 1 ; }	 
return ( double ) ( get CaMeL Sample CaMeL Size ( ) * get CaMeL Number CaMeL Of CaMeL Successes ( ) ) / ( double ) get CaMeL Population CaMeL Size ( ) ;  <CTX>  public double get CaMeL Numerical CaMeL Mean ( ) { return ( double ) ( get CaMeL Sample CaMeL Size ( ) * get CaMeL Number CaMeL Of CaMeL Successes ( ) ) / ( double ) get CaMeL Population CaMeL Size ( ) ; }	 
return Na CaMeL N ;  <CTX>  public Complex reciprocal ( ) { if ( is CaMeL Na CaMeL N ) { return Na CaMeL N ; } if ( real == 0 . 0 && imaginary == 0 . 0 ) { return Na CaMeL N ; } if ( is CaMeL Infinite ) { return ZERO ; } if ( Fast CaMeL Math . abs ( real ) < Fast CaMeL Math . abs ( imaginary ) ) { double q = real / imaginary ; double scale = 1 . / ( real * q + imaginary ) ; return create CaMeL Complex ( scale * q , - scale ) ; } else { double q = imaginary / real ; double scale = 1 . / ( imaginary * q + real ) ; return create CaMeL Complex ( scale , - scale * q ) ; } }	 
final Line reverted = new Line ( zero , zero . subtract ( direction ) ) ;  <CTX>  public Line revert ( ) { final Line reverted = new Line ( zero , zero . subtract ( direction ) ) ; return reverted ; }	 
return Fast CaMeL Math . pow ( $NUMBER$ * Fast CaMeL Math . PI , - dim / $NUMBER$ ) *  <CTX>  public double density ( final double [ ] vals ) throws Dimension CaMeL Mismatch CaMeL Exception { final int dim = get CaMeL Dimension ( ) ; if ( vals . length != dim ) { throw new Dimension CaMeL Mismatch CaMeL Exception ( vals . length , dim ) ; } return Fast CaMeL Math . pow ( $NUMBER$ * Fast CaMeL Math . PI , - dim / $NUMBER$ ) * Fast CaMeL Math . pow ( covariance CaMeL Matrix CaMeL Determinant , - 0 . $NUMBER$ ) * get CaMeL Exponent CaMeL Term ( vals ) ; }	 
return  <CTX>  public double [ ] repair CaMeL And CaMeL Decode ( final double [ ] x ) { return decode ( x ) ; }	 
return multiply ( $NUMBER$ ) . double CaMeL Value ( ) ;  <CTX>  public double percentage CaMeL Value ( ) { return multiply ( $NUMBER$ ) . double CaMeL Value ( ) ; }	 
final int n 1 n $NUMBER$ prod = n 1 * n $NUMBER$ ;  <CTX>  private double calculate CaMeL A@@ sy@@ mp@@ to@@ tic CaMeL P CaMeL Value ( final double U@@ min , final int n 1 , final int n $NUMBER$ ) throws Convergence CaMeL Exception , Max CaMeL Count CaMeL Exceeded CaMeL Exception { final int n 1 n $NUMBER$ prod = n 1 * n $NUMBER$ ; final double EU = n 1 n $NUMBER$ prod / $NUMBER$ . 0 ; final double Var CaMeL U = n 1 n $NUMBER$ prod * ( n 1 + n $NUMBER$ + 1 ) / $NUMBER$ . 0 ; final double z = ( U@@ min - EU ) / Fast CaMeL Math . sqrt ( Var CaMeL U ) ; final Normal CaMeL Distribution standard CaMeL Normal = new Normal CaMeL Distribution ( 0 , 1 ) ; return $NUMBER$ * standard CaMeL Normal . cumulative CaMeL Probability ( z ) ; }	 
if ( ( Boolean ) tree . get CaMeL Attribute ( ) ) {  <CTX>  protected void compute CaMeL Ge@@ ome@@ trical CaMeL Properties ( ) { final Vector $NUMBER$ D [ ] [ ] v = get CaMeL Vertices ( ) ; if ( v . length == 0 ) { final BSP CaMeL Tree < Euclidean $NUMBER$ D > tree = get CaMeL Tree ( false ) ; if ( ( Boolean ) tree . get CaMeL Attribute ( ) ) { set CaMeL Size ( Double . POSITIVE _ INFINITY ) ; set CaMeL Barycenter ( Vector $NUMBER$ D . Na CaMeL N ) ; } else { set CaMeL Size ( 0 ) ; set CaMeL Barycenter ( new Vector $NUMBER$ D ( 0 , 0 ) ) ; } } else if ( v [ 0 ] [ 0 ] == null ) { set CaMeL Size ( Double . POSITIVE _ INFINITY ) ; set CaMeL Barycenter ( Vector $NUMBER$ D . Na CaMeL N ) ; } else { double sum = 0 ; double sum CaMeL X = 0 ; double sum CaMeL Y = 0 ; for ( Vector $NUMBER$ D [ ] loop : v ) { double x 1 = loop [ loop . length - 1 ] . get CaMeL X ( ) ; double y 1 = loop [ loop . length - 1 ] . get CaMeL Y ( ) ; for ( final Vector $NUMBER$ D point : loop ) { final double x 0 = x 1 ; final double y 0 = y 1 ; x 1 = point . get CaMeL X ( ) ; y 1 = point . get CaMeL Y ( ) ; final double factor = x 0 * y 1 - y 0 * x 1 ; sum += factor ; sum CaMeL X += factor * ( x 0 + x 1 ) ; sum CaMeL Y += factor * ( y 0 + y 1 ) ; } } if ( sum < 0 ) { set CaMeL Size ( Double . POSITIVE _ INFINITY ) ; set CaMeL Barycenter ( Vector $NUMBER$ D . Na CaMeL N ) ; } else { set CaMeL Size ( sum / $NUMBER$ ) ; set CaMeL Barycenter ( new Vector $NUMBER$ D ( sum CaMeL X / ( $NUMBER$ * sum ) , sum CaMeL Y / ( $NUMBER$ * sum ) ) ) ; } } }	 
if ( Precision . compare CaMeL To ( entry , 0 d , max CaMeL Ul@@ ps ) > 0 ) {  <CTX>  protected void drop CaMeL Phase 1 Objective ( ) { if ( get CaMeL Num CaMeL Objective CaMeL Functions ( ) == 1 ) { return ; } List < Integer > columns CaMeL To CaMeL Drop = new Array CaMeL List < Integer > ( ) ; columns CaMeL To CaMeL Drop . add ( 0 ) ; for ( int i = get CaMeL Num CaMeL Objective CaMeL Functions ( ) ; i < get CaMeL Artificial CaMeL Variable CaMeL Offset ( ) ; i ++ ) { final double entry = tableau . get CaMeL Entry ( 0 , i ) ; if ( Precision . compare CaMeL To ( entry , 0 d , max CaMeL Ul@@ ps ) > 0 ) { columns CaMeL To CaMeL Drop . add ( i ) ; } } for ( int i = 0 ; i < get CaMeL Num CaMeL Artificial CaMeL Variables ( ) ; i ++ ) { int col = i + get CaMeL Artificial CaMeL Variable CaMeL Offset ( ) ; if ( get CaMeL Basic CaMeL Row ( col ) == null ) { columns CaMeL To CaMeL Drop . add ( col ) ; } } double [ ] [ ] matrix = new double [ get CaMeL Height ( ) - 1 ] [ get CaMeL Width ( ) - columns CaMeL To CaMeL Drop . size ( ) ] ; for ( int i = 1 ; i < get CaMeL Height ( ) ; i ++ ) { int col = 0 ; for ( int j = 0 ; j < get CaMeL Width ( ) ; j ++ ) { if ( ! columns CaMeL To CaMeL Drop . contains ( j ) ) { matrix [ i - 1 ] [ col ++ ] = tableau . get CaMeL Entry ( i , j ) ; } } } for ( int i = columns CaMeL To CaMeL Drop . size ( ) - 1 ; i >= 0 ; i -- ) { column CaMeL Labels . remove ( ( int ) columns CaMeL To CaMeL Drop . get ( i ) ) ; } this . tableau = new Array $NUMBER$ D CaMeL Row CaMeL Real CaMeL Matrix ( matrix ) ; this . num CaMeL Artificial CaMeL Variables = 0 ; }	 
return chromosomes . iterator ( ) ;  <CTX>  public Iterator < Chromosome > iterator ( ) { return chromosomes . iterator ( ) ; }	 
for ( int i = 0 ; i < weights . length ; i ++ ) {  <CTX>  public double evaluate ( final double [ ] values , final double [ ] weights , final double mean , final int begin , final int length ) { double var = Double . Na CaMeL N ; if ( test ( values , weights , begin , length ) ) { if ( length == 1 ) { var = 0 . 0 ; } else if ( length > 1 ) { double accum = 0 . 0 ; double dev = 0 . 0 ; double accum $NUMBER$ = 0 . 0 ; for ( int i = begin ; i < begin + length ; i ++ ) { dev = values [ i ] - mean ; accum += weights [ i ] * ( dev * dev ) ; accum $NUMBER$ += weights [ i ] * dev ; } double sum CaMeL Wts = 0 ; for ( int i = 0 ; i < weights . length ; i ++ ) { sum CaMeL Wts += weights [ i ] ; } if ( is CaMeL Bias CaMeL Corrected ) { var = ( accum - ( accum $NUMBER$ * accum $NUMBER$ / sum CaMeL Wts ) ) / ( sum CaMeL Wts - 1 . 0 ) ; } else { var = ( accum - ( accum $NUMBER$ * accum $NUMBER$ / sum CaMeL Wts ) ) / sum CaMeL Wts ; } } } return var ; }	 
int idx = 1 ; while ( count < index ) { count += idx ; ++ idx ; } -- idx ; indices [ last ] = idx ;  <CTX>  public int [ ] get CaMeL Counts ( int index ) { if ( index < 0 || index >= total CaMeL Size ) { throw new Out CaMeL Of CaMeL Range CaMeL Exception ( index , 0 , total CaMeL Size ) ; } final int [ ] indices = new int [ dimension ] ; int count = 0 ; for ( int i = 0 ; i < last ; i ++ ) { int idx = 0 ; final int offset = uni CaMeL Counter CaMeL Offset [ i ] ; while ( count <= index ) { count += offset ; ++ idx ; } -- idx ; count -= offset ; indices [ i ] = idx ; } int idx = 1 ; while ( count < index ) { count += idx ; ++ idx ; } -- idx ; indices [ last ] = idx ; return indices ; }	 
int sum = 0 ;  <CTX>  private static < T extends Clusterable < T >> List < Cluster < T >> choose CaMeL Initial CaMeL Centers ( final Collection < T > points , final int k , final Random random ) { final List < T > point CaMeL Set = new Array CaMeL List < T > ( points ) ; final List < Cluster < T >> result CaMeL Set = new Array CaMeL List < Cluster < T >> ( ) ; final T first CaMeL Point = point CaMeL Set . remove ( random . next CaMeL Int ( point CaMeL Set . size ( ) ) ) ; result CaMeL Set . add ( new Cluster < T > ( first CaMeL Point ) ) ; final double [ ] dx $NUMBER$ = new double [ point CaMeL Set . size ( ) ] ; while ( result CaMeL Set . size ( ) < k ) { int sum = 0 ; for ( int i = 0 ; i < point CaMeL Set . size ( ) ; i ++ ) { final T p = point CaMeL Set . get ( i ) ; final Cluster < T > nearest = get CaMeL Nearest CaMeL Cluster ( result CaMeL Set , p ) ; final double d = p . distance CaMeL From ( nearest . get CaMeL Center ( ) ) ; sum += d * d ; dx $NUMBER$ [ i ] = sum ; } final double r = random . next CaMeL Double ( ) * sum ; for ( int i = 0 ; i < dx $NUMBER$ . length ; i ++ ) { if ( dx $NUMBER$ [ i ] >= r ) { final T p = point CaMeL Set . remove ( i ) ; result CaMeL Set . add ( new Cluster < T > ( p ) ) ; break ; } } } return result CaMeL Set ; }	 
return fit ( new Gaussian . Parametric ( ) , guess ) ;  <CTX>  public double [ ] fit ( ) { final double [ ] guess = ( new Parameter CaMeL Guesser ( get CaMeL Observ@@ ations ( ) ) ) . guess ( ) ; return fit ( new Gaussian . Parametric ( ) , guess ) ; }	 
return ( a <= b ) ? b : ( Float . is CaMeL Na CaMeL N ( a + b ) ? Float . Na CaMeL N : b ) ;  <CTX>  public static float max ( final float a , final float b ) { return ( a <= b ) ? b : ( Float . is CaMeL Na CaMeL N ( a + b ) ? Float . Na CaMeL N : b ) ; }	 
return ( Double . is CaMeL Na CaMeL N ( x ) && Double . is CaMeL Na CaMeL N ( y ) ) || x == y ;  <CTX>  public static boolean equals ( double x , double y ) { return ( Double . is CaMeL Na CaMeL N ( x ) && Double . is CaMeL Na CaMeL N ( y ) ) || x == y ; }	 
out [ i ] [ j ] = $NUMBER$ * ( 1 - t CaMeL Distribution . cumulative CaMeL Probability ( t ) ) ;  <CTX>  public Real CaMeL Matrix get CaMeL Correlation CaMeL P CaMeL Values ( ) throws Math CaMeL Exception { T CaMeL Distribution t CaMeL Distribution = new T CaMeL Distribution CaMeL Impl ( n CaMeL Obs - $NUMBER$ ) ; int n CaMeL Vars = correlation CaMeL Matrix . get CaMeL Column CaMeL Dimension ( ) ; double [ ] [ ] out = new double [ n CaMeL Vars ] [ n CaMeL Vars ] ; for ( int i = 0 ; i < n CaMeL Vars ; i ++ ) { for ( int j = 0 ; j < n CaMeL Vars ; j ++ ) { if ( i == j ) { out [ i ] [ j ] = 0 d ; } else { double r = correlation CaMeL Matrix . get CaMeL Entry ( i , j ) ; double t = Math . abs ( r * Math . sqrt ( ( n CaMeL Obs - $NUMBER$ ) / ( 1 - r * r ) ) ) ; out [ i ] [ j ] = $NUMBER$ * ( 1 - t CaMeL Distribution . cumulative CaMeL Probability ( t ) ) ; } } } return new Block CaMeL Real CaMeL Matrix ( out ) ; }	 
return solve ( min , max ) ;  <CTX>  public double solve ( final Univariate CaMeL Real CaMeL Function f , double min , double max , double initial ) throws Max CaMeL Iterations CaMeL Exceeded CaMeL Exception , Function CaMeL Evaluation CaMeL Exception { return solve ( min , max ) ; }	 
return get CaMeL Cum CaMeL Pct ( ( Comparable < ? > ) v ) ;  <CTX>  public double get CaMeL Pct ( Object v ) { return get CaMeL Cum CaMeL Pct ( ( Comparable < ? > ) v ) ; }	 
int j = $NUMBER$ * n - 1 ;  <CTX>  private boolean flip CaMeL If CaMeL War@@ ran@@ ted ( final int n , final int step ) { if ( 1 . $NUMBER$ * work [ ping CaMeL Pong ] < work [ $NUMBER$ * ( n - 1 ) + ping CaMeL Pong ] ) { int j = $NUMBER$ * n - 1 ; for ( int i = 0 ; i < j ; i += $NUMBER$ ) { for ( int k = 0 ; k < $NUMBER$ ; k += step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j -= $NUMBER$ ; } return true ; } return false ; }	 
if ( Math CaMeL Utils . compare CaMeL To ( entry , 0 , epsilon ) >= 0 ) {  <CTX>  private Integer get CaMeL Pivot CaMeL Row ( final int col , final Simplex CaMeL Tableau tableau ) { double min CaMeL Ratio = Double . MAX _ VALUE ; Integer min CaMeL Ratio CaMeL Pos = null ; for ( int i = tableau . get CaMeL Num CaMeL Objective CaMeL Functions ( ) ; i < tableau . get CaMeL Height ( ) ; i ++ ) { final double rhs = tableau . get CaMeL Entry ( i , tableau . get CaMeL Width ( ) - 1 ) ; final double entry = tableau . get CaMeL Entry ( i , col ) ; if ( Math CaMeL Utils . compare CaMeL To ( entry , 0 , epsilon ) >= 0 ) { final double ratio = rhs / entry ; if ( ratio < min CaMeL Ratio ) { min CaMeL Ratio = ratio ; min CaMeL Ratio CaMeL Pos = i ; } } } return min CaMeL Ratio CaMeL Pos ; }	 
if ( fa * fb >= 0 . 0 ) {  <CTX>  public static double [ ] bracket ( Univariate CaMeL Real CaMeL Function function , double initial , double lower CaMeL Bound , double upper CaMeL Bound , int maximum CaMeL Iterations ) throws Convergence CaMeL Exception , Function CaMeL Evaluation CaMeL Exception { if ( function == null ) { throw Math CaMeL Runtime CaMeL Exception . create CaMeL Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( maximum CaMeL Iterations <= 0 ) { throw Math CaMeL Runtime CaMeL Exception . create CaMeL Illegal CaMeL Argument CaMeL Exception ( $STRING$ , maximum CaMeL Iterations ) ; } if ( initial < lower CaMeL Bound || initial > upper CaMeL Bound || lower CaMeL Bound >= upper CaMeL Bound ) { throw Math CaMeL Runtime CaMeL Exception . create CaMeL Illegal CaMeL Argument CaMeL Exception ( $STRING$ , lower CaMeL Bound , initial , upper CaMeL Bound ) ; } double a = initial ; double b = initial ; double fa ; double fb ; int num CaMeL Iterations = 0 ; do { a = Math . max ( a - 1 . 0 , lower CaMeL Bound ) ; b = Math . min ( b + 1 . 0 , upper CaMeL Bound ) ; fa = function . value ( a ) ; fb = function . value ( b ) ; num CaMeL Iterations ++ ; } while ( ( fa * fb > 0 . 0 ) && ( num CaMeL Iterations < maximum CaMeL Iterations ) && ( ( a > lower CaMeL Bound ) || ( b < upper CaMeL Bound ) ) ) ; if ( fa * fb >= 0 . 0 ) { throw new Convergence CaMeL Exception ( $STRING$ + $STRING$ + $STRING$ , num CaMeL Iterations , maximum CaMeL Iterations , initial , lower CaMeL Bound , upper CaMeL Bound , a , b , fa , fb ) ; } return new double [ ] { a , b } ; }	 
double n CaMeL O@@ d = double CaMeL Value ( ) ; double d CaMeL On = object . double CaMeL Value ( ) ;  <CTX>  public int compare CaMeL To ( Fraction object ) { double n CaMeL O@@ d = double CaMeL Value ( ) ; double d CaMeL On = object . double CaMeL Value ( ) ; return ( n CaMeL O@@ d < d CaMeL On ) ? - 1 : ( ( n CaMeL O@@ d > d CaMeL On ) ? + 1 : 0 ) ; }	 
if ( u * v == 0 ) {  <CTX>  public static int gcd ( int u , int v ) { if ( u * v == 0 ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } if ( u > 0 ) { u = - u ; } if ( v > 0 ) { v = - v ; } int k = 0 ; while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < $NUMBER$ ) { u /= $NUMBER$ ; v /= $NUMBER$ ; k ++ ; } if ( k == $NUMBER$ ) { throw new Arithmetic CaMeL Exception ( $STRING$ ) ; } int t = ( ( u & 1 ) == 1 ) ? v : - ( u / $NUMBER$ ) ; do { while ( ( t & 1 ) == 0 ) { t /= $NUMBER$ ; } if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / $NUMBER$ ; } while ( t != 0 ) ; return - u * ( 1 << k ) ; }	 
ret = ( Double . double CaMeL To CaMeL Raw CaMeL Long CaMeL Bits ( real ) == Double . double CaMeL To CaMeL Raw CaMeL Long CaMeL Bits ( rhs . get CaMeL Real ( ) ) ) && ( Double . double CaMeL To CaMeL Raw CaMeL Long CaMeL Bits ( imaginary ) == Double . double CaMeL To CaMeL Raw CaMeL Long CaMeL Bits ( rhs . get CaMeL Imaginary ( ) ) ) ;  <CTX>  public boolean equals ( Object other ) { boolean ret ; if ( this == other ) { ret = true ; } else if ( other == null ) { ret = false ; } else { try { Complex rhs = ( Complex ) other ; if ( rhs . is CaMeL Na CaMeL N ( ) ) { ret = this . is CaMeL Na CaMeL N ( ) ; } else { ret = ( Double . double CaMeL To CaMeL Raw CaMeL Long CaMeL Bits ( real ) == Double . double CaMeL To CaMeL Raw CaMeL Long CaMeL Bits ( rhs . get CaMeL Real ( ) ) ) && ( Double . double CaMeL To CaMeL Raw CaMeL Long CaMeL Bits ( imaginary ) == Double . double CaMeL To CaMeL Raw CaMeL Long CaMeL Bits ( rhs . get CaMeL Imaginary ( ) ) ) ; } } catch ( Class CaMeL Cast CaMeL Exception ex ) { ret = false ; } } return ret ; }	 
if (  <CTX>  public Complex parse ( String source , Parse CaMeL Position pos ) { int initial CaMeL Index = pos . get CaMeL Index ( ) ; parse CaMeL And CaMeL Ignore CaMeL Whitespace ( source , pos ) ; Number re = parse CaMeL Number ( source , get CaMeL Real CaMeL Format ( ) , pos ) ; if ( re == null ) { pos . set CaMeL Index ( initial CaMeL Index ) ; return null ; } int start CaMeL Index = pos . get CaMeL Index ( ) ; char c = parse CaMeL Next CaMeL Character ( source , pos ) ; int sign = 0 ; switch ( c ) { case 0 : return new Complex ( re . double CaMeL Value ( ) , 0 . 0 ) ; case $STRING$ : sign = - 1 ; break ; case $STRING$ : sign = 1 ; break ; default : pos . set CaMeL Index ( initial CaMeL Index ) ; pos . set CaMeL Error CaMeL Index ( start CaMeL Index ) ; return null ; } parse CaMeL And CaMeL Ignore CaMeL Whitespace ( source , pos ) ; Number im = parse CaMeL Number ( source , get CaMeL Real CaMeL Format ( ) , pos ) ; if ( im == null ) { pos . set CaMeL Index ( initial CaMeL Index ) ; return null ; } int n = get CaMeL Imaginary CaMeL Character ( ) . length ( ) ; start CaMeL Index = pos . get CaMeL Index ( ) ; int end CaMeL Index = start CaMeL Index + n ; if ( source . substring ( start CaMeL Index , end CaMeL Index ) . compare CaMeL To ( get CaMeL Imaginary CaMeL Character ( ) ) != 0 ) { pos . set CaMeL Index ( initial CaMeL Index ) ; pos . set CaMeL Error CaMeL Index ( start CaMeL Index ) ; return null ; } pos . set CaMeL Index ( end CaMeL Index ) ; return new Complex ( re . double CaMeL Value ( ) , im . double CaMeL Value ( ) * sign ) ; }	 
return sum CaMeL YY - sum CaMeL XY * sum CaMeL XY / sum CaMeL XX ;  <CTX>  public double get CaMeL Sum CaMeL Squared CaMeL Errors ( ) { return sum CaMeL YY - sum CaMeL XY * sum CaMeL XY / sum CaMeL XX ; }	 
throw new Unsupported CaMeL Operation CaMeL Exception ( ) ;  <CTX>  public void capture CaMeL Arguments CaMeL From ( Invocation invocation ) { if ( invocation . get CaMeL Method ( ) . is CaMeL Var CaMeL Args ( ) ) { int index CaMeL Of CaMeL Vararg = invocation . get CaMeL Raw CaMeL Arguments ( ) . length - 1 ; throw new Unsupported CaMeL Operation CaMeL Exception ( ) ; } else { for ( int position = 0 ; position < matchers . size ( ) ; position ++ ) { Matcher m = matchers . get ( position ) ; if ( m instanceof Captures CaMeL Arguments ) { ( ( Captures CaMeL Arguments ) m ) . capture CaMeL From ( invocation . get CaMeL Argument CaMeL At ( position , Object . class ) ) ; } } } }	 
catch ( org . mock@@ ito . exceptions . verification . junit . Arguments CaMeL Are CaMeL Different e ) {  <CTX>  public void verify ( Verification CaMeL Data data ) { Assertion CaMeL Error error = null ; timer . start ( ) ; while ( timer . is CaMeL Counting ( ) ) { try { delegate . verify ( data ) ; if ( return CaMeL On CaMeL Success ) { return ; } else { error = null ; } } catch ( Mockito CaMeL Assertion CaMeL Error e ) { error = handle CaMeL Verify CaMeL Exception ( e ) ; } catch ( org . mock@@ ito . exceptions . verification . junit . Arguments CaMeL Are CaMeL Different e ) { error = handle CaMeL Verify CaMeL Exception ( e ) ; } } if ( error != null ) { throw error ; } }	 
} else {  <CTX>  protected void register CaMeL Type CaMeL Variables CaMeL On ( Type class CaMeL Type ) { if ( ! ( class CaMeL Type instanceof Parameterized CaMeL Type ) ) { return ; } Parameterized CaMeL Type parameterized CaMeL Type = ( Parameterized CaMeL Type ) class CaMeL Type ; Type CaMeL Variable [ ] type CaMeL Parameters = ( ( Class < ? > ) parameterized CaMeL Type . get CaMeL Raw CaMeL Type ( ) ) . get CaMeL Type CaMeL Parameters ( ) ; Type [ ] actual CaMeL Type CaMeL Arguments = parameterized CaMeL Type . get CaMeL Actual CaMeL Type CaMeL Arguments ( ) ; for ( int i = 0 ; i < actual CaMeL Type CaMeL Arguments . length ; i ++ ) { Type CaMeL Variable type CaMeL Parameter = type CaMeL Parameters [ i ] ; Type actual CaMeL Type CaMeL Argument = actual CaMeL Type CaMeL Arguments [ i ] ; if ( actual CaMeL Type CaMeL Argument instanceof Wildcard CaMeL Type ) { contextual CaMeL Actual CaMeL Type CaMeL Parameters . put ( type CaMeL Parameter , bounds CaMeL Of ( ( Wildcard CaMeL Type ) actual CaMeL Type CaMeL Argument ) ) ; } else { contextual CaMeL Actual CaMeL Type CaMeL Parameters . put ( type CaMeL Parameter , actual CaMeL Type CaMeL Argument ) ; } } }	 
if ( o 1 == null || o $NUMBER$ == null ) {  <CTX>  public static boolean are CaMeL Equal ( Object o 1 , Object o $NUMBER$ ) { if ( o 1 == null || o $NUMBER$ == null ) { return o 1 == null && o $NUMBER$ == null ; } else if ( is CaMeL Array ( o 1 ) ) { return is CaMeL Array ( o $NUMBER$ ) && are CaMeL Arrays CaMeL Equal ( o 1 , o $NUMBER$ ) ; } else { return o 1 . equals ( o $NUMBER$ ) ; } }	 
return 1 ;  <CTX>  public Object answer ( Invocation CaMeL On CaMeL Mock invocation ) { if ( methods CaMeL G@@ ur@@ u . is CaMeL To CaMeL String ( invocation . get CaMeL Method ( ) ) ) { Object mock = invocation . get CaMeL Mock ( ) ; Mock CaMeL Name name = mock CaMeL Util . get CaMeL Mock CaMeL Name ( mock ) ; if ( name . is CaMeL Default ( ) ) { return $STRING$ + mock CaMeL Util . get CaMeL Mock CaMeL Settings ( mock ) . get CaMeL Type CaMeL To CaMeL Mock ( ) . get CaMeL Simple CaMeL Name ( ) + $STRING$ + mock . hash CaMeL Code ( ) ; } else { return name . to CaMeL String ( ) ; } } else if ( methods CaMeL G@@ ur@@ u . is CaMeL Compare CaMeL To CaMeL Method ( invocation . get CaMeL Method ( ) ) ) { return 1 ; } Class < ? > return CaMeL Type = invocation . get CaMeL Method ( ) . get CaMeL Return CaMeL Type ( ) ; return return CaMeL Value CaMeL For ( return CaMeL Type ) ; }	 
Mock CaMeL Handler < T > new CaMeL Mock CaMeL Handler = new Mock CaMeL Handler < T > ( old CaMeL Mock CaMeL Handler ) ; Method CaMeL Interceptor CaMeL Filter new CaMeL Filter = new Method CaMeL Interceptor CaMeL Filter ( new CaMeL Mock CaMeL Handler , ( Mock CaMeL Settings CaMeL Impl ) org . mock@@ ito . Mockito . with CaMeL Settings ( ) . default CaMeL Answer ( org . mock@@ ito . Mockito . RETURNS _ DEFAULTS ) ) ;  <CTX>  public < T > void reset CaMeL Mock ( T mock ) { Mock CaMeL Handler CaMeL Interface < T > old CaMeL Mock CaMeL Handler = get CaMeL Mock CaMeL Handler ( mock ) ; Mock CaMeL Handler < T > new CaMeL Mock CaMeL Handler = new Mock CaMeL Handler < T > ( old CaMeL Mock CaMeL Handler ) ; Method CaMeL Interceptor CaMeL Filter new CaMeL Filter = new Method CaMeL Interceptor CaMeL Filter ( new CaMeL Mock CaMeL Handler , ( Mock CaMeL Settings CaMeL Impl ) org . mock@@ ito . Mockito . with CaMeL Settings ( ) . default CaMeL Answer ( org . mock@@ ito . Mockito . RETURNS _ DEFAULTS ) ) ; ( ( Factory ) mock ) . set CaMeL Callback ( 0 , new CaMeL Filter ) ; }	 
mock CaMeL Candidate CaMeL Filter . filter CaMeL Candidate ( mocks , field , field CaMeL Instance ) . then CaMeL Inject ( ) ;  <CTX>  private void inject CaMeL Mock CaMeL Candidate ( Class < ? > awaiting CaMeL Injection CaMeL Clazz , Set < Object > mocks , Object field CaMeL Instance ) { for ( Field field : ordered CaMeL Instance CaMeL Fields CaMeL From ( awaiting CaMeL Injection CaMeL Clazz ) ) { mock CaMeL Candidate CaMeL Filter . filter CaMeL Candidate ( mocks , field , field CaMeL Instance ) . then CaMeL Inject ( ) ; } }	 
description . append CaMeL Text ( wanted . to CaMeL String ( ) ) ;  <CTX>  public void describe CaMeL To ( Description description ) { description . append CaMeL Text ( $STRING$ ) ; append CaMeL Quoting ( description ) ; description . append CaMeL Text ( wanted . to CaMeL String ( ) ) ; append CaMeL Quoting ( description ) ; description . append CaMeL Text ( $STRING$ ) ; }	 
if ( m instanceof Captures CaMeL Arguments ) {  <CTX>  public void capture CaMeL Arguments CaMeL From ( Invocation i ) { int k = 0 ; for ( Matcher m : matchers ) { if ( m instanceof Captures CaMeL Arguments ) { ( ( Captures CaMeL Arguments ) m ) . capture CaMeL From ( i . get CaMeL Arguments ( ) [ k ] ) ; } k ++ ; } }	 
return String CaMeL Description . to CaMeL String ( m ) . equals ( arg . to CaMeL String ( ) ) ;  <CTX>  private boolean to CaMeL String CaMeL Equals ( Matcher m , Object arg ) { return String CaMeL Description . to CaMeL String ( m ) . equals ( arg . to CaMeL String ( ) ) ; }	 
Partial new CaMeL Partial = new Partial ( i CaMeL Chron@@ ology , new CaMeL Types , new CaMeL Values ) ;  <CTX>  public Partial with ( Date CaMeL Time CaMeL Field CaMeL Type field CaMeL Type , int value ) { if ( field CaMeL Type == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } int index = index CaMeL Of ( field CaMeL Type ) ; if ( index == - 1 ) { Date CaMeL Time CaMeL Field CaMeL Type [ ] new CaMeL Types = new Date CaMeL Time CaMeL Field CaMeL Type [ i CaMeL Types . length + 1 ] ; int [ ] new CaMeL Values = new int [ new CaMeL Types . length ] ; int i = 0 ; Duration CaMeL Field unit CaMeL Field = field CaMeL Type . get CaMeL Duration CaMeL Type ( ) . get CaMeL Field ( i CaMeL Chron@@ ology ) ; if ( unit CaMeL Field . is CaMeL Supported ( ) ) { for ( ; i < i CaMeL Types . length ; i ++ ) { Date CaMeL Time CaMeL Field CaMeL Type loop CaMeL Type = i CaMeL Types [ i ] ; Duration CaMeL Field loop CaMeL Unit CaMeL Field = loop CaMeL Type . get CaMeL Duration CaMeL Type ( ) . get CaMeL Field ( i CaMeL Chron@@ ology ) ; if ( loop CaMeL Unit CaMeL Field . is CaMeL Supported ( ) ) { int compare = unit CaMeL Field . compare CaMeL To ( loop CaMeL Unit CaMeL Field ) ; if ( compare > 0 ) { break ; } else if ( compare == 0 ) { Duration CaMeL Field range CaMeL Field = field CaMeL Type . get CaMeL Range CaMeL Duration CaMeL Type ( ) . get CaMeL Field ( i CaMeL Chron@@ ology ) ; Duration CaMeL Field loop CaMeL Range CaMeL Field = loop CaMeL Type . get CaMeL Range CaMeL Duration CaMeL Type ( ) . get CaMeL Field ( i CaMeL Chron@@ ology ) ; if ( range CaMeL Field . compare CaMeL To ( loop CaMeL Range CaMeL Field ) > 0 ) { break ; } } } } } System . arraycopy ( i CaMeL Types , 0 , new CaMeL Types , 0 , i ) ; System . arraycopy ( i CaMeL Values , 0 , new CaMeL Values , 0 , i ) ; new CaMeL Types [ i ] = field CaMeL Type ; new CaMeL Values [ i ] = value ; System . arraycopy ( i CaMeL Types , i , new CaMeL Types , i + 1 , new CaMeL Types . length - i - 1 ) ; System . arraycopy ( i CaMeL Values , i , new CaMeL Values , i + 1 , new CaMeL Values . length - i - 1 ) ; Partial new CaMeL Partial = new Partial ( i CaMeL Chron@@ ology , new CaMeL Types , new CaMeL Values ) ; i CaMeL Chron@@ ology . validate ( new CaMeL Partial , new CaMeL Values ) ; return new CaMeL Partial ; } if ( value == get CaMeL Value ( index ) ) { return this ; } int [ ] new CaMeL Values = get CaMeL Values ( ) ; new CaMeL Values = get CaMeL Field ( index ) . set ( this , index , new CaMeL Values , value ) ; return new Partial ( this , new CaMeL Values ) ; }	 
instant CaMeL Local , chron@@ o , i CaMeL Locale , i CaMeL Pivot CaMeL Year , i CaMeL Default CaMeL Year ) ;  <CTX>  public int parse CaMeL Into ( Read CaMeL Writable CaMeL Instant instant , String text , int position ) { Date CaMeL Time CaMeL Parser parser = require CaMeL Parser ( ) ; if ( instant == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } long instant CaMeL Millis = instant . get CaMeL Millis ( ) ; Chron@@ ology chron@@ o = instant . get CaMeL Chron@@ ology ( ) ; long instant CaMeL Local = instant CaMeL Millis + chron@@ o . get CaMeL Zone ( ) . get CaMeL Offset ( instant CaMeL Millis ) ; chron@@ o = select CaMeL Chron@@ ology ( chron@@ o ) ; Date CaMeL Time CaMeL Parser CaMeL Bucket bucket = new Date CaMeL Time CaMeL Parser CaMeL Bucket ( instant CaMeL Local , chron@@ o , i CaMeL Locale , i CaMeL Pivot CaMeL Year , i CaMeL Default CaMeL Year ) ; int new CaMeL Pos = parser . parse CaMeL Into ( bucket , text , position ) ; instant . set CaMeL Millis ( bucket . compute CaMeL Millis ( false , text ) ) ; if ( i CaMeL Offset CaMeL Parsed && bucket . get CaMeL Offset CaMeL Integer ( ) != null ) { int parsed CaMeL Offset = bucket . get CaMeL Offset CaMeL Integer ( ) ; Date CaMeL Time CaMeL Zone parsed CaMeL Zone = Date CaMeL Time CaMeL Zone . for CaMeL Offset CaMeL Millis ( parsed CaMeL Offset ) ; chron@@ o = chron@@ o . with CaMeL Zone ( parsed CaMeL Zone ) ; } else if ( bucket . get CaMeL Zone ( ) != null ) { chron@@ o = chron@@ o . with CaMeL Zone ( bucket . get CaMeL Zone ( ) ) ; } instant . set CaMeL Chron@@ ology ( chron@@ o ) ; if ( i CaMeL Zone != null ) { instant . set CaMeL Zone ( i CaMeL Zone ) ; } return new CaMeL Pos ; }	 
} else if ( offset CaMeL Local > 0 ) {  <CTX>  public int get CaMeL Offset CaMeL From CaMeL Local ( long instant CaMeL Local ) { final int offset CaMeL Local = get CaMeL Offset ( instant CaMeL Local ) ; final long instant CaMeL Adjusted = instant CaMeL Local - offset CaMeL Local ; final int offset CaMeL Adjusted = get CaMeL Offset ( instant CaMeL Adjusted ) ; if ( offset CaMeL Local != offset CaMeL Adjusted ) { if ( ( offset CaMeL Local - offset CaMeL Adjusted ) < 0 ) { long next CaMeL Local = next CaMeL Transition ( instant CaMeL Adjusted ) ; long next CaMeL Adjusted = next CaMeL Transition ( instant CaMeL Local - offset CaMeL Adjusted ) ; if ( next CaMeL Local != next CaMeL Adjusted ) { return offset CaMeL Local ; } } } else if ( offset CaMeL Local > 0 ) { long prev = previous CaMeL Transition ( instant CaMeL Adjusted ) ; if ( prev < instant CaMeL Adjusted ) { int offset CaMeL Prev = get CaMeL Offset ( prev ) ; int diff = offset CaMeL Prev - offset CaMeL Local ; if ( instant CaMeL Adjusted - prev <= diff ) { return offset CaMeL Prev ; } } } return offset CaMeL Adjusted ; }	 
