String CaMeL Buffer buff = new String CaMeL Buffer ( ) ;  <CTX>  private void check CaMeL Required CaMeL Options ( ) throws Missing CaMeL Option CaMeL Exception { if ( required CaMeL Options . size ( ) > 0 ) { Iterator iter = required CaMeL Options . iterator ( ) ; String CaMeL Buffer buff = new String CaMeL Buffer ( ) ; while ( iter . has CaMeL Next ( ) ) { buff . append ( iter . next ( ) ) ; } throw new Missing CaMeL Option CaMeL Exception ( buff . to CaMeL String ( ) ) ; } }	 
pos = find CaMeL Wrap CaMeL Pos ( text , width , next CaMeL Line CaMeL Tab CaMeL Stop ) ;  <CTX>  protected String CaMeL Buffer render CaMeL Wrapped CaMeL Text ( String CaMeL Buffer sb , int width , int next CaMeL Line CaMeL Tab CaMeL Stop , String text ) { int pos = find CaMeL Wrap CaMeL Pos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( r@@ trim ( text ) ) ; return sb ; } sb . append ( r@@ trim ( text . substring ( 0 , pos ) ) ) . append ( default CaMeL New CaMeL Line ) ; final String padding = create CaMeL Padding ( next CaMeL Line CaMeL Tab CaMeL Stop ) ; while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = find CaMeL Wrap CaMeL Pos ( text , width , next CaMeL Line CaMeL Tab CaMeL Stop ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; } sb . append ( r@@ trim ( text . substring ( 0 , pos ) ) ) . append ( default CaMeL New CaMeL Line ) ; } }	 
if ( option . has CaMeL Arg ( ) && ( option . get CaMeL Arg CaMeL Name ( ) != null ) )  <CTX>  private static void append CaMeL Option ( final String CaMeL Buffer buff , final Option option , final boolean required ) { if ( ! required ) { buff . append ( $STRING$ ) ; } if ( option . get CaMeL Opt ( ) != null ) { buff . append ( $STRING$ ) . append ( option . get CaMeL Opt ( ) ) ; } else { buff . append ( $STRING$ ) . append ( option . get CaMeL Long CaMeL Opt ( ) ) ; } if ( option . has CaMeL Arg ( ) && ( option . get CaMeL Arg CaMeL Name ( ) != null ) ) { buff . append ( $STRING$ ) . append ( option . get CaMeL Arg CaMeL Name ( ) ) . append ( $STRING$ ) ; } if ( ! required ) { buff . append ( $STRING$ ) ; } }	 
throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + $STRING$ ) ;  <CTX>  protected String CaMeL Buffer render CaMeL Wrapped CaMeL Text ( String CaMeL Buffer sb , int width , int next CaMeL Line CaMeL Tab CaMeL Stop , String text ) { int pos = find CaMeL Wrap CaMeL Pos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( r@@ trim ( text ) ) ; return sb ; } sb . append ( r@@ trim ( text . substring ( 0 , pos ) ) ) . append ( default CaMeL New CaMeL Line ) ; if ( next CaMeL Line CaMeL Tab CaMeL Stop >= width ) { throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + $STRING$ ) ; } final String padding = create CaMeL Padding ( next CaMeL Line CaMeL Tab CaMeL Stop ) ; while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = find CaMeL Wrap CaMeL Pos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; } if ( ( text . length ( ) > width ) && ( pos == next CaMeL Line CaMeL Tab CaMeL Stop - 1 ) ) { pos = width ; } sb . append ( r@@ trim ( text . substring ( 0 , pos ) ) ) . append ( default CaMeL New CaMeL Line ) ; } }	 
next CaMeL Line CaMeL Tab CaMeL Stop = width - 1 ;  <CTX>  protected String CaMeL Buffer render CaMeL Wrapped CaMeL Text ( String CaMeL Buffer sb , int width , int next CaMeL Line CaMeL Tab CaMeL Stop , String text ) { int pos = find CaMeL Wrap CaMeL Pos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( r@@ trim ( text ) ) ; return sb ; } sb . append ( r@@ trim ( text . substring ( 0 , pos ) ) ) . append ( default CaMeL New CaMeL Line ) ; if ( next CaMeL Line CaMeL Tab CaMeL Stop >= width ) { next CaMeL Line CaMeL Tab CaMeL Stop = width - 1 ; } final String padding = create CaMeL Padding ( next CaMeL Line CaMeL Tab CaMeL Stop ) ; while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = find CaMeL Wrap CaMeL Pos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; } if ( ( text . length ( ) > width ) && ( pos == next CaMeL Line CaMeL Tab CaMeL Stop - 1 ) ) { pos = width ; } sb . append ( r@@ trim ( text . substring ( 0 , pos ) ) ) . append ( default CaMeL New CaMeL Line ) ; } }	 
break ;  <CTX>  protected void process CaMeL Properties ( Properties properties ) { if ( properties == null ) { return ; } for ( Enumeration e = properties . property CaMeL Names ( ) ; e . has CaMeL More CaMeL Elements ( ) ; ) { String option = e . next CaMeL Element ( ) . to CaMeL String ( ) ; if ( ! cmd . has CaMeL Option ( option ) ) { Option opt = get CaMeL Options ( ) . get CaMeL Option ( option ) ; String value = properties . get CaMeL Property ( option ) ; if ( opt . has CaMeL Arg ( ) ) { if ( opt . get CaMeL Values ( ) == null || opt . get CaMeL Values ( ) . length == 0 ) { try { opt . add CaMeL Value CaMeL For CaMeL Processing ( value ) ; } catch ( Runtime CaMeL Exception exp ) { } } } else if ( ! ( $STRING$ . equals CaMeL Ignore CaMeL Case ( value ) || $STRING$ . equals CaMeL Ignore CaMeL Case ( value ) || $STRING$ . equals CaMeL Ignore CaMeL Case ( value ) ) ) { break ; } cmd . add CaMeL Option ( opt ) ; } } }	 
while ( ( pos <= text . length ( ) ) && ( ( c = text . char CaMeL At ( pos ) ) != $STRING$ ) && ( c != $STRING$ ) && ( c != $STRING$ ) ) { ++ pos ; }  <CTX>  protected int find CaMeL Wrap CaMeL Pos ( String text , int width , int start CaMeL Pos ) { int pos ; if ( ( ( pos = text . index CaMeL Of ( $STRING$ , start CaMeL Pos ) ) != - 1 && pos <= width ) || ( ( pos = text . index CaMeL Of ( $STRING$ , start CaMeL Pos ) ) != - 1 && pos <= width ) ) { return pos + 1 ; } else if ( start CaMeL Pos + width >= text . length ( ) ) { return - 1 ; } pos = start CaMeL Pos + width ; char c ; while ( ( pos >= start CaMeL Pos ) && ( ( c = text . char CaMeL At ( pos ) ) != $STRING$ ) && ( c != $STRING$ ) && ( c != $STRING$ ) ) { -- pos ; } if ( pos > start CaMeL Pos ) { return pos ; } pos = start CaMeL Pos + width ; while ( ( pos <= text . length ( ) ) && ( ( c = text . char CaMeL At ( pos ) ) != $STRING$ ) && ( c != $STRING$ ) && ( c != $STRING$ ) ) { ++ pos ; } return pos == text . length ( ) ? - 1 : pos ; }	 
return null ;  <CTX>  public static < T > T create CaMeL Value ( final String str , final Class < T > clazz ) throws Parse CaMeL Exception { if ( Pattern CaMeL Option CaMeL Builder . STRING _ VALUE == clazz ) { return ( T ) str ; } else if ( Pattern CaMeL Option CaMeL Builder . OBJECT _ VALUE == clazz ) { return ( T ) create CaMeL Object ( str ) ; } else if ( Pattern CaMeL Option CaMeL Builder . NUMBER _ VALUE == clazz ) { return ( T ) create CaMeL Number ( str ) ; } else if ( Pattern CaMeL Option CaMeL Builder . DATE _ VALUE == clazz ) { return ( T ) create CaMeL Date ( str ) ; } else if ( Pattern CaMeL Option CaMeL Builder . CLASS _ VALUE == clazz ) { return ( T ) create CaMeL Class ( str ) ; } else if ( Pattern CaMeL Option CaMeL Builder . FILE _ VALUE == clazz ) { return ( T ) create CaMeL File ( str ) ; } else if ( Pattern CaMeL Option CaMeL Builder . EXISTING _ FILE _ VALUE == clazz ) { return ( T ) open CaMeL File ( str ) ; } else if ( Pattern CaMeL Option CaMeL Builder . FILES _ VALUE == clazz ) { return ( T ) create CaMeL Files ( str ) ; } else if ( Pattern CaMeL Option CaMeL Builder . URL _ VALUE == clazz ) { return ( T ) create CaMeL URL ( str ) ; } else { return null ; } }	 
return new Type CaMeL Pair ( null , null ) ;  <CTX>  public Type CaMeL Pair get CaMeL Types CaMeL Under CaMeL Inequality ( JS CaMeL Type that ) { if ( that instanceof Union CaMeL Type ) { Type CaMeL Pair p = that . get CaMeL Types CaMeL Under CaMeL Inequality ( this ) ; return new Type CaMeL Pair ( p . type CaMeL B , p . type CaMeL A ) ; } switch ( this . test CaMeL For CaMeL Equality ( that ) ) { case TRUE : return new Type CaMeL Pair ( null , null ) ; case FALSE : case UNKNOWN : return new Type CaMeL Pair ( this , that ) ; } throw new Illegal CaMeL State CaMeL Exception ( ) ; }	 
attach CaMeL Literal CaMeL Types ( n ) ; switch ( n . get CaMeL Type ( ) ) { case Token . FUNCTION : if ( parent . get CaMeL Type ( ) == Token . NAME ) { return ; } define CaMeL Declared CaMeL Function ( n , parent ) ; break ; case Token . CATCH : define CaMeL Catch ( n , parent ) ; break ; case Token . VAR : define CaMeL Var ( n , parent ) ; break ; }  <CTX>  public void visit ( Node CaMeL Traversal t , Node n , Node parent ) { if ( n == scope . get CaMeL Root CaMeL Node ( ) ) return ; if ( n . get CaMeL Type ( ) == Token . LP && parent == scope . get CaMeL Root CaMeL Node ( ) ) { handle CaMeL Function CaMeL Inputs ( parent ) ; return ; } attach CaMeL Literal CaMeL Types ( n ) ; switch ( n . get CaMeL Type ( ) ) { case Token . FUNCTION : if ( parent . get CaMeL Type ( ) == Token . NAME ) { return ; } define CaMeL Declared CaMeL Function ( n , parent ) ; break ; case Token . CATCH : define CaMeL Catch ( n , parent ) ; break ; case Token . VAR : define CaMeL Var ( n , parent ) ; break ; } }	 
type CaMeL Of CaMeL This = ( Object CaMeL Type ) safe CaMeL Resolve ( type CaMeL Of CaMeL This , t , scope ) ;  <CTX>  JS CaMeL Type resolve CaMeL Internal ( Error CaMeL Reporter t , Static CaMeL Scope < JS CaMeL Type > scope ) { set CaMeL Resolved CaMeL Type CaMeL Internal ( this ) ; call = ( Arrow CaMeL Type ) safe CaMeL Resolve ( call , t , scope ) ; prototype = ( Function CaMeL Prototype CaMeL Type ) safe CaMeL Resolve ( prototype , t , scope ) ; type CaMeL Of CaMeL This = ( Object CaMeL Type ) safe CaMeL Resolve ( type CaMeL Of CaMeL This , t , scope ) ; boolean changed = false ; Immutable CaMeL List . Builder < Object CaMeL Type > resolved CaMeL Interfaces = Immutable CaMeL List . builder ( ) ; for ( Object CaMeL Type iface : implemented CaMeL Interfaces ) { Object CaMeL Type resolved CaMeL Iface = ( Object CaMeL Type ) iface . resolve ( t , scope ) ; resolved CaMeL Interfaces . add ( resolved CaMeL Iface ) ; changed |= ( resolved CaMeL Iface != iface ) ; } if ( changed ) { implemented CaMeL Interfaces = resolved CaMeL Interfaces . build ( ) ; } if ( sub CaMeL Types != null ) { for ( int i = 0 ; i < sub CaMeL Types . size ( ) ; i ++ ) { sub CaMeL Types . set ( i , ( Function CaMeL Type ) sub CaMeL Types . get ( i ) . resolve ( t , scope ) ) ; } } return super . resolve CaMeL Internal ( t , scope ) ; }	 
if ( node . get CaMeL Type ( ) == Token . CALL ) { Node child = node . get CaMeL First CaMeL Child ( ) ; if ( child . get CaMeL Type ( ) == Token . NAME ) { changed . add ( child . get CaMeL String ( ) ) ;  <CTX>  private void find CaMeL Called CaMeL Functions ( Node node , Set < String > changed ) { Preconditions . check CaMeL Argument ( changed != null ) ; if ( node . get CaMeL Type ( ) == Token . CALL ) { Node child = node . get CaMeL First CaMeL Child ( ) ; if ( child . get CaMeL Type ( ) == Token . NAME ) { changed . add ( child . get CaMeL String ( ) ) ; } } for ( Node c = node . get CaMeL First CaMeL Child ( ) ; c != null ; c = c . get CaMeL Next ( ) ) { find CaMeL Called CaMeL Functions ( c , changed ) ; } }	 
if ( t . get CaMeL Scope CaMeL Depth ( ) <= $NUMBER$ ) {  <CTX>  public void visit ( Node CaMeL Traversal t , Node n , Node parent ) { if ( t . in CaMeL Global CaMeL Scope ( ) ) { return ; } if ( n . is CaMeL Return ( ) && n . get CaMeL First CaMeL Child ( ) != null ) { data . get ( t . get CaMeL Scope CaMeL Root ( ) ) . record CaMeL Non CaMeL Empty CaMeL Return ( ) ; } if ( t . get CaMeL Scope CaMeL Depth ( ) <= $NUMBER$ ) { return ; } if ( n . is CaMeL Name ( ) && Node CaMeL Util . is CaMeL L CaMeL Value ( n ) && ! Node CaMeL Util . is CaMeL Ble@@ eding CaMeL Function CaMeL Name ( n ) ) { String name = n . get CaMeL String ( ) ; Scope scope = t . get CaMeL Scope ( ) ; Var var = scope . get CaMeL Var ( name ) ; if ( var != null ) { Scope owner CaMeL Scope = var . get CaMeL Scope ( ) ; if ( owner CaMeL Scope . is CaMeL Local ( ) ) { data . get ( owner CaMeL Scope . get CaMeL Root CaMeL Node ( ) ) . record CaMeL Assigned CaMeL Name ( name ) ; } if ( scope != owner CaMeL Scope && owner CaMeL Scope . is CaMeL Local ( ) ) { data . get ( owner CaMeL Scope . get CaMeL Root CaMeL Node ( ) ) . record CaMeL Escaped CaMeL Var CaMeL Name ( name ) ; } } } else if ( n . is CaMeL Get CaMeL Prop ( ) && n . is CaMeL Un@@ scoped CaMeL Qualified CaMeL Name ( ) && Node CaMeL Util . is CaMeL L CaMeL Value ( n ) ) { String name = Node CaMeL Util . get CaMeL Root CaMeL Of CaMeL Qualified CaMeL Name ( n ) . get CaMeL String ( ) ; Scope scope = t . get CaMeL Scope ( ) ; Var var = scope . get CaMeL Var ( name ) ; if ( var != null ) { Scope owner CaMeL Scope = var . get CaMeL Scope ( ) ; if ( scope != owner CaMeL Scope && owner CaMeL Scope . is CaMeL Local ( ) ) { data . get ( owner CaMeL Scope . get CaMeL Root CaMeL Node ( ) ) . record CaMeL Escaped CaMeL Qualified CaMeL Name ( n . get CaMeL Qualified CaMeL Name ( ) ) ; } } } }	 
if ( line CaMeL Length > 0 ) {  <CTX>  void encode ( byte [ ] in , int in CaMeL Pos , int in CaMeL Avail ) { if ( eof ) { return ; } if ( in CaMeL Avail < 0 ) { eof = true ; if ( buf == null || buf . length - pos < encode CaMeL Size ) { resize CaMeL Buf ( ) ; } switch ( modulus ) { case 1 : buf [ pos ++ ] = encode CaMeL Table [ ( x >> $NUMBER$ ) & MASK _ $NUMBER$ BITS ] ; buf [ pos ++ ] = encode CaMeL Table [ ( x << $NUMBER$ ) & MASK _ $NUMBER$ BITS ] ; if ( encode CaMeL Table == STANDARD _ ENCODE _ TABLE ) { buf [ pos ++ ] = PAD ; buf [ pos ++ ] = PAD ; } break ; case $NUMBER$ : buf [ pos ++ ] = encode CaMeL Table [ ( x >> $NUMBER$ ) & MASK _ $NUMBER$ BITS ] ; buf [ pos ++ ] = encode CaMeL Table [ ( x >> $NUMBER$ ) & MASK _ $NUMBER$ BITS ] ; buf [ pos ++ ] = encode CaMeL Table [ ( x << $NUMBER$ ) & MASK _ $NUMBER$ BITS ] ; if ( encode CaMeL Table == STANDARD _ ENCODE _ TABLE ) { buf [ pos ++ ] = PAD ; } break ; } if ( line CaMeL Length > 0 ) { System . arraycopy ( line CaMeL Separator , 0 , buf , pos , line CaMeL Separator . length ) ; pos += line CaMeL Separator . length ; } } else { for ( int i = 0 ; i < in CaMeL Avail ; i ++ ) { if ( buf == null || buf . length - pos < encode CaMeL Size ) { resize CaMeL Buf ( ) ; } modulus = ( ++ modulus ) % $NUMBER$ ; int b = in [ in CaMeL Pos ++ ] ; if ( b < 0 ) { b += $NUMBER$ ; } x = ( x << 8 ) + b ; if ( 0 == modulus ) { buf [ pos ++ ] = encode CaMeL Table [ ( x >> $NUMBER$ ) & MASK _ $NUMBER$ BITS ] ; buf [ pos ++ ] = encode CaMeL Table [ ( x >> $NUMBER$ ) & MASK _ $NUMBER$ BITS ] ; buf [ pos ++ ] = encode CaMeL Table [ ( x >> $NUMBER$ ) & MASK _ $NUMBER$ BITS ] ; buf [ pos ++ ] = encode CaMeL Table [ x & MASK _ $NUMBER$ BITS ] ; current CaMeL Line CaMeL Pos += $NUMBER$ ; if ( line CaMeL Length > 0 && line CaMeL Length <= current CaMeL Line CaMeL Pos ) { System . arraycopy ( line CaMeL Separator , 0 , buf , pos , line CaMeL Separator . length ) ; pos += line CaMeL Separator . length ; current CaMeL Line CaMeL Pos = 0 ; } } } } }	 
} else if ( contains ( value , index + 1 , $NUMBER$ , $STRING$ ) ) {  <CTX>  private int handle CaMeL G ( String value , Double CaMeL Metaphone CaMeL Result result , int index , boolean slavo CaMeL Germanic ) { if ( char CaMeL At ( value , index + 1 ) == $STRING$ ) { index = handle CaMeL G@@ H ( value , result , index ) ; } else if ( char CaMeL At ( value , index + 1 ) == $STRING$ ) { if ( index == 1 && is CaMeL Vowel ( char CaMeL At ( value , 0 ) ) && ! slavo CaMeL Germanic ) { result . append ( $STRING$ , $STRING$ ) ; } else if ( ! contains ( value , index + $NUMBER$ , $NUMBER$ , $STRING$ ) && char CaMeL At ( value , index + 1 ) != $STRING$ && ! slavo CaMeL Germanic ) { result . append ( $STRING$ , $STRING$ ) ; } else { result . append ( $STRING$ ) ; } index = index + $NUMBER$ ; } else if ( contains ( value , index + 1 , $NUMBER$ , $STRING$ ) && ! slavo CaMeL Germanic ) { result . append ( $STRING$ , $STRING$ ) ; index += $NUMBER$ ; } else if ( index == 0 && ( char CaMeL At ( value , index + 1 ) == $STRING$ || contains ( value , index + 1 , $NUMBER$ , ES _ EP _ EB _ EL _ EY _ IB _ IL _ IN _ IE _ EI _ ER ) ) ) { result . append ( $STRING$ , $STRING$ ) ; index += $NUMBER$ ; } else if ( ( contains ( value , index + 1 , $NUMBER$ , $STRING$ ) || char CaMeL At ( value , index + 1 ) == $STRING$ ) && ! contains ( value , 0 , $NUMBER$ , $STRING$ , $STRING$ , $STRING$ ) && ! contains ( value , index - 1 , 1 , $STRING$ , $STRING$ ) && ! contains ( value , index - 1 , $NUMBER$ , $STRING$ , $STRING$ ) ) { result . append ( $STRING$ , $STRING$ ) ; index += $NUMBER$ ; } else if ( contains ( value , index + 1 , 1 , $STRING$ , $STRING$ , $STRING$ ) || contains ( value , index - 1 , $NUMBER$ , $STRING$ , $STRING$ ) ) { if ( ( contains ( value , 0 , $NUMBER$ , $STRING$ , $STRING$ ) || contains ( value , 0 , $NUMBER$ , $STRING$ ) ) || contains ( value , index + 1 , $NUMBER$ , $STRING$ ) ) { result . append ( $STRING$ ) ; } else if ( contains ( value , index + 1 , $NUMBER$ , $STRING$ ) ) { result . append ( $STRING$ ) ; } else { result . append ( $STRING$ , $STRING$ ) ; } index += $NUMBER$ ; } else if ( char CaMeL At ( value , index + 1 ) == $STRING$ ) { index += $NUMBER$ ; result . append ( $STRING$ ) ; } else { index ++ ; result . append ( $STRING$ ) ; } return index ; }	 
return String CaMeL Utils . new CaMeL String CaMeL Utf 8 ( encode CaMeL Base 64 ( binary CaMeL Data , true ) ) ;  <CTX>  public static String encode CaMeL Base 64 String ( byte [ ] binary CaMeL Data ) { return String CaMeL Utils . new CaMeL String CaMeL Utf 8 ( encode CaMeL Base 64 ( binary CaMeL Data , true ) ) ; }	 
long len = get CaMeL Encode CaMeL Length ( binary CaMeL Data , MIME _ CHUNK _ SIZE , CHUNK _ SEPARATOR ) ;  <CTX>  public static byte [ ] encode CaMeL Base 64 ( byte [ ] binary CaMeL Data , boolean is CaMeL Chunked , boolean url CaMeL Safe , int max CaMeL Result CaMeL Size ) { if ( binary CaMeL Data == null || binary CaMeL Data . length == 0 ) { return binary CaMeL Data ; } long len = get CaMeL Encode CaMeL Length ( binary CaMeL Data , MIME _ CHUNK _ SIZE , CHUNK _ SEPARATOR ) ; if ( len > max CaMeL Result CaMeL Size ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + len + $STRING$ + max CaMeL Result CaMeL Size ) ; } Base 64 b 64 = is CaMeL Chunked ? new Base 64 ( url CaMeL Safe ) : new Base 64 ( 0 , CHUNK _ SEPARATOR , url CaMeL Safe ) ; return b 64 . encode ( binary CaMeL Data ) ; }	 
txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ;  <CTX>  public String ca@@ ver@@ phone ( String txt ) { if ( txt == null || txt . length ( ) == 0 ) { return $STRING$ ; } txt = txt . to CaMeL Lower CaMeL Case ( java . util . Locale . ENGLISH ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt + $STRING$ + $STRING$ ; return txt . substring ( 0 , $NUMBER$ ) ; }	 
return new String ( bytes , Charsets . ISO _ $NUMBER$ _ 1 ) ;  <CTX>  public static String new CaMeL String CaMeL Iso $NUMBER$ _ 1 ( final byte [ ] bytes ) { return new String ( bytes , Charsets . ISO _ $NUMBER$ _ 1 ) ; }	 
return Char CaMeL Sequence CaMeL Utils . region CaMeL Matches ( cs 1 , false , 0 , cs $NUMBER$ , 0 , Math . max ( cs 1 . length ( ) , cs $NUMBER$ . length ( ) ) ) ;  <CTX>  public static boolean equals ( final Char CaMeL Sequence cs 1 , final Char CaMeL Sequence cs $NUMBER$ ) { if ( cs 1 == cs $NUMBER$ ) { return true ; } if ( cs 1 == null || cs $NUMBER$ == null ) { return false ; } if ( cs 1 instanceof String && cs $NUMBER$ instanceof String ) { return cs 1 . equals ( cs $NUMBER$ ) ; } return Char CaMeL Sequence CaMeL Utils . region CaMeL Matches ( cs 1 , false , 0 , cs $NUMBER$ , 0 , Math . max ( cs 1 . length ( ) , cs $NUMBER$ . length ( ) ) ) ; }	 
private Object read CaMeL Resolve ( ) {  <CTX>  private Object read CaMeL Resolve ( ) { calculate CaMeL Hash CaMeL Code ( keys ) ; return this ; }	 
if ( read == 0 && inf . finished ( ) ) { return - 1 ;  <CTX>  public int read ( byte [ ] buffer , int start , int length ) throws IO CaMeL Exception { if ( closed ) { throw new IO CaMeL Exception ( $STRING$ ) ; } if ( inf . finished ( ) || current == null ) { return - 1 ; } if ( start <= buffer . length && length >= 0 && start >= 0 && buffer . length - start >= length ) { if ( current . get CaMeL Method ( ) == Zip CaMeL Archive CaMeL Output CaMeL Stream . STORED ) { int csize = ( int ) current . get CaMeL Size ( ) ; if ( read CaMeL Bytes CaMeL Of CaMeL Entry >= csize ) { return - 1 ; } if ( offset CaMeL In CaMeL Buffer >= length CaMeL Of CaMeL Last CaMeL Read ) { offset CaMeL In CaMeL Buffer = 0 ; if ( ( length CaMeL Of CaMeL Last CaMeL Read = in . read ( buf ) ) == - 1 ) { return - 1 ; } count ( length CaMeL Of CaMeL Last CaMeL Read ) ; bytes CaMeL Read CaMeL From CaMeL Stream += length CaMeL Of CaMeL Last CaMeL Read ; } int to CaMeL Read = length > length CaMeL Of CaMeL Last CaMeL Read ? length CaMeL Of CaMeL Last CaMeL Read - offset CaMeL In CaMeL Buffer : length ; if ( ( csize - read CaMeL Bytes CaMeL Of CaMeL Entry ) < to CaMeL Read ) { to CaMeL Read = csize - read CaMeL Bytes CaMeL Of CaMeL Entry ; } System . arraycopy ( buf , offset CaMeL In CaMeL Buffer , buffer , start , to CaMeL Read ) ; offset CaMeL In CaMeL Buffer += to CaMeL Read ; read CaMeL Bytes CaMeL Of CaMeL Entry += to CaMeL Read ; crc . update ( buffer , start , to CaMeL Read ) ; return to CaMeL Read ; } if ( inf . needs CaMeL Input ( ) ) { fill ( ) ; if ( length CaMeL Of CaMeL Last CaMeL Read > 0 ) { bytes CaMeL Read CaMeL From CaMeL Stream += length CaMeL Of CaMeL Last CaMeL Read ; } } int read = 0 ; try { read = inf . inflate ( buffer , start , length ) ; } catch ( Data CaMeL Format CaMeL Exception e ) { throw new Zip CaMeL Exception ( e . get CaMeL Message ( ) ) ; } if ( read == 0 && inf . finished ( ) ) { return - 1 ; } crc . update ( buffer , start , read ) ; return read ; } throw new Array CaMeL Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception ( ) ; }	 
curr CaMeL Entry = new Tar CaMeL Archive CaMeL Entry ( header CaMeL Buf ) ;  <CTX>  public Tar CaMeL Archive CaMeL Entry get CaMeL Next CaMeL Tar CaMeL Entry ( ) throws IO CaMeL Exception { if ( has CaMeL Hit CaMeL EOF ) { return null ; } if ( curr CaMeL Entry != null ) { long num CaMeL To CaMeL Skip = entry CaMeL Size - entry CaMeL Offset ; while ( num CaMeL To CaMeL Skip > 0 ) { long skipped = skip ( num CaMeL To CaMeL Skip ) ; if ( skipped <= 0 ) { throw new Runtime CaMeL Exception ( $STRING$ ) ; } num CaMeL To CaMeL Skip -= skipped ; } read CaMeL Buf = null ; } byte [ ] header CaMeL Buf = get CaMeL Record ( ) ; if ( has CaMeL Hit CaMeL EOF ) { curr CaMeL Entry = null ; return null ; } curr CaMeL Entry = new Tar CaMeL Archive CaMeL Entry ( header CaMeL Buf ) ; entry CaMeL Offset = 0 ; entry CaMeL Size = curr CaMeL Entry . get CaMeL Size ( ) ; if ( curr CaMeL Entry . is CaMeL GNU CaMeL Long CaMeL Name CaMeL Entry ( ) ) { String CaMeL Buffer long CaMeL Name = new String CaMeL Buffer ( ) ; byte [ ] buf = new byte [ SMALL _ BUFFER _ SIZE ] ; int length = 0 ; while ( ( length = read ( buf ) ) >= 0 ) { long CaMeL Name . append ( new String ( buf , 0 , length ) ) ; } get CaMeL Next CaMeL Entry ( ) ; if ( curr CaMeL Entry == null ) { return null ; } if ( long CaMeL Name . length ( ) > 0 && long CaMeL Name . char CaMeL At ( long CaMeL Name . length ( ) - 1 ) == 0 ) { long CaMeL Name . delete CaMeL Char CaMeL At ( long CaMeL Name . length ( ) - 1 ) ; } curr CaMeL Entry . set CaMeL Name ( long CaMeL Name . to CaMeL String ( ) ) ; } if ( curr CaMeL Entry . is CaMeL Pax CaMeL Header ( ) ) { pax CaMeL Headers ( ) ; } if ( curr CaMeL Entry . is CaMeL GNU CaMeL Sparse ( ) ) { read CaMeL GNU CaMeL Sparse ( ) ; } entry CaMeL Size = curr CaMeL Entry . get CaMeL Size ( ) ; return curr CaMeL Entry ; }	 
boolean all CaMeL NUL = true ; for ( int i = start ; i < end ; i ++ ) { if ( buffer [ i ] != 0 ) { all CaMeL NUL = false ; break ; } } if ( all CaMeL NUL ) {  <CTX>  public static long parse CaMeL Octal ( final byte [ ] buffer , final int offset , final int length ) { long result = 0 ; int end = offset + length ; int start = offset ; if ( length < $NUMBER$ ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + length + $STRING$ ) ; } boolean all CaMeL NUL = true ; for ( int i = start ; i < end ; i ++ ) { if ( buffer [ i ] != 0 ) { all CaMeL NUL = false ; break ; } } if ( all CaMeL NUL ) { return 0 L ; } while ( start < end ) { if ( buffer [ start ] == $STRING$ ) { start ++ ; } else { break ; } } byte trailer ; trailer = buffer [ end - 1 ] ; if ( trailer == 0 || trailer == $STRING$ ) { end -- ; } else { throw new Illegal CaMeL Argument CaMeL Exception ( exception CaMeL Message ( buffer , offset , length , end - 1 , trailer ) ) ; } trailer = buffer [ end - 1 ] ; if ( trailer == 0 || trailer == $STRING$ ) { end -- ; } for ( ; start < end ; start ++ ) { final byte current CaMeL Byte = buffer [ start ] ; if ( current CaMeL Byte < $STRING$ || current CaMeL Byte > $STRING$ ) { throw new Illegal CaMeL Argument CaMeL Exception ( exception CaMeL Message ( buffer , offset , length , start , current CaMeL Byte ) ) ; } result = ( result << $NUMBER$ ) + ( current CaMeL Byte - $STRING$ ) ; } return result ; }	 
if ( raw CaMeL Central CaMeL Directory CaMeL Data . length != expected CaMeL Length ) {  <CTX>  public void reparse CaMeL Central CaMeL Directory CaMeL Data ( boolean has CaMeL Uncompressed CaMeL Size , boolean has CaMeL Compressed CaMeL Size , boolean has CaMeL Relative CaMeL Header CaMeL Offset , boolean has CaMeL Disk CaMeL Start ) throws Zip CaMeL Exception { if ( raw CaMeL Central CaMeL Directory CaMeL Data != null ) { int expected CaMeL Length = ( has CaMeL Uncompressed CaMeL Size ? DWORD : 0 ) + ( has CaMeL Compressed CaMeL Size ? DWORD : 0 ) + ( has CaMeL Relative CaMeL Header CaMeL Offset ? DWORD : 0 ) + ( has CaMeL Disk CaMeL Start ? WORD : 0 ) ; if ( raw CaMeL Central CaMeL Directory CaMeL Data . length != expected CaMeL Length ) { throw new Zip CaMeL Exception ( $STRING$ + $STRING$ + $STRING$ + $STRING$ + expected CaMeL Length + $STRING$ + raw CaMeL Central CaMeL Directory CaMeL Data . length ) ; } int offset = 0 ; if ( has CaMeL Uncompressed CaMeL Size ) { size = new Zip CaMeL Eight CaMeL Byte CaMeL Integer ( raw CaMeL Central CaMeL Directory CaMeL Data , offset ) ; offset += DWORD ; } if ( has CaMeL Compressed CaMeL Size ) { compressed CaMeL Size = new Zip CaMeL Eight CaMeL Byte CaMeL Integer ( raw CaMeL Central CaMeL Directory CaMeL Data , offset ) ; offset += DWORD ; } if ( has CaMeL Relative CaMeL Header CaMeL Offset ) { relative CaMeL Header CaMeL Offset = new Zip CaMeL Eight CaMeL Byte CaMeL Integer ( raw CaMeL Central CaMeL Directory CaMeL Data , offset ) ; offset += DWORD ; } if ( has CaMeL Disk CaMeL Start ) { disk CaMeL Start = new Zip CaMeL Long ( raw CaMeL Central CaMeL Directory CaMeL Data , offset ) ; offset += WORD ; } } }	 
dict CaMeL Size |= ( coder . properties [ i + 1 ] << ( 8 * i ) ) ;  <CTX>  Input CaMeL Stream decode ( final Input CaMeL Stream in , final Coder coder , byte [ ] password ) throws IO CaMeL Exception { byte props CaMeL Byte = coder . properties [ 0 ] ; long dict CaMeL Size = coder . properties [ 1 ] ; for ( int i = 1 ; i < $NUMBER$ ; i ++ ) { dict CaMeL Size |= ( coder . properties [ i + 1 ] << ( 8 * i ) ) ; } if ( dict CaMeL Size > LZMA CaMeL Input CaMeL Stream . DICT _ SIZE _ MAX ) { throw new IO CaMeL Exception ( $STRING$ ) ; } return new LZMA CaMeL Input CaMeL Stream ( in , - 1 , props CaMeL Byte , ( int ) dict CaMeL Size ) ; }	 
if ( ch == $STRING$ ) {  <CTX>  Map < String , String > parse CaMeL Pax CaMeL Headers ( final Input CaMeL Stream i ) throws IO CaMeL Exception { final Map < String , String > headers = new Hash CaMeL Map < String , String > ( global CaMeL Pax CaMeL Headers ) ; while ( true ) { int ch ; int len = 0 ; int read = 0 ; while ( ( ch = i . read ( ) ) != - 1 ) { read ++ ; if ( ch == $STRING$ ) { final Byte CaMeL Array CaMeL Output CaMeL Stream coll = new Byte CaMeL Array CaMeL Output CaMeL Stream ( ) ; while ( ( ch = i . read ( ) ) != - 1 ) { read ++ ; if ( ch == $STRING$ ) { final String keyword = coll . to CaMeL String ( Charset CaMeL Names . UTF _ 8 ) ; final int rest CaMeL Len = len - read ; if ( rest CaMeL Len == 1 ) { headers . remove ( keyword ) ; } else { final byte [ ] rest = new byte [ rest CaMeL Len ] ; final int got = IO CaMeL Utils . read CaMeL Fully ( i , rest ) ; if ( got != rest CaMeL Len ) { throw new IO CaMeL Exception ( $STRING$ + $STRING$ + rest CaMeL Len + $STRING$ + got ) ; } final String value = new String ( rest , 0 , rest CaMeL Len - 1 , Charset CaMeL Names . UTF _ 8 ) ; headers . put ( keyword , value ) ; } break ; } coll . write ( ( byte ) ch ) ; } break ; } len *= $NUMBER$ ; len += ch - $STRING$ ; } if ( ch == - 1 ) { break ; } } return headers ; }	 
if ( get CaMeL Name ( ) . ends CaMeL With ( $STRING$ ) ) {  <CTX>  public boolean is CaMeL Directory ( ) { if ( file != null ) { return file . is CaMeL Directory ( ) ; } if ( link CaMeL Flag == LF _ DIR ) { return true ; } if ( get CaMeL Name ( ) . ends CaMeL With ( $STRING$ ) ) { return true ; } return false ; }	 
final long TWO _ TO _ 32 = 0 x $NUMBER$ L ; if ( l >= TWO _ TO _ 32 ) {  <CTX>  private static Zip CaMeL Long unix CaMeL Time CaMeL To CaMeL Zip CaMeL Long ( long l ) { final long TWO _ TO _ 32 = 0 x $NUMBER$ L ; if ( l >= TWO _ TO _ 32 ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + l ) ; } return new Zip CaMeL Long ( l ) ; }	 
if ( current == $STRING$ ) {  <CTX>  public int read ( ) throws IO CaMeL Exception { int current = super . read ( ) ; if ( current == $STRING$ ) { line CaMeL Counter ++ ; } last CaMeL Char = current ; return last CaMeL Char ; }	 
return new Linked CaMeL Hash CaMeL Map < String , Integer > ( this . header CaMeL Map ) ;  <CTX>  public Map < String , Integer > get CaMeL Header CaMeL Map ( ) { return new Linked CaMeL Hash CaMeL Map < String , Integer > ( this . header CaMeL Map ) ; }	 
final boolean empty CaMeL Header = header . trim ( ) . is CaMeL Empty ( ) ;  <CTX>	 
if ( new CaMeL Record && ( c < $STRING$ || c > $STRING$ && c < $STRING$ || c > $STRING$ && c < $STRING$ || c > $STRING$ ) ) {  <CTX>	 
if ( new CaMeL Record && ( c < 0 x $NUMBER$ || c > 0 x $NUMBER$ && c < 0 x $NUMBER$ || c > 0 x $NUMBER$ B && c < 0 x $NUMBER$ D || c > 0 x $NUMBER$ E ) ) { quote = true ; } else if ( c <= COMMENT ) {  <CTX>	 
Type CaMeL Adapter t = new Type CaMeL Adapter CaMeL Runtime CaMeL Type CaMeL Wrapper ( context , type CaMeL Adapter , field CaMeL Type . get CaMeL Type ( ) ) ;  <CTX>  void write ( Json CaMeL Writer writer , Object value ) throws IO CaMeL Exception , Illegal CaMeL Access CaMeL Exception { Object field CaMeL Value = field . get ( value ) ; Type CaMeL Adapter t = new Type CaMeL Adapter CaMeL Runtime CaMeL Type CaMeL Wrapper ( context , type CaMeL Adapter , field CaMeL Type . get CaMeL Type ( ) ) ; t . write ( writer , field CaMeL Value ) ; }	 
if ( last == NUMBER _ CHAR _ DIGIT && fits CaMeL In CaMeL Long && ( value != Long . MIN _ VALUE || negative ) ) {  <CTX>  private int peek CaMeL Number ( ) throws IO CaMeL Exception { char [ ] buffer = this . buffer ; int p = pos ; int l = limit ; long value = 0 ; boolean negative = false ; boolean fits CaMeL In CaMeL Long = true ; int last = NUMBER _ CHAR _ NONE ; int i = 0 ; characters CaMeL Of CaMeL Number : for ( ; true ; i ++ ) { if ( p + i == l ) { if ( i == buffer . length ) { return PEEKED _ NONE ; } if ( ! fill CaMeL Buffer ( i + 1 ) ) { break ; } p = pos ; l = limit ; } char c = buffer [ p + i ] ; switch ( c ) { case $STRING$ : if ( last == NUMBER _ CHAR _ NONE ) { negative = true ; last = NUMBER _ CHAR _ SIGN ; continue ; } else if ( last == NUMBER _ CHAR _ EXP _ E ) { last = NUMBER _ CHAR _ EXP _ SIGN ; continue ; } return PEEKED _ NONE ; case $STRING$ : if ( last == NUMBER _ CHAR _ EXP _ E ) { last = NUMBER _ CHAR _ EXP _ SIGN ; continue ; } return PEEKED _ NONE ; case $STRING$ : case $STRING$ : if ( last == NUMBER _ CHAR _ DIGIT || last == NUMBER _ CHAR _ FRACTION _ DIGIT ) { last = NUMBER _ CHAR _ EXP _ E ; continue ; } return PEEKED _ NONE ; case $STRING$ : if ( last == NUMBER _ CHAR _ DIGIT ) { last = NUMBER _ CHAR _ DECIMAL ; continue ; } return PEEKED _ NONE ; default : if ( c < $STRING$ || c > $STRING$ ) { if ( ! is CaMeL Literal ( c ) ) { break characters CaMeL Of CaMeL Number ; } return PEEKED _ NONE ; } if ( last == NUMBER _ CHAR _ SIGN || last == NUMBER _ CHAR _ NONE ) { value = - ( c - $STRING$ ) ; last = NUMBER _ CHAR _ DIGIT ; } else if ( last == NUMBER _ CHAR _ DIGIT ) { if ( value == 0 ) { return PEEKED _ NONE ; } long new CaMeL Value = value * $NUMBER$ - ( c - $STRING$ ) ; fits CaMeL In CaMeL Long &= value > MIN _ INCOMPLETE _ INTEGER || ( value == MIN _ INCOMPLETE _ INTEGER && new CaMeL Value < value ) ; value = new CaMeL Value ; } else if ( last == NUMBER _ CHAR _ DECIMAL ) { last = NUMBER _ CHAR _ FRACTION _ DIGIT ; } else if ( last == NUMBER _ CHAR _ EXP _ E || last == NUMBER _ CHAR _ EXP _ SIGN ) { last = NUMBER _ CHAR _ EXP _ DIGIT ; } } } if ( last == NUMBER _ CHAR _ DIGIT && fits CaMeL In CaMeL Long && ( value != Long . MIN _ VALUE || negative ) ) { peeked CaMeL Long = negative ? value : - value ; pos += i ; return peeked = PEEKED _ LONG ; } else if ( last == NUMBER _ CHAR _ DIGIT || last == NUMBER _ CHAR _ FRACTION _ DIGIT || last == NUMBER _ CHAR _ EXP _ DIGIT ) { peeked CaMeL Number CaMeL Length = i ; return peeked = PEEKED _ NUMBER ; } else { return PEEKED _ NONE ; } }	 
if ( Double . is CaMeL Na CaMeL N ( value ) || Double . is CaMeL Infinite ( value ) ) {  <CTX>  public Json CaMeL Writer value ( double value ) throws IO CaMeL Exception { write CaMeL Deferred CaMeL Name ( ) ; if ( Double . is CaMeL Na CaMeL N ( value ) || Double . is CaMeL Infinite ( value ) ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + value ) ; } before CaMeL Value ( ) ; out . append ( Double . to CaMeL String ( value ) ) ; return this ; }	 
if ( in . peek ( ) != Json CaMeL Token . STRING ) { throw new Json CaMeL Parse CaMeL Exception ( $STRING$ ) ;  <CTX>  public Date read ( Json CaMeL Reader in ) throws IO CaMeL Exception { if ( in . peek ( ) != Json CaMeL Token . STRING ) { throw new Json CaMeL Parse CaMeL Exception ( $STRING$ ) ; } Date date = deserialize CaMeL To CaMeL Date ( in . next CaMeL String ( ) ) ; if ( date CaMeL Type == Date . class ) { return date ; } else if ( date CaMeL Type == Timestamp . class ) { return new Timestamp ( date . get CaMeL Time ( ) ) ; } else if ( date CaMeL Type == java . sql . Date . class ) { return new java . sql . Date ( date . get CaMeL Time ( ) ) ; } else { throw new Assertion CaMeL Error ( ) ; } }	 
char c = str . char CaMeL At ( i ++ ) ;  <CTX>  private final static int _ parse CaMeL Index ( String str ) { final int len = str . length ( ) ; if ( len == 0 || len > $NUMBER$ ) { return - 1 ; } for ( int i = 0 ; i < len ; ++ i ) { char c = str . char CaMeL At ( i ++ ) ; if ( c > $STRING$ || c < $STRING$ ) { return - 1 ; } } if ( len == $NUMBER$ ) { long l = Number CaMeL Input . parse CaMeL Long ( str ) ; if ( l > Integer . MAX _ VALUE ) { return - 1 ; } } return Number CaMeL Input . parse CaMeL Int ( str ) ; }	 
for ( int i = 0 ; i < len ; ++ i ) { char c = str . char CaMeL At ( i ) ;  <CTX>  private final static int _ parse CaMeL Index ( String str ) { final int len = str . length ( ) ; if ( len == 0 || len > $NUMBER$ ) { return - 1 ; } for ( int i = 0 ; i < len ; ++ i ) { char c = str . char CaMeL At ( i ) ; if ( c > $STRING$ || c < $STRING$ ) { return - 1 ; } } if ( len == $NUMBER$ ) { long l = Number CaMeL Input . parse CaMeL Long ( str ) ; if ( l > Integer . MAX _ VALUE ) { return - 1 ; } } return Number CaMeL Input . parse CaMeL Int ( str ) ; }	 
if ( ! _ has CaMeL Segments ) return _ current CaMeL Segment ;  <CTX>  public char [ ] get CaMeL Text CaMeL Buffer ( ) { if ( _ input CaMeL Start >= 0 ) return _ input CaMeL Buffer ; if ( _ result CaMeL Array != null ) return _ result CaMeL Array ; if ( _ result CaMeL String != null ) { return ( _ result CaMeL Array = _ result CaMeL String . to CaMeL Char CaMeL Array ( ) ) ; } if ( ! _ has CaMeL Segments ) return _ current CaMeL Segment ; return contents CaMeL As CaMeL Array ( ) ; }	 
throw new Json CaMeL Generation CaMeL Exception ( $STRING$ ,  <CTX>  public void write CaMeL Embedded CaMeL Object ( Object object ) throws IO CaMeL Exception { throw new Json CaMeL Generation CaMeL Exception ( $STRING$ , this ) ; }	 
if ( i <= max CaMeL Code ) {  <CTX>  private String _ handle CaMeL Odd CaMeL Name $NUMBER$ ( int start CaMeL Ptr , int hash , int [ ] codes ) throws IO CaMeL Exception { _ text CaMeL Buffer . reset CaMeL With CaMeL Shared ( _ input CaMeL Buffer , start CaMeL Ptr , ( _ input CaMeL Ptr - start CaMeL Ptr ) ) ; char [ ] out CaMeL Buf = _ text CaMeL Buffer . get CaMeL Current CaMeL Segment ( ) ; int out CaMeL Ptr = _ text CaMeL Buffer . get CaMeL Current CaMeL Segment CaMeL Size ( ) ; final int max CaMeL Code = codes . length ; while ( true ) { if ( _ input CaMeL Ptr >= _ input CaMeL End ) { if ( ! _ load CaMeL More ( ) ) { break ; } } char c = _ input CaMeL Buffer [ _ input CaMeL Ptr ] ; int i = ( int ) c ; if ( i <= max CaMeL Code ) { if ( codes [ i ] != 0 ) { break ; } } else if ( ! Character . is CaMeL Java CaMeL Identifier CaMeL Part ( c ) ) { break ; } ++ _ input CaMeL Ptr ; hash = ( hash * Chars CaMeL To CaMeL Name CaMeL Canonicalizer . HASH _ MULT ) + i ; out CaMeL Buf [ out CaMeL Ptr ++ ] = c ; if ( out CaMeL Ptr >= out CaMeL Buf . length ) { out CaMeL Buf = _ text CaMeL Buffer . finish CaMeL Current CaMeL Segment ( ) ; out CaMeL Ptr = 0 ; } } _ text CaMeL Buffer . set CaMeL Current CaMeL Length ( out CaMeL Ptr ) ; { Text CaMeL Buffer tb = _ text CaMeL Buffer ; char [ ] buf = tb . get CaMeL Text CaMeL Buffer ( ) ; int start = tb . get CaMeL Text CaMeL Offset ( ) ; int len = tb . size ( ) ; return _ symbols . find CaMeL Symbol ( buf , start , len , hash ) ; } }	 
return ( _ value CaMeL Type CaMeL Deserializer == null )  <CTX>  public boolean is CaMeL Cachable ( ) { return ( _ value CaMeL Type CaMeL Deserializer == null ) && ( _ ignorable CaMeL Properties == null ) ; }	 
return ( previous != null ) && previous . equals ( ann ) ;  <CTX>  protected final boolean _ add ( Annotation ann ) { if ( _ annotations == null ) { _ annotations = new Hash CaMeL Map < Class < ? extends Annotation > , Annotation > ( ) ; } Annotation previous = _ annotations . put ( ann . annotation CaMeL Type ( ) , ann ) ; return ( previous != null ) && previous . equals ( ann ) ; }	 
if ( ext . handle CaMeL Property CaMeL Value ( p , ctxt , prop CaMeL Name , buffer ) ) {  <CTX>  protected Object deserialize CaMeL Using CaMeL Property CaMeL Based CaMeL With CaMeL External CaMeL Type CaMeL Id ( Json CaMeL Parser p , Deserialization CaMeL Context ctxt ) throws IO CaMeL Exception { final External CaMeL Type CaMeL Handler ext = _ external CaMeL Type CaMeL Id CaMeL Handler . start ( ) ; final Property CaMeL Based CaMeL Creator creator = _ property CaMeL Based CaMeL Creator ; Property CaMeL Value CaMeL Buffer buffer = creator . start CaMeL Building ( p , ctxt , _ object CaMeL Id CaMeL Reader ) ; Token CaMeL Buffer tokens = new Token CaMeL Buffer ( p ) ; tokens . write CaMeL Start CaMeL Object ( ) ; Json CaMeL Token t = p . get CaMeL Current CaMeL Token ( ) ; for ( ; t == Json CaMeL Token . FIELD _ NAME ; t = p . next CaMeL Token ( ) ) { String prop CaMeL Name = p . get CaMeL Current CaMeL Name ( ) ; p . next CaMeL Token ( ) ; Settable CaMeL Bean CaMeL Property creator CaMeL Prop = creator . find CaMeL Creator CaMeL Property ( prop CaMeL Name ) ; if ( creator CaMeL Prop != null ) { if ( ext . handle CaMeL Property CaMeL Value ( p , ctxt , prop CaMeL Name , buffer ) ) { ; } else { if ( buffer . assign CaMeL Parameter ( creator CaMeL Prop , _ deserialize CaMeL With CaMeL Error CaMeL Wrapping ( p , ctxt , creator CaMeL Prop ) ) ) { t = p . next CaMeL Token ( ) ; Object bean ; try { bean = creator . build ( ctxt , buffer ) ; } catch ( Exception e ) { wrap CaMeL And CaMeL Throw ( e , _ bean CaMeL Type . get CaMeL Raw CaMeL Class ( ) , prop CaMeL Name , ctxt ) ; continue ; } while ( t == Json CaMeL Token . FIELD _ NAME ) { p . next CaMeL Token ( ) ; tokens . copy CaMeL Current CaMeL Structure ( p ) ; t = p . next CaMeL Token ( ) ; } if ( bean . get CaMeL Class ( ) != _ bean CaMeL Type . get CaMeL Raw CaMeL Class ( ) ) { throw ctxt . mapping CaMeL Exception ( $STRING$ ) ; } return ext . complete ( p , ctxt , bean ) ; } } continue ; } if ( buffer . read CaMeL Id CaMeL Property ( prop CaMeL Name ) ) { continue ; } Settable CaMeL Bean CaMeL Property prop = _ bean CaMeL Properties . find ( prop CaMeL Name ) ; if ( prop != null ) { buffer . buffer CaMeL Property ( prop , prop . deserialize ( p , ctxt ) ) ; continue ; } if ( ext . handle CaMeL Property CaMeL Value ( p , ctxt , prop CaMeL Name , null ) ) { continue ; } if ( _ ignorable CaMeL Props != null && _ ignorable CaMeL Props . contains ( prop CaMeL Name ) ) { handle CaMeL Ignored CaMeL Property ( p , ctxt , handled CaMeL Type ( ) , prop CaMeL Name ) ; continue ; } if ( _ any CaMeL Setter != null ) { buffer . buffer CaMeL Any CaMeL Property ( _ any CaMeL Setter , prop CaMeL Name , _ any CaMeL Setter . deserialize ( p , ctxt ) ) ; } } try { return ext . complete ( p , ctxt , buffer , creator ) ; } catch ( Exception e ) { wrap CaMeL Instantiation CaMeL Problem ( e , ctxt ) ; return null ; } }	 
|| _ has CaMeL Annotation ( a , Json CaMeL Raw CaMeL Value . class ) ) {  <CTX>  public Property CaMeL Name find CaMeL Name CaMeL For CaMeL Serialization ( Annotated a ) { String name = null ; Json CaMeL Getter jg = _ find CaMeL Annotation ( a , Json CaMeL Getter . class ) ; if ( jg != null ) { name = jg . value ( ) ; } else { Json CaMeL Property p@@ ann = _ find CaMeL Annotation ( a , Json CaMeL Property . class ) ; if ( p@@ ann != null ) { name = p@@ ann . value ( ) ; } else if ( _ has CaMeL Annotation ( a , Json CaMeL Serialize . class ) || _ has CaMeL Annotation ( a , Json CaMeL View . class ) || _ has CaMeL Annotation ( a , Json CaMeL Raw CaMeL Value . class ) ) { name = $STRING$ ; } else { return null ; } } return Property CaMeL Name . construct ( name ) ; }	 
visit CaMeL Float CaMeL Format ( visitor , type CaMeL Hint , Json CaMeL Parser . Number CaMeL Type . BIG _ INTEGER ) ;  <CTX>  public void accept CaMeL Json CaMeL Format CaMeL Visitor ( Json CaMeL Format CaMeL Visitor CaMeL Wrapper visitor , Java CaMeL Type type CaMeL Hint ) throws Json CaMeL Mapping CaMeL Exception { if ( _ is CaMeL Int ) { visit CaMeL Int CaMeL Format ( visitor , type CaMeL Hint , Json CaMeL Parser . Number CaMeL Type . BIG _ INTEGER ) ; } else { Class < ? > h = handled CaMeL Type ( ) ; if ( h == Big CaMeL Decimal . class ) { visit CaMeL Float CaMeL Format ( visitor , type CaMeL Hint , Json CaMeL Parser . Number CaMeL Type . BIG _ INTEGER ) ; } else { visitor . expect CaMeL Number CaMeL Format ( type CaMeL Hint ) ; } } }	 
return new Simple CaMeL Type ( subclass , _ bindings , _ super CaMeL Class , _ super CaMeL Interfaces ,  <CTX>  protected Java CaMeL Type _ narrow ( Class < ? > subclass ) { if ( _ class == subclass ) { return this ; } return new Simple CaMeL Type ( subclass , _ bindings , _ super CaMeL Class , _ super CaMeL Interfaces , _ value CaMeL Handler , _ type CaMeL Handler , _ as CaMeL Static ) ; }	 
if ( format . get CaMeL Shape ( ) == Json CaMeL Format . Shape . STRING ) {  <CTX>  public Json CaMeL Serializer < ? > create CaMeL Contextual ( Serializer CaMeL Provider serializers , Bean CaMeL Property property ) throws Json CaMeL Mapping CaMeL Exception { if ( property != null ) { Json CaMeL Format . Value format = serializers . get CaMeL Annotation CaMeL Introspector ( ) . find CaMeL Format ( ( Annotated ) property . get CaMeL Member ( ) ) ; if ( format != null ) { Json CaMeL Format . Shape shape = format . get CaMeL Shape ( ) ; if ( shape . is CaMeL Numeric ( ) ) { return with CaMeL Format ( Boolean . TRUE , null ) ; } if ( format . get CaMeL Shape ( ) == Json CaMeL Format . Shape . STRING ) { Time CaMeL Zone tz = format . get CaMeL Time CaMeL Zone ( ) ; final String pattern = format . has CaMeL Pattern ( ) ? format . get CaMeL Pattern ( ) : Std CaMeL Date CaMeL Format . DATE _ FORMAT _ STR _ ISO $NUMBER$ ; final Locale loc = format . has CaMeL Locale ( ) ? format . get CaMeL Locale ( ) : serializers . get CaMeL Locale ( ) ; Simple CaMeL Date CaMeL Format df = new Simple CaMeL Date CaMeL Format ( pattern , loc ) ; if ( tz == null ) { tz = serializers . get CaMeL Time CaMeL Zone ( ) ; } df . set CaMeL Time CaMeL Zone ( tz ) ; return with CaMeL Format ( Boolean . FALSE , df ) ; } } } return this ; }	 
sb . append ( $STRING$ ) ;  <CTX>  public String CaMeL Builder get CaMeL Generic CaMeL Signature ( String CaMeL Builder sb ) { _ class CaMeL Signature ( _ class , sb , false ) ; sb . append ( $STRING$ ) ; sb = _ referenced CaMeL Type . get CaMeL Generic CaMeL Signature ( sb ) ; sb . append ( $STRING$ ) ; return sb ; }	 
return _ bind CaMeL And CaMeL Read CaMeL Values ( _ consider CaMeL Filter ( _ parser CaMeL Factory . create CaMeL Parser ( src ) ,  <CTX>  public < T > Mapping CaMeL Iterator < T > read CaMeL Values ( byte [ ] src , int offset , int length ) throws IO CaMeL Exception , Json CaMeL Processing CaMeL Exception { if ( _ data CaMeL Format CaMeL Readers != null ) { return _ detect CaMeL Bind CaMeL And CaMeL Read CaMeL Values ( _ data CaMeL Format CaMeL Readers . find CaMeL Format ( src , offset , length ) , false ) ; } return _ bind CaMeL And CaMeL Read CaMeL Values ( _ consider CaMeL Filter ( _ parser CaMeL Factory . create CaMeL Parser ( src ) , true ) ) ; }	 
found = key . equals ( prop . get CaMeL Name ( ) ) ;  <CTX>  public void remove ( Settable CaMeL Bean CaMeL Property prop CaMeL To CaMeL Rm ) { Array CaMeL List < Settable CaMeL Bean CaMeL Property > props = new Array CaMeL List < Settable CaMeL Bean CaMeL Property > ( _ size ) ; String key = get CaMeL Property CaMeL Name ( prop CaMeL To CaMeL Rm ) ; boolean found = false ; for ( int i = 1 , end = _ hash CaMeL Area . length ; i < end ; i += $NUMBER$ ) { Settable CaMeL Bean CaMeL Property prop = ( Settable CaMeL Bean CaMeL Property ) _ hash CaMeL Area [ i ] ; if ( prop == null ) { continue ; } if ( ! found ) { found = key . equals ( prop . get CaMeL Name ( ) ) ; if ( found ) { _ props CaMeL In CaMeL Order [ _ find CaMeL From CaMeL Ordered ( prop ) ] = null ; continue ; } } props . add ( prop ) ; } if ( ! found ) { throw new No CaMeL Such CaMeL Element CaMeL Exception ( $STRING$ + prop CaMeL To CaMeL Rm . get CaMeL Name ( ) + $STRING$ ) ; } init ( props ) ; }	 
if ( raw == String . class || raw == Object . class ) {  <CTX>  public static Std CaMeL Key CaMeL Deserializer for CaMeL Type ( Class < ? > raw ) { int kind ; if ( raw == String . class || raw == Object . class ) { return String CaMeL KD . for CaMeL Type ( raw ) ; } else if ( raw == UUID . class ) { kind = TYPE _ UUID ; } else if ( raw == Integer . class ) { kind = TYPE _ INT ; } else if ( raw == Long . class ) { kind = TYPE _ LONG ; } else if ( raw == Date . class ) { kind = TYPE _ DATE ; } else if ( raw == Calendar . class ) { kind = TYPE _ CALENDAR ; } else if ( raw == Boolean . class ) { kind = TYPE _ BOOLEAN ; } else if ( raw == Byte . class ) { kind = TYPE _ BYTE ; } else if ( raw == Character . class ) { kind = TYPE _ CHAR ; } else if ( raw == Short . class ) { kind = TYPE _ SHORT ; } else if ( raw == Float . class ) { kind = TYPE _ FLOAT ; } else if ( raw == Double . class ) { kind = TYPE _ DOUBLE ; } else if ( raw == URI . class ) { kind = TYPE _ URI ; } else if ( raw == URL . class ) { kind = TYPE _ URL ; } else if ( raw == Class . class ) { kind = TYPE _ CLASS ; } else if ( raw == Locale . class ) { From CaMeL String CaMeL Deserializer < ? > deser = From CaMeL String CaMeL Deserializer . find CaMeL Deserializer ( Locale . class ) ; return new Std CaMeL Key CaMeL Deserializer ( TYPE _ LOCALE , raw , deser ) ; } else if ( raw == Currency . class ) { From CaMeL String CaMeL Deserializer < ? > deser = From CaMeL String CaMeL Deserializer . find CaMeL Deserializer ( Currency . class ) ; return new Std CaMeL Key CaMeL Deserializer ( TYPE _ CURRENCY , raw , deser ) ; } else { return null ; } return new Std CaMeL Key CaMeL Deserializer ( kind , raw ) ; }	 
if ( buffer . assign CaMeL Parameter ( creator CaMeL Prop , creator CaMeL Prop . deserialize ( p , ctxt ) ) ) { t = p . next CaMeL Token ( ) ; Object bean ; try { bean = creator . build ( ctxt , buffer ) ; } catch ( Exception e ) { wrap CaMeL And CaMeL Throw ( e , _ bean CaMeL Type . get CaMeL Raw CaMeL Class ( ) , prop CaMeL Name , ctxt ) ; continue ; } while ( t == Json CaMeL Token . FIELD _ NAME ) { p . next CaMeL Token ( ) ; tokens . copy CaMeL Current CaMeL Structure ( p ) ; t = p . next CaMeL Token ( ) ; } tokens . write CaMeL End CaMeL Object ( ) ; if ( bean . get CaMeL Class ( ) != _ bean CaMeL Type . get CaMeL Raw CaMeL Class ( ) ) { ctxt . report CaMeL Mapping CaMeL Exception ( $STRING$ ) ; return null ; } return _ unwrapped CaMeL Property CaMeL Handler . process CaMeL Unwrapped ( p , ctxt , bean , tokens ) ; }  <CTX>  protected Object deserialize CaMeL Using CaMeL Property CaMeL Based CaMeL With CaMeL Unwrapped ( Json CaMeL Parser p , Deserialization CaMeL Context ctxt ) throws IO CaMeL Exception , Json CaMeL Processing CaMeL Exception { final Property CaMeL Based CaMeL Creator creator = _ property CaMeL Based CaMeL Creator ; Property CaMeL Value CaMeL Buffer buffer = creator . start CaMeL Building ( p , ctxt , _ object CaMeL Id CaMeL Reader ) ; Token CaMeL Buffer tokens = new Token CaMeL Buffer ( p , ctxt ) ; tokens . write CaMeL Start CaMeL Object ( ) ; Json CaMeL Token t = p . get CaMeL Current CaMeL Token ( ) ; for ( ; t == Json CaMeL Token . FIELD _ NAME ; t = p . next CaMeL Token ( ) ) { String prop CaMeL Name = p . get CaMeL Current CaMeL Name ( ) ; p . next CaMeL Token ( ) ; Settable CaMeL Bean CaMeL Property creator CaMeL Prop = creator . find CaMeL Creator CaMeL Property ( prop CaMeL Name ) ; if ( creator CaMeL Prop != null ) { if ( buffer . assign CaMeL Parameter ( creator CaMeL Prop , creator CaMeL Prop . deserialize ( p , ctxt ) ) ) { t = p . next CaMeL Token ( ) ; Object bean ; try { bean = creator . build ( ctxt , buffer ) ; } catch ( Exception e ) { wrap CaMeL And CaMeL Throw ( e , _ bean CaMeL Type . get CaMeL Raw CaMeL Class ( ) , prop CaMeL Name , ctxt ) ; continue ; } while ( t == Json CaMeL Token . FIELD _ NAME ) { p . next CaMeL Token ( ) ; tokens . copy CaMeL Current CaMeL Structure ( p ) ; t = p . next CaMeL Token ( ) ; } tokens . write CaMeL End CaMeL Object ( ) ; if ( bean . get CaMeL Class ( ) != _ bean CaMeL Type . get CaMeL Raw CaMeL Class ( ) ) { ctxt . report CaMeL Mapping CaMeL Exception ( $STRING$ ) ; return null ; } return _ unwrapped CaMeL Property CaMeL Handler . process CaMeL Unwrapped ( p , ctxt , bean , tokens ) ; } continue ; } if ( buffer . read CaMeL Id CaMeL Property ( prop CaMeL Name ) ) { continue ; } Settable CaMeL Bean CaMeL Property prop = _ bean CaMeL Properties . find ( prop CaMeL Name ) ; if ( prop != null ) { buffer . buffer CaMeL Property ( prop , prop . deserialize ( p , ctxt ) ) ; continue ; } if ( _ ignorable CaMeL Props != null && _ ignorable CaMeL Props . contains ( prop CaMeL Name ) ) { handle CaMeL Ignored CaMeL Property ( p , ctxt , handled CaMeL Type ( ) , prop CaMeL Name ) ; continue ; } tokens . write CaMeL Field CaMeL Name ( prop CaMeL Name ) ; tokens . copy CaMeL Current CaMeL Structure ( p ) ; if ( _ any CaMeL Setter != null ) { buffer . buffer CaMeL Any CaMeL Property ( _ any CaMeL Setter , prop CaMeL Name , _ any CaMeL Setter . deserialize ( p , ctxt ) ) ; } } Object bean ; try { bean = creator . build ( ctxt , buffer ) ; } catch ( Exception e ) { return wrap CaMeL Instantiation CaMeL Problem ( e , ctxt ) ; } return _ unwrapped CaMeL Property CaMeL Handler . process CaMeL Unwrapped ( p , ctxt , bean , tokens ) ; }	 
ignored = ign@@ or@@ als . get CaMeL Ignored ( ) ;  <CTX>  protected void add CaMeL Bean CaMeL Props ( Deserialization CaMeL Context ctxt , Bean CaMeL Description bean CaMeL Desc , Bean CaMeL Deserializer CaMeL Builder builder ) throws Json CaMeL Mapping CaMeL Exception { final boolean is CaMeL Concrete = ! bean CaMeL Desc . get CaMeL Type ( ) . is CaMeL Abstract ( ) ; final Settable CaMeL Bean CaMeL Property [ ] creator CaMeL Props = is CaMeL Concrete ? builder . get CaMeL Value CaMeL Instantiator ( ) . get CaMeL From CaMeL Object CaMeL Arguments ( ctxt . get CaMeL Config ( ) ) : null ; final boolean has CaMeL Creator CaMeL Props = ( creator CaMeL Props != null ) ; Json CaMeL Ignore CaMeL Properties . Value ign@@ or@@ als = ctxt . get CaMeL Config ( ) . get CaMeL Default CaMeL Property CaMeL Ign@@ or@@ als ( bean CaMeL Desc . get CaMeL Bean CaMeL Class ( ) , bean CaMeL Desc . get CaMeL Class CaMeL Info ( ) ) ; Set < String > ignored ; if ( ign@@ or@@ als != null ) { boolean ignore CaMeL Any = ign@@ or@@ als . get CaMeL Ignore CaMeL Unknown ( ) ; builder . set CaMeL Ignore CaMeL Unknown CaMeL Properties ( ignore CaMeL Any ) ; ignored = ign@@ or@@ als . get CaMeL Ignored ( ) ; for ( String prop CaMeL Name : ignored ) { builder . add CaMeL Ignorable ( prop CaMeL Name ) ; } } else { ignored = Collections . empty CaMeL Set ( ) ; } Annotated CaMeL Method any CaMeL Setter CaMeL Method = bean CaMeL Desc . find CaMeL Any CaMeL Setter ( ) ; Annotated CaMeL Member any CaMeL Setter CaMeL Field = null ; if ( any CaMeL Setter CaMeL Method != null ) { builder . set CaMeL Any CaMeL Setter ( construct CaMeL Any CaMeL Setter ( ctxt , bean CaMeL Desc , any CaMeL Setter CaMeL Method ) ) ; } else { any CaMeL Setter CaMeL Field = bean CaMeL Desc . find CaMeL Any CaMeL Setter CaMeL Field ( ) ; if ( any CaMeL Setter CaMeL Field != null ) { builder . set CaMeL Any CaMeL Setter ( construct CaMeL Any CaMeL Setter ( ctxt , bean CaMeL Desc , any CaMeL Setter CaMeL Field ) ) ; } } if ( any CaMeL Setter CaMeL Method == null && any CaMeL Setter CaMeL Field == null ) { Collection < String > ignored $NUMBER$ = bean CaMeL Desc . get CaMeL Ignored CaMeL Property CaMeL Names ( ) ; if ( ignored $NUMBER$ != null ) { for ( String prop CaMeL Name : ignored $NUMBER$ ) { builder . add CaMeL Ignorable ( prop CaMeL Name ) ; } } } final boolean use CaMeL Getters CaMeL As CaMeL Setters = ctxt . is CaMeL Enabled ( Mapper CaMeL Feature . USE _ GETTERS _ AS _ SET@@ TERS ) && ctxt . is CaMeL Enabled ( Mapper CaMeL Feature . AUTO _ DETECT _ GETTERS ) ; List < Bean CaMeL Property CaMeL Definition > prop CaMeL Defs = filter CaMeL Bean CaMeL Props ( ctxt , bean CaMeL Desc , builder , bean CaMeL Desc . find CaMeL Properties ( ) , ignored ) ; if ( _ factory CaMeL Config . has CaMeL Deserializer CaMeL Modifiers ( ) ) { for ( Bean CaMeL Deserializer CaMeL Modifier mod : _ factory CaMeL Config . deserializer CaMeL Modifiers ( ) ) { prop CaMeL Defs = mod . update CaMeL Properties ( ctxt . get CaMeL Config ( ) , bean CaMeL Desc , prop CaMeL Defs ) ; } } for ( Bean CaMeL Property CaMeL Definition prop CaMeL Def : prop CaMeL Defs ) { Settable CaMeL Bean CaMeL Property prop = null ; if ( prop CaMeL Def . has CaMeL Setter ( ) ) { Java CaMeL Type property CaMeL Type = prop CaMeL Def . get CaMeL Setter ( ) . get CaMeL Parameter CaMeL Type ( 0 ) ; prop = construct CaMeL Settable CaMeL Property ( ctxt , bean CaMeL Desc , prop CaMeL Def , property CaMeL Type ) ; } else if ( prop CaMeL Def . has CaMeL Field ( ) ) { Java CaMeL Type property CaMeL Type = prop CaMeL Def . get CaMeL Field ( ) . get CaMeL Type ( ) ; prop = construct CaMeL Settable CaMeL Property ( ctxt , bean CaMeL Desc , prop CaMeL Def , property CaMeL Type ) ; } else if ( use CaMeL Getters CaMeL As CaMeL Setters && prop CaMeL Def . has CaMeL Getter ( ) ) { Annotated CaMeL Method getter = prop CaMeL Def . get CaMeL Getter ( ) ; Class < ? > raw CaMeL Property CaMeL Type = getter . get CaMeL Raw CaMeL Type ( ) ; if ( Collection . class . is CaMeL Assignable CaMeL From ( raw CaMeL Property CaMeL Type ) || Map . class . is CaMeL Assignable CaMeL From ( raw CaMeL Property CaMeL Type ) ) { prop = construct CaMeL Set@@ ter@@ less CaMeL Property ( ctxt , bean CaMeL Desc , prop CaMeL Def ) ; } } if ( has CaMeL Creator CaMeL Props && prop CaMeL Def . has CaMeL Constructor CaMeL Parameter ( ) ) { final String name = prop CaMeL Def . get CaMeL Name ( ) ; Creator CaMeL Property c@@ prop = null ; if ( creator CaMeL Props != null ) { for ( Settable CaMeL Bean CaMeL Property cp : creator CaMeL Props ) { if ( name . equals ( cp . get CaMeL Name ( ) ) && ( cp instanceof Creator CaMeL Property ) ) { c@@ prop = ( Creator CaMeL Property ) cp ; break ; } } } if ( c@@ prop == null ) { List < String > n = new Array CaMeL List < > ( ) ; for ( Settable CaMeL Bean CaMeL Property cp : creator CaMeL Props ) { n . add ( cp . get CaMeL Name ( ) ) ; } ctxt . report CaMeL Bad CaMeL Property CaMeL Definition ( bean CaMeL Desc , prop CaMeL Def , $STRING$ , name , n ) ; continue ; } if ( prop != null ) { c@@ prop . set CaMeL Fallback CaMeL Setter ( prop ) ; } prop = c@@ prop ; builder . add CaMeL Creator CaMeL Property ( c@@ prop ) ; continue ; } if ( prop != null ) { Class < ? > [ ] views = prop CaMeL Def . find CaMeL Views ( ) ; if ( views == null ) { if ( ! ctxt . is CaMeL Enabled ( Mapper CaMeL Feature . DEFAULT _ VIEW _ INCLUSION ) ) { views = NO _ VIEWS ; } } prop . set CaMeL Views ( views ) ; builder . add CaMeL Property ( prop ) ; } } }	 
if ( full . starts CaMeL With ( PREFIX _ STRING ) ) { for ( Class < ? > cls = raw ; cls != Object . class ; cls = cls . get CaMeL Superclass ( ) ) {  <CTX>  public void validate CaMeL Sub CaMeL Type ( Deserialization CaMeL Context ctxt , Java CaMeL Type type ) throws Json CaMeL Mapping CaMeL Exception { final Class < ? > raw = type . get CaMeL Raw CaMeL Class ( ) ; String full = raw . get CaMeL Name ( ) ; main _ check : do { if ( _ cfg CaMeL Illegal CaMeL Class CaMeL Names . contains ( full ) ) { break ; } if ( full . starts CaMeL With ( PREFIX _ STRING ) ) { for ( Class < ? > cls = raw ; cls != Object . class ; cls = cls . get CaMeL Superclass ( ) ) { String name = cls . get CaMeL Simple CaMeL Name ( ) ; if ( $STRING$ . equals ( name ) || $STRING$ . equals ( name ) ) { break main _ check ; } } } return ; } while ( false ) ; throw Json CaMeL Mapping CaMeL Exception . from ( ctxt , String . format ( $STRING$ , full ) ) ; }	 
param CaMeL Name = candidate . find CaMeL Implicit CaMeL Param CaMeL Name ( 0 ) ;  <CTX>  protected void _ add CaMeL Explicit CaMeL Any CaMeL Creator ( Deserialization CaMeL Context ctxt , Bean CaMeL Description bean CaMeL Desc , Creator CaMeL Collector creators , Creator CaMeL Candidate candidate ) throws Json CaMeL Mapping CaMeL Exception { if ( 1 != candidate . param CaMeL Count ( ) ) { int one CaMeL Not CaMeL Injected = candidate . find CaMeL Only CaMeL Param CaMeL Without CaMeL Injection ( ) ; if ( one CaMeL Not CaMeL Injected >= 0 ) { if ( candidate . param CaMeL Name ( one CaMeL Not CaMeL Injected ) == null ) { _ add CaMeL Explicit CaMeL Delegating CaMeL Creator ( ctxt , bean CaMeL Desc , creators , candidate ) ; return ; } } _ add CaMeL Explicit CaMeL Property CaMeL Creator ( ctxt , bean CaMeL Desc , creators , candidate ) ; return ; } Annotated CaMeL Parameter param = candidate . parameter ( 0 ) ; Jackson CaMeL Inject . Value inject CaMeL Id = candidate . injection ( 0 ) ; Property CaMeL Name param CaMeL Name = candidate . explicit CaMeL Param CaMeL Name ( 0 ) ; Bean CaMeL Property CaMeL Definition param CaMeL Def = candidate . property CaMeL Def ( 0 ) ; boolean use CaMeL Props = ( param CaMeL Name != null ) || ( inject CaMeL Id != null ) ; if ( ! use CaMeL Props && ( param CaMeL Def != null ) ) { param CaMeL Name = candidate . find CaMeL Implicit CaMeL Param CaMeL Name ( 0 ) ; use CaMeL Props = ( param CaMeL Name != null ) && param CaMeL Def . could CaMeL Serialize ( ) ; } if ( use CaMeL Props ) { Settable CaMeL Bean CaMeL Property [ ] properties = new Settable CaMeL Bean CaMeL Property [ ] { construct CaMeL Creator CaMeL Property ( ctxt , bean CaMeL Desc , param CaMeL Name , 0 , param , inject CaMeL Id ) } ; creators . add CaMeL Property CaMeL Creator ( candidate . creator ( ) , true , properties ) ; return ; } _ handle CaMeL Single CaMeL Argument CaMeL Creator ( creators , candidate . creator ( ) , true , true ) ; if ( param CaMeL Def != null ) { ( ( POJO CaMeL Property CaMeL Builder ) param CaMeL Def ) . remove CaMeL Constructors ( ) ; } }	 
gen . write CaMeL Object ( _ value ) ;  <CTX>  public final void serialize ( Json CaMeL Generator gen , Serializer CaMeL Provider ctxt ) throws IO CaMeL Exception { if ( _ value == null ) { ctxt . default CaMeL Serialize CaMeL Null ( gen ) ; } else if ( _ value instanceof Json CaMeL Serializable ) { ( ( Json CaMeL Serializable ) _ value ) . serialize ( gen , ctxt ) ; } else { gen . write CaMeL Object ( _ value ) ; } }	 
buffer . assign CaMeL Parameter ( type CaMeL Prop , type CaMeL Id ) ;  <CTX>  public Object complete ( Json CaMeL Parser p , Deserialization CaMeL Context ctxt , Property CaMeL Value CaMeL Buffer buffer , Property CaMeL Based CaMeL Creator creator ) throws IO CaMeL Exception { final int len = _ properties . length ; Object [ ] values = new Object [ len ] ; for ( int i = 0 ; i < len ; ++ i ) { String type CaMeL Id = _ type CaMeL Ids [ i ] ; final Ext CaMeL Typed CaMeL Property ext CaMeL Prop = _ properties [ i ] ; if ( type CaMeL Id == null ) { if ( _ tokens [ i ] == null ) { continue ; } if ( ! ext CaMeL Prop . has CaMeL Default CaMeL Type ( ) ) { ctxt . report CaMeL Input CaMeL Mismatch ( _ bean CaMeL Type , $STRING$ , ext CaMeL Prop . get CaMeL Type CaMeL Property CaMeL Name ( ) ) ; } else { type CaMeL Id = ext CaMeL Prop . get CaMeL Default CaMeL Type CaMeL Id ( ) ; } } else if ( _ tokens [ i ] == null ) { Settable CaMeL Bean CaMeL Property prop = ext CaMeL Prop . get CaMeL Property ( ) ; ctxt . report CaMeL Input CaMeL Mismatch ( _ bean CaMeL Type , $STRING$ , prop . get CaMeL Name ( ) , _ properties [ i ] . get CaMeL Type CaMeL Property CaMeL Name ( ) ) ; } values [ i ] = _ deserialize ( p , ctxt , i , type CaMeL Id ) ; final Settable CaMeL Bean CaMeL Property prop = ext CaMeL Prop . get CaMeL Property ( ) ; if ( prop . get CaMeL Creator CaMeL Index ( ) >= 0 ) { buffer . assign CaMeL Parameter ( prop , values [ i ] ) ; Settable CaMeL Bean CaMeL Property type CaMeL Prop = ext CaMeL Prop . get CaMeL Type CaMeL Property ( ) ; if ( ( type CaMeL Prop != null ) && ( type CaMeL Prop . get CaMeL Creator CaMeL Index ( ) >= 0 ) ) { buffer . assign CaMeL Parameter ( type CaMeL Prop , type CaMeL Id ) ; } } } Object bean = creator . build ( ctxt , buffer ) ; for ( int i = 0 ; i < len ; ++ i ) { Settable CaMeL Bean CaMeL Property prop = _ properties [ i ] . get CaMeL Property ( ) ; if ( prop . get CaMeL Creator CaMeL Index ( ) < 0 ) { prop . set ( bean , values [ i ] ) ; } } return bean ; }	 
return null ;  <CTX>  protected final Json CaMeL Deserializer < Object > _ find CaMeL Deserializer ( Deserialization CaMeL Context ctxt , String type CaMeL Id ) throws IO CaMeL Exception { Json CaMeL Deserializer < Object > deser = _ deserializers . get ( type CaMeL Id ) ; if ( deser == null ) { Java CaMeL Type type = _ id CaMeL Resolver . type CaMeL From CaMeL Id ( ctxt , type CaMeL Id ) ; if ( type == null ) { deser = _ find CaMeL Default CaMeL Impl CaMeL Deserializer ( ctxt ) ; if ( deser == null ) { Java CaMeL Type actual = _ handle CaMeL Unknown CaMeL Type CaMeL Id ( ctxt , type CaMeL Id ) ; if ( actual == null ) { return null ; } deser = ctxt . find CaMeL Contextual CaMeL Value CaMeL Deserializer ( actual , _ property ) ; } } else { if ( ( _ base CaMeL Type != null ) && _ base CaMeL Type . get CaMeL Class ( ) == type . get CaMeL Class ( ) ) { if ( ! type . has CaMeL Generic CaMeL Types ( ) ) { type = ctxt . get CaMeL Type CaMeL Factory ( ) . construct CaMeL Specialized CaMeL Type ( _ base CaMeL Type , type . get CaMeL Raw CaMeL Class ( ) ) ; } } deser = ctxt . find CaMeL Contextual CaMeL Value CaMeL Deserializer ( type , _ property ) ; } _ deserializers . put ( type CaMeL Id , deser ) ; } return deser ; }	 
body ( ) . append CaMeL Child ( new Text CaMeL Node ( $STRING$ , $STRING$ ) ) ; body ( ) . append CaMeL Child ( node ) ;  <CTX>  private void normalise ( Element element ) { List < Node > to CaMeL Move = new Array CaMeL List < Node > ( ) ; for ( Node node : element . child CaMeL Nodes ) { if ( node instanceof Text CaMeL Node ) { Text CaMeL Node tn = ( Text CaMeL Node ) node ; if ( ! tn . is CaMeL Blank ( ) ) to CaMeL Move . add ( tn ) ; } } for ( Node node : to CaMeL Move ) { element . remove CaMeL Child ( node ) ; body ( ) . append CaMeL Child ( new Text CaMeL Node ( $STRING$ , $STRING$ ) ) ; body ( ) . append CaMeL Child ( node ) ; } }	 
tq . consume ( ) ;  <CTX>  private Attribute parse CaMeL Attribute ( ) { tq . consume CaMeL Whitespace ( ) ; String key = tq . consume CaMeL Attribute CaMeL Key ( ) ; String value = $STRING$ ; tq . consume CaMeL Whitespace ( ) ; if ( tq . match CaMeL Cho@@ mp ( $STRING$ ) ) { tq . consume CaMeL Whitespace ( ) ; if ( tq . match CaMeL Cho@@ mp ( SQ ) ) { value = tq . chomp CaMeL To ( SQ ) ; } else if ( tq . match CaMeL Cho@@ mp ( DQ ) ) { value = tq . chomp CaMeL To ( DQ ) ; } else { String CaMeL Builder value CaMeL Accum = new String CaMeL Builder ( ) ; while ( ! tq . matches CaMeL Any ( $STRING$ , $STRING$ , $STRING$ ) && ! tq . matches CaMeL Whitespace ( ) && ! tq . is CaMeL Empty ( ) ) { value CaMeL Accum . append ( tq . consume ( ) ) ; } value = value CaMeL Accum . to CaMeL String ( ) ; } tq . consume CaMeL Whitespace ( ) ; } if ( key . length ( ) != 0 ) return Attribute . create CaMeL From CaMeL Encoded ( key , value ) ; else { tq . consume ( ) ; return null ; } }	 
} else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ ) ) {  <CTX>  boolean process ( Token t , Tree CaMeL Builder tb ) { switch ( t . type ) { case Character : { Token . Character c = t . as CaMeL Character ( ) ; if ( c . get CaMeL Data ( ) . equals ( null CaMeL String ) ) { tb . error ( this ) ; return false ; } else if ( is CaMeL Whitespace ( c ) ) { tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; tb . insert ( c ) ; } else { tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; tb . insert ( c ) ; tb . frameset CaMeL Ok ( false ) ; } break ; } case Comment : { tb . insert ( t . as CaMeL Comment ( ) ) ; break ; } case Doctype : { tb . error ( this ) ; return false ; } case Start CaMeL Tag : Token . Start CaMeL Tag start CaMeL Tag = t . as CaMeL Start CaMeL Tag ( ) ; String name = start CaMeL Tag . name ( ) ; if ( name . equals ( $STRING$ ) ) { tb . error ( this ) ; Element html = tb . get CaMeL Stack ( ) . get CaMeL First ( ) ; for ( Attribute attribute : start CaMeL Tag . get CaMeL Attributes ( ) ) { if ( ! html . has CaMeL Attr ( attribute . get CaMeL Key ( ) ) ) html . attributes ( ) . put ( attribute ) ; } } else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ ) ) { return tb . process ( t , In CaMeL Head ) ; } else if ( name . equals ( $STRING$ ) ) { tb . error ( this ) ; Linked CaMeL List < Element > stack = tb . get CaMeL Stack ( ) ; if ( stack . size ( ) == 1 || ( stack . size ( ) > $NUMBER$ && ! stack . get ( 1 ) . node CaMeL Name ( ) . equals ( $STRING$ ) ) ) { return false ; } else { tb . frameset CaMeL Ok ( false ) ; Element body = stack . get ( 1 ) ; for ( Attribute attribute : start CaMeL Tag . get CaMeL Attributes ( ) ) { if ( ! body . has CaMeL Attr ( attribute . get CaMeL Key ( ) ) ) body . attributes ( ) . put ( attribute ) ; } } } else if ( name . equals ( $STRING$ ) ) { tb . error ( this ) ; Linked CaMeL List < Element > stack = tb . get CaMeL Stack ( ) ; if ( stack . size ( ) == 1 || ( stack . size ( ) > $NUMBER$ && ! stack . get ( 1 ) . node CaMeL Name ( ) . equals ( $STRING$ ) ) ) { return false ; } else if ( ! tb . frameset CaMeL Ok ( ) ) { return false ; } else { Element second = stack . get ( 1 ) ; if ( second . parent ( ) != null ) second . remove ( ) ; while ( stack . size ( ) > 1 ) stack . remove CaMeL Last ( ) ; tb . insert ( start CaMeL Tag ) ; tb . transition ( In CaMeL Frameset ) ; } } else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ ) ) { if ( tb . in CaMeL Button CaMeL Scope ( $STRING$ ) ) { tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; } tb . insert ( start CaMeL Tag ) ; } else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ ) ) { if ( tb . in CaMeL Button CaMeL Scope ( $STRING$ ) ) { tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; } if ( String CaMeL Util . in ( tb . current CaMeL Element ( ) . node CaMeL Name ( ) , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ ) ) { tb . error ( this ) ; tb . pop ( ) ; } tb . insert ( start CaMeL Tag ) ; } else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ ) ) { if ( tb . in CaMeL Button CaMeL Scope ( $STRING$ ) ) { tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; } tb . insert ( start CaMeL Tag ) ; tb . frameset CaMeL Ok ( false ) ; } else if ( name . equals ( $STRING$ ) ) { if ( tb . get CaMeL Form CaMeL Element ( ) != null ) { tb . error ( this ) ; return false ; } if ( tb . in CaMeL Button CaMeL Scope ( $STRING$ ) ) { tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; } Element form = tb . insert ( start CaMeL Tag ) ; tb . set CaMeL Form CaMeL Element ( form ) ; } else if ( name . equals ( $STRING$ ) ) { tb . frameset CaMeL Ok ( false ) ; Linked CaMeL List < Element > stack = tb . get CaMeL Stack ( ) ; for ( int i = stack . size ( ) - 1 ; i > 0 ; i -- ) { Element el = stack . get ( i ) ; if ( el . node CaMeL Name ( ) . equals ( $STRING$ ) ) { tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; break ; } if ( tb . is CaMeL Special ( el ) && ! String CaMeL Util . in ( el . node CaMeL Name ( ) , $STRING$ , $STRING$ , $STRING$ ) ) break ; } if ( tb . in CaMeL Button CaMeL Scope ( $STRING$ ) ) { tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; } tb . insert ( start CaMeL Tag ) ; } else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ ) ) { tb . frameset CaMeL Ok ( false ) ; Linked CaMeL List < Element > stack = tb . get CaMeL Stack ( ) ; for ( int i = stack . size ( ) - 1 ; i > 0 ; i -- ) { Element el = stack . get ( i ) ; if ( String CaMeL Util . in ( el . node CaMeL Name ( ) , $STRING$ , $STRING$ ) ) { tb . process ( new Token . End CaMeL Tag ( el . node CaMeL Name ( ) ) ) ; break ; } if ( tb . is CaMeL Special ( el ) && ! String CaMeL Util . in ( el . node CaMeL Name ( ) , $STRING$ , $STRING$ , $STRING$ ) ) break ; } if ( tb . in CaMeL Button CaMeL Scope ( $STRING$ ) ) { tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; } tb . insert ( start CaMeL Tag ) ; } else if ( name . equals ( $STRING$ ) ) { if ( tb . in CaMeL Button CaMeL Scope ( $STRING$ ) ) { tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; } tb . insert ( start CaMeL Tag ) ; tb . tokeniser . transition ( Tokeniser CaMeL State . PLAINTEXT ) ; } else if ( name . equals ( $STRING$ ) ) { if ( tb . in CaMeL Button CaMeL Scope ( $STRING$ ) ) { tb . error ( this ) ; tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; tb . process ( start CaMeL Tag ) ; } else { tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; tb . insert ( start CaMeL Tag ) ; tb . frameset CaMeL Ok ( false ) ; } } else if ( name . equals ( $STRING$ ) ) { if ( tb . get CaMeL Active CaMeL Formatting CaMeL Element ( $STRING$ ) != null ) { tb . error ( this ) ; tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; Element remaining CaMeL A = tb . get CaMeL From CaMeL Stack ( $STRING$ ) ; if ( remaining CaMeL A != null ) { tb . remove CaMeL From CaMeL Active CaMeL Formatting CaMeL Elements ( remaining CaMeL A ) ; tb . remove CaMeL From CaMeL Stack ( remaining CaMeL A ) ; } } tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; Element a = tb . insert ( start CaMeL Tag ) ; tb . push CaMeL Active CaMeL Formatting CaMeL Elements ( a ) ; } else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ ) ) { tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; Element el = tb . insert ( start CaMeL Tag ) ; tb . push CaMeL Active CaMeL Formatting CaMeL Elements ( el ) ; } else if ( name . equals ( $STRING$ ) ) { tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; if ( tb . in CaMeL Scope ( $STRING$ ) ) { tb . error ( this ) ; tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; } Element el = tb . insert ( start CaMeL Tag ) ; tb . push CaMeL Active CaMeL Formatting CaMeL Elements ( el ) ; } else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ , $STRING$ ) ) { tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; tb . insert ( start CaMeL Tag ) ; tb . insert CaMeL Marker CaMeL To CaMeL Formatting CaMeL Elements ( ) ; tb . frameset CaMeL Ok ( false ) ; } else if ( name . equals ( $STRING$ ) ) { if ( tb . get CaMeL Document ( ) . quirks CaMeL Mode ( ) != Document . Quirks CaMeL Mode . quirks && tb . in CaMeL Button CaMeL Scope ( $STRING$ ) ) { tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; } tb . insert ( start CaMeL Tag ) ; tb . frameset CaMeL Ok ( false ) ; tb . transition ( In CaMeL Table ) ; } else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ ) ) { tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; tb . insert CaMeL Empty ( start CaMeL Tag ) ; tb . frameset CaMeL Ok ( false ) ; } else if ( name . equals ( $STRING$ ) ) { tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; Element el = tb . insert CaMeL Empty ( start CaMeL Tag ) ; if ( ! el . attr ( $STRING$ ) . equals CaMeL Ignore CaMeL Case ( $STRING$ ) ) tb . frameset CaMeL Ok ( false ) ; } else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ , $STRING$ ) ) { tb . insert CaMeL Empty ( start CaMeL Tag ) ; } else if ( name . equals ( $STRING$ ) ) { if ( tb . in CaMeL Button CaMeL Scope ( $STRING$ ) ) { tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; } tb . insert CaMeL Empty ( start CaMeL Tag ) ; tb . frameset CaMeL Ok ( false ) ; } else if ( name . equals ( $STRING$ ) ) { start CaMeL Tag . name ( $STRING$ ) ; return tb . process ( start CaMeL Tag ) ; } else if ( name . equals ( $STRING$ ) ) { tb . error ( this ) ; if ( tb . get CaMeL Form CaMeL Element ( ) != null ) return false ; tb . tokeniser . acknowledge CaMeL Self CaMeL Closing CaMeL Flag ( ) ; tb . process ( new Token . Start CaMeL Tag ( $STRING$ ) ) ; if ( start CaMeL Tag . attributes . has CaMeL Key ( $STRING$ ) ) { Element form = tb . get CaMeL Form CaMeL Element ( ) ; form . attr ( $STRING$ , start CaMeL Tag . attributes . get ( $STRING$ ) ) ; } tb . process ( new Token . Start CaMeL Tag ( $STRING$ ) ) ; tb . process ( new Token . Start CaMeL Tag ( $STRING$ ) ) ; String prompt = start CaMeL Tag . attributes . has CaMeL Key ( $STRING$ ) ? start CaMeL Tag . attributes . get ( $STRING$ ) : $STRING$ ; tb . process ( new Token . Character ( prompt ) ) ; Attributes input CaMeL Attribs = new Attributes ( ) ; for ( Attribute attr : start CaMeL Tag . attributes ) { if ( ! String CaMeL Util . in ( attr . get CaMeL Key ( ) , $STRING$ , $STRING$ , $STRING$ ) ) input CaMeL Attribs . put ( attr ) ; } input CaMeL Attribs . put ( $STRING$ , $STRING$ ) ; tb . process ( new Token . Start CaMeL Tag ( $STRING$ , input CaMeL Attribs ) ) ; tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; tb . process ( new Token . Start CaMeL Tag ( $STRING$ ) ) ; tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; } else if ( name . equals ( $STRING$ ) ) { tb . insert ( start CaMeL Tag ) ; tb . tokeniser . transition ( Tokeniser CaMeL State . R@@ cdata ) ; tb . mark CaMeL Insertion CaMeL Mode ( ) ; tb . frameset CaMeL Ok ( false ) ; tb . transition ( Text ) ; } else if ( name . equals ( $STRING$ ) ) { if ( tb . in CaMeL Button CaMeL Scope ( $STRING$ ) ) { tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; } tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; tb . frameset CaMeL Ok ( false ) ; handle CaMeL R@@ aw@@ text ( start CaMeL Tag , tb ) ; } else if ( name . equals ( $STRING$ ) ) { tb . frameset CaMeL Ok ( false ) ; handle CaMeL R@@ aw@@ text ( start CaMeL Tag , tb ) ; } else if ( name . equals ( $STRING$ ) ) { handle CaMeL R@@ aw@@ text ( start CaMeL Tag , tb ) ; } else if ( name . equals ( $STRING$ ) ) { tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; tb . insert ( start CaMeL Tag ) ; tb . frameset CaMeL Ok ( false ) ; Tree CaMeL Builder CaMeL State state = tb . state ( ) ; if ( state . equals ( In CaMeL Table ) || state . equals ( In CaMeL Caption ) || state . equals ( In CaMeL Table CaMeL Body ) || state . equals ( In CaMeL Row ) || state . equals ( In CaMeL Cell ) ) tb . transition ( In CaMeL Select CaMeL In CaMeL Table ) ; else tb . transition ( In CaMeL Select ) ; } else if ( String CaMeL Util . in ( $STRING$ , $STRING$ ) ) { if ( tb . current CaMeL Element ( ) . node CaMeL Name ( ) . equals ( $STRING$ ) ) tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; tb . insert ( start CaMeL Tag ) ; } else if ( String CaMeL Util . in ( $STRING$ , $STRING$ ) ) { if ( tb . in CaMeL Scope ( $STRING$ ) ) { tb . generate CaMeL Implied CaMeL End CaMeL Tags ( ) ; if ( ! tb . current CaMeL Element ( ) . node CaMeL Name ( ) . equals ( $STRING$ ) ) { tb . error ( this ) ; tb . pop CaMeL Stack CaMeL To CaMeL Before ( $STRING$ ) ; } tb . insert ( start CaMeL Tag ) ; } } else if ( name . equals ( $STRING$ ) ) { tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; tb . insert ( start CaMeL Tag ) ; tb . tokeniser . acknowledge CaMeL Self CaMeL Closing CaMeL Flag ( ) ; } else if ( name . equals ( $STRING$ ) ) { tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; tb . insert ( start CaMeL Tag ) ; tb . tokeniser . acknowledge CaMeL Self CaMeL Closing CaMeL Flag ( ) ; } else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ ) ) { tb . error ( this ) ; return false ; } else { tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; tb . insert ( start CaMeL Tag ) ; } break ; case End CaMeL Tag : Token . End CaMeL Tag end CaMeL Tag = t . as CaMeL End CaMeL Tag ( ) ; name = end CaMeL Tag . name ( ) ; if ( name . equals ( $STRING$ ) ) { if ( ! tb . in CaMeL Scope ( $STRING$ ) ) { tb . error ( this ) ; return false ; } else { tb . transition ( After CaMeL Body ) ; } } else if ( name . equals ( $STRING$ ) ) { boolean not CaMeL Ignored = tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; if ( not CaMeL Ignored ) return tb . process ( end CaMeL Tag ) ; } else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ ) ) { if ( ! tb . in CaMeL Scope ( name ) ) { tb . error ( this ) ; return false ; } else { tb . generate CaMeL Implied CaMeL End CaMeL Tags ( ) ; if ( ! tb . current CaMeL Element ( ) . node CaMeL Name ( ) . equals ( name ) ) tb . error ( this ) ; tb . pop CaMeL Stack CaMeL To CaMeL Close ( name ) ; } } else if ( name . equals ( $STRING$ ) ) { Element current CaMeL Form = tb . get CaMeL Form CaMeL Element ( ) ; tb . set CaMeL Form CaMeL Element ( null ) ; if ( current CaMeL Form == null || ! tb . in CaMeL Scope ( name ) ) { tb . error ( this ) ; return false ; } else { tb . generate CaMeL Implied CaMeL End CaMeL Tags ( ) ; if ( ! tb . current CaMeL Element ( ) . node CaMeL Name ( ) . equals ( name ) ) tb . error ( this ) ; tb . remove CaMeL From CaMeL Stack ( current CaMeL Form ) ; } } else if ( name . equals ( $STRING$ ) ) { if ( ! tb . in CaMeL Button CaMeL Scope ( name ) ) { tb . error ( this ) ; tb . process ( new Token . Start CaMeL Tag ( name ) ) ; return tb . process ( end CaMeL Tag ) ; } else { tb . generate CaMeL Implied CaMeL End CaMeL Tags ( name ) ; if ( ! tb . current CaMeL Element ( ) . node CaMeL Name ( ) . equals ( name ) ) tb . error ( this ) ; tb . pop CaMeL Stack CaMeL To CaMeL Close ( name ) ; } } else if ( name . equals ( $STRING$ ) ) { if ( ! tb . in CaMeL List CaMeL Item CaMeL Scope ( name ) ) { tb . error ( this ) ; return false ; } else { tb . generate CaMeL Implied CaMeL End CaMeL Tags ( name ) ; if ( ! tb . current CaMeL Element ( ) . node CaMeL Name ( ) . equals ( name ) ) tb . error ( this ) ; tb . pop CaMeL Stack CaMeL To CaMeL Close ( name ) ; } } else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ ) ) { if ( ! tb . in CaMeL Scope ( name ) ) { tb . error ( this ) ; return false ; } else { tb . generate CaMeL Implied CaMeL End CaMeL Tags ( name ) ; if ( ! tb . current CaMeL Element ( ) . node CaMeL Name ( ) . equals ( name ) ) tb . error ( this ) ; tb . pop CaMeL Stack CaMeL To CaMeL Close ( name ) ; } } else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ ) ) { if ( ! tb . in CaMeL Scope ( new String [ ] { $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ } ) ) { tb . error ( this ) ; return false ; } else { tb . generate CaMeL Implied CaMeL End CaMeL Tags ( name ) ; if ( ! tb . current CaMeL Element ( ) . node CaMeL Name ( ) . equals ( name ) ) tb . error ( this ) ; tb . pop CaMeL Stack CaMeL To CaMeL Close ( $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ ) ; } } else if ( name . equals ( $STRING$ ) ) { return any CaMeL Other CaMeL End CaMeL Tag ( t , tb ) ; } else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ ) ) { OUTER : for ( int i = 0 ; i < 8 ; i ++ ) { Element format CaMeL El = tb . get CaMeL Active CaMeL Formatting CaMeL Element ( name ) ; if ( format CaMeL El == null ) return any CaMeL Other CaMeL End CaMeL Tag ( t , tb ) ; else if ( ! tb . on CaMeL Stack ( format CaMeL El ) ) { tb . error ( this ) ; tb . remove CaMeL From CaMeL Active CaMeL Formatting CaMeL Elements ( format CaMeL El ) ; return true ; } else if ( ! tb . in CaMeL Scope ( format CaMeL El . node CaMeL Name ( ) ) ) { tb . error ( this ) ; return false ; } else if ( tb . current CaMeL Element ( ) != format CaMeL El ) tb . error ( this ) ; Element furthest CaMeL Block = null ; Element common CaMeL Ancestor = null ; boolean seen CaMeL Formatting CaMeL Element = false ; Linked CaMeL List < Element > stack = tb . get CaMeL Stack ( ) ; for ( int si = 0 ; si < stack . size ( ) ; si ++ ) { Element el = stack . get ( si ) ; if ( el == format CaMeL El ) { common CaMeL Ancestor = stack . get ( si - 1 ) ; seen CaMeL Formatting CaMeL Element = true ; } else if ( seen CaMeL Formatting CaMeL Element && tb . is CaMeL Special ( el ) ) { furthest CaMeL Block = el ; break ; } } if ( furthest CaMeL Block == null ) { tb . pop CaMeL Stack CaMeL To CaMeL Close ( format CaMeL El . node CaMeL Name ( ) ) ; tb . remove CaMeL From CaMeL Active CaMeL Formatting CaMeL Elements ( format CaMeL El ) ; return true ; } Element node = furthest CaMeL Block ; Element last CaMeL Node = furthest CaMeL Block ; INNER : for ( int j = 0 ; j < $NUMBER$ ; j ++ ) { if ( tb . on CaMeL Stack ( node ) ) node = tb . above CaMeL On CaMeL Stack ( node ) ; if ( ! tb . is CaMeL In CaMeL Active CaMeL Formatting CaMeL Elements ( node ) ) { tb . remove CaMeL From CaMeL Stack ( node ) ; continue INNER ; } else if ( node == format CaMeL El ) break INNER ; Element replacement = new Element ( Tag . value CaMeL Of ( node . node CaMeL Name ( ) ) , tb . get CaMeL Base CaMeL Uri ( ) ) ; tb . replace CaMeL Active CaMeL Formatting CaMeL Element ( node , replacement ) ; tb . replace CaMeL On CaMeL Stack ( node , replacement ) ; node = replacement ; if ( last CaMeL Node == furthest CaMeL Block ) { } if ( last CaMeL Node . parent ( ) != null ) last CaMeL Node . remove ( ) ; node . append CaMeL Child ( last CaMeL Node ) ; last CaMeL Node = node ; } if ( String CaMeL Util . in ( common CaMeL Ancestor . node CaMeL Name ( ) , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ ) ) { if ( last CaMeL Node . parent ( ) != null ) last CaMeL Node . remove ( ) ; tb . insert CaMeL In CaMeL Foster CaMeL Parent ( last CaMeL Node ) ; } else { if ( last CaMeL Node . parent ( ) != null ) last CaMeL Node . remove ( ) ; common CaMeL Ancestor . append CaMeL Child ( last CaMeL Node ) ; } Element ad@@ op@@ ter = new Element ( Tag . value CaMeL Of ( name ) , tb . get CaMeL Base CaMeL Uri ( ) ) ; Node [ ] child CaMeL Nodes = furthest CaMeL Block . child CaMeL Nodes ( ) . to CaMeL Array ( new Node [ furthest CaMeL Block . child CaMeL Nodes ( ) . size ( ) ] ) ; for ( Node child CaMeL Node : child CaMeL Nodes ) { ad@@ op@@ ter . append CaMeL Child ( child CaMeL Node ) ; } furthest CaMeL Block . append CaMeL Child ( ad@@ op@@ ter ) ; tb . remove CaMeL From CaMeL Active CaMeL Formatting CaMeL Elements ( format CaMeL El ) ; tb . remove CaMeL From CaMeL Stack ( format CaMeL El ) ; tb . insert CaMeL On CaMeL Stack CaMeL After ( furthest CaMeL Block , ad@@ op@@ ter ) ; } } else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ , $STRING$ ) ) { if ( ! tb . in CaMeL Scope ( $STRING$ ) ) { if ( ! tb . in CaMeL Scope ( name ) ) { tb . error ( this ) ; return false ; } tb . generate CaMeL Implied CaMeL End CaMeL Tags ( ) ; if ( ! tb . current CaMeL Element ( ) . node CaMeL Name ( ) . equals ( name ) ) tb . error ( this ) ; tb . pop CaMeL Stack CaMeL To CaMeL Close ( name ) ; tb . clear CaMeL Formatting CaMeL Elements CaMeL To CaMeL Last CaMeL Marker ( ) ; } } else if ( name . equals ( $STRING$ ) ) { tb . error ( this ) ; tb . process ( new Token . Start CaMeL Tag ( $STRING$ ) ) ; return false ; } else { return any CaMeL Other CaMeL End CaMeL Tag ( t , tb ) ; } break ; case EOF : break ; } return true ; }	 
clone . class CaMeL Names ( ) ;  <CTX>  public Element clone ( ) { Element clone = ( Element ) super . clone ( ) ; clone . class CaMeL Names ( ) ; return clone ; }	 
if ( offset < length ) {  <CTX>  int next CaMeL Index CaMeL Of ( Char CaMeL Sequence seq ) { char start CaMeL Char = seq . char CaMeL At ( 0 ) ; for ( int offset = pos ; offset < length ; offset ++ ) { if ( start CaMeL Char != input [ offset ] ) while ( ++ offset < length && start CaMeL Char != input [ offset ] ) ; int i = offset + 1 ; int last = i + seq . length ( ) - 1 ; if ( offset < length ) { for ( int j = 1 ; i < last && seq . char CaMeL At ( j ) == input [ i ] ; i ++ , j ++ ) ; if ( i == last ) return offset - pos ; } } return - 1 ; }	 
return accum . to CaMeL String ( ) . trim ( ) ;  <CTX>  public String html ( ) { String CaMeL Builder accum = new String CaMeL Builder ( ) ; html ( accum ) ; return accum . to CaMeL String ( ) . trim ( ) ; }	 
return this == o ;  <CTX>  public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || get CaMeL Class ( ) != o . get CaMeL Class ( ) ) return false ; if ( ! super . equals ( o ) ) return false ; Element element = ( Element ) o ; return this == o ; }	 
if ( element . equals ( search ) )  <CTX>  private static < E extends Element > Integer index CaMeL In CaMeL List ( Element search , List < E > elements ) { Validate . not CaMeL Null ( search ) ; Validate . not CaMeL Null ( elements ) ; for ( int i = 0 ; i < elements . size ( ) ; i ++ ) { E element = elements . get ( i ) ; if ( element . equals ( search ) ) return i ; } return null ; }	 
} else if ( ( $STRING$ . equals ( name ) || $STRING$ . equals ( name ) && ! last ) ) {  <CTX>  void reset CaMeL Insertion CaMeL Mode ( ) { boolean last = false ; for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element node = stack . get ( pos ) ; if ( pos == 0 ) { last = true ; node = context CaMeL Element ; } String name = node . node CaMeL Name ( ) ; if ( $STRING$ . equals ( name ) ) { transition ( Html CaMeL Tree CaMeL Builder CaMeL State . In CaMeL Select ) ; break ; } else if ( ( $STRING$ . equals ( name ) || $STRING$ . equals ( name ) && ! last ) ) { transition ( Html CaMeL Tree CaMeL Builder CaMeL State . In CaMeL Cell ) ; break ; } else if ( $STRING$ . equals ( name ) ) { transition ( Html CaMeL Tree CaMeL Builder CaMeL State . In CaMeL Row ) ; break ; } else if ( $STRING$ . equals ( name ) || $STRING$ . equals ( name ) || $STRING$ . equals ( name ) ) { transition ( Html CaMeL Tree CaMeL Builder CaMeL State . In CaMeL Table CaMeL Body ) ; break ; } else if ( $STRING$ . equals ( name ) ) { transition ( Html CaMeL Tree CaMeL Builder CaMeL State . In CaMeL Caption ) ; break ; } else if ( $STRING$ . equals ( name ) ) { transition ( Html CaMeL Tree CaMeL Builder CaMeL State . In CaMeL Column CaMeL Group ) ; break ; } else if ( $STRING$ . equals ( name ) ) { transition ( Html CaMeL Tree CaMeL Builder CaMeL State . In CaMeL Table ) ; break ; } else if ( $STRING$ . equals ( name ) ) { transition ( Html CaMeL Tree CaMeL Builder CaMeL State . In CaMeL Body ) ; break ; } else if ( $STRING$ . equals ( name ) ) { transition ( Html CaMeL Tree CaMeL Builder CaMeL State . In CaMeL Body ) ; break ; } else if ( $STRING$ . equals ( name ) ) { transition ( Html CaMeL Tree CaMeL Builder CaMeL State . In CaMeL Frameset ) ; break ; } else if ( $STRING$ . equals ( name ) ) { transition ( Html CaMeL Tree CaMeL Builder CaMeL State . Before CaMeL Head ) ; break ; } else if ( last ) { transition ( Html CaMeL Tree CaMeL Builder CaMeL State . In CaMeL Body ) ; break ; } } }	 
accum . append ( c ) ;  <CTX>  static void escape ( String CaMeL Builder accum , String string , Document . Output CaMeL Settings out , boolean in CaMeL Attribute , boolean normalise CaMeL White , boolean strip CaMeL Leading CaMeL White ) { boolean last CaMeL Was CaMeL White = false ; boolean reached CaMeL Non CaMeL White = false ; final Escape CaMeL Mode escape CaMeL Mode = out . escape CaMeL Mode ( ) ; final Charset CaMeL Encoder encoder = out . encoder ( ) ; final Core CaMeL Charset core CaMeL Charset = Core CaMeL Charset . by CaMeL Name ( encoder . charset ( ) . name ( ) ) ; final Map < Character , String > map = escape CaMeL Mode . get CaMeL Map ( ) ; final int length = string . length ( ) ; int code CaMeL Point ; for ( int offset = 0 ; offset < length ; offset += Character . char CaMeL Count ( code CaMeL Point ) ) { code CaMeL Point = string . code CaMeL Point CaMeL At ( offset ) ; if ( normalise CaMeL White ) { if ( String CaMeL Util . is CaMeL Whitespace ( code CaMeL Point ) ) { if ( ( strip CaMeL Leading CaMeL White && ! reached CaMeL Non CaMeL White ) || last CaMeL Was CaMeL White ) continue ; accum . append ( $STRING$ ) ; last CaMeL Was CaMeL White = true ; continue ; } else { last CaMeL Was CaMeL White = false ; reached CaMeL Non CaMeL White = true ; } } if ( code CaMeL Point < Character . MIN _ SUPPLEMENTARY _ CODE _ POINT ) { final char c = ( char ) code CaMeL Point ; switch ( c ) { case $STRING$ : accum . append ( $STRING$ ) ; break ; case 0 x CaMeL A 0 : if ( escape CaMeL Mode != Escape CaMeL Mode . xhtml ) accum . append ( $STRING$ ) ; else accum . append ( c ) ; break ; case $STRING$ : if ( ! in CaMeL Attribute ) accum . append ( $STRING$ ) ; else accum . append ( c ) ; break ; case $STRING$ : if ( ! in CaMeL Attribute ) accum . append ( $STRING$ ) ; else accum . append ( c ) ; break ; case $STRING$ ; ) ; } } }	 
if ( ! in CaMeL Attribute )  <CTX>  static void escape ( String CaMeL Builder accum , String string , Document . Output CaMeL Settings out , boolean in CaMeL Attribute , boolean normalise CaMeL White , boolean strip CaMeL Leading CaMeL White ) { boolean last CaMeL Was CaMeL White = false ; boolean reached CaMeL Non CaMeL White = false ; final Escape CaMeL Mode escape CaMeL Mode = out . escape CaMeL Mode ( ) ; final Charset CaMeL Encoder encoder = out . encoder ( ) ; final Core CaMeL Charset core CaMeL Charset = Core CaMeL Charset . by CaMeL Name ( encoder . charset ( ) . name ( ) ) ; final Map < Character , String > map = escape CaMeL Mode . get CaMeL Map ( ) ; final int length = string . length ( ) ; int code CaMeL Point ; for ( int offset = 0 ; offset < length ; offset += Character . char CaMeL Count ( code CaMeL Point ) ) { code CaMeL Point = string . code CaMeL Point CaMeL At ( offset ) ; if ( normalise CaMeL White ) { if ( String CaMeL Util . is CaMeL Whitespace ( code CaMeL Point ) ) { if ( ( strip CaMeL Leading CaMeL White && ! reached CaMeL Non CaMeL White ) || last CaMeL Was CaMeL White ) continue ; accum . append ( $STRING$ ) ; last CaMeL Was CaMeL White = true ; continue ; } else { last CaMeL Was CaMeL White = false ; reached CaMeL Non CaMeL White = true ; } } if ( code CaMeL Point < Character . MIN _ SUPPLEMENTARY _ CODE _ POINT ) { final char c = ( char ) code CaMeL Point ; switch ( c ) { case $STRING$ : accum . append ( $STRING$ ) ; break ; case 0 x CaMeL A 0 : if ( escape CaMeL Mode != Escape CaMeL Mode . xhtml ) accum . append ( $STRING$ ) ; else accum . append ( $STRING$ ) ; break ; case $STRING$ : if ( ! in CaMeL Attribute ) accum . append ( $STRING$ ) ; else accum . append ( c ) ; break ; case $STRING$ : if ( ! in CaMeL Attribute ) accum . append ( $STRING$ ) ; else accum . append ( c ) ; break ; case $STRING$ ; ) ; } } }	 
return ( c >= $STRING$ && c <= $STRING$ ) || ( c >= $STRING$ && c <= $STRING$ ) ;  <CTX>  boolean matches CaMeL Letter ( ) { if ( is CaMeL Empty ( ) ) return false ; char c = input [ pos ] ; return ( c >= $STRING$ && c <= $STRING$ ) || ( c >= $STRING$ && c <= $STRING$ ) ; }	 
attributes . remove ( attr CaMeL Key ) ;  <CTX>  public void remove CaMeL Ignore CaMeL Case ( String key ) { Validate . not CaMeL Empty ( key ) ; if ( attributes == null ) return ; for ( Iterator < String > it = attributes . key CaMeL Set ( ) . iterator ( ) ; it . has CaMeL Next ( ) ; ) { String attr CaMeL Key = it . next ( ) ; if ( attr CaMeL Key . equals CaMeL Ignore CaMeL Case ( key ) ) attributes . remove ( attr CaMeL Key ) ; } }	 
final String class CaMeL Attr = attributes . get ( $STRING$ ) ;  <CTX>  public boolean has CaMeL Class ( String class CaMeL Name ) { final String class CaMeL Attr = attributes . get ( $STRING$ ) ; final int len = class CaMeL Attr . length ( ) ; final int want CaMeL Len = class CaMeL Name . length ( ) ; if ( len == 0 || len < want CaMeL Len ) { return false ; } if ( len == want CaMeL Len ) { return class CaMeL Name . equals CaMeL Ignore CaMeL Case ( class CaMeL Attr ) ; } boolean in CaMeL Class = false ; int start = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( Character . is CaMeL Whitespace ( class CaMeL Attr . char CaMeL At ( i ) ) ) { if ( in CaMeL Class ) { if ( i - start == want CaMeL Len && class CaMeL Attr . region CaMeL Matches ( true , start , class CaMeL Name , 0 , want CaMeL Len ) ) { return true ; } in CaMeL Class = false ; } } else { if ( ! in CaMeL Class ) { in CaMeL Class = true ; start = i ; } } } if ( in CaMeL Class && len - start == want CaMeL Len ) { return class CaMeL Attr . region CaMeL Matches ( true , start , class CaMeL Name , 0 , want CaMeL Len ) ; } return false ; }	 
String name = t . as CaMeL End CaMeL Tag ( ) . normal CaMeL Name ( ) ;  <CTX>	 
int bottom = stack . size ( ) - 1 ; if ( bottom > Max CaMeL Scope CaMeL Search CaMeL Depth ) { bottom = Max CaMeL Scope CaMeL Search CaMeL Depth ; }  <CTX>  private boolean in CaMeL Specific CaMeL Scope ( String [ ] target CaMeL Names , String [ ] base CaMeL Types , String [ ] extra CaMeL Types ) { int bottom = stack . size ( ) - 1 ; if ( bottom > Max CaMeL Scope CaMeL Search CaMeL Depth ) { bottom = Max CaMeL Scope CaMeL Search CaMeL Depth ; } final int top = bottom > Max CaMeL Scope CaMeL Search CaMeL Depth ? bottom - Max CaMeL Scope CaMeL Search CaMeL Depth : 0 ; for ( int pos = bottom ; pos >= top ; pos -- ) { final String el CaMeL Name = stack . get ( pos ) . node CaMeL Name ( ) ; if ( in CaMeL Sorted ( el CaMeL Name , target CaMeL Names ) ) return true ; if ( in CaMeL Sorted ( el CaMeL Name , base CaMeL Types ) ) return false ; if ( extra CaMeL Types != null && in CaMeL Sorted ( el CaMeL Name , extra CaMeL Types ) ) return false ; } return false ; }	 
if ( ! ( out . syntax ( ) == Document . Output CaMeL Settings . Syntax . html && ( val == null || val . equals ( key ) && Attribute . is CaMeL Boolean CaMeL Attribute ( key ) ) ) ) {  <CTX>	 
String el CaMeL Name = end CaMeL Tag . name ( ) ;  <CTX>  private void pop CaMeL Stack CaMeL To CaMeL Close ( Token . End CaMeL Tag end CaMeL Tag ) { String el CaMeL Name = end CaMeL Tag . name ( ) ; Element first CaMeL Found = null ; for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element next = stack . get ( pos ) ; if ( next . node CaMeL Name ( ) . equals ( el CaMeL Name ) ) { first CaMeL Found = next ; break ; } } if ( first CaMeL Found == null ) return ; for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element next = stack . get ( pos ) ; stack . remove ( pos ) ; if ( next == first CaMeL Found ) break ; } }	 
Element el =  <CTX>  public void head ( org . j@@ soup . nodes . Node source , int depth ) { namespaces CaMeL Stack . push ( new Hash CaMeL Map < > ( namespaces CaMeL Stack . peek ( ) ) ) ; if ( source instanceof org . j@@ soup . nodes . Element ) { org . j@@ soup . nodes . Element source CaMeL El = ( org . j@@ soup . nodes . Element ) source ; String prefix = update CaMeL Namespaces ( source CaMeL El ) ; String namespace = namespaces CaMeL Stack . peek ( ) . get ( prefix ) ; String tag CaMeL Name = source CaMeL El . tag CaMeL Name ( ) ; Element el = doc . create CaMeL Element CaMeL NS ( namespace , tag CaMeL Name ) ; copy CaMeL Attributes ( source CaMeL El , el ) ; if ( dest == null ) { doc . append CaMeL Child ( el ) ; } else { dest . append CaMeL Child ( el ) ; } dest = el ; } else if ( source instanceof org . j@@ soup . nodes . Text CaMeL Node ) { org . j@@ soup . nodes . Text CaMeL Node source CaMeL Text = ( org . j@@ soup . nodes . Text CaMeL Node ) source ; Text text = doc . create CaMeL Text CaMeL Node ( source CaMeL Text . get CaMeL Whole CaMeL Text ( ) ) ; dest . append CaMeL Child ( text ) ; } else if ( source instanceof org . j@@ soup . nodes . Comment ) { org . j@@ soup . nodes . Comment source CaMeL Comment = ( org . j@@ soup . nodes . Comment ) source ; Comment comment = doc . create CaMeL Comment ( source CaMeL Comment . get CaMeL Data ( ) ) ; dest . append CaMeL Child ( comment ) ; } else if ( source instanceof org . j@@ soup . nodes . Data CaMeL Node ) { org . j@@ soup . nodes . Data CaMeL Node source CaMeL Data = ( org . j@@ soup . nodes . Data CaMeL Node ) source ; Text node = doc . create CaMeL Text CaMeL Node ( source CaMeL Data . get CaMeL Whole CaMeL Data ( ) ) ; dest . append CaMeL Child ( node ) ; } else { } }	 
if ( doc . child CaMeL Node CaMeL Size ( ) > 0 ) {  <CTX>  public Xml CaMeL Declaration as CaMeL Xml CaMeL Declaration ( ) { String data = get CaMeL Data ( ) ; Document doc = Jsoup . parse ( $STRING$ + data . substring ( 1 , data . length ( ) - 1 ) + $STRING$ , base CaMeL Uri ( ) , Parser . xml CaMeL Parser ( ) ) ; Xml CaMeL Declaration decl = null ; if ( doc . child CaMeL Node CaMeL Size ( ) > 0 ) { Element el = doc . child ( 0 ) ; decl = new Xml CaMeL Declaration ( Node CaMeL Utils . parser ( doc ) . settings ( ) . normalize CaMeL Tag ( el . tag CaMeL Name ( ) ) , data . starts CaMeL With ( $STRING$ ) ) ; decl . attributes ( ) . add CaMeL All ( el . attributes ( ) ) ; } return decl ; }	 
return val ;  <CTX>  public String get CaMeL Value ( ) { return val ; }	 
throw new JX CaMeL Path CaMeL Exception ( $STRING$ + p 1 + $STRING$ + p $NUMBER$ + $STRING$ ) ;  <CTX>  private int compare CaMeL Node CaMeL Pointers ( Node CaMeL Pointer p 1 , int depth 1 , Node CaMeL Pointer p $NUMBER$ , int depth $NUMBER$ ) { if ( depth 1 < depth $NUMBER$ ) { int r = compare CaMeL Node CaMeL Pointers ( p 1 , depth 1 , p $NUMBER$ . parent , depth $NUMBER$ - 1 ) ; return r == 0 ? - 1 : r ; } if ( depth 1 > depth $NUMBER$ ) { int r = compare CaMeL Node CaMeL Pointers ( p 1 . parent , depth 1 - 1 , p $NUMBER$ , depth $NUMBER$ ) ; return r == 0 ? 1 : r ; } if ( p 1 == null && p $NUMBER$ == null ) { return 0 ; } if ( p 1 != null && p 1 . equals ( p $NUMBER$ ) ) { return 0 ; } if ( depth 1 == 1 ) { throw new JX CaMeL Path CaMeL Exception ( $STRING$ + p 1 + $STRING$ + p $NUMBER$ + $STRING$ ) ; } int r = compare CaMeL Node CaMeL Pointers ( p 1 . parent , depth 1 - 1 , p $NUMBER$ . parent , depth $NUMBER$ - 1 ) ; if ( r != 0 ) { return r ; } return p 1 . parent . compare CaMeL Child CaMeL Node CaMeL Pointers ( p 1 , p $NUMBER$ ) ; }	 
return compute ( args [ 0 ] . compute CaMeL Value ( context ) , args [ 1 ] . compute CaMeL Value ( context ) )  <CTX>  public final Object compute CaMeL Value ( Eval CaMeL Context context ) { return compute ( args [ 0 ] . compute CaMeL Value ( context ) , args [ 1 ] . compute CaMeL Value ( context ) ) ? Boolean . TRUE : Boolean . FALSE ; }	 
return equal CaMeL Strings ( namespace CaMeL URI , node CaMeL NS ) ;  <CTX>  public static boolean test CaMeL Node ( Node node , Node CaMeL Test test ) { if ( test == null ) { return true ; } if ( test instanceof Node CaMeL Name CaMeL Test ) { if ( node . get CaMeL Node CaMeL Type ( ) != Node . ELEMENT _ NODE ) { return false ; } Node CaMeL Name CaMeL Test node CaMeL Name CaMeL Test = ( Node CaMeL Name CaMeL Test ) test ; Q CaMeL Name test CaMeL Name = node CaMeL Name CaMeL Test . get CaMeL Node CaMeL Name ( ) ; String namespace CaMeL URI = node CaMeL Name CaMeL Test . get CaMeL Namespace CaMeL URI ( ) ; boolean wildcard = node CaMeL Name CaMeL Test . is CaMeL Wildcard ( ) ; String test CaMeL Prefix = test CaMeL Name . get CaMeL Prefix ( ) ; if ( wildcard && test CaMeL Prefix == null ) { return true ; } if ( wildcard || test CaMeL Name . get CaMeL Name ( ) . equals ( DOM CaMeL Node CaMeL Pointer . get CaMeL Local CaMeL Name ( node ) ) ) { String node CaMeL NS = DOM CaMeL Node CaMeL Pointer . get CaMeL Namespace CaMeL URI ( node ) ; return equal CaMeL Strings ( namespace CaMeL URI , node CaMeL NS ) ; } return false ; } if ( test instanceof Node CaMeL Type CaMeL Test ) { int node CaMeL Type = node . get CaMeL Node CaMeL Type ( ) ; switch ( ( ( Node CaMeL Type CaMeL Test ) test ) . get CaMeL Node CaMeL Type ( ) ) { case Compiler . NODE _ TYPE _ NODE : return node CaMeL Type == Node . ELEMENT _ NODE || node CaMeL Type == Node . DOCUMENT _ NODE ; case Compiler . NODE _ TYPE _ TEXT : return node CaMeL Type == Node . CDATA _ SECTION _ NODE || node CaMeL Type == Node . TEXT _ NODE ; case Compiler . NODE _ TYPE _ COMMENT : return node CaMeL Type == Node . COMMENT _ NODE ; case Compiler . NODE _ TYPE _ PI : return node CaMeL Type == Node . PROCESSING _ INSTRUCTION _ NODE ; } return false ; } if ( test instanceof Processing CaMeL Instruction CaMeL Test ) { if ( node . get CaMeL Node CaMeL Type ( ) == Node . PROCESSING _ INSTRUCTION _ NODE ) { String test CaMeL PI = ( ( Processing CaMeL Instruction CaMeL Test ) test ) . get CaMeL Target ( ) ; String node CaMeL PI = ( ( Processing CaMeL Instruction ) node ) . get CaMeL Target ( ) ; return test CaMeL PI . equals ( node CaMeL PI ) ; } } return false ; }	 
return Value CaMeL Utils . get CaMeL Length ( get CaMeL Base CaMeL Value ( ) ) ;  <CTX>  public int get CaMeL Length ( ) { return Value CaMeL Utils . get CaMeL Length ( get CaMeL Base CaMeL Value ( ) ) ; }	 
