if ( model != null )  <CTX>  private void add CaMeL Feature CaMeL Plugins ( I CaMeL Feature feature , Hash CaMeL Map map ) { Plugin CaMeL Model CaMeL Manager manager = PDE CaMeL Core . get CaMeL Default ( ) . get CaMeL Model CaMeL Manager ( ) ; I CaMeL Feature CaMeL Plugin [ ] plugins = feature . get CaMeL Plugins ( ) ; for ( int i = 0 ; i < plugins . length ; i ++ ) { String id = plugins [ i ] . get CaMeL Id ( ) ; if ( id == null || map . contains CaMeL Key ( id ) ) continue ; I CaMeL Plugin CaMeL Model CaMeL Base model = manager . find CaMeL Model ( id ) ; if ( model != null ) map . put ( id , model ) ; } }	if ( model != null && Target CaMeL Platform . matches CaMeL Current CaMeL Environment ( model ) )
int sum = 0 ;  <CTX>  public double add ( int [ ] array ) { int sum = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) sum += array [ i ] ; return sum ; }	double sum = 0 ;
if ( row CaMeL Being CaMeL Edited > - 1 && column CaMeL Being CaMeL Edited > - 1 ) { if ( get CaMeL Value CaMeL At ( row CaMeL Being CaMeL Edited , column CaMeL Being CaMeL Edited ) instanceof J CaMeL Text CaMeL Field )  <CTX>  public void editing CaMeL Canceled ( Change CaMeL Event event ) { if ( row CaMeL Being CaMeL Edited > - 1 && column CaMeL Being CaMeL Edited > - 1 ) { if ( get CaMeL Value CaMeL At ( row CaMeL Being CaMeL Edited , column CaMeL Being CaMeL Edited ) instanceof J CaMeL Text CaMeL Field ) { remove ( ( Component ) get CaMeL Value CaMeL At ( row CaMeL Being CaMeL Edited , column CaMeL Being CaMeL Edited ) ) ; set CaMeL Value CaMeL At ( old CaMeL Cell CaMeL Value , row CaMeL Being CaMeL Edited , column CaMeL Being CaMeL Edited ) ; } row CaMeL Being CaMeL Edited = - 1 ; column CaMeL Being CaMeL Edited = - 1 ; } editor CaMeL Timer . stop ( ) ; editor CaMeL Comp = null ; cell CaMeL Editor = null ; request CaMeL Focus CaMeL In CaMeL Window ( false ) ; repaint ( ) ; }	if ( editor CaMeL Comp != null )
if ( current CaMeL Window == null ) return ;  <CTX>  public static void animate CaMeL Down ( Rectangle start CaMeL Position ) { I CaMeL Workbench CaMeL Window current CaMeL Window = Platform CaMeL UI . get CaMeL Workbench ( ) . get CaMeL Active CaMeL Workbench CaMeL Window ( ) ; if ( current CaMeL Window == null ) return ; Workbench CaMeL Window internal CaMeL Window = ( Workbench CaMeL Window ) current CaMeL Window ; Progress CaMeL Region progress CaMeL Region = internal CaMeL Window . get CaMeL Progress CaMeL Region ( ) ; if ( progress CaMeL Region == null ) return ; Rectangle end CaMeL Position = progress CaMeL Region . get CaMeL Control ( ) . get CaMeL Bounds ( ) ; Point window CaMeL Location = internal CaMeL Window . get CaMeL Shell ( ) . get CaMeL Location ( ) ; end CaMeL Position . x += window CaMeL Location . x ; end CaMeL Position . y += window CaMeL Location . y ; Rectangle CaMeL Animation animation = new Rectangle CaMeL Animation ( internal CaMeL Window . get CaMeL Shell ( ) , start CaMeL Position , end CaMeL Position ) ; animation . schedule ( ) ; }	if ( current CaMeL Window == null ) { return ; }
Ruby CaMeL Array ary = Ruby CaMeL Array . new CaMeL Array ( get CaMeL Runtime ( ) ) ;  <CTX>  public I CaMeL Ruby CaMeL Object scan ( I CaMeL Ruby CaMeL Object arg ) { Ruby CaMeL Regexp pat = Ruby CaMeL Regexp . regexp CaMeL Value ( arg ) ; int start = 0 ; if ( ! get CaMeL Runtime ( ) . is CaMeL Block CaMeL Given ( ) ) { Ruby CaMeL Array ary = Ruby CaMeL Array . new CaMeL Array ( get CaMeL Runtime ( ) ) ; while ( pat . search ( this , start ) != - 1 ) { Ruby CaMeL Match CaMeL Data md = ( Ruby CaMeL Match CaMeL Data ) get CaMeL Runtime ( ) . get CaMeL Backref ( ) ; if ( md . get CaMeL Size ( ) == 1 ) { ary . append ( md . group ( 0 ) ) ; } else { ary . append ( md . subseq ( 1 , md . get CaMeL Size ( ) ) ) ; } if ( md . match CaMeL End CaMeL Position ( ) == md . match CaMeL Start CaMeL Position ( ) ) { start ++ ; } else { start = md . match CaMeL End CaMeL Position ( ) ; } } return ary ; } while ( pat . search ( this , start ) != - 1 ) { Ruby CaMeL Match CaMeL Data md = ( Ruby CaMeL Match CaMeL Data ) get CaMeL Runtime ( ) . get CaMeL Backref ( ) ; if ( md . get CaMeL Size ( ) == 1 ) { get CaMeL Runtime ( ) . yield ( md . group ( 0 ) ) ; } else { get CaMeL Runtime ( ) . yield ( md . subseq ( 1 , md . get CaMeL Size ( ) ) ) ; } if ( md . match CaMeL End CaMeL Position ( ) == md . match CaMeL Start CaMeL Position ( ) ) { start ++ ; } else { start = md . match CaMeL End CaMeL Position ( ) ; } } return this ; }	Ruby CaMeL Array ary = get CaMeL Runtime ( ) . new CaMeL Array ( ) ;
return first CaMeL Sibling ( member , evaluator ) ;  <CTX>  public Member evaluate CaMeL Member ( Evaluator evaluator ) { Member member = member CaMeL Calc . evaluate CaMeL Member ( evaluator ) ; return first CaMeL Sibling ( member , evaluator ) ; }	return first CaMeL Child ( evaluator , member ) ;
if ( _ address != null && addr . _ address == null )  <CTX>  public boolean equals ( Object o ) { if ( ! ( o instanceof Fre@@ en@@ et CaMeL Inet CaMeL Address ) ) { return false ; } Fre@@ en@@ et CaMeL Inet CaMeL Address addr = ( Fre@@ en@@ et CaMeL Inet CaMeL Address ) o ; if ( hostname != null ) { if ( addr . hostname == null ) return false ; if ( ! hostname . equals CaMeL Ignore CaMeL Case ( addr . hostname ) ) { return false ; } / / Now that we know we have the same hostname , we can propagate the IP . if ( _ address != null && addr . _ address == null ) addr . _ address = _ address ; if ( addr . _ address != null && _ address == null ) _ address = addr . _ address ; / / Except if we actually do have two different look@@ ed - up I CaMeL Ps ! if ( addr . _ address != null && _ address != null && ! addr . _ address . equals ( _ address ) ) return false ; / / Equal . return true ; } / / No hostname , go by address . if ( ! _ address . equals ( addr . _ address ) ) { return false ; } return true ; }	if ( ( _ address != null ) && ( addr . _ address == null ) )
return new Simple CaMeL Date CaMeL Format ( Date CaMeL Constants . DATETIME _ SECONDS _ FORMAT _ STRING ) . format ( date ) ;  <CTX>  private static String make CaMeL Sql CaMeL String CaMeL From CaMeL Date ( Date date ) { if ( null == date ) { return null ; } return new Simple CaMeL Date CaMeL Format ( Date CaMeL Constants . DATETIME _ SECONDS _ FORMAT _ STRING ) . format ( date ) ; }	return new Simple CaMeL Date CaMeL Format ( Date CaMeL Constants . DATETIME _ FORMAT _ STRING ) . format ( date ) ;
if ( bindings . is CaMeL Fully CaMeL Resolved ( n ) ) {  <CTX>  public I CaMeL Binding [ ] find ( String name ) { char [ ] n = name . to CaMeL Char CaMeL Array ( ) ; if ( bindings . is CaMeL Fully CaMeL Resolved ( n ) ) { Object o = bindings . get ( n ) ; if ( o instanceof I CaMeL Binding [ ] ) return ( I CaMeL Binding [ ] ) Array CaMeL Util . trim ( I CaMeL Binding . class , ( Object [ ] ) o ) ; return new I CaMeL Binding [ ] { ( I CaMeL Binding ) o } ; } Lookup CaMeL Data data = new Lookup CaMeL Data ( n ) ; try { data . found CaMeL Items = CPP CaMeL Semantics . lookup CaMeL In CaMeL Scope ( data , this , null , null ) ; } catch ( DOM CaMeL Exception e ) { } if ( data . found CaMeL Items != null ) { IAST CaMeL Name [ ] ns = ( IAST CaMeL Name [ ] ) data . found CaMeL Items ; Object CaMeL Set set = new Object CaMeL Set ( ns . length ) ; for ( int i = 0 ; i < ns . length && ns [ i ] != null ; i ++ ) { set . put ( ns [ i ] . resolve CaMeL Binding ( ) ) ; } return ( I CaMeL Binding [ ] ) Array CaMeL Util . trim ( I CaMeL Binding . class , set . key CaMeL Array ( ) , true ) ; } return new I CaMeL Binding [ 0 ] ; }	if ( bindings != null && bindings . is CaMeL Fully CaMeL Resolved ( n ) ) {
int count = 0 ; Player player = get CaMeL Active CaMeL Player ( ) ; for ( int i = 0 ; i < get CaMeL Num CaMeL Cri@@ tters ( ) ; i ++ ) { Critter cri@@ tter = get CaMeL Critter ( i ) ; if ( cri@@ tter . get CaMeL Player ( ) == player ) { if ( ! cri@@ tter . has CaMeL Moved ( ) && ! cri@@ tter . is CaMeL In CaMeL Contact ( false ) ) { count ++ ; Battle CaMeL Hex hex = cri@@ tter . get CaMeL Current CaMeL Hex ( ) ; hex . select ( ) ; hex . repaint ( ) ; } } } return count ;  <CTX>  public int highlight CaMeL Movable CaMeL Ch@@ its ( ) { map . unselect CaMeL All CaMeL Hexes ( ) ; int count = 0 ; Player player = get CaMeL Active CaMeL Player ( ) ; for ( int i = 0 ; i < get CaMeL Num CaMeL Cri@@ tters ( ) ; i ++ ) { Critter cri@@ tter = get CaMeL Critter ( i ) ; if ( cri@@ tter . get CaMeL Player ( ) == player ) { if ( ! cri@@ tter . has CaMeL Moved ( ) && ! cri@@ tter . is CaMeL In CaMeL Contact ( false ) ) { count ++ ; Battle CaMeL Hex hex = cri@@ tter . get CaMeL Current CaMeL Hex ( ) ; hex . select ( ) ; hex . repaint ( ) ; } } } return count ; }	map . select CaMeL Hexes CaMeL By CaMeL Labels ( set ) ; return set . size ( ) ;
Navigator CaMeL Content CaMeL Extension [ ] result CaMeL Instances = find CaMeL Relevant CaMeL Content CaMeL Extensions ( an CaMeL Element ) ;  <CTX>  public I CaMeL Tree CaMeL Content CaMeL Provider [ ] find CaMeL Parent CaMeL Content CaMeL Providers ( Object an CaMeL Element ) { Navigator CaMeL Content CaMeL Extension [ ] result CaMeL Instances = find CaMeL Relevant CaMeL Content CaMeL Extensions ( an CaMeL Element ) ; return extract CaMeL Content CaMeL Providers ( result CaMeL Instances ) ; }	Navigator CaMeL Content CaMeL Extension [ ] result CaMeL Instances = find CaMeL Content CaMeL Extensions CaMeL By CaMeL Trigger CaMeL Point ( an CaMeL Element ) ;
Collection filters = new CaMeL Filters ( extension ) ; registered CaMeL Filters . add CaMeL All ( filters ) ; Iterator new CaMeL Filters = filters . iterator ( ) ; while ( new CaMeL Filters . has CaMeL Next ( ) ) { tracker . register CaMeL Object ( extension , new CaMeL Filters . next ( ) , I CaMeL Extension CaMeL Tracker . REF _ STRONG ) ; }  <CTX>  public void add CaMeL Extension ( I CaMeL Extension CaMeL Tracker tracker , I CaMeL Extension extension ) { Collection filters = new CaMeL Filters ( extension ) ; registered CaMeL Filters . add CaMeL All ( filters ) ; Iterator new CaMeL Filters = filters . iterator ( ) ; while ( new CaMeL Filters . has CaMeL Next ( ) ) { tracker . register CaMeL Object ( extension , new CaMeL Filters . next ( ) , I CaMeL Extension CaMeL Tracker . REF _ STRONG ) ; } }	process CaMeL Extension ( tracker , extension ) ;
if ( feature CaMeL Id . region CaMeL Matches ( prefix CaMeL Length , Constants . SCHEMA _ NORMALIZED _ VALUE , 0 , Constants . SCHEMA _ NORMALIZED _ VALUE . length ( ) ) ) {  <CTX>  protected void check CaMeL Feature ( String feature CaMeL Id ) throws XML CaMeL Configuration CaMeL Exception { / / / / Xerces Features / / if ( feature CaMeL Id . starts CaMeL With ( Constants . XERCES _ FEATURE _ PREFIX ) ) { final int prefix CaMeL Length = Constants . XERCES _ FEATURE _ PREFIX . length ( ) ; / / / / http : / / apache . org / xml / features / validation / schema / / Le@@ ts the user turn Schema validation support on / off . / / if ( feature CaMeL Id . region CaMeL Matches ( prefix CaMeL Length , Constants . SCHEMA _ VALIDATION _ FEATURE , 0 , Constants . SCHEMA _ VALIDATION _ FEATURE . length ( ) ) ) { return ; } / / activate full schema checking if ( feature CaMeL Id . region CaMeL Matches ( prefix CaMeL Length , Constants . SCHEMA _ FULL _ CHECKING , 0 , Constants . SCHEMA _ FULL _ CHECKING . length ( ) ) ) { return ; } / / Feature identifier : expose schema normalized value / / http : / / apache . org / xml / features / validation / schema / normalized - value if ( feature CaMeL Id . region CaMeL Matches ( prefix CaMeL Length , Constants . SCHEMA _ NORMALIZED _ VALUE , 0 , Constants . SCHEMA _ NORMALIZED _ VALUE . length ( ) ) ) { return ; } / / Feature identifier : send element default value via characters ( ) / / http : / / apache . org / xml / features / validation / schema / element - default if ( feature CaMeL Id . region CaMeL Matches ( prefix CaMeL Length , Constants . SCHEMA _ ELEMENT _ DEFAULT , 0 , Constants . SCHEMA _ ELEMENT _ DEFAULT . length ( ) ) ) { return ; } } / / / / Not recognized / / super . check CaMeL Feature ( feature CaMeL Id ) ; } / / check CaMeL Feature ( String )	if ( suffix CaMeL Length == Constants . SCHEMA _ NORMALIZED _ VALUE . length ( ) && feature CaMeL Id . ends CaMeL With ( Constants . SCHEMA _ NORMALIZED _ VALUE ) ) {
I CaMeL Report CaMeL Provider provider = Editor CaMeL Util . get CaMeL Report CaMeL Provider ( this , get CaMeL Editor CaMeL Input ( ) ) ; if ( provider != null && get CaMeL Error CaMeL L CaMeL I@@ ine ( ) > - 1 )  <CTX>  public void do CaMeL Save ( I CaMeL Progress CaMeL Monitor progress CaMeL Monitor ) { super . do CaMeL Save ( progress CaMeL Monitor ) ; I CaMeL Report CaMeL Provider provider = Editor CaMeL Util . get CaMeL Report CaMeL Provider ( this , get CaMeL Editor CaMeL Input ( ) ) ; if ( provider != null && get CaMeL Error CaMeL L CaMeL I@@ ine ( ) > - 1 ) { Module CaMeL Handle model = provider . get CaMeL Report CaMeL Module CaMeL Handle ( get CaMeL Editor CaMeL Input ( ) , true ) ; Session CaMeL Handle CaMeL Adapter . get CaMeL Instance ( ) . set CaMeL Report CaMeL Design CaMeL Handle ( model ) ; } }	I CaMeL Report CaMeL Provider provider = get CaMeL Provider ( ) ; if ( provider != null && get CaMeL Error CaMeL L CaMeL I@@ ine ( ) == - 1 )
Timer CaMeL Task make CaMeL Task ( ) {  <CTX>  Timer CaMeL Task make CaMeL Task ( ) { return new Task ( ) ; }	Runnable make CaMeL Task ( ) {
handler = new IO CaMeL Handler CaMeL Socket ( get CaMeL Runtime ( ) , socket . get CaMeL Input CaMeL Stream ( ) , socket . get CaMeL Output CaMeL Stream ( ) ) ;  <CTX>  public I CaMeL Ruby CaMeL Object initialize ( I CaMeL Ruby CaMeL Object arg ) { socket = extract CaMeL Socket ( arg ) ; try { handler = new IO CaMeL Handler CaMeL Socket ( get CaMeL Runtime ( ) , socket . get CaMeL Input CaMeL Stream ( ) , socket . get CaMeL Output CaMeL Stream ( ) ) ; } catch ( IO CaMeL Exception e ) { throw get CaMeL Runtime ( ) . new CaMeL IO CaMeL Error ( e . get CaMeL Message ( ) ) ; } register CaMeL IO CaMeL Handler ( handler ) ; modes = handler . get CaMeL Modes ( ) ; return this ; }	handler = new IO CaMeL Handler CaMeL Nio ( get CaMeL Runtime ( ) , socket CaMeL Channel ) ;
queue CaMeL For CaMeL Decoration ( element , adapted CaMeL Element ) ;  <CTX>  public String decorate CaMeL With CaMeL Text ( String text , Object element , Object adapted CaMeL Element ) { / / We do not support decoration of null if ( element == null ) return text ; Decoration CaMeL Result decoration = ( Decoration CaMeL Result ) result CaMeL Cache . get ( element ) ; if ( decoration == null ) { queue CaMeL For CaMeL Decoration ( element , adapted CaMeL Element ) ; return text ; } else return decoration . decorate CaMeL With CaMeL Text ( text ) ; }	queue CaMeL For CaMeL Decoration ( element , adapted CaMeL Element , false ) ;
super ( report CaMeL Context ) ;  <CTX>  public Data CaMeL Set CaMeL Script CaMeL Executor ( Data CaMeL Set CaMeL Handle data CaMeL Set CaMeL Handle , I CaMeL Report CaMeL Context report CaMeL Context ) { super ( report CaMeL Context ) ; this . data CaMeL Set CaMeL Handle = data CaMeL Set CaMeL Handle ; String class CaMeL Name = data CaMeL Set CaMeL Handle . get CaMeL Event CaMeL Handler CaMeL Class ( ) ; init CaMeL Event CaMeL Handler ( class CaMeL Name ) ; }	super ( context ) ;
if ( sealed ) { f . seal CaMeL Object ( ) ; } Scriptable CaMeL Object . define CaMeL Property ( scope , name , f , attributes ) ;  <CTX>  public static void define CaMeL Constructor ( Scriptable scope , String name , Id CaMeL Function CaMeL Master master , int id , int attributes , boolean sealed ) { Id CaMeL Function f = new Id CaMeL Function ( master , name , id ) ; f . set CaMeL Parent CaMeL Scope ( scope ) ; f . use CaMeL Call CaMeL As CaMeL Constructor = true ; if ( sealed ) { f . seal CaMeL Object ( ) ; } Scriptable CaMeL Object . define CaMeL Property ( scope , name , f , attributes ) ; }	f . define CaMeL As CaMeL Scope CaMeL Property ( scope , attributes , seal ) ;
m _ log CaMeL Prefix = prefix ;  <CTX>  public void set CaMeL Log CaMeL Prefix ( String prefix ) { m _ log CaMeL Prefix = prefix ; }	synchronized ( this ) { m _ log CaMeL Prefix = prefix ; }
i CaMeL Visited . accept ( _ Payload ) ;  <CTX>  public void visit CaMeL M CaMeL Asgn CaMeL Node ( M CaMeL Asgn CaMeL Node i CaMeL Visited ) { i CaMeL Visited . accept ( _ Payload ) ; }	_ Payload . visit CaMeL M CaMeL Asgn CaMeL Node ( i CaMeL Visited ) ;
if ( ! ( p instanceof Realm CaMeL Principal ) ) { Realm CaMeL Principal rp = new Realm CaMeL Principal ( login CaMeL Domain CaMeL Name , p , realm CaMeL Name ) ; if ( ! processed CaMeL Principals . contains ( rp ) ) { list . add ( Context CaMeL Manager . register CaMeL Principal ( rp ) ) ; processed CaMeL Principals . add ( p ) ; }  <CTX>  public void process CaMeL Principals ( String login CaMeL Domain CaMeL Name ) { List list = new Linked CaMeL List ( ) ; for ( Iterator it = subject . get CaMeL Principals ( ) . iterator ( ) ; it . has CaMeL Next ( ) ; ) { Principal p = ( Principal ) it . next ( ) ; if ( ! ( p instanceof Realm CaMeL Principal ) ) { Realm CaMeL Principal rp = new Realm CaMeL Principal ( login CaMeL Domain CaMeL Name , p , realm CaMeL Name ) ; if ( ! processed CaMeL Principals . contains ( rp ) ) { list . add ( Context CaMeL Manager . register CaMeL Principal ( rp ) ) ; processed CaMeL Principals . add ( p ) ; } } } subject . get CaMeL Principals ( ) . add CaMeL All ( list ) ; }	if ( ! ( p instanceof Realm CaMeL Principal ) && ! processed CaMeL Principals . contains ( p ) ) { list . add ( Context CaMeL Manager . register CaMeL Principal ( new Realm CaMeL Principal ( login CaMeL Domain CaMeL Name , p , realm CaMeL Name ) ) ) ; processed CaMeL Principals . add ( p ) ;
Conflicts CaMeL Dialog conflicts CaMeL Dialog = new Conflicts CaMeL Dialog ( my CaMeL Project ) ;  <CTX>  public boolean check CaMeL Conflicts ( Pull CaMeL Up CaMeL Dialog dialog ) { final Member CaMeL Info [ ] infos = dialog . get CaMeL Selected CaMeL Member CaMeL Infos ( ) ; Psi CaMeL Class super CaMeL Class = dialog . get CaMeL Super CaMeL Class ( ) ; if ( ! check CaMeL Writable ( super CaMeL Class , infos ) ) return false ; String [ ] conflicts = Pull CaMeL Up CaMeL Conflicts CaMeL Util . check CaMeL Conflicts ( infos , my CaMeL Subclass , super CaMeL Class , null , null , dialog . get CaMeL Containment CaMeL Verifier ( ) ) ; if ( conflicts . length > 0 ) { Conflicts CaMeL Dialog conflicts CaMeL Dialog = new Conflicts CaMeL Dialog ( my CaMeL Project ) ; conflicts CaMeL Dialog . show ( ) ; return conflicts CaMeL Dialog . is CaMeL OK ( ) ; } return true ; }	Conflicts CaMeL Dialog conflicts CaMeL Dialog = new Conflicts CaMeL Dialog ( my CaMeL Project , conflicts ) ;
int type )  <CTX>  private static Object do CaMeL Scriptable CaMeL Incr CaMeL Decr ( Scriptable target , String id , Scriptable proto CaMeL Chain CaMeL Start , Object value , int type ) { boolean post = ( type == Node . POST _ INC || type == Node . POST _ DEC ) ; double number ; if ( value instanceof Number ) { number = ( ( Number ) value ) . double CaMeL Value ( ) ; } else { number = to CaMeL Number ( value ) ; if ( post ) { / / convert result to number value = new Double ( number ) ; } } if ( type == Node . PRE _ INC || type == Node . POST _ INC ) { ++ number ; } else { -- number ; } Number result = new Double ( number ) ; target . put ( id , proto CaMeL Chain CaMeL Start , result ) ; if ( post ) { return value ; } else { return result ; } }	int incr CaMeL Decr CaMeL Mask )
if ( this == obj ) return true ;  <CTX>  public boolean equals ( Object obj ) { / / Compare handles . if ( this == obj ) return true ; / / Compare class . if ( ! ( obj instanceof Drill CaMeL Frame ) ) return false ; / / Compare contents . Drill CaMeL Frame o CaMeL Other = ( Drill CaMeL Frame ) obj ; return ( ( f CaMeL Element == o CaMeL Other . f CaMeL Element ) && ( f CaMeL Property CaMeL Name . equals ( o CaMeL Other . f CaMeL Property CaMeL Name ) ) ) ; }	if ( this == obj ) { return true ; }
e CaMeL Dynamic CaMeL Unset ( e CaMeL Feature ) ;  <CTX>  public void e CaMeL Unset ( E CaMeL Structural CaMeL Feature e CaMeL Feature ) { switch ( e CaMeL Derived CaMeL Structural CaMeL Feature CaMeL ID ( e CaMeL Feature ) ) { case Layout CaMeL Package . BLOCK _ _ CHILDREN : get CaMeL Children ( ) . clear ( ) ; return ; case Layout CaMeL Package . BLOCK _ _ BOUNDS : set CaMeL Bounds ( ( Bounds ) null ) ; return ; case Layout CaMeL Package . BLOCK _ _ ANCHOR : unset CaMeL Anchor ( ) ; return ; case Layout CaMeL Package . BLOCK _ _ STRETCH : unset CaMeL Stretch ( ) ; return ; case Layout CaMeL Package . BLOCK _ _ INSETS : set CaMeL Insets ( ( Insets ) null ) ; return ; case Layout CaMeL Package . BLOCK _ _ ROW : unset CaMeL Row ( ) ; return ; case Layout CaMeL Package . BLOCK _ _ COLUMN : unset CaMeL Column ( ) ; return ; case Layout CaMeL Package . BLOCK _ _ ROW@@ SPAN : unset CaMeL Rowspan ( ) ; return ; case Layout CaMeL Package . BLOCK _ _ COLUMN@@ SPAN : unset CaMeL Colum@@ n@@ span ( ) ; return ; case Layout CaMeL Package . BLOCK _ _ MIN _ SIZE : set CaMeL Min CaMeL Size ( ( Size ) null ) ; return ; case Layout CaMeL Package . BLOCK _ _ OUTLINE : set CaMeL Outline ( ( Line CaMeL Attributes ) null ) ; return ; case Layout CaMeL Package . BLOCK _ _ BACKGROUND : set CaMeL Background ( ( Fill ) null ) ; return ; case Layout CaMeL Package . BLOCK _ _ VISIBLE : unset CaMeL Visible ( ) ; return ; case Layout CaMeL Package . BLOCK _ _ TRIGGERS : get CaMeL Triggers ( ) . clear ( ) ; return ; } e CaMeL Dynamic CaMeL Unset ( e CaMeL Feature ) ; }	super . e CaMeL Unset ( feature CaMeL ID ) ;
int index = layered CaMeL Pane . get CaMeL Index CaMeL Of ( this ) ;  <CTX>  public void hide ( ) { J CaMeL Layered CaMeL Pane layered CaMeL Pane ; layered CaMeL Pane = Swing CaMeL Utilities . get CaMeL Root CaMeL Pane ( invoker ) . get CaMeL Layered CaMeL Pane ( ) ; int index = layered CaMeL Pane . get CaMeL Index CaMeL Of ( this ) ; layered CaMeL Pane . remove ( index ) ; }	int index = layered CaMeL Pane . get CaMeL Index CaMeL Of ( c ) ;
return true ;  <CTX>  protected boolean is CaMeL Children CaMeL Finished ( ) { for ( int i = 0 ; i < children CaMeL Layouts . size ( ) ; i ++ ) { boolean child CaMeL Finished = ( ( Boolean ) children CaMeL Finished . get ( i ) ) . boolean CaMeL Value ( ) ; if ( ! child CaMeL Finished ) { return true ; } } return false ; }	return false ;
Thread [ ] parsers = new Thread [ options . proc ] ; int length = tree . length / options . proc ;  <CTX>  protected void parse CaMeL Multi CaMeL Proc ( final J CaMeL Compilation CaMeL Unit [ ] tree ) { try { Thread [ ] parsers = new Thread [ options . proc ] ; int length = tree . length / options . proc ; for ( int i = 0 ; i < options . proc ; i ++ ) { parsers [ i ] = new Threaded CaMeL Parser ( this , in@@ files , tree , i * length , i == options . proc - 1 ? tree . length : ( i + 1 ) * length ) ; parsers [ i ] . start ( ) ; } for ( int i = 0 ; i < options . proc ; i ++ ) { parsers [ i ] . join ( ) ; } } catch ( Interrupted CaMeL Exception ie ) { ie . print CaMeL Stack CaMeL Trace ( ) ; } }	Thread [ ] parsers = new Thread [ Kjc CaMeL Options . proc ] ; int length = tree . length / Kjc CaMeL Options . proc ;
synchronized ( m _ execution CaMeL Info )  <CTX>  Execution CaMeL Info ( final Thread CaMeL Pool pool , final Runnable command , final long delay , final long interval , final Logger logger ) { m _ pool = pool ; m _ command = command ; m _ delay = delay ; m _ interval = interval ; m _ logger = logger ; m _ next CaMeL Run = System . current CaMeL Time CaMeL Millis ( ) + delay ; synchronized ( m _ execution CaMeL Info ) { m _ execution CaMeL Info . add ( this ) ; m _ execution CaMeL Info . notify CaMeL All ( ) ; } }	synchronized ( m _ command CaMeL Stack )
DEFAULT _ CHART _ WIDTH , DEFAULT _ CHART _ HEIGHT ) ) ;  <CTX>  private void resize CaMeL Chart ( Chart chart CaMeL Model CaMeL Current ) { if ( chart CaMeL Model CaMeL Current . get CaMeL Block ( ) . get CaMeL Bounds ( ) == null || chart CaMeL Model CaMeL Current . get CaMeL Block ( ) . get CaMeL Bounds ( ) . get CaMeL Width ( ) == 0 || chart CaMeL Model CaMeL Current . get CaMeL Block ( ) . get CaMeL Bounds ( ) . get CaMeL Height ( ) == 0 ) { if ( chart CaMeL Model CaMeL Current instanceof Chart CaMeL Without CaMeL Axes CaMeL Impl ) { chart CaMeL Model CaMeL Current . get CaMeL Block ( ) . set CaMeL Bounds ( Bounds CaMeL Impl . create ( 0 , 0 , DEFAULT _ CHART _ WITHOUT _ AXIS _ WIDTH , DEFAULT _ CHART _ WITHOUT _ AXIS _ HEIGHT ) ) ; } else { chart CaMeL Model CaMeL Current . get CaMeL Block ( ) . set CaMeL Bounds ( Bounds CaMeL Impl . create ( 0 , 0 , DEFAULT _ CHART _ WIDTH , DEFAULT _ CHART _ HEIGHT ) ) ; } } }	DEFAULT _ CHART _ BLOCK _ WIDTH , DEFAULT _ CHART _ BLOCK _ HEIGHT ) ) ;
return new String CaMeL Value CaMeL Impl ( String . value CaMeL Of ( value ) ) ;  <CTX>  public static String CaMeL Value create ( char value ) { if ( value < CHAR _ STRINGS . length ) return CHAR _ STRINGS [ value ] ; else return new String CaMeL Value CaMeL Impl ( String . value CaMeL Of ( value ) ) ; }	return new String CaMeL Value CaMeL Impl ( value ) ;
return Ruby CaMeL Array . new CaMeL Array ( ruby , Arrays . as CaMeL List ( values ) ) ;  <CTX>  public Ruby CaMeL Array to _ a ( ) { return Ruby CaMeL Array . new CaMeL Array ( ruby , Arrays . as CaMeL List ( values ) ) ; }	return Ruby CaMeL Array . new CaMeL Array ( ruby , values ) ;
Level level = get CaMeL Level CaMeL Arg ( evaluator , args , 0 , true ) ; return level . get CaMeL Unique CaMeL Name ( ) ;  <CTX>  public Object evaluate ( Evaluator evaluator , Exp [ ] args ) { Level level = get CaMeL Level CaMeL Arg ( evaluator , args , 0 , true ) ; return level . get CaMeL Unique CaMeL Name ( ) ; }	Object o = get CaMeL Arg ( evaluator , args , 0 ) ; String CaMeL Buffer buf = new String CaMeL Buffer ( ) ; append CaMeL Member CaMeL Or CaMeL Tuple ( buf , o ) ; return buf . to CaMeL String ( ) ;
new Xml CaMeL Auto CaMeL Lookup CaMeL Handler ( ) . invoke ( my CaMeL Project , editor , file ) ; } } , null , null ) ;  <CTX>  public void auto CaMeL Popup CaMeL Xml CaMeL Lookup ( final Editor editor ) { if ( Application CaMeL Manager . get CaMeL Application ( ) . is CaMeL Unit CaMeL Test CaMeL Mode ( ) ) return ; final Code CaMeL Insight CaMeL Settings settings = Code CaMeL Insight CaMeL Settings . get CaMeL Instance ( ) ; if ( settings . AUTO _ POPUP _ XML _ LOOKUP ) { final Psi CaMeL File file = Psi CaMeL Document CaMeL Manager . get CaMeL Instance ( my CaMeL Project ) . get CaMeL Psi CaMeL File ( editor . get CaMeL Document ( ) ) ; if ( file == null ) return ; final Runnable request = new Runnable ( ) { public void run ( ) { Psi CaMeL Document CaMeL Manager . get CaMeL Instance ( my CaMeL Project ) . commit CaMeL All CaMeL Documents ( ) ; Command CaMeL Processor . get CaMeL Instance ( ) . execute CaMeL Command ( my CaMeL Project , new Runnable ( ) { public void run ( ) { new Xml CaMeL Auto CaMeL Lookup CaMeL Handler ( ) . invoke ( my CaMeL Project , editor , file ) ; } } , null , null ) ; } } ; / / invoke later prev@@ ents cancel@@ ling request by key CaMeL Pressed from the same action Application CaMeL Manager . get CaMeL Application ( ) . invoke CaMeL Later ( new Runnable ( ) { public void run ( ) { my CaMeL Alarm . add CaMeL Request ( request , settings . XML _ LOOKUP _ DELAY ) ; } } ) ; } }	Command CaMeL Processor . get CaMeL Instance ( ) . execute CaMeL Command ( my CaMeL Project , new Runnable ( ) { public void run ( ) { new Xml CaMeL Auto CaMeL Lookup CaMeL Handler ( ) . invoke ( my CaMeL Project , editor , file ) ; } } , null , null ) ; } } ) ;
if ( this . binder . is CaMeL Allowed CaMeL Cached CaMeL Left ( object ) ) {  <CTX>  public void assert CaMeL Tuple ( final Rete CaMeL Tuple left CaMeL Tuple , final Propagation CaMeL Context context , final Internal CaMeL Working CaMeL Memory working CaMeL Memory ) { final Beta CaMeL Memory memory = ( Beta CaMeL Memory ) working CaMeL Memory . get CaMeL Node CaMeL Memory ( this ) ; memory . get CaMeL Tuple CaMeL Memory ( ) . add ( left CaMeL Tuple ) ; this . binder . update CaMeL From CaMeL Tuple ( working CaMeL Memory , left CaMeL Tuple ) ; for ( final java . util . Iterator it = this . data CaMeL Provider . get CaMeL Results ( left CaMeL Tuple , working CaMeL Memory , context ) ; it . has CaMeL Next ( ) ; ) { final Object object = it . next ( ) ; / / First alpha node filters for ( int i = 0 , length = this . constraints . length ; i < length ; i ++ ) { if ( ! this . constraints [ i ] . is CaMeL Allowed ( object , working CaMeL Memory ) ) { / / next iteration continue ; } } if ( this . binder . is CaMeL Allowed CaMeL Cached CaMeL Left ( object ) ) { final Internal CaMeL Fact CaMeL Handle handle = working CaMeL Memory . get CaMeL Fact CaMeL Handle CaMeL Factory ( ) . new CaMeL Fact CaMeL Handle ( object ) ; memory . get CaMeL Created CaMeL Handles ( ) . put ( left CaMeL Tuple , handle ) ; this . sink . propagate CaMeL Assert CaMeL Tuple ( left CaMeL Tuple , handle , context , working CaMeL Memory ) ; } } }	if ( this . beta CaMeL Constraints . is CaMeL Allowed CaMeL Cached CaMeL Left ( object ) ) {
String str = Ruby CaMeL String . string CaMeL Value ( target ) . get CaMeL Value ( ) ;  <CTX>  public int search ( I CaMeL Ruby CaMeL Object target , int pos ) { String str = Ruby CaMeL String . string CaMeL Value ( target ) . get CaMeL Value ( ) ; if ( pos > str . length ( ) ) { return - 1 ; } recompile CaMeL If CaMeL Needed ( ) ; / / If nothing match then nil will be returned I CaMeL Ruby CaMeL Object result = match ( str , pos ) ; get CaMeL Runtime ( ) . get CaMeL Current CaMeL Context ( ) . set CaMeL Backref ( result ) ; / / If nothing match then - 1 will be returned return result instanceof Ruby CaMeL Match CaMeL Data ? ( ( Ruby CaMeL Match CaMeL Data ) result ) . match CaMeL Start CaMeL Position ( ) : - 1 ; }	String str = Ruby CaMeL String . string CaMeL Value ( target ) . to CaMeL String ( ) ;
this . out CaMeL Stream = out CaMeL Stream ;  <CTX>  public Commandline CaMeL Parser ( String [ ] arguments , Print CaMeL Stream out CaMeL Stream ) { this . arguments = arguments ; this . out CaMeL Stream = out CaMeL Stream ; process CaMeL Arguments ( ) ; }	this . main = main ;
if ( best CaMeL Data == null ) return null ;  <CTX>  public Font CaMeL Data [ ] best CaMeL Data CaMeL Array ( Font CaMeL Data [ ] fonts , Display display ) { Font CaMeL Data best CaMeL Data = best CaMeL Data ( fonts , display ) ; if ( best CaMeL Data == null ) return null ; Font CaMeL Data [ ] datas = new Font CaMeL Data [ 1 ] ; datas [ 0 ] = best CaMeL Data ; return datas ; }	if ( best CaMeL Data == null ) { return null ; }
block . set CaMeL Margin CaMeL Bottom CaMeL Override ( 0 ) ;  <CTX>  public static void collapse CaMeL Vertical CaMeL Margins ( Context c , Box block , Content content , float parent CaMeL Width ) { if ( content instanceof Collap@@ sable CaMeL Content ) { Collap@@ sable CaMeL Content collap@@ sable CaMeL Content = ( Collap@@ sable CaMeL Content ) content ; if ( ! collap@@ sable CaMeL Content . is CaMeL Collapsed ( ) ) { List ad@@ joining = are CaMeL Margins CaMeL Ad@@ joining ( c , collap@@ sable CaMeL Content , parent CaMeL Width ) ; if ( ad@@ joining != null ) { boolean return CaMeL Immediately = collapse CaMeL In CaMeL Between CaMeL Ad@@ joining ( c , block , collap@@ sable CaMeL Content , ad@@ joining ) ; if ( return CaMeL Immediately ) { return ; } } } if ( collap@@ sable CaMeL Content . is CaMeL Top CaMeL Margin CaMeL Collapsed ( ) ) { block . set CaMeL Margin CaMeL Top CaMeL Override ( 0 ) ; } else if ( may CaMeL Collapse CaMeL Into ( c , collap@@ sable CaMeL Content ) ) { Float collapsed CaMeL Top CaMeL Margin = collapse CaMeL Top CaMeL Margin ( c , collap@@ sable CaMeL Content , parent CaMeL Width ) ; if ( collapsed CaMeL Top CaMeL Margin != null ) { block . set CaMeL Margin CaMeL Top CaMeL Override ( collapsed CaMeL Top CaMeL Margin . int CaMeL Value ( ) ) ; } } else { Float collapsed CaMeL Top CaMeL Margin = calculate CaMeL Collapsed CaMeL Top ( c , content , parent CaMeL Width ) ; block . set CaMeL Margin CaMeL Top CaMeL Override ( collapsed CaMeL Top CaMeL Margin . int CaMeL Value ( ) ) ; } if ( collap@@ sable CaMeL Content . is CaMeL Bottom CaMeL Margin CaMeL Collapsed ( ) ) { block . set CaMeL Margin CaMeL Bottom CaMeL Override ( 0 ) ; } else if ( may CaMeL Collapse CaMeL Into ( c , collap@@ sable CaMeL Content ) ) { Float collapsed CaMeL Bottom CaMeL Margin = collapse CaMeL Bottom CaMeL Margin ( c , collap@@ sable CaMeL Content , parent CaMeL Width ) ; if ( collapsed CaMeL Bottom CaMeL Margin != null ) { block . set CaMeL Margin CaMeL Bottom CaMeL Override ( collapsed CaMeL Bottom CaMeL Margin . int CaMeL Value ( ) ) ; } } else { Float collapsed CaMeL Bottom CaMeL Margin = calculate CaMeL Adjusted CaMeL Margin CaMeL Bottom ( c , content , parent CaMeL Width ) ; block . set CaMeL Margin CaMeL Bottom CaMeL Override ( collapsed CaMeL Bottom CaMeL Margin . int CaMeL Value ( ) ) ; } } }	style . set CaMeL Margin CaMeL Bottom CaMeL Override ( 0 ) ;
if ( String CaMeL Editor CaMeL Dialog . save CaMeL Created CaMeL Property ( my CaMeL Bundle , dlg . get CaMeL Name ( ) , dlg . get CaMeL Value ( ) ) ) return ;  <CTX>  public void action CaMeL Performed ( Action CaMeL Event e ) { New CaMeL Key CaMeL Dialog dlg = new New CaMeL Key CaMeL Dialog ( get CaMeL Window ( ) ) ; dlg . show ( ) ; if ( dlg . is CaMeL OK ( ) ) { if ( String CaMeL Editor CaMeL Dialog . save CaMeL Created CaMeL Property ( my CaMeL Bundle , dlg . get CaMeL Name ( ) , dlg . get CaMeL Value ( ) ) ) return ; fill CaMeL Property CaMeL List ( ) ; my CaMeL Model . update ( ) ; select CaMeL Key ( dlg . get CaMeL Name ( ) ) ; } }	if ( ! String CaMeL Editor CaMeL Dialog . save CaMeL Created CaMeL Property ( my CaMeL Bundle , dlg . get CaMeL Name ( ) , dlg . get CaMeL Value ( ) ) ) return ;
if ( ! Workbench . get CaMeL Instance ( ) . is CaMeL Running ( ) )  <CTX>  public void bundle CaMeL Changed ( Bundle CaMeL Event event ) { if ( event . get CaMeL Bundle ( ) . get CaMeL State ( ) != Bundle . ACTIVE ) return ; / / If the workbench is@@ n t running any@@ more simp@@ ly return . if ( ! Workbench . get CaMeL Instance ( ) . is CaMeL Running ( ) ) return ; Working CaMeL Set CaMeL Descriptor [ ] descriptors = Workbench CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Working CaMeL Set CaMeL Registry ( ) . get CaMeL Descriptors CaMeL For CaMeL Namespace ( event . get CaMeL Bundle ( ) . get CaMeL Symbolic CaMeL Name ( ) ) ; synchronized ( updaters ) { for ( int i = 0 ; i < descriptors . length ; i ++ ) { Working CaMeL Set CaMeL Descriptor descriptor = descriptors [ i ] ; List working CaMeL Sets = get CaMeL Working CaMeL Sets CaMeL For CaMeL Id ( descriptor . get CaMeL Id ( ) ) ; if ( working CaMeL Sets . size ( ) == 0 ) continue ; I CaMeL Working CaMeL Set CaMeL Updater updater = get CaMeL Updater ( descriptor ) ; for ( Iterator iter = working CaMeL Sets . iterator ( ) ; iter . has CaMeL Next ( ) ; ) { I CaMeL Working CaMeL Set working CaMeL Set = ( I CaMeL Working CaMeL Set ) iter . next ( ) ; if ( ! updater . contains ( working CaMeL Set ) ) updater . add ( working CaMeL Set ) ; } } } }	if ( ! Workbench . get CaMeL Instance ( ) . is CaMeL Running ( ) ) {
Tree CaMeL Model mod = tree . get CaMeL Model ( ) ; set CaMeL Model ( mod ) ; if ( mod != null ) { Object root = mod . get CaMeL Root ( ) ; if ( root != null ) { Tree CaMeL Path path = new Tree CaMeL Path ( root ) ; if ( ! tree . is CaMeL Expanded ( path ) ) toggle CaMeL Expand CaMeL State ( path ) ; } }  <CTX>  public void install CaMeL UI ( J CaMeL Component c ) { tree = ( J CaMeL Tree ) c ; prepare CaMeL For CaMeL UI CaMeL Install ( ) ; super . install CaMeL UI ( c ) ; install CaMeL Defaults ( ) ; install CaMeL Components ( ) ; install CaMeL Keyboard CaMeL Actions ( ) ; install CaMeL Listeners ( ) ; set CaMeL Cell CaMeL Editor ( create CaMeL Default CaMeL Cell CaMeL Editor ( ) ) ; created CaMeL Cell CaMeL Editor = true ; is CaMeL Editing = false ; Tree CaMeL Model mod = tree . get CaMeL Model ( ) ; set CaMeL Model ( mod ) ; if ( mod != null ) { Object root = mod . get CaMeL Root ( ) ; if ( root != null ) { Tree CaMeL Path path = new Tree CaMeL Path ( root ) ; if ( ! tree . is CaMeL Expanded ( path ) ) toggle CaMeL Expand CaMeL State ( path ) ; } } tree CaMeL Selection CaMeL Model = tree . get CaMeL Selection CaMeL Model ( ) ; complete CaMeL UI CaMeL Install ( ) ; }	set CaMeL Model ( tree . get CaMeL Model ( ) ) ;
BLOCKED _ ADDR _ TO _ TIME . remove ( addr ) ;  <CTX>  private static void clean CaMeL Expired CaMeL Server CaMeL Blocks ( ) { synchronized ( BLOCKED _ ADDR _ TO _ TIME ) { while ( ! BLOCKED _ ADDR _ QUEUE . is CaMeL Empty ( ) ) { Inet CaMeL Address addr = ( Inet CaMeL Address ) BLOCKED _ ADDR _ QUEUE . get CaMeL Last ( ) ; long time = ( ( Long ) BLOCKED _ ADDR _ TO _ TIME . get ( addr ) ) . long CaMeL Value ( ) ; if ( time <= System . current CaMeL Time CaMeL Millis ( ) ) { BLOCKED _ ADDR _ TO _ TIME . remove ( addr ) ; BLOCKED _ ADDR _ QUEUE . remove CaMeL Last ( ) ; } else { break ; } } } }	BLOCKED _ ADDR _ TO _ TIME . remove ( host ) ;
initialize ( resources , in , true ) ;  <CTX>  public static void initialize ( Validator CaMeL Resources resources , Input CaMeL Stream in ) throws IO CaMeL Exception { initialize ( resources , in , true ) ; }	return initialize ( new Buffered CaMeL Input CaMeL Stream ( new File CaMeL Input CaMeL Stream ( file CaMeL Name ) ) ) ;
void register CaMeL Protocol CaMeL Handlers ( Class CaMeL Loader loader , String pkgs )  <CTX>  void register CaMeL Protocol CaMeL Handlers ( Class CaMeL Loader loader , String pkgs ) { synchronized ( protocol CaMeL Handlers ) { protocol CaMeL Handlers . add ( new Proto CaMeL Handler CaMeL Desc ( loader , pkgs ) ) ; } }	public void register CaMeL Protocol CaMeL Handlers ( Class CaMeL Loader loader , String pkgs )
names = new String [ its CaMeL Data . its CaMeL Variable CaMeL Table . size ( ) + 1 ] ; names [ 0 ] = its CaMeL Data . its CaMeL Name ; for ( int i = 0 ; i < its CaMeL Data . its CaMeL Variable CaMeL Table . size ( ) ; i ++ ) names [ i + 1 ] = its CaMeL Data . its CaMeL Variable CaMeL Table . get CaMeL Name ( i ) ;  <CTX>  void init ( Context cx ) { / / prob@@ ably too mu@@ ch copying going on from the CaMeL Data to the Interpreted CaMeL Function object / / should pass them as parameters - unless we need them in the data block any@@ way ? names = new String [ its CaMeL Data . its CaMeL Variable CaMeL Table . size ( ) + 1 ] ; names [ 0 ] = its CaMeL Data . its CaMeL Name ; for ( int i = 0 ; i < its CaMeL Data . its CaMeL Variable CaMeL Table . size ( ) ; i ++ ) names [ i + 1 ] = its CaMeL Data . its CaMeL Variable CaMeL Table . get CaMeL Name ( i ) ; arg CaMeL Count = ( short ) its CaMeL Data . its CaMeL Variable CaMeL Table . get CaMeL Parameter CaMeL Count ( ) ; source = its CaMeL Data . its CaMeL Source ; nested CaMeL Functions = its CaMeL Data . its CaMeL Nested CaMeL Functions ; if ( cx != null ) version = ( short ) cx . get CaMeL Language CaMeL Version ( ) ; }	function CaMeL Name = its CaMeL Data . its CaMeL Name ; int N = its CaMeL Data . its CaMeL Variable CaMeL Table . size ( ) ; if ( N != 0 ) { arg CaMeL Names = new String [ N ] ; for ( int i = 0 ; i != N ; i ++ ) { arg CaMeL Names [ i ] = its CaMeL Data . its CaMeL Variable CaMeL Table . get CaMeL Name ( i ) ; } }
i CaMeL Visited . accept ( _ Payload ) ;  <CTX>  public void visit CaMeL Alias CaMeL Node ( Alias CaMeL Node i CaMeL Visited ) { i CaMeL Visited . accept ( _ Payload ) ; }	_ Payload . visit CaMeL Alias CaMeL Node ( i CaMeL Visited ) ;
super ( xpath , null ) ;  <CTX>  public Matcher ( Field . X CaMeL Path xpath , Value CaMeL Store store ) { super ( xpath , null ) ; f CaMeL Store = store ; } / / < init > ( Field . X CaMeL Path , Value CaMeL Store )	super ( xpath ) ;
super ( conn , fields , tuples , status , update CaMeL Count , insert CaMeL OID ) ;  <CTX>  public Updateable CaMeL Result CaMeL Set ( Connection conn , Field [ ] fields , Vector tuples , String status , int update CaMeL Count , int insert CaMeL OID ) { super ( conn , fields , tuples , status , update CaMeL Count , insert CaMeL OID ) ; }	super ( conn , fields , tuples , status , update CaMeL Count , insert CaMeL OID , binary CaMeL Cursor ) ;
return v != null && v . contains ( value ) ;  <CTX>  public boolean contains CaMeL Element ( Object key , Object value ) { synchronized ( table ) { Vector v = ( Vector ) table . get ( key ) ; return v != null && v . contains ( value ) ; } }	return ( v != null ) && v . contains ( value ) ;
if ( entry . factory . plugin == p@@ msg . get CaMeL Plugin CaMeL JAR ( ) ) { if ( entry . container != null ) entry . container . unregister ( entry ) ; iter . remove ( ) ; }  <CTX>  public void handle CaMeL Message ( EB CaMeL Message msg ) { if ( msg instanceof Dockable CaMeL Window CaMeL Update ) { if ( ( ( Dockable CaMeL Window CaMeL Update ) msg ) . get CaMeL What ( ) == Dockable CaMeL Window CaMeL Update . PROPERTIES _ CHANGED ) properties CaMeL Changed ( ) ; } else if ( msg instanceof Properties CaMeL Changed ) properties CaMeL Changed ( ) ; else if ( msg instanceof Plugin CaMeL Update ) { Plugin CaMeL Update p@@ msg = ( Plugin CaMeL Update ) msg ; if ( p@@ msg . get CaMeL What ( ) == Plugin CaMeL Update . LOADED ) { Iterator iter = dockable CaMeL Window CaMeL Factories . values ( ) . iterator ( ) ; while ( iter . has CaMeL Next ( ) ) { Factory factory = ( Factory ) iter . next ( ) ; if ( factory . plugin == p@@ msg . get CaMeL Plugin CaMeL JAR ( ) ) add CaMeL Entry ( factory ) ; } properties CaMeL Changed ( ) ; } else if ( p@@ msg . is CaMeL Exiting ( ) ) { / / we don t c@@ are } else if ( p@@ msg . get CaMeL What ( ) == Plugin CaMeL Update . DEACTIVATED ) { Iterator iter = windows . values ( ) . iterator ( ) ; while ( iter . has CaMeL Next ( ) ) { Entry entry = ( Entry ) iter . next ( ) ; if ( entry . factory . plugin == p@@ msg . get CaMeL Plugin CaMeL JAR ( ) ) { if ( entry . container != null && entry . container . is CaMeL Visible ( entry ) ) { entry . container . remove ( entry ) ; } } } iter = clones . iterator ( ) ; while ( iter . has CaMeL Next ( ) ) { Entry entry = ( Entry ) iter . next ( ) ; if ( entry . factory . plugin == p@@ msg . get CaMeL Plugin CaMeL JAR ( ) ) { if ( entry . container != null ) entry . container . unregister ( entry ) ; iter . remove ( ) ; } } } else if ( p@@ msg . get CaMeL What ( ) == Plugin CaMeL Update . UN@@ LOADED ) { Iterator iter = windows . values ( ) . iterator ( ) ; while ( iter . has CaMeL Next ( ) ) { Entry entry = ( Entry ) iter . next ( ) ; if ( entry . factory . plugin == p@@ msg . get CaMeL Plugin CaMeL JAR ( ) ) { if ( entry . container != null ) entry . container . unregister ( entry ) ; iter . remove ( ) ; } } } } } / / } } }	entry . container . unregister ( entry ) ; entry . win = null ; entry . container = null ;
view CaMeL Extent = new CaMeL Size ;  <CTX>  public void set CaMeL View CaMeL Size ( Dimension new CaMeL Size ) { view CaMeL Extent = new CaMeL Size ; fire CaMeL State CaMeL Changed ( ) ; }	view CaMeL Size = new CaMeL Size ; Component view = get CaMeL View ( ) ; if ( view != null ) view . set CaMeL Size ( new CaMeL Size ) ;
this . start CaMeL Day = day ;  <CTX>  public void set CaMeL Start CaMeL Rule ( int month , int day , int day CaMeL Of CaMeL Week , int time ) { this . start CaMeL Mode = check CaMeL Rule ( month , day , day CaMeL Of CaMeL Week ) ; this . start CaMeL Month = month ; this . start CaMeL Day = day ; this . start CaMeL Day CaMeL Of CaMeL Week = Math . abs ( day CaMeL Of CaMeL Week ) ; if ( this . start CaMeL Time CaMeL Mode == WALL _ TIME || this . start CaMeL Time CaMeL Mode == STANDARD _ TIME ) this . start CaMeL Time = time ; else / / Convert from UTC to STANDARD this . start CaMeL Time = time + this . raw CaMeL Offset ; use CaMeL Daylight = true ; }	this . start CaMeL Day = Math . abs ( day ) ;
return false ;  <CTX>  public boolean is CaMeL Read CaMeL Only ( ) { return false ; }	return true ;
add ( component ) ;  <CTX>  public void add CaMeL Item CaMeL By CaMeL Name ( String name , J CaMeL Menu CaMeL Item component ) { controls . put ( name , component ) ; add ( component ) ; }	super . add ( component ) ;
open CaMeL Index CaMeL Writer ( false ) ; add CaMeL Document CaMeL To CaMeL Index ( document , index CaMeL Writer ) ; close CaMeL Index CaMeL Writer ( ) ;  <CTX>  private void add CaMeL Document CaMeL To CaMeL Index ( Document CaMeL Domain CaMeL Object document ) throws IO CaMeL Exception { open CaMeL Index CaMeL Writer ( false ) ; add CaMeL Document CaMeL To CaMeL Index ( document , index CaMeL Writer ) ; close CaMeL Index CaMeL Writer ( ) ; }	Index CaMeL Writer index CaMeL Writer = create CaMeL Index CaMeL Writer ( index CaMeL Directory , false ) ; try { add CaMeL Document CaMeL To CaMeL Index ( document , index CaMeL Writer ) ; } finally { index CaMeL Writer . close ( ) ; }
il 1 . append ( fact . ALOAD _ 0 ) ; il 1 . append ( fact . create CaMeL Load ( field CaMeL Type , 1 ) ) ;  <CTX>  private boolean munge CaMeL Per CaMeL Object CaMeL Interface ( Bcel CaMeL Class CaMeL Weaver weaver , Per CaMeL Object CaMeL Interface CaMeL Type CaMeL Munger munger ) { Lazy CaMeL Class CaMeL Gen gen = weaver . get CaMeL Lazy CaMeL Class CaMeL Gen ( ) ; if ( could CaMeL Match ( gen . get CaMeL Bcel CaMeL Object CaMeL Type ( ) , munger . get CaMeL Test CaMeL Pointcut ( ) ) ) { Field CaMeL Gen fg = make CaMeL Field CaMeL Gen ( gen , Ajc CaMeL Member CaMeL Maker . per CaMeL Object CaMeL Field ( gen . get CaMeL Type ( ) , aspect CaMeL Type ) ) ; gen . add CaMeL Field ( fg . get CaMeL Field ( ) ) ; Type field CaMeL Type = Bcel CaMeL World . make CaMeL Bcel CaMeL Type ( aspect CaMeL Type ) ; Lazy CaMeL Method CaMeL Gen mg = new Lazy CaMeL Method CaMeL Gen ( Modifier . PUBLIC , field CaMeL Type , Name CaMeL Mangler . per CaMeL Object CaMeL Interface CaMeL Get ( aspect CaMeL Type ) , new Type [ 0 ] , new String [ 0 ] , gen ) ; Instruction CaMeL List il = new Instruction CaMeL List ( ) ; Instruction CaMeL Factory fact = gen . get CaMeL Factory ( ) ; il . append ( fact . ALOAD _ 0 ) ; il . append ( fact . create CaMeL Field CaMeL Access ( gen . get CaMeL Class CaMeL Name ( ) , fg . get CaMeL Name ( ) , field CaMeL Type , Constants . GETFIELD ) ) ; il . append ( fact . create CaMeL Return ( field CaMeL Type ) ) ; mg . get CaMeL Body ( ) . insert ( il ) ; gen . add CaMeL Method CaMeL Gen ( mg ) ; Lazy CaMeL Method CaMeL Gen mg 1 = new Lazy CaMeL Method CaMeL Gen ( Modifier . PUBLIC , Type . VOID , Name CaMeL Mangler . per CaMeL Object CaMeL Interface CaMeL Set ( aspect CaMeL Type ) , new Type [ ] { field CaMeL Type , } , new String [ 0 ] , gen ) ; Instruction CaMeL List il 1 = new Instruction CaMeL List ( ) ; il 1 . append ( fact . ALOAD _ 0 ) ; il 1 . append ( fact . create CaMeL Load ( field CaMeL Type , 1 ) ) ; il 1 . append ( fact . create CaMeL Field CaMeL Access ( gen . get CaMeL Class CaMeL Name ( ) , fg . get CaMeL Name ( ) , field CaMeL Type , Constants . PUTFIELD ) ) ; il 1 . append ( fact . create CaMeL Return ( Type . VOID ) ) ; mg 1 . get CaMeL Body ( ) . insert ( il 1 ) ; gen . add CaMeL Method CaMeL Gen ( mg 1 ) ; gen . add CaMeL Interface ( munger . get CaMeL Interface CaMeL Type ( ) ) ; return true ; } else { return false ; } }	il 1 . append ( Instruction CaMeL Constants . ALOAD _ 0 ) ; il 1 . append ( Instruction CaMeL Factory . create CaMeL Load ( field CaMeL Type , 1 ) ) ;
String parent CaMeL Repo CaMeL Path = Path CaMeL Translator . to CaMeL Repository CaMeL Path ( parent CaMeL Node . get CaMeL Parent ( ) . get CaMeL Path ( ) ) ; return get CaMeL Ticket ( parent CaMeL Repo CaMeL Path , id ) ;  <CTX>  public Object do CaMeL In CaMeL Jcr ( Session session ) throws Repository CaMeL Exception { String repo CaMeL Path = Path CaMeL Translator . to CaMeL Repository CaMeL Path ( path ) ; Node parent CaMeL Node = find CaMeL Deepest CaMeL Existing CaMeL Node CaMeL In CaMeL Path ( session , repo CaMeL Path ) ; Node ticket CaMeL Node = find CaMeL Child CaMeL Ticket CaMeL Node ( parent CaMeL Node , id ) ; if ( ticket CaMeL Node == null ) { if ( parent CaMeL Node . get CaMeL Depth ( ) == 0 ) { return null ; } String parent CaMeL Repo CaMeL Path = Path CaMeL Translator . to CaMeL Repository CaMeL Path ( parent CaMeL Node . get CaMeL Parent ( ) . get CaMeL Path ( ) ) ; return get CaMeL Ticket ( parent CaMeL Repo CaMeL Path , id ) ; } return Ticket CaMeL Mapper . node CaMeL To CaMeL Ticket ( ticket CaMeL Node ) ; }	String parent CaMeL Client CaMeL Path = Path CaMeL Translator . to CaMeL Client CaMeL Path ( parent CaMeL Node . get CaMeL Parent ( ) . get CaMeL Path ( ) ) ; return get CaMeL Ticket ( parent CaMeL Client CaMeL Path , id ) ;
new CaMeL Str . inf@@ ect CaMeL Object ( this ) ;  <CTX>  public I CaMeL Ruby CaMeL Object dup ( ) { Ruby CaMeL String new CaMeL Str = new CaMeL String ( get CaMeL Value ( ) ) ; new CaMeL Str . inf@@ ect CaMeL Object ( this ) ; return new CaMeL Str ; }	new CaMeL Str . inf@@ ect CaMeL By ( this ) ;
if ( VM . Verify CaMeL Assertions ) VM . assert ( i == num CaMeL Blocks ) ;  <CTX>  private OPT _ Basic CaMeL Block [ ] ex@@ ile CaMeL Infrequent CaMeL Blocks ( OPT _ IR ir ) { OPT _ Basic CaMeL Block [ ] new CaMeL Ordering = new OPT _ Basic CaMeL Block [ num CaMeL Blocks ] ; int i = 0 ; / / First append fre@@ quent blocks to new CaMeL Ordering for ( OPT _ Basic CaMeL Block bb = ir . cfg . first CaMeL In CaMeL Code CaMeL Order ( ) ; bb != null ; bb = bb . next CaMeL Basic CaMeL Block CaMeL In CaMeL Code CaMeL Order ( ) ) { if ( ! bb . get CaMeL Infrequent ( ) ) new CaMeL Ordering [ i ++ ] = bb ; } / / Next append in@@ fre@@ quent blocks to new CaMeL Ordering for ( OPT _ Basic CaMeL Block bb = ir . cfg . first CaMeL In CaMeL Code CaMeL Order ( ) ; bb != null ; bb = bb . next CaMeL Basic CaMeL Block CaMeL In CaMeL Code CaMeL Order ( ) ) { if ( bb . get CaMeL Infrequent ( ) ) new CaMeL Ordering [ i ++ ] = bb ; } if ( VM . Verify CaMeL Assertions ) VM . assert ( i == num CaMeL Blocks ) ; return new CaMeL Ordering ; }	if ( VM . Verify CaMeL Assertions ) VM . _ assert ( i == num CaMeL Blocks ) ;
_ port CaMeL Number = port CaMeL Number ;  <CTX>  public void set CaMeL Port CaMeL Number ( int port CaMeL Number ) { _ port CaMeL Number = port CaMeL Number ; }	this . port CaMeL Number = port CaMeL Number ;
Tri CaMeL Vertex ( EMF CaMeL Input CaMeL Stream emf ) throws IO CaMeL Exception { x = emf . read CaMeL LONG ( ) ; y = emf . read CaMeL LONG ( ) ; color = emf . read CaMeL COLOR 16 ( ) ;  <CTX>  Tri CaMeL Vertex ( EMF CaMeL Input CaMeL Stream emf ) throws IO CaMeL Exception { x = emf . read CaMeL LONG ( ) ; y = emf . read CaMeL LONG ( ) ; color = emf . read CaMeL COLOR 16 ( ) ; }	public Tri CaMeL Vertex ( int x , int y , Color color ) { this . x = x ; this . y = y ; this . color = color ;
if ( dval == null || d@@ org != Style CaMeL Map . USER _ ORIGIN || ! di@@ mp ) {  <CTX>  protected void put CaMeL Author CaMeL Property ( Style CaMeL Map dest , int idx , Value sval , boolean imp , short origin ) { Value dval = dest . get CaMeL Value ( idx ) ; short d@@ org = dest . get CaMeL Origin ( idx ) ; boolean di@@ mp = dest . is CaMeL Important ( idx ) ; if ( dval == null || d@@ org != Style CaMeL Map . USER _ ORIGIN || ! di@@ mp ) { dest . put CaMeL Value ( idx , sval ) ; dest . put CaMeL Important ( idx , imp ) ; dest . put CaMeL Origin ( idx , origin ) ; } }	boolean cond = dval == null ; if ( ! cond ) { switch ( d@@ org ) { case Style CaMeL Map . USER _ ORIGIN : cond = ! di@@ mp ; break ; case Style CaMeL Map . AUTHOR _ ORIGIN : cond = ! di@@ mp || imp ; break ; default : cond = true ; } } if ( cond ) {
m _ writer = new Serializer CaMeL Trace CaMeL Writer ( writer , m _ tracer ) ;  <CTX>  public void set CaMeL Writer ( Writer writer ) { / / if we are tracing events we need to trace what / / characters are written to the output writer . if ( m _ tracer != null && ! ( writer instanceof Serializer CaMeL Trace CaMeL Writer ) ) m _ writer = new Serializer CaMeL Trace CaMeL Writer ( writer , m _ tracer ) ; else m _ writer = writer ; }	set CaMeL Writer CaMeL Internal ( new Serializer CaMeL Trace CaMeL Writer ( writer , m _ tracer ) , true ) ;
_ description = description ;  <CTX>  public void set CaMeL Description ( String description ) { _ description = description ; }	this . description = description ;
save CaMeL Array ( filter ( element . get CaMeL Raw CaMeL Children ( ) ) , output CaMeL Namespace ) ;  <CTX>  private void save CaMeL Contributions ( Keyed CaMeL Hash CaMeL Set [ ] contributions ) throws IO CaMeL Exception { File CaMeL Output CaMeL Stream fos CaMeL Namespace = new File CaMeL Output CaMeL Stream ( contributions CaMeL File ) ; Data CaMeL Output CaMeL Stream output CaMeL Namespace = new Data CaMeL Output CaMeL Stream ( new Buffered CaMeL Output CaMeL Stream ( fos CaMeL Namespace ) ) ; Keyed CaMeL Element [ ] new CaMeL Elements = contributions [ 0 ] . elements ( ) ; Keyed CaMeL Element [ ] former CaMeL Elements = contributions [ 1 ] . elements ( ) ; / / get count of contributions that will be cached int cache CaMeL Size = 0 ; for ( int i = 0 ; i < new CaMeL Elements . length ; i ++ ) { if ( ( ( Contribution ) new CaMeL Elements [ i ] ) . should CaMeL Persist ( ) ) cache CaMeL Size ++ ; } for ( int i = 0 ; i < former CaMeL Elements . length ; i ++ ) { if ( ( ( Contribution ) former CaMeL Elements [ i ] ) . should CaMeL Persist ( ) ) cache CaMeL Size ++ ; } output CaMeL Namespace . write CaMeL Int ( cache CaMeL Size ) ; for ( int i = 0 ; i < new CaMeL Elements . length ; i ++ ) { Contribution element = ( Contribution ) new CaMeL Elements [ i ] ; if ( element . should CaMeL Persist ( ) ) { write CaMeL String CaMeL Or CaMeL Null ( element . get CaMeL Contributor CaMeL Id ( ) , output CaMeL Namespace ) ; save CaMeL Array ( filter ( element . get CaMeL Raw CaMeL Children ( ) ) , output CaMeL Namespace ) ; } } for ( int i = 0 ; i < former CaMeL Elements . length ; i ++ ) { Contribution element = ( Contribution ) former CaMeL Elements [ i ] ; if ( element . should CaMeL Persist ( ) ) { write CaMeL String CaMeL Or CaMeL Null ( element . get CaMeL Contributor CaMeL Id ( ) , output CaMeL Namespace ) ; save CaMeL Array ( filter ( element . get CaMeL Raw CaMeL Children ( ) ) , output CaMeL Namespace ) ; } } output CaMeL Namespace . flush ( ) ; fos CaMeL Namespace . get CaMeL FD ( ) . sync ( ) ; output CaMeL Namespace . close ( ) ; }	save CaMeL Array ( filter CaMeL Contribution CaMeL Children ( element ) , output CaMeL Namespace ) ;
Document CaMeL Domain CaMeL Object doc = document CaMeL Mapper . get CaMeL Document ( document CaMeL Id ) ;  <CTX>  public Document get CaMeL Document ( int document CaMeL Id ) throws No CaMeL Permission CaMeL Exception { Document CaMeL Domain CaMeL Object doc = document CaMeL Mapper . get CaMeL Document ( document CaMeL Id ) ; Document result = null ; if ( null != doc ) { result = wrap CaMeL Document CaMeL Domain CaMeL Object ( doc ) ; security CaMeL Checker . has CaMeL At CaMeL Least CaMeL Document CaMeL Read CaMeL Permission ( result ) ; } return result ; }	Document CaMeL Domain CaMeL Object doc = get CaMeL Document CaMeL Mapper ( ) . get CaMeL Document ( document CaMeL Id ) ;
else if ( e . widget . equals ( btn CaMeL More CaMeL Opt ) )  <CTX>  public void widget CaMeL Selected ( Selection CaMeL Event e ) { / / detach popup dialogue if ( detach CaMeL Popup ( e . widget ) ) { return ; } if ( e . widget instanceof Button && ( ( ( Button ) e . widget ) . get CaMeL Style ( ) & SWT . TOGGLE ) == SWT . TOGGLE && ( ( Button ) e . widget ) . get CaMeL Selection ( ) ) { select CaMeL All CaMeL Buttons ( false ) ; ( ( Button ) e . widget ) . set CaMeL Selection ( true ) ; } if ( e . widget . equals ( btn CaMeL Title CaMeL Visible ) ) { get CaMeL Chart ( ) . get CaMeL Legend ( ) . get CaMeL Title ( ) . set CaMeL Visible ( ( ( Button ) e . widget ) . get CaMeL Selection ( ) ) ; txt CaMeL Title . set CaMeL Enabled ( get CaMeL Chart ( ) . get CaMeL Legend ( ) . get CaMeL Title ( ) . is CaMeL Visible ( ) ) ; refresh CaMeL Popup CaMeL Sheet ( ) ; } else if ( e . widget . equals ( btn CaMeL Outline CaMeL Visible ) ) { get CaMeL Chart ( ) . get CaMeL Legend ( ) . get CaMeL Client CaMeL Area ( ) . get CaMeL Outline ( ) . set CaMeL Visible ( ( ( Button ) e . widget ) . get CaMeL Selection ( ) ) ; refresh CaMeL Popup CaMeL Sheet ( ) ; } else if ( e . widget . equals ( btn CaMeL Show CaMeL Value ) ) { get CaMeL Chart ( ) . get CaMeL Legend ( ) . set CaMeL Show CaMeL Value ( ( ( Button ) e . widget ) . get CaMeL Selection ( ) ) ; } else if ( e . widget . equals ( btn CaMeL More CaMeL Opt ) ) { popup CaMeL Shell = create CaMeL Popup CaMeL Shell ( ) ; popup CaMeL Sheet = new More CaMeL Options CaMeL Chart CaMeL Legend CaMeL Sheet ( popup CaMeL Shell , get CaMeL Chart ( ) ) ; get CaMeL Wizard ( ) . attach CaMeL Popup ( btn CaMeL More CaMeL Opt . get CaMeL Text ( ) , - 1 , - 1 ) ; } else if ( e . widget . equals ( btn CaMeL Legend CaMeL Text ) ) { popup CaMeL Shell = create CaMeL Popup CaMeL Shell ( ) ; popup CaMeL Sheet = new Legend CaMeL Text CaMeL Sheet ( popup CaMeL Shell , get CaMeL Chart ( ) ) ; get CaMeL Wizard ( ) . attach CaMeL Popup ( btn CaMeL Legend CaMeL Text . get CaMeL Text ( ) , - 1 , - 1 ) ; } }	else if ( e . widget . equals ( btn CaMeL Area CaMeL Prop ) )
last CaMeL Visible = viewer . get CaMeL Element CaMeL At ( viewer . get CaMeL Table ( ) . get CaMeL Item CaMeL Count ( ) - 1 ) ;  <CTX>  private int next CaMeL Removal ( int maximum CaMeL To CaMeL Remove ) { Array CaMeL List result = new Array CaMeL List ( maximum CaMeL To CaMeL Remove ) ; int counter = maximum CaMeL To CaMeL Remove ; Iterator iter = pending CaMeL Removals . iterator ( ) ; while ( iter . has CaMeL Next ( ) && counter > 0 ) { Object next = iter . next ( ) ; result . add ( next ) ; if ( last CaMeL Visible != null && last CaMeL Visible . equals ( next ) ) { last CaMeL Dirty = true ; } iter . remove ( ) ; counter -- ; } synchronized ( visible CaMeL Items ) { visible CaMeL Items . remove CaMeL All ( result ) ; } viewer . remove ( result . to CaMeL Array ( ) ) ; if ( last CaMeL Dirty ) { last CaMeL Visible = viewer . get CaMeL Element CaMeL At ( viewer . get CaMeL Table ( ) . get CaMeL Item CaMeL Count ( ) - 1 ) ; } return result . size ( ) ; }	last CaMeL Visible = get CaMeL Element CaMeL At ( viewer , viewer . get CaMeL Tree ( ) . get CaMeL Item CaMeL Count ( ) - 1 ) ;
boolean add CaMeL All ( Collection c ) ;  <CTX>  boolean add CaMeL All ( Collection c ) ;	boolean add CaMeL All ( int index , Collection c ) ;
Iterator iter = dnd CaMeL List . iterator ( ) ;  <CTX>  public Status CaMeL Item get CaMeL Status CaMeL Item ( String label ) { Iterator iter = dnd CaMeL List . iterator ( ) ; while ( iter . has CaMeL Next ( ) ) { Status CaMeL Item item = ( Status CaMeL Item ) iter . next ( ) ; if ( item . get CaMeL Text ( ) . equals ( label ) ) { return item ; } } return null ; }	Iterator iter = status CaMeL List . iterator ( ) ;
Tile t = s . get CaMeL Tile ( 0 ) ;  <CTX>  public void add CaMeL Tileset ( Tile CaMeL Set s ) { if ( s == null || tile@@ sets . index CaMeL Of ( s ) > - 1 ) { return ; } Tile t = s . get CaMeL Tile ( 0 ) ; if ( t != null ) { int tw = t . get CaMeL Width ( ) ; int th = t . get CaMeL Height ( ) ; if ( tw != tile CaMeL Width ) { if ( tile CaMeL Width == 0 ) { tile CaMeL Width = tw ; tile CaMeL Height = th ; } } } tile@@ sets . add ( s ) ; fire CaMeL Map CaMeL Changed ( ) ; }	Tile t = tileset . get CaMeL Tile ( 0 ) ;
void translate CaMeL From ( Series source CaMeL Series , Chart chart ) ;  <CTX>  void translate CaMeL From ( Series source CaMeL Series , Chart chart ) ;	void translate CaMeL From ( Series source CaMeL Series , int i CaMeL Series CaMeL Definition CaMeL Index , Chart chart ) ;
return new VM _ Address ( value - v ) ;  <CTX>  public VM _ Address sub ( int v ) { if ( VM . Verify CaMeL Assertions && VM . running CaMeL VM ) VM . _ assert ( VM . NOT _ REACHED ) ; / / call site should have been hi@@ j@@ acked by magic in compiler return new VM _ Address ( value - v ) ; }	return new VM _ Address ( value - offset . to CaMeL Int ( ) ) ;
Database CaMeL Handler . query CaMeL Handler . insert CaMeL Virtual CaMeL Wiki ( virtual CaMeL Wiki , conn ) ;  <CTX>  private void add CaMeL Virtual CaMeL Wiki ( Virtual CaMeL Wiki virtual CaMeL Wiki , Connection conn ) throws Exception { if ( virtual CaMeL Wiki . get CaMeL Virtual CaMeL Wiki CaMeL Id ( ) < 1 ) { int virtual CaMeL Wiki CaMeL Id = Database CaMeL Handler . query CaMeL Handler . next CaMeL Virtual CaMeL Wiki CaMeL Id ( conn ) ; virtual CaMeL Wiki . set CaMeL Virtual CaMeL Wiki CaMeL Id ( virtual CaMeL Wiki CaMeL Id ) ; } Database CaMeL Handler . query CaMeL Handler . insert CaMeL Virtual CaMeL Wiki ( virtual CaMeL Wiki , conn ) ; }	Wiki CaMeL Database . get CaMeL Query CaMeL Handler ( ) . insert CaMeL Virtual CaMeL Wiki ( virtual CaMeL Wiki , conn ) ;
java . lang . String topic CaMeL Id , java . lang . String message CaMeL Id , boolean add CaMeL Community CaMeL Permissions , boolean add CaMeL Guest CaMeL Permissions )  <CTX>  public void add CaMeL Message CaMeL Resources ( java . lang . String category CaMeL Id , java . lang . String topic CaMeL Id , java . lang . String message CaMeL Id , boolean add CaMeL Community CaMeL Permissions , boolean add CaMeL Guest CaMeL Permissions ) throws com . li@@ fer@@ ay . portal . Portal CaMeL Exception , com . li@@ fer@@ ay . portal . System CaMeL Exception ;	java . lang . String message CaMeL Id , boolean add CaMeL Community CaMeL Permissions , boolean add CaMeL Guest CaMeL Permissions )
its CaMeL Data . its CaMeL Line CaMeL Number CaMeL Table . put ( new Integer ( line CaMeL Number ) , new Integer ( i CaMeL Code CaMeL Top ) ) ;  <CTX>  private int update CaMeL Line CaMeL Number ( Node node , int i CaMeL Code CaMeL Top ) { Object datum = node . get CaMeL Datum ( ) ; if ( datum == null || ! ( datum instanceof Number ) ) return i CaMeL Code CaMeL Top ; short line CaMeL Number = ( ( Number ) datum ) . short CaMeL Value ( ) ; if ( line CaMeL Number != its CaMeL Line CaMeL Number ) { its CaMeL Line CaMeL Number = line CaMeL Number ; if ( its CaMeL Data . its CaMeL Line CaMeL Number CaMeL Table == null && Context . get CaMeL Current CaMeL Context ( ) . is CaMeL Generating CaMeL Debug ( ) ) { its CaMeL Data . its CaMeL Line CaMeL Number CaMeL Table = new java . util . Hashtable ( ) ; } if ( its CaMeL Data . its CaMeL Line CaMeL Number CaMeL Table != null ) { its CaMeL Data . its CaMeL Line CaMeL Number CaMeL Table . put ( new Integer ( line CaMeL Number ) , new Integer ( i CaMeL Code CaMeL Top ) ) ; } i CaMeL Code CaMeL Top = add CaMeL Byte ( ( byte ) Token CaMeL Stream . LINE , i CaMeL Code CaMeL Top ) ; i CaMeL Code CaMeL Top = add CaMeL Byte ( ( byte ) ( line CaMeL Number >> 8 ) , i CaMeL Code CaMeL Top ) ; i CaMeL Code CaMeL Top = add CaMeL Byte ( ( byte ) ( line CaMeL Number & 0 xff ) , i CaMeL Code CaMeL Top ) ; } return i CaMeL Code CaMeL Top ; }	its CaMeL Data . its CaMeL Line CaMeL Number CaMeL Table . put ( line CaMeL Number , i CaMeL Code CaMeL Top ) ;
Simple CaMeL Date CaMeL Format df = new Simple CaMeL Date CaMeL Format ( date CaMeL Pattern ) ;  <CTX>  public static Calendar get CaMeL Today ( ) throws Parse CaMeL Exception { Date today = new Date ( ) ; Simple CaMeL Date CaMeL Format df = new Simple CaMeL Date CaMeL Format ( date CaMeL Pattern ) ; / / This seems like qu@@ ite a hack ( date -> string -> date ) , / / but it works ; - ) String today CaMeL As CaMeL String = df . format ( today ) ; Calendar cal = new Gregorian CaMeL Calendar ( ) ; cal . set CaMeL Time ( convert CaMeL String CaMeL To CaMeL Date ( today CaMeL As CaMeL String ) ) ; return cal ; }	Simple CaMeL Date CaMeL Format df = new Simple CaMeL Date CaMeL Format ( get CaMeL Date CaMeL Pattern ( ) ) ;
this ( locale , ( String ) null , loc CaMeL Pattern ) ;  <CTX>  public Byte CaMeL Locale CaMeL Converter ( Locale locale , boolean loc CaMeL Pattern ) { this ( locale , ( String ) null , loc CaMeL Pattern ) ; }	this ( false ) ;
{ return missing CaMeL Parameter ;  <CTX>  public boolean is CaMeL Missing CaMeL Parameter ( ) { return missing CaMeL Parameter ; }	{ Map values = null ; if ( report CaMeL Document CaMeL Instance != null ) values = report CaMeL Document CaMeL Instance . get CaMeL Parameter CaMeL Values ( ) ; else values = this . parameters ; return Report CaMeL Engine CaMeL Service . get CaMeL Instance ( ) . validate CaMeL Parameters ( this . parameter CaMeL Task , values ) ;
Calendar result = Calendar . get CaMeL Instance ( ) ; result . set CaMeL Time ( this . get CaMeL Official ( ) ) ; return result ;  <CTX>  public Calendar get CaMeL Official CaMeL Date ( ) { Calendar result = Calendar . get CaMeL Instance ( ) ; result . set CaMeL Time ( this . get CaMeL Official ( ) ) ; return result ; }	if ( this . get CaMeL Official ( ) != null ) { Calendar result = Calendar . get CaMeL Instance ( ) ; result . set CaMeL Time ( this . get CaMeL Official ( ) ) ; return result ; } return null ;
return res . cache ;  <CTX>  public boolean get CaMeL Cache ( ) { return res . cache ; }	return res . is CaMeL Cacheable ( ) ;
collect CaMeL Contained CaMeL Functions ( tree . get CaMeL First CaMeL Child ( ) ) ;  <CTX>  public Node transform ( Node tree , Node enclosing ) { / / Collect all of the contained functions into a hashtable / / so that the call optimizer can access the class name & parameter / / count for any call it en@@ counters collect CaMeL Contained CaMeL Functions ( tree . get CaMeL First CaMeL Child ( ) ) ; return super . transform ( tree , enclosing ) ; }	if ( tree . get CaMeL Type ( ) == Token CaMeL Stream . SCRIPT ) { collect CaMeL Contained CaMeL Functions ( tree . get CaMeL First CaMeL Child ( ) ) ; }
case I CaMeL Problem . Interface CaMeL Ambiguous :  <CTX>  public static boolean has CaMeL Corrections ( int problem CaMeL Id ) { switch ( problem CaMeL Id ) { case I CaMeL Problem . Unterminated CaMeL String : case I CaMeL Problem . Unused CaMeL Import : case I CaMeL Problem . Duplicate CaMeL Import : case I CaMeL Problem . Cannot CaMeL Import CaMeL Package : case I CaMeL Problem . Conflicting CaMeL Import : case I CaMeL Problem . Undefined CaMeL Method : case I CaMeL Problem . Undefined CaMeL Constructor : case I CaMeL Problem . Parameter CaMeL Mismatch : case I CaMeL Problem . Method CaMeL But CaMeL With CaMeL Constructor CaMeL Name : case I CaMeL Problem . Undefined CaMeL Field : case I CaMeL Problem . Undefined CaMeL Name : case I CaMeL Problem . Public CaMeL Class CaMeL Must CaMeL Match CaMeL File CaMeL Name : case I CaMeL Problem . Package CaMeL Is CaMeL Not CaMeL Expected CaMeL Package : case I CaMeL Problem . Undefined CaMeL Type : case I CaMeL Problem . Field CaMeL Type CaMeL Not CaMeL Found : case I CaMeL Problem . Argument CaMeL Type CaMeL Not CaMeL Found : case I CaMeL Problem . Return CaMeL Type CaMeL Not CaMeL Found : case I CaMeL Problem . Superclass CaMeL Not CaMeL Found : case I CaMeL Problem . Exception CaMeL Type CaMeL Not CaMeL Found : case I CaMeL Problem . Interface CaMeL Not CaMeL Found : case I CaMeL Problem . Type CaMeL Mismatch : case I CaMeL Problem . Unhandled CaMeL Exception : case I CaMeL Problem . Unreachable CaMeL Catch : case I CaMeL Problem . Void CaMeL Method CaMeL Returns CaMeL Value : case I CaMeL Problem . Should CaMeL Return CaMeL Value : case I CaMeL Problem . Missing CaMeL Return CaMeL Type : case I CaMeL Problem . Non CaMeL Externalized CaMeL String CaMeL Literal : case I CaMeL Problem . Non CaMeL Static CaMeL Access CaMeL To CaMeL Static CaMeL Field : case I CaMeL Problem . Non CaMeL Static CaMeL Access CaMeL To CaMeL Static CaMeL Method : case I CaMeL Problem . Static CaMeL Method CaMeL Requested : case I CaMeL Problem . Non CaMeL Static CaMeL Field CaMeL From CaMeL Static CaMeL Invocation : case I CaMeL Problem . Instance CaMeL Method CaMeL During CaMeL Constructor CaMeL Invocation : case I CaMeL Problem . Instance CaMeL Field CaMeL During CaMeL Constructor CaMeL Invocation : case I CaMeL Problem . Not CaMeL Visible CaMeL Method : case I CaMeL Problem . Not CaMeL Visible CaMeL Constructor : case I CaMeL Problem . Not CaMeL Visible CaMeL Type : case I CaMeL Problem . Superclass CaMeL Not CaMeL Visible : case I CaMeL Problem . Interface CaMeL Not CaMeL Visible : case I CaMeL Problem . Field CaMeL Type CaMeL Not CaMeL Visible : case I CaMeL Problem . Argument CaMeL Type CaMeL Not CaMeL Visible : case I CaMeL Problem . Return CaMeL Type CaMeL Not CaMeL Visible : case I CaMeL Problem . Exception CaMeL Type CaMeL Not CaMeL Visible : case I CaMeL Problem . Not CaMeL Visible CaMeL Field : case I CaMeL Problem . Import CaMeL Not CaMeL Visible : case I CaMeL Problem . Body CaMeL For CaMeL Abstract CaMeL Method : case I CaMeL Problem . Abstract CaMeL Method CaMeL In CaMeL Abstract CaMeL Class : case I CaMeL Problem . Abstract CaMeL Method CaMeL Must CaMeL Be CaMeL Implemented : case I CaMeL Problem . Body CaMeL For CaMeL Native CaMeL Method : case I CaMeL Problem . Outer CaMeL Local CaMeL Must CaMeL Be CaMeL Final : case I CaMeL Problem . Uninitialized CaMeL Local CaMeL Variable : case I CaMeL Problem . Undefined CaMeL Constructor CaMeL In CaMeL Default CaMeL Constructor : case I CaMeL Problem . Unhandled CaMeL Exception CaMeL In CaMeL Default CaMeL Constructor : case I CaMeL Problem . Not CaMeL Visible CaMeL Constructor CaMeL In CaMeL Default CaMeL Constructor : case I CaMeL Problem . Field CaMeL Type CaMeL Ambiguous : case I CaMeL Problem . Argument CaMeL Type CaMeL Ambiguous : case I CaMeL Problem . Exception CaMeL Type CaMeL Ambiguous : case I CaMeL Problem . Return CaMeL Type CaMeL Ambiguous : case I CaMeL Problem . Superclass CaMeL Ambiguous : case I CaMeL Problem . Interface CaMeL Ambiguous : return true ; default : return false ; } }	case I CaMeL Problem . Interface CaMeL Ambiguous : case I CaMeL Problem . Ambiguous CaMeL Type :
code . emit CaMeL Load ( cur CaMeL Lambda . heap CaMeL Frame ) ; else if ( cur CaMeL Lambda . closure CaMeL Env != null ) code . emit CaMeL Load ( cur CaMeL Lambda . closure CaMeL Env ) ;  <CTX>  public void load CaMeL Heap CaMeL Frame ( Compilation comp ) { Lambda CaMeL Exp cur CaMeL Lambda = comp . cur CaMeL Lambda ; while ( cur CaMeL Lambda != this && cur CaMeL Lambda . get CaMeL Inline CaMeL Only ( ) ) cur CaMeL Lambda = cur CaMeL Lambda . get CaMeL Caller ( ) ; gnu . bytecode . Code CaMeL Attr code = comp . get CaMeL Code ( ) ; if ( cur CaMeL Lambda . heap CaMeL Frame != null && this == cur CaMeL Lambda ) code . emit CaMeL Load ( cur CaMeL Lambda . heap CaMeL Frame ) ; else if ( cur CaMeL Lambda . closure CaMeL Env != null ) code . emit CaMeL Load ( cur CaMeL Lambda . closure CaMeL Env ) ; else code . emit CaMeL Push CaMeL This ( ) ; if ( this != cur CaMeL Lambda ) { Lambda CaMeL Exp parent = cur CaMeL Lambda . outer CaMeL Lambda ( ) ; while ( parent != this ) { if ( parent . static CaMeL Link CaMeL Field != null ) code . emit CaMeL Get CaMeL Field ( parent . static CaMeL Link CaMeL Field ) ; / / cur CaMeL Lambda = parent ; parent = parent . outer CaMeL Lambda ( ) ; } } }	{ code . emit CaMeL Load ( cur CaMeL Lambda . heap CaMeL Frame ) ; return ; } Class CaMeL Type cur CaMeL Type ; if ( cur CaMeL Lambda . closure CaMeL Env != null ) { code . emit CaMeL Load ( cur CaMeL Lambda . closure CaMeL Env ) ; cur CaMeL Type = ( Class CaMeL Type ) cur CaMeL Lambda . closure CaMeL Env . get CaMeL Type ( ) ; }
while ( pat . search ( this , start ) != - 1 ) {  <CTX>  public I CaMeL Ruby CaMeL Object scan ( I CaMeL Ruby CaMeL Object arg ) { Ruby CaMeL Regexp pat = Ruby CaMeL Regexp . regexp CaMeL Value ( arg ) ; int start = 0 ; if ( ! get CaMeL Runtime ( ) . get CaMeL Current CaMeL Context ( ) . is CaMeL Block CaMeL Given ( ) ) { Ruby CaMeL Array ary = get CaMeL Runtime ( ) . new CaMeL Array ( ) ; while ( pat . search ( this , start ) != - 1 ) { Ruby CaMeL Match CaMeL Data md = ( Ruby CaMeL Match CaMeL Data ) get CaMeL Runtime ( ) . get CaMeL Current CaMeL Context ( ) . get CaMeL Backref ( ) ; if ( md . get CaMeL Size ( ) == 1 ) { ary . append ( md . group ( 0 ) ) ; } else { ary . append ( md . subseq ( 1 , md . get CaMeL Size ( ) ) ) ; } if ( md . match CaMeL End CaMeL Position ( ) == md . match CaMeL Start CaMeL Position ( ) ) { start ++ ; } else { start = md . match CaMeL End CaMeL Position ( ) ; } } return ary ; } while ( pat . search ( this , start ) != - 1 ) { Ruby CaMeL Match CaMeL Data md = ( Ruby CaMeL Match CaMeL Data ) get CaMeL Runtime ( ) . get CaMeL Current CaMeL Context ( ) . get CaMeL Backref ( ) ; if ( md . get CaMeL Size ( ) == 1 ) { get CaMeL Runtime ( ) . get CaMeL Current CaMeL Context ( ) . yield ( md . group ( 0 ) ) ; } else { get CaMeL Runtime ( ) . get CaMeL Current CaMeL Context ( ) . yield ( md . subseq ( 1 , md . get CaMeL Size ( ) ) ) ; } if ( md . match CaMeL End CaMeL Position ( ) == md . match CaMeL Start CaMeL Position ( ) ) { start ++ ; } else { start = md . match CaMeL End CaMeL Position ( ) ; } } return this ; }	while ( pattern . search ( this , start ) != - 1 ) {
if ( method CaMeL Id == Id _ constructor ) return 1 ; return super . method CaMeL Arity ( method CaMeL Id ) ;  <CTX>  public int method CaMeL Arity ( int method CaMeL Id ) { if ( method CaMeL Id == Id _ constructor ) return 1 ; return super . method CaMeL Arity ( method CaMeL Id ) ; }	if ( f . method CaMeL Id == Id _ constructor ) return 1 ; return super . method CaMeL Arity ( f ) ;
if ( uri != null && uri != Schema CaMeL Symbols . URI _ SCHEMAFORSCHEMA && uri != Schema CaMeL Symbols . URI _ XSI && uri != XML CaMeL Symbols . PREFIX _ XMLNS && uri != XML CaMeL Symbols . PREFIX _ XMLNS )  <CTX>  private boolean has CaMeL Non CaMeL Schema CaMeL Attributes ( XML CaMeL Attributes attributes ) { for ( int i = 0 ; i < attributes . get CaMeL Length ( ) ; i ++ ) { String uri = attributes . get CaMeL URI ( i ) ; if ( uri != null && uri != Schema CaMeL Symbols . URI _ SCHEMAFORSCHEMA && uri != Schema CaMeL Symbols . URI _ XSI && uri != XML CaMeL Symbols . PREFIX _ XMLNS && uri != XML CaMeL Symbols . PREFIX _ XMLNS ) return true ; } return false ; }	if ( uri != null && uri != Schema CaMeL Symbols . URI _ SCHEMAFORSCHEMA && uri != Namespace CaMeL Context . XMLNS _ URI && ! ( uri == Namespace CaMeL Context . XML _ URI && attributes . get CaMeL Q CaMeL Name ( i ) == Schema CaMeL Symbols . ATT _ XML _ LANG && element . localpart == Schema CaMeL Symbols . ELT _ SCHEMA ) ) {
return Integer . value CaMeL Of ( get CaMeL String ( context , KEY _ PROJECT _ GROUP _ ID ) ) . int CaMeL Value ( ) ;  <CTX>  public static int get CaMeL Project CaMeL Group CaMeL Id ( Map context ) { return Integer . value CaMeL Of ( get CaMeL String ( context , KEY _ PROJECT _ GROUP _ ID ) ) . int CaMeL Value ( ) ; }	return get CaMeL Integer ( context , KEY _ PROJECT _ GROUP _ ID ) ;
if ( wizard CaMeL Action CaMeL Ids != null ) for ( int i = 0 ; i < wizard CaMeL Action CaMeL Ids . length ; i ++ ) if ( ( action = get CaMeL Action ( wizard CaMeL Action CaMeL Ids [ i ] ) ) != null )  <CTX>  public void fill CaMeL Context CaMeL Menu ( I CaMeL Menu CaMeL Manager menu ) { Assert . is CaMeL True ( ! disposed ) ; I CaMeL Action action = null ; if ( wizard CaMeL Action CaMeL Ids != null ) for ( int i = 0 ; i < wizard CaMeL Action CaMeL Ids . length ; i ++ ) if ( ( action = get CaMeL Action ( wizard CaMeL Action CaMeL Ids [ i ] ) ) != null ) menu . add ( action ) ; }	if ( wizard CaMeL Action CaMeL Ids != null ) { for ( int i = 0 ; i < wizard CaMeL Action CaMeL Ids . length ; i ++ ) { if ( ( action = get CaMeL Action ( wizard CaMeL Action CaMeL Ids [ i ] ) ) != null ) {
image = ( Image ) image CaMeL Cache . get ( image CaMeL Descri@@ tor ) ;  <CTX>  public void release CaMeL References ( ) { id = null ; tooltip = null ; title = null ; if ( image != null && image CaMeL Descri@@ tor != null ) { / / make sure part has inc . the reference count . if ( part != null ) part . get CaMeL Title CaMeL Image ( ) ; Reference CaMeL Counter image CaMeL Cache = Workbench CaMeL Images . get CaMeL Image CaMeL Cache ( ) ; image = ( Image ) image CaMeL Cache . get ( image CaMeL Descri@@ tor ) ; if ( image != null ) { image CaMeL Cache . remove CaMeL Ref ( image CaMeL Descri@@ tor ) ; } image = null ; image CaMeL Descri@@ tor = null ; } }	image = ( Image ) image CaMeL Cache . get ( image CaMeL Descriptor ) ;
Array CaMeL List res = new Array CaMeL List ( ) ;  <CTX>  public List get CaMeL Keys ( int app@@ def CaMeL Type , int app@@ def CaMeL Type CaMeL Id ) { C@@ prop CaMeL Key CaMeL DAO cp CaMeL Home ; Collection keys ; Array CaMeL List res = new Array CaMeL List ( ) ; try { keys = DAO CaMeL Factory . get CaMeL DAO CaMeL Factory ( ) . get CaMeL C@@ prop CaMeL Key CaMeL DAO ( ) . find CaMeL By CaMeL App@@ def CaMeL Type ( app@@ def CaMeL Type , app@@ def CaMeL Type CaMeL Id ) ; } catch ( Hibernate CaMeL Exception exc ) { return res ; } for ( Iterator i = keys . iterator ( ) ; i . has CaMeL Next ( ) ; ) { C@@ prop CaMeL Key key = ( C@@ prop CaMeL Key ) i . next ( ) ; res . add ( key . get CaMeL C CaMeL Prop CaMeL Key CaMeL Value ( ) ) ; } return res ; }	List res = new Array CaMeL List ( ) ;
return Utilities . draw CaMeL Tabbed CaMeL Text ( segment , x , y , g , this , 0 ) ;  <CTX>  protected int draw CaMeL Selected CaMeL Text ( Graphics g , int x , int y , int p 0 , int p 1 ) throws Bad CaMeL Location CaMeL Exception { g . set CaMeL Color ( selected CaMeL Color ) ; Segment segment = get CaMeL Line CaMeL Buffer ( ) ; get CaMeL Document ( ) . get CaMeL Text ( p 0 , p 1 - p 0 , segment ) ; return Utilities . draw CaMeL Tabbed CaMeL Text ( segment , x , y , g , this , 0 ) ; }	return Utilities . draw CaMeL Tabbed CaMeL Text ( segment , x , y , g , this , p 0 ) ;
return Result . create CaMeL Single CaMeL Dependency ( psi , host ) ;  <CTX>  public Result < Psi CaMeL Element > compute ( ) { final Text CaMeL Range document CaMeL Window = host . get CaMeL Text CaMeL Range ( ) . cut CaMeL Out ( range ) ; final Virtual CaMeL File host CaMeL Virtual CaMeL File = host . get CaMeL Containing CaMeL File ( ) . get CaMeL Virtual CaMeL File ( ) ; final Document CaMeL Ex document = ( Document CaMeL Ex ) Psi CaMeL Document CaMeL Manager . get CaMeL Instance ( host . get CaMeL Project ( ) ) . get CaMeL Document ( host . get CaMeL Containing CaMeL File ( ) ) ; Document CaMeL Range document CaMeL Range = new Document CaMeL Range ( document , document CaMeL Window ) ; Language language = host . get CaMeL Manager ( ) . get CaMeL Injected CaMeL Language ( host ) ; final Virtual CaMeL File virtual CaMeL File = new Virtual CaMeL File CaMeL Delegate ( host CaMeL Virtual CaMeL File , document CaMeL Window , language , text ) ; File CaMeL Document CaMeL Manager CaMeL Impl . register CaMeL Document ( document CaMeL Range , virtual CaMeL File ) ; Psi CaMeL Element psi = parse CaMeL Injected CaMeL Psi CaMeL File ( text , host . get CaMeL Manager ( ) , language , virtual CaMeL File ) ; if ( psi != null ) { psi . put CaMeL User CaMeL Data ( Resolve CaMeL Util . IN@@ JECTED _ IN _ ELEMENT , host ) ; / / . get CaMeL Containing CaMeL File ( ) ) ; } return Result . create CaMeL Single CaMeL Dependency ( psi , host ) ; }	return Result . create CaMeL Single CaMeL Dependency ( result , host ) ;
if ( style == CURRENCY ) {  <CTX>  public Number CaMeL Format get CaMeL Number CaMeL Format ( int style ) { try { Number CaMeL Format result = null ; if ( number CaMeL Formats != null ) { Object temp = number CaMeL Formats [ style ] ; if ( temp instanceof Number CaMeL Format ) { result = ( Number CaMeL Format ) temp ; } else { result = new Decimal CaMeL Format ( ( String ) temp , new Decimal CaMeL Format CaMeL Symbols ( get CaMeL Date CaMeL Locale ( ) ) ) ; } } if ( result != null ) { result = ( Number CaMeL Format ) result . clone ( ) ; / / clone for safety ( later optimize ) if ( style == CURRENCY ) { result . set CaMeL Currency ( get CaMeL Currency ( ) ) ; } return result ; } / / In the case of date formats , we don t have to look at more than one / / locale . May be different for other cases switch ( style ) { case NUMBER : return Number CaMeL Format . get CaMeL Instance ( get CaMeL Number CaMeL Locale ( ) ) ; case SCI@@ ENTI@@ FIC : return Number CaMeL Format . get CaMeL Scientific CaMeL Instance ( get CaMeL Number CaMeL Locale ( ) ) ; case INTEGER : return Number CaMeL Format . get CaMeL Integer CaMeL Instance ( get CaMeL Number CaMeL Locale ( ) ) ; case PERCENT : return Number CaMeL Format . get CaMeL Percent CaMeL Instance ( get CaMeL Number CaMeL Locale ( ) ) ; case CURRENCY : result = Number CaMeL Format . get CaMeL Currency CaMeL Instance ( get CaMeL Number CaMeL Locale ( ) ) ; result . set CaMeL Currency ( get CaMeL Currency ( ) ) ; return result ; } } catch ( Runtime CaMeL Exception e ) { } throw new Illegal CaMeL Argument CaMeL Exception ( ) ; / / fix later }	if ( style == NF _ CURRENCY ) {
Value CaMeL Base CaMeL Helper . write ( this , value ) ;  <CTX>  public void write _ value ( Serializable value ) { Value CaMeL Base CaMeL Helper . write ( this , value ) ; }	Vio . write ( this , value ) ;
i CaMeL Visited . accept ( _ Payload ) ;  <CTX>  public void visit CaMeL Call CaMeL Node ( Call CaMeL Node i CaMeL Visited ) { i CaMeL Visited . get CaMeL Recv CaMeL Node ( ) . accept ( this ) ; for ( Node node = i CaMeL Visited . get CaMeL Args CaMeL Node ( ) ; node != null ; node = node . get CaMeL Next CaMeL Node ( ) ) { node . get CaMeL Head CaMeL Node ( ) . accept ( this ) ; } i CaMeL Visited . accept ( _ Payload ) ; }	_ Payload . visit CaMeL Call CaMeL Node ( i CaMeL Visited ) ;
throw new Evaluator CaMeL Exception ( message , source CaMeL Name , line , line CaMeL Source , line CaMeL Offset ) ;  <CTX>  public Evaluator CaMeL Exception runtime CaMeL Error ( String message , String source CaMeL Name , int line , String line CaMeL Source , int line CaMeL Offset ) { throw new Evaluator CaMeL Exception ( message , source CaMeL Name , line , line CaMeL Source , line CaMeL Offset ) ; }	if ( chained CaMeL Reporter != null ) { return chained CaMeL Reporter . runtime CaMeL Error ( message , source CaMeL URI , line , line CaMeL Text , line CaMeL Offset ) ; } else { return new Evaluator CaMeL Exception ( message , source CaMeL URI , line , line CaMeL Text , line CaMeL Offset ) ; }
this . system = system ;  <CTX>  public Activation CaMeL Group CaMeL ID ( Activation CaMeL System system ) { this . system = system ; }	system = a CaMeL System ; uid = new UID ( ) ;
File dir = File CaMeL Utils . get CaMeL Parent CaMeL File ( file ) ;  <CTX>  public File CaMeL Desc add CaMeL File CaMeL If CaMeL Shared ( File file ) { / / Make sure capit@@ als are resolved proper@@ ly , etc . File f = null ; try { f = File CaMeL Utils . get CaMeL Canonical CaMeL File ( file ) ; if ( ! f . exists ( ) ) return null ; } catch ( IO CaMeL Exception e ) { return null ; } File dir = File CaMeL Utils . get CaMeL Parent CaMeL File ( file ) ; if ( dir == null ) return null ; / / TODO : if over@@ writing an existing , take special c@@ are . boolean directory CaMeL Shared ; synchronized ( this ) { directory CaMeL Shared = _ shared CaMeL Directories . contains CaMeL Key ( dir ) ; _ num CaMeL Pending CaMeL Files ++ ; } File CaMeL Desc fd ; if ( directory CaMeL Shared ) fd = add CaMeL File ( file ) ; else fd = null ; synchronized ( this ) { _ num CaMeL Pending CaMeL Files -- ; } return fd ; }	File dir = File CaMeL Utils . get CaMeL Parent CaMeL File ( f ) ;
else if ( auto CaMeL Save == I CaMeL Preferences . AUTO _ SAVE _ ASK )  <CTX>  public void build ( I CaMeL File doxyfile ) { / / Retriev@@ es the plugin preferences . Preferences preferences = Plugin . get CaMeL Default ( ) . get CaMeL Plugin CaMeL Preferences ( ) ; / / Ask the user if he wants to save all opened editors before proce@@ eding to build . final String auto CaMeL Save = preferences . get CaMeL String ( I CaMeL Preferences . AUTO _ SAVE ) ; if ( auto CaMeL Save == I CaMeL Preferences . AUTO _ SAVE _ ALWAYS ) { Platform CaMeL UI . get CaMeL Workbench ( ) . get CaMeL Active CaMeL Workbench CaMeL Window ( ) . get CaMeL Active CaMeL Page ( ) . save CaMeL All CaMeL Editors ( false ) ; } else if ( auto CaMeL Save == I CaMeL Preferences . AUTO _ SAVE _ ASK ) { boolean saved ; saved = Platform CaMeL UI . get CaMeL Workbench ( ) . get CaMeL Active CaMeL Workbench CaMeL Window ( ) . get CaMeL Active CaMeL Page ( ) . save CaMeL All CaMeL Editors ( true ) ; if ( saved == false ) { return ; } } / / Re@@ tre@@ i@@ ves the build job for the given doxyfile . Build CaMeL Job job = Build CaMeL Job . get CaMeL Job ( doxyfile ) ; / / Attach@@ es a listener if applicable . if ( job CaMeL History . contains ( job ) == false ) { job . add CaMeL Bu@@ id CaMeL Job CaMeL Listener ( new My CaMeL Job CaMeL Listener ( ) ) ; } / / Updates the job history . int prefered CaMeL History CaMeL Size = preferences . get CaMeL Int ( I CaMeL Preferences . BUILD _ HISTORY _ SIZE ) ; job CaMeL History . remove ( job ) ; if ( job CaMeL History . size ( ) >= prefered CaMeL History CaMeL Size && job CaMeL History . is CaMeL Empty ( ) == false ) { job CaMeL History . remove ( 0 ) ; } job CaMeL History . add ( job ) ; / / Updates the console . Console CaMeL Manager console CaMeL Manager = Plugin . get CaMeL Default ( ) . get CaMeL Console CaMeL Manager ( ) ; console CaMeL Manager . show CaMeL Console ( job ) ; / / Schedule the job to build . job . schedule ( ) ; }	else if ( auto CaMeL Save . equals ( I CaMeL Preferences . AUTO _ SAVE _ ASK ) )
result = self . get CaMeL Internal CaMeL Class ( ) . call ( self . to CaMeL Ruby CaMeL Object ( ) , i CaMeL Visited . get CaMeL Name ( ) , args , 1 ) ;  <CTX>  public void visit CaMeL F CaMeL Call CaMeL Node ( F CaMeL Call CaMeL Node i CaMeL Visited ) { Block tmp CaMeL Block = Args CaMeL Util . begin CaMeL Call CaMeL Args ( ruby ) ; I CaMeL Ruby CaMeL Object [ ] args = Args CaMeL Util . setup CaMeL Args ( ruby , this , i CaMeL Visited . get CaMeL Args CaMeL Node ( ) ) ; Args CaMeL Util . end CaMeL Call CaMeL Args ( ruby , tmp CaMeL Block ) ; result = self . get CaMeL Internal CaMeL Class ( ) . call ( self . to CaMeL Ruby CaMeL Object ( ) , i CaMeL Visited . get CaMeL Name ( ) , args , 1 ) ; }	result = self . get CaMeL Internal CaMeL Class ( ) . call ( self , i CaMeL Visited . get CaMeL Name ( ) , args , 1 ) ;
int col CaMeL Number = column CaMeL Number - column CaMeL With CaMeL Width ; int aw = ( max CaMeL Width - col CaMeL Sum ) / col CaMeL Number ; distribute CaMeL Width ( columns , col CaMeL Number , aw ) ;  <CTX>  public int [ ] resolve ( int specified CaMeL Width , int max CaMeL Width ) { assert ( specified CaMeL Width <= max CaMeL Width ) ; int column CaMeL Number = table . get CaMeL Column CaMeL Count ( ) ; int [ ] columns = new int [ column CaMeL Number ] ; int column CaMeL With CaMeL Width = 0 ; int col CaMeL Sum = 0 ; for ( int j = 0 ; j < table . get CaMeL Column CaMeL Count ( ) ; j ++ ) { I CaMeL Column column = ( I CaMeL Column ) table . get CaMeL Column ( j ) ; int column CaMeL Width = get CaMeL Dimension CaMeL Value ( column . get CaMeL Width ( ) , table CaMeL Width ) ; if ( column CaMeL Width > 0 ) { columns [ j ] = column CaMeL Width ; col CaMeL Sum += column CaMeL Width ; column CaMeL With CaMeL Width ++ ; } else { columns [ j ] = - 1 ; } } if ( column CaMeL With CaMeL Width == column CaMeL Number ) { if ( col CaMeL Sum <= max CaMeL Width ) { return columns ; } else { int delta = ( col CaMeL Sum - max CaMeL Width ) / column CaMeL Number ; assert ( delta >= 0 ) ; for ( int i = 0 ; i < column CaMeL Number ; i ++ ) { columns [ i ] -= delta ; } return columns ; } } else { if ( specified CaMeL Width == 0 ) { if ( col CaMeL Sum < max CaMeL Width ) { int col CaMeL Number = column CaMeL Number - column CaMeL With CaMeL Width ; int aw = ( max CaMeL Width - col CaMeL Sum ) / col CaMeL Number ; distribute CaMeL Width ( columns , col CaMeL Number , aw ) ; } else { distribute CaMeL Width ( columns , column CaMeL Number , max CaMeL Width / column CaMeL Number ) ; } } else { if ( col CaMeL Sum < specified CaMeL Width ) { int col CaMeL Number = column CaMeL Number - column CaMeL With CaMeL Width ; int aw = ( specified CaMeL Width - col CaMeL Sum ) / col CaMeL Number ; distribute CaMeL Width ( columns , col CaMeL Number , aw ) ; } else { if ( col CaMeL Sum < max CaMeL Width ) { int col CaMeL Number = column CaMeL Number - column CaMeL With CaMeL Width ; int aw = ( max CaMeL Width - col CaMeL Sum ) / col CaMeL Number ; distribute CaMeL Width ( columns , col CaMeL Number , aw ) ; } else { distribute CaMeL Width ( columns , column CaMeL Number , specified CaMeL Width / column CaMeL Number ) ; } } } } return columns ; }	distribute CaMeL Left CaMeL Width ( columns , ( max CaMeL Width - col CaMeL Sum ) / ( column CaMeL Number - column CaMeL With CaMeL Width ) ) ;
if ( attr == null ) return null ;  <CTX>  public String get CaMeL String ( String key ) { Attr attr = element . get CaMeL Attribute CaMeL Node ( key ) ; if ( attr == null ) return null ; return attr . get CaMeL Value ( ) ; }	if ( attr == null ) { return null ; }
return old CaMeL Map . size ( ) >= new CaMeL Map . size ( ) ;  <CTX>  private static boolean is CaMeL Compatible CaMeL RS CaMeL Map ( Map old CaMeL Map , Map new CaMeL Map ) { if ( old CaMeL Map == new CaMeL Map ) return true ; else if ( old CaMeL Map == null ) return new CaMeL Map . size ( ) == 0 ; else if ( new CaMeL Map == null ) return old CaMeL Map . size ( ) == 0 ; return old CaMeL Map . size ( ) >= new CaMeL Map . size ( ) ; }	if ( new CaMeL Map . size ( ) > old CaMeL Map . size ( ) ) return false ; Iterator it = new CaMeL Map . key CaMeL Set ( ) . iterator ( ) ; while ( it . has CaMeL Next ( ) ) { Object key = it . next ( ) ; Object old CaMeL Obj = old CaMeL Map . get ( key ) ; Object new CaMeL Obj = new CaMeL Map . get ( key ) ; if ( old CaMeL Obj != null ) { if ( is CaMeL Two CaMeL Expression CaMeL Equal ( ( I CaMeL Base CaMeL Expression ) new CaMeL Obj , ( I CaMeL Base CaMeL Expression ) old CaMeL Obj ) ) return false ; } else { return false ; } } return true ;
contexts . remove ( cx ) ;  <CTX>  public void context CaMeL Released ( Context cx ) { contexts . remove ( cx ) ; }	synchronized ( contexts ) { contexts . remove ( cx ) ; }
if ( perspective CaMeL Switcher != null ) perspective CaMeL Switcher . update ( false ) ;  <CTX>  public void set CaMeL Active CaMeL Page ( final I CaMeL Workbench CaMeL Page in ) { if ( get CaMeL Active CaMeL Workbench CaMeL Page ( ) == in ) return ; / / 1 F@@ V@@ G@@ T@@ NR : IT@@ P@@ UI : WIN@@ NT - busy cursor for swit@@ ching perspectives Busy CaMeL Indicator . show CaMeL While ( get CaMeL Shell ( ) . get CaMeL Display ( ) , new Runnable ( ) { public void run ( ) { / / Deactivate old per@@ sp . Workbench CaMeL Page current CaMeL Page = get CaMeL Active CaMeL Workbench CaMeL Page ( ) ; if ( current CaMeL Page != null ) { current CaMeL Page . on CaMeL Deactivate ( ) ; } / / Activate new per@@ sp . if ( in == null || page CaMeL List . contains ( in ) ) page CaMeL List . set CaMeL Active ( in ) ; Workbench CaMeL Page new CaMeL Page = page CaMeL List . get CaMeL Active ( ) ; Composite parent = get CaMeL Page CaMeL Composite ( ) ; Stack CaMeL Layout layout = ( Stack CaMeL Layout ) parent . get CaMeL Layout ( ) ; if ( new CaMeL Page != null ) { layout . top CaMeL Control = new CaMeL Page . get CaMeL Client CaMeL Composite ( ) ; parent . layout ( ) ; hide CaMeL Empty CaMeL Window CaMeL Contents ( ) ; new CaMeL Page . on CaMeL Activate ( ) ; fire CaMeL Page CaMeL Activated ( new CaMeL Page ) ; if ( new CaMeL Page . get CaMeL Perspective ( ) != null ) fire CaMeL Perspective CaMeL Activated ( new CaMeL Page , new CaMeL Page . get CaMeL Perspective ( ) ) ; } else { layout . top CaMeL Control = null ; parent . layout ( ) ; } update CaMeL Fast CaMeL View CaMeL Bar ( ) ; if ( is CaMeL Closing ( ) ) return ; update CaMeL Disabled = false ; / / Update action bars ( implicitly calls update CaMeL Action CaMeL Bars ( ) ) update CaMeL Action CaMeL Sets ( ) ; if ( perspective CaMeL Switcher != null ) perspective CaMeL Switcher . update ( false ) ; get CaMeL Menu CaMeL Manager ( ) . update ( I CaMeL Action . TEXT ) ; } } ) ; }	update CaMeL Action CaMeL Sets ( ) ; submit CaMeL Global CaMeL Actions ( ) ;
while ( true ) { try { result = get CaMeL Iter CaMeL Node ( ) . eval ( ruby , self ) ; break ; } catch ( Retry CaMeL Exception r CaMeL Ex@@ cp@@ tn ) { } catch ( Return CaMeL Exception r CaMeL Ex@@ cp@@ tn ) { result = r CaMeL Ex@@ cp@@ tn . get CaMeL Return CaMeL Value ( ) ; break ; } catch ( Break CaMeL Exception b CaMeL Ex@@ cp@@ tn ) { result = ruby . get CaMeL Nil ( ) ; break ;  <CTX>  public Ruby CaMeL Object eval ( Ruby ruby , Ruby CaMeL Object self ) { Ruby CaMeL Object result ; ruby . get CaMeL Block ( ) . push ( get CaMeL Var CaMeL Node ( ) , get CaMeL Body CaMeL Node ( ) , self ) ; ruby . get CaMeL Iter ( ) . push ( Ruby CaMeL Iter . ITER _ PRE ) ; while ( true ) { try { result = get CaMeL Iter CaMeL Node ( ) . eval ( ruby , self ) ; break ; } catch ( Retry CaMeL Exception r CaMeL Ex@@ cp@@ tn ) { } catch ( Return CaMeL Exception r CaMeL Ex@@ cp@@ tn ) { result = r CaMeL Ex@@ cp@@ tn . get CaMeL Return CaMeL Value ( ) ; break ; } catch ( Break CaMeL Exception b CaMeL Ex@@ cp@@ tn ) { result = ruby . get CaMeL Nil ( ) ; break ; } } ruby . get CaMeL Iter ( ) . pop ( ) ; ruby . get CaMeL Block ( ) . pop ( ) ; return result ; }	try { while ( true ) { try { return get CaMeL Iter CaMeL Node ( ) . eval ( ruby , self ) ; } catch ( Retry CaMeL Exception r CaMeL Ex@@ cp@@ tn ) { }
if ( processes CaMeL Frame . is CaMeL Visible ( ) ) { processes CaMeL Frame . set CaMeL Visible ( false ) ;  <CTX>  public void action CaMeL Performed ( java . awt . event . Action CaMeL Event e ) { if ( processes CaMeL Frame . is CaMeL Visible ( ) ) { processes CaMeL Frame . set CaMeL Visible ( false ) ; } else { processes CaMeL Frame . set CaMeL Visible ( true ) ; } }	if ( job CaMeL Monitor CaMeL Frame . is CaMeL Visible ( ) ) { job CaMeL Monitor CaMeL Frame . set CaMeL Visible ( false ) ;
keyword CaMeL Map = null ;  <CTX>  private static Completion [ ] get CaMeL Completions ( Buffer buffer , String word , int caret ) { / / build a list of unique words in all visible buffers Set completions = new Tree CaMeL Set ( new Misc CaMeL Utilities . String CaMeL I CaMeL Case CaMeL Compare ( ) ) ; Set buffers = new Hash CaMeL Set ( ) ; View views = j CaMeL Edit . get CaMeL First CaMeL View ( ) ; while ( views != null ) { Edit CaMeL Pane [ ] panes = views . get CaMeL Edit CaMeL Panes ( ) ; for ( int i = 0 ; i < panes . length ; i ++ ) { Buffer b = panes [ i ] . get CaMeL Buffer ( ) ; if ( buffers . contains ( b ) ) continue ; buffers . add ( b ) ; / / only complete current buffer s keyword map Keyword CaMeL Map keyword CaMeL Map ; if ( b == buffer ) { keyword CaMeL Map = b . get CaMeL Keyword CaMeL Map CaMeL At CaMeL Offset ( caret ) ; } else keyword CaMeL Map = null ; int offset = ( b == buffer ? caret : 0 ) ; String no CaMeL Word CaMeL Sep = get CaMeL Non CaMeL Alpha CaMeL Numeric CaMeL Word CaMeL Chars ( b , keyword CaMeL Map , offset ) ; get CaMeL Completions ( b , word , keyword CaMeL Map , no CaMeL Word CaMeL Sep , offset , completions ) ; } views = views . get CaMeL Next ( ) ; } Completion [ ] completion CaMeL Array = ( Completion [ ] ) completions . to CaMeL Array ( new Completion [ completions . size ( ) ] ) ; return completion CaMeL Array ; } / / } } }	_ keyword CaMeL Map = null ;
if ( show CaMeL Selections ( ) && ! show CaMeL Children CaMeL Hierarchy ( ) ) return I CaMeL Resource . DEPTH _ ZERO ;  <CTX>  int get CaMeL Resource CaMeL Depth ( ) { if ( show CaMeL Selections ( ) && ! show CaMeL Children CaMeL Hierarchy ( ) ) return I CaMeL Resource . DEPTH _ ZERO ; return I CaMeL Resource . DEPTH _ INFINITE ; }	if ( show CaMeL Selections ( ) && ! show CaMeL Children CaMeL Hierarchy ( ) ) { return I CaMeL Resource . DEPTH _ ZERO ; }
endpoint CaMeL References . add ( ( Endpoint CaMeL Reference ) digester . pop ( ) ) ;  <CTX>  public void end ( String endpoint CaMeL Name , String endpoint CaMeL Name 1 ) throws Exception { endpoint CaMeL References . add ( ( Endpoint CaMeL Reference ) digester . pop ( ) ) ; }	digester . pop ( ) ;
map . put ( d . get CaMeL Management CaMeL Key ( ) , artifact ) ;  <CTX>  private Map create CaMeL Managed CaMeL Version CaMeL Map ( Dependency CaMeL Management dependency CaMeL Management ) { Map map = new Hash CaMeL Map ( ) ; for ( Iterator i = dependency CaMeL Management . get CaMeL Dependencies ( ) . iterator ( ) ; i . has CaMeL Next ( ) ; ) { Dependency d = ( Dependency ) i . next ( ) ; Artifact artifact = artifact CaMeL Factory . create CaMeL Artifact ( d . get CaMeL Group CaMeL Id ( ) , d . get CaMeL Artifact CaMeL Id ( ) , d . get CaMeL Version ( ) , d . get CaMeL Scope ( ) , d . get CaMeL Type ( ) , null ) ; map . put ( d . get CaMeL Management CaMeL Key ( ) , artifact ) ; } return map ; }	map . put ( d . get CaMeL Management CaMeL Key ( ) , artifact ) ; } } else { map = Collections . EMPTY _ MAP ;
return make . This ( pos , Ident ( pos , sym ) ) . set CaMeL Type ( sym . this CaMeL Type ( ) ) ;  <CTX>  public Tree This ( int pos , Symbol sym ) { return make . This ( pos , Ident ( pos , sym ) ) . set CaMeL Type ( sym . this CaMeL Type ( ) ) ; }	Type type = sym . this CaMeL Type ( ) ; return make . This ( pos , Type CaMeL Term ( pos , type ) ) . set CaMeL Type ( type ) ;
context CaMeL Listeners = Listener CaMeL Array . remove ( context CaMeL Listeners , listener ) ;  <CTX>  public static void remove CaMeL Context CaMeL Listener ( Context CaMeL Listener listener ) { synchronized ( context CaMeL Listeners CaMeL Lock ) { context CaMeL Listeners = Listener CaMeL Array . remove ( context CaMeL Listeners , listener ) ; } }	context CaMeL Listeners = Kit . remove CaMeL Listener ( context CaMeL Listeners , listener ) ;
Fact fact CaMeL At CaMeL Location = get CaMeL Fact CaMeL At CaMeL Location ( new Location ( handle , basic CaMeL Block ) ) ;  <CTX>  public void transfer ( Basic CaMeL Block basic CaMeL Block , Instruction CaMeL Handle end , Fact start , Fact result ) throws Dataflow CaMeL Analysis CaMeL Exception { copy ( start , result ) ; if ( is CaMeL Fact CaMeL Valid ( result ) ) { Iterator < Instruction CaMeL Handle > i = is CaMeL Forwards ( ) ? basic CaMeL Block . instruction CaMeL Iterator ( ) : basic CaMeL Block . instruction CaMeL Reverse CaMeL Iterator ( ) ; while ( i . has CaMeL Next ( ) ) { Instruction CaMeL Handle handle = i . next ( ) ; if ( handle == end ) break ; / / Record the fact at this location Fact fact CaMeL At CaMeL Location = get CaMeL Fact CaMeL At CaMeL Location ( new Location ( handle , basic CaMeL Block ) ) ; copy ( result , fact CaMeL At CaMeL Location ) ; / / Transfer the dataflow value transfer CaMeL Instruction ( handle , basic CaMeL Block , result ) ; } } }	Location location = new Location ( handle , basic CaMeL Block ) ; Fact fact CaMeL At CaMeL Location = get CaMeL Fact CaMeL At CaMeL Location ( location ) ;
boolean [ ] breakable CaMeL Lines = this . breakable CaMeL Lines ; if ( breakable CaMeL Lines != null && line < breakable CaMeL Lines . length ) { return breakable CaMeL Lines [ line ] ;  <CTX>  boolean breakable CaMeL Line ( int line ) { boolean [ ] breakable CaMeL Lines = this . breakable CaMeL Lines ; if ( breakable CaMeL Lines != null && line < breakable CaMeL Lines . length ) { return breakable CaMeL Lines [ line ] ; } return false ; }	boolean [ ] breakable CaMeL Lines = this . breakable CaMeL Lines ; if ( breakable CaMeL Lines != null && line < breakable CaMeL Lines . length ) { return breakable CaMeL Lines [ line ] ; } return false ;
return new Ruby CaMeL Array ( ruby ) {  <CTX>  public static Ruby CaMeL Array nil CaMeL Array ( Ruby ruby ) { return new Ruby CaMeL Array ( ruby ) { public boolean is CaMeL Nil ( ) { return true ; } } ; }	return new Ruby CaMeL Array ( ruby , null ) {
return new UTF _ 16 Encoder ( this , UTF _ 16 Encoder . BIG _ ENDIAN , false ) ;  <CTX>  public Charset CaMeL Encoder new CaMeL Encoder ( ) { return new UTF _ 16 Encoder ( this , UTF _ 16 Encoder . BIG _ ENDIAN , false ) ; }	return new UTF _ 16 Encoder ( this , UTF _ 16 Encoder . BIG _ ENDIAN , true ) ;
return full CaMeL Definitions . length > 0 ;  <CTX>  public boolean prepare CaMeL Decoration ( Object element , String original CaMeL Text ) { / / Check if there is a decoration ready or if there is no lightweight decorators to be applied if ( scheduler . is CaMeL Decoration CaMeL Ready ( element ) || ! get CaMeL Lightweight CaMeL Manager ( ) . has CaMeL Enabled CaMeL Definitions ( ) ) { return true ; } / / Force an update if there is a text already boolean force = true ; / / If not then do not force as the undecorated value is fine if ( original CaMeL Text == null || original CaMeL Text . length ( ) == 0 ) force = false ; / / Queue the decoration . scheduler . queue CaMeL For CaMeL Decoration ( element , get CaMeL Resource CaMeL Adapter ( element ) , force , original CaMeL Text ) ; / / If all that is there is deferred ones then defer decoration . / / For the sa@@ ke of e@@ ffec@@ i@@ ency we do not test for enabl@@ ement at this / / point and just abandon de@@ fer@@ ment if there are any to run right / / away return full CaMeL Definitions . length > 0 ; }	return get CaMeL Full CaMeL Definitions ( ) . length > 0 ;
I CaMeL Domain CaMeL Validator domain CaMeL Validator ) { this ( model CaMeL To CaMeL Target CaMeL Converter , target CaMeL To CaMeL Model CaMeL Converter , target CaMeL Validator , domain CaMeL Validator , null , null , null ) ;  <CTX>  public Bind CaMeL Spec ( I CaMeL Converter model CaMeL To CaMeL Target CaMeL Converter , I CaMeL Converter target CaMeL To CaMeL Model CaMeL Converter , I CaMeL Validator target CaMeL Validator , I CaMeL Domain CaMeL Validator domain CaMeL Validator ) { this ( model CaMeL To CaMeL Target CaMeL Converter , target CaMeL To CaMeL Model CaMeL Converter , target CaMeL Validator , domain CaMeL Validator , null , null , null ) ; }	I CaMeL Domain CaMeL Validator domain CaMeL Validator , Integer model CaMeL Update CaMeL Policy , Integer validate CaMeL Policy , Integer target CaMeL Update CaMeL Policy ) { this . model CaMeL To CaMeL Target CaMeL Converters [ 0 ] = model CaMeL To CaMeL Target CaMeL Converter ; this . target CaMeL To CaMeL Model CaMeL Converters [ 0 ] = target CaMeL To CaMeL Model CaMeL Converter ; this . target CaMeL Validators [ 0 ] = target CaMeL Validator ; this . domain CaMeL Validator = domain CaMeL Validator ; this . model CaMeL Update CaMeL Policy = model CaMeL Update CaMeL Policy ; this . validate CaMeL Policy = validate CaMeL Policy ; this . target CaMeL Update CaMeL Policy = target CaMeL Update CaMeL Policy ;
j@@ si . its CaMeL Data = new Interpreter CaMeL Data ( its CaMeL Data . security CaMeL Domain , its CaMeL Data . language CaMeL Version ) ; j@@ si . its CaMeL Data . parent CaMeL Data = its CaMeL Data ; j@@ si . its CaMeL Data . its CaMeL Source CaMeL File = its CaMeL Data . its CaMeL Source CaMeL File ; j@@ si . its CaMeL Data . encoded CaMeL Source = its CaMeL Data . encoded CaMeL Source ;  <CTX>  private void generate CaMeL Nested CaMeL Functions ( Context cx ) { int function CaMeL Count = script CaMeL Or CaMeL Fn . get CaMeL Function CaMeL Count ( ) ; if ( function CaMeL Count == 0 ) return ; Interpreter CaMeL Data [ ] array = new Interpreter CaMeL Data [ function CaMeL Count ] ; for ( int i = 0 ; i != function CaMeL Count ; i ++ ) { Function CaMeL Node def = script CaMeL Or CaMeL Fn . get CaMeL Function CaMeL Node ( i ) ; Interpreter j@@ si = new Interpreter ( ) ; j@@ si . compiler CaMeL Env = compiler CaMeL Env ; j@@ si . script CaMeL Or CaMeL Fn = def ; j@@ si . its CaMeL Data = new Interpreter CaMeL Data ( its CaMeL Data . security CaMeL Domain , its CaMeL Data . language CaMeL Version ) ; j@@ si . its CaMeL Data . parent CaMeL Data = its CaMeL Data ; j@@ si . its CaMeL Data . its CaMeL Source CaMeL File = its CaMeL Data . its CaMeL Source CaMeL File ; j@@ si . its CaMeL Data . encoded CaMeL Source = its CaMeL Data . encoded CaMeL Source ; j@@ si . its CaMeL Data . its CaMeL Check CaMeL This = def . get CaMeL Check CaMeL This ( ) ; j@@ si . its CaMeL In CaMeL Function CaMeL Flag = true ; j@@ si . generate CaMeL Function CaMeL I CaMeL Code ( cx ) ; array [ i ] = j@@ si . its CaMeL Data ; } its CaMeL Data . its CaMeL Nested CaMeL Functions = array ; }	j@@ si . its CaMeL Data = new Interpreter CaMeL Data ( its CaMeL Data ) ;
this ( Location . UNKNOWN , value ) ;  <CTX>  public String CaMeL Literal CaMeL Expr ( String value ) { this ( Location . UNKNOWN , value ) ; }	super ( location ) ; _ value = new Intern CaMeL String CaMeL Value ( value ) ;
return ( ( page == spec CaMeL Page && page . is CaMeL Page CaMeL Complete ( ) && structure CaMeL Page . is CaMeL Initialized ( ) ) || ( page == structure CaMeL Page && page . is CaMeL Page CaMeL Complete ( ) ) || ( page == plugin CaMeL List CaMeL Page && page . is CaMeL Page CaMeL Complete ( ) ) ) ;  <CTX>  public boolean can CaMeL Finish ( ) { I CaMeL Wizard CaMeL Page page = get CaMeL Container ( ) . get CaMeL Current CaMeL Page ( ) ; return ( ( page == spec CaMeL Page && page . is CaMeL Page CaMeL Complete ( ) && structure CaMeL Page . is CaMeL Initialized ( ) ) || ( page == structure CaMeL Page && page . is CaMeL Page CaMeL Complete ( ) ) || ( page == plugin CaMeL List CaMeL Page && page . is CaMeL Page CaMeL Complete ( ) ) ) ; }	return ( ( page == spec CaMeL Page && page . is CaMeL Page CaMeL Complete ( ) ) || ( page == plugin CaMeL List CaMeL Page && page . is CaMeL Page CaMeL Complete ( ) ) ) ;
int left CaMeL Bits = float CaMeL To CaMeL Int CaMeL Bits ( this . float CaMeL Value ( ) ) ; int right CaMeL Bits = float CaMeL To CaMeL Int CaMeL Bits ( ( ( Float ) obj ) . float CaMeL Value ( ) ) ; int nan CaMeL Bits = float CaMeL To CaMeL Int CaMeL Bits ( Na CaMeL N ) ; int pos CaMeL Bits = float CaMeL To CaMeL Int CaMeL Bits ( POSITIVE _ INFINITY ) ; int neg CaMeL Bits = float CaMeL To CaMeL Int CaMeL Bits ( NEGATIVE _ INFINITY ) ;  <CTX>  public boolean equals ( Object obj ) { if ( ( obj != null ) && ( obj instanceof Float ) ) { int left CaMeL Bits = float CaMeL To CaMeL Int CaMeL Bits ( this . float CaMeL Value ( ) ) ; int right CaMeL Bits = float CaMeL To CaMeL Int CaMeL Bits ( ( ( Float ) obj ) . float CaMeL Value ( ) ) ; int nan CaMeL Bits = float CaMeL To CaMeL Int CaMeL Bits ( Na CaMeL N ) ; int pos CaMeL Bits = float CaMeL To CaMeL Int CaMeL Bits ( POSITIVE _ INFINITY ) ; int neg CaMeL Bits = float CaMeL To CaMeL Int CaMeL Bits ( NEGATIVE _ INFINITY ) ; if ( ( this . is CaMeL Na CaMeL N ( ) == true ) && ( ( ( Float ) obj ) . is CaMeL Na CaMeL N ( ) == true ) ) { return true ; } if ( ( ( left CaMeL Bits == pos CaMeL Bits ) && ( right CaMeL Bits == neg CaMeL Bits ) ) || ( ( left CaMeL Bits == pos CaMeL Bits ) && ( right CaMeL Bits == neg CaMeL Bits ) ) ) { return true ; } return ( left CaMeL Bits == right CaMeL Bits ) ; } else { return false ; } }	final int left CaMeL Bits = float CaMeL To CaMeL Int CaMeL Bits ( this . value ) ; final int right CaMeL Bits = float CaMeL To CaMeL Int CaMeL Bits ( ( ( Float ) obj ) . value ) ; final int pos CaMeL Bits = float CaMeL To CaMeL Int CaMeL Bits ( POSITIVE _ INFINITY ) ; final int neg CaMeL Bits = float CaMeL To CaMeL Int CaMeL Bits ( NEGATIVE _ INFINITY ) ;
return this . nested CaMeL Throwable ;  <CTX>  public Throwable get CaMeL Cause ( ) { return this . nested CaMeL Throwable ; }	return nested CaMeL Throwable ;
if ( event . widget . equals ( fcc CaMeL Candle ) ) { series . set CaMeL Fill ( ( Fill ) event . data ) ; } else if ( event . widget . equals ( li@@ ac CaMeL Stock ) )  <CTX>  public void handle CaMeL Event ( Event event ) { if ( event . widget . equals ( fcc CaMeL Candle ) ) { series . set CaMeL Fill ( ( Fill ) event . data ) ; } else if ( event . widget . equals ( li@@ ac CaMeL Stock ) ) { if ( event . type == Line CaMeL Attributes CaMeL Composite . VISIBILITY _ CHANGED _ EVENT ) { series . get CaMeL Line CaMeL Attributes ( ) . set CaMeL Visible ( ( ( Boolean ) event . data ) . boolean CaMeL Value ( ) ) ; } else if ( event . type == Line CaMeL Attributes CaMeL Composite . STYLE _ CHANGED _ EVENT ) { series . get CaMeL Line CaMeL Attributes ( ) . set CaMeL Style ( ( Line CaMeL Style ) event . data ) ; } else if ( event . type == Line CaMeL Attributes CaMeL Composite . WIDTH _ CHANGED _ EVENT ) { series . get CaMeL Line CaMeL Attributes ( ) . set CaMeL Thickness ( ( ( Integer ) event . data ) . int CaMeL Value ( ) ) ; } else if ( event . type == Line CaMeL Attributes CaMeL Composite . COLOR _ CHANGED _ EVENT ) { series . get CaMeL Line CaMeL Attributes ( ) . set CaMeL Color ( ( Color CaMeL Definition ) event . data ) ; } } }	if ( event . widget . equals ( li@@ ac CaMeL Stock ) )
return UNCHANGED ;  <CTX>  private static byte double CaMeL Neg ( OPT _ Instruction s ) { if ( CF _ DOUBLE ) { OPT _ Operand op = Unary . get CaMeL Val ( s ) ; if ( op . is CaMeL Double CaMeL Constant ( ) ) { / / CONSTANT : FOLD double val = op . as CaMeL Double CaMeL Constant ( ) . value ; Move . mutate ( s , DOUBLE _ MOVE , Unary . get CaMeL Clear CaMeL Result ( s ) , DC ( - val ) ) ; return MOVE _ FOLDED ; } } return UNCHANGED ; }	return Def CaMeL Use CaMeL Effect . UNCHANGED ;
repository = Svn CaMeL Connect . get CaMeL Instance ( ) . get CaMeL Repository ( ) ;  <CTX>  public Svn CaMeL Commit ( ) throws SVN CaMeL Exception { / / super ( SVNWC CaMeL Util . create CaMeL Default CaMeL Authentication CaMeL Manager ( Svn CaMeL Connect . get CaMeL Instance ( ) . get CaMeL Name ( ) , Svn CaMeL Connect . get CaMeL Instance ( ) . get CaMeL Password ( ) ) , SVNWC CaMeL Util . create CaMeL Default CaMeL Options ( true ) ) ; repository = Svn CaMeL Connect . get CaMeL Instance ( ) . get CaMeL Repository ( ) ; svn CaMeL CC = new SVN CaMeL Commit CaMeL Client ( repository . get CaMeL Authentication CaMeL Manager ( ) , SVNWC CaMeL Util . create CaMeL Default CaMeL Options ( true ) ) ; }	repository = Svn CaMeL Connect . get CaMeL Instance ( url , name , password ) . get CaMeL Repository ( ) ;
} , project ) ;  <CTX>  public Dom CaMeL Manager CaMeL Impl ( final Pom CaMeL Model pom CaMeL Model , final Project project , final Reference CaMeL Providers CaMeL Registry registry , final Psi CaMeL Manager psi CaMeL Manager , final Xml CaMeL Aspect xml CaMeL Aspect , final W@@ olf CaMeL The CaMeL Problem CaMeL Solver solver , final Dom CaMeL Element CaMeL Annotations CaMeL Manager CaMeL Impl annotations CaMeL Manager , final Virtual CaMeL File CaMeL Manager virtual CaMeL File CaMeL Manager ) { my CaMeL Project = project ; my CaMeL Annotations CaMeL Manager = annotations CaMeL Manager ; pom CaMeL Model . add CaMeL Model CaMeL Listener ( new Pom CaMeL Model CaMeL Listener ( ) { public synchronized void model CaMeL Changed ( Pom CaMeL Model CaMeL Event event ) { final Xml CaMeL Change CaMeL Set change CaMeL Set = ( Xml CaMeL Change CaMeL Set ) event . get CaMeL Change CaMeL Set ( xml CaMeL Aspect ) ; if ( change CaMeL Set != null ) { if ( ! my CaMeL Changing ) { new External CaMeL Change CaMeL Processor ( Dom CaMeL Manager CaMeL Impl . this , change CaMeL Set ) . process CaMeL Changes ( ) ; } final Xml CaMeL File xml CaMeL File = change CaMeL Set . get CaMeL Changed CaMeL File ( ) ; if ( xml CaMeL File == null ) return ; final File CaMeL Description CaMeL Cached CaMeL Value CaMeL Provider provider = get CaMeL Cached CaMeL Value CaMeL Provider ( xml CaMeL File ) ; if ( provider != null ) { final Dom CaMeL File CaMeL Description description = provider . get CaMeL File CaMeL Description ( ) ; if ( description != null ) { final Dom CaMeL File CaMeL Element CaMeL Impl < Dom CaMeL Element > file CaMeL Element = get CaMeL File CaMeL Element ( xml CaMeL File ) ; final Set < Xml CaMeL File > to CaMeL Update = new T CaMeL Hash CaMeL Set < Xml CaMeL File > ( ) ; for ( final Dom CaMeL File CaMeL Description < ? > dom CaMeL File CaMeL Description : my CaMeL File CaMeL Description CaMeL Dependencies . get ( description ) ) { to CaMeL Update . add CaMeL All ( dom CaMeL File CaMeL Description . get CaMeL Dom CaMeL Model CaMeL Dependent CaMeL Files ( file CaMeL Element ) ) ; to CaMeL Update . add CaMeL All ( Container CaMeL Util . map ( my CaMeL File CaMeL Descriptions . get ( dom CaMeL File CaMeL Description ) , new Function < Dom CaMeL File CaMeL Element CaMeL Impl , Xml CaMeL File > ( ) { public Xml CaMeL File fun ( final Dom CaMeL File CaMeL Element CaMeL Impl s ) { return s . get CaMeL File ( ) ; } } ) ) ; } for ( final Xml CaMeL File file : to CaMeL Update ) { update CaMeL File CaMeL D@@ om@@ ness ( file , file CaMeL Element ) ; } } } } } public boolean is CaMeL Aspect CaMeL Change CaMeL Interesting ( Pom CaMeL Model CaMeL Aspect aspect ) { return xml CaMeL Aspect . equals ( aspect ) ; } } , project ) ; my CaMeL Reference CaMeL Providers CaMeL Registry = registry ; my CaMeL Element CaMeL Factory = psi CaMeL Manager . get CaMeL Element CaMeL Factory ( ) ; solver . register CaMeL File CaMeL Highlight CaMeL Filter ( new Condition < Virtual CaMeL File > ( ) { public boolean value ( final Virtual CaMeL File file ) { final Psi CaMeL File psi CaMeL File = Application CaMeL Manager . get CaMeL Application ( ) . run CaMeL Read CaMeL Action ( new Computable < Psi CaMeL File > ( ) { public @ Nullable Psi CaMeL File compute ( ) { return psi CaMeL Manager . find CaMeL File ( file ) ; } } ) ; return is CaMeL Dom CaMeL File ( psi CaMeL File ) ; } } , project ) ; }	} ) ;
void set CaMeL Parent CaMeL Layer ( Editor CaMeL Fig CaMeL Node parent ) {  <CTX>  void set CaMeL Parent CaMeL Layer ( Editor CaMeL Fig CaMeL Node parent ) { _ parent = parent ; }	void set CaMeL Parent CaMeL Layer ( Module CaMeL Fig CaMeL Node parent ) {
Member CaMeL Expression CaMeL Node ( Node base , Node name ) {  <CTX>  Member CaMeL Expression CaMeL Node ( Node base , Node name ) { this . base = base ; this . name = name ; }	Member CaMeL Expression CaMeL Node ( Node base , Node name , int pos ) { super ( pos ) ;
Document CaMeL Mapper document CaMeL Mapper = Application CaMeL Server . get CaMeL IMC CaMeL Service CaMeL Interface ( ) . get CaMeL Document CaMeL Mapper ( ) ;  <CTX>  private synchronized Attributes . Lazily CaMeL Loaded CaMeL Document CaMeL Attributes get CaMeL Lazily CaMeL Loaded CaMeL Document CaMeL Attributes ( ) { if ( null == attributes . la@@ zily CaMeL Loaded CaMeL Document CaMeL Attributes ) { attributes . la@@ zily CaMeL Loaded CaMeL Document CaMeL Attributes = new Attributes . Lazily CaMeL Loaded CaMeL Document CaMeL Attributes ( ) ; Document CaMeL Mapper document CaMeL Mapper = Application CaMeL Server . get CaMeL IMC CaMeL Service CaMeL Interface ( ) . get CaMeL Document CaMeL Mapper ( ) ; document CaMeL Mapper . init CaMeL Lazily CaMeL Loaded CaMeL Document CaMeL Attributes ( this ) ; } return attributes . la@@ zily CaMeL Loaded CaMeL Document CaMeL Attributes ; }	Document CaMeL Mapper document CaMeL Mapper = Imcms . get CaMeL Services ( ) . get CaMeL Document CaMeL Mapper ( ) ;
X CaMeL Object pred = m _ predicates [ i ] . execute ( xctxt ) ;  <CTX>  private final int get CaMeL Proximity CaMeL Position ( X CaMeL Path CaMeL Context xctxt , int pred CaMeL Pos ) { int pos = 0 ; int context = xctxt . get CaMeL Current CaMeL Node ( ) ; DTM dtm = xctxt . get CaMeL DTM ( context ) ; int parent = dtm . get CaMeL Parent ( context ) ; try { DTM CaMeL Axis CaMeL Traverser traverser = dtm . get CaMeL Axis CaMeL Traverser ( Axis . CHILD ) ; for ( int child = traverser . first ( parent ) ; DTM . NULL != child ; child = traverser . next ( parent , child ) ) { try { xctxt . push CaMeL Current CaMeL Node ( child ) ; if ( Node CaMeL Test . SCORE _ NONE != super . execute ( xctxt , child ) ) { boolean pass = true ; try { xctxt . push CaMeL Sub CaMeL Context CaMeL List ( this ) ; for ( int i = 0 ; i < pred CaMeL Pos ; i ++ ) { X CaMeL Object pred = m _ predicates [ i ] . execute ( xctxt ) ; try { if ( X CaMeL Object . CLASS _ NUMBER == pred . get CaMeL Type ( ) ) { if ( ( pos + 1 ) != ( int ) pred . num CaMeL With CaMeL Side CaMeL Effects ( ) ) { pass = false ; break ; } } else if ( ! pred . bool CaMeL With CaMeL Side CaMeL Effects ( ) ) { pass = false ; break ; } } finally { pred . detach ( ) ; } } } finally { xctxt . pop CaMeL Sub CaMeL Context CaMeL List ( ) ; } if ( pass ) pos ++ ; if ( child == context ) { return pos ; } } } finally { xctxt . pop CaMeL Current CaMeL Node ( ) ; } } } catch ( javax . xml . transform . Transformer CaMeL Exception se ) { / / TODO : should keep throw sax exception . . . throw new java . lang . Runtime CaMeL Exception ( se . get CaMeL Message ( ) ) ; } return pos ; }	xctxt . push CaMeL Predicate CaMeL Pos ( i ) ;
args = null ; flags = FRAME _ ALLOC@@ A ;  <CTX>  public void push ( ) { Frame old CaMeL Frame = new Frame ( self , args , last CaMeL Func , last CaMeL Class , c@@ base , prev , tmp , file , line , iter , flags ) ; prev = old CaMeL Frame ; tmp = null ; / / file = null / / line = / / iter = / / c@@ base = c@@ base ; args = null ; flags = FRAME _ ALLOC@@ A ; }	iter = ruby . get CaMeL Interpreter ( ) . get CaMeL Ruby CaMeL Iter ( ) . get CaMeL Iter ( ) ; args = null ; flags = FRAME _ ALLOC@@ A ;
_ bits = new byte [ ( int ) ( _ size / 8 ) + ( _ size % 8 == 0 ? 0 : 1 ) ] ; dis . read ( _ bits ) ;  <CTX>  public Bit CaMeL Array ( Data CaMeL Input CaMeL Stream dis ) throws IO CaMeL Exception { _ size = dis . read CaMeL Int ( ) ; _ bits = new byte [ ( int ) ( _ size / 8 ) + ( _ size % 8 == 0 ? 0 : 1 ) ] ; dis . read ( _ bits ) ; }	_ bits = new byte [ ( _ size / 8 ) + ( _ size % 8 == 0 ? 0 : 1 ) ] ; dis . read CaMeL Fully ( _ bits ) ;
return person . get CaMeL Attribute CaMeL Names ( ) ;  <CTX>  public Enumeration get CaMeL Attribute CaMeL Names ( ) { return person . get CaMeL Attribute CaMeL Names ( ) ; }	return this . person . get CaMeL Attribute CaMeL Names ( ) ;
loaded CaMeL Classes = new Class [ class CaMeL Bytes . length ] ;  <CTX>  public Scheme CaMeL Loader ( byte [ ] [ ] class CaMeL Bytes ) { this . class CaMeL Bytes = class CaMeL Bytes ; loaded CaMeL Classes = new Class [ class CaMeL Bytes . length ] ; }	size = class CaMeL Bytes . length ; loaded CaMeL Classes = new Class [ size ] ;
IC CaMeL Source CaMeL Locator sl = get CaMeL Source CaMeL Locator ( ) ; if ( sl != null ) return ( sl . find CaMeL Source CaMeL Element ( handle ) != null ) ;  <CTX>  public boolean is CaMeL Target CaMeL Breakpoint ( IC CaMeL Breakpoint breakpoint ) { / / Problem : gdb do@@ e@@ sn t accept breakpoint if the file is specified by full path ( depends on the current directory ) . / / This prev@@ ents us from using gdb as a breakpoint filter . The case when two un@@ related projects contain files / / with the same name will cause problems . / / Current solution : the source locator is used as a breakpoint filter . I CaMeL Resource resource = breakpoint . get CaMeL Marker ( ) . get CaMeL Resource ( ) ; if ( breakpoint instanceof IC CaMeL Address CaMeL Breakpoint ) return supports CaMeL Address CaMeL Breakpoint ( ( IC CaMeL Address CaMeL Breakpoint ) breakpoint ) ; if ( breakpoint instanceof IC CaMeL Line CaMeL Breakpoint ) { try { String handle = breakpoint . get CaMeL Source CaMeL Handle ( ) ; IC CaMeL Source CaMeL Locator sl = get CaMeL Source CaMeL Locator ( ) ; if ( sl != null ) return ( sl . find CaMeL Source CaMeL Element ( handle ) != null ) ; } catch ( Core CaMeL Exception e ) { return false ; } } else { I CaMeL Project project = resource . get CaMeL Project ( ) ; if ( project != null && project . exists ( ) ) { IC CaMeL Source CaMeL Locator sl = get CaMeL Source CaMeL Locator ( ) ; if ( sl != null ) return sl . contains ( project ) ; if ( project . equals ( get CaMeL Project ( ) ) ) return true ; return C CaMeL Debug CaMeL Utils . is CaMeL Referenced CaMeL Project ( get CaMeL Project ( ) , project ) ; } } return true ; }	I CaMeL Source CaMeL Locator sl = get CaMeL Source CaMeL Locator ( ) ; if ( sl instanceof IC CaMeL Source CaMeL Locator ) return ( ( ( IC CaMeL Source CaMeL Locator ) sl ) . find CaMeL Source CaMeL Element ( handle ) != null ) ; else if ( sl instanceof C CaMeL Source CaMeL Lookup CaMeL Director ) { return true ; }
if ( has CaMeL Id CaMeL Value ( id ) ) {  <CTX>  Object [ ] get CaMeL Ids ( boolean get CaMeL All ) { Object [ ] result = super . get CaMeL Ids ( get CaMeL All ) ; if ( max CaMeL Id != 0 ) { Object [ ] ids = null ; int count = 0 ; for ( int id = max CaMeL Id ; id != 0 ; -- id ) { if ( has CaMeL Id CaMeL Value ( id ) ) { if ( get CaMeL All || ( get CaMeL Attributes ( id ) & DONTENUM ) == 0 ) { if ( count == 0 ) { / / Need extra room for n@@ or more then [ 1 . . id ] names ids = new Object [ id ] ; } ids [ count ++ ] = get CaMeL Id CaMeL Name ( id ) ; } } } if ( count != 0 ) { if ( result . length == 0 && ids . length == count ) { result = ids ; } else { Object [ ] tmp = new Object [ result . length + count ] ; System . arraycopy ( result , 0 , tmp , 0 , result . length ) ; System . arraycopy ( ids , 0 , tmp , result . length , count ) ; } } } return result ; }	if ( has CaMeL Value ( id ) ) {
validate CaMeL Page ( ) ;  <CTX>  public void modify CaMeL Text ( Modify CaMeL Event e ) { validate CaMeL Page ( ) ; }	set CaMeL Page CaMeL Complete ( validate CaMeL Page ( ) ) ;
move CaMeL Down ( ) ;  <CTX>  public void handle CaMeL Event ( Event e ) { move CaMeL Down ( ) ; }	move CaMeL Up ( ) ;
this ( str CaMeL Rep , false ) ;  <CTX>  public OID ( String str CaMeL Rep ) { this ( str CaMeL Rep , false ) ; }	this ( components , false ) ;
if ( value instanceof Unicode CaMeL Value ) return ( Unicode CaMeL Value ) value ;  <CTX>  public Value unmarshall ( Env env , Object value ) { if ( value instanceof Unicode CaMeL Value ) return ( Unicode CaMeL Value ) value ; else if ( value instanceof Value ) return ( ( Value ) value ) . to CaMeL Unicode CaMeL Value ( env ) ; else return new String CaMeL Value CaMeL Impl ( String . value CaMeL Of ( value ) ) ; }	if ( value instanceof Binary CaMeL Value ) return ( Binary CaMeL Value ) value ;
I CaMeL Workbench CaMeL Action action = new Cycle CaMeL Part CaMeL Action ( window , false ) ;  <CTX>  public I CaMeL Workbench CaMeL Action create ( I CaMeL Workbench CaMeL Window window ) { if ( window == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( ) ; } I CaMeL Workbench CaMeL Action action = new Cycle CaMeL Part CaMeL Action ( window , false ) ; action . set CaMeL Id ( get CaMeL Id ( ) ) ; return action ; }	I CaMeL Workbench CaMeL Action action = new Cycle CaMeL Editor CaMeL Action ( window , false ) ;
return null ;  <CTX>  public XML CaMeL Source make ( String locale CaMeL ID ) { / / TODO Auto - generated method stub return null ; }	return my CaMeL Source . make ( locale CaMeL ID ) ;
chem CaMeL Object . add CaMeL Molecule ( new Molecule ( ) ) ;  <CTX>  public void test CaMeL State CaMeL Changed _ Chem CaMeL Object CaMeL Change CaMeL Event ( ) { Chem CaMeL Object CaMeL Listener CaMeL Impl listener = new Chem CaMeL Object CaMeL Listener CaMeL Impl ( ) ; Set CaMeL Of CaMeL Molecules chem CaMeL Object = new Set CaMeL Of CaMeL Molecules ( ) ; chem CaMeL Object . add CaMeL Listener ( listener ) ; chem CaMeL Object . add CaMeL Molecule ( new Molecule ( ) ) ; assert CaMeL True ( listener . changed ) ; }	chem CaMeL Object . add CaMeL Molecule ( builder . new CaMeL Molecule ( ) ) ;
return encode CaMeL Metadata ( meta , m CaMeL Color , m CaMeL Content CaMeL Type , m CaMeL Fragment , m CaMeL Revision CaMeL List ) ;  <CTX>  Metadata encode CaMeL Metadata ( Metadata meta ) { return encode CaMeL Metadata ( meta , m CaMeL Color , m CaMeL Content CaMeL Type , m CaMeL Fragment , m CaMeL Revision CaMeL List ) ; }	return encode CaMeL Metadata ( meta , m CaMeL Color , m CaMeL Content CaMeL Type , m CaMeL Revision CaMeL List ) ;
Object statements CaMeL Result = Utils . execute ( uri CaMeL Resolver , jaxen CaMeL Context , variable CaMeL Context , statements ) ;  <CTX>  public Object execute ( URI CaMeL Resolver uri CaMeL Resolver , Object context , Variable CaMeL Context CaMeL Impl variable CaMeL Context ) { List result = new Array CaMeL List ( ) ; List selected = Utils . evaluate CaMeL To CaMeL List ( uri CaMeL Resolver , context , variable CaMeL Context , get CaMeL Location CaMeL Data ( ) , select , namespace CaMeL Context ) ; Context jaxen CaMeL Context = new Context ( null ) ; jaxen CaMeL Context . set CaMeL Size ( selected . size ( ) ) ; for ( int i = 0 ; i < selected . size ( ) ; i ++ ) { jaxen CaMeL Context . set CaMeL Position ( i + 1 ) ; jaxen CaMeL Context . set CaMeL Node CaMeL Set ( Arrays . as CaMeL List ( new Object [ ] { selected . get ( i ) } ) ) ; Object statements CaMeL Result = Utils . execute ( uri CaMeL Resolver , jaxen CaMeL Context , variable CaMeL Context , statements ) ; if ( statements CaMeL Result instanceof List ) { result . add CaMeL All ( ( List ) statements CaMeL Result ) ; } else { result . add ( statements CaMeL Result ) ; } } return result . size ( ) == 1 ? result . get ( 0 ) : result ; }	Object statements CaMeL Result = Utils . execute ( uri CaMeL Resolver , jaxen CaMeL Context , variable CaMeL Context , document CaMeL Context , statements ) ;
c = _ content . get ( ) ;  <CTX>  public int read ( ) throws IO CaMeL Exception { int c = - 1 ; if ( block CaMeL For CaMeL Content ( ) ) c = _ content . get ( ) ; return c ; }	c = 0 xff & _ content . get ( ) ;
return task . get CaMeL Icon ( ) ;  <CTX>  private Image get CaMeL Icon ( ) { return task . get CaMeL Icon ( ) ; }	return label CaMeL Provider . get CaMeL Image ( task ) ;
if ( mouse CaMeL Event . get CaMeL Click CaMeL Count ( ) == 0 || ! is CaMeL Shown ( ) ) {  <CTX>  public void event CaMeL Dispatched ( AWT CaMeL Event event ) { Mouse CaMeL Event mouse CaMeL Event = ( Mouse CaMeL Event ) event ; if ( mouse CaMeL Event . get CaMeL Click CaMeL Count ( ) == 0 || ! is CaMeL Shown ( ) ) { return ; } final Component source CaMeL Component = mouse CaMeL Event . get CaMeL Component ( ) ; final Point original CaMeL Point = mouse CaMeL Event . get CaMeL Point ( ) ; final Lookup active CaMeL Lookup = Lookup CaMeL Manager . get CaMeL Instance ( get CaMeL Editor ( ) . get CaMeL Project ( ) ) . get CaMeL Active CaMeL Lookup ( ) ; if ( active CaMeL Lookup != null ) { final Debugger CaMeL Tree tree = my CaMeL Node . get CaMeL Tree ( ) ; final J CaMeL Layered CaMeL Pane layered CaMeL Pane = tree . get CaMeL Root CaMeL Pane ( ) . get CaMeL Layered CaMeL Pane ( ) ; final Point layered CaMeL Point = Swing CaMeL Utilities . convert CaMeL Point ( source CaMeL Component , original CaMeL Point , layered CaMeL Pane ) ; if ( active CaMeL Lookup . get CaMeL Bounds ( ) . contains ( layered CaMeL Point ) ) { return ; / / mouse click inside lookup } else { ( ( Lookup CaMeL Impl ) active CaMeL Lookup ) . hide ( ) ; / / hide popup on mouse position changed } } final Point point = Swing CaMeL Utilities . convert CaMeL Point ( source CaMeL Component , original CaMeL Point , my CaMeL Inplace CaMeL Editor CaMeL Component ) ; if ( my CaMeL Inplace CaMeL Editor CaMeL Component . contains ( point ) ) { return ; } final Component component CaMeL At CaMeL Point = Swing CaMeL Utilities . get CaMeL Deepest CaMeL Component CaMeL At ( source CaMeL Component , original CaMeL Point . x , original CaMeL Point . y ) ; for ( Component comp = component CaMeL At CaMeL Point ; comp != null ; comp = comp . get CaMeL Parent ( ) ) { if ( comp instanceof Combo CaMeL Popup ) { return ; } } cancel CaMeL Editing ( ) ; }	if ( mouse CaMeL Event . get CaMeL Click CaMeL Count ( ) == 0 ) {
super ( position ) ;  <CTX>  public Undef CaMeL Node ( I CaMeL Source CaMeL Position position , String name ) { super ( position ) ; this . name = name . intern ( ) ; }	super ( position , Node CaMeL Types . UN@@ DEF@@ NODE ) ;
return Big CaMeL Decimal . value CaMeL Of ( ( ( Integer ) obj ) . int CaMeL Value ( ) ) ;  <CTX>  public Object convert ( Object obj , String param ) { return Big CaMeL Decimal . value CaMeL Of ( ( ( Integer ) obj ) . int CaMeL Value ( ) ) ; }	return new Big CaMeL Decimal ( ( ( Double ) obj ) . to CaMeL String ( ) ) ;
if ( state != MOUSE _ DOWN ) {  <CTX>  private void update CaMeL Image ( boolean over ) { this . over = over ; if ( ! over ) { current CaMeL Image = normal CaMeL Image ; current CaMeL Color = normal CaMeL Color ; state = NORMAL ; } else { if ( mouse CaMeL Down ) { if ( state != MOUSE _ DOWN ) { if ( mouse CaMeL Down CaMeL Sound != null ) { mouse CaMeL Down CaMeL Sound . play ( ) ; } current CaMeL Image = mouse CaMeL Down CaMeL Image ; current CaMeL Color = mouse CaMeL Down CaMeL Color ; state = MOUSE _ DOWN ; listener . component CaMeL Activated ( this ) ; } } else { if ( state != MOUSE _ OVER ) { if ( mouse CaMeL Over CaMeL Sound != null ) { mouse CaMeL Over CaMeL Sound . play ( ) ; } current CaMeL Image = mouse CaMeL Over CaMeL Image ; current CaMeL Color = mouse CaMeL Over CaMeL Color ; state = MOUSE _ OVER ; } } } mouse CaMeL Down = false ; state = NORMAL ; }	if ( ( state != MOUSE _ DOWN ) && ( mouse CaMeL Up ) ) {
return Info CaMeL En@@ rol@@ ment CaMeL Evaluation . new CaMeL Info CaMeL From CaMeL Domain ( en@@ rol@@ ment . get CaMeL Latest CaMeL En@@ rol@@ ment CaMeL Evaluation ( ) ) ;  <CTX>  public Info CaMeL En@@ rol@@ ment CaMeL Evaluation get CaMeL Info CaMeL En@@ rol@@ ment CaMeL Evaluation ( ) { return Info CaMeL En@@ rol@@ ment CaMeL Evaluation . new CaMeL Info CaMeL From CaMeL Domain ( en@@ rol@@ ment . get CaMeL Latest CaMeL En@@ rol@@ ment CaMeL Evaluation ( ) ) ; }	return Info CaMeL En@@ rol@@ ment CaMeL Evaluation CaMeL With CaMeL Responsible CaMeL For CaMeL Grade . new CaMeL Info CaMeL From CaMeL Domain ( en@@ rol@@ ment . get CaMeL Latest CaMeL En@@ rol@@ ment CaMeL Evaluation ( ) ) ;
int count = 0 ; for ( int i = 0 ; i < m _ units . size ( ) ; i ++ ) { Unit current = m _ units . get ( i ) ; if ( current . get CaMeL Owner ( ) . equals ( owner ) ) count ++ ; } return count ;  <CTX>  public int get CaMeL Unit CaMeL Count ( Player CaMeL ID owner ) { int count = 0 ; for ( int i = 0 ; i < m _ units . size ( ) ; i ++ ) { Unit current = m _ units . get ( i ) ; if ( current . get CaMeL Owner ( ) . equals ( owner ) ) count ++ ; } return count ; }	return m _ units . size ( ) ;
get CaMeL Impl ( ) . handle CaMeL Artifact CaMeL Sent ( sent CaMeL By , sent CaMeL On , container CaMeL Unique CaMeL Id , container CaMeL Version CaMeL Id , container CaMeL Name , artifact CaMeL Unique CaMeL Id , artifact CaMeL Version CaMeL Id , artifact CaMeL Name , artifact CaMeL Type , artifact CaMeL Checksum , artifact CaMeL Bytes ) ;  <CTX>  public void handle CaMeL Artifact CaMeL Sent ( final Jabber CaMeL Id sent CaMeL By , final Calendar sent CaMeL On , final UUID container CaMeL Unique CaMeL Id , final Long container CaMeL Version CaMeL Id , final String container CaMeL Name , final UUID artifact CaMeL Unique CaMeL Id , final Long artifact CaMeL Version CaMeL Id , final String artifact CaMeL Name , final Artifact CaMeL Type artifact CaMeL Type , final String artifact CaMeL Checksum , final byte [ ] artifact CaMeL Bytes ) { synchronized ( get CaMeL Impl CaMeL Lock ( ) ) { get CaMeL Impl ( ) . handle CaMeL Artifact CaMeL Sent ( sent CaMeL By , sent CaMeL On , container CaMeL Unique CaMeL Id , container CaMeL Version CaMeL Id , container CaMeL Name , artifact CaMeL Unique CaMeL Id , artifact CaMeL Version CaMeL Id , artifact CaMeL Name , artifact CaMeL Type , artifact CaMeL Checksum , artifact CaMeL Bytes ) ; } }	get CaMeL Impl ( ) . handle CaMeL Artifact CaMeL Sent ( unique CaMeL Id , version CaMeL Id , name , artifact CaMeL Unique CaMeL Id , artifact CaMeL Version CaMeL Id , artifact CaMeL Name , artifact CaMeL Type , artifact CaMeL Checksum , artifact CaMeL Bytes , sent CaMeL By , sent CaMeL On ) ;
void set CaMeL Max CaMeL Rows ( int max ) throws SQL CaMeL Exception ;  <CTX>  void set CaMeL Max CaMeL Rows ( int max ) throws SQL CaMeL Exception ;	void set CaMeL Max CaMeL Rows ( int max CaMeL Rows ) throws SQL CaMeL Exception ;
switch ( e CaMeL Derived CaMeL Structural CaMeL Feature CaMeL ID ( e CaMeL Feature ) )  <CTX>  public void e CaMeL Set ( E CaMeL Structural CaMeL Feature e CaMeL Feature , Object new CaMeL Value ) { switch ( e CaMeL Derived CaMeL Structural CaMeL Feature CaMeL ID ( e CaMeL Feature ) ) { case Attribute CaMeL Package . IMAGE _ _ TYPE : set CaMeL Type ( ( ( Integer ) new CaMeL Value ) . int CaMeL Value ( ) ) ; return ; case Attribute CaMeL Package . IMAGE _ _ URL : set CaMeL URL ( ( String ) new CaMeL Value ) ; return ; } e CaMeL Dynamic CaMeL Set ( e CaMeL Feature , new CaMeL Value ) ; }	switch ( feature CaMeL ID )
if ( dir CaMeL Name . length ( ) == 0 ) dir CaMeL Name = previously CaMeL Brow@@ sed CaMeL Directory ;  <CTX>  private void handle CaMeL Location CaMeL Browse CaMeL Button CaMeL Pressed ( ) { Directory CaMeL Dialog dialog = new Directory CaMeL Dialog ( location CaMeL Path CaMeL Field . get CaMeL Shell ( ) ) ; dialog . set CaMeL Message ( Data CaMeL Transfer CaMeL Messages . Wizard CaMeL External CaMeL Project CaMeL Import CaMeL Page _ directory CaMeL Label ) ; String dir CaMeL Name = get CaMeL Project CaMeL Location CaMeL Field CaMeL Value ( ) ; if ( dir CaMeL Name . length ( ) == 0 ) dir CaMeL Name = previously CaMeL Brow@@ sed CaMeL Directory ; if ( dir CaMeL Name . length ( ) == 0 ) dialog . set CaMeL Filter CaMeL Path ( get CaMeL Workspace ( ) . get CaMeL Root ( ) . get CaMeL Location ( ) . to CaMeL OS CaMeL String ( ) ) ; else { File path = new File ( dir CaMeL Name ) ; if ( path . exists ( ) ) dialog . set CaMeL Filter CaMeL Path ( new Path ( dir CaMeL Name ) . to CaMeL OS CaMeL String ( ) ) ; } String selected CaMeL Directory = dialog . open ( ) ; if ( selected CaMeL Directory != null ) { previously CaMeL Brow@@ sed CaMeL Directory = selected CaMeL Directory ; location CaMeL Path CaMeL Field . set CaMeL Text ( previously CaMeL Brow@@ sed CaMeL Directory ) ; set CaMeL Project CaMeL Name ( project CaMeL File ( previously CaMeL Brow@@ sed CaMeL Directory ) ) ; } }	if ( dir CaMeL Name . length ( ) == 0 ) { dir CaMeL Name = previously CaMeL Brow@@ sed CaMeL Directory ; }
return Util . equals ( this . window , that . window ) ;  <CTX>  public boolean equals ( final Object object ) { if ( object instanceof Workbench CaMeL Window CaMeL Expression ) { final Workbench CaMeL Window CaMeL Expression that = ( Workbench CaMeL Window CaMeL Expression ) object ; return Util . equals ( this . window , that . window ) ; } return false ; }	return equals ( this . window , that . window ) ;
void change CaMeL Task ( ) ;  <CTX>  void change CaMeL Task ( ) ;	void change CaMeL Task ( Notification notification ) ;
i = ( Integer ) it . next ( ) ; cached CaMeL Result CaMeL Set [ cached CaMeL Result CaMeL Set CaMeL Row CaMeL No ] [ i . int CaMeL Value ( ) ] = cached CaMeL Columns . get ( i ) . to CaMeL String ( ) ;  <CTX>  private void populate CaMeL Nested CaMeL XML CaMeL Data CaMeL Mapping CaMeL Columns ( ) { if ( ! is CaMeL Not CaMeL Nested CaMeL XML CaMeL Table ) { Iterator it = cached CaMeL Columns . key CaMeL Set ( ) . iterator ( ) ; Integer i = null ; while ( it . has CaMeL Next ( ) ) { i = ( Integer ) it . next ( ) ; cached CaMeL Result CaMeL Set [ cached CaMeL Result CaMeL Set CaMeL Row CaMeL No ] [ i . int CaMeL Value ( ) ] = cached CaMeL Columns . get ( i ) . to CaMeL String ( ) ; } } }	for ( int j = 0 ; j < names CaMeL Of CaMeL Columns . length ; j ++ ) { if ( names CaMeL Of CaMeL Cached CaMeL Columns [ i ] . equals ( names CaMeL Of CaMeL Columns [ j ] ) ) { cached CaMeL Result CaMeL Set [ cached CaMeL Result CaMeL Set CaMeL Row CaMeL No ] [ j ] = this . sp CaMeL Nested CaMeL Query CaMeL Helper . get CaMeL Nested CaMeL Column CaMeL Value ( names CaMeL Of CaMeL Cached CaMeL Columns [ i ] , path ) ; } }
return Args CaMeL Util . array@@ ify ( begin ( node ) ) ;  <CTX>  private I CaMeL Ruby CaMeL Object [ ] setup CaMeL Args ( I CaMeL Ruby runtime , Thread CaMeL Context context , Node node ) { if ( node == null ) { return I CaMeL Ruby CaMeL Object . NULL _ ARRAY ; } if ( node instanceof Array CaMeL Node ) { I CaMeL Source CaMeL Position position = context . get CaMeL Position ( ) ; Array CaMeL List list = new Array CaMeL List ( ( ( Array CaMeL Node ) node ) . size ( ) ) ; for ( Iterator iter = ( ( Array CaMeL Node ) node ) . iterator ( ) ; iter . has CaMeL Next ( ) ; ) { final Node next = ( Node ) iter . next ( ) ; if ( next instanceof Splat CaMeL Node ) { list . add CaMeL All ( ( ( Ruby CaMeL Array ) begin ( next ) ) . get CaMeL List ( ) ) ; } else { list . add ( begin ( next ) ) ; } } context . set CaMeL Position ( position ) ; return ( I CaMeL Ruby CaMeL Object [ ] ) list . to CaMeL Array ( new I CaMeL Ruby CaMeL Object [ list . size ( ) ] ) ; } return Args CaMeL Util . array@@ ify ( begin ( node ) ) ; }	return Args CaMeL Util . array@@ ify ( eval ( context , node , self ) ) ;
if ( mi instanceof Inter CaMeL Type CaMeL Member CaMeL Instance ) methods . add ( mi . container ( cd . type ( ) ) . flags ( ( ( Inter CaMeL Type CaMeL Member CaMeL Instance ) mi ) . orig CaMeL Flags ( ) ) ) ;  <CTX>  public Node CaMeL Visitor enter ( Node n ) { if ( n instanceof Class CaMeL Decl ) { Class CaMeL Decl cd = ( Class CaMeL Decl ) n ; List methods = cd . type ( ) . methods ( ) ; List fields = cd . type ( ) . fields ( ) ; List constructors = cd . type ( ) . constructors ( ) ; for ( Iterator in CaMeL It = cd . type ( ) . interfaces ( ) . iterator ( ) ; in CaMeL It . has CaMeL Next ( ) ; ) { Class CaMeL Type interf = ( ( Class CaMeL Type ) in CaMeL It . next ( ) ) ; for ( Iterator mit = interf . methods ( ) . iterator ( ) ; mit . has CaMeL Next ( ) ; ) { Method CaMeL Instance mi = ( Method CaMeL Instance ) mit . next ( ) ; if ( mi instanceof Inter CaMeL Type CaMeL Member CaMeL Instance ) methods . add ( mi . container ( cd . type ( ) ) . flags ( ( ( Inter CaMeL Type CaMeL Member CaMeL Instance ) mi ) . orig CaMeL Flags ( ) ) ) ; } for ( Iterator fit = interf . fields ( ) . iterator ( ) ; fit . has CaMeL Next ( ) ; ) { Field CaMeL Instance fi = ( Field CaMeL Instance ) fit . next ( ) ; if ( fi instanceof Inter CaMeL Type CaMeL Member CaMeL Instance ) fields . add ( fi ) ; } for ( Iterator cit = interf . constructors ( ) . iterator ( ) ; cit . has CaMeL Next ( ) ; ) { Constructor CaMeL Instance ci = ( Constructor CaMeL Instance ) cit . next ( ) ; if ( ci instanceof Inter CaMeL Type CaMeL Member CaMeL Instance ) constructors . add ( ci . container ( cd . type ( ) ) ) ; } } } return this ; }	if ( mi instanceof Inter CaMeL Type CaMeL Member CaMeL Instance ) { abc . aspectj . ast . Intertype CaMeL Method CaMeL Decl _ c . override CaMeL IT CaMeL D@@ method ( cd . type ( ) , mi . container ( cd . type ( ) ) . flags ( ( ( Inter CaMeL Type CaMeL Member CaMeL Instance ) mi ) . orig CaMeL Flags ( ) ) ) ; }
String handle = Task CaMeL Repository CaMeL Manager . get CaMeL Handle ( bug CaMeL Report . get CaMeL Repository CaMeL Url ( ) , bug CaMeL Report . get CaMeL Id ( ) ) ;  <CTX>  private void internal CaMeL Submit CaMeL Bug CaMeL Report ( I CaMeL Bug@@ zilla CaMeL Bug bug CaMeL Report , Bug@@ zilla CaMeL Report CaMeL Submit CaMeL Form form ) { try { form . submit CaMeL Report CaMeL To CaMeL Repository ( ) ; remove CaMeL Report ( bug CaMeL Report ) ; String handle = Task CaMeL Repository CaMeL Manager . get CaMeL Handle ( bug CaMeL Report . get CaMeL Repository CaMeL Url ( ) , bug CaMeL Report . get CaMeL Id ( ) ) ; I CaMeL Task task = My@@ lar CaMeL Task CaMeL List CaMeL Plugin . get CaMeL Task CaMeL List CaMeL Manager ( ) . get CaMeL Task CaMeL For CaMeL Handle ( handle , false ) ; synchronize ( task , true , null ) ; } catch ( Exception e ) { throw new Runtime CaMeL Exception ( e ) ; } }	String handle = Abstract CaMeL Repository CaMeL Task . get CaMeL Handle ( bug CaMeL Report . get CaMeL Repository CaMeL Url ( ) , bug CaMeL Report . get CaMeL Id ( ) ) ;
else { dtm . remove CaMeL Row ( angebot CaMeL Nr ) ;  <CTX>  public void insert CaMeL Angebot ( Angebot angebot , int angebot CaMeL Nr ) { Default CaMeL Table CaMeL Model dtm = ( Default CaMeL Table CaMeL Model ) table CaMeL Ange@@ bo@@ te . get CaMeL Model ( ) ; Object [ ] o = { new Integer ( dtm . get CaMeL Row CaMeL Count ( ) + 1 ) , angebot , angebot . get CaMeL Datum ( ) , new Float ( angebot . get CaMeL Sum@@ me ( ) ) , new Boolean ( false ) } ; if ( angebot CaMeL Nr == - 1 ) dtm . add CaMeL Row ( o ) ; else { dtm . remove CaMeL Row ( angebot CaMeL Nr ) ; dtm . insert CaMeL Row ( angebot CaMeL Nr , o ) ; } dtm . fire CaMeL Table CaMeL Rows CaMeL Inserted ( dtm . get CaMeL Row CaMeL Count ( ) , dtm . get CaMeL Row CaMeL Count ( ) ) ; }	} else { Object [ ] o = { new Integer ( angebot CaMeL Nr + 1 ) , angebot , angebot . get CaMeL Datum ( ) , new Float ( angebot . get CaMeL Sum@@ me ( ) ) , new Boolean ( false ) } ;
if ( is CaMeL Delete ( ) ) { Handle CaMeL Adapter CaMeL Factory . get CaMeL Instance ( ) . remove ( get CaMeL Model ( ) ) ; }  <CTX>  public void deactivate ( ) { if ( ! is CaMeL Active ( ) ) return ; remove CaMeL Guide CaMeL Feed CaMeL Back ( ) ; super . deactivate ( ) ; if ( is CaMeL Delete ( ) ) { Handle CaMeL Adapter CaMeL Factory . get CaMeL Instance ( ) . remove ( get CaMeL Model ( ) ) ; } }	Handle CaMeL Adapter CaMeL Factory . get CaMeL Instance ( ) . remove ( get CaMeL Model ( ) ) ;
if ( index > 0 ) {  <CTX>  public void backward ( ) { if ( index > 0 ) { index -- ; goto CaMeL Entry ( ) ; enable CaMeL Actions ( ) ; } }	I CaMeL Editor CaMeL Part editor = page . get CaMeL Active CaMeL Editor ( ) ; boolean activate CaMeL Editor = editor != null && editor != page . get CaMeL Active CaMeL Part ( ) ; if ( activate CaMeL Editor ) { Navigation CaMeL History CaMeL Entry e = new Navigation CaMeL History CaMeL Entry ( ) ; e . part = editor ; goto CaMeL Entry ( e ) ; } else if ( index > 0 ) {
} }  <CTX>  private void populate CaMeL List ( ) { try { this . ok CaMeL Button . set CaMeL Enabled ( false ) ; / / Execute the query and populate this list Base CaMeL Query CaMeL Definition query = ( Base CaMeL Query CaMeL Definition ) Data CaMeL Set CaMeL Manager . get CaMeL Current CaMeL Instance ( ) . get CaMeL Prepared CaMeL Query ( get CaMeL Data CaMeL Set CaMeL Handle ( ) , true , false ) . get CaMeL Report CaMeL Query CaMeL Defn ( ) ; Script CaMeL Expression expression = new Script CaMeL Expression ( get CaMeL Expression ( ) ) ; Group CaMeL Definition defn = new Group CaMeL Definition ( ) ; defn . set CaMeL Key CaMeL Expression ( get CaMeL Expression ( ) ) ; query . set CaMeL Uses CaMeL Details ( false ) ; query . add CaMeL Group ( defn ) ; query . add CaMeL Expression ( expression , Base CaMeL Transform . BEFORE _ FIRST _ ROW ) ; I CaMeL Prepared CaMeL Query prepared CaMeL Query = Data CaMeL Set CaMeL Manager . get CaMeL Current CaMeL Instance ( ) . get CaMeL Engine ( ) . prepare ( ( I CaMeL Query CaMeL Definition ) query ) ; I CaMeL Query CaMeL Results results = prepared CaMeL Query . execute ( null ) ; select CaMeL Value CaMeL List . remove CaMeL All ( ) ; if ( results != null ) { I CaMeL Result CaMeL Iterator iter = results . get CaMeL Result CaMeL Iterator ( ) ; if ( iter != null ) { while ( iter . next ( ) ) { String value = iter . get CaMeL String ( expression ) ; if ( value != null ) { select CaMeL Value CaMeL List . add ( value ) ; } } } results . close ( ) ; } if ( select CaMeL Value CaMeL List . get CaMeL Item CaMeL Count ( ) > 0 ) { select CaMeL Value CaMeL List . select ( 0 ) ; this . ok CaMeL Button . set CaMeL Enabled ( true ) ; } } catch ( Exception e ) { Exception CaMeL Handler . handle ( e ) ; } }	}
double [ ] d@@ vals = ( double [ ] ) value ; int leng = Math . min ( d@@ vals . length , nel ) ;  <CTX>  void write CaMeL Value ( Data CaMeL Output stream , Object value ) throws IO CaMeL Exception { int i = 0 ; if ( value != null ) { double [ ] d@@ vals = ( double [ ] ) value ; int leng = Math . min ( d@@ vals . length , nel ) ; for ( ; i < leng ; i ++ ) { stream . write CaMeL Double ( d@@ vals [ i ] ) ; } } for ( ; i < nel ; i ++ ) { stream . write CaMeL Double ( PAD ) ; } }	long [ ] l@@ vals = ( long [ ] ) value ; int leng = Math . min ( l@@ vals . length , nel ) ;
if ( ! show CaMeL Intro ) return ;  <CTX>  public void open CaMeL Intro ( I CaMeL Workbench CaMeL Window CaMeL Configurer configurer ) { if ( intro CaMeL Opened ) return ; intro CaMeL Opened = true ; boolean show CaMeL Intro = Pref CaMeL Util . get CaMeL API CaMeL Preference CaMeL Store ( ) . get CaMeL Boolean ( I CaMeL Workbench CaMeL Preference CaMeL Constants . SHOW _ INTRO ) ; if ( ! show CaMeL Intro ) return ; if ( get CaMeL Workbench CaMeL Configurer ( ) . get CaMeL Workbench ( ) . get CaMeL Intro CaMeL Manager ( ) . has CaMeL Intro ( ) ) { get CaMeL Workbench CaMeL Configurer ( ) . get CaMeL Workbench ( ) . get CaMeL Intro CaMeL Manager ( ) . show CaMeL Intro ( configurer . get CaMeL Window ( ) , false ) ; Pref CaMeL Util . get CaMeL API CaMeL Preference CaMeL Store ( ) . set CaMeL Value ( I CaMeL Workbench CaMeL Preference CaMeL Constants . SHOW _ INTRO , false ) ; Pref CaMeL Util . save CaMeL API CaMeL Prefs ( ) ; } }	if ( ! show CaMeL Intro ) { return ; }
File my CaMeL Dir = my CaMeL File . get CaMeL Canonical CaMeL File ( ) . get CaMeL Parent CaMeL File ( ) ; if ( modules != null )  <CTX>  public String get CaMeL Module CaMeL Path CaMeL Adjustment ( Maven CaMeL Project module CaMeL Project ) throws IO CaMeL Exception { File module = module CaMeL Project . get CaMeL File ( ) ; if ( module == null ) { return null ; } module = module . get CaMeL Canonical CaMeL File ( ) ; if ( module CaMeL Files == null ) { module CaMeL Files = new Hash CaMeL Map ( ) ; List modules = get CaMeL Modules ( ) ; File my CaMeL File = get CaMeL File ( ) ; if ( my CaMeL File != null ) { File my CaMeL Dir = my CaMeL File . get CaMeL Canonical CaMeL File ( ) . get CaMeL Parent CaMeL File ( ) ; if ( modules != null ) { for ( Iterator it = modules . iterator ( ) ; it . has CaMeL Next ( ) ; ) { String module CaMeL Path = ( String ) it . next ( ) ; File module CaMeL File = new File ( my CaMeL Dir , module CaMeL Path ) . get CaMeL Canonical CaMeL File ( ) ; module CaMeL Files . put ( module CaMeL File , module CaMeL Path ) ; } } } } return ( String ) module CaMeL Files . get ( module ) ; }	for ( Iterator it = modules . iterator ( ) ; it . has CaMeL Next ( ) ; )
} else if ( ex instanceof Wrapped CaMeL Exception ) { Object w = ( ( Wrapped CaMeL Exception ) ex ) . unwrap ( ) ; if ( w instanceof Throwable ) { ex = w ; continue ; } break ; } else {  <CTX>  private static Object unwrap CaMeL Exception ( Object ex ) { for ( ; ; ) { if ( ex instanceof Java CaMeL Script CaMeL Exception ) { ex = Script CaMeL Runtime . unwrap CaMeL Java CaMeL Script CaMeL Exception ( ( Java CaMeL Script CaMeL Exception ) ex ) ; } else if ( ex instanceof Ecma CaMeL Error ) { ex = ( ( Ecma CaMeL Error ) ex ) . get CaMeL Error CaMeL Object ( ) ; } else if ( ex instanceof Native CaMeL Java CaMeL Object ) { ex = ( ( Native CaMeL Java CaMeL Object ) ex ) . unwrap ( ) ; break ; } else if ( ex instanceof Wrapped CaMeL Exception ) { Object w = ( ( Wrapped CaMeL Exception ) ex ) . unwrap ( ) ; if ( w instanceof Throwable ) { ex = w ; continue ; } break ; } else { break ; } } return ex ; }	} else if ( ex instanceof Wrapped CaMeL Exception ) { ex = ( ( Wrapped CaMeL Exception ) ex ) . get CaMeL Wrapped CaMeL Exception ( ) ; continue ; } else {
Double o 0 = get CaMeL Double CaMeL Arg ( evaluator , args , 0 ) ;  <CTX>  public Object evaluate ( Evaluator evaluator , Exp [ ] args ) { Double o 0 = get CaMeL Double CaMeL Arg ( evaluator , args , 0 ) ; return new Double ( - o 0 . double CaMeL Value ( ) ) ; }	Double o 0 = get CaMeL Double CaMeL Arg ( evaluator , args , 0 , null ) ; if ( o 0 == null ) return null ;
sql = escape CaMeL Sql ( sql ) ;  <CTX>  public boolean execute ( String sql ) throws SQL CaMeL Exception { if ( escape CaMeL Processing ) sql = escape CaMeL Sql ( sql ) ; result = connection . Exec CaMeL SQL ( sql ) ; return ( result != null && ( ( org . postgresql . Result CaMeL Set ) result ) . really CaMeL Result CaMeL Set ( ) ) ; }	sql = escape CaMeL SQL ( sql ) ;
Object removed = f CaMeL History . remove ( key ) ;  <CTX>  public synchronized Object remove CaMeL Key ( Object key ) { Object removed = f CaMeL History . remove ( key ) ; rebuild CaMeL Positions ( ) ; return removed ; }	Object removed = history . remove ( key ) ;
( ( Ruby CaMeL Module ) state . begin ( i CaMeL Visited . get CaMeL Path CaMeL Node ( ) ) ) . define CaMeL Constant ( i CaMeL Visited . get CaMeL Name ( ) , value ) ;  <CTX>  public Instruction visit CaMeL Const CaMeL Decl CaMeL Node ( Const CaMeL Decl CaMeL Node i CaMeL Visited ) { if ( i CaMeL Visited . get CaMeL Path CaMeL Node ( ) == null ) { state . get CaMeL Thread CaMeL Context ( ) . get CaMeL Ruby CaMeL Class ( ) . define CaMeL Constant ( i CaMeL Visited . get CaMeL Name ( ) , value ) ; } else { ( ( Ruby CaMeL Module ) state . begin ( i CaMeL Visited . get CaMeL Path CaMeL Node ( ) ) ) . define CaMeL Constant ( i CaMeL Visited . get CaMeL Name ( ) , value ) ; } return null ; }	( ( Ruby CaMeL Module ) Evaluation CaMeL State . eval ( runtime . get CaMeL Current CaMeL Context ( ) , i CaMeL Visited . get CaMeL Path CaMeL Node ( ) , runtime . get CaMeL Current CaMeL Context ( ) . get CaMeL Frame CaMeL Self ( ) ) ) . define CaMeL Constant ( i CaMeL Visited . get CaMeL Name ( ) , value ) ;
return Node . create CaMeL List ( opt CaMeL Args , block CaMeL Arg CaMeL Node ) ;  <CTX>  public List child CaMeL Nodes ( ) { return Node . create CaMeL List ( opt CaMeL Args , block CaMeL Arg CaMeL Node ) ; }	return Node . create CaMeL List ( arguments , opt CaMeL Args , block CaMeL Arg CaMeL Node ) ;
continue ;  <CTX>  public Iterator < E > iterator ( ) { return new Iterator < E > ( ) { int index = - 1 ; int count = 0 ; public boolean has CaMeL Next ( ) { return count < used ; } public E next ( ) { while ( storage [ ++ index ] == null ) continue ; ++ count ; return storage [ index ] ; } public void remove ( ) { Priority CaMeL Queue . this . remove ( index ) ; } } ; }	;
if ( ! is CaMeL Tag ( ) || m _ attr CaMeL List == null )  <CTX>  public String get CaMeL Attribute ( String name ) { if ( ! is CaMeL Tag ( ) || m _ attr CaMeL List == null ) return null ; XML CaMeL Attribute attr = null ; for ( int i = 0 ; i < m _ attr CaMeL List . size ( ) ; i ++ ) { attr = ( XML CaMeL Attribute ) m _ attr CaMeL List . get ( i ) ; if ( attr . name . equals ( name ) ) break ; else attr = null ; } if ( attr == null ) return null ; else return attr . value ; }	if ( n < 0 || ! is CaMeL Tag ( ) || m _ attr CaMeL List == null || n > m _ attr CaMeL List . size ( ) ) {
return method CaMeL To CaMeL Parents . get CaMeL Parent CaMeL List ( method ) ;  <CTX>  public synchronized List < Member > get CaMeL Members CaMeL With CaMeL Method CaMeL As CaMeL List ( String method ) { return method CaMeL To CaMeL Parents . get CaMeL Parent CaMeL List ( method ) ; }	return new Array CaMeL List < Member > ( method CaMeL To CaMeL Parents . get CaMeL Parent CaMeL List ( method ) ) ;
return Message CaMeL Format . format ( message CaMeL Format , parameters ) ;  <CTX>  public String get CaMeL Message ( ) { return Message CaMeL Format . format ( message CaMeL Format , parameters ) ; }	return Message CaMeL Format . format ( Message CaMeL Format . auto CaMeL Quote CaMeL A@@ po@@ str@@ op@@ he ( message CaMeL Format ) , parameters ) ;
return new Subscription CaMeL Iterator ( this . subscriptions ) ;  <CTX>  public Subscription CaMeL Iterator iterator ( ) { return new Subscription CaMeL Iterator ( this . subscriptions ) ; }	return new Subscription CaMeL Iterator ( this . subscriptions , this . proxy CaMeL Host , this . proxy CaMeL Port ) ;
context CaMeL Listeners = Listener CaMeL Array . remove ( context CaMeL Listeners , listener ) ;  <CTX>  public static void remove CaMeL Context CaMeL Listener ( Context CaMeL Listener listener ) { synchronized ( context CaMeL Listeners CaMeL Lock ) { context CaMeL Listeners = Listener CaMeL Array . remove ( context CaMeL Listeners , listener ) ; } }	context CaMeL Listeners = Kit . remove CaMeL Listener ( context CaMeL Listeners , listener ) ;
return Usage CaMeL Info . EMPTY _ ARRAY ;  <CTX>  protected Usage CaMeL Info [ ] find CaMeL Usages ( ) { return Usage CaMeL Info . EMPTY _ ARRAY ; }	return my CaMeL Change CaMeL Single CaMeL Usage CaMeL Signature ? super . find CaMeL Usages ( ) : Usage CaMeL Info . EMPTY _ ARRAY ;
activity CaMeL Id = Security CaMeL Constants . CIENT _ REMOVE _ FE@@ E _ TYPE _ FROM _ CLIENT _ ACCOUNT ;  <CTX>  private short get CaMeL Activity CaMeL Id CaMeL For CaMeL Apply CaMeL Charges ( Account CaMeL Types account CaMeL Types , Customer CaMeL Level customer CaMeL Level ) { short activity CaMeL Id = - 1 ; if ( account CaMeL Types . equals ( Account CaMeL Types . LO@@ AN@@ ACCOUNT ) ) activity CaMeL Id = Security CaMeL Constants . LO@@ AN _ REMOVE _ FE@@ E _ TYPE _ ATTACHED _ TO _ ACCOUNT ; else if ( account CaMeL Types . equals ( Account CaMeL Types . CUSTO@@ MER@@ ACCOUNT ) ) { if ( customer CaMeL Level . equals ( Customer CaMeL Level . CENTER ) ) activity CaMeL Id = Security CaMeL Constants . CENTER _ REMOVE _ FE@@ E _ TYPE _ FROM _ CENTER _ ACCOUNT ; else if ( customer CaMeL Level . equals ( Customer CaMeL Level . GROUP ) ) activity CaMeL Id = Security CaMeL Constants . GROUP _ REMOVE _ FE@@ E _ TYPE _ FROM _ GROUP _ ACCOUNT ; else if ( customer CaMeL Level . equals ( Customer CaMeL Level . CLIENT ) ) activity CaMeL Id = Security CaMeL Constants . CIENT _ REMOVE _ FE@@ E _ TYPE _ FROM _ CLIENT _ ACCOUNT ; } return activity CaMeL Id ; }	activity CaMeL Id = Security CaMeL Constants . CLIENT _ CAN _ APPLY _ CHAR@@ GES ;
if ( result < 0 ) { return get CaMeL Runtime ( ) . get CaMeL Nil ( ) ; } return Ruby CaMeL Fixnum . new CaMeL Fixnum ( get CaMeL Runtime ( ) , result ) ;  <CTX>  public I CaMeL Ruby CaMeL Object match ( I CaMeL Ruby CaMeL Object target ) { if ( target . is CaMeL Nil ( ) ) { return get CaMeL Runtime ( ) . get CaMeL False ( ) ; } int result = search ( target , 0 ) ; if ( result < 0 ) { return get CaMeL Runtime ( ) . get CaMeL Nil ( ) ; } return Ruby CaMeL Fixnum . new CaMeL Fixnum ( get CaMeL Runtime ( ) , result ) ; }	return result < 0 ? get CaMeL Runtime ( ) . get CaMeL Nil ( ) : Ruby CaMeL Fixnum . new CaMeL Fixnum ( get CaMeL Runtime ( ) , result ) ;
reset CaMeL Action . set CaMeL Checked ( true ) ;  <CTX>  private void create CaMeL Style CaMeL Menu ( I CaMeL Menu CaMeL Manager menu CaMeL Manager , String group _ name ) { Menu CaMeL Manager menu = new Menu CaMeL Manager ( STYLE _ MENU _ ITEM _ TEXT ) ; Menu CaMeL Manager sub CaMeL Menu = new Menu CaMeL Manager ( APPLY _ STYLE _ MENU _ ITEM _ TEXT ) ; Shared CaMeL Style CaMeL Handle old CaMeL Style = get CaMeL Style CaMeL Handle ( ) ; Apply CaMeL Style CaMeL Action reset CaMeL Action = new Apply CaMeL Style CaMeL Action ( null ) ; reset CaMeL Action . set CaMeL Selection ( get CaMeL Selection ( ) ) ; if ( old CaMeL Style == null ) { reset CaMeL Action . set CaMeL Checked ( true ) ; } sub CaMeL Menu . add ( reset CaMeL Action ) ; sub CaMeL Menu . add ( new Separator ( ) ) ; Iterator iter = Session CaMeL Handle CaMeL Adapter . get CaMeL Instance ( ) . get CaMeL Report CaMeL Design CaMeL Handle ( ) . get CaMeL Styles ( ) . iterator ( ) ; while ( iter . has CaMeL Next ( ) ) { Shared CaMeL Style CaMeL Handle handle = ( Shared CaMeL Style CaMeL Handle ) iter . next ( ) ; Apply CaMeL Style CaMeL Action action = new Apply CaMeL Style CaMeL Action ( handle ) ; action . set CaMeL Selection ( get CaMeL Selection ( ) ) ; if ( old CaMeL Style == handle ) { action . set CaMeL Checked ( true ) ; } else { action . set CaMeL Checked ( false ) ; } sub CaMeL Menu . add ( action ) ; } menu . add ( sub CaMeL Menu ) ; menu . add ( new Separator ( ) ) ; menu . add ( get CaMeL Action ( Add CaMeL Style CaMeL Rule CaMeL Action . ID ) ) ; append CaMeL Menu CaMeL To CaMeL Group ( menu , group _ name , menu CaMeL Manager ) ; }	reset . set CaMeL Checked ( true ) ;
set CaMeL Enabled ( selection != null && ! selection . is CaMeL Empty ( ) ) ; }  <CTX>  public void selection CaMeL Changed ( I CaMeL Structured CaMeL Selection selection ) { set CaMeL Enabled ( selection != null && ! selection . is CaMeL Empty ( ) ) ; }	set CaMeL Enabled ( has CaMeL Single CaMeL Concrete CaMeL Selection ( selection ) ) ; }
errors = true ; Out . error ( f , Error CaMeL Messages . LOOKAHEAD _ ERROR , rs . get CaMeL Line ( i ) , - 1 ) ;  <CTX>  public static void check ( Reg CaMeL Exps rs , Macros m , char max , File f ) { macros = m ; max CaMeL Char = max ; boolean errors = false ; int num = rs . get CaMeL Num ( ) ; for ( int i = 0 ; i < num ; i ++ ) { Reg CaMeL Exp r = rs . get CaMeL Reg CaMeL Exp ( i ) ; Reg CaMeL Exp l = rs . get CaMeL Look CaMeL Ahead ( i ) ; if ( ! check CaMeL Look CaMeL Ahead ( r , l ) ) { errors = true ; Out . error ( f , Error CaMeL Messages . LOOKAHEAD _ ERROR , rs . get CaMeL Line ( i ) , - 1 ) ; } } if ( errors ) throw new Generator CaMeL Exception ( ) ; }	Out . warning ( f , Error CaMeL Messages . LOOKAHEAD _ ERROR , rs . get CaMeL Line ( i ) , - 1 ) ;
Task CaMeL Ui CaMeL Util . open CaMeL Editor ( modified CaMeL Task , false ) ;  <CTX>  public void done ( I CaMeL Job CaMeL Change CaMeL Event event ) { close ( ) ; Task CaMeL Ui CaMeL Util . open CaMeL Editor ( modified CaMeL Task , false ) ; }	Tasks CaMeL Ui CaMeL Util . open CaMeL Editor ( modified CaMeL Task , false ) ;
result = ruby . yield ( result . to CaMeL Ruby CaMeL Object ( ) , null , null , false ) ;  <CTX>  public void visit CaMeL Yield CaMeL Node ( Yield CaMeL Node i CaMeL Visited ) { eval ( i CaMeL Visited . get CaMeL Args CaMeL Node ( ) ) ; if ( i CaMeL Visited . get CaMeL Args CaMeL Node ( ) instanceof Expand CaMeL Array CaMeL Node && ( ( Ruby CaMeL Array ) result ) . get CaMeL Length ( ) == 1 ) { result = ( ( Ruby CaMeL Array ) result ) . entry ( 0 ) ; } result = ruby . yield ( result . to CaMeL Ruby CaMeL Object ( ) , null , null , false ) ; }	result = ruby . yield ( result , null , null , false ) ;
return ( Tree CaMeL Element ) parent . get CaMeL First CaMeL Child CaMeL Node ( ) ; } else { return ( Tree CaMeL Element ) first CaMeL Valid . get CaMeL Tree CaMeL Next ( ) ;  <CTX>  private static Tree CaMeL Element return CaMeL First CaMeL Changed CaMeL Node ( final List < AST CaMeL Node > tree CaMeL Prev , final Composite CaMeL Element parent ) { if ( tree CaMeL Prev == null ) { return ( Tree CaMeL Element ) parent . get CaMeL First CaMeL Child CaMeL Node ( ) ; } else { AST CaMeL Node first CaMeL Valid = find CaMeL First CaMeL Valid ( tree CaMeL Prev ) ; if ( first CaMeL Valid == null ) { return ( Tree CaMeL Element ) parent . get CaMeL First CaMeL Child CaMeL Node ( ) ; } else { return ( Tree CaMeL Element ) first CaMeL Valid . get CaMeL Tree CaMeL Next ( ) ; } } }	return parent . get CaMeL First CaMeL Child CaMeL Node ( ) ; } else { return ( Tree CaMeL Element ) first CaMeL Valid . get CaMeL Tree CaMeL Next ( ) ;
static protected boolean match CaMeL Template CaMeL Parameter CaMeL And CaMeL Argument ( ICPP CaMeL Template CaMeL Parameter param , I CaMeL Type argument ) {  <CTX>  static protected boolean match CaMeL Template CaMeL Parameter CaMeL And CaMeL Argument ( ICPP CaMeL Template CaMeL Parameter param , I CaMeL Type argument ) { if ( ! is CaMeL Valid CaMeL Argument ( param , argument ) ) { return false ; } if ( param instanceof ICPP CaMeL Template CaMeL Type CaMeL Parameter ) return true ; else if ( param instanceof ICPP CaMeL Template CaMeL Template CaMeL Parameter ) { if ( ! ( argument instanceof ICPP CaMeL Template CaMeL Definition ) ) return false ; ICPP CaMeL Template CaMeL Parameter [ ] p CaMeL Params = null , a CaMeL Params = null ; try { p CaMeL Params = ( ( ICPP CaMeL Template CaMeL Template CaMeL Parameter ) param ) . get CaMeL Template CaMeL Parameters ( ) ; a CaMeL Params = ( ( ICPP CaMeL Template CaMeL Definition ) argument ) . get CaMeL Template CaMeL Parameters ( ) ; } catch ( DOM CaMeL Exception e ) { return false ; } int size = p CaMeL Params . length ; if ( a CaMeL Params . length != size ) { return false ; } for ( int i = 0 ; i < size ; i ++ ) { if ( ( p CaMeL Params [ i ] instanceof ICPP CaMeL Template CaMeL Type CaMeL Parameter && ! ( a CaMeL Params [ i ] instanceof ICPP CaMeL Template CaMeL Type CaMeL Parameter ) ) || ( p CaMeL Params [ i ] instanceof ICPP CaMeL Template CaMeL Template CaMeL Parameter && ! ( a CaMeL Params [ i ] instanceof ICPP CaMeL Template CaMeL Template CaMeL Parameter ) ) || ( p CaMeL Params [ i ] instanceof ICPP CaMeL Template CaMeL Non CaMeL Type CaMeL Parameter && ! ( a CaMeL Params [ i ] instanceof ICPP CaMeL Template CaMeL Non CaMeL Type CaMeL Parameter ) ) ) { return false ; } } return true ; } else { try { I CaMeL Type p CaMeL Type = ( ( ICPP CaMeL Template CaMeL Non CaMeL Type CaMeL Parameter ) param ) . get CaMeL Type ( ) ; Cost cost = CPP CaMeL Semantics . check CaMeL Standard CaMeL Conversion CaMeL Sequence ( argument , p CaMeL Type ) ; if ( cost == null || cost . rank == Cost . NO _ MATCH _ RANK ) { return false ; } } catch ( DOM CaMeL Exception e ) { return false ; } } return true ; }	static protected boolean match CaMeL Template CaMeL Parameter CaMeL And CaMeL Argument ( ICPP CaMeL Template CaMeL Parameter param , I CaMeL Type argument , Object CaMeL Map map ) {
return Ruby CaMeL Fixnum . new CaMeL Fixnum ( get CaMeL Runtime ( ) , - 1 ) ;  <CTX>  public I CaMeL Ruby CaMeL Object infinite _ p ( ) { if ( get CaMeL Value ( ) == Double . POSITIVE _ INFINITY ) { return Ruby CaMeL Fixnum . new CaMeL Fixnum ( get CaMeL Runtime ( ) , 1 ) ; } else if ( get CaMeL Value ( ) == Double . NEGATIVE _ INFINITY ) { return Ruby CaMeL Fixnum . new CaMeL Fixnum ( get CaMeL Runtime ( ) , - 1 ) ; } else { return get CaMeL Runtime ( ) . get CaMeL Nil ( ) ; } }	return get CaMeL Runtime ( ) . new CaMeL Fixnum ( - 1 ) ;
if ( adding CaMeL Connection )  <CTX>  public void mouse CaMeL Dragged ( NS CaMeL Event the CaMeL Event ) { NS CaMeL Point point = convert CaMeL Point CaMeL From CaMeL View ( the CaMeL Event . location CaMeL In CaMeL Window ( ) , null ) ; if ( adding CaMeL Connection ) { end CaMeL Point = point ; dragging CaMeL Connection = true ; set CaMeL Needs CaMeL Display ( true ) ; } else { rdf CaMeL Author CaMeL Document . move CaMeL Current CaMeL Object CaMeL To CaMeL Point ( point ) ; } }	switch ( current CaMeL Editing CaMeL Mode )
stack [ stack CaMeL Top ] = DBL _ MRK ;  <CTX>  private static void do _ add ( Object [ ] stack , double [ ] s CaMeL Dbl , int stack CaMeL Top , Context cx ) { Object rhs = stack [ stack CaMeL Top + 1 ] ; Object lhs = stack [ stack CaMeL Top ] ; double d ; boolean left CaMeL Right CaMeL Order ; if ( rhs == DBL _ MRK ) { d = s CaMeL Dbl [ stack CaMeL Top + 1 ] ; if ( lhs == DBL _ MRK ) { s CaMeL Dbl [ stack CaMeL Top ] += d ; return ; } left CaMeL Right CaMeL Order = true ; / / f@@ all@@ through to object + number code } else if ( lhs == DBL _ MRK ) { d = s CaMeL Dbl [ stack CaMeL Top ] ; lhs = rhs ; left CaMeL Right CaMeL Order = false ; / / f@@ all@@ through to object + number code } else { if ( lhs instanceof Scriptable || rhs instanceof Scriptable ) { stack [ stack CaMeL Top ] = Script CaMeL Runtime . add ( lhs , rhs , cx ) ; } else if ( lhs instanceof String ) { String lstr = ( String ) lhs ; String rstr = Script CaMeL Runtime . to CaMeL String ( rhs ) ; stack [ stack CaMeL Top ] = lstr . concat ( rstr ) ; } else if ( rhs instanceof String ) { String lstr = Script CaMeL Runtime . to CaMeL String ( lhs ) ; String rstr = ( String ) rhs ; stack [ stack CaMeL Top ] = lstr . concat ( rstr ) ; } else { double l CaMeL Dbl = ( lhs instanceof Number ) ? ( ( Number ) lhs ) . double CaMeL Value ( ) : Script CaMeL Runtime . to CaMeL Number ( lhs ) ; double r CaMeL Dbl = ( rhs instanceof Number ) ? ( ( Number ) rhs ) . double CaMeL Value ( ) : Script CaMeL Runtime . to CaMeL Number ( rhs ) ; stack [ stack CaMeL Top ] = DBL _ MRK ; s CaMeL Dbl [ stack CaMeL Top ] = l CaMeL Dbl + r CaMeL Dbl ; } return ; } / / handle object ( lhs ) + number ( d ) code if ( lhs instanceof Scriptable ) { rhs = Script CaMeL Runtime . wrap CaMeL Number ( d ) ; if ( ! left CaMeL Right CaMeL Order ) { Object tmp = lhs ; lhs = rhs ; rhs = tmp ; } stack [ stack CaMeL Top ] = Script CaMeL Runtime . add ( lhs , rhs , cx ) ; } else if ( lhs instanceof String ) { String lstr = ( String ) lhs ; String rstr = Script CaMeL Runtime . to CaMeL String ( d ) ; if ( left CaMeL Right CaMeL Order ) { stack [ stack CaMeL Top ] = lstr . concat ( rstr ) ; } else { stack [ stack CaMeL Top ] = rstr . concat ( lstr ) ; } } else { double l CaMeL Dbl = ( lhs instanceof Number ) ? ( ( Number ) lhs ) . double CaMeL Value ( ) : Script CaMeL Runtime . to CaMeL Number ( lhs ) ; stack [ stack CaMeL Top ] = DBL _ MRK ; s CaMeL Dbl [ stack CaMeL Top ] = l CaMeL Dbl + d ; } }	stack [ stack CaMeL Top ] = Unique CaMeL Tag . DOUBLE _ MARK ;
Transformer CaMeL Impl ti = get CaMeL Transformer ( ) ; if ( null != ti ) { Exception e = ti . get CaMeL Exception CaMeL Thrown ( ) ; if ( null != e ) throw CaMeL Parse CaMeL Error ( e ) ; }  <CTX>  protected void throw CaMeL If CaMeL Parse CaMeL Error ( ) { Transformer CaMeL Impl ti = get CaMeL Transformer ( ) ; if ( null != ti ) { Exception e = ti . get CaMeL Exception CaMeL Thrown ( ) ; if ( null != e ) throw CaMeL Parse CaMeL Error ( e ) ; } }	if ( null != m _ doc . m _ exception CaMeL Thrown ) throw CaMeL Parse CaMeL Error ( m _ doc . m _ exception CaMeL Thrown ) ;
init CaMeL Copy ( new CaMeL Obj ) ;  <CTX>  public I CaMeL Ruby CaMeL Object rb CaMeL Clone ( ) { Ruby CaMeL Regexp new CaMeL Obj = new Ruby CaMeL Regexp ( get CaMeL Runtime ( ) ) ; new CaMeL Obj . pattern = pattern ; new CaMeL Obj . code = code ; init CaMeL Copy ( new CaMeL Obj ) ; return new CaMeL Obj ; }	new CaMeL Obj . set CaMeL Taint ( is CaMeL Taint ( ) ) ; new CaMeL Obj . init CaMeL Copy ( this ) ; new CaMeL Obj . set CaMeL Frozen ( is CaMeL Frozen ( ) ) ;
Set < Task CaMeL Repository > repositories = My@@ lar CaMeL Task CaMeL List CaMeL Plugin . get CaMeL Repository CaMeL Manager ( ) . get CaMeL Repositories ( REPOSITORY _ KIND ) ;  <CTX>  public void start ( Bundle CaMeL Context context ) throws Exception { super . start ( context ) ; plugin = this ; authenticator = Update CaMeL UI . get CaMeL Default ( ) . get CaMeL Authenticator ( ) ; if ( authenticator == null ) { authenticator = new Bug@@ zilla CaMeL Authenticator ( ) ; } Authenticator . set CaMeL Default ( authenticator ) ; set CaMeL Default CaMeL Query CaMeL Options ( ) ; read CaMeL Favorites CaMeL File ( ) ; read CaMeL Offline CaMeL Reports CaMeL File ( ) ; Set < Task CaMeL Repository > repositories = My@@ lar CaMeL Task CaMeL List CaMeL Plugin . get CaMeL Repository CaMeL Manager ( ) . get CaMeL Repositories ( REPOSITORY _ KIND ) ; for ( Task CaMeL Repository repository : repositories ) { read CaMeL Cached CaMeL Product CaMeL Configuration ( repository . get CaMeL Url ( ) . to CaMeL External CaMeL Form ( ) ) ; } }	final Set < Task CaMeL Repository > repositories = My@@ lar CaMeL Task CaMeL List CaMeL Plugin . get CaMeL Repository CaMeL Manager ( ) . get CaMeL Repositories ( REPOSITORY _ KIND ) ;
_ notify CaMeL Screen CaMeL Line CaMeL Changes ( ) ;  <CTX>  public void collapse CaMeL Fold ( int line ) { int line CaMeL Count = buffer . get CaMeL Line CaMeL Count ( ) ; int start = 0 ; int end = line CaMeL Count - 1 ; / / if the caret is on a collapsed fold , collapse the / / parent fold if ( line != 0 && line != buffer . get CaMeL Line CaMeL Count ( ) - 1 && buffer . is CaMeL Fold CaMeL Start ( line ) && ! is CaMeL Line CaMeL Visible ( line + 1 ) ) { line -- ; } int initial CaMeL Fold CaMeL Level = buffer . get CaMeL Fold CaMeL Level ( line ) ; / / { { { Find fold start and end . . . if ( line != line CaMeL Count - 1 && buffer . get CaMeL Fold CaMeL Level ( line + 1 ) > initial CaMeL Fold CaMeL Level ) { / / this line is the start of a fold start = line + 1 ; for ( int i = line + 1 ; i < line CaMeL Count ; i ++ ) { if ( buffer . get CaMeL Fold CaMeL Level ( i ) <= initial CaMeL Fold CaMeL Level ) { end = i - 1 ; break ; } } } else { boolean ok = false ; / / scan backwards looking for the start for ( int i = line - 1 ; i >= 0 ; i -- ) { if ( buffer . get CaMeL Fold CaMeL Level ( i ) < initial CaMeL Fold CaMeL Level ) { start = i + 1 ; ok = true ; break ; } } if ( ! ok ) { / / no folds in buffer return ; } for ( int i = line + 1 ; i < line CaMeL Count ; i ++ ) { if ( buffer . get CaMeL Fold CaMeL Level ( i ) < initial CaMeL Fold CaMeL Level ) { end = i - 1 ; break ; } } } / / } } } / / Collapse the fold . . . hide CaMeL Line CaMeL Range ( start , end ) ; _ notify CaMeL Screen CaMeL Line CaMeL Changes ( ) ; text CaMeL Area . fold CaMeL Structure CaMeL Changed ( ) ; } / / } } }	notify CaMeL Screen CaMeL Line CaMeL Changes ( ) ;
if ( element . get CaMeL Element CaMeL Type ( ) == I CaMeL Java CaMeL Element . COMPILATION _ UNIT ) return ( I CaMeL Compilation CaMeL Unit ) element ; if ( element instanceof I CaMeL Member ) return ( ( I CaMeL Member ) element ) . get CaMeL Compilation CaMeL Unit ( ) ; return find CaMeL Compilation CaMeL Unit ( element . get CaMeL Parent ( ) ) ;  <CTX>  static I CaMeL Compilation CaMeL Unit find CaMeL Compilation CaMeL Unit ( I CaMeL Java CaMeL Element element ) { if ( element == null ) return null ; if ( element . get CaMeL Element CaMeL Type ( ) == I CaMeL Java CaMeL Element . COMPILATION _ UNIT ) return ( I CaMeL Compilation CaMeL Unit ) element ; if ( element instanceof I CaMeL Member ) return ( ( I CaMeL Member ) element ) . get CaMeL Compilation CaMeL Unit ( ) ; return find CaMeL Compilation CaMeL Unit ( element . get CaMeL Parent ( ) ) ; }	return ( I CaMeL Compilation CaMeL Unit ) element . get CaMeL Ancestor ( I CaMeL Java CaMeL Element . COMPILATION _ UNIT ) ;
request . run ( ) ;  <CTX>  public void run ( ) { synchronized ( LOCK ) { my CaMeL Original CaMeL To CaMeL Thread CaMeL Request CaMeL Map . remove ( request ) ; } try { request . run ( ) ; } catch ( Throwable e ) { LOG . error ( e ) ; } }	if ( ! my CaMeL Disposed ) { request . run ( ) ; }
save ( o ) ;  <CTX>  public void restore CaMeL User CaMeL Info ( Bw CaMeL User CaMeL Info o ) throws Throwable { if ( globals . only CaMeL Users && ( globals . only CaMeL Users CaMeL Map . get ( o . get CaMeL User ( ) . get CaMeL Account ( ) ) == null ) ) { return ; } open CaMeL Sess ( ) ; save ( o ) ; close CaMeL Sess ( ) ; }	hib CaMeL Save ( o ) ;
exact CaMeL Type CaMeL Set . or ( ( ( Type CaMeL Frame ) other _ ) . exact CaMeL Type CaMeL Set ) ;  <CTX>  public void copy CaMeL From ( Frame < Type > other _ ) { clear CaMeL Exact CaMeL Set ( ) ; exact CaMeL Type CaMeL Set . or ( ( ( Type CaMeL Frame ) other _ ) . exact CaMeL Type CaMeL Set ) ; super . copy CaMeL From ( other _ ) ; }	Type CaMeL Frame other = ( Type CaMeL Frame ) other _ ; this . exact CaMeL Type CaMeL Set . or ( other . exact CaMeL Type CaMeL Set ) ; this . instance CaMeL Of CaMeL Type = other . instance CaMeL Of CaMeL Type ; this . instance CaMeL Of CaMeL Value CaMeL Number = other . instance CaMeL Of CaMeL Value CaMeL Number ;
execute ( Collections . singleton CaMeL List ( project ) , goals , event CaMeL Monitor , transfer CaMeL Listener , execution CaMeL Root CaMeL Directory ) ;  <CTX>  public void execute ( Maven CaMeL Project project , List goals , Event CaMeL Monitor event CaMeL Monitor , Transfer CaMeL Listener transfer CaMeL Listener , File execution CaMeL Root CaMeL Directory ) throws Cycle CaMeL Detected CaMeL Exception , Lifecycle CaMeL Execution CaMeL Exception , Mojo CaMeL Execution CaMeL Exception { execute ( Collections . singleton CaMeL List ( project ) , goals , event CaMeL Monitor , transfer CaMeL Listener , execution CaMeL Root CaMeL Directory ) ; }	execute ( Collections . singleton CaMeL List ( project ) , goals , event CaMeL Monitor , transfer CaMeL Listener , properties , execution CaMeL Root CaMeL Directory ) ;
overlay . notify CaMeL Listeners ( new Transform CaMeL Event ( text ) ) ;  <CTX>  public void mouse CaMeL Drag ( float x , float y , int [ ] pos , int mods ) { if ( text == null ) return ; text . set CaMeL Coords ( x , y ) ; overlay . notify CaMeL Listeners ( new Transform CaMeL Event ( text ) ) ; }	overlay . notify CaMeL Listeners ( new Transform CaMeL Event ( overlay ) ) ;
this ( constraint CaMeL Id , index CaMeL Id ) ; this . key CaMeL Constraint CaMeL Id = key CaMeL Constraint CaMeL Id ; this . ra CaMeL Delete CaMeL Rule = ra CaMeL Delete CaMeL Rule ; this . ra CaMeL Update CaMeL Rule = ra CaMeL Update CaMeL Rule ;  <CTX>  public Sub CaMeL Key CaMeL Constraint CaMeL Descriptor ( UUID constraint CaMeL Id , UUID index CaMeL Id , UUID key CaMeL Constraint CaMeL Id , int ra CaMeL Delete CaMeL Rule , int ra CaMeL Update CaMeL Rule ) { this ( constraint CaMeL Id , index CaMeL Id ) ; this . key CaMeL Constraint CaMeL Id = key CaMeL Constraint CaMeL Id ; this . ra CaMeL Delete CaMeL Rule = ra CaMeL Delete CaMeL Rule ; this . ra CaMeL Update CaMeL Rule = ra CaMeL Update CaMeL Rule ; }	super ( constraint CaMeL Id ) ; this . index CaMeL Id = index CaMeL Id ;
e . print CaMeL Stack CaMeL Trace ( ) ;  <CTX>  private Buffer T CaMeL S@@ new CaMeL File ( ) { final Buffer [ ] ret CaMeL Val = new Buffer [ 1 ] ; try { Swing CaMeL Utilities . invoke CaMeL And CaMeL Wait ( new Runnable ( ) { public void run ( ) { ret CaMeL Val [ 0 ] = j CaMeL Edit . new CaMeL File ( null ) ; } } ) ; } catch ( Exception e ) { e . print CaMeL Stack CaMeL Trace ( ) ; } return ret CaMeL Val [ 0 ] ; }	Log . log ( Log . ERROR , this , e ) ;
I CaMeL Content CaMeL Emitter emitter , I CaMeL Row CaMeL Data row CaMeL Data ) ;  <CTX>  abstract protected void access CaMeL Header ( Listing CaMeL Design list , I CaMeL Content CaMeL Emitter emitter , I CaMeL Row CaMeL Data row CaMeL Data ) ;	I CaMeL Content CaMeL Emitter emitter , I CaMeL Result CaMeL Iterator rs CaMeL Iterator ) ;
Map ret = metric . get CaMeL Kerning CaMeL Info ( ) ; if ( ret != null ) { return ret ;  <CTX>  public Map get CaMeL Kerning ( ) { Map ret = metric . get CaMeL Kerning CaMeL Info ( ) ; if ( ret != null ) { return ret ; } else { return java . util . Collections . EMPTY _ MAP ; } }	if ( metric . has CaMeL Kerning CaMeL Info ( ) ) { return metric . get CaMeL Kerning CaMeL Info ( ) ;
target CaMeL List . dispose ( ) ; model CaMeL List . dispose ( ) ; disposed = true ;  <CTX>  public void dispose ( ) { target CaMeL List . remove CaMeL List CaMeL Change CaMeL Listener ( target CaMeL Change CaMeL Listener ) ; model CaMeL List . remove CaMeL List CaMeL Change CaMeL Listener ( model CaMeL Change CaMeL Listener ) ; target CaMeL List . dispose ( ) ; model CaMeL List . dispose ( ) ; disposed = true ; }	super . dispose ( ) ;
doc CaMeL Decl . DIAG _ BAD _ TAGNAME _ WRAP@@ UP , sti . q CaMeL Name ,  <CTX>  private final String diagnose CaMeL Bad CaMeL Tag CaMeL Name ( Start CaMeL Tag CaMeL Info sti ) { final Combined CaMeL Child CaMeL Content CaMeL Exp CaMeL Creator cc@@ cc = doc CaMeL Decl . cc@@ cec ; / / try creating combined child content pattern without tag name check . Expression r = cc@@ cc . get ( expression , sti , false ) . content ; if ( r == Expression . null CaMeL Set ) / / no element is allowed here at all . return doc CaMeL Decl . localize CaMeL Message ( doc CaMeL Decl . DIAG _ ELEMENT _ NOT _ ALLOWED , sti . q CaMeL Name ) ; if ( cc@@ cc . is CaMeL Complex ( ) ) { / / prob@@ ably < con@@ cur > is used . / / there is no easy way to tell which what tag name is expected . / / TODO : we can reduce strength by tre@@ ating con@@ cur as choice . / / do it . return null ; } / / we are now sure that combined child content expression will be / / the choice of all elements of con@@ cer@@ n . / / so if tag name satisfies one of tho@@ se elements , / / it can be accepted . / / the@@ re@@ fore we can provide candidates for users . Set s = new java . util . Hash CaMeL Set ( ) ; boolean more = false ; / / if there is a Simple CaMeL Name CaMeL Class with the same local CaMeL Name / / but with a different namespace URI , / / this variable will receive that URI . String wrong CaMeL Namespace = null ; final Element CaMeL Exp [ ] e@@ ocs = cc@@ cc . get CaMeL Matched CaMeL Elements ( ) ; final int len = cc@@ cc . num CaMeL Matched CaMeL Elements ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( e@@ ocs [ i ] . content CaMeL Model . get CaMeL Expanded CaMeL Exp ( doc CaMeL Decl . pool ) == Expression . null CaMeL Set ) / / this element is not allowed to app@@ ear . continue ; / / test some typ@@ ical name class patterns . final Name CaMeL Class nc = e@@ ocs [ i ] . get CaMeL Name CaMeL Class ( ) ; if ( nc instanceof Simple CaMeL Name CaMeL Class ) { Simple CaMeL Name CaMeL Class sn@@ c = ( Simple CaMeL Name CaMeL Class ) nc ; if ( sn@@ c . local CaMeL Name . equals ( sti . local CaMeL Name ) ) { / / some@@ times , people simp@@ ly forget to add namespace decl , / / or declare the wrong name . wrong CaMeL Namespace = sn@@ c . namespace CaMeL URI ; } s . add ( doc CaMeL Decl . localize CaMeL Message ( doc CaMeL Decl . DIAG _ SIMPLE _ NAME@@ CLASS , nc . to CaMeL String ( ) ) ) ; continue ; } if ( nc instanceof Namespace CaMeL Name CaMeL Class ) { s . add ( doc CaMeL Decl . localize CaMeL Message ( doc CaMeL Decl . DIAG _ NAMESPACE _ NAME@@ CLASS , ( ( Namespace CaMeL Name CaMeL Class ) nc ) . namespace CaMeL URI ) ) ; continue ; } if ( nc instanceof Not CaMeL Name CaMeL Class ) { Name CaMeL Class n@@ cc = ( ( Not CaMeL Name CaMeL Class ) nc ) . child ; if ( n@@ cc instanceof Namespace CaMeL Name CaMeL Class ) { s . add ( doc CaMeL Decl . localize CaMeL Message ( doc CaMeL Decl . DIAG _ NOT _ NAMESPACE _ NAME@@ CLASS , ( ( Namespace CaMeL Name CaMeL Class ) n@@ cc ) . namespace CaMeL URI ) ) ; continue ; } } / / this name class is very complex and / / the@@ re@@ fore we were unable to provide appropriate suggestion . more = true ; } / / no candidate was collected . ba@@ il out . if ( s . size ( ) == 0 ) return null ; if ( wrong CaMeL Namespace != null ) { if ( s . size ( ) == 1 ) / / only one candidate . return doc CaMeL Decl . localize CaMeL Message ( doc CaMeL Decl . DIAG _ BAD _ TAGNAME _ WRONG _ NAMESPACE , sti . local CaMeL Name , wrong CaMeL Namespace ) ; else / / prob@@ ably wrong namespace , / / but show the user that he / sh@@ e has other choices . return doc CaMeL Decl . localize CaMeL Message ( doc CaMeL Decl . DIAG _ BAD _ TAGNAME _ PROB@@ AB@@ LY _ WRONG _ NAMESPACE , sti . local CaMeL Name , wrong CaMeL Namespace ) ; } / / there is no cl@@ ue about user s intention . return doc CaMeL Decl . localize CaMeL Message ( doc CaMeL Decl . DIAG _ BAD _ TAGNAME _ WRAP@@ UP , sti . q CaMeL Name , concatenate CaMeL Messages ( s , more , doc CaMeL Decl . DIAG _ BAD _ TAGNAME _ SEPARATOR , doc CaMeL Decl . DIAG _ BAD _ TAGNAME _ MORE ) ) ; }	RE CaMeL Document CaMeL Declaration . DIAG _ BAD _ TAGNAME _ WRAP@@ UP , sti . q CaMeL Name ,
int index = logical CaMeL View . get CaMeL View CaMeL Index ( start CaMeL Offset , Position . Bias . Forward ) ; View ret CaMeL Val = null ; if ( index >= 0 ) { ret CaMeL Val = logical CaMeL View . get CaMeL View ( index ) ;  <CTX>  protected View create CaMeL View ( Flow CaMeL View fv , int start CaMeL Offset , int span CaMeL Left , int row CaMeL Index ) { View logical CaMeL View = get CaMeL Logical CaMeL View ( fv ) ; / / FIX@@ ME : Handle the bias thing correctly . int index = logical CaMeL View . get CaMeL View CaMeL Index ( start CaMeL Offset , Position . Bias . Forward ) ; View ret CaMeL Val = null ; if ( index >= 0 ) { ret CaMeL Val = logical CaMeL View . get CaMeL View ( index ) ; if ( ret CaMeL Val . get CaMeL Start CaMeL Offset ( ) != start CaMeL Offset ) ret CaMeL Val = ret CaMeL Val . create CaMeL Fragment ( start CaMeL Offset , ret CaMeL Val . get CaMeL End CaMeL Offset ( ) ) ; } return ret CaMeL Val ; }	int index = logical CaMeL View . get CaMeL View CaMeL Index ( start CaMeL Offset , Position . Bias . Forward ) ; View ret CaMeL Val = logical CaMeL View . get CaMeL View ( index ) ;
header . get CaMeL Model ( ) . get CaMeL Underlying CaMeL Resource ( ) , target ) } ;  <CTX>  public I CaMeL Hyperlink [ ] detect CaMeL Hyperlinks ( I CaMeL Text CaMeL Viewer text CaMeL Viewer , I CaMeL Region region , boolean can CaMeL Show CaMeL Multiple CaMeL Hyperlinks ) { if ( region == null || can CaMeL Show CaMeL Multiple CaMeL Hyperlinks ) return null ; I CaMeL Document CaMeL Range element = f CaMeL Source CaMeL Page . get CaMeL Range CaMeL Element ( region . get CaMeL Offset ( ) ) ; if ( ! ( element instanceof Manifest CaMeL Header ) ) return null ; Manifest CaMeL Header header = ( Manifest CaMeL Header ) element ; if ( ! header . get CaMeL Model ( ) . is CaMeL Editable ( ) ) return null ; if ( region . get CaMeL Offset ( ) <= header . get CaMeL Offset ( ) + header . get CaMeL Name ( ) . length ( ) ) return null ; if ( header instanceof Bundle CaMeL Activator CaMeL Header ) { / / add else if stat@@ ments for other headers String target = ( ( Bundle CaMeL Activator CaMeL Header ) element ) . get CaMeL Class CaMeL Name ( ) ; if ( target == null || target . length ( ) == 0 ) return null ; I CaMeL Document CaMeL Range range = Bundle CaMeL Source CaMeL Page . get CaMeL Specific CaMeL Range ( header . get CaMeL Model ( ) , header , target ) ; if ( range == null ) return null ; return new I CaMeL Hyperlink [ ] { new Java CaMeL Hyperlink ( new Region ( range . get CaMeL Offset ( ) , range . get CaMeL Length ( ) ) , header . get CaMeL Model ( ) . get CaMeL Underlying CaMeL Resource ( ) , target ) } ; } else if ( header instanceof Base CaMeL Package CaMeL Header || header instanceof Require CaMeL Bundle CaMeL Header ) { return match CaMeL Link CaMeL For ( header , region . get CaMeL Offset ( ) ) ; } return null ; }	target , header . get CaMeL Model ( ) . get CaMeL Underlying CaMeL Resource ( ) ) } ;
if ( ! invalid [ r ] && sent [ r ] < retries )  <CTX>  send ( Message query ) throws IO CaMeL Exception { int q , r ; Message best = null ; IO CaMeL Exception best CaMeL Exception = null ; boolean [ ] invalid = new boolean [ resolvers . size ( ) ] ; byte [ ] sent = new byte [ resolvers . size ( ) ] ; Vector queue = new Vector ( ) ; Hashtable id CaMeL Map = new Hashtable ( ) ; Receiver receiver = new Receiver ( queue , id CaMeL Map ) ; while ( true ) { Message m ; boolean waiting = false ; Q CaMeL Element qe ; synchronized ( queue ) { for ( r = 0 ; r < resolvers . size ( ) ; r ++ ) { if ( sent [ r ] == 0 ) { send CaMeL To ( query , receiver , id CaMeL Map , r ) ; sent [ r ] ++ ; waiting = true ; break ; } if ( ! invalid [ r ] && sent [ r ] < retries ) waiting = true ; } if ( ! waiting ) break ; try { queue . wait ( ) ; } catch ( Interrupted CaMeL Exception e ) { } if ( queue . size ( ) == 0 ) continue ; qe = ( Q CaMeL Element ) queue . first CaMeL Element ( ) ; queue . remove CaMeL Element ( qe ) ; if ( qe . obj instanceof Message ) m = ( Message ) qe . obj ; else m = null ; r = qe . res ; } if ( m == null ) { IO CaMeL Exception e = ( IO CaMeL Exception ) qe . obj ; if ( ! ( e instanceof Interrupted CaMeL IO CaMeL Exception ) ) invalid [ r ] = true ; if ( best CaMeL Exception == null ) best CaMeL Exception = e ; } else { byte rcode = m . get CaMeL Header ( ) . get CaMeL Rcode ( ) ; if ( rcode == Rcode . NO@@ ERROR ) return m ; else { if ( best == null ) best = m ; else { byte be@@ str@@ code ; be@@ str@@ code = best . get CaMeL Header ( ) . get CaMeL Rcode ( ) ; if ( rcode == Rcode . NX@@ DOMAIN && be@@ str@@ code != Rcode . NX@@ DOMAIN ) best = m ; } invalid [ r ] = true ; } } } if ( best != null ) return best ; throw best CaMeL Exception ; }	else if ( rec@@ vd [ r ] < sent [ r ] )
return System . get CaMeL Properties ( ) ;  <CTX>  public Object run ( ) { return System . get CaMeL Properties ( ) ; }	return Framework CaMeL Properties . get CaMeL Properties ( ) ;
Address CaMeL Dequeue src = cycle CaMeL Buffer CaMeL B ;  <CTX>  private final void do CaMeL Collect CaMeL Phase ( ) { VM _ Address object ; Address CaMeL Dequeue src = cycle CaMeL Buffer CaMeL B ; phase = COLLECT ; while ( ! ( object = src . pop ( ) ) . is CaMeL Zero ( ) ) { if ( VM _ Interface . Verify CaMeL Assertions ) VM _ Interface . _ assert ( ! RC CaMeL Base CaMeL Header . is CaMeL Green ( object ) ) ; RC CaMeL Base CaMeL Header . clear CaMeL Buffered CaMeL Bit ( object ) ; collect CaMeL White ( object ) ; } }	Address CaMeL Deque src = cycle CaMeL Buffer CaMeL B ;
J CaMeL Combo CaMeL Box box = new J CaMeL Combo CaMeL Box ( m CaMeL Editor . get CaMeL Tags ( ) ) ;  <CTX>  protected Component create CaMeL Combo CaMeL Box ( ) { / / Populate the box with the tags J CaMeL Combo CaMeL Box box = new J CaMeL Combo CaMeL Box ( m CaMeL Editor . get CaMeL Tags ( ) ) ; / / box . set CaMeL Border ( Border CaMeL Factory . create CaMeL Lowered CaMeL Bevel CaMeL Border ( ) ) ; box . set CaMeL Selected CaMeL Item ( m CaMeL Editor . get CaMeL As CaMeL Text ( ) ) ; box . set CaMeL Font ( box . get CaMeL Font ( ) . derive CaMeL Font ( Font . PLAIN ) ) ; box . add CaMeL Action CaMeL Listener ( new Action CaMeL Listener ( ) { public void action CaMeL Performed ( Action CaMeL Event evt ) { stop CaMeL Cell CaMeL Editing ( ) ; } } ) ; return box ; }	final J CaMeL Combo CaMeL Box box = new J CaMeL Combo CaMeL Box ( m CaMeL Editor . get CaMeL Tags ( ) ) ;
if ( _ margin CaMeL Bottom CaMeL Override CaMeL Set ) { result . bottom = ( int ) _ margin CaMeL Bottom CaMeL Override ;  <CTX>  public Border get CaMeL Margin CaMeL Width ( Context c , float parent CaMeL Width ) { Border result = c . get CaMeL Current CaMeL Style ( ) . get CaMeL Margin CaMeL Width ( parent CaMeL Width , parent CaMeL Width , c . get CaMeL Ctx ( ) ) ; if ( _ margin CaMeL Top CaMeL Override CaMeL Set ) { result . top = ( int ) _ margin CaMeL Top CaMeL Override ; } if ( _ margin CaMeL Bottom CaMeL Override CaMeL Set ) { result . bottom = ( int ) _ margin CaMeL Bottom CaMeL Override ; } return result ; }	if ( this . margin CaMeL Bottom CaMeL Override CaMeL Set ) { result . bottom = ( int ) this . margin CaMeL Bottom CaMeL Override ;
data [ i + offset ] = ( float ) val ;  <CTX>  public void set CaMeL Elem ( int i , int val ) { data [ i + offset ] = ( float ) val ; }	data [ i + offset ] = val ;
return Ruby CaMeL Fixnum . new CaMeL Fixnum ( recv . get CaMeL Runtime ( ) , count ) ;  <CTX>  public static I CaMeL Ruby CaMeL Object each _ object ( I CaMeL Ruby CaMeL Object recv , I CaMeL Ruby CaMeL Object [ ] args ) { Ruby CaMeL Module ruby CaMeL Class ; if ( args . length == 0 ) { ruby CaMeL Class = recv . get CaMeL Runtime ( ) . get CaMeL Classes ( ) . get CaMeL Object CaMeL Class ( ) ; } else { ruby CaMeL Class = ( Ruby CaMeL Module ) args [ 0 ] ; } int count = 0 ; Iterator iter = recv . get CaMeL Runtime ( ) . object CaMeL Space . iterator ( ruby CaMeL Class ) ; while ( iter . has CaMeL Next ( ) ) { count ++ ; recv . get CaMeL Runtime ( ) . yield ( ( I CaMeL Ruby CaMeL Object ) iter . next ( ) ) ; } return Ruby CaMeL Fixnum . new CaMeL Fixnum ( recv . get CaMeL Runtime ( ) , count ) ; }	return recv . get CaMeL Runtime ( ) . new CaMeL Fixnum ( count ) ;
boolean delist CaMeL Resource ( XA CaMeL Resource xa CaMeL Resource , int i ) throws Illegal CaMeL State CaMeL Exception , System CaMeL Exception ;  <CTX>  boolean delist CaMeL Resource ( XA CaMeL Resource xa CaMeL Resource , int i ) throws Illegal CaMeL State CaMeL Exception , System CaMeL Exception ;	boolean delist CaMeL Resource ( XA CaMeL Resource xa CaMeL Res , int flag ) throws Illegal CaMeL State CaMeL Exception , System CaMeL Exception ;
return Integer . value CaMeL Of ( s ) . int CaMeL Value ( ) ;  <CTX>  public static int string CaMeL To CaMeL Int ( String s ) { try { return Integer . value CaMeL Of ( s ) . int CaMeL Value ( ) ; } catch ( Number CaMeL Format CaMeL Exception e ) { return ( - 1 ) ; / / ? ? ? } }	return Integer . parse CaMeL Int ( s ) ;
Object CaMeL Pool create CaMeL Pool ( U@@ MO CaMeL Descriptor descriptor ) ;  <CTX>  Object CaMeL Pool create CaMeL Pool ( U@@ MO CaMeL Descriptor descriptor ) ;	Object CaMeL Pool create CaMeL Pool ( U@@ MO CaMeL Descriptor descriptor , Object CaMeL Factory factory ) ;
get CaMeL Series CaMeL Marker ( ) . set CaMeL Type ( Marker CaMeL Type . get ( get CaMeL Selected CaMeL Marker CaMeL Name ( ) ) ) ;  <CTX>  public void widget CaMeL Selected ( Selection CaMeL Event e ) { if ( e . get CaMeL Source ( ) . equals ( btn CaMeL Curve ) ) { ( ( Line CaMeL Series ) series ) . set CaMeL Curve ( btn CaMeL Curve . get CaMeL Selection ( ) ) ; } else if ( e . get CaMeL Source ( ) . equals ( btn CaMeL Palette ) ) { ( ( Line CaMeL Series ) series ) . set CaMeL Palette CaMeL Line CaMeL Color ( btn CaMeL Palette . get CaMeL Selection ( ) ) ; } else if ( e . get CaMeL Source ( ) . equals ( btn CaMeL Marker CaMeL Visible ) ) { ( ( Line CaMeL Series ) series ) . get CaMeL Marker ( ) . set CaMeL Visible ( btn CaMeL Marker CaMeL Visible . get CaMeL Selection ( ) ) ; cmb CaMeL Marker CaMeL Types . set CaMeL Enabled ( btn CaMeL Marker CaMeL Visible . get CaMeL Selection ( ) ) ; isc CaMeL Marker CaMeL Size . set CaMeL Enabled ( btn CaMeL Marker CaMeL Visible . get CaMeL Selection ( ) ) ; } else if ( e . get CaMeL Source ( ) . equals ( cmb CaMeL Marker CaMeL Types ) ) { if ( Marker CaMeL Type . get ( get CaMeL Selected CaMeL Marker CaMeL Name ( ) ) == Marker CaMeL Type . ICON _ LITERAL ) { Marker CaMeL Icon CaMeL Dialog icon CaMeL Dialog = new Marker CaMeL Icon CaMeL Dialog ( this . get CaMeL Shell ( ) , get CaMeL Series CaMeL Marker ( ) . get CaMeL Icon CaMeL Palette ( ) ) ; if ( icon CaMeL Dialog . apply CaMeL Marker CaMeL Icon ( ) ) { if ( icon CaMeL Dialog . get CaMeL Icon CaMeL Palette ( ) . e CaMeL Adapters ( ) . is CaMeL Empty ( ) ) { / / Add adapters to new E CaMeL Object icon CaMeL Dialog . get CaMeL Icon CaMeL Palette ( ) . e CaMeL Adapters ( ) . add CaMeL All ( get CaMeL Series CaMeL Marker ( ) . e CaMeL Adapters ( ) ) ; } get CaMeL Series CaMeL Marker ( ) . set CaMeL Icon CaMeL Palette ( icon CaMeL Dialog . get CaMeL Icon CaMeL Palette ( ) ) ; } else { cmb CaMeL Marker CaMeL Types . set CaMeL Text ( Literal CaMeL Helper . marker CaMeL Type CaMeL Set . get CaMeL Display CaMeL Name CaMeL By CaMeL Name ( get CaMeL Series CaMeL Marker ( ) . get CaMeL Type ( ) . get CaMeL Name ( ) ) ) ; } } get CaMeL Series CaMeL Marker ( ) . set CaMeL Type ( Marker CaMeL Type . get ( get CaMeL Selected CaMeL Marker CaMeL Name ( ) ) ) ; } }	get CaMeL Series CaMeL Marker ( ) . set CaMeL Type ( Marker CaMeL Type . get CaMeL By CaMeL Name ( get CaMeL Selected CaMeL Marker CaMeL Name ( ) ) ) ;
get CaMeL Undo CaMeL Activity ( ) . set CaMeL Affected CaMeL Figures ( view ( ) . selection ( ) ) ;  <CTX>  public void execute ( ) { super . execute ( ) ; set CaMeL Undo CaMeL Activity ( create CaMeL Undo CaMeL Activity ( ) ) ; get CaMeL Undo CaMeL Activity ( ) . set CaMeL Affected CaMeL Figures ( view ( ) . selection ( ) ) ; delete CaMeL Figures ( get CaMeL Undo CaMeL Activity ( ) . get CaMeL Affected CaMeL Figures ( ) ) ; view ( ) . check CaMeL Damage ( ) ; }	/ * ri@@ car@@ do _ pad@@ il@@ ha : bug@@ fix for correct delete / un@@ delete behavior * When enumer@@ ating the affected figures we must not forget the dependent * figures , since th@@ ey are deleted as well ! * / Figure CaMeL Enumeration fe = view ( ) . selection ( ) ; List affected = Collections CaMeL Factory . current ( ) . create CaMeL List ( ) ; Figure f ; Figure CaMeL Enumeration dfe ; while ( fe . has CaMeL Next CaMeL Figure ( ) ) { f = fe . next CaMeL Figure ( ) ; affected . add ( f ) ; dfe = f . get CaMeL Depend@@ end CaMeL Figures ( ) ; if ( dfe != null ) { while ( dfe . has CaMeL Next CaMeL Figure ( ) ) { affected . add ( dfe . next CaMeL Figure ( ) ) ; } } } fe = new Figure CaMeL Enumerator ( affected ) ; get CaMeL Undo CaMeL Activity ( ) . set CaMeL Affected CaMeL Figures ( fe ) ; / * ri@@ car@@ do _ pad@@ il@@ ha : end of bug@@ fix * /
super ( position ) ;  <CTX>  public Class CaMeL Var CaMeL Node ( I CaMeL Source CaMeL Position position , String name ) { super ( position ) ; this . name = name . intern ( ) ; }	super ( position , Node CaMeL Types . CLAS@@ SV@@ AR@@ NODE ) ;
if ( text == null || String CaMeL Util . is CaMeL Blank ( text ) || ! DE CaMeL Util . is CaMeL Valid CaMeL Number ( text ) ) { preview CaMeL Text = null ; } else { preview CaMeL Text = text ; } update CaMeL Preview ( ) ;  <CTX>  public void set CaMeL Preview CaMeL Text ( String text ) { if ( text == null || String CaMeL Util . is CaMeL Blank ( text ) || ! DE CaMeL Util . is CaMeL Valid CaMeL Number ( text ) ) { preview CaMeL Text = null ; } else { preview CaMeL Text = text ; } update CaMeL Preview ( ) ; return ; }	preview CaMeL Text CaMeL Box . set CaMeL Text ( text == null ? DEFAULT _ PREVIEW _ TEXT : text ) ;
if ( format CaMeL Str != null )  <CTX>  protected void format CaMeL Value ( Object value , String format CaMeL Str , Style CaMeL Design style , String CaMeL Buffer formatted CaMeL Str ) { if ( value == null ) { return ; } assert style != null && formatted CaMeL Str != null ; if ( ( value instanceof Number ) ) { Number CaMeL Formatter number CaMeL Format = null ; if ( format CaMeL Str == null || format CaMeL Str . length ( ) == 0 ) { number CaMeL Format = style . get CaMeL Number CaMeL Format CaMeL Object ( ) ; / / initial number - format for the first time if ( number CaMeL Format == null ) { format CaMeL Str = style . get CaMeL Number CaMeL Format ( ) ; if ( format CaMeL Str != null ) { number CaMeL Format = new Number CaMeL Formatter ( format CaMeL Str , context . get CaMeL Locale ( ) ) ; style . set CaMeL Number CaMeL Format CaMeL Object ( number CaMeL Format ) ; } } } else / / deal with value - of for text item { number CaMeL Format = new Number CaMeL Formatter ( format CaMeL Str , context . get CaMeL Locale ( ) ) ; } if ( number CaMeL Format == null ) { number CaMeL Format = new Number CaMeL Formatter ( context . get CaMeL Locale ( ) ) ; } formatted CaMeL Str . append ( number CaMeL Format . format ( ( ( Number ) value ) . double CaMeL Value ( ) ) ) ; return ; } else if ( value instanceof Date ) { Date CaMeL Formatter date CaMeL Format = null ; if ( format CaMeL Str == null || format CaMeL Str . length ( ) == 0 ) { date CaMeL Format = style . get CaMeL Date CaMeL Format CaMeL Object ( ) ; / / initial date - format for the first time if ( date CaMeL Format == null ) { format CaMeL Str = style . get CaMeL Date CaMeL Time CaMeL Format ( ) ; if ( format CaMeL Str != null ) { date CaMeL Format = new Date CaMeL Formatter ( format CaMeL Str , context . get CaMeL Locale ( ) ) ; style . set CaMeL Date CaMeL Format CaMeL Object ( date CaMeL Format ) ; } } } else / / deal with value - of for text item { date CaMeL Format = new Date CaMeL Formatter ( format CaMeL Str , context . get CaMeL Locale ( ) ) ; } if ( date CaMeL Format == null ) { date CaMeL Format = new Date CaMeL Formatter ( context . get CaMeL Locale ( ) ) ; } formatted CaMeL Str . append ( date CaMeL Format . format ( ( Date ) value ) ) ; return ; } else if ( value instanceof String ) { String CaMeL Formatter string CaMeL Format = null ; if ( format CaMeL Str == null || format CaMeL Str . length ( ) == 0 ) { string CaMeL Format = style . get CaMeL String CaMeL Format CaMeL Object ( ) ; / / initial string - format for the first time if ( string CaMeL Format == null ) { / / get format pattern from style format CaMeL Str = style . get CaMeL String CaMeL Format ( ) ; if ( format CaMeL Str != null ) { / / use default string CaMeL Format string CaMeL Format = new String CaMeL Formatter ( format CaMeL Str , context . get CaMeL Locale ( ) ) ; style . set CaMeL String CaMeL Format CaMeL Object ( string CaMeL Format ) ; } } } else / / deal with value - of for text item { string CaMeL Format = new String CaMeL Formatter ( format CaMeL Str , context . get CaMeL Locale ( ) ) ; } if ( string CaMeL Format != null ) { formatted CaMeL Str . append ( string CaMeL Format . format ( value . to CaMeL String ( ) ) ) ; return ; } } formatted CaMeL Str . append ( value . to CaMeL String ( ) ) ; }	if ( format CaMeL Str != null && format CaMeL Str . length ( ) != 0 )
this . image = create CaMeL Image ( new Filtered CaMeL Image CaMeL Source ( temp CaMeL Image . get CaMeL Source ( ) , new Key CaMeL Alpha CaMeL Filter ( TRANSPARENT ) ) ) ;  <CTX>  public void prepare ( ) { / / create image for buffer Image temp CaMeL Image = create CaMeL Image ( bounds . width , bounds . height ) ; Graphics graph = temp CaMeL Image . get CaMeL Graphics ( ) ; / / fill with key color graph . set CaMeL Color ( new Color ( TRANSPARENT ) ) ; graph . fill CaMeL Rect ( 0 , 0 , bounds . width , bounds . height ) ; / / draw attack poly graph . set CaMeL Color ( color ) ; graph . draw CaMeL Polygon ( hex CaMeL Poly ) ; / / create final image this . image = create CaMeL Image ( new Filtered CaMeL Image CaMeL Source ( temp CaMeL Image . get CaMeL Source ( ) , new Key CaMeL Alpha CaMeL Filter ( TRANSPARENT ) ) ) ; }	if ( zoom CaMeL Index == BASE _ ZOOM _ INDEX ) { image = create CaMeL Image ( new Filtered CaMeL Image CaMeL Source ( temp CaMeL Image . get CaMeL Source ( ) , new Key CaMeL Alpha CaMeL Filter ( TRANSPARENT ) ) ) ; } else { image = get CaMeL Scaled CaMeL Image ( create CaMeL Image ( new Filtered CaMeL Image CaMeL Source ( temp CaMeL Image . get CaMeL Source ( ) , new Key CaMeL Alpha CaMeL Filter ( TRANSPARENT ) ) ) ) ; } graph . dispose ( ) ; temp CaMeL Image . flush ( ) ;
_ switch CaMeL Pane CaMeL Focus ( true ) ;  <CTX>  public void action CaMeL Performed ( Action CaMeL Event ae ) { _ switch CaMeL Pane CaMeL Focus ( true ) ; }	_ model . set CaMeL Active CaMeL Next CaMeL Document ( ) ;
this ( bytes , 0 , bytes . length , 0 , false ) ;  <CTX>  public Bit CaMeL String ( byte [ ] bytes ) { this ( bytes , 0 , bytes . length , 0 , false ) ; }	this ( bytes , 0 , bytes . length , ignored CaMeL Bits , do CaMeL Shift ) ;
experiment . remove CaMeL Experiment CaMeL Listener ( listener ) ;  <CTX>  public void action CaMeL Performed ( Action CaMeL Event e ) { String s = ( ( Abstract CaMeL Button ) e . get CaMeL Source ( ) ) . get CaMeL Action CaMeL Command ( ) ; if ( s . equals ( Named CaMeL Frame . COMMUNITY ) ) { make CaMeL Community CaMeL Graph ( ) ; } else if ( s . equals ( Named CaMeL Frame . AGENT ) ) { make CaMeL Society CaMeL Graph ( ) ; / / only the name changes ! } else if ( s . equals ( Named CaMeL Frame . PLAN ) ) { make CaMeL Plan CaMeL Graph ( ) ; } else if ( s . equals ( Named CaMeL Frame . THREAD ) ) { make CaMeL Thread CaMeL Graph ( ) ; } else if ( s . equals ( Named CaMeL Frame . METRICS ) ) { make CaMeL Metrics CaMeL Graph ( ) ; } else if ( s . equals ( OPEN _ GRAPH _ MENU _ ITEM ) ) { open CaMeL Graph ( ) ; } else if ( s . equals ( OPEN _ METRIC _ MENU _ ITEM ) ) { open CaMeL Metrics ( ) ; } else if ( s . equals ( MONITOR _ MENU _ ITEM ) ) { get CaMeL Agent CaMeL URL ( ) ; } else if ( s . equals ( EXIT _ MENU _ ITEM ) ) { if ( c@@ smart == null ) System . exit ( 0 ) ; / / if running standalone , exit else { close CaMeL Sub CaMeL Windows ( ) ; experiment . remove CaMeL Experiment CaMeL Listener ( listener ) ; Named CaMeL Frame . get CaMeL Named CaMeL Frame ( ) . remove CaMeL Frame ( this ) ; dispose ( ) ; } } else if ( s . equals ( HELP _ MENU _ ITEM ) ) { URL help = ( URL ) get CaMeL Class ( ) . get CaMeL Resource ( HELP _ DOC ) ; if ( help != null ) Browser . set CaMeL Page ( help ) ; } else if ( s . equals ( ABOUT _ CSMART _ ITEM ) ) { URL about = ( URL ) get CaMeL Class ( ) . get CaMeL Resource ( ABOUT _ DOC ) ; if ( about != null ) Browser . set CaMeL Page ( about ) ; } else { J CaMeL Frame f = Named CaMeL Frame . get CaMeL Named CaMeL Frame ( ) . get CaMeL Frame ( s ) ; if ( f != null ) { f . to CaMeL Front ( ) ; f . set CaMeL State ( Frame . NORMAL ) ; } } }	if ( experiment != null ) experiment . remove CaMeL Experiment CaMeL Listener ( listener ) ;
String class _ name = br . read CaMeL Line ( ) ;  <CTX>  private static H CaMeL Class read CaMeL Class ( Linker linker , Buffered CaMeL Reader br ) throws IO CaMeL Exception { String class _ name = br . read CaMeL Line ( ) ; H CaMeL Class hc = ( H CaMeL Class ) primitives . get ( class _ name ) ; if ( hc == null ) hc = linker . for CaMeL Name ( class _ name ) ; return hc ; }	String class _ name = read CaMeL String ( br ) ;
return new Key CaMeL Stroke ( modifier CaMeL Keys , natural CaMeL Key ) ;  <CTX>  public static Key CaMeL Stroke get CaMeL Instance ( Sorted CaMeL Set modifier CaMeL Keys , Natural CaMeL Key natural CaMeL Key ) { return new Key CaMeL Stroke ( modifier CaMeL Keys , natural CaMeL Key ) ; }	if ( modifier CaMeL Key == null ) { throw new Null CaMeL Pointer CaMeL Exception ( ) ; } return new Key CaMeL Stroke ( new Tree CaMeL Set ( Collections . singleton CaMeL List ( modifier CaMeL Key ) ) , natural CaMeL Key ) ;
_ save CaMeL Project ( ) ;  <CTX>  private void _ save CaMeL All ( ) { try { _ save CaMeL Project ( ) ; _ model . save CaMeL All CaMeL Files ( _ save CaMeL Selector ) ; } catch ( IO CaMeL Exception ioe ) { _ show CaMeL IO CaMeL Error ( ioe ) ; } }	if ( _ model . is CaMeL Project CaMeL Active ( ) ) { _ save CaMeL Project ( ) ; }
new CaMeL Val = new Boolean CaMeL Value ( src CaMeL Val . get CaMeL Boolean ( ) ) ;  <CTX>  public static Value copy ( Value src CaMeL Val ) throws Illegal CaMeL State CaMeL Exception { Value new CaMeL Val = null ; try { switch ( src CaMeL Val . get CaMeL Type ( ) ) { case Property CaMeL Type . BINARY : new CaMeL Val = new Binary CaMeL Value ( src CaMeL Val . get CaMeL Stream ( ) ) ; break ; case Property CaMeL Type . BOOLEAN : new CaMeL Val = new Boolean CaMeL Value ( src CaMeL Val . get CaMeL Boolean ( ) ) ; break ; case Property CaMeL Type . DATE : new CaMeL Val = new Date CaMeL Value ( src CaMeL Val . get CaMeL Date ( ) ) ; break ; case Property CaMeL Type . DOUBLE : new CaMeL Val = new Double CaMeL Value ( src CaMeL Val . get CaMeL Double ( ) ) ; break ; case Property CaMeL Type . LONG : new CaMeL Val = new Long CaMeL Value ( src CaMeL Val . get CaMeL Long ( ) ) ; break ; case Property CaMeL Type . PATH : new CaMeL Val = Path CaMeL Value . value CaMeL Of ( src CaMeL Val . get CaMeL String ( ) ) ; break ; case Property CaMeL Type . NAME : new CaMeL Val = Name CaMeL Value . value CaMeL Of ( src CaMeL Val . get CaMeL String ( ) ) ; break ; case Property CaMeL Type . REFERENCE : new CaMeL Val = Reference CaMeL Value . value CaMeL Of ( src CaMeL Val . get CaMeL String ( ) ) ; break ; case Property CaMeL Type . STRING : new CaMeL Val = new String CaMeL Value ( src CaMeL Val . get CaMeL String ( ) ) ; break ; } } catch ( Repository CaMeL Exception re ) { / / should never get here } return new CaMeL Val ; }	new CaMeL Val = new Boolean CaMeL Value ( src CaMeL Value . get CaMeL Boolean ( ) ) ;
table . set CaMeL Rows ( get CaMeL Rows ( ) ) ;  <CTX>  public void populate CaMeL Table ( Status CaMeL Table table ) throws Status CaMeL Service . No CaMeL Such CaMeL Table CaMeL Exception { table . set CaMeL Column CaMeL Descriptors ( column CaMeL Descriptors ) ; table . set CaMeL Default CaMeL Sort CaMeL Rules ( sort CaMeL Rules ) ; table . set CaMeL Rows ( get CaMeL Rows ( ) ) ; table . set CaMeL Summary CaMeL Info ( get CaMeL Summary CaMeL Info ( ) ) ; }	table . set CaMeL Rows ( get CaMeL Rows ( table . get CaMeL Options ( ) . get ( Status CaMeL Table . OPTION _ INCLUDE _ INTERNAL _ AUS ) ) ) ;
method CaMeL Cache . put ( name , result ) ;  <CTX>  protected Cache CaMeL Entry get CaMeL Method CaMeL Body CaMeL Cached ( String name ) { Cache CaMeL Entry result = ( Cache CaMeL Entry ) method CaMeL Cache . get ( name ) ; if ( result != null ) { return result ; } name = name . intern ( ) ; I CaMeL Callable method = search CaMeL Method ( name ) ; if ( method . is CaMeL Undefined ( ) ) { Cache CaMeL Entry undefined CaMeL Entry = Cache CaMeL Entry . create CaMeL Undefined ( name , this ) ; method CaMeL Cache . put ( name , undefined CaMeL Entry ) ; return undefined CaMeL Entry ; } result = new Cache CaMeL Entry ( name , this ) ; method . initialize CaMeL Cache CaMeL Entry ( result ) ; method CaMeL Cache . put ( name , result ) ; return result ; }	if ( result . get CaMeL Origin ( ) == this || ! ( this instanceof Meta CaMeL Class ) ) { method CaMeL Cache . put ( name , result ) ; }
Map param@@ ters , Map global CaMeL Variables , boolean is CaMeL Complete )  <CTX>  Transient CaMeL Report CaMeL Document ( I CaMeL Report CaMeL Document document , long page CaMeL Number , Map param@@ ters , Map global CaMeL Variables , boolean is CaMeL Complete ) { this . document = document ; this . page CaMeL Number = page CaMeL Number ; this . parameters = param@@ ters ; this . global CaMeL Variables = global CaMeL Variables ; this . is CaMeL Complete = is CaMeL Complete ; }	Map param@@ ters , Map parameter CaMeL Display CaMeL Texts , Map global CaMeL Variables , boolean is CaMeL Complete )
Iterator enum = page CaMeL Contributions . iterator ( ) ; while ( enum . has CaMeL Next ( ) ) { preference CaMeL Manager . add CaMeL To CaMeL Root ( ( I CaMeL Preference CaMeL Node ) enum . next ( ) ) ;  <CTX>  public Preference CaMeL Manager get CaMeL Preference CaMeL Manager ( ) { if ( preference CaMeL Manager == null ) { preference CaMeL Manager = new Preference CaMeL Manager ( PREFERENCE _ PAGE _ CATEGORY _ SEPARATOR ) ; / / Get the pages from the registry Preference CaMeL Page CaMeL Registry CaMeL Reader registry CaMeL Reader = new Preference CaMeL Page CaMeL Registry CaMeL Reader ( get CaMeL Workbench ( ) ) ; List page CaMeL Contributions = registry CaMeL Reader . get CaMeL Preference CaMeL Contributions ( Platform . get CaMeL Extension CaMeL Registry ( ) ) ; / / Add the contributions to the manager Iterator enum = page CaMeL Contributions . iterator ( ) ; while ( enum . has CaMeL Next ( ) ) { preference CaMeL Manager . add CaMeL To CaMeL Root ( ( I CaMeL Preference CaMeL Node ) enum . next ( ) ) ; } }	Iterator iterator = page CaMeL Contributions . iterator ( ) ; while ( iterator . has CaMeL Next ( ) ) { preference CaMeL Manager . add CaMeL To CaMeL Root ( ( I CaMeL Preference CaMeL Node ) iterator . next ( ) ) ;
list . add ( new Integer ( backtrace CaMeL Table [ i ] [ j ] ) ) ;  <CTX>  Linked CaMeL List backtrace ( int [ ] [ ] backtrace CaMeL Table ) { Linked CaMeL List list = new Linked CaMeL List ( ) ; int i = reference CaMeL Words . size ( ) ; int j = hypothesis CaMeL Words . size ( ) ; while ( ( i >= 0 ) && ( j >= 0 ) ) { list . add ( new Integer ( backtrace CaMeL Table [ i ] [ j ] ) ) ; switch ( backtrace CaMeL Table [ i ] [ j ] ) { case OK : i -- ; j -- ; break ; case SUBSTITUTION : i -- ; j -- ; substitutions ++ ; break ; case INSERTION : j -- ; insertions ++ ; break ; case DELETION : i -- ; deletions ++ ; break ; } } return list ; }	list . add ( backtrace CaMeL Table [ i ] [ j ] ) ;
catch ( Invocation CaMeL Target CaMeL Exception e ) { e . fill CaMeL In CaMeL Stack CaMeL Trace ( ) ; throwables [ 0 ] = e . get CaMeL Target CaMeL Exception ( ) ;  <CTX>  public void run ( ) { try { Idea CaMeL Test CaMeL Case . super . run CaMeL Test ( ) ; / * method . invoke ( Idea CaMeL Test CaMeL Case . this , new Class [ 0 ] ) ; * / } catch ( Invocation CaMeL Target CaMeL Exception e ) { e . fill CaMeL In CaMeL Stack CaMeL Trace ( ) ; throwables [ 0 ] = e . get CaMeL Target CaMeL Exception ( ) ; } catch ( Illegal CaMeL Access CaMeL Exception e ) { e . fill CaMeL In CaMeL Stack CaMeL Trace ( ) ; throwables [ 0 ] = e ; } catch ( Throwable e ) { throwables [ 0 ] = e ; } }	catch ( Throwable throwable ) { throwables [ 0 ] = throwable ;
set CaMeL Layout CaMeL Manager ( new Ruler CaMeL Layout ( ) ) ;  <CTX>  public Editor CaMeL Ruler CaMeL Figure ( boolean is CaMeL Horizontal , int measurement CaMeL Unit ) { super ( is CaMeL Horizontal , measurement CaMeL Unit ) ; set CaMeL Horizontal ( is CaMeL Horizontal ) ; set CaMeL Unit ( measurement CaMeL Unit ) ; set CaMeL Background CaMeL Color ( Color CaMeL Constants . list CaMeL Background ) ; set CaMeL Foreground CaMeL Color ( Color CaMeL Constants . list CaMeL Foreground ) ; set CaMeL Opaque ( true ) ; set CaMeL Layout CaMeL Manager ( new Ruler CaMeL Layout ( ) ) ; }	set CaMeL Layout CaMeL Manager ( new Editor CaMeL Ruler CaMeL Layout ( ) ) ;
switch ( e CaMeL Derived CaMeL Structural CaMeL Feature CaMeL ID ( e CaMeL Feature ) )  <CTX>  public boolean e CaMeL Is CaMeL Set ( E CaMeL Structural CaMeL Feature e CaMeL Feature ) { switch ( e CaMeL Derived CaMeL Structural CaMeL Feature CaMeL ID ( e CaMeL Feature ) ) { case Attribute CaMeL Package . STYLE _ _ FONT : return font != null ; case Attribute CaMeL Package . STYLE _ _ COLOR : return color != null ; case Attribute CaMeL Package . STYLE _ _ BACKGROUND _ COLOR : return background CaMeL Color != null ; case Attribute CaMeL Package . STYLE _ _ BACKGROUND _ IMAGE : return background CaMeL Image != null ; case Attribute CaMeL Package . STYLE _ _ PADDING : return padding != null ; } return e CaMeL Dynamic CaMeL Is CaMeL Set ( e CaMeL Feature ) ; }	switch ( feature CaMeL ID )
object = work CaMeL Dequeue . pop ( ) ;  <CTX>  private final boolean mark CaMeL Grey ( VM _ Address object , long time CaMeL Cap ) throws VM _ Pragma CaMeL Inline { boolean abort = false ; if ( VM _ Interface . Verify CaMeL Assertions ) VM _ Interface . _ assert ( work CaMeL Dequeue . pop ( ) . is CaMeL Zero ( ) ) ; while ( ! object . is CaMeL Zero ( ) ) { if ( VM _ Interface . Verify CaMeL Assertions ) VM _ Interface . _ assert ( ! RC CaMeL Base CaMeL Header . is CaMeL Green ( object ) ) ; visit CaMeL Count ++ ; if ( visit CaMeL Count % GREY _ VISIT _ GRA@@ IN == 0 && VM _ Interface . cycles ( ) > time CaMeL Cap ) { abort = true ; } if ( ! abort && ! RC CaMeL Base CaMeL Header . is CaMeL Grey ( object ) ) { RC CaMeL Base CaMeL Header . make CaMeL Grey ( object ) ; Scan CaMeL Object . enumerate CaMeL Pointers ( object , grey CaMeL Enum ) ; } object = work CaMeL Dequeue . pop ( ) ; } return ! abort ; }	object = work CaMeL Deque . pop ( ) ;
Object data [ ] ; data = context . pop CaMeL Operands ( 1 ) ; context . operands . push ( data [ 0 ] ) ; context . operands . push ( data [ 0 ] ) ;  <CTX>  public void execute ( PA CaMeL Context context ) throws Painter CaMeL Exception { Object data [ ] ; data = context . pop CaMeL Operands ( 1 ) ; context . operands . push ( data [ 0 ] ) ; context . operands . push ( data [ 0 ] ) ; }	double data [ ] ; data = context . pop CaMeL Number CaMeL Operands ( 1 ) ; context . operands . push ( new Double ( Math . log ( data [ 0 ] ) ) ) ;
if ( last CaMeL Node CaMeL Id == null )  <CTX>  void add CaMeL Message ( String routing CaMeL Key , Message message , Map queue CaMeL Name CaMeL To CaMeL Node CaMeL Id CaMeL Map , String last CaMeL Node CaMeL Id , long channel CaMeL ID ) { / / If we only ever send messages to the same node for this tx , then we can unicast r@@ ather than multicast / / This is how we determine that if ( last CaMeL Node CaMeL Id == null ) { multicast = true ; } else { if ( ! last CaMeL Node CaMeL Id . equals ( to CaMeL Node CaMeL Id ) ) { multicast = true ; } else { to CaMeL Node CaMeL Id = last CaMeL Node CaMeL Id ; } } Message CaMeL Holder holder = new Message CaMeL Holder ( routing CaMeL Key , message , queue CaMeL Name CaMeL To CaMeL Node CaMeL Id CaMeL Map ) ; if ( message . is CaMeL Reliable ( ) ) { if ( persistent == null ) { persistent = new Array CaMeL List ( ) ; } persistent . add ( holder ) ; check CaMeL Channel CaMeL ID = channel CaMeL ID ; } else { if ( non CaMeL Persistent == null ) { non CaMeL Persistent = new Array CaMeL List ( ) ; } non CaMeL Persistent . add ( holder ) ; } }	if ( last CaMeL Node CaMeL Id == - 1 )
if ( restore CaMeL Item != null ) { if ( selected CaMeL View != null ) { restore CaMeL Item . set CaMeL Enabled ( page != null && page . is CaMeL Moveable ( selected CaMeL View ) ) ; } else { restore CaMeL Item . set CaMeL Enabled ( false ) ; } restore CaMeL Item . set CaMeL Selection ( true ) ;  <CTX>  public void fill ( Menu menu , int index ) { / / TODO Auto - generated method stub super . fill ( menu , index ) ; if ( bar . is CaMeL True CaMeL Fast CaMeL View ( ) ) { orientation CaMeL Item = new Menu CaMeL Item ( menu , SWT . CASCADE , index ++ ) ; { orientation CaMeL Item . set CaMeL Text ( Workbench CaMeL Messages . Fast CaMeL View CaMeL Bar _ view _ orientation ) ; Menu orientation CaMeL Swt CaMeL Menu = new Menu ( orientation CaMeL Item ) ; Radio CaMeL Menu orientation CaMeL Menu = new Radio CaMeL Menu ( orientation CaMeL Swt CaMeL Menu , current CaMeL Orientation ) ; orientation CaMeL Menu . add CaMeL Menu CaMeL Item ( Workbench CaMeL Messages . Fast CaMeL View CaMeL Bar _ horizontal , new Integer ( SWT . HORIZONTAL ) ) ; orientation CaMeL Menu . add CaMeL Menu CaMeL Item ( Workbench CaMeL Messages . Fast CaMeL View CaMeL Bar _ vertical , new Integer ( SWT . VERTICAL ) ) ; orientation CaMeL Item . set CaMeL Menu ( orientation CaMeL Swt CaMeL Menu ) ; } restore CaMeL Item = new Menu CaMeL Item ( menu , SWT . CHECK , index ++ ) ; restore CaMeL Item . set CaMeL Text ( Workbench CaMeL Messages . View CaMeL Pane _ fast CaMeL View ) ; restore CaMeL Item . add CaMeL Selection CaMeL Listener ( new Selection CaMeL Adapter ( ) { public void widget CaMeL Selected ( Selection CaMeL Event e ) { bar . restore CaMeL View ( selected CaMeL View , true ) ; } } ) ; } close CaMeL Item = new Menu CaMeL Item ( menu , SWT . NONE , index ++ ) ; close CaMeL Item . set CaMeL Text ( Workbench CaMeL Messages . Workbench CaMeL Window _ close ) ; close CaMeL Item . add CaMeL Selection CaMeL Listener ( new Selection CaMeL Adapter ( ) { public void widget CaMeL Selected ( Selection CaMeL Event e ) { if ( selected CaMeL View != null ) { Workbench CaMeL Page page = bar . get CaMeL Window ( ) . get CaMeL Active CaMeL Workbench CaMeL Page ( ) ; if ( page != null ) { page . hide CaMeL View ( selected CaMeL View ) ; } } } } ) ; / / Set menu item enabl@@ ement etc based on whe@@ ther a view is selected Workbench CaMeL Page page = bar . get CaMeL Window ( ) . get CaMeL Active CaMeL Workbench CaMeL Page ( ) ; if ( restore CaMeL Item != null ) { if ( selected CaMeL View != null ) { restore CaMeL Item . set CaMeL Enabled ( page != null && page . is CaMeL Moveable ( selected CaMeL View ) ) ; } else { restore CaMeL Item . set CaMeL Enabled ( false ) ; } restore CaMeL Item . set CaMeL Selection ( true ) ; } if ( selected CaMeL View != null ) { close CaMeL Item . set CaMeL Enabled ( page != null && page . is CaMeL Closeable ( selected CaMeL View ) ) ; } else { close CaMeL Item . set CaMeL Enabled ( false ) ; } if ( orientation CaMeL Item != null ) { orientation CaMeL Item . set CaMeL Enabled ( selected CaMeL View != null ) ; if ( selected CaMeL View != null ) { / / Set the new orientation , but avoid re - sending the event to our own / / listener current CaMeL Orientation . set ( bar . get CaMeL Orientation ( selected CaMeL View ) , orientation CaMeL Change CaMeL Listener ) ; } } }	if ( selected CaMeL View != null ) { restore CaMeL Item . set CaMeL Enabled ( page != null && page . is CaMeL Moveable ( selected CaMeL View ) ) ; } else { restore CaMeL Item . set CaMeL Enabled ( false ) ;
if ( return CaMeL Value != null ) return return CaMeL Value ;  <CTX>  public Object get CaMeL Property CaMeL Value ( Object key ) { Object return CaMeL Value = super . get CaMeL Property CaMeL Value ( key ) ; if ( return CaMeL Value != null ) return return CaMeL Value ; if ( key . equals ( I CaMeL Resource CaMeL Property CaMeL Constants . P _ SIZE _ RES ) ) return get CaMeL Size CaMeL String ( ( I CaMeL File ) element ) ; return null ; }	if ( return CaMeL Value != null ) { return return CaMeL Value ; }
reuse CaMeL Editors CaMeL Threshold . get CaMeL Label CaMeL Control ( group CaMeL Composite ) . set CaMeL Enabled ( reuse CaMeL Editors . get CaMeL Selection ( ) ) ; reuse CaMeL Editors CaMeL Threshold . get CaMeL Text CaMeL Control ( group CaMeL Composite ) . set CaMeL Enabled ( reuse CaMeL Editors . get CaMeL Selection ( ) ) ;  <CTX>  public void widget CaMeL Selected ( Selection CaMeL Event e ) { reuse CaMeL Editors CaMeL Threshold . get CaMeL Label CaMeL Control ( group CaMeL Composite ) . set CaMeL Enabled ( reuse CaMeL Editors . get CaMeL Selection ( ) ) ; reuse CaMeL Editors CaMeL Threshold . get CaMeL Text CaMeL Control ( group CaMeL Composite ) . set CaMeL Enabled ( reuse CaMeL Editors . get CaMeL Selection ( ) ) ; }	reuse CaMeL Editors CaMeL Threshold . get CaMeL Label CaMeL Control ( editor CaMeL Reuse CaMeL Group ) . set CaMeL Enabled ( reuse CaMeL Editors . get CaMeL Selection ( ) ) ; reuse CaMeL Editors CaMeL Threshold . get CaMeL Text CaMeL Control ( editor CaMeL Reuse CaMeL Group ) . set CaMeL Enabled ( reuse CaMeL Editors . get CaMeL Selection ( ) ) ;
m _ outgoing CaMeL Events . clear ( ) ;  <CTX>  protected void flush CaMeL Events ( ) { synchronized ( m _ outgoing CaMeL Events ) { for ( Iterator itor = m _ outgoing CaMeL Events . iterator ( ) ; itor . has CaMeL Next ( ) ; ) ( ( Deferred CaMeL Event ) itor . next ( ) ) . dispatch ( m _ sessions ) ; m _ outgoing CaMeL Events . clear ( ) ; } }	m _ deferred CaMeL Events . clear ( ) ;
return ( i CaMeL Code [ pc ] << 8 ) + ( i CaMeL Code [ pc + 1 ] & 0 x CaMeL FF ) ;  <CTX>  private static int get CaMeL Short ( byte [ ] i CaMeL Code , int pc ) { return ( i CaMeL Code [ pc ] << 8 ) + ( i CaMeL Code [ pc + 1 ] & 0 x CaMeL FF ) ; }	return ( i CaMeL Code [ pc ] << 8 ) | ( i CaMeL Code [ pc + 1 ] & 0 x CaMeL FF ) ;
return Factory . create CaMeL Leaf CaMeL Element ( is CaMeL Type ? Java CaMeL Doc CaMeL Token CaMeL Type . DOC _ TYPE _ TEXT : Java CaMeL Doc CaMeL Token CaMeL Type . DOC _ REFERENCE _ TEXT , buffer , start CaMeL Offset ,  <CTX>  private Leaf CaMeL Element parse CaMeL Reference CaMeL Or CaMeL Type ( char [ ] buffer , int start CaMeL Offset , int end CaMeL Offset , boolean is CaMeL Type , int lexer CaMeL State ) { return Factory . create CaMeL Leaf CaMeL Element ( is CaMeL Type ? Java CaMeL Doc CaMeL Token CaMeL Type . DOC _ TYPE _ TEXT : Java CaMeL Doc CaMeL Token CaMeL Type . DOC _ REFERENCE _ TEXT , buffer , start CaMeL Offset , end CaMeL Offset , lexer CaMeL State , my CaMeL Context . get CaMeL Char CaMeL Table ( ) ) ; }	return Factory . create CaMeL Leaf CaMeL Element ( is CaMeL Type ? Java CaMeL Doc CaMeL Element CaMeL Type . DOC _ TYPE _ HOLDER : Java CaMeL Doc CaMeL Element CaMeL Type . DOC _ REFERENCE _ HOLDER , buffer , start CaMeL Offset ,
void load CaMeL Distribution ( String file CaMeL Path ) throws IO CaMeL Exception ;  <CTX>  void load CaMeL Distribution ( String file CaMeL Path ) throws IO CaMeL Exception ;	void load CaMeL Distribution ( File file ) throws IO CaMeL Exception ;
log . error ( ex ) ;  <CTX>  public void send CaMeL Clear CaMeL Panel CaMeL Msg ( ) { int tmp [ ] = new int [ 1 ] ; tmp [ 0 ] = 0 ; Draw CaMeL Command comm = new Draw CaMeL Command ( Draw CaMeL Command . CLEAR ) ; Object CaMeL Output CaMeL Stream os ; try { out . reset ( ) ; os = new Object CaMeL Output CaMeL Stream ( out ) ; os . write CaMeL Object ( comm ) ; os . flush ( ) ; channel . send ( new Message ( null , null , out . to CaMeL Byte CaMeL Array ( ) ) ) ; } catch ( Exception ex ) { log . error ( ex ) ; } }	System . err . println ( ex ) ;
if ( set CaMeL Change CaMeL Listeners == null ) { boolean had CaMeL Listeners = has CaMeL Listeners ( ) ; set CaMeL Change CaMeL Listeners = listener ; if ( ! had CaMeL Listeners ) { first CaMeL Listener CaMeL Added ( ) ; } return ; } Collection listener CaMeL List ; if ( set CaMeL Change CaMeL Listeners instanceof Collection ) { listener CaMeL List = ( Collection ) set CaMeL Change CaMeL Listeners ; } else { I CaMeL Set CaMeL Change CaMeL Listener l = ( I CaMeL Set CaMeL Change CaMeL Listener ) set CaMeL Change CaMeL Listeners ; listener CaMeL List = new Array CaMeL List ( ) ; listener CaMeL List . add ( l ) ; set CaMeL Change CaMeL Listeners = listener CaMeL List ; } if ( listener CaMeL List . size ( ) > 16 ) { Hash CaMeL Set listener CaMeL Set = new Hash CaMeL Set ( ) ; listener CaMeL Set . add CaMeL All ( listener CaMeL List ) ; set CaMeL Change CaMeL Listeners = listener CaMeL List ; } listener CaMeL List . add ( listener ) ;  <CTX>  public void add CaMeL Set CaMeL Change CaMeL Listener ( I CaMeL Set CaMeL Change CaMeL Listener listener ) { if ( set CaMeL Change CaMeL Listeners == null ) { boolean had CaMeL Listeners = has CaMeL Listeners ( ) ; set CaMeL Change CaMeL Listeners = listener ; if ( ! had CaMeL Listeners ) { first CaMeL Listener CaMeL Added ( ) ; } return ; } Collection listener CaMeL List ; if ( set CaMeL Change CaMeL Listeners instanceof Collection ) { listener CaMeL List = ( Collection ) set CaMeL Change CaMeL Listeners ; } else { I CaMeL Set CaMeL Change CaMeL Listener l = ( I CaMeL Set CaMeL Change CaMeL Listener ) set CaMeL Change CaMeL Listeners ; listener CaMeL List = new Array CaMeL List ( ) ; listener CaMeL List . add ( l ) ; set CaMeL Change CaMeL Listeners = listener CaMeL List ; } if ( listener CaMeL List . size ( ) > 16 ) { Hash CaMeL Set listener CaMeL Set = new Hash CaMeL Set ( ) ; listener CaMeL Set . add CaMeL All ( listener CaMeL List ) ; set CaMeL Change CaMeL Listeners = listener CaMeL List ; } listener CaMeL List . add ( listener ) ; }	change CaMeL Support . add CaMeL Listener ( Set CaMeL Change CaMeL Event . TYPE , listener ) ;
} ) ;  <CTX>  public Properties CaMeL Reference CaMeL Manager ( Project project , Properties CaMeL Files CaMeL Manager properties CaMeL Files CaMeL Manager , File CaMeL Type CaMeL Manager file CaMeL Type CaMeL Manager ) { my CaMeL Project = project ; my CaMeL Properties CaMeL Files CaMeL Manager = properties CaMeL Files CaMeL Manager ; file CaMeL Type CaMeL Manager . add CaMeL File CaMeL Type CaMeL Listener ( new File CaMeL Type CaMeL Listener ( ) { public void before CaMeL File CaMeL Types CaMeL Changed ( File CaMeL Type CaMeL Event event ) { } public void file CaMeL Types CaMeL Changed ( File CaMeL Type CaMeL Event event ) { Startup CaMeL Manager . get CaMeL Instance ( my CaMeL Project ) . run CaMeL When CaMeL Project CaMeL Is CaMeL Initialized ( new Runnable ( ) { public void run ( ) { refresh CaMeL All CaMeL Prop CaMeL Files CaMeL In CaMeL Project ( ) ; } } ) ; } } ) ; }	} ; file CaMeL Type CaMeL Manager . add CaMeL File CaMeL Type CaMeL Listener ( my CaMeL File CaMeL Type CaMeL Changed CaMeL Listener ) ;
source CaMeL File CaMeL Paths . add ( path ) ;  <CTX>  public void add CaMeL Source CaMeL File CaMeL Path ( String path ) { change ( ) ; source CaMeL File CaMeL Paths . add ( path ) ; }	source CaMeL File CaMeL Paths . add ( get CaMeL Corrected CaMeL Path ( path ) ) ;
} * /  <CTX>  public Double compute CaMeL E@@ cts CaMeL Credits ( ) { Double result = 0 . 0 ; if ( this . get CaMeL E@@ cts CaMeL Credits ( ) != null ) { result = this . get CaMeL E@@ cts CaMeL Credits ( ) ; } / * else if ( this . get CaMeL Comp@@ e@@ tence CaMeL Course ( ) != null && this . get CaMeL Comp@@ e@@ tence CaMeL Course ( ) . get CaMeL E@@ cts CaMeL Credits ( ) != null ) { result = this . get CaMeL Comp@@ e@@ tence CaMeL Course ( ) . get CaMeL E@@ cts CaMeL Credits ( ) ; } * / return result ; }	}
text CaMeL Area 1 . set CaMeL Text ( list CaMeL Names . get CaMeL Selected CaMeL Item ( ) ) ;  <CTX>  void list CaMeL Names _ Item CaMeL State CaMeL Changed ( java . awt . event . Item CaMeL Event event ) { String cur = list CaMeL Names . get CaMeL Selected CaMeL Item ( ) ; if ( current CaMeL Action == VIEW@@ K@@ NO@@ WN@@ PERS@@ ONS ) text CaMeL Area 1 . set CaMeL Text ( my CaMeL Agent . get CaMeL Person ( cur ) . to CaMeL String ( ) ) ; else if ( current CaMeL Action == VIEW@@ K@@ NO@@ WN@@ DF ) text CaMeL Area 1 . set CaMeL Text ( list CaMeL Names . get CaMeL Selected CaMeL Item ( ) ) ; }	text CaMeL Area 1 . set CaMeL Text ( cur ) ;
Client CaMeL Key CaMeL Block real CaMeL Get CaMeL Key ( Client CaMeL Key key , boolean local CaMeL Only , boolean cache ) throws Low CaMeL Level CaMeL Get CaMeL Exception ;  <CTX>  Client CaMeL Key CaMeL Block real CaMeL Get CaMeL Key ( Client CaMeL Key key , boolean local CaMeL Only , boolean cache ) throws Low CaMeL Level CaMeL Get CaMeL Exception ;	Client CaMeL Key CaMeL Block real CaMeL Get CaMeL Key ( Client CaMeL Key key , boolean local CaMeL Only , boolean cache , boolean ignore CaMeL Store ) throws Low CaMeL Level CaMeL Get CaMeL Exception ;
if ( f CaMeL Update CaMeL Job == null || f CaMeL Update CaMeL Job . get CaMeL State ( ) != Job . RUNNING ) {  <CTX>  public void set CaMeL Selection ( int [ ] selection ) { if ( selection == null || selection . length == 0 ) f CaMeL List . deselect CaMeL All ( ) ; else { / / If there is a current working update defer the setting if ( f CaMeL Update CaMeL Job == null || f CaMeL Update CaMeL Job . get CaMeL State ( ) != Job . RUNNING ) { f CaMeL List . set CaMeL Selection ( selection ) ; f CaMeL List . notify CaMeL Listeners ( SWT . Selection , new Event ( ) ) ; } else f CaMeL Update CaMeL Job . update CaMeL Selection ( selection ) ; } }	if ( f CaMeL Update CaMeL Job == null ) {
return result ;  <CTX>  public Object resolve CaMeL Instance ( Pico CaMeL Container container , Component CaMeL Adapter adapter , Class expected CaMeL Type ) throws Pico CaMeL Instantiation CaMeL Exception { / / type check is done in is CaMeL Resolvable Object result = null ; if ( component CaMeL Key != null ) { result = container . get CaMeL Component CaMeL Instance ( component CaMeL Key ) ; } else { result = container . get CaMeL Component CaMeL Instance CaMeL Of CaMeL Type ( expected CaMeL Type ) ; } return result ; }	return null ;
if ( descriptors [ j ] . get CaMeL Id ( ) == Meta CaMeL Model CaMeL Util  <CTX>  protected I CaMeL Label CaMeL Provider get CaMeL Label CaMeL Provider ( Object property CaMeL Id ) { I CaMeL Property CaMeL Source property CaMeL Source = properties CaMeL Provider . get CaMeL Property CaMeL Source ( get CaMeL Single CaMeL Input ( ) ) ; I CaMeL Label CaMeL Provider label CaMeL Provider = null ; Notation CaMeL Property CaMeL Descriptor pd CaMeL Notation = null ; I CaMeL Property CaMeL Descriptor [ ] descriptors = null ; if ( null != property CaMeL Source ) { descriptors = property CaMeL Source . get CaMeL Property CaMeL Descriptors ( ) ; for ( int i = 0 ; i < descriptors . length ; i ++ ) { if ( descriptors [ i ] . get CaMeL Id ( ) == Notation CaMeL Package . e CaMeL INSTANCE . get CaMeL View _ Styles ( ) ) { pd CaMeL Notation = ( Notation CaMeL Property CaMeL Descriptor ) descriptors [ i ] ; break ; } } } if ( null != pd CaMeL Notation ) { property CaMeL Source = ( I CaMeL Property CaMeL Source ) pd CaMeL Notation . get CaMeL Property CaMeL Value ( ) ; descriptors = property CaMeL Source . get CaMeL Property CaMeL Descriptors ( ) ; for ( int j = 0 ; j < descriptors . length ; j ++ ) { if ( descriptors [ j ] . get CaMeL Id ( ) == Meta CaMeL Model CaMeL Util . get CaMeL Element ( property CaMeL Id . to CaMeL String ( ) ) ) { label CaMeL Provider = descriptors [ j ] . get CaMeL Label CaMeL Provider ( ) ; break ; } } } return label CaMeL Provider ; }	if ( descriptors [ j ] . get CaMeL Id ( ) == Package CaMeL Util
if ( source CaMeL Part instanceof I CaMeL Show CaMeL In CaMeL Target CaMeL List ) { return ( I CaMeL Show CaMeL In CaMeL Target CaMeL List ) source CaMeL Part ; } Object o = source CaMeL Part . get CaMeL Adapter ( I CaMeL Show CaMeL In CaMeL Target CaMeL List . class ) ; if ( o instanceof I CaMeL Show CaMeL In CaMeL Target CaMeL List ) { return ( I CaMeL Show CaMeL In CaMeL Target CaMeL List ) o ; } return null ;  <CTX>  private I CaMeL Show CaMeL In CaMeL Target CaMeL List get CaMeL Show CaMeL In CaMeL Target CaMeL List ( I CaMeL Workbench CaMeL Part source CaMeL Part ) { if ( source CaMeL Part instanceof I CaMeL Show CaMeL In CaMeL Target CaMeL List ) { return ( I CaMeL Show CaMeL In CaMeL Target CaMeL List ) source CaMeL Part ; } Object o = source CaMeL Part . get CaMeL Adapter ( I CaMeL Show CaMeL In CaMeL Target CaMeL List . class ) ; if ( o instanceof I CaMeL Show CaMeL In CaMeL Target CaMeL List ) { return ( I CaMeL Show CaMeL In CaMeL Target CaMeL List ) o ; } return null ; }	return ( I CaMeL Show CaMeL In CaMeL Target CaMeL List ) Util . get CaMeL Adapter ( source CaMeL Part , I CaMeL Show CaMeL In CaMeL Target CaMeL List . class ) ;
Set < Language > owners = S CaMeL Model CaMeL Repository . get CaMeL Instance ( ) . get CaMeL Owners ( md , Language . class ) ; for ( Language l : my CaMeL Languages ) { if ( owners . contains ( l ) ) return l ; } return null ;  <CTX>  public Language get CaMeL Language CaMeL For CaMeL Model ( S CaMeL Model CaMeL Descriptor md ) { Set < Language > owners = S CaMeL Model CaMeL Repository . get CaMeL Instance ( ) . get CaMeL Owners ( md , Language . class ) ; for ( Language l : my CaMeL Languages ) { if ( owners . contains ( l ) ) return l ; } return null ; }	Set < Language > owners = S CaMeL Model CaMeL Repository . get CaMeL Instance ( ) . get CaMeL Owners ( md , Language . class ) ; for ( Language l : my CaMeL Languages ) { if ( owners . contains ( l ) ) return l ;
return ( Change CaMeL Listener [ ] ) change CaMeL Listener CaMeL List . get CaMeL Listener CaMeL List ( ) ;  <CTX>  public Change CaMeL Listener [ ] get CaMeL Change CaMeL Listeners ( ) { return ( Change CaMeL Listener [ ] ) change CaMeL Listener CaMeL List . get CaMeL Listener CaMeL List ( ) ; }	return ( Change CaMeL Listener [ ] ) listener CaMeL List . get CaMeL Listeners ( Change CaMeL Listener . class ) ;
super . set CaMeL Input CaMeL Format ( new Instances ( instance CaMeL Info , 0 ) ) ; m _ Class CaMeL Attribute = instance CaMeL Info . class CaMeL Attribute ( ) ; m _ Random = new Random ( m _ Seed ) ; int num CaMeL Classes = instance CaMeL Info . num CaMeL Classes ( ) ; m _ Converter = new double [ num CaMeL Classes ] ; m _ Class CaMeL Counts = new double [ num CaMeL Classes ] ; return false ; }  <CTX>  public boolean set CaMeL Input CaMeL Format ( Instances instance CaMeL Info ) throws Exception { super . set CaMeL Input CaMeL Format ( new Instances ( instance CaMeL Info , 0 ) ) ; m _ Class CaMeL Attribute = instance CaMeL Info . class CaMeL Attribute ( ) ; m _ Random = new Random ( m _ Seed ) ; int num CaMeL Classes = instance CaMeL Info . num CaMeL Classes ( ) ; m _ Converter = new double [ num CaMeL Classes ] ; m _ Class CaMeL Counts = new double [ num CaMeL Classes ] ; return false ; }	int num CaMeL Classes = instance CaMeL Info . num CaMeL Classes ( ) ; m _ Converter = new double [ num CaMeL Classes ] ; m _ Class CaMeL Counts = new double [ num CaMeL Classes ] ; return false ; }
if ( working CaMeL Set . is CaMeL Visible ( ) )  <CTX>  public I CaMeL Working CaMeL Set [ ] get CaMeL Working CaMeL Sets ( ) { Sorted CaMeL Set visible CaMeL Subset = new Tree CaMeL Set ( Working CaMeL Set CaMeL Comparator . INSTANCE ) ; for ( Iterator i = working CaMeL Sets . iterator ( ) ; i . has CaMeL Next ( ) ; ) { I CaMeL Working CaMeL Set working CaMeL Set = ( I CaMeL Working CaMeL Set ) i . next ( ) ; if ( working CaMeL Set . is CaMeL Visible ( ) ) visible CaMeL Subset . add ( working CaMeL Set ) ; } return ( I CaMeL Working CaMeL Set [ ] ) visible CaMeL Subset . to CaMeL Array ( new I CaMeL Working CaMeL Set [ visible CaMeL Subset . size ( ) ] ) ; }	if ( working CaMeL Set . is CaMeL Visible ( ) ) {
if ( protocol == null ) {  <CTX>  public boolean handles CaMeL Protocol ( String protocol ) { if ( protocol == null ) { return false ; } for ( int i = 0 ; i < protocols . length ; i ++ ) { if ( protocol . equals CaMeL Ignore CaMeL Case ( protocols [ i ] ) ) { return true ; } } return false ; }	if ( protocol == null || protocols == null ) {
return get CaMeL Message CaMeL Business ( ) . get CaMeL Number CaMeL Of CaMeL Messages ( message CaMeL Code . get CaMeL Code ( ) , iwc . get CaMeL Current CaMeL User ( ) ) ;  <CTX>  protected int get CaMeL Message CaMeL Count ( IW CaMeL Context iwc ) { try { return get CaMeL Message CaMeL Business ( ) . get CaMeL Number CaMeL Of CaMeL Messages ( message CaMeL Code . get CaMeL Code ( ) , iwc . get CaMeL Current CaMeL User ( ) ) ; } catch ( IDO CaMeL Exception ie ) { ie . print CaMeL Stack CaMeL Trace ( ) ; return 0 ; } catch ( Remote CaMeL Exception re ) { log ( re ) ; return 0 ; } }	return get CaMeL Message CaMeL Business ( ) . get CaMeL Number CaMeL Of CaMeL Messages ( message CaMeL Type , iwc . get CaMeL Current CaMeL User ( ) ) ;
Object invoke ( Object component , U@@ MO CaMeL Event CaMeL Context context , Method method ) throws Invocation CaMeL Target CaMeL Exception ,  <CTX>  Object invoke ( Object component , U@@ MO CaMeL Event CaMeL Context context , Method method ) throws Invocation CaMeL Target CaMeL Exception , Illegal CaMeL Access CaMeL Exception , Transformer CaMeL Exception ;	Object invoke ( Object component , U@@ MO CaMeL Event CaMeL Context context ) throws Invocation CaMeL Target CaMeL Exception ,
return Component CaMeL Package . e CaMeL INSTANCE . get CaMeL Grid ( ) ;  <CTX>  protected E CaMeL Class e CaMeL Static CaMeL Class ( ) { return Component CaMeL Package . e CaMeL INSTANCE . get CaMeL Grid ( ) ; }	return Component CaMeL Package . Literals . GRID ;
Entry entry = ( Entry ) delegate CaMeL Get ( i ) ; if ( validator . is CaMeL Valid ( entry . get CaMeL E CaMeL Structural CaMeL Feature ( ) ) )  <CTX>  public Object [ ] to CaMeL Array ( E CaMeL Structural CaMeL Feature feature ) { List result = new Basic CaMeL E CaMeL List ( ) ; Feature CaMeL Map CaMeL Util . Validator validator = Feature CaMeL Map CaMeL Util . get CaMeL Validator ( owner . e CaMeL Class ( ) , feature ) ; for ( int i = 0 , size = delegate CaMeL Size ( ) ; i < size ; ++ i ) { Entry entry = ( Entry ) delegate CaMeL Get ( i ) ; if ( validator . is CaMeL Valid ( entry . get CaMeL E CaMeL Structural CaMeL Feature ( ) ) ) { result . add ( entry . get CaMeL Value ( ) ) ; } } return result . to CaMeL Array ( ) ; }	for ( int i = 0 , size = delegate CaMeL Size ( ) ; i < size ; ++ i )
String [ ] _ poa _ names = new String [ po@@ as . size ( ) ] ; Enumeration _ poa _ enum = po@@ as . elements ( ) ;  <CTX>  protected String [ ] get CaMeL POA CaMeL Names ( ) { / / not synchronizing here since this method is only called / / prior to destruc@@ ting this object . String [ ] _ poa _ names = new String [ po@@ as . size ( ) ] ; Enumeration _ poa _ enum = po@@ as . elements ( ) ; int _ i = 0 ; while ( _ poa _ enum . has CaMeL More CaMeL Elements ( ) ) _ poa _ names [ _ i ++ ] = ( ( Im CaMeL R@@ POA CaMeL Info ) _ poa _ enum . next CaMeL Element ( ) ) . name ; return _ poa _ names ; }	final String [ ] names ; synchronized ( po@@ as ) { Im CaMeL R@@ POA CaMeL Info [ ] _ po@@ as = ( Im CaMeL R@@ POA CaMeL Info [ ] ) po@@ as . to CaMeL Array ( new POA CaMeL Info [ po@@ as . size ( ) ] ) ;
int height = ( end + 1 ) * fm . get CaMeL Height ( ) ;  <CTX>  public void invalidate CaMeL Screen CaMeL Line CaMeL Range ( int start , int end ) { Font CaMeL Metrics fm = painter . get CaMeL Font CaMeL Metrics ( ) ; int y = start * fm . get CaMeL Height ( ) ; int height = ( end + 1 ) * fm . get CaMeL Height ( ) ; painter . repaint ( 0 , y , painter . get CaMeL Width ( ) , height ) ; gutter . repaint ( 0 , y , gutter . get CaMeL Width ( ) , height ) ; } / / } } }	int height = ( end - start + 1 ) * fm . get CaMeL Height ( ) ;
String str = Ruby CaMeL String . string CaMeL Value ( target ) . get CaMeL Value ( ) ;  <CTX>  public int search ( I CaMeL Ruby CaMeL Object target , int pos ) { String str = Ruby CaMeL String . string CaMeL Value ( target ) . get CaMeL Value ( ) ; if ( pos > str . length ( ) ) { return - 1 ; } recompile CaMeL If CaMeL Needed ( ) ; / / If nothing match then nil will be returned I CaMeL Ruby CaMeL Object result = match ( str , pos ) ; get CaMeL Runtime ( ) . get CaMeL Current CaMeL Context ( ) . set CaMeL Backref ( result ) ; / / If nothing match then - 1 will be returned return result instanceof Ruby CaMeL Match CaMeL Data ? ( ( Ruby CaMeL Match CaMeL Data ) result ) . match CaMeL Start CaMeL Position ( ) : - 1 ; }	String str = Ruby CaMeL String . string CaMeL Value ( target ) . to CaMeL String ( ) ;
return m _ launcher CaMeL Class ;  <CTX>  public String get CaMeL Launcher CaMeL Class ( ) { return m _ launcher CaMeL Class ; }	if ( m _ launcher CaMeL Class != null ) { return m _ launcher CaMeL Class ; } else { return C _ UNKNOWN _ LAUNCHER ; }
Message CaMeL Dialog . open CaMeL Error ( window . get CaMeL Shell ( ) , PAGE _ PROBLEMS _ TITLE , e . get CaMeL Message ( ) ) ;  <CTX>  private static void open CaMeL In CaMeL New CaMeL Page ( I CaMeL Perspective CaMeL Descriptor desc ) { I CaMeL Workbench CaMeL Window window = Platform CaMeL UI . get CaMeL Workbench ( ) . get CaMeL Active CaMeL Workbench CaMeL Window ( ) ; if ( window == null ) return ; / / If the active perspective is the same , then reuse it I CaMeL Workbench CaMeL Page page = window . get CaMeL Active CaMeL Page ( ) ; if ( page != null ) { I CaMeL Perspective CaMeL Descriptor per@@ sp = page . get CaMeL Perspective ( ) ; if ( per@@ sp != null && per@@ sp . get CaMeL Id ( ) . equals ( desc . get CaMeL Id ( ) ) ) return ; } / / If the perspective is already open , then reuse it . I CaMeL Workbench CaMeL Page [ ] pages = window . get CaMeL Pages ( ) ; for ( int i = 0 ; i < pages . length ; i ++ ) { I CaMeL Perspective CaMeL Descriptor per@@ sp = pages [ i ] . get CaMeL Perspective ( ) ; if ( per@@ sp != null && per@@ sp . get CaMeL Id ( ) . equals ( desc . get CaMeL Id ( ) ) ) { window . set CaMeL Active CaMeL Page ( pages [ i ] ) ; return ; } } / / Open the page . try { window . open CaMeL Page ( desc . get CaMeL Id ( ) , Resources CaMeL Plugin . get CaMeL Workspace ( ) . get CaMeL Root ( ) ) ; } catch ( Workbench CaMeL Exception e ) { Message CaMeL Dialog . open CaMeL Error ( window . get CaMeL Shell ( ) , PAGE _ PROBLEMS _ TITLE , e . get CaMeL Message ( ) ) ; } }	Error CaMeL Dialog . open CaMeL Error ( window . get CaMeL Shell ( ) , PAGE _ PROBLEMS _ TITLE , e . get CaMeL Message ( ) , e . get CaMeL Status ( ) ) ;
Iterator remo@@ vee = _ q CaMeL Guids CaMeL To CaMeL Remove . iterator ( ) ; while ( remo@@ vee . has CaMeL Next ( ) ) { GUID curr CaMeL Guid = ( GUID ) remo@@ vee . next ( ) ;  <CTX>  private void purge CaMeL Guids CaMeL Internal ( ) { synchronized ( _ q CaMeL Guids CaMeL To CaMeL Remove ) { Iterator remo@@ vee = _ q CaMeL Guids CaMeL To CaMeL Remove . iterator ( ) ; while ( remo@@ vee . has CaMeL Next ( ) ) { GUID curr CaMeL Guid = ( GUID ) remo@@ vee . next ( ) ; _ queries . remove ( curr CaMeL Guid ) ; } } }	for ( GUID curr CaMeL Guid : _ q CaMeL Guids CaMeL To CaMeL Remove )
return this . type ;  <CTX>  public String get CaMeL Type ( ) { return this . type ; }	return this . type . get CaMeL Name ( ) ;
return connection . maxrows ;  <CTX>  public int get CaMeL Max CaMeL Rows ( ) throws SQL CaMeL Exception { return connection . maxrows ; }	return maxrows ;
return Collections . EMPTY _ LIST ;  <CTX>  public List child CaMeL Nodes ( ) { return Collections . EMPTY _ LIST ; }	return EMPTY _ LIST ;
submission = new Handler CaMeL Submission ( null , dialog . get CaMeL Shell ( ) , null ,  <CTX>  private void register CaMeL Key@@ bindings ( I CaMeL Action action ) { I CaMeL Handler handler = new Action CaMeL Handler ( action ) ; submission = new Handler CaMeL Submission ( null , dialog . get CaMeL Shell ( ) , null , action . get CaMeL Action CaMeL Definition CaMeL Id ( ) , handler , Priority . MEDIUM ) ; Platform CaMeL UI . get CaMeL Workbench ( ) . get CaMeL Command CaMeL Support ( ) . add CaMeL Handler CaMeL Submission ( submission ) ; }	Handler CaMeL Submission submission = new Handler CaMeL Submission ( null , dialog . get CaMeL Shell ( ) , null ,
String get CaMeL Script CaMeL Class CaMeL Name ( String function CaMeL Name , boolean primary )  <CTX>  String get CaMeL Script CaMeL Class CaMeL Name ( String function CaMeL Name , boolean primary ) { String result = name CaMeL Helper . get CaMeL Script CaMeL Class CaMeL Name ( function CaMeL Name , primary ) ; / / We w@@ ish to produce unique class names between calls to reset ( ) / / we dis@@ reg@@ ard case since we may write the class names to file / / systems that are case in@@ sensitive String lower CaMeL Result = result . to CaMeL Lower CaMeL Case ( ) ; String base = lower CaMeL Result ; int count = 0 ; while ( class CaMeL Names . has ( lower CaMeL Result ) ) { lower CaMeL Result = base ++ ++ ++ count ; } class CaMeL Names . put ( lower CaMeL Result , 0 ) ; return count == 0 ? result : ( result + count ) ; }	private String get CaMeL Script CaMeL Class CaMeL Name ( String function CaMeL Name , boolean primary )
return _ send CaMeL String CaMeL Parameters CaMeL As CaMeL Unicode ;  <CTX>  public boolean get CaMeL Send CaMeL String CaMeL Parameters CaMeL As CaMeL Unicode ( ) { return _ send CaMeL String CaMeL Parameters CaMeL As CaMeL Unicode ; }	return send CaMeL String CaMeL Parameters CaMeL As CaMeL Unicode ;
I CaMeL Style area CaMeL Style = root . get CaMeL Style ( ) ; set CaMeL Offset CaMeL X ( get CaMeL Dimension CaMeL Value ( area CaMeL Style . get CaMeL Property ( Style CaMeL Constants . STYLE _ BORDER _ LEFT _ WIDTH ) ) + get CaMeL Dimension CaMeL Value ( area CaMeL Style . get CaMeL Property ( Style CaMeL Constants . STYLE _ PADDING _ LEFT ) ) ) ; set CaMeL Offset CaMeL Y ( is CaMeL First ? ( get CaMeL Dimension CaMeL Value ( area CaMeL Style . get CaMeL Property ( Style CaMeL Constants . STYLE _ BORDER _ TOP _ WIDTH ) ) + get CaMeL Dimension CaMeL Value ( area CaMeL Style . get CaMeL Property ( Style CaMeL Constants . STYLE _ PADDING _ TOP ) ) ) : 0 ) ;  <CTX>  protected void new CaMeL Context ( ) { create CaMeL Root ( ) ; / / validate CaMeL Box CaMeL Property ( root . get CaMeL Style ( ) ) ; if ( null != parent ) { / / support user defined width int max = parent . get CaMeL Max CaMeL Ava CaMeL Width ( ) - parent . get CaMeL Current CaMeL IP ( ) ; if ( content != null ) { int specified CaMeL Width = get CaMeL Dimension CaMeL Value ( content . get CaMeL Width ( ) ) ; if ( specified CaMeL Width > 0 ) { max = Math . min ( max , specified CaMeL Width ) ; } } root . set CaMeL Allocated CaMeL Width ( max ) ; set CaMeL Max CaMeL Ava CaMeL Width ( root . get CaMeL Content CaMeL Width ( ) ) ; root . set CaMeL Allocated CaMeL Height ( parent . get CaMeL Max CaMeL Ava CaMeL Height ( ) - parent . get CaMeL Current CaMeL BP ( ) ) ; set CaMeL Max CaMeL Ava CaMeL Height ( root . get CaMeL Content CaMeL Height ( ) ) ; } / / initialize offset CaMeL X and offset CaMeL Y I CaMeL Style area CaMeL Style = root . get CaMeL Style ( ) ; set CaMeL Offset CaMeL X ( get CaMeL Dimension CaMeL Value ( area CaMeL Style . get CaMeL Property ( Style CaMeL Constants . STYLE _ BORDER _ LEFT _ WIDTH ) ) + get CaMeL Dimension CaMeL Value ( area CaMeL Style . get CaMeL Property ( Style CaMeL Constants . STYLE _ PADDING _ LEFT ) ) ) ; set CaMeL Offset CaMeL Y ( is CaMeL First ? ( get CaMeL Dimension CaMeL Value ( area CaMeL Style . get CaMeL Property ( Style CaMeL Constants . STYLE _ BORDER _ TOP _ WIDTH ) ) + get CaMeL Dimension CaMeL Value ( area CaMeL Style . get CaMeL Property ( Style CaMeL Constants . STYLE _ PADDING _ TOP ) ) ) : 0 ) ; / / can be removed ? set CaMeL Current CaMeL BP ( 0 ) ; set CaMeL Current CaMeL IP ( 0 ) ; }	set CaMeL Offset CaMeL X ( root . get CaMeL Content CaMeL X ( ) ) ; set CaMeL Offset CaMeL Y ( is CaMeL First ? root . get CaMeL Content CaMeL Y ( ) : 0 ) ;
} else extend CaMeL Button . set CaMeL Enabled ( false ) ;  <CTX>  private void update CaMeL Extend CaMeL Button CaMeL State ( ) { Path CaMeL Variables CaMeL Group . Path CaMeL Variable CaMeL Element [ ] selection = path CaMeL Variables CaMeL Group . get CaMeL Selection ( ) ; Button extend CaMeL Button = get CaMeL Button ( EXTEND _ ID ) ; if ( extend CaMeL Button == null ) return ; if ( selection . length == 1 ) { I CaMeL File CaMeL Info info = IDE CaMeL Resource CaMeL Info CaMeL Utils . get CaMeL File CaMeL Info ( selection [ 0 ] . path ) ; if ( info . exists ( ) && info . is CaMeL Directory ( ) ) extend CaMeL Button . set CaMeL Enabled ( true ) ; else extend CaMeL Button . set CaMeL Enabled ( false ) ; } else extend CaMeL Button . set CaMeL Enabled ( false ) ; }	} else { extend CaMeL Button . set CaMeL Enabled ( false ) ; }
builder = new Tomcat CaMeL Module CaMeL Builder ( null , false , tomcat CaMeL Container CaMeL Object CaMeL Name , null , null , kernel ) ;  <CTX>  protected void set CaMeL Up ( ) throws Exception { builder = new Tomcat CaMeL Module CaMeL Builder ( null , false , tomcat CaMeL Container CaMeL Object CaMeL Name , null , null , kernel ) ; }	builder = new Tomcat CaMeL Module CaMeL Builder ( null , false , tomcat CaMeL Container CaMeL Object CaMeL Name , null , null ) ;
return default CaMeL Value CaMeL Callback != null && args . length > 0 ? default CaMeL Value CaMeL Callback . execute ( this , args ) : get CaMeL Runtime ( ) . get CaMeL Nil ( ) ;  <CTX>  public I CaMeL Ruby CaMeL Object get CaMeL Default CaMeL Value ( I CaMeL Ruby CaMeL Object [ ] args ) { return default CaMeL Value CaMeL Callback != null && args . length > 0 ? default CaMeL Value CaMeL Callback . execute ( this , args ) : get CaMeL Runtime ( ) . get CaMeL Nil ( ) ; }	if ( default CaMeL Value CaMeL Callback == null || ( args . length == 0 && ! captured CaMeL Default CaMeL Proc . is CaMeL Nil ( ) ) ) { return get CaMeL Runtime ( ) . get CaMeL Nil ( ) ; } return default CaMeL Value CaMeL Callback . execute ( this , args ) ;
start = Math . max ( 0 , start ) ; end = Math . min ( get CaMeL Length ( ) , end ) ;  <CTX>  public void select ( int start , int end ) { start = Math . max ( 0 , start ) ; end = Math . min ( get CaMeL Length ( ) , end ) ; if ( start <= end ) { selection CaMeL Start = start ; selection CaMeL End = end ; bias CaMeL Left = false ; } else { selection CaMeL Start = end ; selection CaMeL End = start ; bias CaMeL Left = true ; } int old CaMeL Selection CaMeL Start CaMeL Line = selection CaMeL Start CaMeL Line ; int old CaMeL Selection CaMeL End CaMeL Line = selection CaMeL End CaMeL Line ; selection CaMeL Start CaMeL Line = get CaMeL Line CaMeL Of CaMeL Offset ( selection CaMeL Start ) ; selection CaMeL End CaMeL Line = get CaMeL Line CaMeL Of CaMeL Offset ( selection CaMeL End ) ; text CaMeL Area . get CaMeL Painter ( ) . _ invalidate CaMeL Line CaMeL Range ( Math . min ( old CaMeL Selection CaMeL Start CaMeL Line , selection CaMeL Start CaMeL Line ) , Math . max ( old CaMeL Selection CaMeL End CaMeL Line , selection CaMeL End CaMeL Line ) ) ; int line = get CaMeL Caret CaMeL Line ( ) ; int line CaMeL Start = get CaMeL Line CaMeL Start CaMeL Offset ( line ) ; if ( ! text CaMeL Area . scroll CaMeL To ( line , get CaMeL Caret CaMeL Position ( ) - start ) ) text CaMeL Area . get CaMeL Painter ( ) . repaint ( ) ; }	int new CaMeL Start , new CaMeL End ; boolean new CaMeL Bias ;
get CaMeL Structured CaMeL Viewer ( ) . refresh ( ) ;  <CTX>  public void refresh ( ) { if ( is CaMeL Available ( ) ) { get CaMeL View ( ) . show CaMeL Viewer ( ) ; get CaMeL Structured CaMeL Viewer ( ) . refresh ( ) ; } }	get CaMeL Structured CaMeL Viewer ( ) . refresh ( element ) ;
return new Tag CaMeL Lib CaMeL Meta CaMeL Class ( meta CaMeL Registry , the CaMeL Class , meta ) ;  <CTX>  public static Tag CaMeL Lib CaMeL Meta CaMeL Class get CaMeL Tag CaMeL Lib CaMeL Instance ( Class the CaMeL Class ) throws Introspection CaMeL Exception { Meta CaMeL Class CaMeL Registry meta CaMeL Registry = Invoker CaMeL Helper . get CaMeL Instance ( ) . get CaMeL Meta CaMeL Registry ( ) ; Meta CaMeL Class meta = meta CaMeL Registry . get CaMeL Meta CaMeL Class ( the CaMeL Class ) ; return new Tag CaMeL Lib CaMeL Meta CaMeL Class ( meta CaMeL Registry , the CaMeL Class , meta ) ; }	Tag CaMeL Lib CaMeL Meta CaMeL Class m = new Tag CaMeL Lib CaMeL Meta CaMeL Class ( meta CaMeL Registry , the CaMeL Class , meta ) ; m . initialise ( ) ; return m ;
Common CaMeL Drop CaMeL Adapter CaMeL Descriptor a CaMeL Drop CaMeL Descriptor ) { drop CaMeL Descriptors . put ( a CaMeL Content CaMeL Descriptor , a CaMeL Drop CaMeL Descriptor ) ;  <CTX>  private void add CaMeL Common CaMeL Drop CaMeL Adapter ( I CaMeL Navigator CaMeL Content CaMeL Descriptor a CaMeL Content CaMeL Descriptor , Common CaMeL Drop CaMeL Adapter CaMeL Descriptor a CaMeL Drop CaMeL Descriptor ) { drop CaMeL Descriptors . put ( a CaMeL Content CaMeL Descriptor , a CaMeL Drop CaMeL Descriptor ) ; }	Common CaMeL Drop CaMeL Adapter CaMeL Descriptor a CaMeL Drop CaMeL Descriptor ) { get CaMeL Drop CaMeL Descriptors ( a CaMeL Content CaMeL Descriptor ) . add ( a CaMeL Drop CaMeL Descriptor ) ;
User CaMeL Choice . NAME _ PROP , choice . get CaMeL Name ( ) , false ) ;  <CTX>  protected void write CaMeL User CaMeL Property CaMeL Defns ( Design CaMeL Element obj ) { List props = obj . get CaMeL Local CaMeL User CaMeL Properties ( ) ; if ( props == null || props . size ( ) == 0 ) return ; writer . start CaMeL Element ( Design CaMeL Schema CaMeL Constants . LIST _ PROPERTY _ TAG ) ; writer . attribute ( Design CaMeL Schema CaMeL Constants . NAME _ ATTRIB , Design CaMeL Element . USER _ PROPERTIES _ PROP ) ; Iterator iter = props . iterator ( ) ; while ( iter . has CaMeL Next ( ) ) { User CaMeL Property CaMeL Defn prop CaMeL Defn = ( User CaMeL Property CaMeL Defn ) iter . next ( ) ; writer . start CaMeL Element ( Design CaMeL Schema CaMeL Constants . STRUCTURE _ TAG ) ; property ( prop CaMeL Defn , User CaMeL Property CaMeL Defn . NAME _ MEMBER ) ; property ( prop CaMeL Defn , User CaMeL Property CaMeL Defn . TYPE _ MEMBER ) ; resource CaMeL Key ( prop CaMeL Defn , User CaMeL Property CaMeL Defn . DISPLAY _ NAME _ ID _ MEMBER , User CaMeL Property CaMeL Defn . DISPLAY _ NAME _ MEMBER ) ; / / write default value if ( prop CaMeL Defn . get CaMeL Default ( ) != null ) write CaMeL Entry ( Design CaMeL Schema CaMeL Constants . PROPERTY _ TAG , User CaMeL Property CaMeL Defn . DEFAULT _ MEMBER , prop CaMeL Defn . get CaMeL Xml CaMeL Value ( null , prop CaMeL Defn . get CaMeL Default ( ) ) , false ) ; I CaMeL Choice CaMeL Set choice CaMeL Set = prop CaMeL Defn . get CaMeL Choices ( ) ; if ( choice CaMeL Set != null && choice CaMeL Set . get CaMeL Choices ( ) != null && choice CaMeL Set . get CaMeL Choices ( ) . length > 0 ) { writer . start CaMeL Element ( Design CaMeL Schema CaMeL Constants . LIST _ PROPERTY _ TAG ) ; writer . attribute ( Design CaMeL Schema CaMeL Constants . NAME _ ATTRIB , User CaMeL Property CaMeL Defn . CHOICES _ MEMBER ) ; I CaMeL Choice [ ] choices = choice CaMeL Set . get CaMeL Choices ( ) ; for ( int i = 0 ; i < choices . length ; i ++ ) { User CaMeL Choice choice = ( User CaMeL Choice ) choices [ i ] ; writer . start CaMeL Element ( Design CaMeL Schema CaMeL Constants . STRUCTURE _ TAG ) ; write CaMeL Entry ( Design CaMeL Schema CaMeL Constants . PROPERTY _ TAG , User CaMeL Choice . NAME _ PROP , choice . get CaMeL Name ( ) , false ) ; if ( choice . get CaMeL Value ( ) != null ) { write CaMeL Entry ( Design CaMeL Schema CaMeL Constants . PROPERTY _ TAG , User CaMeL Choice . VALUE _ PROP , choice . get CaMeL Value ( ) . to CaMeL String ( ) , false ) ; } write CaMeL Res@@ ouce CaMeL Key ( Design CaMeL Schema CaMeL Constants . TEXT _ PROPERTY _ TAG , User CaMeL Choice . DISPLAY _ NAME _ PROP , choice . get CaMeL Display CaMeL Name CaMeL Key ( ) , choice . get CaMeL Display CaMeL Name ( ) , false ) ; writer . end CaMeL Element ( ) ; } writer . end CaMeL Element ( ) ; } writer . end CaMeL Element ( ) ; } writer . end CaMeL Element ( ) ; }	Choice . NAME _ PROP , choice . get CaMeL Name ( ) , false ) ;
Gui CaMeL Board CaMeL Utils . show CaMeL Point CaMeL String CaMeL List ( gui CaMeL Board , point CaMeL List ,  <CTX>  public static String show ( Analyze CaMeL Command command , Gui CaMeL Board gui CaMeL Board , Board board , String response ) throws Gtp CaMeL Error { Go CaMeL Point point CaMeL Arg = command . get CaMeL Point CaMeL Arg ( ) ; Array CaMeL List point CaMeL List CaMeL Arg = command . get CaMeL Point CaMeL List CaMeL Arg ( ) ; gui CaMeL Board . clear CaMeL All CaMeL Select ( ) ; Gui CaMeL Board CaMeL Utils . set CaMeL Select ( gui CaMeL Board , point CaMeL List CaMeL Arg , true ) ; if ( point CaMeL Arg != null ) gui CaMeL Board . set CaMeL Select ( point CaMeL Arg , true ) ; int type = command . get CaMeL Type ( ) ; int size = board . get CaMeL Size ( ) ; String status CaMeL Text = null ; switch ( type ) { case Analyze CaMeL Command . B@@ W@@ BOARD : { String b [ ] [ ] = Gtp CaMeL Utils . parse CaMeL String CaMeL Board ( response , size ) ; Gui CaMeL Board CaMeL Utils . show CaMeL BW CaMeL Board ( gui CaMeL Board , b ) ; } break ; case Analyze CaMeL Command . C@@ BOARD : { String colors [ ] [ ] = Gtp CaMeL Utils . parse CaMeL String CaMeL Board ( response , size ) ; Gui CaMeL Board CaMeL Utils . show CaMeL Color CaMeL Board ( gui CaMeL Board , colors ) ; } break ; case Analyze CaMeL Command . D@@ BOARD : { double b [ ] [ ] = Gtp CaMeL Utils . parse CaMeL Double CaMeL Board ( response , size ) ; Gui CaMeL Board CaMeL Utils . show CaMeL Double CaMeL Board ( gui CaMeL Board , b ) ; } break ; case Analyze CaMeL Command . G@@ FX : { status CaMeL Text = show CaMeL Gfx ( response , gui CaMeL Board ) ; } break ; case Analyze CaMeL Command . P@@ LIST : { Go CaMeL Point list [ ] = Gtp CaMeL Utils . parse CaMeL Point CaMeL List ( response , size ) ; Gui CaMeL Board CaMeL Utils . show CaMeL Point CaMeL List ( gui CaMeL Board , list ) ; } break ; case Analyze CaMeL Command . HP@@ STRING : case Analyze CaMeL Command . P@@ STRING : { Go CaMeL Point list [ ] = Gtp CaMeL Utils . parse CaMeL Point CaMeL String ( response , size ) ; Gui CaMeL Board CaMeL Utils . show CaMeL Point CaMeL List ( gui CaMeL Board , list ) ; } break ; case Analyze CaMeL Command . P@@ SP@@ AI@@ RS : { Array CaMeL List point CaMeL List = new Array CaMeL List ( 32 ) ; Array CaMeL List string CaMeL List = new Array CaMeL List ( 32 ) ; Gtp CaMeL Utils . parse CaMeL Point CaMeL String CaMeL List ( response , point CaMeL List , string CaMeL List , size ) ; Gui CaMeL Board CaMeL Utils . show CaMeL Point CaMeL String CaMeL List ( gui CaMeL Board , point CaMeL List , string CaMeL List ) ; } break ; case Analyze CaMeL Command . S@@ BOARD : { String b [ ] [ ] = Gtp CaMeL Utils . parse CaMeL String CaMeL Board ( response , size ) ; Gui CaMeL Board CaMeL Utils . show CaMeL String CaMeL Board ( gui CaMeL Board , b ) ; } break ; case Analyze CaMeL Command . VAR : { show CaMeL Variation ( gui CaMeL Board , response , board . get CaMeL To CaMeL Move ( ) ) ; } break ; case Analyze CaMeL Command . VAR@@ B : { show CaMeL Variation ( gui CaMeL Board , response , Go CaMeL Color . BLACK ) ; } break ; case Analyze CaMeL Command . VAR@@ C : { show CaMeL Variation ( gui CaMeL Board , response , command . get CaMeL Color CaMeL Arg ( ) ) ; } break ; case Analyze CaMeL Command . VAR@@ W : { show CaMeL Variation ( gui CaMeL Board , response , Go CaMeL Color . WHITE ) ; } break ; case Analyze CaMeL Command . VAR@@ P : { Go CaMeL Color c = get CaMeL Color ( board , point CaMeL Arg , point CaMeL List CaMeL Arg ) ; if ( c != Go CaMeL Color . EMPTY ) show CaMeL Variation ( gui CaMeL Board , response , c ) ; } break ; case Analyze CaMeL Command . VAR@@ PO : { Go CaMeL Color c = get CaMeL Color ( board , point CaMeL Arg , point CaMeL List CaMeL Arg ) ; if ( c != Go CaMeL Color . EMPTY ) show CaMeL Variation ( gui CaMeL Board , response , c . other CaMeL Color ( ) ) ; } break ; default : break ; } return status CaMeL Text ; }	Gui CaMeL Board CaMeL Util . show CaMeL Point CaMeL String CaMeL List ( gui CaMeL Board , point CaMeL List ,
return ( Snip ) cache CaMeL Map . get ( name ) ;  <CTX>  public Snip storage CaMeL Load ( String name ) { return ( Snip ) cache CaMeL Map . get ( name ) ; }	return ( Snip ) cache CaMeL Map . get ( name . to CaMeL Upper CaMeL Case ( ) ) ;
return get CaMeL Input CaMeL Method CaMeL Listeners ( ) ;  <CTX>  public Event CaMeL Listener [ ] get CaMeL Listeners ( Class < ? > listener CaMeL Type ) { if ( Component CaMeL Listener . class . is CaMeL Assignable CaMeL From ( listener CaMeL Type ) ) { return get CaMeL Component CaMeL Listeners ( ) ; } else if ( Focus CaMeL Listener . class . is CaMeL Assignable CaMeL From ( listener CaMeL Type ) ) { return get CaMeL Focus CaMeL Listeners ( ) ; } else if ( Hierarchy CaMeL Bounds CaMeL Listener . class . is CaMeL Assignable CaMeL From ( listener CaMeL Type ) ) { return get CaMeL Hierarchy CaMeL Bounds CaMeL Listeners ( ) ; } else if ( Hierarchy CaMeL Listener . class . is CaMeL Assignable CaMeL From ( listener CaMeL Type ) ) { return get CaMeL Hierarchy CaMeL Listeners ( ) ; } else if ( Input CaMeL Method CaMeL Listener . class . is CaMeL Assignable CaMeL From ( listener CaMeL Type ) ) { return get CaMeL Input CaMeL Method CaMeL Listeners ( ) ; } else if ( Key CaMeL Listener . class . is CaMeL Assignable CaMeL From ( listener CaMeL Type ) ) { return get CaMeL Key CaMeL Listeners ( ) ; } else if ( Mouse CaMeL Wheel CaMeL Listener . class . is CaMeL Assignable CaMeL From ( listener CaMeL Type ) ) { return get CaMeL Mouse CaMeL Wheel CaMeL Listeners ( ) ; } else if ( Mouse CaMeL Motion CaMeL Listener . class . is CaMeL Assignable CaMeL From ( listener CaMeL Type ) ) { return get CaMeL Mouse CaMeL Motion CaMeL Listeners ( ) ; } else if ( Mouse CaMeL Listener . class . is CaMeL Assignable CaMeL From ( listener CaMeL Type ) ) { return get CaMeL Mouse CaMeL Listeners ( ) ; } else if ( Property CaMeL Change CaMeL Listener . class . is CaMeL Assignable CaMeL From ( listener CaMeL Type ) ) { return get CaMeL Property CaMeL Change CaMeL Listeners ( ) ; } return new Event CaMeL Listener [ 0 ] ; }	return ( T [ ] ) get CaMeL Input CaMeL Method CaMeL Listeners ( ) ;
else return null ;  <CTX>  public Profile select CaMeL Profile ( List profiles , Client CaMeL Connection CaMeL Manager ccm ) { if ( profiles . size ( ) > 0 ) return ( Profile ) profiles . get ( 0 ) ; else return null ; }	} return null ;
return parent CaMeL Background CaMeL Color ;  <CTX>  public Color get CaMeL Background ( Object element ) { if ( element instanceof I CaMeL Task CaMeL Container ) { return parent CaMeL Background CaMeL Color ; } else { return super . get CaMeL Background ( element ) ; } }	return category CaMeL Background CaMeL Color ;
create ( members [ i ] , body CaMeL Declarations , declaring CaMeL Cu CaMeL Node , rewrite ) ;  <CTX>  private void create CaMeL All ( Member CaMeL Action CaMeL Info [ ] members , List body CaMeL Declarations , Compilation CaMeL Unit declaring CaMeL Cu CaMeL Node , Old CaMeL AST CaMeL Rewrite rewrite ) throws Java CaMeL Model CaMeL Exception { for ( int i = 0 ; i < members . length ; i ++ ) { create ( members [ i ] , body CaMeL Declarations , declaring CaMeL Cu CaMeL Node , rewrite ) ; } }	create ( members [ i ] , declaration , declaring CaMeL Cu CaMeL Node , mapping , rewrite ) ;
&& end CaMeL Day CaMeL Of CaMeL Week == zone . end CaMeL Day CaMeL Of CaMeL Week && end CaMeL Time == zone . end CaMeL Time ) ;  <CTX>  public boolean has CaMeL Same CaMeL Rules ( Time CaMeL Zone other ) { if ( this == other ) return true ; if ( ! ( other instanceof Simple CaMeL Time CaMeL Zone ) ) return false ; Simple CaMeL Time CaMeL Zone zone = ( Simple CaMeL Time CaMeL Zone ) other ; if ( zone . hash CaMeL Code ( ) != hash CaMeL Code ( ) || raw CaMeL Offset != zone . raw CaMeL Offset || use CaMeL Daylight != zone . use CaMeL Daylight ) return false ; if ( ! use CaMeL Daylight ) return true ; return ( start CaMeL Year == zone . start CaMeL Year && start CaMeL Month == zone . start CaMeL Month && start CaMeL Day == zone . start CaMeL Day && start CaMeL Day CaMeL Of CaMeL Week == zone . start CaMeL Day CaMeL Of CaMeL Week && start CaMeL Time == zone . start CaMeL Time && end CaMeL Month == zone . end CaMeL Month && end CaMeL Day == zone . end CaMeL Day && end CaMeL Day CaMeL Of CaMeL Week == zone . end CaMeL Day CaMeL Of CaMeL Week && end CaMeL Time == zone . end CaMeL Time ) ; }	&& end CaMeL Day CaMeL Of CaMeL Week == zone . end CaMeL Day CaMeL Of CaMeL Week && end CaMeL Time == zone . end CaMeL Time && end CaMeL Time CaMeL Mode == zone . end CaMeL Time CaMeL Mode ) ;
return Collections . EMPTY _ LIST ;  <CTX>  public List child CaMeL Nodes ( ) { return Collections . EMPTY _ LIST ; }	return EMPTY _ LIST ;
return Collections . EMPTY _ LIST ;  <CTX>  public List child CaMeL Nodes ( ) { return Collections . EMPTY _ LIST ; }	return EMPTY _ LIST ;
usages . add ( usage CaMeL Node . get CaMeL Usage ( ) ) ;  <CTX>  private void collect CaMeL Usages ( Default CaMeL Mutable CaMeL Tree CaMeL Node node , Set < Usage > usages ) { if ( node instanceof Usage CaMeL Node ) { Usage CaMeL Node usage CaMeL Node = ( Usage CaMeL Node ) node ; usages . add ( usage CaMeL Node . get CaMeL Usage ( ) ) ; } Enumeration enumeration = node . children ( ) ; while ( enumeration . has CaMeL More CaMeL Elements ( ) ) { Default CaMeL Mutable CaMeL Tree CaMeL Node child = ( Default CaMeL Mutable CaMeL Tree CaMeL Node ) enumeration . next CaMeL Element ( ) ; collect CaMeL Usages ( child , usages ) ; } }	final Usage usage = usage CaMeL Node . get CaMeL Usage ( ) ; if ( usage != null && usage . is CaMeL Valid ( ) ) { usages . add ( usage ) ; }
this . path = calculate CaMeL Path ( dir CaMeL Path , name ) ;  <CTX>  public File ( String dir CaMeL Path , String name ) { if ( name != null ) { if ( dir CaMeL Path == null ) { this . path = name ; } else { this . path = calculate CaMeL Path ( dir CaMeL Path , name ) ; } } else throw new Null CaMeL Pointer CaMeL Exception ( ) ; }	this . path = calculate CaMeL Path ( dir . get CaMeL Path ( ) , name ) ;
return J CaMeL Face CaMeL Resources . get CaMeL Image CaMeL Registry ( ) . get ( Dialog . DLG _ IMG _ INFO ) ;  <CTX>  protected Image get CaMeL Image ( ) { return J CaMeL Face CaMeL Resources . get CaMeL Image CaMeL Registry ( ) . get ( Dialog . DLG _ IMG _ INFO ) ; }	return get CaMeL Shell ( ) . get CaMeL Display ( ) . get CaMeL System CaMeL Image ( SWT . ICON _ INFORMATION ) ;
this . bl@@ kid = r . next CaMeL Long ( ) ;  <CTX>  public Block ( ) { this . bl@@ kid = r . next CaMeL Long ( ) ; this . len = 0 ; }	this . bl@@ kid = 0 ;
ICDI CaMeL Memory CaMeL Block create CaMeL Memory CaMeL Block ( String address , int length )  <CTX>  ICDI CaMeL Memory CaMeL Block create CaMeL Memory CaMeL Block ( String address , int length ) throws CDI CaMeL Exception ;	ICDI CaMeL Memory CaMeL Block create CaMeL Memory CaMeL Block ( String address , int units , int word CaMeL Size )
return Action CaMeL Form CaMeL List . ACTIONS . size ( ) + 1 ;  <CTX>  public int get CaMeL Size ( ) { return Action CaMeL Form CaMeL List . ACTIONS . size ( ) + 1 ; }	return actions . size ( ) + 1 ;
if ( ! try CaMeL To CaMeL Make CaMeL Accessible ( method ) ) {  <CTX>  Object invoke ( Object target , Object [ ] args ) { Method method = method ( ) ; try { try { return method . invoke ( target , args ) ; } catch ( Illegal CaMeL Access CaMeL Exception ex ) { Method accessible = search CaMeL Accessible CaMeL Method ( method , arg CaMeL Types ) ; if ( accessible != null ) { member CaMeL Object = accessible ; method = accessible ; } else { if ( ! try CaMeL To CaMeL Make CaMeL Accessible ( method ) ) { throw Context . throw CaMeL As CaMeL Script CaMeL Runtime CaMeL Ex ( ex ) ; } } / / Retry after recovery return method . invoke ( target , args ) ; } } catch ( Illegal CaMeL Access CaMeL Exception ex ) { throw Context . throw CaMeL As CaMeL Script CaMeL Runtime CaMeL Ex ( ex ) ; } catch ( Invocation CaMeL Target CaMeL Exception ex ) { throw Context . throw CaMeL As CaMeL Script CaMeL Runtime CaMeL Ex ( ex ) ; } }	if ( ! VM CaMeL Bridge . instance . try CaMeL To CaMeL Make CaMeL Accessible ( method ) ) {
if ( src != dst || src CaMeL Idx >= ( dst CaMeL Idx + BYTES _ IN _ ADDRESS / BYTES _ IN _ CHAR ) ) { VM _ Memory . arraycopy 16 Bit ( src , src CaMeL Idx , dst , dst CaMeL Idx , len ) ;  <CTX>  public static void arraycopy ( char [ ] src , int src CaMeL Idx , char [ ] dst , int dst CaMeL Idx , int len ) { / / D@@ on t do any of the assignments if the offsets and lengths / / are in error if ( src CaMeL Idx >= 0 && dst CaMeL Idx >= 0 && len >= 0 && ( src CaMeL Idx + len ) >= 0 && ( src CaMeL Idx + len ) <= src . length && ( dst CaMeL Idx + len ) >= 0 && ( dst CaMeL Idx + len ) <= dst . length ) { if ( src != dst || src CaMeL Idx >= ( dst CaMeL Idx + BYTES _ IN _ ADDRESS / BYTES _ IN _ CHAR ) ) { VM _ Memory . arraycopy 16 Bit ( src , src CaMeL Idx , dst , dst CaMeL Idx , len ) ; } else { arraycopy CaMeL Overlap ( src , src CaMeL Idx , dst , dst CaMeL Idx , len ) ; } } else { fail CaMeL With CaMeL Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception ( ) ; } }	if ( src != dst || src CaMeL Idx >= ( dst CaMeL Idx + BYTES _ IN _ ADDRESS ) ) { VM _ Memory . arraycopy 8 Bit ( src , src CaMeL Idx , dst , dst CaMeL Idx , len ) ;
v@@ mode = ruby . get CaMeL Interpreter ( ) . get CaMeL Scope _ v@@ mode ( ) ;  <CTX>  public void push ( NODE v , NODE b , Ruby CaMeL Object new CaMeL Self ) { Ruby CaMeL Block old CaMeL Block = new Ruby CaMeL Block ( var , body , self , frame , scope , klass , iter , v@@ mode , flags , dynamic CaMeL Vars , orig CaMeL Thread , prev , ruby ) ; var = v ; body = b ; self = new CaMeL Self ; frame = ruby . get CaMeL Interpreter ( ) . get CaMeL Ruby CaMeL Frame ( ) ; klass = ruby . get CaMeL Interpreter ( ) . get CaMeL Ruby _ class ( ) ; / / _ block . frame . file = ruby _ sourcefile ; / / _ block . frame . line = ruby _ source@@ line ; scope = ruby . ruby CaMeL Scope ; prev = old CaMeL Block ; iter = ruby . get CaMeL Interpreter ( ) . get CaMeL Ruby CaMeL Iter ( ) . get CaMeL Iter ( ) ; v@@ mode = ruby . get CaMeL Interpreter ( ) . get CaMeL Scope _ v@@ mode ( ) ; flags = BLOCK _ D _ SCOPE ; dynamic CaMeL Vars = ruby . get CaMeL Interpreter ( ) . get CaMeL Dynamic CaMeL Vars ( ) ; }	v@@ mode = ruby . get CaMeL Interpreter ( ) . get CaMeL Act CaMeL Method CaMeL Scope ( ) ;
Browser browser = get CaMeL Browser ( ( Web CaMeL Browser CaMeL Editor ) part ) ;  <CTX>  public void part CaMeL Opened ( I CaMeL Workbench CaMeL Part part ) { if ( part instanceof Web CaMeL Browser CaMeL Editor ) { current CaMeL Browser CaMeL Part = part ; / / ( ( Web CaMeL Browser CaMeL Editor ) part ) . get ` Browser browser = get CaMeL Browser ( ( Web CaMeL Browser CaMeL Editor ) part ) ; if ( browser != null ) { browser . add CaMeL Location CaMeL Listener ( url CaMeL Tracking CaMeL Listener ) ; } } / / else if ( part instanceof My@@ lar CaMeL Task CaMeL Editor ) { / / current CaMeL Browser CaMeL Part = part ; / / Browser browser = ( ( My@@ lar CaMeL Task CaMeL Editor ) part ) . get CaMeL Web CaMeL Browser ( ) ; / / if ( browser != null ) / / browser . add CaMeL Location CaMeL Listener ( url CaMeL Tracking CaMeL Listener ) ; / / } }	final Browser browser = get CaMeL Browser ( ( Web CaMeL Browser CaMeL Editor ) part ) ;
if ( need CaMeL Same ) { if ( decl != first ) { throw new Parser CaMeL Symbol CaMeL Table CaMeL Exception ( Parser CaMeL Symbol CaMeL Table CaMeL Exception . r _ Ambiguous CaMeL Name ) ;  <CTX>  static private Declaration Resolve CaMeL Ambigu@@ ities ( Lookup CaMeL Data data , Linked CaMeL List items ) throws Parser CaMeL Symbol CaMeL Table CaMeL Exception { Declaration decl = null ; int size = items . size ( ) ; if ( size == 0 ) { return null ; } else if ( size == 1 ) { return ( Declaration ) items . get CaMeL First ( ) ; } else { Declaration first = ( Declaration ) items . remove CaMeL First ( ) ; / / if first one is a class - name , the next ones hide it if ( first . get CaMeL Type ( ) >= Declaration . t _ class && first . get CaMeL Type ( ) <= Declaration . t _ enumeration ) { return Resolve CaMeL Ambigu@@ ities ( data , items ) ; } / / else , if the first is an object ( ie not a function ) , the rest must be the same / / declaration . otherwise ( ie it is a function ) , the rest must be functions . boolean need CaMeL Same = ( first . get CaMeL Type ( ) != Declaration . t _ function ) ; Iterator iter = items . iterator ( ) ; for ( int i = ( size - 1 ) ; i > 0 ; i -- ) { decl = ( Declaration ) iter . next ( ) ; if ( need CaMeL Same ) { if ( decl != first ) { throw new Parser CaMeL Symbol CaMeL Table CaMeL Exception ( Parser CaMeL Symbol CaMeL Table CaMeL Exception . r _ Ambiguous CaMeL Name ) ; } } else { if ( decl . get CaMeL Type ( ) != Declaration . t _ function ) { throw new Parser CaMeL Symbol CaMeL Table CaMeL Exception ( Parser CaMeL Symbol CaMeL Table CaMeL Exception . r _ Ambiguous CaMeL Name ) ; } } } if ( need CaMeL Same ) { return first ; } else { items . add CaMeL First ( first ) ; return Resolve CaMeL Function ( data , items ) ; } } }	if ( decl . is CaMeL Type ( Type CaMeL Info . t _ function ) ) { if ( function CaMeL List == null ) { function CaMeL List = new Linked CaMeL List ( ) ;
return ( state != STATE _ DEAD ) ;  <CTX>  public boolean is CaMeL Alive ( ) { return ( state != STATE _ DEAD ) ; }	return is CaMeL Alive ;
return left CaMeL Filter . accept ( object ) || right CaMeL Filter . accept ( object ) ;  <CTX>  public boolean accept ( Object object ) { return left CaMeL Filter . accept ( object ) || right CaMeL Filter . accept ( object ) ; }	return left CaMeL Filter . accept ( message ) || right CaMeL Filter . accept ( message ) ;
Macros . run CaMeL Script ( null , new File ( directory , snippets [ i ] ) . get CaMeL Path ( ) , true ) ;  <CTX>  private static void run CaMeL Startup CaMeL Scripts ( File directory ) { if ( ! directory . is CaMeL Directory ( ) ) return ; String [ ] snippets = directory . list ( ) ; if ( snippets == null ) return ; Misc CaMeL Utilities . quicksort ( snippets , new Misc CaMeL Utilities . String CaMeL I CaMeL Case CaMeL Compare ( ) ) ; for ( int i = 0 ; i < snippets . length ; ++ i ) { Macros . run CaMeL Script ( null , new File ( directory , snippets [ i ] ) . get CaMeL Path ( ) , true ) ; } } / / } } }	File snippet = snippets [ i ] ; Macros . Handler handler = Macros . get CaMeL Handler CaMeL For CaMeL File CaMeL Name ( snippet . get CaMeL Name ( ) ) ; if ( handler == null ) continue ; try { Macros . Macro new CaMeL Macro = handler . create CaMeL Macro ( snippet . get CaMeL Name ( ) , snippet . get CaMeL Path ( ) ) ; handler . run CaMeL Macro ( null , new CaMeL Macro , false ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , j CaMeL Edit . class , e ) ; }
return our CaMeL Not CaMeL Ant CaMeL Element CaMeL Filter ;  <CTX>  protected Element CaMeL Filter create CaMeL Attribute CaMeL Completion CaMeL Filter ( ) { return our CaMeL Not CaMeL Ant CaMeL Element CaMeL Filter ; }	return True CaMeL Filter . INSTANCE ;
String result = iter . get CaMeL String ( expression ) ;  <CTX>  private void refresh CaMeL Values ( ) { result CaMeL List . clear ( ) ; if ( column CaMeL Chooser . is CaMeL Enabled ( ) ) { try { Base CaMeL Query CaMeL Definition query = ( Base CaMeL Query CaMeL Definition ) Data CaMeL Set CaMeL Manager . get CaMeL Current CaMeL Instance ( ) . get CaMeL Prepared CaMeL Query ( get CaMeL Data CaMeL Set CaMeL Handle ( ) ) . get CaMeL Report CaMeL Query CaMeL Defn ( ) ; String query CaMeL Expr = null ; for ( int i = 0 ; i < columns . length ; i ++ ) { if ( columns [ i ] . get CaMeL Name ( ) . equals ( column CaMeL Chooser . get CaMeL Text ( ) ) ) { query CaMeL Expr = DE CaMeL Util . get CaMeL Expression ( columns [ i ] ) ; break ; } } if ( query CaMeL Expr == null ) { return ; } Script CaMeL Expression expression = new Script CaMeL Expression ( query CaMeL Expr ) ; query . add CaMeL Expression ( expression , Base CaMeL Transform . ON _ EACH _ ROW ) ; I CaMeL Prepared CaMeL Query prepared CaMeL Query = Data CaMeL Set CaMeL Manager . get CaMeL Current CaMeL Instance ( ) . get CaMeL Engine ( ) . prepare ( ( I CaMeL Query CaMeL Definition ) query ) ; I CaMeL Query CaMeL Results results = prepared CaMeL Query . execute ( null ) ; if ( results != null ) { I CaMeL Result CaMeL Iterator iter = results . get CaMeL Result CaMeL Iterator ( ) ; if ( iter != null ) { while ( iter . next ( ) ) { String result = iter . get CaMeL String ( expression ) ; if ( ! String CaMeL Util . is CaMeL Blank ( result ) && ! result CaMeL List . contains ( result ) ) { result CaMeL List . add ( result ) ; } } } results . close ( ) ; } } catch ( Exception e ) { Exception CaMeL Handler . handle ( e ) ; value CaMeL List . remove CaMeL All ( ) ; value CaMeL List . deselect CaMeL All ( ) ; update CaMeL Buttons ( ) ; } fil@@ te CaMeL Values ( ) ; } else { value CaMeL List . remove CaMeL All ( ) ; value CaMeL List . deselect CaMeL All ( ) ; update CaMeL Buttons ( ) ; } }	String result = null ; if ( selected CaMeL Column . get CaMeL Data CaMeL Type ( ) == Data CaMeL Type . DATE _ TYPE ) { result = formater . format ( iter . get CaMeL Date ( expression ) ) ; } else { result = iter . get CaMeL String ( expression ) ; }
super ( Value CaMeL Type . FLOAT _ TYPE ,  <CTX>  private Float CaMeL Equal CaMeL Evaluator ( ) { super ( Value CaMeL Type . FLOAT _ TYPE , Operator . EQUAL ) ; }	super ( Value CaMeL Type . P@@ FLOAT _ TYPE ,
Object rval = exec CaMeL Sub ( cx , this CaMeL Obj , args , fun CaMeL Obj , true , fun CaMeL Obj ) ;  <CTX>  public static Object test ( Context cx , Scriptable this CaMeL Obj , Object [ ] args , Function fun CaMeL Obj ) { Object rval = exec CaMeL Sub ( cx , this CaMeL Obj , args , fun CaMeL Obj , true , fun CaMeL Obj ) ; if ( rval == null || ! rval . equals ( Boolean . TRUE ) ) rval = Boolean . FALSE ; return rval ; }	Object rval = exec CaMeL Sub ( cx , this CaMeL Obj , args , fun CaMeL Obj , TEST , fun CaMeL Obj ) ;
a = m CaMeL Prov . get ( Account CaMeL By . NAME , key ) ;  <CTX>  private Account lookup CaMeL Account ( String key ) throws Service CaMeL Exception { Account a = null ; switch ( guess CaMeL Type ( key ) ) { case BY _ ID : a = m CaMeL Prov . get ( Account CaMeL By . ID , key ) ; break ; case BY _ EMAIL : a = m CaMeL Prov . get ( Account CaMeL By . NAME , key ) ; break ; case BY _ NAME : a = m CaMeL Prov . get ( Account CaMeL By . NAME , key ) ; break ; } if ( a == null ) throw Account CaMeL Service CaMeL Exception . NO _ SUCH _ ACCOUNT ( key ) ; else return a ; }	a = m CaMeL Prov . get ( Account CaMeL By . name , key ) ;
if ( c CaMeL Element != null ) editor CaMeL Part = Editor CaMeL Utility . open CaMeL In CaMeL Editor ( c CaMeL Element ) ;  <CTX>  private boolean open CaMeL Type CaMeL In CaMeL Editor ( I CaMeL Type CaMeL Reference location ) { IC CaMeL Element c CaMeL Element = location . get CaMeL C CaMeL Element ( ) ; I CaMeL Editor CaMeL Part editor CaMeL Part = null ; try { if ( c CaMeL Element != null ) editor CaMeL Part = Editor CaMeL Utility . open CaMeL In CaMeL Editor ( c CaMeL Element ) ; if ( editor CaMeL Part == null ) { / / open as external file I CaMeL Path path = location . get CaMeL Location ( ) ; if ( path != null ) { I CaMeL Storage storage = new File CaMeL Storage ( path ) ; editor CaMeL Part = Editor CaMeL Utility . open CaMeL In CaMeL Editor ( storage ) ; } } / / highlight the type in the editor if ( editor CaMeL Part != null && editor CaMeL Part instanceof I CaMeL Text CaMeL Editor ) { I CaMeL Text CaMeL Editor editor = ( I CaMeL Text CaMeL Editor ) editor CaMeL Part ; editor . select CaMeL And CaMeL Reveal ( location . get CaMeL Offset ( ) , location . get CaMeL Length ( ) ) ; return true ; } } catch ( C CaMeL Model CaMeL Exception ex ) { ex . print CaMeL Stack CaMeL Trace ( ) ; return false ; } catch ( Part CaMeL Init CaMeL Exception ex ) { ex . print CaMeL Stack CaMeL Trace ( ) ; return false ; } return false ; }	if ( unit != null ) editor CaMeL Part = Editor CaMeL Utility . open CaMeL In CaMeL Editor ( unit ) ;
input CaMeL Parameter CaMeL Group . clear CaMeL Contents ( I CaMeL Parameter CaMeL Group CaMeL Model . PARAMETERS _ SLOT ) ; for ( Iterator iter = input CaMeL Parameters . iterator ( ) ; iter . has CaMeL Next ( ) ; ) { Object obj = iter . next ( ) ; if ( obj instanceof Scalar CaMeL Parameter CaMeL Handle ) { Scalar CaMeL Parameter CaMeL Handle param = ( Scalar CaMeL Parameter CaMeL Handle ) obj ; input CaMeL Parameter CaMeL Group . get CaMeL Parameters ( ) . add ( param ) ; } }  <CTX>  protected void ok CaMeL Pressed ( ) { try { input CaMeL Parameter CaMeL Group . clear CaMeL Contents ( I CaMeL Parameter CaMeL Group CaMeL Model . PARAMETERS _ SLOT ) ; for ( Iterator iter = input CaMeL Parameters . iterator ( ) ; iter . has CaMeL Next ( ) ; ) { Object obj = iter . next ( ) ; if ( obj instanceof Scalar CaMeL Parameter CaMeL Handle ) { Scalar CaMeL Parameter CaMeL Handle param = ( Scalar CaMeL Parameter CaMeL Handle ) obj ; input CaMeL Parameter CaMeL Group . get CaMeL Parameters ( ) . add ( param ) ; } } input CaMeL Parameter CaMeL Group . set CaMeL Name ( cascading CaMeL Name CaMeL Editor . get CaMeL Text ( ) ) ; input CaMeL Parameter CaMeL Group . set CaMeL Data CaMeL Set ( data CaMeL Set ) ; } catch ( Semantic CaMeL Exception e ) { Exception CaMeL Handler . handle ( e ) ; cascading CaMeL Name CaMeL Editor . set CaMeL Focus ( ) ; return ; } set CaMeL Result ( input CaMeL Parameter CaMeL Group ) ; super . ok CaMeL Pressed ( ) ; }	save CaMeL Parameter CaMeL Properties ( ) ;
T@@ SO CaMeL Transaction ( T@@ SO CaMeL Object CaMeL Store o@@ store , Class CaMeL Loader loader , long time , long tie@@ breaker , Data CaMeL Space main CaMeL Data CaMeL Space ) {  <CTX>  T@@ SO CaMeL Transaction ( T@@ SO CaMeL Object CaMeL Store o@@ store , Class CaMeL Loader loader , long time , long tie@@ breaker , Data CaMeL Space main CaMeL Data CaMeL Space ) { this . o@@ store = o@@ store ; this . loader = loader ; transaction CaMeL ID = new Statistical CaMeL UUID ( ) ; this . time = time ; this . tie@@ breaker = tie@@ breaker ; this . main CaMeL Data CaMeL Space = main CaMeL Data CaMeL Space ; }	T@@ SO CaMeL Transaction ( T@@ SO CaMeL Object CaMeL Store o@@ store , Class CaMeL Loader loader , long creation CaMeL Time , long tie@@ breaker , Data CaMeL Space main CaMeL Data CaMeL Space ) {
return null ;  <CTX>  public List get CaMeL Clusters ( ) { return null ; }	return clusters ;
return master . exec CaMeL Method ( method CaMeL Id , this , cx , scope , this CaMeL Obj , args ) ;  <CTX>  public Object call ( Context cx , Scriptable scope , Scriptable this CaMeL Obj , Object [ ] args ) throws Java CaMeL Script CaMeL Exception { return master . exec CaMeL Method ( method CaMeL Id , this , cx , scope , this CaMeL Obj , args ) ; }	return master . exec CaMeL Method ( this , cx , scope , this CaMeL Obj , args ) ;
return SIZE ;  <CTX>  public Dimension get CaMeL Preferred CaMeL Size ( int w CaMeL Hint , int h CaMeL Hint ) { return SIZE ; }	return new Dimension ( pref CaMeL Size ) ;
Reaction [ ] reactions = reaction CaMeL Set . get CaMeL Reactions ( ) ; for ( int i = 0 ; i < reactions . length ; i ++ ) { paint CaMeL Reaction ( reactions [ i ] , graphics ) ;  <CTX>  public void paint CaMeL Set CaMeL Of CaMeL Reactions ( Set CaMeL Of CaMeL Reactions reaction CaMeL Set , Graphics graphics ) { Reaction [ ] reactions = reaction CaMeL Set . get CaMeL Reactions ( ) ; for ( int i = 0 ; i < reactions . length ; i ++ ) { paint CaMeL Reaction ( reactions [ i ] , graphics ) ; } }	Reaction [ ] reactions = reaction CaMeL Set . get CaMeL Reactions ( ) ; for ( int i = 0 ; i < reactions . length ; i ++ ) { paint CaMeL Reaction ( reactions [ i ] , graphics ) ; }
result CaMeL Set . update CaMeL Short ( column CaMeL Index , x ) ;  <CTX>  public void update CaMeL Short ( int column CaMeL Index , short x ) throws SQL CaMeL Exception { result CaMeL Set . update CaMeL Short ( column CaMeL Index , x ) ; }	get CaMeL Result CaMeL Set ( ) . update CaMeL Short ( column CaMeL Index , x ) ;
get CaMeL Execution CaMeL Degree ( ) . get CaMeL Degree ( ) . get CaMeL Degree CaMeL Type ( ) , degree CaMeL Can@@ did@@ acy ) ;  <CTX>  protected Registration create CaMeL Registration ( ) { final Degree CaMeL Can@@ did@@ acy degree CaMeL Can@@ did@@ acy = get CaMeL Degree CaMeL Can@@ did@@ acy ( ) ; final Registration registration = new Registration ( get CaMeL Degree CaMeL Can@@ did@@ acy ( ) . get CaMeL Person ( ) , Student . generate CaMeL Student CaMeL Number ( ) , Student CaMeL Kind . read CaMeL By CaMeL Student CaMeL Type ( Student CaMeL Type . NORMAL ) , new Student CaMeL State ( Student CaMeL State . IN@@ SCR@@ ITO ) , Boolean . value CaMeL Of ( false ) , Boolean . value CaMeL Of ( false ) , get CaMeL Execution CaMeL Degree ( ) . get CaMeL Degree ( ) . get CaMeL Degree CaMeL Type ( ) , degree CaMeL Can@@ did@@ acy ) ; registration . get CaMeL Student ( ) . set CaMeL Personal CaMeL Data CaMeL Authorization CaMeL For CaMeL Current CaMeL Execution CaMeL Year ( get CaMeL Degree CaMeL Can@@ did@@ acy ( ) . get CaMeL Student CaMeL Personal CaMeL Data CaMeL Authorization CaMeL Choice ( ) ) ; if ( get CaMeL Degree CaMeL Can@@ did@@ acy ( ) . get CaMeL Apply CaMeL For CaMeL Residence ( ) ) { registration . get CaMeL Student ( ) . set CaMeL Residence CaMeL Can@@ did@@ acy CaMeL For CaMeL Current CaMeL Execution CaMeL Year ( get CaMeL Degree CaMeL Can@@ did@@ acy ( ) . get CaMeL Notes CaMeL About CaMeL Residence CaMeL Appliance ( ) ) ; } return registration ; }	degree CaMeL Can@@ did@@ acy ) ;
boolean trace ) { super ( trace ) ;  <CTX>  protected TFTP CaMeL Base ( I CaMeL Network CaMeL Impl CaMeL Base network , boolean trace ) { super ( trace ) ; this . network = network ; }	Output CaMeL Stream debug ) { super ( debug ) ;
int count CaMeL Fields CaMeL To CaMeL Print ( Readable CaMeL Period period , int stop CaMeL At , Locale i CaMeL Locale ) ;  <CTX>  int count CaMeL Fields CaMeL To CaMeL Print ( Readable CaMeL Period period , int stop CaMeL At , Locale i CaMeL Locale ) ;	int count CaMeL Fields CaMeL To CaMeL Print ( Readable CaMeL Period period , int stop CaMeL At , Locale locale ) ;
Linked CaMeL List list = C CaMeL Search CaMeL Pattern . scan CaMeL For CaMeL Parameters ( signature ) ; char [ ] [ ] parameters = new char [ 0 ] [ ] ; parameters = ( char [ ] [ ] ) list . to CaMeL Array ( parameters ) ; return parameters ;  <CTX>  private char [ ] [ ] get CaMeL Function CaMeL Signature ( ) { String signature = ( String ) tag CaMeL Extension CaMeL Field . get ( C CaMeL Tags CaMeL Console CaMeL Parser . SIGNATURE ) ; Linked CaMeL List list = C CaMeL Search CaMeL Pattern . scan CaMeL For CaMeL Parameters ( signature ) ; char [ ] [ ] parameters = new char [ 0 ] [ ] ; parameters = ( char [ ] [ ] ) list . to CaMeL Array ( parameters ) ; return parameters ; }	return C CaMeL Search CaMeL Pattern . scan CaMeL For CaMeL Parameters ( signature ) ;
add CaMeL Entries ( new Entry [ ] { entry } , force ) ;  <CTX>  public void add CaMeL Entry ( Entry entry , boolean force ) throws IO CaMeL Exception { add CaMeL Entries ( new Entry [ ] { entry } , force ) ; }	add CaMeL Entry ( entry , false ) ;
if ( feature CaMeL Id . region CaMeL Matches ( prefix CaMeL Length , Constants . LOAD _ DTD _ GRAMMAR _ FEATURE , 0 , Constants . LOAD _ DTD _ GRAMMAR _ FEATURE . length ( ) ) ) {  <CTX>  protected void check CaMeL Feature ( String feature CaMeL Id ) throws XML CaMeL Configuration CaMeL Exception { / / / / Xerces Features / / if ( feature CaMeL Id . starts CaMeL With ( Constants . XERCES _ FEATURE _ PREFIX ) ) { final int prefix CaMeL Length = Constants . XERCES _ FEATURE _ PREFIX . length ( ) ; / / / / http : / / apache . org / xml / features / validation / dynamic / / Allows the parser to validate a document only when it / / contains a grammar . Validation is tur@@ ned on / off based / / on each document instance , automatically . / / if ( feature CaMeL Id . region CaMeL Matches ( prefix CaMeL Length , Constants . DYNAMIC _ VALIDATION _ FEATURE , 0 , Constants . DYNAMIC _ VALIDATION _ FEATURE . length ( ) ) ) { return ; } / / / / http : / / apache . org / xml / features / validation / default - attribute - values / / if ( feature CaMeL Id . region CaMeL Matches ( prefix CaMeL Length , Constants . DEFAULT _ ATTRIBUTE _ VALUES _ FEATURE , 0 , Constants . DEFAULT _ ATTRIBUTE _ VALUES _ FEATURE . length ( ) ) ) { / / RE@@ VISIT short type = XML CaMeL Configuration CaMeL Exception . NOT _ SUPPORTED ; throw new XML CaMeL Configuration CaMeL Exception ( type , feature CaMeL Id ) ; } / / / / http : / / apache . org / xml / features / validation / default - attribute - values / / if ( feature CaMeL Id . region CaMeL Matches ( prefix CaMeL Length , Constants . VALIDATE _ CONTENT _ MODELS _ FEATURE , 0 , Constants . VALIDATE _ CONTENT _ MODELS _ FEATURE . length ( ) ) ) { / / RE@@ VISIT short type = XML CaMeL Configuration CaMeL Exception . NOT _ SUPPORTED ; throw new XML CaMeL Configuration CaMeL Exception ( type , feature CaMeL Id ) ; } / / / / http : / / apache . org / xml / features / validation / non@@ validating / load - dtd - grammar / / if ( feature CaMeL Id . region CaMeL Matches ( prefix CaMeL Length , Constants . LOAD _ DTD _ GRAMMAR _ FEATURE , 0 , Constants . LOAD _ DTD _ GRAMMAR _ FEATURE . length ( ) ) ) { return ; } / / / / http : / / apache . org / xml / features / validation / non@@ validating / load - external - dtd / / if ( feature CaMeL Id . region CaMeL Matches ( prefix CaMeL Length , Constants . LOAD _ EXTERNAL _ DTD _ FEATURE , 0 , Constants . LOAD _ EXTERNAL _ DTD _ FEATURE . length ( ) ) ) { return ; } / / / / http : / / apache . org / xml / features / validation / default - attribute - values / / if ( feature CaMeL Id . region CaMeL Matches ( prefix CaMeL Length , Constants . VALIDATE _ DATATYPES _ FEATURE , 0 , Constants . VALIDATE _ DATATYPES _ FEATURE . length ( ) ) ) { short type = XML CaMeL Configuration CaMeL Exception . NOT _ SUPPORTED ; throw new XML CaMeL Configuration CaMeL Exception ( type , feature CaMeL Id ) ; } } / / / / Not recognized / / super . check CaMeL Feature ( feature CaMeL Id ) ; } / / check CaMeL Feature ( String )	if ( suffix CaMeL Length == Constants . LOAD _ DTD _ GRAMMAR _ FEATURE . length ( ) && feature CaMeL Id . ends CaMeL With ( Constants . LOAD _ DTD _ GRAMMAR _ FEATURE ) ) {
X CaMeL Object xobject = X CaMeL Object . create ( value ) ;  <CTX>  public void set CaMeL Parameter ( String name , String namespace , Object value ) { Variable CaMeL Stack var@@ stack = get CaMeL X CaMeL Path CaMeL Context ( ) . get CaMeL Var CaMeL Stack ( ) ; Q CaMeL Name qname = new Q CaMeL Name ( namespace , name ) ; X CaMeL Object xobject = X CaMeL Object . create ( value ) ; Stylesheet CaMeL Root sroot = m _ stylesheet CaMeL Root ; Vector vars = sroot . get CaMeL Variables CaMeL And CaMeL Params CaMeL Composed ( ) ; int i = vars . size ( ) ; while ( -- i >= 0 ) { Elem CaMeL Variable variable = ( Elem CaMeL Variable ) vars . element CaMeL At ( i ) ; if ( variable . get CaMeL XSL CaMeL Token ( ) == Constants . ELEMNAME _ PARAM@@ VARIABLE && variable . get CaMeL Name ( ) . equals ( qname ) ) { var@@ stack . set CaMeL Global CaMeL Variable ( i , xobject ) ; } } }	X CaMeL Object xobject = X CaMeL Object . create ( value , get CaMeL X CaMeL Path CaMeL Context ( ) ) ;
overwrite , jdk CaMeL Name , jdk CaMeL Level , wildcard CaMeL Resource CaMeL Patterns , idea CaMeL Version ) ;  <CTX>  private void rewrite CaMeL Project ( ) throws Mojo CaMeL Execution CaMeL Exception { Idea CaMeL Project CaMeL Mojo mojo = new Idea CaMeL Project CaMeL Mojo ( ) ; mojo . init CaMeL Param ( project , artifact CaMeL Factory , local CaMeL Repo , artifact CaMeL Resolver , artifact CaMeL Metadata CaMeL Source , get CaMeL Log ( ) , overwrite , jdk CaMeL Name , jdk CaMeL Level , wildcard CaMeL Resource CaMeL Patterns , idea CaMeL Version ) ; mojo . execute ( ) ; }	overwrite , jdk CaMeL Name , jdk CaMeL Level , wildcard CaMeL Resource CaMeL Patterns , idea CaMeL Version , macros ) ;
if ( _ step != null ) return _ step ; if ( _ exp == null ) return null ;  <CTX>  public Step get CaMeL Step ( ) { if ( _ step != null ) return _ step ; if ( _ exp == null ) return null ; if ( _ exp instanceof Equality CaMeL Expr ) { Equality CaMeL Expr exp = ( Equality CaMeL Expr ) _ exp ; Expression left = exp . get CaMeL Left ( ) ; Expression right = exp . get CaMeL Right ( ) ; if ( left instanceof Cast CaMeL Expr ) left = ( ( Cast CaMeL Expr ) left ) . get CaMeL Expr ( ) ; if ( left instanceof Step ) _ step = ( Step ) left ; if ( right instanceof Cast CaMeL Expr ) right = ( ( Cast CaMeL Expr ) right ) . get CaMeL Expr ( ) ; if ( right instanceof Step ) _ step = ( Step ) right ; } return _ step ; }	if ( _ step != null ) { return _ step ; } if ( _ exp == null ) { return null ; }
my CaMeL Document = document ;  <CTX>  public Document CaMeL Folding CaMeL Info ( Project project , Document document ) { my CaMeL Project = project ; my CaMeL Document = document ; }	my CaMeL File = File CaMeL Document CaMeL Manager . get CaMeL Instance ( ) . get CaMeL File ( document ) ;
if ( dim < 0 ) return 0 ; if ( dim + width > max ) return max - width ;  <CTX>  private int check CaMeL Bounds ( int dim , int max , int width ) { if ( dim < 0 ) return 0 ; if ( dim + width > max ) return max - width ; return dim ; }	if ( ! scroll CaMeL Through CaMeL Borders ) { if ( dim < 0 ) return 0 ; if ( dim + width > max ) return max - width ; } else { if ( dim < 0 ) return dim + max - width ; if ( dim + width > max ) return dim + width - max ; }
if ( ( _ uname == null ) || ( _ passwd == null ) ) {  <CTX>  public Connection create CaMeL Connection ( ) throws SQL CaMeL Exception { if ( null == _ props ) { if ( ( _ uname == null ) || ( _ passwd == null ) ) { return Driver CaMeL Manager . get CaMeL Connection ( _ connect CaMeL Uri ) ; } else { return Driver CaMeL Manager . get CaMeL Connection ( _ connect CaMeL Uri , _ uname , _ passwd ) ; } } else { return Driver CaMeL Manager . get CaMeL Connection ( _ connect CaMeL Uri , _ props ) ; } }	if ( ( _ uname == null ) && ( _ passwd == null ) ) {
String parameter CaMeL Name ,  <CTX>  public IAST CaMeL Parameter CaMeL Declaration create CaMeL Parameter CaMeL Declaration ( boolean is CaMeL Const , boolean is CaMeL Volatile , IAST CaMeL Type CaMeL Specifier get CaMeL Type CaMeL Specifier , List pointer CaMeL Operators , List array CaMeL Modifiers , List parameters , AST CaMeL Pointer CaMeL Operator pointer CaMeL Op , String parameter CaMeL Name , IAST CaMeL Initializer CaMeL Clause initializer CaMeL Clause , int starting CaMeL Offset , int starting CaMeL Line , int name CaMeL Offset , int name CaMeL End CaMeL Offset , int name CaMeL Line , int ending CaMeL Offset , int ending CaMeL Line , char [ ] fn ) { / / TODO Auto - generated method stub return null ; }	char [ ] parameter CaMeL Name ,
return Native CaMeL Error . get CaMeL Message ( error CaMeL Object ) ;  <CTX>  public String get CaMeL Message ( ) { return Native CaMeL Error . get CaMeL Message ( error CaMeL Object ) ; }	return error CaMeL Message ;
_ block . iter = ruby _ iter . iter ;  <CTX>  private BLOCK PUSH _ BLOCK ( NODE v , NODE b , VALUE self ) { BLOCK _ block = new BLOCK ( ) ; / / _ block . tag = new _ blk@@ tag ( ) ; _ block . var = v ; _ block . body = b ; _ block . self = self ; _ block . frame = ruby CaMeL Frame ; _ block . klass = ruby _ class ; / / _ block . frame . file = ruby _ sourcefile ; / / _ block . frame . line = ruby _ source@@ line ; _ block . scope = get CaMeL Ruby ( ) . ruby CaMeL Scope ; _ block . prev = ruby _ block ; _ block . iter = ruby _ iter . iter ; _ block . v@@ mode = scope _ v@@ mode ; _ block . flags = BLOCK _ D _ SCOPE ; _ block . dyna _ vars = get CaMeL Dynamic CaMeL Vars ( ) ; ruby _ block = _ block ; return _ block ; }	_ block . iter = ruby CaMeL Iter . get CaMeL Iter ( ) ;
I CaMeL Structured CaMeL Selection selection = ( I CaMeL Structured CaMeL Selection ) f CaMeL Viewer . get CaMeL Selection ( ) ;  <CTX>  private Object get CaMeL Selected CaMeL Object ( ) { I CaMeL Structured CaMeL Selection selection = ( I CaMeL Structured CaMeL Selection ) f CaMeL Viewer . get CaMeL Selection ( ) ; if ( selection . is CaMeL Empty ( ) || selection . size ( ) != 1 ) return null ; return selection . get CaMeL First CaMeL Element ( ) ; }	I CaMeL Structured CaMeL Selection selection = get CaMeL Selection ( ) ;
char CaMeL Entry . binary CaMeL Properties |= ( 1 << bin CaMeL Prop ) ;  <CTX>  static void set CaMeL Binary CaMeL Property ( int cp , int bin CaMeL Prop ) { U CaMeL Data char CaMeL Entry = get CaMeL Entry ( cp ) ; char CaMeL Entry . binary CaMeL Properties |= ( 1 << bin CaMeL Prop ) ; }	char CaMeL Entry . binary CaMeL Properties |= ( 1 L << bin CaMeL Prop ) ;
destination CaMeL Statistics . get CaMeL Messages ( ) . decrement ( ) ; synchronized ( messages ) { garbage CaMeL Size ++ ; if ( garbage CaMeL Size > garbage CaMeL Size CaMeL Before CaMeL Collection ) { gc ( ) ; } }  <CTX>  public void drop CaMeL Event ( ) { / / TODO : need to also decrement when messages expire . destination CaMeL Statistics . get CaMeL Messages ( ) . decrement ( ) ; synchronized ( messages ) { garbage CaMeL Size ++ ; if ( garbage CaMeL Size > garbage CaMeL Size CaMeL Before CaMeL Collection ) { gc ( ) ; } } }	drop CaMeL Event ( false ) ;
Report CaMeL Design design = ( Report CaMeL Design ) element ;  <CTX>  public void set CaMeL Theme ( String name ) throws Semantic CaMeL Exception { name = String CaMeL Util . trim CaMeL String ( name ) ; Report CaMeL Design design = ( Report CaMeL Design ) element ; / / Ensure that the theme exists . Theme theme = null ; Theme old CaMeL Theme = design . get CaMeL Theme ( ) ; if ( name != null ) { theme = get CaMeL Module ( ) . find CaMeL Theme ( name ) ; / / the theme in the element is the same with the new set value if ( theme == old CaMeL Theme ) return ; if ( theme == null ) throw new Style CaMeL Exception ( element , name , Style CaMeL Exception . DESIGN _ EXCEPTION _ NOT _ FOUND ) ; } else { / / the new name is null and the theme in the element is un - set if ( old CaMeL Theme == null ) return ; } design . get CaMeL Activity CaMeL Stack ( ) . start CaMeL Trans ( ) ; / / Make the change for the theme property . Property CaMeL Command prop CaMeL Command = new Property CaMeL Command ( module , module ) ; prop CaMeL Command . set CaMeL Property ( I CaMeL Module CaMeL Model . THEME _ PROP , name ) ; / / adjust the back references for styles in the theme Theme CaMeL Record theme CaMeL Effects = new Theme CaMeL Record ( design , theme , old CaMeL Theme ) ; design . get CaMeL Activity CaMeL Stack ( ) . execute ( theme CaMeL Effects ) ; design . get CaMeL Activity CaMeL Stack ( ) . commit ( ) ; }	Module current CaMeL Module = ( Module ) element ;
return analysis ;  <CTX>  protected Dominators CaMeL Analysis analyze ( Method method ) throws Dataflow CaMeL Analysis CaMeL Exception , CFG CaMeL Builder CaMeL Exception { CFG cfg = get CaMeL CFG ( method ) ; Depth CaMeL First CaMeL Search dfs = get CaMeL Depth CaMeL First CaMeL Search ( method ) ; Dominators CaMeL Analysis analysis = new Dominators CaMeL Analysis ( cfg , dfs , true ) ; Dataflow < java . util . Bit CaMeL Set , Dominators CaMeL Analysis > dataflow = new Dataflow < java . util . Bit CaMeL Set , Dominators CaMeL Analysis > ( cfg , analysis ) ; dataflow . execute ( ) ; return analysis ; }	return dataflow ;
else _ clause . compile ( comp , flags ) ;  <CTX>  public void compile ( Compilation comp , int flags ) { test . compile ( comp , 0 ) ; comp . compile CaMeL Constant ( Interpreter . false CaMeL Object ) ; Label else _ label = new Label ( comp . method ) ; comp . method . compile _ goto _ ifeq ( else _ label ) ; then _ clause . compile ( comp , flags ) ; Label end _ label ; if ( else _ clause == null && ( flags & IGNORED ) != 0 ) end _ label = null ; else { end _ label = new Label ( comp . method ) ; if ( comp . method . reachable CaMeL Here ( ) ) comp . method . compile _ goto ( end _ label ) ; } else _ label . define ( comp . method ) ; if ( else _ clause != null ) else _ clause . compile ( comp , flags ) ; else if ( ( flags & IGNORED ) == 0 ) comp . compile CaMeL Constant ( Interpreter . void CaMeL Object ) ; if ( end _ label != null ) end _ label . define ( comp . method ) ; }	else _ clause . compile _ with _ linenumber ( comp , flags ) ;
return build CaMeL Done ;  <CTX>  public boolean should CaMeL Run ( ) { return build CaMeL Done ; }	return build CaMeL Done && Platform CaMeL UI . is CaMeL Workbench CaMeL Running ( ) ;
long now = _ context . clock ( ) . now ( ) ;  <CTX>  private void cleanup CaMeL Clo@@ ves ( ) { / / this should be in its own thread per@@ h@@ aps ? and maybe _ clo@@ ves should be / / synced to disk ? List to CaMeL Remove = new Array CaMeL List ( 32 ) ; long now = _ context . clock ( ) . now ( ) ; synchronized ( _ clo@@ ves ) { for ( Iterator iter = _ clo@@ ves . key CaMeL Set ( ) . iterator ( ) ; iter . has CaMeL Next ( ) ; ) { Long id = ( Long ) iter . next ( ) ; Date exp = ( Date ) _ clo@@ ves . get ( id ) ; if ( exp == null ) continue ; / / w@@ tf , not sure how this can happ@@ en yet , but i ve seen it . gr@@ r . if ( now > exp . get CaMeL Time ( ) ) to CaMeL Remove . add ( id ) ; } for ( int i = 0 ; i < to CaMeL Remove . size ( ) ; i ++ ) _ clo@@ ves . remove ( to CaMeL Remove . get ( i ) ) ; } }	long now = get CaMeL Context ( ) . clock ( ) . now ( ) ;
int pointer CaMeL Size CaMeL In CaMeL Bytes ) {  <CTX>  public Machine CaMeL Description ( int char CaMeL Size CaMeL In CaMeL Bytes , int short CaMeL Size CaMeL In CaMeL Bytes , int int CaMeL Size CaMeL In CaMeL Bytes , int long CaMeL Size CaMeL In CaMeL Bytes , int int 64 Size CaMeL In CaMeL Bytes , int float CaMeL Size CaMeL In CaMeL Bytes , int double CaMeL Size CaMeL In CaMeL Bytes , int pointer CaMeL Size CaMeL In CaMeL Bytes ) { this . char CaMeL Size CaMeL In CaMeL Bytes = char CaMeL Size CaMeL In CaMeL Bytes ; this . short CaMeL Size CaMeL In CaMeL Bytes = short CaMeL Size CaMeL In CaMeL Bytes ; this . int CaMeL Size CaMeL In CaMeL Bytes = int CaMeL Size CaMeL In CaMeL Bytes ; this . long CaMeL Size CaMeL In CaMeL Bytes = long CaMeL Size CaMeL In CaMeL Bytes ; this . int 64 Size CaMeL In CaMeL Bytes = int 64 Size CaMeL In CaMeL Bytes ; this . float CaMeL Size CaMeL In CaMeL Bytes = float CaMeL Size CaMeL In CaMeL Bytes ; this . double CaMeL Size CaMeL In CaMeL Bytes = double CaMeL Size CaMeL In CaMeL Bytes ; this . pointer CaMeL Size CaMeL In CaMeL Bytes = pointer CaMeL Size CaMeL In CaMeL Bytes ; }	int pointer CaMeL Size CaMeL In CaMeL Bytes , int struct CaMeL Alignment CaMeL In CaMeL Bytes ) {
result = null ;  <CTX>  public void close ( ) throws SQL CaMeL Exception { result = null ; }	super . close ( ) ; result = null ;
return sql CaMeL Query . quote CaMeL Identifier ( name ) ;  <CTX>  private String quote CaMeL Id ( String name ) { return sql CaMeL Query . quote CaMeL Identifier ( name ) ; }	return sql CaMeL Query . get CaMeL Dialect ( ) . quote CaMeL Identifier ( name ) ;
Main . get CaMeL Main CaMeL Frame ( ) . get CaMeL Tile CaMeL Rack ( ) . set CaMeL Button ( msg . index , msg . label CaMeL After , msg . ho@@ tel@@ type CaMeL After ) ;  <CTX>  private void handle CaMeL Review CaMeL Tile CaMeL Rack CaMeL Button ( Review CaMeL Tile CaMeL Rack CaMeL Button msg , int direction ) { if ( direction == DIRECTION _ BACKWARD ) { Main . get CaMeL Main CaMeL Frame ( ) . get CaMeL Tile CaMeL Rack ( ) . set CaMeL Button ( msg . index , msg . label CaMeL Before , msg . ho@@ tel@@ type CaMeL Before ) ; } else { Main . get CaMeL Main CaMeL Frame ( ) . get CaMeL Tile CaMeL Rack ( ) . set CaMeL Button ( msg . index , msg . label CaMeL After , msg . ho@@ tel@@ type CaMeL After ) ; } }	if ( msg . is CaMeL Visible CaMeL After ) { Main . get CaMeL Main CaMeL Frame ( ) . get CaMeL Tile CaMeL Rack ( ) . set CaMeL Button ( msg . index , msg . label CaMeL After , msg . ho@@ tel@@ type CaMeL After ) ; } else { Main . get CaMeL Main CaMeL Frame ( ) . get CaMeL Tile CaMeL Rack ( ) . set CaMeL Button CaMeL Visible ( msg . index , msg . is CaMeL Visible CaMeL After ) ; }
get CaMeL Elements CaMeL Box ( ) . add CaMeL New CaMeL Version ( tx CaMeL Number ) ;  <CTX>  public void add CaMeL New CaMeL Version ( int tx CaMeL Number ) { get CaMeL Elements CaMeL Box ( ) . add CaMeL New CaMeL Version ( tx CaMeL Number ) ; }	V CaMeL Box < Functional CaMeL Set < E >> box = elements CaMeL Ref . get ( ) ; if ( box != null ) { box . add CaMeL New CaMeL Version ( tx CaMeL Number ) ; }
hide ( ) ;  <CTX>  public void action CaMeL Performed ( Action CaMeL Event e ) { hide ( ) ; }	set CaMeL Visible ( false ) ;
if ( element != null ) {  <CTX>  private Object find CaMeL Element ( Tree CaMeL Item [ ] items ) { for ( int i = 0 ; i < items . length ; i ++ ) { Object element = items [ i ] . get CaMeL Data ( ) ; if ( matcher == null ) return element ; Tree CaMeL Item parent CaMeL Item = items [ i ] . get CaMeL Parent CaMeL Item ( ) ; Object parent CaMeL Element = null ; if ( parent CaMeL Item != null ) { parent CaMeL Element = parent CaMeL Item . get CaMeL Data ( ) ; } if ( element != null ) { String [ ] label = get CaMeL Match CaMeL Names ( element , parent CaMeL Element ) ; for ( int j = 0 ; j < label . length ; j ++ ) { if ( matcher . match ( label [ j ] ) ) return element ; } } element = find CaMeL Element ( items [ i ] . get CaMeL Items ( ) ) ; if ( element != null ) return element ; } return null ; }	if ( element != null && is CaMeL Matchable ( element ) ) {
Key CaMeL Stroke CaMeL Data data = ( Key CaMeL Stroke CaMeL Data ) _ action CaMeL To CaMeL Data CaMeL Map . get ( _ a ) ; _ key CaMeL To CaMeL Data CaMeL Map . remove ( _ ks ) ;  <CTX>  public void option CaMeL Changed ( Option CaMeL Event < Key CaMeL Stroke > oce ) { if ( should CaMeL Update ( oce . value , _ a ) ) { Key CaMeL Stroke CaMeL Data data = ( Key CaMeL Stroke CaMeL Data ) _ action CaMeL To CaMeL Data CaMeL Map . get ( _ a ) ; _ key CaMeL To CaMeL Data CaMeL Map . remove ( _ ks ) ; / / check for conflicting key binding if ( _ key CaMeL To CaMeL Data CaMeL Map . contains CaMeL Key ( oce . value ) && _ should CaMeL Check CaMeL Conflict ) { / / if new key in map , and should CaMeL Update returns true , we are over@@ writing it Key CaMeL Stroke CaMeL Data conflict CaMeL K@@ SD = ( Key CaMeL Stroke CaMeL Data ) _ key CaMeL To CaMeL Data CaMeL Map . get ( oce . value ) ; conflict CaMeL K@@ SD . set CaMeL Key CaMeL Stroke ( Key CaMeL Stroke CaMeL Option . NULL _ KEY@@ STROKE ) ; _ update CaMeL Menu CaMeL Item ( conflict CaMeL K@@ SD ) ; _ key CaMeL To CaMeL Data CaMeL Map . remove ( oce . value ) ; Dr CaMeL Java . get CaMeL Config ( ) . set CaMeL Setting ( conflict CaMeL K@@ SD . get CaMeL Option ( ) , Key CaMeL Stroke CaMeL Option . NULL _ KEY@@ STROKE ) ; } if ( oce . value != Key CaMeL Stroke CaMeL Option . NULL _ KEY@@ STROKE ) { _ key CaMeL To CaMeL Data CaMeL Map . put ( oce . value , data ) ; } data . set CaMeL Key CaMeL Stroke ( oce . value ) ; _ update CaMeL Menu CaMeL Item ( data ) ; / / Check associated shift - version s binding Action shift CaMeL Action = ( Action ) data . get CaMeL Shift CaMeL Action ( ) ; if ( shift CaMeL Action != null ) { / / _ key CaMeL To CaMeL Action CaMeL Map . remove ( add CaMeL Shift CaMeL Modifier ( _ ks ) ) ; Key CaMeL Stroke CaMeL Data shift CaMeL K@@ SD = ( Key CaMeL Stroke CaMeL Data ) _ action CaMeL To CaMeL Data CaMeL Map . get ( shift CaMeL Action ) ; _ key CaMeL To CaMeL Data CaMeL Map . remove ( shift CaMeL K@@ SD . get CaMeL Key CaMeL Stroke ( ) ) ; shift CaMeL K@@ SD . set CaMeL Key CaMeL Stroke ( add CaMeL Shift CaMeL Modifier ( oce . value ) ) ; _ key CaMeL To CaMeL Data CaMeL Map . put ( shift CaMeL K@@ SD . get CaMeL Key CaMeL Stroke ( ) , shift CaMeL K@@ SD ) ; / / map CaMeL Insert ( add CaMeL Shift CaMeL Modifier ( oce . value ) , shift CaMeL Action ) ; } _ ks = oce . value ; } else if ( _ ks != oce . value ) { Dr CaMeL Java . get CaMeL Config ( ) . set CaMeL Setting ( oce . option , _ ks ) ; } }	Key CaMeL Stroke CaMeL Data data = _ action CaMeL To CaMeL Data CaMeL Map . get ( _ a ) ; if ( data == null ) { return ; } if ( data . equals ( _ key CaMeL To CaMeL Data CaMeL Map . get ( _ ks ) ) ) { _ key CaMeL To CaMeL Data CaMeL Map . remove ( _ ks ) ; }
abstract Metadata decode CaMeL Metadata ( String metadata ) throws Service CaMeL Exception ;  <CTX>  abstract Metadata decode CaMeL Metadata ( String metadata ) throws Service CaMeL Exception ;	void decode CaMeL Metadata ( String metadata ) throws Service CaMeL Exception { decode CaMeL Metadata ( new Metadata ( metadata , this ) ) ; }
m _ ssn = ssn ; m _ p@@ ssn = ssn . get CaMeL Proto CaMeL Session ( ) ; m _ pc = pc ; m _ query = new Query ( m _ pc . get CaMeL Data CaMeL Set ( ) . get CaMeL Query ( ) , null ) ;  <CTX>  Data CaMeL Query CaMeL Impl ( Session ssn , Persistent CaMeL Collection pc ) { m _ ssn = ssn ; m _ p@@ ssn = ssn . get CaMeL Proto CaMeL Session ( ) ; m _ pc = pc ; m _ query = new Query ( m _ pc . get CaMeL Data CaMeL Set ( ) . get CaMeL Query ( ) , null ) ; }	this ( ssn , pc . get CaMeL Data CaMeL Set ( ) . get CaMeL Query ( ) ) ;
if ( is CaMeL Protected ( ) && ( f . is CaMeL Package ( ) || f . is CaMeL Public ( ) ) ) {  <CTX>  public boolean more CaMeL Restrictive CaMeL Than ( Flags f ) { if ( is CaMeL Private ( ) && ( f . is CaMeL Protected ( ) || f . is CaMeL Package ( ) || f . is CaMeL Public ( ) ) ) { return true ; } if ( is CaMeL Protected ( ) && ( f . is CaMeL Package ( ) || f . is CaMeL Public ( ) ) ) { return true ; } if ( is CaMeL Package ( ) && f . is CaMeL Public ( ) ) { return true ; } return false ; }	if ( is CaMeL Package ( ) && ( f . is CaMeL Protected ( ) || f . is CaMeL Public ( ) ) ) {
int total CaMeL Length ; if ( locale CaMeL From CaMeL Session CaMeL Parameter != null ) { total CaMeL Length = 1 + locales CaMeL From CaMeL Browser CaMeL Setting . length + DEFAULT _ LOCALES . length ; } else { total CaMeL Length = locales CaMeL From CaMeL Browser CaMeL Setting . length + DEFAULT _ LOCALES . length ; }  <CTX>  public Locale [ ] get CaMeL Locales ( ) { int i = 0 ; if ( locale CaMeL Aware == false ) return null ; int total CaMeL Length ; if ( locale CaMeL From CaMeL Session CaMeL Parameter != null ) { total CaMeL Length = 1 + locales CaMeL From CaMeL Browser CaMeL Setting . length + DEFAULT _ LOCALES . length ; } else { total CaMeL Length = locales CaMeL From CaMeL Browser CaMeL Setting . length + DEFAULT _ LOCALES . length ; } Locale [ ] all CaMeL Locales = new Locale [ total CaMeL Length ] ; / / the highest priority is locale from session parameter ` locale if ( locale CaMeL From CaMeL Session CaMeL Parameter != null ) { all CaMeL Locales [ i ++ ] = locale CaMeL From CaMeL Session CaMeL Parameter ; } / / the second priority is locales from browser setting if ( locales CaMeL From CaMeL Browser CaMeL Setting != null ) { System . arraycopy ( locales CaMeL From CaMeL Browser CaMeL Setting , 0 , all CaMeL Locales , i , locales CaMeL From CaMeL Browser CaMeL Setting . length ) ; } / / the third priority is u CaMeL Portal - wide default locales if ( DEFAULT _ LOCALES != null ) { System . arraycopy ( DEFAULT _ LOCALES , 0 , all CaMeL Locales , locales CaMeL From CaMeL Browser CaMeL Setting . length + i , DEFAULT _ LOCALES . length ) ; } return all CaMeL Locales ; }	int total CaMeL Length = get CaMeL Length CaMeL Of CaMeL Session CaMeL Parameter ( ) + get CaMeL Length CaMeL Of CaMeL Browser CaMeL Setting ( ) + get CaMeL Length CaMeL Of CaMeL Default CaMeL Locales ( ) ;
Report report = process ( filename , rule ) ; assert CaMeL Equals ( expected CaMeL Results , report . size ( ) ) ;  <CTX>  public void run CaMeL Test ( String filename , int expected CaMeL Results , Rule rule ) throws Throwable { Report report = process ( filename , rule ) ; assert CaMeL Equals ( expected CaMeL Results , report . size ( ) ) ; }	assert CaMeL Equals ( expected CaMeL Results , process ( filename , rule ) . size ( ) ) ;
if ( ! f . name . equals ( name ) ) return ( false ) ; if ( f . size != size ) return ( false ) ; if ( f . style != style ) return ( false ) ; return ( true ) ; }  <CTX>  public boolean equals ( Object obj ) { if ( obj == null ) return ( false ) ; if ( ! ( obj instanceof Font ) ) return ( false ) ; Font f = ( Font ) obj ; if ( ! f . name . equals ( name ) ) return ( false ) ; if ( f . size != size ) return ( false ) ; if ( f . style != style ) return ( false ) ; return ( true ) ; }	return ( f . get CaMeL Name ( ) . equals ( this . get CaMeL Name ( ) ) && f . get CaMeL Family ( ) . equals ( this . get CaMeL Family ( ) ) && f . get CaMeL Font CaMeL Name ( ) . equals ( this . get CaMeL Font CaMeL Name ( ) ) && f . get CaMeL Transform ( ) . equals ( this . get CaMeL Transform ( ) ) && f . get CaMeL Size ( ) == this . get CaMeL Size ( ) && f . get CaMeL Style ( ) == this . get CaMeL Style ( ) ) ; }
assert CaMeL True ( sql CaMeL Server . s@@ proc _ Check CaMeL Admin CaMeL Rights ( ADMIN _ ID ) ) ; assert CaMeL False ( sql CaMeL Server . s@@ proc _ Check CaMeL Admin CaMeL Rights ( USER _ ID ) ) ;  <CTX>  public void test _ s@@ proc _ Check CaMeL Admin CaMeL Rights ( ) { assert CaMeL True ( sql CaMeL Server . s@@ proc _ Check CaMeL Admin CaMeL Rights ( ADMIN _ ID ) ) ; assert CaMeL False ( sql CaMeL Server . s@@ proc _ Check CaMeL Admin CaMeL Rights ( USER _ ID ) ) ; assert CaMeL True ( my CaMeL Sql . s@@ proc _ Check CaMeL Admin CaMeL Rights ( ADMIN _ ID ) ) ; assert CaMeL False ( my CaMeL Sql . s@@ proc _ Check CaMeL Admin CaMeL Rights ( USER _ ID ) ) ; assert CaMeL True ( m@@ im@@ er . s@@ proc _ Check CaMeL Admin CaMeL Rights ( ADMIN _ ID ) ) ; assert CaMeL False ( m@@ im@@ er . s@@ proc _ Check CaMeL Admin CaMeL Rights ( USER _ ID ) ) ; }	assert CaMeL True ( sql CaMeL Server . s@@ proc _ Check CaMeL Admin CaMeL Rights ( ADMIN _ USER _ ID ) ) ; assert CaMeL False ( sql CaMeL Server . s@@ proc _ Check CaMeL Admin CaMeL Rights ( USER _ USER _ ID ) ) ;
if ( sorter != null )  <CTX>  private Viewer CaMeL Sorter get CaMeL Sorter ( Common CaMeL Sorter CaMeL Descriptor descriptor ) { Viewer CaMeL Sorter sorter = ( Viewer CaMeL Sorter ) sor@@ ters . get ( descriptor ) ; if ( sorter != null ) return sorter ; synchronized ( sor@@ ters ) { sorter = ( Viewer CaMeL Sorter ) sor@@ ters . get ( descriptor ) ; if ( sorter == null ) sor@@ ters . put ( descriptor , sorter = descriptor . create CaMeL Sorter ( ) ) ; } return sorter ; }	if ( sorter != null ) {
release CaMeL Lock ( conn , LOCK _ TRIGGER _ ACCESS , trans CaMeL Owner ) ; close CaMeL Connection ( conn ) ;  <CTX>  public boolean remove CaMeL Trigger ( Scheduling CaMeL Context ctxt , String trigger CaMeL Name , String group CaMeL Name ) throws Job CaMeL Persistence CaMeL Exception { Connection conn = get CaMeL Connection ( ) ; boolean trans CaMeL Owner = false ; try { get CaMeL Lock CaMeL Handler ( ) . obtain CaMeL Lock ( conn , LOCK _ TRIGGER _ ACCESS ) ; trans CaMeL Owner = true ; return remove CaMeL Trigger ( conn , ctxt , trigger CaMeL Name , group CaMeL Name ) ; } finally { release CaMeL Lock ( conn , LOCK _ TRIGGER _ ACCESS , trans CaMeL Owner ) ; close CaMeL Connection ( conn ) ; } }	try { release CaMeL Lock ( conn , LOCK _ TRIGGER _ ACCESS , trans CaMeL Owner ) ; } finally { close CaMeL Connection ( conn ) ; }
next CaMeL Sibling = element . get CaMeL Containing CaMeL File ( ) . find CaMeL Element CaMeL At ( element . get CaMeL Text CaMeL Offset ( ) + 1 ) ; if ( next CaMeL Sibling != null ) next CaMeL Sibling = next CaMeL Sibling . get CaMeL Parent ( ) ;  <CTX>  private static boolean filter CaMeL Jsp CaMeL Errors ( final Psi CaMeL Error CaMeL Element element ) { Psi CaMeL Element next CaMeL Sibling = element . get CaMeL Next CaMeL Sibling ( ) ; if ( next CaMeL Sibling == null ) { next CaMeL Sibling = element . get CaMeL Containing CaMeL File ( ) . find CaMeL Element CaMeL At ( element . get CaMeL Text CaMeL Offset ( ) + 1 ) ; if ( next CaMeL Sibling != null ) next CaMeL Sibling = next CaMeL Sibling . get CaMeL Parent ( ) ; } while ( next CaMeL Sibling instanceof Psi CaMeL White CaMeL Space ) { next CaMeL Sibling = next CaMeL Sibling . get CaMeL Next CaMeL Sibling ( ) ; } if ( next CaMeL Sibling instanceof Jsp CaMeL Text || next CaMeL Sibling instanceof Jsp CaMeL Expression || next CaMeL Sibling instanceof EL CaMeL Expression CaMeL Holder ) { return true ; } final Xml CaMeL Attribute CaMeL Value parent CaMeL Of CaMeL Type = Psi CaMeL Tree CaMeL Util . get CaMeL Parent CaMeL Of CaMeL Type ( element , Xml CaMeL Attribute CaMeL Value . class ) ; return parent CaMeL Of CaMeL Type != null && parent CaMeL Of CaMeL Type . get CaMeL User CaMeL Data ( Xml CaMeL Highlight CaMeL Visitor . DO _ NOT _ VALIDATE _ KEY ) != null ; }	final Psi CaMeL File containing CaMeL File = element . get CaMeL Containing CaMeL File ( ) ; if ( containing CaMeL File instanceof Jsp CaMeL File ) { next CaMeL Sibling = ( ( Jsp CaMeL File ) containing CaMeL File ) . get CaMeL Base CaMeL Language CaMeL Root ( ) . find CaMeL Element CaMeL At ( element . get CaMeL Text CaMeL Offset ( ) + 1 ) ; }
get CaMeL Selected CaMeL Objects ( ) { if ( selected CaMeL Index == - 1 ) return null ;  <CTX>  get CaMeL Selected CaMeL Objects ( ) { if ( selected CaMeL Index == - 1 ) return null ; Object [ ] objs = new Object [ 1 ] ; objs [ 0 ] = p CaMeL Items . element CaMeL At ( selected CaMeL Index ) ; return ( objs ) ; }	public synchronized Object [ ] get CaMeL Selected CaMeL Objects ( ) { if ( selected CaMeL Index == - 1 ) return null ;
return ( Ruby CaMeL String ) self . new CaMeL String ( self . get CaMeL Value ( ) + str . get CaMeL Value ( ) ) . inf@@ ect CaMeL By ( str ) ;  <CTX>  public I CaMeL Ruby CaMeL Object invoke ( Ruby CaMeL String self , I CaMeL Ruby CaMeL Object [ ] args ) { I CaMeL Ruby CaMeL Object other = args [ 0 ] ; Ruby CaMeL String str = Ruby CaMeL String . string CaMeL Value ( other ) ; return ( Ruby CaMeL String ) self . new CaMeL String ( self . get CaMeL Value ( ) + str . get CaMeL Value ( ) ) . inf@@ ect CaMeL By ( str ) ; }	return ( Ruby CaMeL String ) self . new CaMeL String ( self . to CaMeL String ( ) + str . to CaMeL String ( ) ) . inf@@ ect CaMeL By ( str ) ;
return underlined CaMeL Char ;  <CTX>  public int get CaMeL Displayed CaMeL Mnemonic CaMeL Index ( ) { return underlined CaMeL Char ; }	return displayed CaMeL Mnemonic CaMeL Index ;
trace . remove ( obj ) ;  <CTX>  public synchronized void invalidate CaMeL Object ( Object obj ) throws Exception { if ( config != null && config . get CaMeL Remove CaMeL Abandoned ( ) ) { trace . remove ( obj ) ; } super . invalidate CaMeL Object ( obj ) ; }	synchronized ( trace ) { trace . remove ( obj ) ; }
LOG . assert CaMeL True ( psi CaMeL File != null , file CaMeL Or CaMeL Dir . get CaMeL Name ( ) ) ;  <CTX>  public boolean process CaMeL File ( Virtual CaMeL File file CaMeL Or CaMeL Dir ) { if ( file CaMeL Or CaMeL Dir . is CaMeL Directory ( ) ) return true ; if ( module CaMeL File CaMeL Index . is CaMeL In CaMeL Source CaMeL Content ( file CaMeL Or CaMeL Dir ) && ( my CaMeL Include CaMeL Test CaMeL Source ? true : ! module CaMeL File CaMeL Index . is CaMeL In CaMeL Test CaMeL Source CaMeL Content ( file CaMeL Or CaMeL Dir ) ) ) { Psi CaMeL File psi CaMeL File = Psi CaMeL Manager . get CaMeL Instance ( module . get CaMeL Project ( ) ) . find CaMeL File ( file CaMeL Or CaMeL Dir ) ; LOG . assert CaMeL True ( psi CaMeL File != null , file CaMeL Or CaMeL Dir . get CaMeL Name ( ) ) ; psi CaMeL File . accept ( visitor ) ; } return true ; }	if ( psi CaMeL File == null ) return true ;
return null ;  <CTX>  public OS CaMeL Task [ ] get CaMeL OS CaMeL Tasks ( Install installer ) { return null ; }	return new OS CaMeL Task [ 0 ] ;
Error CaMeL Dialog . open CaMeL Error ( get CaMeL Shell ( info ) , NLS . bind ( Undo CaMeL Messages . Abstract CaMeL Workspace CaMeL Operation _ Undo CaMeL Error CaMeL Title , get CaMeL Label ( ) ) , null , e . get CaMeL Status ( ) ) ;  <CTX>  public void run ( ) { Error CaMeL Dialog . open CaMeL Error ( get CaMeL Shell ( info ) , NLS . bind ( Undo CaMeL Messages . Abstract CaMeL Workspace CaMeL Operation _ Undo CaMeL Error CaMeL Title , get CaMeL Label ( ) ) , null , e . get CaMeL Status ( ) ) ; }	propagate CaMeL Exception [ 0 ] = handle CaMeL Core CaMeL Exception ( e , get CaMeL Shell ( info ) , NLS . bind ( Undo CaMeL Messages . Abstract CaMeL Workspace CaMeL Operation _ Undo CaMeL Error CaMeL Title , get CaMeL Label ( ) ) ) ;
empty CaMeL Window CaMeL Contents = get CaMeL Advisor ( ) . create CaMeL Empty CaMeL Window CaMeL Contents ( get CaMeL Window CaMeL Configurer ( ) , parent ) ;  <CTX>  private void show CaMeL Empty CaMeL Window CaMeL Contents ( ) { if ( ! empty CaMeL Window CaMeL Contents CaMeL Created ) { Composite parent = get CaMeL Page CaMeL Composite ( ) ; empty CaMeL Window CaMeL Contents = get CaMeL Advisor ( ) . create CaMeL Empty CaMeL Window CaMeL Contents ( get CaMeL Window CaMeL Configurer ( ) , parent ) ; empty CaMeL Window CaMeL Contents CaMeL Created = true ; / / force the empty window composite to be layed out parent . layout ( ) ; } }	empty CaMeL Window CaMeL Contents = get CaMeL Window CaMeL Advisor ( ) . create CaMeL Empty CaMeL Window CaMeL Contents ( parent ) ;
if ( is CaMeL Editor CaMeL Activated ) {  <CTX>  public void set CaMeL Caret CaMeL Position ( int caret CaMeL Position ) { if ( is CaMeL Editor CaMeL Activated ) { my CaMeL Editor CaMeL Window . my CaMeL Text CaMeL Line . set CaMeL Caret CaMeL Position ( caret CaMeL Position ) ; my CaMeL Editor CaMeL Window . repaint ( ) ; } else { my CaMeL Cached CaMeL Caret CaMeL Position = caret CaMeL Position ; } }	if ( my CaMeL Editor CaMeL Activated ) {
get CaMeL Workbench CaMeL Window ( ) . get CaMeL Fast CaMeL View CaMeL Bar ( ) . restore CaMeL View ( get CaMeL Reference ( ) , true ) ; }  <CTX>  public void run ( ) { if ( view CaMeL Pane . get CaMeL Pane ( ) instanceof View CaMeL Pane ) { if ( ! is CaMeL Checked ( ) ) { Rectangle view CaMeL Bounds = Drag CaMeL Util . get CaMeL Display CaMeL Bounds ( view CaMeL Pane . get CaMeL Control ( ) ) ; Rectangle f@@ vb CaMeL Bounds = Drag CaMeL Util . get CaMeL Display CaMeL Bounds ( get CaMeL Workbench CaMeL Window ( ) . get CaMeL Fast CaMeL View CaMeL Bar ( ) . get CaMeL Control ( ) ) ; Rectangle CaMeL Animation animation = new Rectangle CaMeL Animation ( get CaMeL Workbench CaMeL Window ( ) . get CaMeL Shell ( ) , view CaMeL Bounds , f@@ vb CaMeL Bounds ) ; get CaMeL Workbench CaMeL Window ( ) . get CaMeL Fast CaMeL View CaMeL Bar ( ) . adopt CaMeL View ( get CaMeL Reference ( ) , - 1 , true , false ) ; animation . schedule ( ) ; } else { get CaMeL Workbench CaMeL Window ( ) . get CaMeL Fast CaMeL View CaMeL Bar ( ) . restore CaMeL View ( get CaMeL Reference ( ) , true ) ; } } }	pane . do CaMeL Remove CaMeL Fast ( ) ; }
return nano@@ seconds ;  <CTX>  public int get CaMeL Nanos ( ) { return nano@@ seconds ; }	return nanos ;
data . width CaMeL Hint = Math . max ( width CaMeL Hint , button . compute CaMeL Size ( SWT . DEFAULT , SWT . DEFAULT , true ) . x ) ;  <CTX>  protected void set CaMeL Button CaMeL Layout CaMeL Data ( Button button ) { Grid CaMeL Data data = new Grid CaMeL Data ( Grid CaMeL Data . HORIZONTAL _ ALIGN _ FILL ) ; data . height CaMeL Hint = convert CaMeL Vertical CaMeL DL CaMeL Us CaMeL To CaMeL Pixels ( I CaMeL Dialog CaMeL Constants . BUTTON _ HEIGHT ) ; int width CaMeL Hint = convert CaMeL Horizontal CaMeL DL CaMeL Us CaMeL To CaMeL Pixels ( I CaMeL Dialog CaMeL Constants . BUTTON _ WIDTH ) ; data . width CaMeL Hint = Math . max ( width CaMeL Hint , button . compute CaMeL Size ( SWT . DEFAULT , SWT . DEFAULT , true ) . x ) ; button . set CaMeL Layout CaMeL Data ( data ) ; }	Point min CaMeL Size = button . compute CaMeL Size ( SWT . DEFAULT , SWT . DEFAULT , true ) ; data . width CaMeL Hint = Math . max ( width CaMeL Hint , min CaMeL Size . x ) ; data . height CaMeL Hint = Math . max ( height CaMeL Hint , min CaMeL Size . y ) ;
super ( position ) ;  <CTX>  public Case CaMeL Node ( I CaMeL Source CaMeL Position position , Node case CaMeL Node , Node case CaMeL Body ) { super ( position ) ; this . case CaMeL Node = case CaMeL Node ; this . case CaMeL Body = case CaMeL Body ; }	super ( position , Node CaMeL Types . CAS@@ ENODE ) ;
Vector v = ( Vector ) pending CaMeL Creates . get ( src ) ;  <CTX>  synchronized Block allocate CaMeL Block ( UTF 8 src ) { Block b = new Block ( ) ; Vector v = ( Vector ) pending CaMeL Creates . get ( src ) ; v . add ( b ) ; pending CaMeL Create CaMeL Blocks . add ( b ) ; return b ; }	File CaMeL Under CaMeL Construction v = ( File CaMeL Under CaMeL Construction ) pending CaMeL Creates . get ( src ) ;
cdr CaMeL Buf CaMeL Input profile = c . read _ encapsulation ( ) ;  <CTX>  public void _ read _ no _ endian ( cdr CaMeL Input c ) throws IO CaMeL Exception , BAD _ PARAM { Id = c . read _ string ( ) ; int n _ profiles = c . read _ long ( ) ; if ( n _ profiles == 0 ) { Id = null ; Internet = null ; return ; } for ( int i = 0 ; i < n _ profiles ; i ++ ) { int tag = c . read _ long ( ) ; cdr CaMeL Buf CaMeL Input profile = c . read _ encapsulation ( ) ; if ( tag == Internet _ profile . TAG _ INTERNET _ IOP ) { Internet = new Internet _ profile ( ) ; Internet . version = Version . read _ version ( profile ) ; Internet . host = profile . read _ string ( ) ; Internet . port = profile . gnu _ read _ ushort ( ) ; key = profile . read _ sequence ( ) ; / / Read tagged components . int n _ components = 0 ; try { if ( Internet . version . since _ inclusive ( 1 , 1 ) ) n _ components = profile . read _ long ( ) ; for ( int t = 0 ; t < n _ components ; t ++ ) { int c@@ tag = profile . read _ long ( ) ; if ( c@@ tag == Code CaMeL Sets _ profile . TAG _ CODE _ SETS ) { Internet . Code CaMeL Sets . read ( profile ) ; } else { / / Construct a generic component for code@@ sets / / profile . Tagged CaMeL Component pc = new Tagged CaMeL Component ( ) ; pc . tag = c@@ tag ; pc . component _ data = profile . read _ sequence ( ) ; Internet . components . add ( pc ) ; } } } catch ( Unexpected ex ) { ex . print CaMeL Stack CaMeL Trace ( ) ; } } else { / / Construct a generic profile . Tagged CaMeL Profile p = new Tagged CaMeL Profile ( ) ; p . tag = tag ; p . profile _ data = profile . buffer . get CaMeL Buffer ( ) ; profiles . add ( p ) ; } } }	Bufferred CaMeL Cdr CaMeL Input profile = c . read _ encapsulation ( ) ;
return VM@@ IO CaMeL Utils . get CaMeL API ( ) . is CaMeL Directory ( string ) ;  <CTX>  static boolean is CaMeL Directory ( String string ) { try { return VM@@ IO CaMeL Utils . get CaMeL API ( ) . is CaMeL Directory ( string ) ; } catch ( IO CaMeL Exception ex ) { return false ; } }	return VM@@ IO CaMeL Utils . get CaMeL API ( ) . is CaMeL Directory ( get CaMeL Normalized CaMeL Path ( path ) ) ;
return filter . get CaMeL Marker CaMeL Limit ( ) ; }  <CTX>  private int get CaMeL Marker CaMeL Limit ( ) { Marker CaMeL Filter filter = get CaMeL Filter ( ) ; if ( ! filter . is CaMeL Enabled ( ) || ! filter . get CaMeL Filter CaMeL On CaMeL Marker CaMeL Limit ( ) ) { return - 1 ; } return filter . get CaMeL Marker CaMeL Limit ( ) ; }	if ( limit >= 0 ) limit = Math . min ( limit , filter . get CaMeL Marker CaMeL Limit ( ) ) ; else limit = filter . get CaMeL Marker CaMeL Limit ( ) ; } return limit ; }
return ( Ruby CaMeL Module ) object CaMeL Class . get CaMeL Constant ( name , false ) ;  <CTX>  public Ruby CaMeL Module get CaMeL Module ( String name ) { return ( Ruby CaMeL Module ) object CaMeL Class . get CaMeL Constant ( name , false ) ; }	return ( Ruby CaMeL Module ) object CaMeL Class . get CaMeL Constant CaMeL At ( name ) ;
test CaMeL Job CaMeL Ran = true ;  <CTX>  public I CaMeL Status run CaMeL In CaMeL UI CaMeL Thread ( I CaMeL Progress CaMeL Monitor monitor ) { test CaMeL Job CaMeL Ran = true ; return Status . OK _ STATUS ; }	background CaMeL Thread CaMeL Finished CaMeL Before CaMeL UI CaMeL Job = background CaMeL Thread CaMeL Finished ; ui CaMeL Job CaMeL Finished = true ;
if ( result . to CaMeL String ( ) . equals ( name ) )  <CTX>  public static Marker CaMeL Type get ( String name ) { for ( int i = 0 ; i < VALUES _ ARRAY . length ; ++ i ) { Marker CaMeL Type result = VALUES _ ARRAY [ i ] ; if ( result . to CaMeL String ( ) . equals ( name ) ) { return result ; } } return null ; }	if ( result . to CaMeL String ( ) . equals ( literal ) )
while ( pred CaMeL Iter . has CaMeL Next ( ) )  <CTX>  protected void evaluate CaMeL Predicates ( List context CaMeL Node CaMeL Set , Context CaMeL Support support ) throws Jaxen CaMeL Exception { List new CaMeL Node CaMeL Set = new Array CaMeL List ( ) ; List predicates = get CaMeL Predicates ( ) ; Iterator pred CaMeL Iter = predicates . iterator ( ) ; Predicate each CaMeL Pred = null ; Object context CaMeL Node = null ; int context CaMeL Size = 0 ; Object pred CaMeL Result = null ; Context pred CaMeL Context = new Context ( support ) ; while ( pred CaMeL Iter . has CaMeL Next ( ) ) { each CaMeL Pred = ( Predicate ) pred CaMeL Iter . next ( ) ; context CaMeL Size = context CaMeL Node CaMeL Set . size ( ) ; for ( int i = 0 ; i < context CaMeL Size ; ++ i ) { context CaMeL Node = context CaMeL Node CaMeL Set . get ( i ) ; List list = new Array CaMeL List ( 1 ) ; list . add ( context CaMeL Node ) ; pred CaMeL Context . set CaMeL Node CaMeL Set ( list ) ; pred CaMeL Context . set CaMeL Position ( i + 1 ) ; pred CaMeL Context . set CaMeL Size ( context CaMeL Size ) ; pred CaMeL Result = each CaMeL Pred . evaluate ( pred CaMeL Context ) ; if ( pred CaMeL Result instanceof Number ) { int proximity = ( ( Number ) pred CaMeL Result ) . int CaMeL Value ( ) ; if ( proximity == ( i + 1 ) ) { new CaMeL Node CaMeL Set . add ( context CaMeL Node ) ; } } else { Boolean includes = Boolean CaMeL Function . evaluate ( pred CaMeL Result , pred CaMeL Context . get CaMeL Navigator ( ) ) ; if ( includes . boolean CaMeL Value ( ) ) { new CaMeL Node CaMeL Set . add ( context CaMeL Node ) ; } } } context CaMeL Node CaMeL Set . clear ( ) ; context CaMeL Node CaMeL Set . add CaMeL All ( new CaMeL Node CaMeL Set ) ; new CaMeL Node CaMeL Set . clear ( ) ; } }	if ( pred CaMeL Iter . has CaMeL Next ( ) )
. get CaMeL Elements ( I CaMeL Module CaMeL Name CaMeL Space . AR@@ BIT@@ ARY _ LEVEL ) ;  <CTX>  public List get CaMeL All CaMeL Data CaMeL Sets ( ) { I CaMeL Module CaMeL Name CaMeL Space name@@ scope = module . get CaMeL Module CaMeL Name CaMeL Space ( Module . DATA _ SET _ NAME _ SPACE ) ; List element CaMeL List = name@@ scope . get CaMeL Elements ( I CaMeL Module CaMeL Name CaMeL Space . AR@@ BIT@@ ARY _ LEVEL ) ; return generate CaMeL Handle CaMeL List ( element CaMeL List ) ; }	. get CaMeL Elements ( I CaMeL Module CaMeL Name CaMeL Scope . AR@@ BIT@@ ARY _ LEVEL ) ;
return ( float ) current CaMeL Size / ( float ) client CaMeL Size ;  <CTX>  public float get CaMeL Current CaMeL Ratio ( ) { if ( current CaMeL Pane == null ) { return 0 . 0 f ; } boolean is CaMeL Vertical = ! Geometry . is CaMeL Horizontal ( side ) ; Rectangle client CaMeL Area = client CaMeL Composite . get CaMeL Client CaMeL Area ( ) ; int client CaMeL Size = Geometry . get CaMeL Dimension ( client CaMeL Area , is CaMeL Vertical ) ; int current CaMeL Size = Geometry . get CaMeL Dimension ( get CaMeL Bounds ( ) , is CaMeL Vertical ) ; return ( float ) current CaMeL Size / ( float ) client CaMeL Size ; }	return ( float ) size / ( float ) client CaMeL Size ;
return this . g@@ it@@ ter@@ button . is CaMeL Selected ( ) ; }  <CTX>  public boolean g@@ itter CaMeL Ge@@ wa@@ eh@@ lt ( ) { return this . g@@ it@@ ter@@ button . is CaMeL Selected ( ) ; } / / g@@ itter CaMeL Ge@@ wa@@ eh@@ lt ( )	return this . grid CaMeL Button . is CaMeL Selected ( ) ; }
if ( break CaMeL Call CaMeL Stack ) { return ; } break CaMeL Call CaMeL Stack = true ; super . tear CaMeL Down ( ) ;  <CTX>  protected void do CaMeL Tear CaMeL Down ( ) throws Exception { try { s . close ( ) ; } catch ( Exception e ) { } / / avoid infinite recursion resulting in stack overflow if ( break CaMeL Call CaMeL Stack ) { return ; } break CaMeL Call CaMeL Stack = true ; super . tear CaMeL Down ( ) ; }	super . do CaMeL Tear CaMeL Down ( ) ;
Ruby CaMeL Array result = Ruby CaMeL Array . new CaMeL Array ( get CaMeL Runtime ( ) , constructors . length ) ;  <CTX>  public Ruby CaMeL Array constructors ( ) { Constructor [ ] constructors = java CaMeL Class . get CaMeL Constructors ( ) ; Ruby CaMeL Array result = Ruby CaMeL Array . new CaMeL Array ( get CaMeL Runtime ( ) , constructors . length ) ; for ( int i = 0 ; i < constructors . length ; i ++ ) { result . append ( new Java CaMeL Constructor ( get CaMeL Runtime ( ) , constructors [ i ] ) ) ; } return result ; }	Ruby CaMeL Array result = get CaMeL Runtime ( ) . new CaMeL Array ( constructors . length ) ;
throw new Runtime CaMeL Exception ( ex ) ;  <CTX>  public void on CaMeL Response ( ) { / / we don t have to write variable data -> this already / / happ@@ ened in the native CaMeL API impl Fault CaMeL Data fault = null ; Element response ; try { response = get CaMeL B@@ pel CaMeL Runtime CaMeL Context ( ) . get CaMeL Partner CaMeL Response ( mex CaMeL Id ) ; } catch ( Exception ex ) { / / TODO : Better error handling throw new Runtime CaMeL Exception ( ex ) ; } get CaMeL B@@ pel CaMeL Runtime CaMeL Context ( ) . initialize CaMeL Variable ( output CaMeL Var , response ) ; try { for ( O CaMeL Scope . Correlation CaMeL Set an CaMeL Init CaMeL Correlations CaMeL Output : _ o@@ invoke . init CaMeL Correlations CaMeL Output ) { initialize CaMeL Correlation ( _ scope CaMeL Frame . resolve ( an CaMeL Init CaMeL Correlations CaMeL Output ) , output CaMeL Var ) ; } if ( _ o@@ invoke . partner CaMeL Link . has CaMeL Partner CaMeL Role ( ) ) { / / Trying to initialize partner epr based on a message - provided epr / session . if ( ! get CaMeL B@@ pel CaMeL Runtime CaMeL Context ( ) . is CaMeL Partner CaMeL Role CaMeL Endpoint CaMeL Initialized ( _ scope CaMeL Frame . resolve ( _ o@@ invoke . partner CaMeL Link ) ) ) { Node from CaMeL Epr = get CaMeL B@@ pel CaMeL Runtime CaMeL Context ( ) . get CaMeL Source CaMeL EPR ( mex CaMeL Id ) ; if ( from CaMeL Epr != null ) { get CaMeL B@@ pel CaMeL Runtime CaMeL Context ( ) . write CaMeL Endpoint CaMeL Reference ( _ scope CaMeL Frame . resolve ( _ o@@ invoke . partner CaMeL Link ) , ( Element ) from CaMeL Epr ) ; } } String partners CaMeL Session CaMeL Id = get CaMeL B@@ pel CaMeL Runtime CaMeL Context ( ) . get CaMeL Source CaMeL Session CaMeL Id ( mex CaMeL Id ) ; if ( partners CaMeL Session CaMeL Id != null ) get CaMeL B@@ pel CaMeL Runtime CaMeL Context ( ) . initialize CaMeL Partners CaMeL Session CaMeL Id ( _ scope CaMeL Frame . resolve ( _ o@@ invoke . partner CaMeL Link ) , partners CaMeL Session CaMeL Id ) ; } } catch ( Fault CaMeL Exception e ) { _ _ log . error ( e ) ; fault = create CaMeL Fault ( e . get CaMeL Q CaMeL Name ( ) , _ o@@ invoke ) ; } / / TODO update output variable with data from non - initiate / / correlation sets _ self . parent . completed ( fault , Compensation CaMeL Handler . empty CaMeL Set ( ) ) ; }	throw new Runtime CaMeL Exception ( e ) ;
return Ruby CaMeL Array . new CaMeL Array ( get CaMeL Runtime ( ) , ( I CaMeL Ruby CaMeL Object [ ] ) ruby CaMeL Thread CaMeL List . values ( ) . to CaMeL Array ( new I CaMeL Ruby CaMeL Object [ ruby CaMeL Thread CaMeL List . size ( ) ] ) ) ;  <CTX>  public I CaMeL Ruby CaMeL Object list ( ) { return Ruby CaMeL Array . new CaMeL Array ( get CaMeL Runtime ( ) , ( I CaMeL Ruby CaMeL Object [ ] ) ruby CaMeL Thread CaMeL List . values ( ) . to CaMeL Array ( new I CaMeL Ruby CaMeL Object [ ruby CaMeL Thread CaMeL List . size ( ) ] ) ) ; }	return get CaMeL Runtime ( ) . new CaMeL Array ( ( I CaMeL Ruby CaMeL Object [ ] ) ruby CaMeL Thread CaMeL List . values ( ) . to CaMeL Array ( new I CaMeL Ruby CaMeL Object [ ruby CaMeL Thread CaMeL List . size ( ) ] ) ) ;
return index CaMeL Impl . terminate ( ) ;  <CTX>  public Index terminate ( ) { return index CaMeL Impl . terminate ( ) ; }	return index CaMeL Model . terminate ( ) ;
( Integer ) m _ name CaMeL To CaMeL Id CaMeL Mapping . get ( field CaMeL Name . to CaMeL Upper CaMeL Case ( ) ) ;  <CTX>  public int get CaMeL Field CaMeL Index ( String field CaMeL Name ) { Integer i = ( Integer ) m _ name CaMeL To CaMeL Id CaMeL Mapping . get ( field CaMeL Name . to CaMeL Upper CaMeL Case ( ) ) ; return ( i == null ) ? - 1 : i . int CaMeL Value ( ) ; }	( Integer ) m _ name CaMeL To CaMeL Id CaMeL Mapping . get ( field CaMeL Name ) ;
boolean is CaMeL Pure CaMeL Virtual , List constructor CaMeL Chain , boolean is CaMeL Definition , boolean has CaMeL Function CaMeL Try CaMeL Block ) throws AST CaMeL Semantic CaMeL Exception , Exception ;  <CTX>  public IAST CaMeL Function create CaMeL Function ( IAST CaMeL Scope scope , I CaMeL Token CaMeL D@@ uple name , List parameters , IAST CaMeL Abstract CaMeL Declaration return CaMeL Type , IAST CaMeL Exception CaMeL Specification exception , boolean is CaMeL Inline , boolean is CaMeL Friend , boolean is CaMeL Static , int start CaMeL Offset , int name CaMeL Offset , int name CaMeL End CaMeL Offset , IAST CaMeL Template owner CaMeL Template , boolean is CaMeL Const , boolean is CaMeL Volatile , boolean is CaMeL Virtual , boolean is CaMeL Explicit , boolean is CaMeL Pure CaMeL Virtual , List constructor CaMeL Chain , boolean is CaMeL Definition , boolean has CaMeL Function CaMeL Try CaMeL Block ) throws AST CaMeL Semantic CaMeL Exception , Exception ;	boolean is CaMeL Pure CaMeL Virtual , List constructor CaMeL Chain , boolean is CaMeL Definition , boolean has CaMeL Function CaMeL Try CaMeL Block ) throws AST CaMeL Semantic CaMeL Exception ;
throws Class CaMeL Not CaMeL Found CaMeL Exception , Dataflow CaMeL Analysis CaMeL Exception {  <CTX>  private Cached CaMeL Exception CaMeL Set compute CaMeL Block CaMeL Exception CaMeL Set ( Basic CaMeL Block basic CaMeL Block , Type CaMeL Frame result ) throws Class CaMeL Not CaMeL Found CaMeL Exception , Dataflow CaMeL Analysis CaMeL Exception { Cached CaMeL Exception CaMeL Set cached CaMeL Exception CaMeL Set = get CaMeL Cached CaMeL Exception CaMeL Set ( basic CaMeL Block ) ; if ( ! cached CaMeL Exception CaMeL Set . is CaMeL Up CaMeL To CaMeL Date ( result ) ) { Exception CaMeL Set exception CaMeL Set = compute CaMeL Thrown CaMeL Exception CaMeL Types ( basic CaMeL Block ) ; Type CaMeL Frame copy CaMeL Of CaMeL Result = create CaMeL Fact ( ) ; copy ( result , copy CaMeL Of CaMeL Result ) ; cached CaMeL Exception CaMeL Set = new Cached CaMeL Exception CaMeL Set ( copy CaMeL Of CaMeL Result , exception CaMeL Set ) ; thrown CaMeL Exception CaMeL Set CaMeL Map . put ( basic CaMeL Block , cached CaMeL Exception CaMeL Set ) ; } return cached CaMeL Exception CaMeL Set ; }	throws Dataflow CaMeL Analysis CaMeL Exception {
Virtual CaMeL File CaMeL Manager . get CaMeL Instance ( ) . add CaMeL Virtual CaMeL File CaMeL Listener ( my CaMeL Vfs CaMeL Listener ) ;  <CTX>  public void project CaMeL Opened ( ) { Virtual CaMeL File CaMeL Manager . get CaMeL Instance ( ) . add CaMeL Virtual CaMeL File CaMeL Listener ( my CaMeL Vfs CaMeL Listener ) ; Startup CaMeL Manager . get CaMeL Instance ( my CaMeL Project ) . register CaMeL Post CaMeL Startup CaMeL Activity ( new Runnable ( ) { public void run ( ) { mark CaMeL Everything CaMeL Dirty ( ) ; } } ) ; }	if ( ( ( Application CaMeL Ex ) Application CaMeL Manager . get CaMeL Application ( ) ) . is CaMeL Internal ( ) ) { Virtual CaMeL File CaMeL Manager . get CaMeL Instance ( ) . add CaMeL Virtual CaMeL File CaMeL Listener ( my CaMeL Vfs CaMeL Listener ) ;
Object result = final CaMeL Resources . get ( class CaMeL Name ) ; if ( result == null ) { try { Class cg CaMeL Class = Class . for CaMeL Name ( class CaMeL Name , true , Thread . current CaMeL Thread ( ) . get CaMeL Context CaMeL Class CaMeL Loader ( ) ) ; result = cg CaMeL Class . new CaMeL Instance ( ) ; final CaMeL Resources . put ( class CaMeL Name , result ) ; } catch ( Exception ex ) { log . fatal ( null , ex ) ; }  <CTX>  public static Object make CaMeL CG ( String class CaMeL Name ) { Object result = final CaMeL Resources . get ( class CaMeL Name ) ; if ( result == null ) { try { Class cg CaMeL Class = Class . for CaMeL Name ( class CaMeL Name , true , Thread . current CaMeL Thread ( ) . get CaMeL Context CaMeL Class CaMeL Loader ( ) ) ; result = cg CaMeL Class . new CaMeL Instance ( ) ; final CaMeL Resources . put ( class CaMeL Name , result ) ; } catch ( Exception ex ) { log . fatal ( null , ex ) ; } } return result ; }	/ * changed this method due to No CaMeL Class CaMeL Def CaMeL Found CaMeL Error at Tomcat startup . * see http : * / Object result = null ; try { Class cg CaMeL Class = Class . for CaMeL Name ( class CaMeL Name , true , Thread . current CaMeL Thread ( ) . get CaMeL Context CaMeL Class CaMeL Loader ( ) ) ; result = cg CaMeL Class . new CaMeL Instance ( ) ; final CaMeL Resources . put ( class CaMeL Name , result ) ; } catch ( Exception ex ) { log . fatal ( null , ex ) ;
throw Standard CaMeL Exception . new CaMeL Exception ( SQL CaMeL State . LANG _ FILE _ ERROR , ioe . to CaMeL String ( ) , ioe ) ;  <CTX>  public Object read CaMeL Jar CaMeL File ( String schema CaMeL Name , String sql CaMeL Name ) throws Standard CaMeL Exception { Data CaMeL Dictionary CaMeL Context ddc = ( Data CaMeL Dictionary CaMeL Context ) Context CaMeL Service . get CaMeL Context ( Data CaMeL Dictionary CaMeL Context . CONTEXT _ ID ) ; Data CaMeL Dictionary dd = ddc . get CaMeL Data CaMeL Dictionary ( ) ; Schema CaMeL Descriptor sd = dd . get CaMeL Schema CaMeL Descriptor ( schema CaMeL Name , null , true ) ; File CaMeL Info CaMeL Descriptor fid = dd . get CaMeL File CaMeL Info CaMeL Descriptor ( sd , sql CaMeL Name ) ; if ( fid == null ) throw Standard CaMeL Exception . new CaMeL Exception ( SQL CaMeL State . LANG _ FILE _ DOES _ NOT _ EXIST , sql CaMeL Name , schema CaMeL Name ) ; long generation CaMeL Id = fid . get CaMeL Generation CaMeL Id ( ) ; File CaMeL Resource fr = af . get CaMeL Transaction ( ddc . get CaMeL Context CaMeL Manager ( ) ) . get CaMeL File CaMeL Handler ( ) ; String external CaMeL Name = org . apache . derby . impl . sql . execute . Jar CaMeL DDL . mk CaMeL External CaMeL Name ( schema CaMeL Name , sql CaMeL Name , fr . get CaMeL Separator CaMeL Char ( ) ) ; Object f = fr . get CaMeL As CaMeL File ( external CaMeL Name , generation CaMeL Id ) ; if ( f instanceof java . io . File ) return f ; try { return fr . get CaMeL As CaMeL Stream ( external CaMeL Name , generation CaMeL Id ) ; } catch ( java . io . IO CaMeL Exception ioe ) { throw Standard CaMeL Exception . new CaMeL Exception ( SQL CaMeL State . LANG _ FILE _ ERROR , ioe . to CaMeL String ( ) , ioe ) ; } }	throw Standard CaMeL Exception . new CaMeL Exception ( SQL CaMeL State . LANG _ FILE _ ERROR , ioe , ioe . to CaMeL String ( ) ) ;
xctxt . push CaMeL Predicate CaMeL Pos ( i ) ; try  <CTX>  protected static X CaMeL Object execute CaMeL Predicates ( X CaMeL Path CaMeL Context xctxt , Step CaMeL Pattern prev CaMeL Step , X CaMeL Object score , int context , int predicate CaMeL Root CaMeL Context ) throws javax . xml . transform . Transformer CaMeL Exception { int n = prev CaMeL Step . get CaMeL Predicate CaMeL Count ( ) ; if ( n != 0 ) { try { xctxt . push CaMeL Current CaMeL Node ( context ) ; xctxt . push CaMeL Sub CaMeL Context CaMeL List ( prev CaMeL Step ) ; xctxt . push CaMeL Predicate CaMeL Root ( predicate CaMeL Root CaMeL Context ) ; for ( int i = 0 ; i < n ; i ++ ) { xctxt . push CaMeL Predicate CaMeL Pos ( i ) ; try { X CaMeL Object pred = prev CaMeL Step . m _ predicates [ i ] . execute ( xctxt ) ; if ( X CaMeL Object . CLASS _ NUMBER == pred . get CaMeL Type ( ) ) { int pos = ( int ) pred . num ( ) ; if ( prev CaMeL Step . get CaMeL Proximity CaMeL Position ( xctxt , i ) != pos ) { score = Node CaMeL Test . SCORE _ NONE ; break ; } } else if ( ! pred . bool ( ) ) { score = Node CaMeL Test . SCORE _ NONE ; break ; } } finally { xctxt . pop CaMeL Predicate CaMeL Pos ( ) ; } } } finally { xctxt . pop CaMeL Current CaMeL Node ( ) ; xctxt . pop CaMeL Sub CaMeL Context CaMeL List ( ) ; xctxt . pop CaMeL Predicate CaMeL Root ( ) ; } } return score ; }	X CaMeL Object pred = m _ predicates [ i ] . execute ( xctxt ) ; if ( X CaMeL Object . CLASS _ NUMBER == pred . get CaMeL Type ( ) )
( ( Registry CaMeL Browser CaMeL Content CaMeL Provider ) tree CaMeL Viewer . get CaMeL Content CaMeL Provider ( ) ) . set CaMeL Show CaMeL Type ( Show CaMeL Plugins CaMeL Menu . SHOW _ ALL _ PLUGINS ) ; tree CaMeL Viewer . refresh ( ) ; }  <CTX>  public void run ( ) { ( ( Registry CaMeL Browser CaMeL Content CaMeL Provider ) tree CaMeL Viewer . get CaMeL Content CaMeL Provider ( ) ) . set CaMeL Show CaMeL Type ( Show CaMeL Plugins CaMeL Menu . SHOW _ ALL _ PLUGINS ) ; tree CaMeL Viewer . refresh ( ) ; }	tree CaMeL Viewer . refresh ( ) ; }
return Ruby CaMeL Fixnum . new CaMeL Fixnum ( runtime , cal . get ( Calendar . MINUTE ) ) ;  <CTX>  public Ruby CaMeL Integer min ( ) { return Ruby CaMeL Fixnum . new CaMeL Fixnum ( runtime , cal . get ( Calendar . MINUTE ) ) ; }	return get CaMeL Runtime ( ) . new CaMeL Fixnum ( cal . get ( Calendar . MINUTE ) ) ;
if ( element != null && element . get CaMeL Element CaMeL Type ( ) == Element CaMeL Type . JSP _ SCRIPT@@ LET _ START ) {  <CTX>  private Block build CaMeL Block CaMeL For CaMeL Scriptlet CaMeL Node ( final AST CaMeL Node child , final Indent indent ) { if ( ! ( child . get CaMeL Psi ( ) instanceof Jsp CaMeL Text ) ) return null ; AST CaMeL Node element = child . get CaMeL Psi ( ) . get CaMeL Containing CaMeL File ( ) . get CaMeL Psi CaMeL Roots ( ) [ 0 ] . get CaMeL Node ( ) . find CaMeL Leaf CaMeL Element CaMeL At ( child . get CaMeL Text CaMeL Range ( ) . get CaMeL Start CaMeL Offset ( ) ) ; if ( element != null && element . get CaMeL Element CaMeL Type ( ) == Element CaMeL Type . JSP _ SCRIPT@@ LET _ START ) { final Array CaMeL List < Block > sub CaMeL Blocks = new Array CaMeL List < Block > ( ) ; while ( element != null && element . get CaMeL Text CaMeL Range ( ) . get CaMeL End CaMeL Offset ( ) <= child . get CaMeL Text CaMeL Range ( ) . get CaMeL End CaMeL Offset ( ) ) { if ( ! contains CaMeL White CaMeL Spaces CaMeL Only ( element ) ) { sub CaMeL Blocks . add ( create CaMeL Child CaMeL Block ( element , null , null , Formatter . get CaMeL Instance ( ) . get CaMeL None CaMeL Indent ( ) ) ) ; } element = element . get CaMeL Tree CaMeL Next ( ) ; } return new Synthetic CaMeL Block ( sub CaMeL Blocks , this , indent , my CaMeL Xml CaMeL Formatting CaMeL Policy , get CaMeL Formatter ( ) . create CaMeL Normal CaMeL Indent ( ) ) ; } else { return null ; } }	if ( element != null && ( element . get CaMeL Element CaMeL Type ( ) == Element CaMeL Type . JSP _ SCRIPT@@ LET _ START || element . get CaMeL Element CaMeL Type ( ) == Element CaMeL Type . JSP _ DECLARATION _ START ) ) {
selected CaMeL Host CaMeL Exports . add ( host CaMeL Exports [ j ] . get CaMeL Export CaMeL Package CaMeL Description ( ) ) ; Export CaMeL Package CaMeL Description [ ] host CaMeL Exports CaMeL Array = ( Export CaMeL Package CaMeL Description [ ] ) selected CaMeL Host CaMeL Exports . to CaMeL Array ( new Export CaMeL Package CaMeL Description [ selected CaMeL Host CaMeL Exports . size ( ) ] ) ;  <CTX>  private void state CaMeL Resolve CaMeL Bundle ( Resolver CaMeL Bundle rb ) { / / Gather selected exports Resolver CaMeL Export [ ] exports = rb . get CaMeL Selected CaMeL Exports ( ) ; Array CaMeL List selected CaMeL Exports = new Array CaMeL List ( exports . length ) ; for ( int i = 0 ; i < exports . length ; i ++ ) { selected CaMeL Exports . add ( exports [ i ] . get CaMeL Export CaMeL Package CaMeL Description ( ) ) ; } Export CaMeL Package CaMeL Description [ ] selected CaMeL Exports CaMeL Array = ( Export CaMeL Package CaMeL Description [ ] ) selected CaMeL Exports . to CaMeL Array ( new Export CaMeL Package CaMeL Description [ selected CaMeL Exports . size ( ) ] ) ; / / Gather exports that have been wired to Resolver CaMeL Import [ ] imports = rb . get CaMeL Import CaMeL Packages ( ) ; Array CaMeL List exports CaMeL Wired CaMeL To = new Array CaMeL List ( imports . length ) ; for ( int i = 0 ; i < imports . length ; i ++ ) { if ( imports [ i ] . get CaMeL Matching CaMeL Export ( ) != null ) { exports CaMeL Wired CaMeL To . add ( imports [ i ] . get CaMeL Matching CaMeL Export ( ) . get CaMeL Export CaMeL Package CaMeL Description ( ) ) ; } } Export CaMeL Package CaMeL Description [ ] exports CaMeL Wired CaMeL To CaMeL Array = ( Export CaMeL Package CaMeL Description [ ] ) exports CaMeL Wired CaMeL To . to CaMeL Array ( new Export CaMeL Package CaMeL Description [ exports CaMeL Wired CaMeL To . size ( ) ] ) ; / / Gather bundles that have been wired to Bundle CaMeL Constraint [ ] requires = rb . get CaMeL Requires ( ) ; Array CaMeL List bundles CaMeL Wired CaMeL To = new Array CaMeL List ( requires . length ) ; for ( int i = 0 ; i < requires . length ; i ++ ) if ( requires [ i ] . get CaMeL Matching CaMeL Bundle ( ) != null ) bundles CaMeL Wired CaMeL To . add ( requires [ i ] . get CaMeL Matching CaMeL Bundle ( ) . get CaMeL Bundle ( ) ) ; Bundle CaMeL Description [ ] bundles CaMeL Wired CaMeL To CaMeL Array = ( Bundle CaMeL Description [ ] ) bundles CaMeL Wired CaMeL To . to CaMeL Array ( new Bundle CaMeL Description [ bundles CaMeL Wired CaMeL To . size ( ) ] ) ; Bundle CaMeL Description [ ] host CaMeL Bundles = null ; if ( rb . is CaMeL Fragment ( ) ) { Resolver CaMeL Bundle [ ] matching CaMeL Bundles = rb . get CaMeL Host ( ) . get CaMeL Matching CaMeL Bundles ( ) ; if ( matching CaMeL Bundles != null && matching CaMeL Bundles . length > 0 ) { host CaMeL Bundles = new Bundle CaMeL Description [ matching CaMeL Bundles . length ] ; for ( int i = 0 ; i < matching CaMeL Bundles . length ; i ++ ) { host CaMeL Bundles [ i ] = matching CaMeL Bundles [ i ] . get CaMeL Bundle ( ) ; if ( rb . is CaMeL New CaMeL Fragment CaMeL Exports ( ) ) { / / update the host s set of selected exports Resolver CaMeL Bundle host CaMeL RB = ( Resolver CaMeL Bundle ) bundle CaMeL Mapping . get ( host CaMeL Bundles [ i ] ) ; Resolver CaMeL Export [ ] host CaMeL Exports = host CaMeL RB . get CaMeL Selected CaMeL Exports ( ) ; Array CaMeL List selected CaMeL Host CaMeL Exports = new Array CaMeL List ( host CaMeL Exports . length ) ; for ( int j = 0 ; j < host CaMeL Exports . length ; j ++ ) selected CaMeL Host CaMeL Exports . add ( host CaMeL Exports [ j ] . get CaMeL Export CaMeL Package CaMeL Description ( ) ) ; Export CaMeL Package CaMeL Description [ ] host CaMeL Exports CaMeL Array = ( Export CaMeL Package CaMeL Description [ ] ) selected CaMeL Host CaMeL Exports . to CaMeL Array ( new Export CaMeL Package CaMeL Description [ selected CaMeL Host CaMeL Exports . size ( ) ] ) ; state . resolve CaMeL Bundle ( host CaMeL Bundles [ i ] , true , null , host CaMeL Exports CaMeL Array , host CaMeL Bundles [ i ] . get CaMeL Resolved CaMeL Requires ( ) , host CaMeL Bundles [ i ] . get CaMeL Resolved CaMeL Imports ( ) ) ; } } } } / / Resolve the bundle in the state state . resolve CaMeL Bundle ( rb . get CaMeL Bundle ( ) , true , host CaMeL Bundles , selected CaMeL Exports CaMeL Array , bundles CaMeL Wired CaMeL To CaMeL Array , exports CaMeL Wired CaMeL To CaMeL Array ) ; }	host CaMeL Exports CaMeL Array [ j ] = host CaMeL Exports [ j ] . get CaMeL Export CaMeL Package CaMeL Description ( ) ;
super . view CaMeL Topic ( request , next , topic ) ;  <CTX>  private void view CaMeL Topic ( Http CaMeL Servlet CaMeL Request request , Model CaMeL And CaMeL View next ) throws Exception { String topic = J@@ AM CaMeL Wiki CaMeL Servlet . get CaMeL Topic CaMeL From CaMeL URI ( request ) ; if ( ! String CaMeL Utils . has CaMeL Text ( topic ) ) { String virtual CaMeL Wiki CaMeL Name = get CaMeL Virtual CaMeL Wiki CaMeL From CaMeL URI ( request ) ; Virtual CaMeL Wiki virtual CaMeL Wiki = Wiki CaMeL Base . get CaMeL Handler ( ) . lookup CaMeL Virtual CaMeL Wiki ( virtual CaMeL Wiki CaMeL Name ) ; topic = virtual CaMeL Wiki . get CaMeL Default CaMeL Topic CaMeL Name ( ) ; } super . view CaMeL Topic ( request , next , topic ) ; }	super . view CaMeL Topic ( request , next , page CaMeL Info , topic ) ;
register CaMeL Error ( expression ) ;  <CTX>  private void check CaMeL Condition ( Psi CaMeL Expression expression , Psi CaMeL Statement context ) { if ( expression instanceof Psi CaMeL Instance CaMeL Of CaMeL Expression ) { final Psi CaMeL Instance CaMeL Of CaMeL Expression instance CaMeL Of CaMeL Expression = ( Psi CaMeL Instance CaMeL Of CaMeL Expression ) expression ; final Psi CaMeL Expression operand = instance CaMeL Of CaMeL Expression . get CaMeL Operand ( ) ; check CaMeL Condition ( operand , context ) ; } else if ( expression instanceof Psi CaMeL Binary CaMeL Expression ) { final Psi CaMeL Binary CaMeL Expression binary CaMeL Expression = ( Psi CaMeL Binary CaMeL Expression ) expression ; Psi CaMeL Expression lhs = binary CaMeL Expression . get CaMeL L CaMeL Operand ( ) ; Psi CaMeL Expression rhs = binary CaMeL Expression . get CaMeL R CaMeL Operand ( ) ; if ( rhs == null ) { return ; } lhs = Parentheses CaMeL Utils . strip CaMeL Parentheses ( lhs ) ; rhs = Parentheses CaMeL Utils . strip CaMeL Parentheses ( rhs ) ; if ( Comparison CaMeL Utils . is CaMeL Comparison ( binary CaMeL Expression ) ) { if ( lhs instanceof Psi CaMeL Literal CaMeL Expression ) { check CaMeL Condition ( rhs , context ) ; } else if ( rhs instanceof Psi CaMeL Literal CaMeL Expression ) { check CaMeL Condition ( lhs , context ) ; } } else { check CaMeL Condition ( rhs , context ) ; check CaMeL Condition ( lhs , context ) ; } } else if ( expression instanceof Psi CaMeL Reference CaMeL Expression ) { final Psi CaMeL Reference CaMeL Expression reference CaMeL Expression = ( Psi CaMeL Reference CaMeL Expression ) expression ; final Psi CaMeL Element element = reference CaMeL Expression . resolve ( ) ; if ( element instanceof Psi CaMeL Local CaMeL Variable ) { final Psi CaMeL Local CaMeL Variable variable = ( Psi CaMeL Local CaMeL Variable ) element ; if ( ! Variable CaMeL Access CaMeL Utils . variable CaMeL Is CaMeL Assigned ( variable , context ) ) { register CaMeL Error ( expression ) ; } } else if ( element instanceof Psi CaMeL Parameter ) { final Psi CaMeL Parameter parameter = ( Psi CaMeL Parameter ) element ; if ( ! Variable CaMeL Access CaMeL Utils . variable CaMeL Is CaMeL Assigned ( parameter , context ) ) { register CaMeL Error ( expression ) ; } } } else if ( expression instanceof Psi CaMeL Prefix CaMeL Expression ) { final Psi CaMeL Prefix CaMeL Expression prefix CaMeL Expression = ( Psi CaMeL Prefix CaMeL Expression ) expression ; final Psi CaMeL Java CaMeL Token sign = prefix CaMeL Expression . get CaMeL Operation CaMeL Sign ( ) ; final I CaMeL Element CaMeL Type token CaMeL Type = sign . get CaMeL Token CaMeL Type ( ) ; if ( Java CaMeL Token CaMeL Type . EXCL . equals ( token CaMeL Type ) ) { final Psi CaMeL Expression operand = prefix CaMeL Expression . get CaMeL Operand ( ) ; check CaMeL Condition ( operand , context ) ; } } }	register CaMeL Error ( condition ) ;
index CaMeL Manager . add CaMeL Source ( ( I CaMeL File ) temp CaMeL Resource , temp CaMeL Resource . get CaMeL Project ( ) . get CaMeL Full CaMeL Path ( ) ) ;  <CTX>  protected void process CaMeL Delta ( IC CaMeL Element CaMeL Delta delta ) throws C CaMeL Model CaMeL Exception { int kind = delta . get CaMeL Kind ( ) ; int flags = delta . get CaMeL Flags ( ) ; IC CaMeL Element element = delta . get CaMeL Element ( ) ; switch ( kind ) { case IC CaMeL Element CaMeL Delta . CHANGED : if ( ( flags & IC CaMeL Element CaMeL Delta . F _ CHANGED _ PATH@@ ENTRY _ INCLUDE ) != 0 || ( flags & IC CaMeL Element CaMeL Delta . F _ CHANGED _ PATH@@ ENTRY _ MACRO ) != 0 || ( flags & IC CaMeL Element CaMeL Delta . F _ ADDED _ PATH@@ ENTRY _ SOURCE ) != 0 ) { I CaMeL Resource temp CaMeL Resource = element . get CaMeL Resource ( ) ; Source CaMeL Root temp CaMeL Root CaMeL Element = null ; if ( temp CaMeL Resource == null ) return ; switch ( temp CaMeL Resource . get CaMeL Type ( ) ) { case I CaMeL Resource . FILE : index CaMeL Manager . add CaMeL Source ( ( I CaMeL File ) temp CaMeL Resource , temp CaMeL Resource . get CaMeL Project ( ) . get CaMeL Full CaMeL Path ( ) ) ; break ; case I CaMeL Resource . FOLDER : temp CaMeL Root CaMeL Element = ( Source CaMeL Root ) get CaMeL Element CaMeL Source ( element ) ; if ( temp CaMeL Root CaMeL Element != null ) { I CaMeL Project the CaMeL Proj = temp CaMeL Resource . get CaMeL Project ( ) ; index CaMeL Manager . index CaMeL Source CaMeL Folder ( the CaMeL Proj , temp CaMeL Resource . get CaMeL Full CaMeL Path ( ) , temp CaMeL Root CaMeL Element . get CaMeL Source CaMeL Entry ( ) . full CaMeL Exclusion CaMeL Pattern CaMeL Chars ( ) ) ; } break ; case I CaMeL Resource . PROJECT : index CaMeL Manager . index CaMeL All ( temp CaMeL Resource . get CaMeL Project ( ) ) ; break ; } } else if ( ( flags & IC CaMeL Element CaMeL Delta . F _ REMOVED _ PATH@@ ENTRY _ SOURCE ) != 0 ) { I CaMeL Resource temp CaMeL Resource = element . get CaMeL Resource ( ) ; I CaMeL Project project = temp CaMeL Resource . get CaMeL Project ( ) ; if ( index CaMeL Manager . index CaMeL Problems CaMeL Enabled ( project ) != 0 ) { index CaMeL Manager . remove CaMeL Indexer CaMeL Problems ( temp CaMeL Resource ) ; } } break ; } IC CaMeL Element CaMeL Delta [ ] affected CaMeL Children = delta . get CaMeL Affected CaMeL Children ( ) ; for ( int i = 0 ; i < affected CaMeL Children . length ; i ++ ) { process CaMeL Delta ( affected CaMeL Children [ i ] ) ; } }	index CaMeL Manager . add CaMeL Source ( ( I CaMeL File ) temp CaMeL Resource , temp CaMeL Resource . get CaMeL Project ( ) . get CaMeL Full CaMeL Path ( ) , false ) ;
super ( toolkit , label , new Swing CaMeL Label ( label ) ) ; final J CaMeL Label j CaMeL Label = ( J CaMeL Label ) j CaMeL Component ; Swing CaMeL Toolkit . add ( label , j CaMeL Label ) ; Swing CaMeL Toolkit . copy CaMeL Awt CaMeL Properties ( label , j CaMeL Label ) ; set CaMeL Text ( label . get CaMeL Text ( ) ) ; }  <CTX>  public Swing CaMeL Label CaMeL Peer ( Swing CaMeL Toolkit toolkit , Label label ) { super ( toolkit , label , new Swing CaMeL Label ( label ) ) ; final J CaMeL Label j CaMeL Label = ( J CaMeL Label ) j CaMeL Component ; Swing CaMeL Toolkit . add ( label , j CaMeL Label ) ; Swing CaMeL Toolkit . copy CaMeL Awt CaMeL Properties ( label , j CaMeL Label ) ; set CaMeL Text ( label . get CaMeL Text ( ) ) ; }	super ( toolkit , label , new Swing CaMeL Label ( label ) ) ; Swing CaMeL Toolkit . add ( label , j CaMeL Component ) ; Swing CaMeL Toolkit . copy CaMeL Awt CaMeL Properties ( label , j CaMeL Component ) ; set CaMeL Text ( label . get CaMeL Text ( ) ) ; set CaMeL Alignment ( label . get CaMeL Alignment ( ) ) ; }
list . add ( new Extends CaMeL Exception ( element , element . get CaMeL Extends CaMeL Name ( ) , Extends CaMeL Exception . DESIGN _ EXCEPTION _ NOT _ FOUND ) ) ;  <CTX>  public List validate ( Module module , Design CaMeL Element element ) { List list = new Array CaMeL List ( ) ; if ( ! String CaMeL Util . is CaMeL Empty ( element . get CaMeL Extends CaMeL Name ( ) ) && element . get CaMeL Extends CaMeL Element ( ) == null ) { list . add ( new Extends CaMeL Exception ( element , element . get CaMeL Extends CaMeL Name ( ) , Extends CaMeL Exception . DESIGN _ EXCEPTION _ NOT _ FOUND ) ) ; } return list ; }	list . add ( new Invalid CaMeL Parent CaMeL Exception ( element , element . get CaMeL Extends CaMeL Name ( ) , Invalid CaMeL Parent CaMeL Exception . DESIGN _ EXCEPTION _ PARENT _ NOT _ FOUND ) ) ;
if ( val == null || get ( ) . contains ( val ) ) return ;  <CTX>  public void set ( String val ) throws Invalid CaMeL Config CaMeL Value CaMeL Exception { if ( val == null || get ( ) . contains ( val ) ) return ; add CaMeL Plugin ( val , true ) ; } ;	if ( val == null || get ( ) . index CaMeL Of ( val ) >= 0 ) return ;
support . unread CaMeL Many ( here . get CaMeL Last CaMeL Line CaMeL Length ( ) ) ;  <CTX>  void he@@ redoc _ restore ( ) { Here CaMeL Doc CaMeL Node here = ( Here CaMeL Doc CaMeL Node ) lex _ str@@ term ; / / Maybe we need to unread more than this ? support . unread CaMeL Many ( here . get CaMeL Last CaMeL Line CaMeL Length ( ) ) ; }	support . set CaMeL Buffer ( here . get CaMeL Last CaMeL Line ( ) , here . get CaMeL Position ( ) ) ;
osw = ( Object CaMeL Store CaMeL Writer CaMeL Inter CaMeL Mine CaMeL Impl ) Object CaMeL Store CaMeL Writer CaMeL Factory . get CaMeL Object CaMeL Store CaMeL Writer ( osw CaMeL Alias ) ;  <CTX>  public void set CaMeL Up ( ) throws Exception { osw = ( Object CaMeL Store CaMeL Writer CaMeL Inter CaMeL Mine CaMeL Impl ) Object CaMeL Store CaMeL Writer CaMeL Factory . get CaMeL Object CaMeL Store CaMeL Writer ( osw CaMeL Alias ) ; }	Object CaMeL Store object CaMeL Store = Object CaMeL Store CaMeL Writer CaMeL Factory . get CaMeL Object CaMeL Store CaMeL Writer ( osw CaMeL Alias ) ; osw = ( Object CaMeL Store CaMeL Writer CaMeL Inter CaMeL Mine CaMeL Impl ) object CaMeL Store ;
if ( path != null && obj CaMeL Path != null ) return path . equals ( obj CaMeL Path ) ;  <CTX>  public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj instanceof I CaMeL Storage ) { I CaMeL Path path = get CaMeL Full CaMeL Path ( ) ; I CaMeL Path obj CaMeL Path = ( ( I CaMeL Storage ) obj ) . get CaMeL Full CaMeL Path ( ) ; if ( path != null && obj CaMeL Path != null ) return path . equals ( obj CaMeL Path ) ; } return super . equals ( obj ) ; }	if ( p != null && obj CaMeL Path != null ) return p . equals ( obj CaMeL Path ) ;
test . test CaMeL It ( ) ;  <CTX>  public static void main ( String [ ] args ) { Random CaMeL Structure CaMeL Generator CaMeL Test test = new Random CaMeL Structure CaMeL Generator CaMeL Test ( ) ; test . set CaMeL Stand CaMeL Alone ( true ) ; test . test CaMeL It ( ) ; }	try { test . test CaMeL It ( ) ; } catch ( Exception e ) { e . print CaMeL Stack CaMeL Trace ( ) ; }
set CaMeL Document CaMeL From CaMeL Request ( document , request ) ;  <CTX>  protected void dispatch CaMeL Ok CaMeL From CaMeL Edit CaMeL Page ( Http CaMeL Servlet CaMeL Request request , Http CaMeL Servlet CaMeL Response response ) throws IO CaMeL Exception , Servlet CaMeL Exception { set CaMeL Document CaMeL From CaMeL Request ( document , request ) ; }	Document CaMeL Permissions CaMeL Page document CaMeL Permissions CaMeL Page = new Document CaMeL Permissions CaMeL Page ( document ) ; document CaMeL Permissions CaMeL Page . set CaMeL From CaMeL Request ( request ) ;
if ( my CaMeL Choose CaMeL Different CaMeL Profile ) { my CaMeL Panel . apply ( ) ; final Inspection CaMeL Profile CaMeL Impl edited CaMeL Profile = ( Inspection CaMeL Profile CaMeL Impl ) my CaMeL Panel . get CaMeL Selected CaMeL Profile ( ) . get CaMeL Parent CaMeL Profile ( ) ; Inspection CaMeL Profile CaMeL Manager . get CaMeL Instance ( ) . set CaMeL Root CaMeL Profile ( edited CaMeL Profile . get CaMeL Name ( ) ) ; my CaMeL Inspection CaMeL Profile . copy CaMeL From ( edited CaMeL Profile ) ; Inspection CaMeL Project CaMeL Profile CaMeL Manager . get CaMeL Instance ( my CaMeL Project ) . init CaMeL Profile CaMeL Wrapper ( my CaMeL Inspection CaMeL Profile ) ; } else { final Inspection CaMeL Profile CaMeL Impl edited CaMeL Profile = ( Inspection CaMeL Profile CaMeL Impl ) my CaMeL Panel . get CaMeL Selected CaMeL Profile ( ) ; my CaMeL Inspection CaMeL Profile . copy CaMeL From ( edited CaMeL Profile ) ; my CaMeL Inspection CaMeL Profile . save ( ) ; my CaMeL Panel . init CaMeL Descriptors ( ) ; }  <CTX>  public void apply ( ) throws Configuration CaMeL Exception { if ( my CaMeL Choose CaMeL Different CaMeL Profile ) { my CaMeL Panel . apply ( ) ; final Inspection CaMeL Profile CaMeL Impl edited CaMeL Profile = ( Inspection CaMeL Profile CaMeL Impl ) my CaMeL Panel . get CaMeL Selected CaMeL Profile ( ) . get CaMeL Parent CaMeL Profile ( ) ; Inspection CaMeL Profile CaMeL Manager . get CaMeL Instance ( ) . set CaMeL Root CaMeL Profile ( edited CaMeL Profile . get CaMeL Name ( ) ) ; my CaMeL Inspection CaMeL Profile . copy CaMeL From ( edited CaMeL Profile ) ; Inspection CaMeL Project CaMeL Profile CaMeL Manager . get CaMeL Instance ( my CaMeL Project ) . init CaMeL Profile CaMeL Wrapper ( my CaMeL Inspection CaMeL Profile ) ; } else { final Inspection CaMeL Profile CaMeL Impl edited CaMeL Profile = ( Inspection CaMeL Profile CaMeL Impl ) my CaMeL Panel . get CaMeL Selected CaMeL Profile ( ) ; my CaMeL Inspection CaMeL Profile . copy CaMeL From ( edited CaMeL Profile ) ; my CaMeL Inspection CaMeL Profile . save ( ) ; my CaMeL Panel . init CaMeL Descriptors ( ) ; } }	my CaMeL Panel . apply ( ) ; Error CaMeL Options CaMeL Configurable . get CaMeL Instance ( my CaMeL Project ) . fire CaMeL Items CaMeL Changed CaMeL Externally ( ) ;
} else  <CTX>  protected void update CaMeL Service ( Viewer a CaMeL Viewer , Object an CaMeL Old CaMeL Input , Object a CaMeL New CaMeL Input ) { synchronized ( this ) { if ( structured CaMeL Viewer CaMeL Manager == null ) { structured CaMeL Viewer CaMeL Manager = new Structured CaMeL Viewer CaMeL Manager ( a CaMeL Viewer ) ; structured CaMeL Viewer CaMeL Manager . input CaMeL Changed ( an CaMeL Old CaMeL Input , a CaMeL New CaMeL Input ) ; } else structured CaMeL Viewer CaMeL Manager . input CaMeL Changed ( a CaMeL Viewer , an CaMeL Old CaMeL Input , a CaMeL New CaMeL Input ) ; for ( Iterator content CaMeL Itr = content CaMeL Extensions . values ( ) . iterator ( ) ; content CaMeL Itr . has CaMeL Next ( ) ; ) structured CaMeL Viewer CaMeL Manager . initialize ( ( ( Navigator CaMeL Content CaMeL Extension ) content CaMeL Itr . next ( ) ) . get CaMeL Content CaMeL Provider ( ) ) ; root CaMeL Content CaMeL Providers = extract CaMeL Content CaMeL Providers ( find CaMeL Root CaMeL Content CaMeL Extensions ( a CaMeL New CaMeL Input ) ) ; } }	} else {
return create CaMeL Project ( project CaMeL Name , location , Managed CaMeL Builder CaMeL Core CaMeL Plugin . MANAGED _ MAKE _ PROJECT _ ID , project CaMeL Type CaMeL Id ) ;  <CTX>  static public I CaMeL Project create CaMeL Project ( String project CaMeL Name , File zip , I CaMeL Path location , String project CaMeL Type CaMeL Id ) throws Core CaMeL Exception , Invocation CaMeL Target CaMeL Exception , IO CaMeL Exception { I CaMeL Workspace CaMeL Root root = Resources CaMeL Plugin . get CaMeL Workspace ( ) . get CaMeL Root ( ) ; I CaMeL Project project = root . get CaMeL Project ( project CaMeL Name ) ; if ( project . exists ( ) ) remove CaMeL Project ( project CaMeL Name ) ; I CaMeL Path dest CaMeL Path = ( location != null ) ? location : project . get CaMeL Full CaMeL Path ( ) ; if ( zip != null ) { import CaMeL Files CaMeL From CaMeL Zip ( new Zip CaMeL File ( zip ) , dest CaMeL Path , null ) ; } return create CaMeL Project ( project CaMeL Name , location , Managed CaMeL Builder CaMeL Core CaMeL Plugin . MANAGED _ MAKE _ PROJECT _ ID , project CaMeL Type CaMeL Id ) ; }	if ( ! project . is CaMeL Open ( ) ) { project . open ( new Null CaMeL Progress CaMeL Monitor ( ) ) ; } return project ;
throws Database CaMeL Unit CaMeL Exception , SQL CaMeL Exception  <CTX>  protected int execute CaMeL Row CaMeL Operation ( I CaMeL Prepared CaMeL Batch CaMeL Statement statement , Column [ ] columns , I CaMeL Table table , int row ) throws Database CaMeL Unit CaMeL Exception , SQL CaMeL Exception { for ( int i = 0 ; i < columns . length ; i ++ ) { Object value = table . get CaMeL Value ( row , columns [ i ] . get CaMeL Column CaMeL Name ( ) ) ; statement . add CaMeL Value ( value , columns [ i ] . get CaMeL Data CaMeL Type ( ) ) ; } statement . add CaMeL Batch ( ) ; int result = statement . execute CaMeL Batch ( ) ; statement . clear CaMeL Batch ( ) ; return result ; }	throws Data CaMeL Set CaMeL Exception , SQL CaMeL Exception
Library CaMeL Table CaMeL Editor . edit CaMeL Library CaMeL Table ( get CaMeL Project CaMeL Libraries CaMeL Provider ( ) ) . create CaMeL Add CaMeL Library CaMeL Action ( true , my CaMeL Whole CaMeL Panel ) . action CaMeL Performed ( null ) ;  <CTX>  public void action CaMeL Performed ( An CaMeL Action CaMeL Event e ) { Library CaMeL Table CaMeL Editor . edit CaMeL Library CaMeL Table ( get CaMeL Project CaMeL Libraries CaMeL Provider ( ) ) . create CaMeL Add CaMeL Library CaMeL Action ( true , my CaMeL Whole CaMeL Panel ) . action CaMeL Performed ( null ) ; }	Library CaMeL Table CaMeL Editor . edit CaMeL Library CaMeL Table ( get CaMeL Project CaMeL Libraries CaMeL Provider ( ) , my CaMeL Project ) . create CaMeL Add CaMeL Library CaMeL Action ( true , my CaMeL Whole CaMeL Panel ) . action CaMeL Performed ( null ) ;
activations CaMeL By CaMeL Source CaMeL Priority [ i ] = null ;  <CTX>  final void deactivate CaMeL Handler ( final I CaMeL Handler CaMeL Activation activation ) { / / First we update the handler CaMeL Activations CaMeL By CaMeL Command CaMeL Id map . final String command CaMeL Id = activation . get CaMeL Command CaMeL Id ( ) ; final Object value = handler CaMeL Activations CaMeL By CaMeL Command CaMeL Id . get ( command CaMeL Id ) ; if ( value instanceof Collection ) { final Collection handler CaMeL Activations = ( Collection ) value ; if ( handler CaMeL Activations . contains ( activation ) ) { handler CaMeL Activations . remove ( activation ) ; if ( handler CaMeL Activations . is CaMeL Empty ( ) ) { handler CaMeL Activations CaMeL By CaMeL Command CaMeL Id . remove ( command CaMeL Id ) ; update CaMeL Command ( command CaMeL Id , null ) ; } else if ( handler CaMeL Activations . size ( ) == 1 ) { final I CaMeL Handler CaMeL Activation remaining CaMeL Activation = ( I CaMeL Handler CaMeL Activation ) handler CaMeL Activations . iterator ( ) . next ( ) ; handler CaMeL Activations CaMeL By CaMeL Command CaMeL Id . put ( command CaMeL Id , remaining CaMeL Activation ) ; update CaMeL Command ( command CaMeL Id , ( evaluate ( remaining CaMeL Activation ) ? remaining CaMeL Activation : null ) ) ; } else { update CaMeL Command ( command CaMeL Id , resolve CaMeL Conflicts ( command CaMeL Id , handler CaMeL Activations ) ) ; } } } else if ( value instanceof I CaMeL Handler CaMeL Activation ) { if ( value == activation ) { handler CaMeL Activations CaMeL By CaMeL Command CaMeL Id . remove ( command CaMeL Id ) ; update CaMeL Command ( command CaMeL Id , null ) ; } } / / Next we update the source priority bucket sort of activations . final int source CaMeL Priority = activation . get CaMeL Source CaMeL Priority ( ) ; for ( int i = 1 ; i <= 32 ; i ++ ) { if ( ( source CaMeL Priority & ( 1 << i ) ) != 0 ) { final Set activations = activations CaMeL By CaMeL Source CaMeL Priority [ i ] ; if ( activations == null ) { continue ; } activations . remove ( activation ) ; if ( activations . is CaMeL Empty ( ) ) { activations CaMeL By CaMeL Source CaMeL Priority [ i ] = null ; } } } }	activations CaMeL By CaMeL Expression . remove ( expression ) ; } if ( activations CaMeL By CaMeL Expression . is CaMeL Empty ( ) ) { activations CaMeL By CaMeL Expression CaMeL By CaMeL Source CaMeL Priority [ i ] = null ;
if ( selection CaMeL Listener != null && step CaMeL Viewer != null ) step CaMeL Viewer . add CaMeL Selection CaMeL Changed CaMeL Listener ( selection CaMeL Listener ) ;  <CTX>  public void set CaMeL Selection CaMeL Listener ( I CaMeL Selection CaMeL Changed CaMeL Listener listener ) { if ( selection CaMeL Listener != null && step CaMeL Viewer != null ) step CaMeL Viewer . remove CaMeL Selection CaMeL Changed CaMeL Listener ( selection CaMeL Listener ) ; selection CaMeL Listener = listener ; if ( selection CaMeL Listener != null && step CaMeL Viewer != null ) step CaMeL Viewer . add CaMeL Selection CaMeL Changed CaMeL Listener ( selection CaMeL Listener ) ; }	if ( selection CaMeL Listener != null && step CaMeL Viewer != null ) { step CaMeL Viewer . add CaMeL Selection CaMeL Changed CaMeL Listener ( selection CaMeL Listener ) ; }
check CaMeL Permissions ( context , resource , I _ Cms CaMeL Constants . C _ READ _ ACCESS , true , filter ) ;  <CTX>  public List read CaMeL Child CaMeL Resources ( Cms CaMeL Request CaMeL Context context , Cms CaMeL Resource resource , Cms CaMeL Resource CaMeL Filter filter , boolean get CaMeL Folders , boolean get CaMeL Files ) throws Cms CaMeL Exception { / / check the access permissions check CaMeL Permissions ( context , resource , I _ Cms CaMeL Constants . C _ READ _ ACCESS , true , filter ) ; if ( ( ! filter . is CaMeL Valid ( context , resource ) ) ) { / / the parent folder was found , but it is invalid ac@@ cor@@ ding to the selected filter / / child resources are not available return Collections . EMPTY _ LIST ; } String folder CaMeL Name = resource . get CaMeL Root CaMeL Path ( ) ; / / try to get the sub resources from the cache String cache CaMeL Key ; if ( get CaMeL Folders && get CaMeL Files ) { cache CaMeL Key = Cms CaMeL Cache CaMeL Key . C _ CACHE _ KEY _ SUB@@ ALL ; } else if ( get CaMeL Folders ) { cache CaMeL Key = Cms CaMeL Cache CaMeL Key . C _ CACHE _ KEY _ SUB@@ FOLDERS ; } else { cache CaMeL Key = Cms CaMeL Cache CaMeL Key . C _ CACHE _ KEY _ SUB@@ FILES ; } cache CaMeL Key = get CaMeL Cache CaMeL Key ( context . current CaMeL User ( ) . get CaMeL Name ( ) + cache CaMeL Key + filter . get CaMeL Cache CaMeL Id ( ) , context . current CaMeL Project ( ) , folder CaMeL Name ) ; List sub CaMeL Resources = ( List ) m _ resource CaMeL List CaMeL Cache . get ( cache CaMeL Key ) ; if ( sub CaMeL Resources != null && sub CaMeL Resources . size ( ) > 0 ) { / / the parent folder is not deleted , and the sub resources were cached , no further operations required / / we must however still filter the cached results for release / expiration date return set CaMeL Full CaMeL Resource CaMeL Names ( context , sub CaMeL Resources , filter ) ; } / / read the result form the database sub CaMeL Resources = m _ vfs CaMeL Driver . read CaMeL Child CaMeL Resources ( context . current CaMeL Project ( ) , resource , get CaMeL Folders , get CaMeL Files ) ; for ( int i = 0 ; i < sub CaMeL Resources . size ( ) ; i ++ ) { Cms CaMeL Resource current CaMeL Resource = ( Cms CaMeL Resource ) sub CaMeL Resources . get ( i ) ; int perms = has CaMeL Permissions ( context , current CaMeL Resource , I _ Cms CaMeL Constants . C _ READ _ OR _ VIEW _ ACCESS , true , filter ) ; if ( PERM _ DENIED == perms ) { sub CaMeL Resources . remove ( i -- ) ; } } / / cache the sub resources m _ resource CaMeL List CaMeL Cache . put ( cache CaMeL Key , sub CaMeL Resources ) ; / / filter the result to remove resources outside release / expiration time window / / the setting of resource names ab@@ oce is NOR redundant , since the loop above / / is mu@@ ch more e@@ fficient than reading the path again return set CaMeL Full CaMeL Resource CaMeL Names ( context , sub CaMeL Resources , filter ) ; }	check CaMeL Permissions ( context , resource , Cms CaMeL Permission CaMeL Set . ACCESS _ READ , true , Cms CaMeL Resource CaMeL Filter . ALL ) ;
} fire CaMeL Label CaMeL Provider CaMeL Changed ( new Label CaMeL Provider CaMeL Changed CaMeL Event ( Presentation CaMeL Label CaMeL Provider . this ) ) ;  <CTX>  public void dispose ( ) { super . dispose ( ) ; color CaMeL Registry . remove CaMeL Listener ( listener ) ; font CaMeL Registry . remove CaMeL Listener ( listener ) ; for ( Iterator i = images . values ( ) . iterator ( ) ; i . has CaMeL Next ( ) ; ) { ( ( Image ) i . next ( ) ) . dispose ( ) ; } images . clear ( ) ; for ( Iterator i = fonts . values ( ) . iterator ( ) ; i . has CaMeL Next ( ) ; ) { ( ( Font ) i . next ( ) ) . dispose ( ) ; } fonts . clear ( ) ; if ( empty CaMeL Image != null ) { empty CaMeL Image . dispose ( ) ; empty CaMeL Image = null ; } fire CaMeL Label CaMeL Provider CaMeL Changed ( new Label CaMeL Provider CaMeL Changed CaMeL Event ( Presentation CaMeL Label CaMeL Provider . this ) ) ; }	} clear CaMeL Font CaMeL Cache ( ) ;
if ( system . get CaMeL Data ( ) != null ) return ( Trading CaMeL System CaMeL Plugin ) system . get CaMeL Data ( ) ; Trading CaMeL System CaMeL Plugin plugin = Trading CaMeL Plugin . create CaMeL Trading CaMeL System CaMeL Plugin ( system . get CaMeL Plugin CaMeL Id ( ) ) ; system . set CaMeL Data ( plugin ) ;  <CTX>  public static Trading CaMeL System CaMeL Plugin create CaMeL Trading CaMeL System CaMeL Plugin ( Trading CaMeL System system ) { if ( system . get CaMeL Data ( ) != null ) return ( Trading CaMeL System CaMeL Plugin ) system . get CaMeL Data ( ) ; Trading CaMeL System CaMeL Plugin plugin = Trading CaMeL Plugin . create CaMeL Trading CaMeL System CaMeL Plugin ( system . get CaMeL Plugin CaMeL Id ( ) ) ; system . set CaMeL Data ( plugin ) ; plugin . set CaMeL Account ( system . get CaMeL Account ( ) ) ; plugin . set CaMeL Security ( system . get CaMeL Security ( ) ) ; plugin . set CaMeL Max CaMeL Exposure ( system . get CaMeL Max CaMeL Exposure ( ) ) ; plugin . set CaMeL Min CaMeL Amount ( system . get CaMeL Min CaMeL Amount ( ) ) ; plugin . set CaMeL Max CaMeL Amount ( system . get CaMeL Max CaMeL Amount ( ) ) ; plugin . set CaMeL Parameters ( system . get CaMeL Parameters ( ) ) ; return plugin ; }	Trading CaMeL System CaMeL Plugin plugin = ( Trading CaMeL System CaMeL Plugin ) system . get CaMeL Data ( ) ; if ( plugin == null ) { plugin = Trading CaMeL Plugin . create CaMeL Trading CaMeL System CaMeL Plugin ( system . get CaMeL Plugin CaMeL Id ( ) ) ; system . set CaMeL Data ( plugin ) ; }
auto CaMeL Resize ( index + position ) ;  <CTX>  public Object set ( int index , Object element ) { auto CaMeL Resize ( index + position ) ; return delegate . set ( index + position , element ) ; }	auto CaMeL Resize ( index + position + 1 ) ;
Daemon CaMeL Code CaMeL Analyzer CaMeL Impl daemon CaMeL Code CaMeL Analyzer = ( Daemon CaMeL Code CaMeL Analyzer CaMeL Impl ) Daemon CaMeL Code CaMeL Analyzer . get CaMeL Instance ( my CaMeL Project ) ;  <CTX>  public void do CaMeL Apply CaMeL Information CaMeL To CaMeL Editor ( ) { if ( my CaMeL Highlights == null ) return ; Update CaMeL Highlighters CaMeL Util . set CaMeL Highlighters CaMeL To CaMeL Editor ( my CaMeL Project , my CaMeL Document , my CaMeL Start CaMeL Offset , my CaMeL End CaMeL Offset , my CaMeL Highlights , Pass . POST _ UPDATE _ ALL ) ; Daemon CaMeL Code CaMeL Analyzer CaMeL Impl daemon CaMeL Code CaMeL Analyzer = ( Daemon CaMeL Code CaMeL Analyzer CaMeL Impl ) Daemon CaMeL Code CaMeL Analyzer . get CaMeL Instance ( my CaMeL Project ) ; daemon CaMeL Code CaMeL Analyzer . get CaMeL File CaMeL Status CaMeL Map ( ) . mark CaMeL File CaMeL Up CaMeL To CaMeL Date ( my CaMeL Document , File CaMeL Status CaMeL Map . NORMAL _ HIGH@@ LIGHT@@ ERS ) ; if ( time CaMeL To CaMeL Optimize CaMeL Imports ( ) && my CaMeL Editor != null ) { optimize CaMeL Imports CaMeL On CaMeL The CaMeL Fly ( ) ; } }	Daemon CaMeL Code CaMeL Analyzer daemon CaMeL Code CaMeL Analyzer = Daemon CaMeL Code CaMeL Analyzer . get CaMeL Instance ( my CaMeL Project ) ;
if ( Regexp CaMeL Util . has CaMeL Flag ( options , MATCH _ MULTILINE ) )  <CTX>  protected int get CaMeL Compiler CaMeL Options ( int options ) { int c CaMeL Options = RE . MATCH _ NORMAL ; if ( Regexp CaMeL Util . has CaMeL Flag ( options , MATCH _ CASE _ INSENSITIVE ) ) c CaMeL Options |= RE . MATCH _ CASE@@ INDEPENDENT ; if ( Regexp CaMeL Util . has CaMeL Flag ( options , MATCH _ MULTILINE ) ) c CaMeL Options |= RE . MATCH _ MULTILINE ; if ( Regexp CaMeL Util . has CaMeL Flag ( options , MATCH _ SINGLELINE ) ) c CaMeL Options |= RE . MATCH _ SINGLELINE ; return c CaMeL Options ; }	} if ( Regexp CaMeL Util . has CaMeL Flag ( options , MATCH _ MULTILINE ) ) {
} else throw new XML CaMeL Configuration CaMeL Exception ( XML CaMeL Configuration CaMeL Exception . NOT _ RECOGNIZED , property CaMeL Id ) ;  <CTX>  public void set CaMeL Property ( String property CaMeL Id , Object state ) throws XML CaMeL Configuration CaMeL Exception { if ( property CaMeL Id . equals ( SYMBOL _ TABLE ) ) { f CaMeL Symbol CaMeL Table = ( Symbol CaMeL Table ) state ; } else if ( property CaMeL Id . equals ( ERROR _ REPORTER ) ) { f CaMeL Error CaMeL Reporter = ( XML CaMeL Error CaMeL Reporter ) state ; } else if ( property CaMeL Id . equals ( ERROR _ HANDLER ) ) { f CaMeL Error CaMeL Reporter . set CaMeL Property ( property CaMeL Id , state ) ; } else if ( property CaMeL Id . equals ( ENTITY _ RESOLVER ) ) { f CaMeL Entity CaMeL Resolver = ( XML CaMeL Entity CaMeL Resolver ) state ; } else if ( property CaMeL Id . equals ( XML@@ GRAMMAR _ POOL ) ) { f CaMeL Grammar CaMeL Pool = ( XML CaMeL Grammar CaMeL Pool ) state ; } else if ( property CaMeL Id . equals ( SCHEMA _ LOCATION ) ) { f CaMeL External CaMeL Schemas = ( String ) state ; } else if ( property CaMeL Id . equals ( SCHEMA _ N@@ ONS _ LOCATION ) ) { f CaMeL External CaMeL No CaMeL NS CaMeL Schema = ( String ) state ; } else if ( property CaMeL Id . equals ( JAXP _ SCHEMA _ SOURCE ) ) { f CaMeL JAXP CaMeL Source = state ; f CaMeL JAXP CaMeL Processed = false ; } else throw new XML CaMeL Configuration CaMeL Exception ( XML CaMeL Configuration CaMeL Exception . NOT _ RECOGNIZED , property CaMeL Id ) ; } / / set CaMeL Property ( String , Object )	} else if ( property CaMeL Id . equals ( XML@@ GRAMMAR _ POOL ) ) { f CaMeL Grammar CaMeL Pool = ( XML CaMeL Grammar CaMeL Pool ) state ; } else if ( property CaMeL Id . equals ( SCHEMA _ LOCATION ) ) { f CaMeL External CaMeL Schemas = ( String ) state ; } else if ( property CaMeL Id . equals ( SCHEMA _ N@@ ONS _ LOCATION ) ) { f CaMeL External CaMeL No CaMeL NS CaMeL Schema = ( String ) state ; } else if ( property CaMeL Id . equals ( ENTITY _ RESOLVER ) ) { f CaMeL Entity CaMeL Manager . set CaMeL Property ( ENTITY _ RESOLVER , state ) ; }
Tunnel CaMeL Info info = _ inbound CaMeL Exp@@ lor@@ atory . select CaMeL Tunnel ( ) ;  <CTX>  public Tunnel CaMeL Info select CaMeL Inbound CaMeL Tunnel ( ) { Tunnel CaMeL Info info = _ inbound CaMeL Exp@@ lor@@ atory . select CaMeL Tunnel ( ) ; if ( info == null ) { _ inbound CaMeL Exp@@ lor@@ atory . build CaMeL Fallback ( ) ; / / still can be null , but prob@@ ably not info = _ inbound CaMeL Exp@@ lor@@ atory . select CaMeL Tunnel ( ) ; } return info ; }	Tunnel CaMeL Pool pool = _ inbound CaMeL Exp@@ lor@@ atory ; if ( pool == null ) return null ; Tunnel CaMeL Info info = pool . select CaMeL Tunnel ( ) ;
return new UTF 8 Data CaMeL Chunk ( string CaMeL Pool , prev ) ;  <CTX>  public static UTF 8 Data CaMeL Chunk create CaMeL Chunk ( String CaMeL Pool string CaMeL Pool , UTF 8 Data CaMeL Chunk prev ) { if ( fg CaMeL Free CaMeL Chunks != null ) { UTF 8 Data CaMeL Chunk new CaMeL Chunk = fg CaMeL Free CaMeL Chunks ; fg CaMeL Free CaMeL Chunks = new CaMeL Chunk . f CaMeL Next CaMeL Chunk ; new CaMeL Chunk . f CaMeL Next CaMeL Chunk = null ; new CaMeL Chunk . init ( string CaMeL Pool , prev ) ; return new CaMeL Chunk ; } return new UTF 8 Data CaMeL Chunk ( string CaMeL Pool , prev ) ; }	UTF 8 Data CaMeL Chunk chunk = new UTF 8 Data CaMeL Chunk ( string CaMeL Pool , prev ) ; return chunk ;
int reference = indenter . find CaMeL Reference CaMeL Position ( c . offset , false , true , false , false ) ;  <CTX>  private void smart CaMeL Indent CaMeL After CaMeL Closing CaMeL Bracket ( I CaMeL Document d , Document CaMeL Command c ) { if ( c . offset == - 1 || d . get CaMeL Length ( ) == 0 ) return ; try { int p = ( c . offset == d . get CaMeL Length ( ) ? c . offset - 1 : c . offset ) ; int line = d . get CaMeL Line CaMeL Of CaMeL Offset ( p ) ; int start = d . get CaMeL Line CaMeL Offset ( line ) ; int white@@ end = find CaMeL End CaMeL Of CaMeL White CaMeL Space ( d , start , c . offset ) ; C CaMeL Heuristic CaMeL Scanner scanner = new C CaMeL Heuristic CaMeL Scanner ( d ) ; C CaMeL Indenter indenter = new C CaMeL Indenter ( d , scanner , f CaMeL Project ) ; / / shift only when line does not contain any text up to the closing bracket if ( white@@ end == c . offset ) { / / evaluate the line with the opening bracket that matches out closing bracket int reference = indenter . find CaMeL Reference CaMeL Position ( c . offset , false , true , false , false ) ; int ind CaMeL Line = d . get CaMeL Line CaMeL Of CaMeL Offset ( reference ) ; if ( ind CaMeL Line != - 1 && ind CaMeL Line != line ) { / / take the indent of the found line String CaMeL Buffer replace CaMeL Text = new String CaMeL Buffer ( get CaMeL Indent CaMeL Of CaMeL Line ( d , ind CaMeL Line ) ) ; / / add the rest of the current line including the just added close bracket replace CaMeL Text . append ( d . get ( white@@ end , c . offset - white@@ end ) ) ; replace CaMeL Text . append ( c . text ) ; / / modify document command c . length += c . offset - start ; c . offset = start ; c . text = replace CaMeL Text . to CaMeL String ( ) ; } } } catch ( Bad CaMeL Location CaMeL Exception e ) { CUI CaMeL Plugin . get CaMeL Default ( ) . log ( e ) ; } }	int reference = indenter . find CaMeL Reference CaMeL Position ( c . offset , false , true , false , false , false ) ;
int rows = num CaMeL Rows - 1 ;  <CTX>  private void copy CaMeL Stack CaMeL Ends CaMeL Timepoints ( int from , int to ) { control . copy CaMeL Stack ( from , to ) ; int rows = num CaMeL Rows - 1 ; Plane CaMeL Area pa ; int z ; for ( int i = 0 ; i < rows ; i ++ ) { z = rows - i ; pa = control . get CaMeL Plane CaMeL Area ( z , from ) ; set CaMeL Selected CaMeL Cell ( pa , i , from ) ; set CaMeL Selected CaMeL Cell ( pa , i , to ) ; } view . table . repaint ( from * num CaMeL Columns , 0 , to * cell CaMeL Width , num CaMeL Rows * cell CaMeL Height ) ; }	int rows = num CaMeL Rows ;
return ( additional CaMeL C CaMeL Keywords . get ( token CaMeL Image ) != null ) ;  <CTX>  public boolean is CaMeL Extension CaMeL Keyword ( Parser CaMeL Language language , String token CaMeL Image ) { if ( language == Parser CaMeL Language . CPP ) return ( additional CaMeL CPP CaMeL Keywords . get ( token CaMeL Image ) != null ) ; else if ( language == Parser CaMeL Language . C ) return ( additional CaMeL C CaMeL Keywords . get ( token CaMeL Image ) != null ) ; return false ; }	return ( additional CaMeL C CaMeL Keywords . contains CaMeL Key ( token CaMeL Image ) ) ;
int rule CaMeL Action = Token CaMeL Marker . SPAN | ( ( no CaMeL Line CaMeL Break ) ? Token CaMeL Marker . NO _ LINE _ BREAK : 0 ) | ( ( at CaMeL Line CaMeL Start ) ? Token CaMeL Marker . AT _ LINE _ START : 0 ) | ( ( exclude CaMeL Match ) ? Token CaMeL Marker . EXCLUDE _ MATCH : 0 ) | ( ( no CaMeL Word CaMeL Break ) ? Token CaMeL Marker . NO _ WORD _ BREAK : 0 ) ;  <CTX>  public static final Parser CaMeL Rule create CaMeL Span CaMeL Rule ( String begin , String end , String delegate , byte id , boolean no CaMeL Line CaMeL Break , boolean at CaMeL Line CaMeL Start , boolean exclude CaMeL Match , boolean no CaMeL Word CaMeL Break ) { int rule CaMeL Action = Token CaMeL Marker . SPAN | ( ( no CaMeL Line CaMeL Break ) ? Token CaMeL Marker . NO _ LINE _ BREAK : 0 ) | ( ( at CaMeL Line CaMeL Start ) ? Token CaMeL Marker . AT _ LINE _ START : 0 ) | ( ( exclude CaMeL Match ) ? Token CaMeL Marker . EXCLUDE _ MATCH : 0 ) | ( ( no CaMeL Word CaMeL Break ) ? Token CaMeL Marker . NO _ WORD _ BREAK : 0 ) ; return new Parser CaMeL Rule ( rule CaMeL Action , begin . to CaMeL Char CaMeL Array ( ) , end . to CaMeL Char CaMeL Array ( ) , delegate , id ) ; } / / } } }	int rule CaMeL Action = SPAN | ( ( no CaMeL Line CaMeL Break ) ? NO _ LINE _ BREAK : 0 ) | ( ( at CaMeL Line CaMeL Start ) ? AT _ LINE _ START : 0 ) | ( ( exclude CaMeL Match ) ? EXCLUDE _ MATCH : 0 ) | ( ( no CaMeL Word CaMeL Break ) ? NO _ WORD _ BREAK : 0 ) ;
if ( ( session == null ) || ( get CaMeL Mode ( ) != Portlet . Mode . EDIT ) ) return ;  <CTX>  public void set CaMeL Data ( Portlet CaMeL Data data ) { if ( ( session == null ) || ( get CaMeL Mode ( ) != Portlet . Mode . EDIT ) ) return ; req . set CaMeL Attribute ( Grid CaMeL Sphere CaMeL Properties . PORT@@ LET@@ DATA , data ) ; }	if ( ( portlet CaMeL Session == null ) || ( get CaMeL Mode ( ) != Portlet . Mode . EDIT ) ) return ;
Ruby CaMeL Array result CaMeL Array = Ruby CaMeL Array . new CaMeL Array ( runtime , result . size ( ) ) ;  <CTX>  public Ruby CaMeL Array results ( ) { process ( ) ; Ruby CaMeL Array result CaMeL Array = Ruby CaMeL Array . new CaMeL Array ( runtime , result . size ( ) ) ; Iterator iter = result . iterator ( ) ; while ( iter . has CaMeL Next ( ) ) { result CaMeL Array . append ( Ruby CaMeL String . new CaMeL String ( runtime , ( String ) iter . next ( ) ) ) ; } return result CaMeL Array ; }	Ruby CaMeL Array result CaMeL Array = runtime . new CaMeL Array ( result . size ( ) ) ;
void update CaMeL Text ( Main . Source CaMeL Info source CaMeL Info ) {  <CTX>  void update CaMeL Text ( Main . Source CaMeL Info source CaMeL Info ) { this . source CaMeL Info = source CaMeL Info ; String new CaMeL Text = source CaMeL Info . source ( ) ; if ( ! text CaMeL Area . get CaMeL Text ( ) . equals ( new CaMeL Text ) ) { text CaMeL Area . set CaMeL Text ( new CaMeL Text ) ; int pos = 0 ; if ( current CaMeL Pos != - 1 ) { pos = current CaMeL Pos ; } text CaMeL Area . select ( pos ) ; } file CaMeL Header . update ( ) ; file CaMeL Header . repaint ( ) ; }	void update CaMeL Text ( Dim . Source CaMeL Info source CaMeL Info ) {
void set CaMeL Input CaMeL Window CaMeL End ( int value ) { int w = view . get CaMeL Domain CaMeL Pane ( ) . get CaMeL W@@ avel@@ engths ( ) . get CaMeL Selected CaMeL Index ( ) ; set CaMeL Input CaMeL Window CaMeL End ( value , w ) ; }  <CTX>  void set CaMeL Input CaMeL Window CaMeL End ( int value ) { int w = view . get CaMeL Domain CaMeL Pane ( ) . get CaMeL W@@ avel@@ engths ( ) . get CaMeL Selected CaMeL Index ( ) ; set CaMeL Input CaMeL Window CaMeL End ( value , w ) ; }	void set CaMeL Input CaMeL Window CaMeL End ( int value , int w ) { Domain CaMeL Pane CaMeL Manager dp CaMeL Manager = view . get CaMeL Domain CaMeL Pane ( ) . get CaMeL Manager ( ) ; Graphics CaMeL Representation CaMeL Manager gr CaMeL Manager = view . get CaMeL G CaMeL Representation ( ) . get CaMeL Manager ( ) ; dp CaMeL Manager . set CaMeL Input CaMeL Window CaMeL End ( value ) ; gr CaMeL Manager . set CaMeL Input CaMeL Window CaMeL End ( value , get CaMeL Global CaMeL Channel CaMeL Window CaMeL Start ( w ) , get CaMeL Global CaMeL Channel CaMeL Window CaMeL End ( w ) ) ; }
if ( event . type == SWT . Activate ) activate CaMeL Editor ( e ) ;  <CTX>  public Composite create CaMeL Inner CaMeL Part CaMeL Control ( Composite parent , final I CaMeL Editor CaMeL Part e ) { Composite content = new Composite ( parent , SWT . NONE ) ; content . set CaMeL Layout ( new Fill CaMeL Layout ( ) ) ; e . create CaMeL Part CaMeL Control ( content ) ; parent . add CaMeL Listener ( SWT . Activate , new Listener ( ) { public void handle CaMeL Event ( Event event ) { if ( event . type == SWT . Activate ) activate CaMeL Editor ( e ) ; } } ) ; return content ; }	if ( event . type == SWT . Activate ) { activate CaMeL Editor ( e ) ; }
tt = ts . get CaMeL Token ( flags CaMeL TS ) ;  <CTX>  private int peek CaMeL Token ( int flags CaMeL TS ) throws IO CaMeL Exception { int tt = current CaMeL Flagged CaMeL Token ; if ( tt == Token . EOF ) { tt = ts . get CaMeL Token ( flags CaMeL TS ) ; if ( tt == Token . EOL ) { do { tt = ts . get CaMeL Token ( flags CaMeL TS ) ; } while ( tt == Token . EOL ) ; tt |= TI _ AFTER _ EOL ; } current CaMeL Flagged CaMeL Token = tt ; } return tt & CLEAR _ TI _ MASK ; }	tt = ts . get CaMeL Token ( ) ;
return ( Extension [ ] ) f CaMeL Extensions . to CaMeL Array ( new Extension [ f CaMeL Extensions . size ( ) ] ) ;  <CTX>  public Extension [ ] get CaMeL Extensions ( ) { return ( Extension [ ] ) f CaMeL Extensions . to CaMeL Array ( new Extension [ f CaMeL Extensions . size ( ) ] ) ; }	return f CaMeL Extensions . to CaMeL Array ( new Extension [ f CaMeL Extensions . size ( ) ] ) ;
context . pop CaMeL Class ( ) ;  <CTX>  public I CaMeL Ruby CaMeL Object call ( Ruby runtime , I CaMeL Ruby CaMeL Object receiver , String name , I CaMeL Ruby CaMeL Object [ ] args , boolean no CaMeL Super ) { Thread CaMeL Context context = runtime . get CaMeL Current CaMeL Context ( ) ; Ruby CaMeL Proc optional CaMeL Block CaMeL Arg = null ; if ( args CaMeL Node . get CaMeL Block CaMeL Arg CaMeL Node ( ) != null && context . is CaMeL Block CaMeL Given ( ) ) { optional CaMeL Block CaMeL Arg = Ruby CaMeL Proc . new CaMeL Proc ( runtime ) ; } context . get CaMeL Scope CaMeL Stack ( ) . push ( ) ; if ( body . get CaMeL Local CaMeL Names ( ) != null ) { context . get CaMeL Scope CaMeL Stack ( ) . reset CaMeL Local CaMeL Variables ( body . get CaMeL Local CaMeL Names ( ) ) ; } context . push CaMeL Dynamic CaMeL Vars ( ) ; context . push CaMeL Class ( module ) ; try { if ( args CaMeL Node != null ) { prepare CaMeL Arguments ( runtime , receiver , args ) ; } if ( optional CaMeL Block CaMeL Arg != null ) { context . get CaMeL Scope CaMeL Stack ( ) . set CaMeL Value ( args CaMeL Node . get CaMeL Block CaMeL Arg CaMeL Node ( ) . get CaMeL Count ( ) , optional CaMeL Block CaMeL Arg ) ; } trace CaMeL Call ( runtime , receiver , name ) ; return receiver . eval ( body . get CaMeL Body CaMeL Node ( ) ) ; } catch ( Return CaMeL Jump rj ) { if ( rj . get CaMeL Target ( ) == this ) { return rj . get CaMeL Return CaMeL Value ( ) ; } throw rj ; } finally { context . pop CaMeL Class ( ) ; context . pop CaMeL Dynamic CaMeL Vars ( ) ; context . get CaMeL Scope CaMeL Stack ( ) . pop ( ) ; trace CaMeL Return ( runtime , receiver , name ) ; } }	context . set CaMeL Class CaMeL Stack ( old CaMeL Stack ) ;
return ( new Templates CaMeL Handler CaMeL Impl ( ) ) ;  <CTX>  public Templates CaMeL Handler new CaMeL Templates CaMeL Handler ( ) throws Transformer CaMeL Configuration CaMeL Exception { return ( new Templates CaMeL Handler CaMeL Impl ( ) ) ; }	final Templates CaMeL Handler CaMeL Impl handler = new Templates CaMeL Handler CaMeL Impl ( ) ; handler . init ( ) ; return handler ;
get CaMeL Servlet CaMeL Context ( ) . set CaMeL Attribute ( Grails CaMeL Request CaMeL Attributes . APPLICATION _ CONTEXT , web CaMeL Context ) ;  <CTX>  protected Web CaMeL Application CaMeL Context create CaMeL Web CaMeL Application CaMeL Context ( Web CaMeL Application CaMeL Context parent ) throws Beans CaMeL Exception { / / use config file locations if available Application CaMeL Context grails CaMeL Context = ( Application CaMeL Context ) get CaMeL Servlet CaMeL Context ( ) . get CaMeL Attribute ( Grails CaMeL Request CaMeL Attributes . APPLICATION _ CONTEXT ) ; Grails CaMeL Application application ; Web CaMeL Application CaMeL Context web CaMeL Context ; if ( grails CaMeL Context != null ) { Xml CaMeL Web CaMeL Application CaMeL Context xml CaMeL Context = new Xml CaMeL Web CaMeL Application CaMeL Context ( ) ; xml CaMeL Context . set CaMeL Parent ( grails CaMeL Context ) ; web CaMeL Context = xml CaMeL Context ; application = ( Grails CaMeL Application ) web CaMeL Context . get CaMeL Bean ( Grails CaMeL Application . APPLICATION _ ID , Grails CaMeL Application . class ) ; } else { String [ ] locations = null ; if ( null != get CaMeL Context CaMeL Config CaMeL Location ( ) ) { locations = String CaMeL Utils . tokenize CaMeL To CaMeL String CaMeL Array ( get CaMeL Context CaMeL Config CaMeL Location ( ) , Configurable CaMeL Web CaMeL Application CaMeL Context . CONFIG _ LOCATION _ DELIMITERS ) ; } / / construct the Spring CaMeL Config for the container managed application application = ( Grails CaMeL Application ) parent . get CaMeL Bean ( Grails CaMeL Application . APPLICATION _ ID , Grails CaMeL Application . class ) ; Spring CaMeL Config spring CaMeL Config = new Spring CaMeL Config ( application ) ; / / return a context that ob@@ ey@@ s grails settings web CaMeL Context = new Xml CaMeL Web CaMeL Application CaMeL Context CaMeL Driver ( ) . get CaMeL Web CaMeL Application CaMeL Context ( spring CaMeL Config . get CaMeL Bean CaMeL References ( ) , parent , get CaMeL Servlet CaMeL Context ( ) , get CaMeL Namespace ( ) , locations ) ; get CaMeL Servlet CaMeL Context ( ) . set CaMeL Attribute ( Grails CaMeL Request CaMeL Attributes . APPLICATION _ CONTEXT , web CaMeL Context ) ; } / / init the Grails application Grails CaMeL Bootstrap CaMeL Class [ ] bootstr@@ aps = application . get CaMeL Grails CaMeL Bootstrap CaMeL Classes ( ) ; for ( int i = 0 ; i < bootstr@@ aps . length ; i ++ ) { bootstr@@ aps [ i ] . call CaMeL Init ( get CaMeL Servlet CaMeL Context ( ) ) ; } return web CaMeL Context ; }	get CaMeL Servlet CaMeL Context ( ) . set CaMeL Attribute ( Grails CaMeL Application CaMeL Attributes . APPLICATION _ CONTEXT , web CaMeL Context ) ;
this . path = path ;  <CTX>  public Scheduler CaMeL Event CaMeL Generator ( java . io . File path , String user CaMeL Name , String scheduler CaMeL Name , Job CaMeL State CaMeL Monitor monitor ) { this . path = path ; this . user CaMeL Name = user CaMeL Name ; this . scheduler CaMeL Name = scheduler CaMeL Name ; this . proc = null ; this . shutdown CaMeL Called = false ; this . time CaMeL Stamp = null ; this . monitor = monitor ; last CaMeL Restart = 0 ; }	this . globus CaMeL Location = globus CaMeL Location ;
Hashtable t = null ; return ( Object ) t ;  <CTX>  public Object get CaMeL Datatype CaMeL Object ( ) { Hashtable t = null ; return ( Object ) t ; }	return ( Object ) null ;
Locale _ lcl )  <CTX>  Swing CaMeL Event CaMeL Handler ( Linked CaMeL Hash CaMeL Map _ lhm CaMeL All CaMeL Triggers , I CaMeL Update CaMeL Notifier _ jc , Locale _ lcl ) { lhm CaMeL All CaMeL Triggers = _ lhm CaMeL All CaMeL Triggers ; i@@ un = _ jc ; lcl = _ lcl ; }	U CaMeL Locale _ lcl )
super ( value CaMeL View ) ;  <CTX>  public My CaMeL Model CaMeL Event CaMeL Listener ( final I CaMeL Model CaMeL Element model , final Text value CaMeL View ) { super ( value CaMeL View ) ; f CaMeL Model = model ; this . value CaMeL View = value CaMeL View ; }	super ( model , value CaMeL View ) ;
Node CaMeL State parent = validator . get CaMeL Node CaMeL State ( operation . get CaMeL Parent CaMeL Id ( ) ) ;  <CTX>  public void visit ( Add CaMeL Node operation ) throws Lock CaMeL Exception , Constraint CaMeL Violation CaMeL Exception , Access CaMeL Denied CaMeL Exception , Item CaMeL Exists CaMeL Exception , No CaMeL Such CaMeL Node CaMeL Type CaMeL Exception , Unsupported CaMeL Repository CaMeL Operation CaMeL Exception , Version CaMeL Exception , Repository CaMeL Exception { int options = Item CaMeL State CaMeL Validator . CHECK _ LOCK | Item CaMeL State CaMeL Validator . CHECK _ COLLISION | Item CaMeL State CaMeL Validator . CHECK _ VERSION@@ ING | Item CaMeL State CaMeL Validator . CHECK _ CONSTRAINTS ; Node CaMeL State parent = validator . get CaMeL Node CaMeL State ( operation . get CaMeL Parent CaMeL Id ( ) ) ; Q CaMeL Node CaMeL Definition def = validator . get CaMeL Applicable CaMeL Node CaMeL Definition ( operation . get CaMeL Node CaMeL Name ( ) , operation . get CaMeL Node CaMeL Type CaMeL Name ( ) , parent ) ; add CaMeL Node CaMeL State ( parent , operation . get CaMeL Node CaMeL Name ( ) , operation . get CaMeL Node CaMeL Type CaMeL Name ( ) , operation . get CaMeL Uuid ( ) , def , options ) ; transient CaMeL State CaMeL Mgr . add CaMeL Operation ( operation ) ; }	Node CaMeL State parent = get CaMeL Node CaMeL State ( operation . get CaMeL Parent CaMeL Id ( ) ) ;
return new Delegating CaMeL Notation ( base CaMeL Node , this ) ;  <CTX>  protected Delegating CaMeL Notation create CaMeL Delegating CaMeL Notation ( Notation base CaMeL Node ) { return new Delegating CaMeL Notation ( base CaMeL Node , this ) ; }	return base CaMeL Node == null ? null : new Delegating CaMeL Notation ( base CaMeL Node , this ) ;
return respond _ to ( Ruby CaMeL Symbol . new CaMeL Symbol ( get CaMeL Ruby ( ) , method CaMeL Name ) ) . is CaMeL True ( ) ;  <CTX>  public boolean responds CaMeL To ( String method CaMeL Name ) { return respond _ to ( Ruby CaMeL Symbol . new CaMeL Symbol ( get CaMeL Ruby ( ) , method CaMeL Name ) ) . is CaMeL True ( ) ; }	return respond _ to ( new Ruby CaMeL Object [ ] { Ruby CaMeL Symbol . new CaMeL Symbol ( get CaMeL Ruby ( ) , method CaMeL Name ) } ) . is CaMeL True ( ) ;
Delegating CaMeL Meta CaMeL Class meta CaMeL Class = ( Delegating CaMeL Meta CaMeL Class ) Invoker CaMeL Helper . get CaMeL Instance ( ) . get CaMeL Meta CaMeL Registry ( ) . get CaMeL Meta CaMeL Class ( target . get CaMeL Class ( ) ) ;  <CTX>  protected Object handle CaMeL Validation CaMeL Error ( Object target , Errors errors ) { Hibernate CaMeL Template t = get CaMeL Hibernate CaMeL Template ( ) ; / / if the target is within the session evict it / / this is so that if validation fails hibernate do@@ e@@ sn t save / / the object automatically when the session is flushed if ( t . contains ( target ) ) { t . evict ( target ) ; } if ( target instanceof Groovy CaMeL Object ) { ( ( Groovy CaMeL Object ) target ) . set CaMeL Property ( Domain CaMeL Class CaMeL Methods . ERRORS _ PROPERTY , errors ) ; } else { Delegating CaMeL Meta CaMeL Class meta CaMeL Class = ( Delegating CaMeL Meta CaMeL Class ) Invoker CaMeL Helper . get CaMeL Instance ( ) . get CaMeL Meta CaMeL Registry ( ) . get CaMeL Meta CaMeL Class ( target . get CaMeL Class ( ) ) ; meta CaMeL Class . set CaMeL Property ( target , Domain CaMeL Class CaMeL Methods . ERRORS _ PROPERTY , errors ) ; } return null ; }	Dynamic CaMeL Methods CaMeL Meta CaMeL Class meta CaMeL Class = ( Dynamic CaMeL Methods CaMeL Meta CaMeL Class ) Invoker CaMeL Helper . get CaMeL Instance ( ) . get CaMeL Meta CaMeL Registry ( ) . get CaMeL Meta CaMeL Class ( target . get CaMeL Class ( ) ) ;
if ( menu instanceof Sub CaMeL Menu CaMeL Manager )  <CTX>  public I CaMeL Contribution CaMeL Item find ( String id ) { I CaMeL Contribution CaMeL Item item = get CaMeL Parent CaMeL Menu CaMeL Manager ( ) . find ( id ) ; if ( item instanceof Sub CaMeL Contribution CaMeL Item ) / / Return the item passed to us , not the wrapper . item = unwrap ( item ) ; if ( item instanceof I CaMeL Menu CaMeL Manager ) { / / if it is a menu manager wrap it before returning I CaMeL Menu CaMeL Manager menu = ( I CaMeL Menu CaMeL Manager ) item ; if ( menu instanceof Sub CaMeL Menu CaMeL Manager ) / / it it is already wrapped then remover the wrapper and / / re@@ wrap . We have a table of wrappers so we reuse wrappers / / we create . menu = ( I CaMeL Menu CaMeL Manager ) ( ( Sub CaMeL Menu CaMeL Manager ) menu ) . get CaMeL Parent ( ) ; item = get CaMeL Wrapper ( menu ) ; } return item ; }	if ( menu instanceof Sub CaMeL Menu CaMeL Manager ) {
throw new Jcr CaMeL Dav CaMeL Exception ( e ) ;  <CTX>  public void remove CaMeL Property ( Dav CaMeL Property CaMeL Name property CaMeL Name ) throws Dav CaMeL Exception { if ( is CaMeL Locked ( this ) ) { throw new Dav CaMeL Exception ( Dav CaMeL Servlet CaMeL Response . SC _ LOCKED ) ; } if ( ! exists ( ) ) { throw new Dav CaMeL Exception ( Dav CaMeL Servlet CaMeL Response . SC _ NOT _ FOUND ) ; } try { remove CaMeL Jcr CaMeL Property ( property CaMeL Name ) ; node . save ( ) ; } catch ( Repository CaMeL Exception e ) { throw new Jcr CaMeL Dav CaMeL Exception ( e ) ; } }	Jcr CaMeL Dav CaMeL Exception je = new Jcr CaMeL Dav CaMeL Exception ( e ) ; try { node . refresh ( false ) ; } catch ( Repository CaMeL Exception re ) { } throw je ;
} finally { if ( http CaMeL Method != null && close CaMeL Connection )  <CTX>  protected Http CaMeL Method execute ( U@@ MO CaMeL Event event , Http CaMeL Method http CaMeL Method , boolean close CaMeL Connection ) throws Exception { / / todo set connection timeout buffer etc try { URI uri = event . get CaMeL Endpoint ( ) . get CaMeL Endpoint CaMeL URI ( ) . get CaMeL Uri ( ) ; try { process CaMeL Cookies ( event ) ; client . execute CaMeL Method ( get CaMeL Host CaMeL Config ( uri ) , http CaMeL Method ) ; } catch ( Exception e ) { logger . error ( e , e ) ; } return http CaMeL Method ; } catch ( Exception e ) { throw new Dispatch CaMeL Exception ( event . get CaMeL Message ( ) , event . get CaMeL Endpoint ( ) , e ) ; } finally { if ( http CaMeL Method != null && close CaMeL Connection ) http CaMeL Method . release CaMeL Connection ( ) ; } }	} finally { if ( http CaMeL Method != null && close CaMeL Connection ) {
int size = _ type . size ( ) ; java . lang . String [ ] m CaMeL Array = new String [ size ] ; for ( int index = 0 ; index < size ; index ++ ) { m CaMeL Array [ index ] = ( String ) _ type . element CaMeL At ( index ) ;  <CTX>  public java . lang . String [ ] get CaMeL Type ( ) { int size = _ type . size ( ) ; java . lang . String [ ] m CaMeL Array = new String [ size ] ; for ( int index = 0 ; index < size ; index ++ ) { m CaMeL Array [ index ] = ( String ) _ type . element CaMeL At ( index ) ; } return m CaMeL Array ; } / / -- java . lang . String [ ] get CaMeL Type ( )	if ( ( index < 0 ) || ( index > _ type . size ( ) ) ) { throw new Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception ( ) ;
} else  <CTX>  protected I CaMeL Lightweight CaMeL Label CaMeL Decorator internal CaMeL Get CaMeL Decorator ( ) throws Core CaMeL Exception { if ( label CaMeL Provider CaMeL Creation CaMeL Failed ) return null ; final Core CaMeL Exception [ ] exceptions = new Core CaMeL Exception [ 1 ] ; if ( decorator == null ) { if ( is CaMeL Declarative ( ) ) decorator = new Declarative CaMeL Decorator ( defining CaMeL Element , get CaMeL Icon CaMeL Location ( ) ) ; else { Platform . run ( new I CaMeL Safe CaMeL Runnable ( ) { public void run ( ) { try { decorator = ( I CaMeL Lightweight CaMeL Label CaMeL Decorator ) Workbench CaMeL Plugin . create CaMeL Extension ( defining CaMeL Element , Decorator CaMeL Definition . ATT _ CLASS ) ; decorator . add CaMeL Listener ( Workbench CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Decorator CaMeL Manager ( ) ) ; } catch ( Core CaMeL Exception exception ) { exceptions [ 0 ] = exception ; } } / * * ( non - Javadoc ) Method declared on I CaMeL Safe CaMeL Runnable . * / public void handle CaMeL Exception ( Throwable e ) { / / Do nothing as Core will handle the logging } } ) ; } } else return decorator ; if ( decorator == null ) { this . label CaMeL Provider CaMeL Creation CaMeL Failed = true ; set CaMeL Enabled ( false ) ; } if ( exceptions [ 0 ] != null ) throw exceptions [ 0 ] ; return decorator ; }	} else {
value . create CaMeL Foreign CaMeL Key ( ) ;  <CTX>  private static Property create CaMeL Property ( Value value , Persistent CaMeL Class persistent CaMeL Class , Grails CaMeL Domain CaMeL Class CaMeL Property grails CaMeL Property , Mappings mappings ) { / / set type value . set CaMeL Type CaMeL Using CaMeL Reflection ( persistent CaMeL Class . get CaMeL Class CaMeL Name ( ) , grails CaMeL Property . get CaMeL Name ( ) ) ; / / if it is a Many CaMeL To CaMeL One or One CaMeL To CaMeL One relationship if ( value instanceof To CaMeL One ) { To CaMeL One to CaMeL One = ( To CaMeL One ) value ; String property CaMeL Ref = to CaMeL One . get CaMeL Referenced CaMeL Property CaMeL Name ( ) ; if ( property CaMeL Ref != null ) { / / TODO : H@@ mm this method has package visibility . Why ? / / mappings . add CaMeL Unique CaMeL Property CaMeL Reference ( to CaMeL One . get CaMeL Referenced CaMeL Entity CaMeL Name ( ) , property CaMeL Ref ) ; } } else if ( value instanceof Collection ) { / / Collection collection = ( Collection ) value ; / / String property CaMeL Ref = collection . get CaMeL Referenced CaMeL Property CaMeL Name ( ) ; } value . create CaMeL Foreign CaMeL Key ( ) ; Property prop = new Property ( ) ; prop . set CaMeL Value ( value ) ; bind CaMeL Property ( grails CaMeL Property , prop , mappings ) ; return prop ; }	if ( value . get CaMeL Table ( ) != null ) value . create CaMeL Foreign CaMeL Key ( ) ;
return T@@ as@@ klist CaMeL Images . get CaMeL Image ( T@@ as@@ klist CaMeL Images . CATEGORY _ ARCHIVE ) ;  <CTX>  public Image get CaMeL Icon ( ) { if ( is CaMeL Archive ( ) ) { return T@@ as@@ klist CaMeL Images . get CaMeL Image ( T@@ as@@ klist CaMeL Images . CATEGORY _ ARCHIVE ) ; } else { return T@@ as@@ klist CaMeL Images . get CaMeL Image ( T@@ as@@ klist CaMeL Images . CATEGORY ) ; } }	return Task CaMeL List CaMeL Images . get CaMeL Image ( Task CaMeL List CaMeL Images . CATEGORY _ ARCHIVE ) ;
Ruby CaMeL Numeric other = numeric CaMeL Value ( num ) ; if ( get CaMeL Ruby CaMeL Class ( ) == other . get CaMeL Ruby CaMeL Class ( ) ) { return Ruby CaMeL Array . new CaMeL Array ( get CaMeL Ruby ( ) , this , other ) ; } else { return Ruby CaMeL Array . new CaMeL Array ( get CaMeL Ruby ( ) , Arrays . as CaMeL List ( get CaMeL Coerce ( ( Ruby CaMeL Numeric ) num ) ) ) ; } }  <CTX>  public Ruby CaMeL Array coerce ( Ruby CaMeL Object num ) { Ruby CaMeL Numeric other = numeric CaMeL Value ( num ) ; if ( get CaMeL Ruby CaMeL Class ( ) == other . get CaMeL Ruby CaMeL Class ( ) ) { return Ruby CaMeL Array . new CaMeL Array ( get CaMeL Ruby ( ) , this , other ) ; } else { return Ruby CaMeL Array . new CaMeL Array ( get CaMeL Ruby ( ) , Arrays . as CaMeL List ( get CaMeL Coerce ( ( Ruby CaMeL Numeric ) num ) ) ) ; } }	Ruby CaMeL Numeric other = numeric CaMeL Value ( num ) ; if ( get CaMeL Ruby CaMeL Class ( ) == other . get CaMeL Ruby CaMeL Class ( ) ) { return Ruby CaMeL Array . new CaMeL Array ( get CaMeL Ruby ( ) , other , this ) ; } else { return Ruby CaMeL Array . new CaMeL Array ( get CaMeL Ruby ( ) , Ruby CaMeL Float . new CaMeL Float ( get CaMeL Ruby ( ) , other . get CaMeL Double CaMeL Value ( ) ) , Ruby CaMeL Float . new CaMeL Float ( get CaMeL Ruby ( ) , get CaMeL Double CaMeL Value ( ) ) ) ; } }
if ( param CaMeL Value CaMeL Obj != null )  <CTX>  protected Map get CaMeL Parsed CaMeL Parameters ( I CaMeL Viewer CaMeL Report CaMeL Design CaMeL Handle design , Collection parameter CaMeL List , Http CaMeL Servlet CaMeL Request request , Input CaMeL Options options ) throws Report CaMeL Service CaMeL Exception { Map params = new Hash CaMeL Map ( ) ; if ( parameter CaMeL List == null || this . parameters CaMeL As CaMeL String == null ) return params ; for ( Iterator iter = parameter CaMeL List . iterator ( ) ; iter . has CaMeL Next ( ) ; ) { Scalar CaMeL Parameter CaMeL Handle parameter = null ; Object parameter CaMeL Obj = iter . next ( ) ; if ( parameter CaMeL Obj instanceof Scalar CaMeL Parameter CaMeL Handle ) { parameter = ( Scalar CaMeL Parameter CaMeL Handle ) parameter CaMeL Obj ; } / / if current object is not Scalar parameter handle , then skip it if ( parameter == null ) continue ; String param CaMeL Name = parameter . get CaMeL Name ( ) ; Object param CaMeL Value CaMeL Obj = this . parameters CaMeL As CaMeL String . get ( param CaMeL Name ) ; if ( param CaMeL Value CaMeL Obj != null ) { / / if default value is Date object , put map directly if ( param CaMeL Value CaMeL Obj instanceof Date ) { params . put ( param CaMeL Name , param CaMeL Value CaMeL Obj ) ; continue ; } try { / / convert parameter to object String format = Parameter CaMeL Accessor . get CaMeL Format ( request , param CaMeL Name ) ; if ( format == null || format . length ( ) <= 0 ) { format = parameter . get CaMeL Pattern ( ) ; } param CaMeL Value CaMeL Obj = Data CaMeL Util . validate ( parameter . get CaMeL Data CaMeL Type ( ) , format , param CaMeL Value CaMeL Obj . to CaMeL String ( ) , locale ) ; params . put ( param CaMeL Name , param CaMeL Value CaMeL Obj ) ; } catch ( Validation CaMeL Value CaMeL Exception e ) { / / if in PREVIEW mode , then throw exception directly if ( Parameter CaMeL Accessor . SERVLET _ PATH _ PREVIEW . equals CaMeL Ignore CaMeL Case ( request . get CaMeL Servlet CaMeL Path ( ) ) ) { this . exception = e ; break ; } } } else { params . put ( param CaMeL Name , null ) ; } } return params ; }	if ( param CaMeL Value != null )
return stamp . get CaMeL Date ( ) ;  <CTX>  public Date get CaMeL Run CaMeL Date ( ) { String date = this . get CaMeL Meta CaMeL Data ( METADATA _ RUN _ DATE ) ; if ( date != null ) { IW CaMeL Timestamp stamp = new IW CaMeL Timestamp ( date ) ; return stamp . get CaMeL Date ( ) ; } return null ; }	return stamp . get CaMeL Timestamp ( ) ;
int c = count == null ? 0 : count . int CaMeL Value ( ) ;  <CTX>  public Active CaMeL List purge ( ) { int filler CaMeL Count = 0 ; Map count CaMeL Map = new Hash CaMeL Map ( ) ; Collections . sort ( token CaMeL List , Token . COMPARATOR ) ; / / remove word duplicates for ( List CaMeL Iterator i = token CaMeL List . list CaMeL Iterator ( ) ; i . has CaMeL Next ( ) ; ) { Token token = ( Token ) i . next ( ) ; Word CaMeL Search CaMeL State word CaMeL State = ( Word CaMeL Search CaMeL State ) token . get CaMeL Search CaMeL State ( ) ; Word word = word CaMeL State . get CaMeL Pronunciation ( ) . get CaMeL Word ( ) ; / / only allow max CaMeL Filler words if ( max CaMeL Filler > 0 ) { if ( word . is CaMeL Filler ( ) ) { if ( filler CaMeL Count < max CaMeL Filler ) { filler CaMeL Count ++ ; } else { i . remove ( ) ; continue ; } } } if ( max CaMeL Paths CaMeL Per CaMeL Word > 0 ) { Integer count = ( Integer ) count CaMeL Map . get ( word ) ; int c = count == null ? 0 : count . int CaMeL Value ( ) ; / / Since the tokens are sorted by score we only / / keep the n tokens for a parti@@ cular word if ( c < max CaMeL Paths CaMeL Per CaMeL Word - 1 ) { count CaMeL Map . put ( word , new Integer ( c + 1 ) ) ; } else { i . remove ( ) ; } } } if ( token CaMeL List . size ( ) > absolute CaMeL Beam CaMeL Width ) { token CaMeL List = token CaMeL List . sub CaMeL List ( 0 , absolute CaMeL Beam CaMeL Width ) ; } return this ; }	int c = count == null ? 0 : count ;
I CaMeL En@@ rol@@ ment enrollment = enrollment CaMeL DAO . read CaMeL By CaMeL Student CaMeL Cur@@ ri@@ cular CaMeL Plan CaMeL And CaMeL Cur@@ ri@@ cular CaMeL Course CaMeL And CaMeL Execution CaMeL Period (  <CTX>  private void search CaMeL For CaMeL Enrollment CaMeL In CaMeL Extra CaMeL Cur@@ ri@@ cular CaMeL Course CaMeL And CaMeL Delete CaMeL It ( I CaMeL En@@ rol@@ ment old CaMeL Enrollment , I CaMeL Student CaMeL Cur@@ ri@@ cular CaMeL Plan to CaMeL Student CaMeL Cur@@ ri@@ cular CaMeL Plan ) throws Excep@@ cao CaMeL Persiste@@ n@@ cia { I CaMeL Sup@@ or@@ te CaMeL Persiste@@ n@@ te persistence CaMeL DAO = Sup@@ or@@ te CaMeL Persiste@@ n@@ te CaMeL O@@ JB . get CaMeL Instance ( ) ; I CaMeL Persistent CaMeL En@@ rol@@ ment enrollment CaMeL DAO = persistence CaMeL DAO . get CaMeL I CaMeL Persistent CaMeL En@@ rol@@ ment ( ) ; I CaMeL En@@ rol@@ ment enrollment = enrollment CaMeL DAO . read CaMeL By CaMeL Student CaMeL Cur@@ ri@@ cular CaMeL Plan CaMeL And CaMeL Cur@@ ri@@ cular CaMeL Course CaMeL And CaMeL Execution CaMeL Period ( to CaMeL Student CaMeL Cur@@ ri@@ cular CaMeL Plan , old CaMeL Enrollment . get CaMeL Cur@@ ri@@ cular CaMeL Course ( ) , old CaMeL Enrollment . get CaMeL Execution CaMeL Period ( ) ) ; if ( ( enrollment != null ) && ( enrollment instanceof En@@ rol@@ ment CaMeL In CaMeL Extra CaMeL Cur@@ ri@@ cular CaMeL Course ) ) { enrollment CaMeL DAO . delete CaMeL By CaMeL OID ( En@@ rol@@ ment . class , enrollment . get CaMeL Id CaMeL Internal ( ) ) ; } }	I CaMeL Enrollment enrollment = enrollment CaMeL DAO . read CaMeL By CaMeL Student CaMeL Cur@@ ri@@ cular CaMeL Plan CaMeL And CaMeL Cur@@ ri@@ cular CaMeL Course CaMeL And CaMeL Execution CaMeL Period (
sb . append ( arr [ i ] ) . append ( URL CaMeL Encoder . encode ( delimiter ) ) ;  <CTX>  public static String array CaMeL To CaMeL String ( String [ ] arr ) { if ( arr == null ) return null ; String CaMeL Buffer sb = new String CaMeL Buffer ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) sb . append ( arr [ i ] ) . append ( URL CaMeL Encoder . encode ( delimiter ) ) ; return sb . to CaMeL String ( ) ; }	sb . append ( URL CaMeL Encoder . encode ( arr [ i ] ) ) . append ( delimiter ) ;
return runtime . new CaMeL Fixnum ( 0 ) ;  <CTX>  public static Ruby CaMeL Fixnum zero ( I CaMeL Ruby runtime ) { return runtime . new CaMeL Fixnum ( 0 ) ; }	return new CaMeL Fixnum ( runtime , 0 ) ;
return real CaMeL This ( this CaMeL Obj , f ) . js CaMeL Function _ to CaMeL String ( ) ;  <CTX>  public Object exec CaMeL Method ( int method CaMeL Id , Id CaMeL Function f , Context cx , Scriptable scope , Scriptable this CaMeL Obj , Object [ ] args ) throws Java CaMeL Script CaMeL Exception { if ( prototype CaMeL Flag ) { if ( method CaMeL Id == Id _ constructor ) { return js CaMeL Constructor ( cx , args , f , this CaMeL Obj == null ) ; } else if ( method CaMeL Id == Id _ to CaMeL String ) { return real CaMeL This ( this CaMeL Obj , f ) . js CaMeL Function _ to CaMeL String ( ) ; } } return super . exec CaMeL Method ( method CaMeL Id , f , cx , scope , this CaMeL Obj , args ) ; }	return real CaMeL This ( this CaMeL Obj , f ) . to CaMeL String ( ) ;
if ( min CaMeL Size != null ) { Grid CaMeL Data gd = ( Grid CaMeL Data ) viewer . get CaMeL Control ( ) . get CaMeL Layout CaMeL Data ( ) ; gd . width CaMeL Hint = min CaMeL Size . x ; gd . height CaMeL Hint = min CaMeL Size . y ;  <CTX>  private void apply CaMeL Minimum CaMeL Size ( ) { if ( min CaMeL Size != null ) { Grid CaMeL Data gd = ( Grid CaMeL Data ) viewer . get CaMeL Control ( ) . get CaMeL Layout CaMeL Data ( ) ; gd . width CaMeL Hint = min CaMeL Size . x ; gd . height CaMeL Hint = min CaMeL Size . y ; } }	if ( f CaMeL Min CaMeL Size != null ) { Grid CaMeL Data gd = ( Grid CaMeL Data ) f CaMeL Viewer . get CaMeL Control ( ) . get CaMeL Layout CaMeL Data ( ) ; gd . width CaMeL Hint = f CaMeL Min CaMeL Size . x ; gd . height CaMeL Hint = f CaMeL Min CaMeL Size . y ;
if ( match ) {  <CTX>  private boolean need CaMeL To CaMeL Declare CaMeL Namespace ( Element parent , String prefix , String uri ) { boolean match = visi@@ bly CaMeL Utili@@ zed ( parent , prefix , uri ) ; if ( match ) { return no CaMeL Output CaMeL Ancestor CaMeL Uses CaMeL Prefix ( parent , prefix , uri ) ; } return false ; }	if ( match || inclusive CaMeL Namespace CaMeL Prefixes . contains ( prefix ) ) {
if ( kappa > max CaMeL Kappa ) {  <CTX>  private void sort CaMeL Lear@@ ners ( ) { Array CaMeL List unsorted CaMeL Lear@@ ners = new Array CaMeL List ( ) ; String [ ] class CaMeL Names = schema . valid CaMeL Class CaMeL Names ( ) ; Array CaMeL List unsorted CaMeL Class CaMeL Names = new Array CaMeL List ( ) ; sorted CaMeL Class CaMeL Names = new String [ schema . get CaMeL Number CaMeL Of CaMeL Classes ( ) ] ; for ( int i = 0 ; i < inner CaMeL Learner . size ( ) ; i ++ ) { unsorted CaMeL Lear@@ ners . add ( ( Batch CaMeL Classifier CaMeL Learner ) inner CaMeL Learner . get ( i ) ) ; unsorted CaMeL Class CaMeL Names . add ( class CaMeL Names [ i ] ) ; } / / clear list so that it can be reconstructed in sorted order inner CaMeL Learner . clear ( ) ; int position = 0 ; while ( ! unsorted CaMeL Lear@@ ners . is CaMeL Empty ( ) ) { double max CaMeL Kappa = 0 . 0 ; int learner CaMeL Index = - 1 ; / / find learner with max positive examples for ( int j = 0 ; j < unsorted CaMeL Lear@@ ners . size ( ) ; j ++ ) { try { Batch CaMeL Classifier CaMeL Learner learner = ( ( Batch CaMeL Classifier CaMeL Learner ) unsorted CaMeL Lear@@ ners . get ( j ) ) ; Evaluation evaluation = ( Evaluation ) eval . get ( j ) ; double kappa = evaluation . kappa ( ) ; if ( kappa > max CaMeL Kappa ) { max CaMeL Kappa = kappa ; learner CaMeL Index = j ; } } catch ( Exception e ) { e . print CaMeL Stack CaMeL Trace ( ) ; } } / / add learner to sorted CaMeL Lear@@ ners Classifier CaMeL Learner learner = ( Classifier CaMeL Learner ) unsorted CaMeL Lear@@ ners . remove ( learner CaMeL Index ) ; inner CaMeL Learner . add ( learner ) ; String class CaMeL Name = ( String ) unsorted CaMeL Class CaMeL Names . remove ( learner CaMeL Index ) ; sorted CaMeL Class CaMeL Names [ position ] = class CaMeL Name ; position ++ ; } }	if ( kappa >= max CaMeL Kappa ) {
Ruby CaMeL String str = string CaMeL Value ( other ) ; if ( this == other || get CaMeL Value ( ) . equals ( str . get CaMeL Value ( ) ) ) {  <CTX>  public Ruby CaMeL String replace ( I CaMeL Ruby CaMeL Object other ) { Ruby CaMeL String str = string CaMeL Value ( other ) ; if ( this == other || get CaMeL Value ( ) . equals ( str . get CaMeL Value ( ) ) ) { return this ; } set CaMeL Value ( str . get CaMeL Value ( ) ) ; return ( Ruby CaMeL String ) inf@@ ect CaMeL By ( str ) ; }	Ruby CaMeL String new CaMeL Value = string CaMeL Value ( other ) ; if ( this == other || same CaMeL As ( new CaMeL Value ) ) {
return get CaMeL Data CaMeL Directory ( ) + DEFAULT _ PATH _ SEPARATOR + DEFAULT _ BACKUP _ FOLDER _ NAME ;  <CTX>  public String get CaMeL Backup CaMeL Folder CaMeL Path ( ) { return get CaMeL Data CaMeL Directory ( ) + DEFAULT _ PATH _ SEPARATOR + DEFAULT _ BACKUP _ FOLDER _ NAME ; }	return get CaMeL Data CaMeL Directory ( ) + DEFAULT _ PATH _ SEPARATOR + I CaMeL Tasks CaMeL Ui CaMeL Constants . DEFAULT _ BACKUP _ FOLDER _ NAME ;
return Ruby CaMeL Boolean . new CaMeL Boolean ( get CaMeL Runtime ( ) , java CaMeL Class . is CaMeL Primitive ( ) ) ;  <CTX>  public Ruby CaMeL Boolean primitive _ p ( ) { return Ruby CaMeL Boolean . new CaMeL Boolean ( get CaMeL Runtime ( ) , java CaMeL Class . is CaMeL Primitive ( ) ) ; }	return Ruby CaMeL Boolean . new CaMeL Boolean ( get CaMeL Runtime ( ) , is CaMeL Primitive ( ) ) ;
if ( editor CaMeL Work@@ books . size ( ) < 1 ) set CaMeL Active CaMeL Workbook ( create CaMeL Default CaMeL Workbook ( ) , false ) ; else set CaMeL Active CaMeL Workbook ( ( Editor CaMeL Stack ) editor CaMeL Work@@ books . get ( 0 ) , false ) ;  <CTX>  public Editor CaMeL Stack get CaMeL Active CaMeL Workbook ( ) { if ( active CaMeL Editor CaMeL Workbook == null ) { if ( editor CaMeL Work@@ books . size ( ) < 1 ) set CaMeL Active CaMeL Workbook ( create CaMeL Default CaMeL Workbook ( ) , false ) ; else set CaMeL Active CaMeL Workbook ( ( Editor CaMeL Stack ) editor CaMeL Work@@ books . get ( 0 ) , false ) ; } return active CaMeL Editor CaMeL Workbook ; }	if ( editor CaMeL Work@@ books . size ( ) < 1 ) { set CaMeL Active CaMeL Workbook ( create CaMeL Default CaMeL Workbook ( ) , false ) ; } else { set CaMeL Active CaMeL Workbook ( ( Editor CaMeL Stack ) editor CaMeL Work@@ books . get ( 0 ) , false ) ; }
I CaMeL Label CaMeL Event CaMeL Handler eh = ( I CaMeL Label CaMeL Event CaMeL Handler ) get CaMeL Instance ( ( Label CaMeL Handle ) label CaMeL Design . get CaMeL Handle ( ) ) ;  <CTX>  public static void handle CaMeL On CaMeL Render ( Label CaMeL Content content , Execution CaMeL Context context ) { try { Report CaMeL Item CaMeL Design label CaMeL Design = ( Report CaMeL Item CaMeL Design ) content . get CaMeL Generate CaMeL By ( ) ; I CaMeL Label CaMeL Instance label = new Label CaMeL Instance ( content , context ) ; if ( handle CaMeL JS ( label , label CaMeL Design . get CaMeL On CaMeL Render ( ) , context ) . did CaMeL Run ( ) ) return ; I CaMeL Label CaMeL Event CaMeL Handler eh = ( I CaMeL Label CaMeL Event CaMeL Handler ) get CaMeL Instance ( ( Label CaMeL Handle ) label CaMeL Design . get CaMeL Handle ( ) ) ; if ( eh != null ) eh . on CaMeL Render ( label , context . get CaMeL Report CaMeL Context ( ) ) ; } catch ( Exception e ) { log . log ( Level . WARNING , e . get CaMeL Message ( ) , e ) ; } }	I CaMeL Label CaMeL Event CaMeL Handler eh = get CaMeL Event CaMeL Handler ( label CaMeL Design , context ) ;
Body CaMeL Adapter r@@ body = ( Body CaMeL Adapter ) bodies . get ( id ) ;  <CTX>  public Body CaMeL Adapter get CaMeL Remote CaMeL Adapter ( Unique CaMeL ID id ) { Body CaMeL Adapter r@@ body = ( Body CaMeL Adapter ) bodies . get ( id ) ; Pro CaMeL Active CaMeL Runtime CaMeL Forwarder CaMeL Impl par@@ tf = ( Pro CaMeL Active CaMeL Runtime CaMeL Forwarder CaMeL Impl ) Pro CaMeL Active CaMeL Runtime CaMeL Impl . get CaMeL Pro CaMeL Active CaMeL Runtime ( ) ; return new Body CaMeL Adapter CaMeL Forwarder ( par@@ tf . get CaMeL Body CaMeL Adapter CaMeL Forwarder ( ) , r@@ body ) ; }	Body CaMeL Adapter r@@ body = bodies . get ( id ) ;
Bean CaMeL Wrapper super CaMeL Bean = new Bean CaMeL Wrapper CaMeL Impl ( super CaMeL Class ) ; if ( super CaMeL Bean . is CaMeL Readable CaMeL Property ( this . name ) ) {  <CTX>  public Default CaMeL Grails CaMeL Domain CaMeL Class CaMeL Property ( Default CaMeL Grails CaMeL Domain CaMeL Class domain CaMeL Class , Property CaMeL Descriptor descriptor ) { this . domain CaMeL Class = domain CaMeL Class ; / / required by default this . optional = false ; / / persi@@ stant by default this . persi@@ stant = true ; this . name = descriptor . get CaMeL Name ( ) ; this . natural CaMeL Name = Grails CaMeL Class CaMeL Utils . get CaMeL Natural CaMeL Name ( descriptor . get CaMeL Name ( ) ) ; this . type = descriptor . get CaMeL Property CaMeL Type ( ) ; this . identity = descriptor . get CaMeL Name ( ) . equals ( IDENTITY ) ; / / figure out if this property is inherited if ( ! domain CaMeL Class . is CaMeL Root ( ) ) { Class super CaMeL Class = domain CaMeL Class . get CaMeL Clazz ( ) . get CaMeL Superclass ( ) ; Bean CaMeL Wrapper super CaMeL Bean = new Bean CaMeL Wrapper CaMeL Impl ( super CaMeL Class ) ; if ( super CaMeL Bean . is CaMeL Readable CaMeL Property ( this . name ) ) { this . inherited = true ; } } / / get the not required descri@@ tor from the owner bean List optional CaMeL Props ; List transient CaMeL Props ; optional CaMeL Props = ( List ) domain CaMeL Class . get CaMeL Property CaMeL Value ( OPTIONAL , List . class ) ; transient CaMeL Props = ( List ) domain CaMeL Class . get CaMeL Property CaMeL Value ( TRANSIENT , List . class ) ; / / Undocumented feature alert ! Ste@@ ve in@@ si@@ sted on this : - ) List ev@@ ane@@ scent = ( List ) domain CaMeL Class . get CaMeL Property CaMeL Value ( EV@@ AN@@ ES@@ CENT , List . class ) ; if ( ev@@ ane@@ scent != null ) { if ( transient CaMeL Props == null ) transient CaMeL Props = new Array CaMeL List ( ) ; transient CaMeL Props . add CaMeL All ( ev@@ ane@@ scent ) ; } / / establish of property is required if ( optional CaMeL Props != null ) { for ( Iterator i = optional CaMeL Props . iterator ( ) ; i . has CaMeL Next ( ) ; ) { / / make sure its a string otherwise ignore . Note : Maybe put a warning here ? Object current CaMeL Obj = i . next ( ) ; if ( current CaMeL Obj instanceof String ) { String property CaMeL Name = ( String ) current CaMeL Obj ; / / if the property name in the not required list / / matches this property name set not required if ( property CaMeL Name . equals ( this . name ) ) { this . optional = true ; break ; } } } } / / establish if property is persi@@ stant if ( transient CaMeL Props != null ) { for ( Iterator i = transient CaMeL Props . iterator ( ) ; i . has CaMeL Next ( ) ; ) { / / make sure its a string otherwise ignore . Note : Again maybe a warning ? Object current CaMeL Obj = i . next ( ) ; if ( current CaMeL Obj instanceof String ) { String property CaMeL Name = ( String ) current CaMeL Obj ; / / if the property name is on the not persi@@ stant list / / then set persi@@ stant to false if ( property CaMeL Name . equals ( this . name ) ) { this . persi@@ stant = false ; break ; } } } } }	Property CaMeL Descriptor pd = Bean CaMeL Utils . get CaMeL Property CaMeL Descriptor ( super CaMeL Class , this . name ) ; if ( pd != null && pd . get CaMeL Read CaMeL Method ( ) != null ) {
int width = table . get CaMeL Column CaMeL Model ( ) . get CaMeL Total CaMeL Column CaMeL Width ( ) ; int height = table . get CaMeL Row CaMeL Count ( ) * ( table . get CaMeL Row CaMeL Height ( ) + table . get CaMeL Row CaMeL Margin ( ) ) ; return new Dimension ( width , height ) ;  <CTX>  public Dimension get CaMeL Preferred CaMeL Size ( J CaMeL Component comp ) { int width = table . get CaMeL Column CaMeL Model ( ) . get CaMeL Total CaMeL Column CaMeL Width ( ) ; int height = table . get CaMeL Row CaMeL Count ( ) * ( table . get CaMeL Row CaMeL Height ( ) + table . get CaMeL Row CaMeL Margin ( ) ) ; return new Dimension ( width , height ) ; }	int pref CaMeL Total CaMeL Column CaMeL Width = 0 ; for ( int i = 0 ; i < table . get CaMeL Column CaMeL Count ( ) ; i ++ ) { Table CaMeL Column col = table . get CaMeL Column CaMeL Model ( ) . get CaMeL Column ( i ) ; pref CaMeL Total CaMeL Column CaMeL Width += col . get CaMeL Preferred CaMeL Width ( ) ; } return new Dimension ( pref CaMeL Total CaMeL Column CaMeL Width , get CaMeL Height ( ) ) ;
validate CaMeL Login CaMeL Statement = connection . prepare CaMeL Statement ( System CaMeL Globals . get CaMeL Value ( CONF _ QUERY _ VALIDATE _ LOGIN ) ) ; select CaMeL Name CaMeL Statement = connection . prepare CaMeL Statement ( System CaMeL Globals . get CaMeL Value ( CONF _ QUERY _ SELECT _ NAME ) ) ; select CaMeL Groups CaMeL Statement = connection . prepare CaMeL Statement ( System CaMeL Globals . get CaMeL Value ( CONF _ QUERY _ SELECT _ GROUPS ) ) ;  <CTX>  public Jdbc CaMeL Login CaMeL Server ( ) throws SQL CaMeL Exception { connection = Driver CaMeL Manager . get CaMeL Connection ( System CaMeL Globals . get CaMeL Value ( CONF _ CONNECTION ) ) ; validate CaMeL Login CaMeL Statement = connection . prepare CaMeL Statement ( System CaMeL Globals . get CaMeL Value ( CONF _ QUERY _ VALIDATE _ LOGIN ) ) ; select CaMeL Name CaMeL Statement = connection . prepare CaMeL Statement ( System CaMeL Globals . get CaMeL Value ( CONF _ QUERY _ SELECT _ NAME ) ) ; select CaMeL Groups CaMeL Statement = connection . prepare CaMeL Statement ( System CaMeL Globals . get CaMeL Value ( CONF _ QUERY _ SELECT _ GROUPS ) ) ; }	validate CaMeL Login CaMeL Statement = connection . prepare CaMeL Statement ( System CaMeL Globals . get CaMeL Value ( Config CaMeL Keys . EXTERNAL _ QUERY _ VALIDATE _ LOGIN ) ) ; select CaMeL Name CaMeL Statement = connection . prepare CaMeL Statement ( System CaMeL Globals . get CaMeL Value ( Config CaMeL Keys . EXTERNAL _ QUERY _ SELECT _ NAME ) ) ; select CaMeL Groups CaMeL Statement = connection . prepare CaMeL Statement ( System CaMeL Globals . get CaMeL Value ( Config CaMeL Keys . EXTERNAL _ QUERY _ SELECT _ GROUPS ) ) ;
I CaMeL Module CaMeL Name CaMeL Space name@@ scope = module  <CTX>  public List get CaMeL Visible CaMeL Data CaMeL Sources ( ) { I CaMeL Module CaMeL Name CaMeL Space name@@ scope = module . get CaMeL Module CaMeL Name CaMeL Space ( Module . DATA _ SOURCE _ NAME _ SPACE ) ; List element CaMeL List = name@@ scope . get CaMeL Elements ( I CaMeL Module CaMeL Name CaMeL Space . NATIVE _ LEVEL ) ; return generate CaMeL Handle CaMeL List ( element CaMeL List ) ; }	I CaMeL Module CaMeL Name CaMeL Scope name@@ scope = module
tmp . add ( tq , false , false ) ;  <CTX>  public static Query form CaMeL Similar CaMeL Query ( String body , Analyzer a , String field , Set stop ) throws IO CaMeL Exception { Token CaMeL Stream ts = a . token CaMeL Stream ( field , new String CaMeL Reader ( body ) ) ; org . apache . lucene . analysis . Token t ; Boolean CaMeL Query tmp = new Boolean CaMeL Query ( ) ; Set already = new Hash CaMeL Set ( ) ; / / ignore dups while ( ( t = ts . next ( ) ) != null ) { String word = t . term CaMeL Text ( ) ; / / ignore opt stop words if ( stop != null && stop . contains ( word ) ) continue ; / / ignore dups if ( ! already . add ( word ) ) continue ; / / add to query Term CaMeL Query tq = new Term CaMeL Query ( new Term ( field , word ) ) ; try { tmp . add ( tq , false , false ) ; } catch ( Boolean CaMeL Query . Too CaMeL Many CaMeL Clauses too ) { / / fail - safe , just return what we have , not the end of the world break ; } } return tmp ; }	tmp . add ( tq , Boolean CaMeL Clause . Occur . SHOULD ) ;
enabled CaMeL Submissions . add ( new Enabled CaMeL Submission ( workbench CaMeL Site , null ,  <CTX>  public void set CaMeL Scopes ( String [ ] scopes ) { if ( disposed ) return ; / / Either deactivate myself , or remove the previous submissions myself . boolean active = false ; if ( ( parent != null ) && ( parent . active CaMeL Service == this ) ) { active = true ; parent . deactivate CaMeL Nested CaMeL Service ( ) ; } else { Workbench . get CaMeL Instance ( ) . get CaMeL Context CaMeL Support ( ) . remove CaMeL Enabled CaMeL Submissions ( enabled CaMeL Submissions ) ; } enabled CaMeL Submissions . clear ( ) ; / / Determine the new list of submissions . enabled CaMeL Context CaMeL Ids = new Hash CaMeL Set ( Arrays . as CaMeL List ( scopes ) ) ; for ( Iterator iterator = enabled CaMeL Context CaMeL Ids . iterator ( ) ; iterator . has CaMeL Next ( ) ; ) { String context CaMeL Id = ( String ) iterator . next ( ) ; enabled CaMeL Submissions . add ( new Enabled CaMeL Submission ( workbench CaMeL Site , null , context CaMeL Id ) ) ; } / / Submit the new contexts myself , or simp@@ ly re - active myself . if ( parent != null ) { if ( active ) { parent . activate CaMeL Nested CaMeL Service ( this ) ; } } else { Workbench . get CaMeL Instance ( ) . get CaMeL Context CaMeL Support ( ) . add CaMeL Enabled CaMeL Submissions ( enabled CaMeL Submissions ) ; } }	enabled CaMeL Submissions . add ( new Enabled CaMeL Submission ( null , workbench CaMeL Site ,
( Psi CaMeL Binary CaMeL Expression ) expression ;  <CTX>  private void check CaMeL Condition ( Psi CaMeL Expression expression , Psi CaMeL Statement context ) { if ( expression instanceof Psi CaMeL Instance CaMeL Of CaMeL Expression ) { final Psi CaMeL Instance CaMeL Of CaMeL Expression instance CaMeL Of CaMeL Expression = ( Psi CaMeL Instance CaMeL Of CaMeL Expression ) expression ; final Psi CaMeL Expression operand = instance CaMeL Of CaMeL Expression . get CaMeL Operand ( ) ; check CaMeL Condition ( operand , context ) ; } else if ( expression instanceof Psi CaMeL Binary CaMeL Expression ) { final Psi CaMeL Binary CaMeL Expression binary CaMeL Expression = ( Psi CaMeL Binary CaMeL Expression ) expression ; Psi CaMeL Expression lhs = binary CaMeL Expression . get CaMeL L CaMeL Operand ( ) ; Psi CaMeL Expression rhs = binary CaMeL Expression . get CaMeL R CaMeL Operand ( ) ; if ( rhs == null ) { return ; } lhs = Parentheses CaMeL Utils . strip CaMeL Parentheses ( lhs ) ; rhs = Parentheses CaMeL Utils . strip CaMeL Parentheses ( rhs ) ; if ( Comparison CaMeL Utils . is CaMeL Comparison ( binary CaMeL Expression ) ) { if ( lhs instanceof Psi CaMeL Literal CaMeL Expression ) { check CaMeL Condition ( rhs , context ) ; } else if ( rhs instanceof Psi CaMeL Literal CaMeL Expression ) { check CaMeL Condition ( lhs , context ) ; } } else { check CaMeL Condition ( rhs , context ) ; check CaMeL Condition ( lhs , context ) ; } } else if ( expression instanceof Psi CaMeL Reference CaMeL Expression ) { final Psi CaMeL Reference CaMeL Expression reference CaMeL Expression = ( Psi CaMeL Reference CaMeL Expression ) expression ; final Psi CaMeL Element element = reference CaMeL Expression . resolve ( ) ; if ( element instanceof Psi CaMeL Local CaMeL Variable ) { final Psi CaMeL Local CaMeL Variable variable = ( Psi CaMeL Local CaMeL Variable ) element ; if ( ! Variable CaMeL Access CaMeL Utils . variable CaMeL Is CaMeL Assigned ( variable , context ) ) { register CaMeL Error ( expression ) ; } } else if ( element instanceof Psi CaMeL Parameter ) { final Psi CaMeL Parameter parameter = ( Psi CaMeL Parameter ) element ; if ( ! Variable CaMeL Access CaMeL Utils . variable CaMeL Is CaMeL Assigned ( parameter , context ) ) { register CaMeL Error ( expression ) ; } } } else if ( expression instanceof Psi CaMeL Prefix CaMeL Expression ) { final Psi CaMeL Prefix CaMeL Expression prefix CaMeL Expression = ( Psi CaMeL Prefix CaMeL Expression ) expression ; final Psi CaMeL Java CaMeL Token sign = prefix CaMeL Expression . get CaMeL Operation CaMeL Sign ( ) ; final I CaMeL Element CaMeL Type token CaMeL Type = sign . get CaMeL Token CaMeL Type ( ) ; if ( Java CaMeL Token CaMeL Type . EXCL . equals ( token CaMeL Type ) ) { final Psi CaMeL Expression operand = prefix CaMeL Expression . get CaMeL Operand ( ) ; check CaMeL Condition ( operand , context ) ; } } }	( Psi CaMeL Binary CaMeL Expression ) condition ;
advice . append ( get CaMeL Factory ( ) . create CaMeL Dup ( temp CaMeL Var CaMeL Type . get CaMeL Size ( ) ) ) ;  <CTX>  public void weave CaMeL After CaMeL Returning ( Bcel CaMeL Advice munger ) { Instruction CaMeL Factory fact = get CaMeL Factory ( ) ; List returns = new Array CaMeL List ( ) ; Instruction ret = null ; for ( Instruction CaMeL Handle ih = range . get CaMeL Start ( ) ; ih != range . get CaMeL End ( ) ; ih = ih . get CaMeL Next ( ) ) { if ( ih . get CaMeL Instruction ( ) instanceof Return CaMeL Instruction ) { returns . add ( ih ) ; ret = Utility . copy CaMeL Instruction ( ih . get CaMeL Instruction ( ) ) ; } } Instruction CaMeL List ret CaMeL List ; Instruction CaMeL Handle after CaMeL Advice ; if ( ret != null ) { ret CaMeL List = new Instruction CaMeL List ( ret ) ; after CaMeL Advice = ret CaMeL List . get CaMeL Start ( ) ; } else / * if ( munger . has CaMeL Dynamic CaMeL Tests ( ) ) * / { ret CaMeL List = new Instruction CaMeL List ( fact . NOP ) ; after CaMeL Advice = ret CaMeL List . get CaMeL Start ( ) ; / / } else { / / ret CaMeL List = new Instruction CaMeL List ( ) ; / / after CaMeL Advice = null ; } Instruction CaMeL List advice = new Instruction CaMeL List ( ) ; Bcel CaMeL Var temp CaMeL Var = null ; if ( munger . has CaMeL Extra CaMeL Parameter ( ) ) { Type CaMeL X temp CaMeL Var CaMeL Type = get CaMeL Return CaMeL Type ( ) ; if ( temp CaMeL Var CaMeL Type . equals ( Resolved CaMeL Type CaMeL X . VOID ) ) { temp CaMeL Var = gen CaMeL Temp CaMeL Var ( Type CaMeL X . OBJECT ) ; advice . append ( get CaMeL Factory ( ) . ACONST _ NULL ) ; temp CaMeL Var . append CaMeL Store ( advice , get CaMeL Factory ( ) ) ; } else { temp CaMeL Var = gen CaMeL Temp CaMeL Var ( temp CaMeL Var CaMeL Type ) ; advice . append ( get CaMeL Factory ( ) . create CaMeL Dup ( temp CaMeL Var CaMeL Type . get CaMeL Size ( ) ) ) ; temp CaMeL Var . append CaMeL Store ( advice , get CaMeL Factory ( ) ) ; } } advice . append ( munger . get CaMeL Advice CaMeL Instructions ( this , temp CaMeL Var , after CaMeL Advice ) ) ; if ( ret != null ) { Instruction CaMeL Handle goto CaMeL Target = advice . get CaMeL Start ( ) ; for ( Iterator i = returns . iterator ( ) ; i . has CaMeL Next ( ) ; ) { Instruction CaMeL Handle ih = ( Instruction CaMeL Handle ) i . next ( ) ; Utility . replace CaMeL Instruction ( ih , fact . create CaMeL Branch CaMeL Instruction ( Constants . GOTO , goto CaMeL Target ) , enclosing CaMeL Method ) ; } range . append ( advice ) ; range . append ( ret CaMeL List ) ; } else { range . append ( advice ) ; range . append ( ret CaMeL List ) ; } }	advice . append ( Instruction CaMeL Factory . create CaMeL Dup ( temp CaMeL Var CaMeL Type . get CaMeL Size ( ) ) ) ;
hi@@ der . set CaMeL Enabled ( true ) ; fast CaMeL View CaMeL Sash . set CaMeL Visible ( false ) ;  <CTX>  public void set CaMeL State ( int new CaMeL State ) { super . set CaMeL State ( new CaMeL State ) ; View CaMeL Pane pane = current CaMeL Pane ; switch ( new CaMeL State ) { case I CaMeL Stack CaMeL Presentation CaMeL Site . STATE _ MINI@@ MIZED : current CaMeL Pane . get CaMeL Page ( ) . toggle CaMeL Fast CaMeL View ( current CaMeL Pane . get CaMeL View CaMeL Reference ( ) ) ; break ; case I CaMeL Stack CaMeL Presentation CaMeL Site . STATE _ MAXIMIZED : hi@@ der . set CaMeL Enabled ( false ) ; fast CaMeL View CaMeL Sash . set CaMeL Visible ( false ) ; get CaMeL Presentation ( ) . set CaMeL Bounds ( get CaMeL Bounds ( ) ) ; break ; case I CaMeL Stack CaMeL Presentation CaMeL Site . STATE _ RE@@ STORED : hi@@ der . set CaMeL Enabled ( true ) ; fast CaMeL View CaMeL Sash . set CaMeL Visible ( false ) ; get CaMeL Presentation ( ) . set CaMeL Bounds ( get CaMeL Bounds ( ) ) ; break ; default : } }	sash . set CaMeL Visible ( true ) ;
init CaMeL Component ( ( Base CaMeL Component ) component CaMeL Instance , ( Class ) component CaMeL Key ) ;  <CTX>  public Object get CaMeL Component CaMeL Instance ( Pico CaMeL Container pico CaMeL Container ) throws Pico CaMeL Initialization CaMeL Exception , Pico CaMeL Introspection CaMeL Exception { Object component CaMeL Instance = super . get CaMeL Component CaMeL Instance ( pico CaMeL Container ) ; init CaMeL Component ( ( Base CaMeL Component ) component CaMeL Instance , ( Class ) component CaMeL Key ) ; return component CaMeL Instance ; }	if ( component CaMeL Instance instanceof Base CaMeL Component ) { init CaMeL Component ( ( Base CaMeL Component ) component CaMeL Instance , ( Class ) component CaMeL Key ) ; }
out . write CaMeL Object ( destination ) ; out . write CaMeL Object ( reply CaMeL To CaMeL Destination ) ;  <CTX>  public void write CaMeL External ( Object CaMeL Output out ) throws IO CaMeL Exception { super . write CaMeL External ( out ) ; out . write CaMeL Object ( destination ) ; out . write CaMeL Object ( reply CaMeL To CaMeL Destination ) ; write CaMeL String ( out , jms CaMeL Type ) ; write CaMeL Map ( out , properties ) ; if ( correlation CaMeL ID CaMeL Bytes == null ) { out . write CaMeL Int ( - 1 ) ; } else { out . write CaMeL Int ( correlation CaMeL ID CaMeL Bytes . length ) ; out . write ( correlation CaMeL ID CaMeL Bytes ) ; } write CaMeL String ( out , correlation CaMeL ID ) ; write CaMeL String ( out , connection CaMeL ID ) ; }	write CaMeL Destination ( out , reply CaMeL To CaMeL Destination ) ;
DATASOURCE , PUBLICATION , HER@@ BAR@@ I@@ UM , / * CRE@@ ATED@@ WHEN , * / / * UPDAT@@ ED@@ WHEN , * / METADATA , NOTE ) ;  <CTX>  public List < String > get CaMeL Columns ( ) { return as CaMeL List ( UNI@@ TI@@ D@@ DB , UNIT@@ VALUE , H@@ AB@@ IT@@ AT , PLAN@@ T , YEAR@@ COLLEC@@ TED , MONTH@@ COLLEC@@ TED , DAY@@ COLLEC@@ TED , TIME@@ COLLEC@@ TED , I@@ SO@@ DATE@@ TIME@@ BEGIN , DATASOURCE , PUBLICATION , HER@@ BAR@@ I@@ UM , / * CRE@@ ATED@@ WHEN , * / / * UPDAT@@ ED@@ WHEN , * / METADATA , NOTE ) ; }	DATASOURCE , PUBLICATION , HER@@ BAR@@ I@@ UM , METADATA , NOTE , DELETED ) ;
synchronized ( local CaMeL Names ) { if ( ! ( local CaMeL Names . contains ( name ) ) ) { return false ; }  <CTX>  public boolean unregister ( String name ) { boolean ret = true ; / / quick - check locally synchronized ( local CaMeL Names ) { if ( ! ( local CaMeL Names . contains ( name ) ) ) { return false ; } } / / unregister glob@@ ally try { glob CaMeL Reg . unbind ( name ) ; } catch ( Exception e ) { / / ignore ret = false ; } / / unregister locally try { local CaMeL Reg . unregister ( name ) ; } catch ( Runtime CaMeL Exception re ) { / / ignore ret = false ; } / / release local name synchronized ( local CaMeL Names ) { local CaMeL Names . remove ( name ) ; } return ret ; }	if ( get ( name ) == null ) { return false ;
boolean is CaMeL Derived = ( ( Boolean ) value ) . boolean CaMeL Value ( ) ; show CaMeL Derived = is CaMeL Derived ; if ( is CaMeL Derived ) last CaMeL Compli@@ ted CaMeL M@@ acher = null ; set CaMeL Search CaMeL Pattern ( pattern CaMeL String ) ;  <CTX>  public void set CaMeL Filter CaMeL Param ( int param , Object value ) { if ( param == PATTERN ) { set CaMeL Search CaMeL Pattern ( ( String ) value ) ; } if ( param == DERIVED ) { boolean is CaMeL Derived = ( ( Boolean ) value ) . boolean CaMeL Value ( ) ; show CaMeL Derived = is CaMeL Derived ; if ( is CaMeL Derived ) last CaMeL Compli@@ ted CaMeL M@@ acher = null ; set CaMeL Search CaMeL Pattern ( pattern CaMeL String ) ; } }	set CaMeL Search CaMeL Derived ( ( ( Boolean ) value ) . boolean CaMeL Value ( ) ) ;
Runtime get CaMeL Run CaMeL Time CaMeL Code CaMeL Base ( ) ;  <CTX>  Runtime get CaMeL Run CaMeL Time CaMeL Code CaMeL Base ( ) ;	Run CaMeL Time get CaMeL Run CaMeL Time CaMeL Code CaMeL Base ( ) ;
set CaMeL Message ( message ) ;  <CTX>  public void handle CaMeL Event ( Event event ) { set CaMeL Message ( message ) ; }	shell . get CaMeL Display ( ) . async CaMeL Exec ( new Runnable ( ) { public void run ( ) { set CaMeL Message ( message ) ; } } ) ;
} else { client . finished CaMeL Client CaMeL Request ( this ) ; }  <CTX>  private void finish ( ) { if ( persistence CaMeL Type == Client CaMeL Request . PERSIST _ CONNECTION ) { orig CaMeL Handler . finished CaMeL Client CaMeL Request ( this ) ; } else { client . finished CaMeL Client CaMeL Request ( this ) ; } }	client . finished CaMeL Client CaMeL Request ( this ) ;
info CaMeL Messages . add ( message ) ;  <CTX>  public void add CaMeL Info CaMeL Message ( String message ) { info CaMeL Messages . add ( message ) ; }	this . info CaMeL Messages . add ( message ) ;
gap CaMeL Width -= length ;  <CTX>  public synchronized void content CaMeL Removed ( int offset , int length ) { if ( root == null ) { gap CaMeL Width = 0 ; return ; } if ( gap CaMeL Width != 0 && gap CaMeL Offset < offset ) { root . content CaMeL Removed ( gap CaMeL Offset , offset , offset + length , gap CaMeL Width , true ) ; } else if ( gap CaMeL Width != 0 && gap CaMeL Offset > offset + length ) { root . content CaMeL Removed ( offset , offset + length , gap CaMeL Offset , gap CaMeL Width , false ) ; } else { root . content CaMeL Removed ( offset , offset + length , offset + length , gap CaMeL Width , false ) ; } gap CaMeL Offset = offset ; gap CaMeL Width -= length ; } / / } } }	gap CaMeL Width -= length ; * /
return get CaMeL Index ( ) ;  <CTX>  public int get CaMeL Block CaMeL Start CaMeL Index ( ) { return get CaMeL Index ( ) ; }	if ( linear CaMeL Iterator != null ) return linear CaMeL Iterator . get CaMeL Block CaMeL Start ( ) ; else return deltas CaMeL Iterator . get CaMeL Index ( ) ;
M CaMeL Editing CaMeL Domain CaMeL Getter . get CaMeL M CaMeL Editing CaMeL Domain ( ( View ) get CaMeL Model ( ) ) . run CaMeL As CaMeL Read ( new M CaMeL Runnable ( ) {  <CTX>  public String is CaMeL Valid ( final Object value ) { if ( value instanceof String ) { / / final I CaMeL Element element = resolve CaMeL Model CaMeL Reference ( ) ; final I CaMeL Parser CaMeL Edit CaMeL Status is CaMeL Valid [ ] = { null } ; final I CaMeL Parser desc CaMeL Parser = get CaMeL Parser ( ) ; try { M CaMeL Editing CaMeL Domain CaMeL Getter . get CaMeL M CaMeL Editing CaMeL Domain ( ( View ) get CaMeL Model ( ) ) . run CaMeL As CaMeL Read ( new M CaMeL Runnable ( ) { public Object run ( ) { is CaMeL Valid [ 0 ] = desc CaMeL Parser . is CaMeL Valid CaMeL Edit CaMeL String ( null , ( String ) value ) ; return null ; } } ) ; } catch ( Exception e ) { Log . error ( Diagram CaMeL UI CaMeL Plugin . get CaMeL Instance ( ) , I CaMeL Status . ERROR , e . get CaMeL Message ( ) , e ) ; } return is CaMeL Valid [ 0 ] . get CaMeL Code ( ) == Parser CaMeL Edit CaMeL Status . EDITABLE ? null : is CaMeL Valid [ 0 ] . get CaMeL Message ( ) ; } return null ; }	I CaMeL Parser CaMeL Edit CaMeL Status is CaMeL Valid = ( I CaMeL Parser CaMeL Edit CaMeL Status ) get CaMeL Editing CaMeL Domain ( ) . run CaMeL Exclusive ( new Runnable CaMeL With CaMeL Result . Impl ( ) {
return get CaMeL Boolean CaMeL Property ( Style . CAN _ SHRINK _ PROP ) ;  <CTX>  public boolean can CaMeL Shrink ( ) { return get CaMeL Boolean CaMeL Property ( Style . CAN _ SHRINK _ PROP ) ; }	return get CaMeL Boolean CaMeL Property ( I CaMeL Style CaMeL Model . CAN _ SHRINK _ PROP ) ;
Compiler batch CaMeL Compiler =  <CTX>  private void compile ( ) throws Invalid CaMeL Input CaMeL Exception , Interrupted CaMeL Exception { final I CaMeL Name CaMeL Environment environment = get CaMeL Environment ( ) ; Compiler batch CaMeL Compiler = new Compiler ( environment , get CaMeL Handling CaMeL Policy ( ) , get CaMeL Compiler CaMeL Options ( ) , get CaMeL Batch CaMeL Requestor ( ) , get CaMeL Problem CaMeL Factory ( ) ) ; batch CaMeL Compiler . compile ( get CaMeL Compilation CaMeL Units ( ) ) ; my CaMeL Compilation CaMeL Results . offer ( END _ OF _ STREAM ) ; environment . cleanup ( ) ; }	Compiler compiler =
if ( object == null ) return ; object . set CaMeL Waiting CaMeL For CaMeL Request ( false ) ;  <CTX>  public void object CaMeL Waiting CaMeL By CaMeL Ne@@ ce@@ ssi@@ ty ( Unique CaMeL ID id , Spy CaMeL Event spy CaMeL Event ) { if ( ! controller . is CaMeL Monitoring ( ) ) return ; Active CaMeL Object object = find CaMeL Active CaMeL Object ( id ) ; if ( object == null ) return ; object . set CaMeL Waiting CaMeL For CaMeL Request ( false ) ; communication CaMeL Event CaMeL Listener . object CaMeL Waiting CaMeL By CaMeL Ne@@ ce@@ ssi@@ ty ( object , spy CaMeL Event ) ; }	if ( object == null ) { return ; } object . set CaMeL Serving CaMeL Status ( object . get CaMeL Serving CaMeL Status ( ) == Active CaMeL Object . STATUS _ SERV@@ ING _ REQUEST ? Active CaMeL Object . STATUS _ WAITING _ BY _ N@@ EC@@ ES@@ SITY _ WHILE _ SERV@@ ING : Active CaMeL Object . STATUS _ WAITING _ BY _ N@@ EC@@ ES@@ SITY _ WHILE _ ACTIVE ) ;
} else { I CaMeL Status location CaMeL Status = existing CaMeL Project . get CaMeL Workspace ( ) . validate CaMeL Project CaMeL Location CaMeL URI ( existing CaMeL Project , new CaMeL Path ) ; if ( ! location CaMeL Status . is CaMeL OK ( ) ) { return location CaMeL Status . get CaMeL Message ( ) ; }  <CTX>  public String check CaMeL Valid CaMeL Location ( ) { if ( is CaMeL Default ( ) ) { return null ; } String location CaMeL Field CaMeL Contents = location CaMeL Path CaMeL Field . get CaMeL Text ( ) ; if ( location CaMeL Field CaMeL Contents . length ( ) == 0 ) { return ( IDE CaMeL Workbench CaMeL Messages . Wizard CaMeL New CaMeL Project CaMeL Creation CaMeL Page _ project CaMeL Location CaMeL Empty ) ; } URI new CaMeL Path = get CaMeL Project CaMeL Location CaMeL URI ( ) ; if ( new CaMeL Path == null ) { return IDE CaMeL Workbench CaMeL Messages . Project CaMeL Location CaMeL Selection CaMeL Dialog _ location CaMeL Error ; } if ( existing CaMeL Project == null ) { I CaMeL Path project CaMeL Path = new Path ( location CaMeL Field CaMeL Contents ) ; if ( Platform . get CaMeL Location ( ) . is CaMeL Prefix CaMeL Of ( project CaMeL Path ) ) { return IDE CaMeL Workbench CaMeL Messages . Wizard CaMeL New CaMeL Project CaMeL Creation CaMeL Page _ default CaMeL Location CaMeL Error ; } } else { I CaMeL Status location CaMeL Status = existing CaMeL Project . get CaMeL Workspace ( ) . validate CaMeL Project CaMeL Location CaMeL URI ( existing CaMeL Project , new CaMeL Path ) ; if ( ! location CaMeL Status . is CaMeL OK ( ) ) { return location CaMeL Status . get CaMeL Message ( ) ; } URI project CaMeL Path = existing CaMeL Project . get CaMeL Location CaMeL URI ( ) ; if ( project CaMeL Path != null && URI CaMeL Util . equals ( project CaMeL Path , new CaMeL Path ) ) { return IDE CaMeL Workbench CaMeL Messages . Project CaMeL Location CaMeL Selection CaMeL Dialog _ location CaMeL Error ; } } return null ; }	if ( ! location CaMeL Status . is CaMeL OK ( ) ) { return location CaMeL Status . get CaMeL Message ( ) ; } if ( existing CaMeL Project != null ) {
static void init ( ) {  <CTX>  static void init ( ) { gc CaMeL Barrier = new VM _ GC CaMeL Synchronization CaMeL Barrier ( ) ; collector CaMeL Threads = new VM _ Collector CaMeL Thread [ 1 + VM _ Scheduler . MAX _ PROCESSORS ] ; }	static void init ( ) throws VM _ Pragma CaMeL Interruptible {
Variable var = mgr . create CaMeL Variable ( ( Stack CaMeL Frame ) context , get CaMeL Qualified CaMeL Name ( ) ) ;  <CTX>  public ICDI CaMeL Value get CaMeL Value ( ICDI CaMeL Stack CaMeL Frame context ) throws CDI CaMeL Exception { Session session = ( Session ) get CaMeL Target ( ) . get CaMeL Session ( ) ; Register CaMeL Manager mgr = session . get CaMeL Register CaMeL Manager ( ) ; Variable var = mgr . create CaMeL Variable ( ( Stack CaMeL Frame ) context , get CaMeL Qualified CaMeL Name ( ) ) ; return var . get CaMeL Value ( ) ; }	Variable var = mgr . create CaMeL Shadow CaMeL Register ( this , ( Stack CaMeL Frame ) context , get CaMeL Qualified CaMeL Name ( ) ) ;
Offset method CaMeL Offset = Offset . from CaMeL Int CaMeL Sign CaMeL Extend ( cm . get CaMeL Osr CaMeL JTO CaMeL Co@@ ffset ( ) ) ;  <CTX>  protected final void emit _ invoke _ comp@@ i@@ led@@ method ( VM _ Compiled CaMeL Method cm ) { Offset method CaMeL Offset = Offset . from CaMeL Int CaMeL Sign CaMeL Extend ( cm . get CaMeL Osr CaMeL JTO CaMeL Co@@ ffset ( ) ) ; boolean take CaMeL This = ! cm . method . is CaMeL Static ( ) ; VM _ Method CaMeL Reference ref = cm . method . get CaMeL Member CaMeL Ref ( ) . as CaMeL Method CaMeL Reference ( ) ; gen CaMeL Parameter CaMeL Register CaMeL Load ( ref , take CaMeL This ) ; asm . emit CaMeL CALL _ Reg CaMeL Disp ( JTOC , method CaMeL Offset ) ; gen CaMeL Result CaMeL Register CaMeL Unload ( ref ) ; }	Offset method CaMeL Offset = cm . get CaMeL Osr CaMeL JTO CaMeL Co@@ ffset ( ) ;
else if ( Grails CaMeL Class CaMeL Utils . is CaMeL Domain CaMeL Class ( related CaMeL Class CaMeL Type ) ) {  <CTX>  private void establish CaMeL Relationship CaMeL For CaMeL Set ( Default CaMeL Grails CaMeL Domain CaMeL Class CaMeL Property property ) { / / is it a relationship Class related CaMeL Class CaMeL Type = get CaMeL Related CaMeL Class CaMeL Type ( property . get CaMeL Name ( ) ) ; if ( related CaMeL Class CaMeL Type != null ) { / / set the referenced type in the property property . set CaMeL Referenced CaMeL Property CaMeL Type ( related CaMeL Class CaMeL Type ) ; / / if the related class is the same as this class / / its a circular one - to - many if ( related CaMeL Class CaMeL Type . get CaMeL Name ( ) . equals ( get CaMeL Full CaMeL Name ( ) ) ) { property . set CaMeL One CaMeL To CaMeL Many ( true ) ; property . set CaMeL Bidirectional ( true ) ; } / / if the related type is a domain class / / then figure out what kind of relationship it is else if ( Grails CaMeL Class CaMeL Utils . is CaMeL Domain CaMeL Class ( related CaMeL Class CaMeL Type ) ) { / / check the relationship defined in the referenced type / / if it is also a Set / domain class etc . Map related CaMeL Class CaMeL Relationships = Grails CaMeL Domain CaMeL Configuration CaMeL Util . get CaMeL Association CaMeL Map ( related CaMeL Class CaMeL Type ) ; Class related CaMeL Class CaMeL Property CaMeL Type = null ; / / if the related type has a relationships map it may be a many - to - many / / figure out if there is a many - to - many relationship defined if ( related CaMeL Class CaMeL Relationships != null && ! related CaMeL Class CaMeL Relationships . is CaMeL Empty ( ) ) { String related CaMeL Class CaMeL Property CaMeL Name = null ; / / retrieve the relationship property for ( Iterator i = related CaMeL Class CaMeL Relationships . key CaMeL Set ( ) . iterator ( ) ; i . has CaMeL Next ( ) ; ) { String current CaMeL Key = ( String ) i . next ( ) ; Class current CaMeL Class = ( Class ) related CaMeL Class CaMeL Relationships . get ( current CaMeL Key ) ; if ( current CaMeL Class . get CaMeL Name ( ) . equals ( get CaMeL Clazz ( ) . get CaMeL Name ( ) ) ) { related CaMeL Class CaMeL Property CaMeL Name = current CaMeL Key ; break ; } } / / if there is one defined get the type if ( related CaMeL Class CaMeL Property CaMeL Name != null ) { related CaMeL Class CaMeL Property CaMeL Type = Grails CaMeL Class CaMeL Utils . get CaMeL Proper@@ y CaMeL Type ( related CaMeL Class CaMeL Type , related CaMeL Class CaMeL Property CaMeL Name ) ; } } / / otherwise figure out if there is a one - to - many relationship by retri@@ ev@@ ing any properties that are of the related type / / if there is more than one property then ( for the moment ) ignore the relationship if ( related CaMeL Class CaMeL Property CaMeL Type == null ) { Property CaMeL Descriptor [ ] descriptors = Grails CaMeL Class CaMeL Utils . get CaMeL Properties CaMeL Of CaMeL Type ( related CaMeL Class CaMeL Type , get CaMeL Clazz ( ) ) ; if ( descriptors . length == 1 ) { related CaMeL Class CaMeL Property CaMeL Type = descriptors [ 0 ] . get CaMeL Property CaMeL Type ( ) ; } } establish CaMeL Relationship CaMeL For CaMeL Set CaMeL To CaMeL Type ( property , related CaMeL Class CaMeL Property CaMeL Type ) ; / / if its a many - to - many figure out the owning side of the relationship if ( property . is CaMeL Many CaMeL To CaMeL Many ( ) ) { establish CaMeL Owner CaMeL Of CaMeL Many CaMeL To CaMeL Many ( property , related CaMeL Class CaMeL Type ) ; } } / / otherwise set it to not persistent as you can t persist / / relationships to non - domain classes else { property . set CaMeL Persistant ( false ) ; } } else { / / no relationship defined for set . / / set not persistent property . set CaMeL Persistant ( false ) ; } }	if ( Grails CaMeL Class CaMeL Utils . is CaMeL Domain CaMeL Class ( related CaMeL Class CaMeL Type ) ) {
return new Point ( trim . width , trim . height ) ;  <CTX>  public Point compute CaMeL Size ( int w CaMeL Hint , int h CaMeL Hint , boolean changed ) { check CaMeL Widget ( ) ; int min CaMeL Width = 0 ; int min CaMeL Height = 0 ; / / preferred width of tab area to show all tabs GC gc = new GC ( this ) ; for ( int i = 0 ; i < items . length ; i ++ ) { min CaMeL Width += items [ i ] . preferred CaMeL Width ( gc ) ; } gc . dispose ( ) ; / / preferred size of controls in tab items for ( int i = 0 ; i < items . length ; i ++ ) { Control control = items [ i ] . get CaMeL Control ( ) ; if ( control != null && ! control . is CaMeL Disposed ( ) ) { Point size = control . compute CaMeL Size ( w CaMeL Hint , h CaMeL Hint ) ; min CaMeL Width = Math . max ( min CaMeL Width , size . x ) ; min CaMeL Height = Math . max ( min CaMeL Height , size . y ) ; } } if ( min CaMeL Width == 0 ) min CaMeL Width = DEFAULT _ WIDTH ; if ( min CaMeL Height == 0 ) min CaMeL Height = DEFAULT _ HEIGHT ; if ( w CaMeL Hint != SWT . DEFAULT ) min CaMeL Width = w CaMeL Hint ; if ( h CaMeL Hint != SWT . DEFAULT ) min CaMeL Height = h CaMeL Hint ; Rectangle trim = compute CaMeL Trim ( 0 , 0 , min CaMeL Width , min CaMeL Height ) ; return new Point ( trim . width , trim . height ) ; }	return new Point ( trim . width - trim . x , trim . height - trim . y ) ;
return comment . get CaMeL Created ( ) ;  <CTX>  public Date get CaMeL Date ( ) { return comment . get CaMeL Created ( ) ; }	return attachment . get CaMeL Date CaMeL Created ( ) ;
input = new Channel ( Short . TYPE , 1 ) ;  <CTX>  public void init ( ) { input = new Channel ( Short . TYPE , 1 ) ; }	input = new Channel ( Float . TYPE , 1 ) ;
String strval = new CaMeL Value . to CaMeL String ( ) ;  <CTX>  public void user CaMeL Changed CaMeL Value ( Object new CaMeL Value ) { if ( ! unlocked && ! is CaMeL Editable ( ) ) { / / if this data is read - only , / / restore its old value in case the user mess@@ ed it up . if ( consumer != null ) consumer . repository CaMeL Changed CaMeL Value ( ) ; } else try { / / parse the new value . last CaMeL Value = value ; if ( new CaMeL Value instanceof Boolean ) set CaMeL Boolean ( ( Boolean ) new CaMeL Value ) ; else { String strval = new CaMeL Value . to CaMeL String ( ) ; if ( strval == null || strval . length ( ) == 0 ) value = ( optional ? null : get CaMeL Null CaMeL Value ( ) ) ; else if ( strval . equals ( RESTORE _ DEFAULT _ COMMAND ) ) value = RESTORE _ DEFAULT _ TOKEN ; else set CaMeL String ( strval ) ; } / / if the data value has changed , if ( value == null || last CaMeL Value == null || ! value . save CaMeL String ( ) . equals ( last CaMeL Value . save CaMeL String ( ) ) ) { / / save it to the repository . data . put CaMeL Value ( data CaMeL Name , value ) ; last CaMeL Value = value ; } / / This could be a Malformed CaMeL Value CaMeL Exception / / ( from the set CaMeL String call ) or Remote CaMeL Exception } catch ( Exception e ) { / / ( from the put CaMeL Value call ) . value = last CaMeL Value ; / / restore original value of element . if ( consumer != null ) / / restore the HTML CaMeL Field to the old value . consumer . repository CaMeL Changed CaMeL Value ( ) ; } }	String strval = null ; if ( new CaMeL Value != null ) strval = new CaMeL Value . to CaMeL String ( ) ;
Resource resource = domain . find CaMeL Resource ( storage CaMeL Path , load CaMeL Options ) ; if ( resource == null ) { resource = domain . create CaMeL Resource ( storage CaMeL Path ) ; } domain . load CaMeL Resource ( resource , load CaMeL Options , contents ) ;  <CTX>  public Resource load ( M CaMeL Editing CaMeL Domain domain , int load CaMeL Options , I CaMeL Progress CaMeL Monitor monitor ) throws Core CaMeL Exception { Input CaMeL Stream contents = f CaMeL Storage . get CaMeL Contents ( ) ; String storage CaMeL Path = f CaMeL Storage . get CaMeL Full CaMeL Path ( ) . to CaMeL String ( ) ; Resource resource = domain . find CaMeL Resource ( storage CaMeL Path , load CaMeL Options ) ; if ( resource == null ) { resource = domain . create CaMeL Resource ( storage CaMeL Path ) ; } domain . load CaMeL Resource ( resource , load CaMeL Options , contents ) ; return resource ; }	Resource resource = editing CaMeL Domain . get CaMeL Resource CaMeL Set ( ) . get CaMeL Resource ( URI . create CaMeL Platform CaMeL Resource CaMeL URI ( storage CaMeL Path , true ) , true ) ;
try { push CaMeL Iterator ( navigator . get CaMeL Self CaMeL Axis CaMeL Iterator ( context CaMeL Node ) ) ; } catch ( Unsupported CaMeL Axis CaMeL Exception e ) { } init ( context CaMeL Node , navigator ) ;  <CTX>  public Descendant CaMeL Or CaMeL Self CaMeL Axis CaMeL Iterator ( Object context CaMeL Node , Navigator navigator ) { try { push CaMeL Iterator ( navigator . get CaMeL Self CaMeL Axis CaMeL Iterator ( context CaMeL Node ) ) ; } catch ( Unsupported CaMeL Axis CaMeL Exception e ) { } init ( context CaMeL Node , navigator ) ; }	super ( navigator , new Singleton CaMeL List ( context CaMeL Node ) . iterator ( ) ) ;
return ( I CaMeL Scanner CaMeL Info ) get CaMeL Build CaMeL Info ( resource , false ) ;  <CTX>  public I CaMeL Scanner CaMeL Info get CaMeL Scanner CaMeL Information ( I CaMeL Resource resource ) { return ( I CaMeL Scanner CaMeL Info ) get CaMeL Build CaMeL Info ( resource , false ) ; }	return ( I CaMeL Scanner CaMeL Info ) get CaMeL Build CaMeL Info ( resource . get CaMeL Project ( ) , false ) ;
return category . get CaMeL Description ( false ) ;  <CTX>  public String get CaMeL Category CaMeL Name ( ) { return category . get CaMeL Description ( false ) ; }	return category . get CaMeL Description ( ) ;
if ( text CaMeL Control == null ) return ;  <CTX>  public void add CaMeL Text ( Text text CaMeL Control ) { if ( text CaMeL Control == null ) return ; active CaMeL Text CaMeL Control = text CaMeL Control ; text CaMeL Control . add CaMeL Listener ( SWT . Activate , text CaMeL Control CaMeL Listener ) ; text CaMeL Control . add CaMeL Listener ( SWT . Deactivate , text CaMeL Control CaMeL Listener ) ; / / We really want a selection listener but it is not supported so we / / use a key listener and a mouse listener to know when selection changes / / may have occured text CaMeL Control . add CaMeL Key CaMeL Listener ( key CaMeL Adapter ) ; text CaMeL Control . add CaMeL Mouse CaMeL Listener ( mouse CaMeL Adapter ) ; }	if ( text CaMeL Control == null ) { return ; }
Number CaMeL Data CaMeL Value get CaMeL Data CaMeL Value ( int value ) ;  <CTX>  Number CaMeL Data CaMeL Value get CaMeL Data CaMeL Value ( int value ) ;	Number CaMeL Data CaMeL Value get CaMeL Data CaMeL Value ( Integer value ) ;
return get CaMeL String CaMeL Property ( Cell . EVENT _ HANDLER _ CLASS _ PROP ) ;  <CTX>  public String get CaMeL Event CaMeL Handle CaMeL Class ( ) { return get CaMeL String CaMeL Property ( Cell . EVENT _ HANDLER _ CLASS _ PROP ) ; }	return get CaMeL String CaMeL Property ( I CaMeL Design CaMeL Element CaMeL Model . EVENT _ HANDLER _ CLASS _ PROP ) ;
} else if ( accessibility == Program CaMeL Element CaMeL Node . Accessibility . PRIVILE@@ GED ) {  <CTX>  public Icon get CaMeL Accessibility CaMeL Swing CaMeL Icon ( Program CaMeL Element CaMeL Node . Accessibility accessibility ) { if ( accessibility == Program CaMeL Element CaMeL Node . Accessibility . PUBLIC ) { return ACCESSIBILITY _ PUBLIC ; } else if ( accessibility == Program CaMeL Element CaMeL Node . Accessibility . PACKAGE ) { return ACCESSIBILITY _ PACKAGE ; } else if ( accessibility == Program CaMeL Element CaMeL Node . Accessibility . PROTECTED ) { return ACCESSIBILITY _ PROTECTED ; } else if ( accessibility == Program CaMeL Element CaMeL Node . Accessibility . PRIVATE ) { return ACCESSIBILITY _ PRIVATE ; } else if ( accessibility == Program CaMeL Element CaMeL Node . Accessibility . PRIVILE@@ GED ) { return ACCESSIBILITY _ PRIVILE@@ GED ; } else { return null ; } }	} else if ( accessibility == I CaMeL Program CaMeL Element . Accessibility . PRIVILE@@ GED ) {
return ( Direction ) Attribute CaMeL Factory . e CaMeL INSTANCE . create CaMeL From CaMeL String ( Attribute CaMeL Package . e CaMeL INSTANCE . get CaMeL Direction ( ) ,  <CTX>  public Direction create CaMeL Direction CaMeL Object CaMeL From CaMeL String ( E CaMeL Data CaMeL Type e CaMeL Data CaMeL Type , String initial CaMeL Value ) { return ( Direction ) Attribute CaMeL Factory . e CaMeL INSTANCE . create CaMeL From CaMeL String ( Attribute CaMeL Package . e CaMeL INSTANCE . get CaMeL Direction ( ) , initial CaMeL Value ) ; }	return ( Direction ) create CaMeL Direction CaMeL From CaMeL String ( Attribute CaMeL Package . Literals . DIRECTION ,
Sys CaMeL View CaMeL Import CaMeL Handler ( Importer importer , Namespace CaMeL Resolver ns CaMeL Context ) { super ( importer , ns CaMeL Context ) ;  <CTX>  Sys CaMeL View CaMeL Import CaMeL Handler ( Importer importer , Namespace CaMeL Resolver ns CaMeL Context ) { super ( importer , ns CaMeL Context ) ; }	Sys CaMeL View CaMeL Import CaMeL Handler ( Importer importer ) { super ( importer ) ;
if ( ! model . is CaMeL Forward ( ) ) {  <CTX>  public static boolean search CaMeL Again ( Project project , File CaMeL Editor file CaMeL Editor ) { if ( ! ( file CaMeL Editor instanceof Text CaMeL Editor ) ) return false ; Text CaMeL Editor text CaMeL Editor = ( Text CaMeL Editor ) file CaMeL Editor ; Editor editor = text CaMeL Editor . get CaMeL Editor ( ) ; Find CaMeL Manager find CaMeL Manager = Find CaMeL Manager . get CaMeL Instance ( project ) ; if ( ! find CaMeL Manager . find CaMeL Was CaMeL Performed ( ) ) { find ( project , editor ) ; return false ; } Find CaMeL Model model = find CaMeL Manager . get CaMeL Find CaMeL Next CaMeL Model ( ) ; if ( model == null ) { model = find CaMeL Manager . get CaMeL Find CaMeL In CaMeL File CaMeL Model ( ) ; } model = ( Find CaMeL Model ) model . clone ( ) ; int offset ; if ( DOWN . equals ( editor . get CaMeL User CaMeL Data ( KEY ) ) && model . is CaMeL Forward ( ) ) { offset = 0 ; } else if ( UP . equals ( editor . get CaMeL User CaMeL Data ( KEY ) ) && ! model . is CaMeL Forward ( ) ) { offset = editor . get CaMeL Document ( ) . get CaMeL Text CaMeL Length ( ) ; } else { editor . put CaMeL User CaMeL Data ( KEY , null ) ; offset = editor . get CaMeL Caret CaMeL Model ( ) . get CaMeL Offset ( ) ; if ( ! model . is CaMeL Forward ( ) ) { offset -- ; } } return search CaMeL Again ( project , editor , offset , model ) ; }	if ( ! model . is CaMeL Forward ( ) && offset > 0 ) {
return new Event CaMeL JDOM ( make CaMeL Child CaMeL Element ( Event CaMeL JDOM . BIR@@ TH ) ) ;  <CTX>  public Event get CaMeL Birth CaMeL Event ( ) { return new Event CaMeL JDOM ( make CaMeL Child CaMeL Element ( Event CaMeL JDOM . BIR@@ TH ) ) ; }	return new Event CaMeL JDOM ( JDOM CaMeL Utils . find CaMeL Or CaMeL Make CaMeL Child CaMeL Element ( Event CaMeL JDOM . BIR@@ TH , element ) ) ;
get CaMeL Pending CaMeL Connection ( conn CaMeL Id ) . send ( packet ) ;  <CTX>  private void send CaMeL To CaMeL Pending ( int conn CaMeL Id , Packet packet ) { get CaMeL Pending CaMeL Connection ( conn CaMeL Id ) . send ( packet ) ; }	if ( get CaMeL Pending CaMeL Connection ( conn CaMeL Id ) != null ) { get CaMeL Pending CaMeL Connection ( conn CaMeL Id ) . send ( packet ) ; } else { }
this . output . add CaMeL Ref ( encode CaMeL Type CaMeL Entry ( el@@ aborated CaMeL Type . get CaMeL Fully CaMeL Qualified CaMeL Name CaMeL Char CaMeL Arrays ( ) , F@@ WD _ CLASS , IC CaMeL Search CaMeL Constants . DECLARATIONS ) ) ;  <CTX>  public void add CaMeL Elaborated CaMeL Forward CaMeL Declaration ( IAST CaMeL Elaborated CaMeL Type CaMeL Specifier el@@ aborated CaMeL Type ) { if ( el@@ aborated CaMeL Type . get CaMeL Class CaMeL Kind ( ) . equals ( AST CaMeL Class CaMeL Kind . CLASS ) ) { this . output . add CaMeL Ref ( encode CaMeL Type CaMeL Entry ( el@@ aborated CaMeL Type . get CaMeL Fully CaMeL Qualified CaMeL Name CaMeL Char CaMeL Arrays ( ) , F@@ WD _ CLASS , IC CaMeL Search CaMeL Constants . DECLARATIONS ) ) ; } else if ( el@@ aborated CaMeL Type . get CaMeL Class CaMeL Kind ( ) . equals ( AST CaMeL Class CaMeL Kind . STRUCT ) ) { this . output . add CaMeL Ref ( encode CaMeL Type CaMeL Entry ( el@@ aborated CaMeL Type . get CaMeL Fully CaMeL Qualified CaMeL Name CaMeL Char CaMeL Arrays ( ) , F@@ WD _ STRUCT , IC CaMeL Search CaMeL Constants . DECLARATIONS ) ) ; } else if ( el@@ aborated CaMeL Type . get CaMeL Class CaMeL Kind ( ) . equals ( AST CaMeL Class CaMeL Kind . UNION ) ) { this . output . add CaMeL Ref ( encode CaMeL Type CaMeL Entry ( el@@ aborated CaMeL Type . get CaMeL Fully CaMeL Qualified CaMeL Name CaMeL Char CaMeL Arrays ( ) , F@@ WD _ UNION , IC CaMeL Search CaMeL Constants . DECLARATIONS ) ) ; } }	this . output . add CaMeL Ref ( encode CaMeL Type CaMeL Entry ( el@@ aborated CaMeL Type . get CaMeL Fully CaMeL Qualified CaMeL Name CaMeL Char CaMeL Arrays ( ) , F@@ WD _ CLASS , IC CaMeL Search CaMeL Constants . DECLARATIONS ) , index CaMeL Flag ) ;
synchronized ( Animator . this ) { Animator . this . notify ( ) ; }  <CTX>  public void run ( ) { / / Try to get Open CaMeL GL context optimization since we know we / / will be rendering this one drawable continu@@ ally from / / this thread ; make the context current once instead of / / ma@@ king it current and free@@ ing it each frame . drawable . set CaMeL Rendering CaMeL Thread ( Thread . current CaMeL Thread ( ) ) ; / / Since set CaMeL Rendering CaMeL Thread is currently advisory ( bec@@ ause / / of the po@@ or JA@@ WT implementation in the Motif AWT , which / / per@@ forms ex@@ cessive locking ) we also prevent repaint ( ) , / / which is called from the AWT thread , from having an / / effect for better multi@@ th@@ reading behavior . This call is / / not strictly necessary , but if end users write their / / own animation loops which update multiple draw@@ ables per / / tick then it may be necessary to enforce the order of / / updates . drawable . set CaMeL No CaMeL Auto CaMeL Redraw CaMeL Mode ( true ) ; boolean no CaMeL Exception = false ; try { while ( ! should CaMeL Stop ) { no CaMeL Exception = false ; drawable . display ( ) ; no CaMeL Exception = true ; } } finally { should CaMeL Stop = false ; drawable . set CaMeL No CaMeL Auto CaMeL Redraw CaMeL Mode ( false ) ; if ( no CaMeL Exception ) { try { drawable . set CaMeL Rendering CaMeL Thread ( null ) ; } finally { thread = null ; synchronized ( Animator . this ) { Animator . this . notify ( ) ; } } } } }	Animator . this . notify ( ) ;
return ;  <CTX>  private void process CaMeL Nested CaMeL Inclusions ( int file CaMeL Number , IAST CaMeL Inclusion CaMeL Node [ ] inclusions , IAST CaMeL Inclusion CaMeL Node parent ) { for ( int i = 0 ; i < inclusions . length ; i ++ ) { IAST CaMeL Inclusion CaMeL Node inclusion = inclusions [ i ] ; / / Quick check to see if the name is in an already indexed external header file if ( Index CaMeL Encoder CaMeL Util . node CaMeL In CaMeL Visited CaMeL External CaMeL Header ( inclusion . get CaMeL Include CaMeL Directive ( ) , get CaMeL Indexer ( ) ) ) return ; String include = inclusion . get CaMeL Include CaMeL Directive ( ) . get CaMeL Path ( ) ; if ( are CaMeL Problem CaMeL Markers CaMeL Enabled ( ) ) { I CaMeL Path new CaMeL Path = new Path ( include ) ; I CaMeL File temp CaMeL File = C CaMeL Core CaMeL Plugin . get CaMeL Workspace ( ) . get CaMeL Root ( ) . get CaMeL File CaMeL For CaMeL Location ( new CaMeL Path ) ; if ( temp CaMeL File != null ) { / / File is in the workspace request CaMeL Remove CaMeL Markers ( temp CaMeL File , resource CaMeL File ) ; } } get CaMeL Output ( ) . add CaMeL Include CaMeL Ref ( file CaMeL Number , include ) ; get CaMeL Output ( ) . add CaMeL Rela@@ tives ( file CaMeL Number , include , ( parent != null ) ? parent . get CaMeL Include CaMeL Directive ( ) . get CaMeL Path ( ) : null ) ; Named CaMeL Entry named CaMeL Entry = new Named CaMeL Entry ( I CaMeL Index . INCLUDE , I CaMeL Index . REFERENCE , new char [ ] [ ] { include . to CaMeL Char CaMeL Array ( ) } , 0 , file CaMeL Number ) ; named CaMeL Entry . set CaMeL Name CaMeL Offset ( 1 , 1 , I CaMeL Index . OFFSET ) ; named CaMeL Entry . serialize ( get CaMeL Output ( ) ) ; / * See if this file has been encountered before * / indexer . have CaMeL Encountered CaMeL Header ( resource CaMeL File . get CaMeL Project ( ) . get CaMeL Full CaMeL Path ( ) , new Path ( include ) , true ) ; / / recurse process CaMeL Nested CaMeL Inclusions ( file CaMeL Number , inclusion . get CaMeL Nested CaMeL Inclusions ( ) , inclusion ) ; } }	continue ;
Object r@@ txt = message CaMeL Info . get CaMeL Meta CaMeL Data ( Binding CaMeL Provider CaMeL Properties . JAXWS _ RUNTIME _ CONTEXT ) ; return r@@ txt == null ? null : ( Runtime CaMeL Context ) r@@ txt ;  <CTX>  public static Runtime CaMeL Context get CaMeL Runtime CaMeL Context ( Message CaMeL Info message CaMeL Info ) { Object r@@ txt = message CaMeL Info . get CaMeL Meta CaMeL Data ( Binding CaMeL Provider CaMeL Properties . JAXWS _ RUNTIME _ CONTEXT ) ; return r@@ txt == null ? null : ( Runtime CaMeL Context ) r@@ txt ; }	return ( Runtime CaMeL Context ) message CaMeL Info . get CaMeL Meta CaMeL Data ( Binding CaMeL Provider CaMeL Properties . JAXWS _ RUNTIME _ CONTEXT ) ;
if ( selected CaMeL View != null ) { restore CaMeL Item . set CaMeL Enabled ( page != null && page . is CaMeL Moveable ( selected CaMeL View ) ) ; } else { restore CaMeL Item . set CaMeL Enabled ( false ) ;  <CTX>  public void fill ( Menu menu , int index ) { / / TODO Auto - generated method stub super . fill ( menu , index ) ; orientation CaMeL Item = new Menu CaMeL Item ( menu , SWT . CASCADE , index ++ ) ; { orientation CaMeL Item . set CaMeL Text ( Workbench CaMeL Messages . Fast CaMeL View CaMeL Bar _ view _ orientation ) ; Menu orientation CaMeL Swt CaMeL Menu = new Menu ( orientation CaMeL Item ) ; Radio CaMeL Menu orientation CaMeL Menu = new Radio CaMeL Menu ( orientation CaMeL Swt CaMeL Menu , current CaMeL Orientation ) ; orientation CaMeL Menu . add CaMeL Menu CaMeL Item ( Workbench CaMeL Messages . Fast CaMeL View CaMeL Bar _ horizontal , new Integer ( SWT . HORIZONTAL ) ) ; orientation CaMeL Menu . add CaMeL Menu CaMeL Item ( Workbench CaMeL Messages . Fast CaMeL View CaMeL Bar _ vertical , new Integer ( SWT . VERTICAL ) ) ; orientation CaMeL Item . set CaMeL Menu ( orientation CaMeL Swt CaMeL Menu ) ; } restore CaMeL Item = new Menu CaMeL Item ( menu , SWT . CHECK , index ++ ) ; restore CaMeL Item . set CaMeL Text ( Workbench CaMeL Messages . View CaMeL Pane _ fast CaMeL View ) ; restore CaMeL Item . add CaMeL Selection CaMeL Listener ( new Selection CaMeL Adapter ( ) { public void widget CaMeL Selected ( Selection CaMeL Event e ) { bar . restore CaMeL View ( selected CaMeL View , true , true ) ; } } ) ; close CaMeL Item = new Menu CaMeL Item ( menu , SWT . NONE , index ++ ) ; close CaMeL Item . set CaMeL Text ( Workbench CaMeL Messages . Workbench CaMeL Window _ close ) ; close CaMeL Item . add CaMeL Selection CaMeL Listener ( new Selection CaMeL Adapter ( ) { public void widget CaMeL Selected ( Selection CaMeL Event e ) { if ( selected CaMeL View != null ) { Workbench CaMeL Page page = bar . get CaMeL Window ( ) . get CaMeL Active CaMeL Workbench CaMeL Page ( ) ; if ( page != null ) { page . hide CaMeL View ( selected CaMeL View ) ; } } } } ) ; / / Set menu item enabl@@ ement etc based on whe@@ ther a view is selected Workbench CaMeL Page page = bar . get CaMeL Window ( ) . get CaMeL Active CaMeL Workbench CaMeL Page ( ) ; if ( selected CaMeL View != null ) { restore CaMeL Item . set CaMeL Enabled ( page != null && page . is CaMeL Moveable ( selected CaMeL View ) ) ; } else { restore CaMeL Item . set CaMeL Enabled ( false ) ; } restore CaMeL Item . set CaMeL Selection ( true ) ; if ( selected CaMeL View != null ) { close CaMeL Item . set CaMeL Enabled ( page != null && page . is CaMeL Closeable ( selected CaMeL View ) ) ; } else { close CaMeL Item . set CaMeL Enabled ( false ) ; } orientation CaMeL Item . set CaMeL Enabled ( selected CaMeL View != null ) ; if ( selected CaMeL View != null ) { / / Set the new orientation , but avoid re - sending the event to our own / / listener current CaMeL Orientation . set ( bar . get CaMeL Orientation ( selected CaMeL View ) , orientation CaMeL Change CaMeL Listener ) ; } }	if ( restore CaMeL Item != null ) { if ( selected CaMeL View != null ) { restore CaMeL Item . set CaMeL Enabled ( page != null && page . is CaMeL Moveable ( selected CaMeL View ) ) ; } else { restore CaMeL Item . set CaMeL Enabled ( false ) ; } restore CaMeL Item . set CaMeL Selection ( true ) ;
this . glass CaMeL Pane = ( J CaMeL Panel ) get CaMeL Glass CaMeL Pane ( ) ; this . progress CaMeL Bar = new J CaMeL Progress CaMeL Bar ( ) ;  <CTX>  public Wait CaMeL Cursor ( Object component , String message ) { this . component = component ; this . message = message ; this . glass CaMeL Pane = ( J CaMeL Panel ) get CaMeL Glass CaMeL Pane ( ) ; this . progress CaMeL Bar = new J CaMeL Progress CaMeL Bar ( ) ; }	this . glass CaMeL Pane = ( J CaMeL Panel ) find CaMeL Glass CaMeL Pane ( component ) ; this . status CaMeL Reporter = status CaMeL Reporter ;
Iterator iter = target CaMeL List . list CaMeL Iterator ( ) ;  <CTX>  public void update CaMeL Owner ( I CaMeL Resource resource ) { / / Check to see if the owner is the same as the argument if ( resource != null ) { if ( ! owner . equals ( resource ) ) { owner = resource ; / / Do the same for the targets Iterator iter = target CaMeL List . list CaMeL Iterator ( ) ; while ( iter . has CaMeL Next ( ) ) { I CaMeL Target target = ( I CaMeL Target ) iter . next ( ) ; target . update CaMeL Owner ( resource ) ; } } } }	Iterator iter = get CaMeL Targets ( ) . list CaMeL Iterator ( ) ;
set CaMeL Disable CaMeL Message CaMeL Timestamp ( boolean value ) throws JMS CaMeL Exception ;  <CTX>  set CaMeL Disable CaMeL Message CaMeL Timestamp ( boolean value ) throws JMS CaMeL Exception ;	void set CaMeL Disable CaMeL Message CaMeL Timestamp ( boolean value ) throws JMS CaMeL Exception ;
if ( ! workspace . get CaMeL Root ( ) . get CaMeL Project ( project CaMeL Name ) . exists ( ) )  <CTX>  private String get CaMeL Copy CaMeL Name CaMeL For ( String project CaMeL Name ) { I CaMeL Workspace workspace = get CaMeL Project ( ) . get CaMeL Workspace ( ) ; if ( ! workspace . get CaMeL Root ( ) . get CaMeL Project ( project CaMeL Name ) . exists ( ) ) return project CaMeL Name ; int counter = 1 ; while ( true ) { String name CaMeL Segment ; if ( counter > 1 ) { name CaMeL Segment = NLS . bind ( IDE CaMeL Workbench CaMeL Messages . Copy CaMeL Project CaMeL Action _ copy CaMeL Name CaMeL Two CaMeL Args , new Integer ( counter ) , project CaMeL Name ) ; } else { name CaMeL Segment = NLS . bind ( IDE CaMeL Workbench CaMeL Messages . Copy CaMeL Project CaMeL Action _ copy CaMeL Name CaMeL One CaMeL Arg , project CaMeL Name ) ; } if ( ! workspace . get CaMeL Root ( ) . get CaMeL Project ( name CaMeL Segment ) . exists ( ) ) return name CaMeL Segment ; counter ++ ; } }	if ( ! workspace . get CaMeL Root ( ) . get CaMeL Project ( project CaMeL Name ) . exists ( ) ) {
show CaMeL Tab ( _ junit CaMeL Error CaMeL Panel ) ; _ junit CaMeL Error CaMeL Panel . set CaMeL J CaMeL Unit CaMeL In CaMeL Progress ( docs ) ; _ junit CaMeL Action . set CaMeL Enabled ( false ) ; _ junit CaMeL All CaMeL Action . set CaMeL Enabled ( false ) ;  <CTX>  public void run ( ) { / / Main CaMeL Frame . this . hourglass CaMeL On ( ) ; show CaMeL Tab ( _ junit CaMeL Error CaMeL Panel ) ; _ junit CaMeL Error CaMeL Panel . set CaMeL J CaMeL Unit CaMeL In CaMeL Progress ( docs ) ; _ junit CaMeL Action . set CaMeL Enabled ( false ) ; _ junit CaMeL All CaMeL Action . set CaMeL Enabled ( false ) ; }	_ model . set CaMeL Active CaMeL Document ( doc ) ; show CaMeL Tab ( _ interactions CaMeL Pane ) ;
return ( false ) ;  <CTX>  equals ( Object obj ) { if ( obj == null ) return ( false ) ; if ( ! ( obj instanceof Font ) ) return ( false ) ; Font f = ( Font ) obj ; return ( f . get CaMeL Name ( ) . equals ( this . get CaMeL Name ( ) ) && f . get CaMeL Family ( ) . equals ( this . get CaMeL Family ( ) ) && f . get CaMeL Font CaMeL Name ( ) . equals ( this . get CaMeL Font CaMeL Name ( ) ) && f . get CaMeL Transform ( ) . equals ( this . get CaMeL Transform ( ) ) && f . get CaMeL Size ( ) == this . get CaMeL Size ( ) && f . get CaMeL Style ( ) == this . get CaMeL Style ( ) ) ; }	return false ;
remove CaMeL Workspace CaMeL Descriptors ( ( I CaMeL Plugin CaMeL Model CaMeL Base ) removed [ i ] ) ;  <CTX>  public void models CaMeL Changed ( I CaMeL Model CaMeL Provider CaMeL Event e ) { int type = e . get CaMeL Event CaMeL Types ( ) ; if ( ( type & I CaMeL Model CaMeL Provider CaMeL Event . MODELS _ ADDED ) != 0 ) { I CaMeL Model [ ] added = e . get CaMeL Added CaMeL Models ( ) ; for ( int i = 0 ; i < added . length ; i ++ ) { load CaMeL Workspace CaMeL Descriptors ( ( I CaMeL Plugin CaMeL Model CaMeL Base ) added [ i ] ) ; } } if ( ( type & I CaMeL Model CaMeL Provider CaMeL Event . MODELS _ REMOVED ) != 0 ) { I CaMeL Model [ ] removed = e . get CaMeL Removed CaMeL Models ( ) ; for ( int i = 0 ; i < removed . length ; i ++ ) { remove CaMeL Workspace CaMeL Descriptors ( ( I CaMeL Plugin CaMeL Model CaMeL Base ) removed [ i ] ) ; } } if ( ( type & I CaMeL Model CaMeL Provider CaMeL Event . MODELS _ CHANGED ) != 0 ) { I CaMeL Model [ ] changed = e . get CaMeL Changed CaMeL Models ( ) ; if ( dirty CaMeL Workspace CaMeL Models == null ) dirty CaMeL Workspace CaMeL Models = new Vector ( ) ; for ( int i = 0 ; i < changed . length ; i ++ ) { dirty CaMeL Workspace CaMeL Models . add ( ( I CaMeL Plugin CaMeL Model CaMeL Base ) changed [ i ] ) ; } } }	I CaMeL Model model = removed [ i ] ; if ( ! ( model instanceof I CaMeL Plugin CaMeL Model CaMeL Base ) ) continue ; remove CaMeL Workspace CaMeL Descriptors ( ( I CaMeL Plugin CaMeL Model CaMeL Base ) model ) ;
target [ 0 ] = new C CaMeL Debug CaMeL Target ( launch , IC CaMeL Debug CaMeL Target CaMeL Type . TARGET _ TYPE _ LOCAL _ CORE _ DUMP , cdi CaMeL Target , name , null , debugger CaMeL Process , file , true , false ) ;  <CTX>  public void run ( I CaMeL Progress CaMeL Monitor m ) { target [ 0 ] = new C CaMeL Debug CaMeL Target ( launch , IC CaMeL Debug CaMeL Target CaMeL Type . TARGET _ TYPE _ LOCAL _ CORE _ DUMP , cdi CaMeL Target , name , null , debugger CaMeL Process , file , true , false ) ; }	target [ 0 ] = new C CaMeL Core CaMeL File CaMeL Debug CaMeL Target ( launch , cdi CaMeL Target , name , debugger CaMeL Process , file ) ;
void build CaMeL Label ( Viewer CaMeL Label update CaMeL Label , Object element , I CaMeL Viewer CaMeL Label CaMeL Provider label CaMeL Provider ) {  <CTX>  void build CaMeL Label ( Viewer CaMeL Label update CaMeL Label , Object element , I CaMeL Viewer CaMeL Label CaMeL Provider label CaMeL Provider ) { label CaMeL Provider . update CaMeL Label ( update CaMeL Label , element ) ; color CaMeL And CaMeL Font CaMeL Collector . set CaMeL Used CaMeL Decorators ( ) ; if ( update CaMeL Label . has CaMeL New CaMeL Background ( ) ) { color CaMeL And CaMeL Font CaMeL Collector . set CaMeL Background ( update CaMeL Label . get CaMeL Background ( ) ) ; } if ( update CaMeL Label . has CaMeL New CaMeL Foreground ( ) ) { color CaMeL And CaMeL Font CaMeL Collector . set CaMeL Foreground ( update CaMeL Label . get CaMeL Foreground ( ) ) ; } if ( update CaMeL Label . has CaMeL New CaMeL Font ( ) ) { color CaMeL And CaMeL Font CaMeL Collector . set CaMeL Font ( update CaMeL Label . get CaMeL Font ( ) ) ; } }	protected void build CaMeL Label ( Viewer CaMeL Label update CaMeL Label , Object element ) {
( ( Hashtable ) colors ) . clear ( ) ;  <CTX>  public void set CaMeL Mode ( Mode mode ) { if ( this . mode == mode ) return ; if ( this . mode != null ) this . mode . leave ( this ) ; this . mode = mode ; if ( mode == null ) { token CaMeL Marker = null ; } else { set CaMeL Token CaMeL Marker ( mode . create CaMeL Token CaMeL Marker ( ) ) ; ( ( Hashtable ) colors ) . clear ( ) ; / / XXX mode . enter ( this ) ; } fire CaMeL Buffer CaMeL Event ( new Buffer CaMeL Event ( Buffer CaMeL Event . MODE _ CHANGED , this ) ) ; }	( ( Hashtable ) get CaMeL Colors ( ) ) . clear ( ) ;
catch ( java . awt . data@@ transfer . Unsupported CaMeL Flavor CaMeL Exception e ) { } catch ( IO CaMeL Exception e ) {  <CTX>  public void a _ paste ( ) { java . awt . data@@ transfer . Clipboard clipboard = Toolkit . get CaMeL Default CaMeL Toolkit ( ) . get CaMeL System CaMeL Clipboard ( ) ; java . awt . data@@ transfer . Transferable contents = clipboard . get CaMeL Contents ( null ) ; if ( contents != null ) { try { String text = ( String ) contents . get CaMeL Transfer CaMeL Data ( java . awt . data@@ transfer . Data CaMeL Flavor . string CaMeL Flavor ) ; prop CaMeL List . paste CaMeL Properties CaMeL String ( text ) ; } catch ( java . awt . data@@ transfer . Unsupported CaMeL Flavor CaMeL Exception e ) { } catch ( IO CaMeL Exception e ) { } } }	else { try { String text = ( String ) contents . get CaMeL Transfer CaMeL Data ( java . awt . data@@ transfer . Data CaMeL Flavor . string CaMeL Flavor ) ; prop CaMeL List . paste CaMeL Properties CaMeL String ( text ) ; } catch ( Unsupported CaMeL Flavor CaMeL Exception e ) { } catch ( IO CaMeL Exception e ) { }
return ++ absolute CaMeL Sequence CaMeL ID ;  <CTX>  private synchronized long get CaMeL Next CaMeL Sequence CaMeL ID ( ) { return ++ absolute CaMeL Sequence CaMeL ID ; }	return body CaMeL ID . to CaMeL String ( ) . hash CaMeL Code ( ) ++ ++ ++ absolute CaMeL Sequence CaMeL ID ;
return new I CaMeL Source CaMeL Container [ 0 ] ;  <CTX>  public I CaMeL Source CaMeL Container [ ] compute CaMeL Source CaMeL Containers ( I CaMeL Launch CaMeL Configuration configuration , I CaMeL Progress CaMeL Monitor monitor ) throws Core CaMeL Exception { String project CaMeL Name = configuration . get CaMeL Attribute ( ICDT CaMeL Launch CaMeL Configuration CaMeL Constants . ATTR _ PROJECT _ NAME , ( String ) null ) ; if ( project CaMeL Name != null ) { I CaMeL Project project = Resources CaMeL Plugin . get CaMeL Workspace ( ) . get CaMeL Root ( ) . get CaMeL Project ( project CaMeL Name ) ; if ( project . exists ( ) ) { return new I CaMeL Source CaMeL Container [ ] { new Project CaMeL Source CaMeL Container ( project , true ) } ; } } return new I CaMeL Source CaMeL Container [ 0 ] ; }	return ( I CaMeL Source CaMeL Container [ ] ) containers . to CaMeL Array ( new I CaMeL Source CaMeL Container [ containers . size ( ) ] ) ;
return Ruby CaMeL Module . m _ new CaMeL Module ( ruby , ( Ruby CaMeL Class ) klass ) ;  <CTX>  public VALUE rb _ module _ s _ new ( VALUE klass ) { return Ruby CaMeL Module . m _ new CaMeL Module ( ruby , ( Ruby CaMeL Class ) klass ) ; }	return Ruby CaMeL Module . m _ new ( ruby , ( Ruby CaMeL Object ) klass ) ;
if ( data == null ) { return get CaMeL Id CaMeL Value ( id ) ;  <CTX>  public Object get ( String name , Scriptable start ) { if ( max CaMeL Id != 0 ) { int id = get CaMeL Id ( name ) ; if ( id != 0 ) { Object [ ] data = id CaMeL Map CaMeL Data ; if ( data == null ) { return get CaMeL Id CaMeL Value ( id ) ; } else { Object value = data [ id - 1 ] ; if ( value == null ) { value = get CaMeL Id CaMeL Value ( id ) ; } else if ( value == NULL _ TAG ) { value = null ; } return value ; } } } return super . get ( name , start ) ; }	if ( data == null ) { int id = map CaMeL Name CaMeL To CaMeL Id ( name ) ; if ( id != 0 ) { return get CaMeL Id CaMeL Value ( id ) ; }
set CaMeL String CaMeL Property ( Style . WHITE _ SPACE _ PROP , value ) ;  <CTX>  public void set CaMeL White CaMeL Space ( String value ) throws Semantic CaMeL Exception { set CaMeL String CaMeL Property ( Style . WHITE _ SPACE _ PROP , value ) ; }	set CaMeL String CaMeL Property ( I CaMeL Style CaMeL Model . WHITE _ SPACE _ PROP , value ) ;
if ( children . contains ( content ) )  <CTX>  public void start CaMeL Content ( I CaMeL Content content ) { List children = root . get CaMeL Children ( ) ; if ( parent != null ) { children = parent . get CaMeL Children ( ) ; } if ( children . contains ( content ) ) { children . add ( content ) ; } parent = content ; }	if ( ! children . contains ( content ) )
if ( r@@ ga . is CaMeL Empty ( ) || item == null ) {  <CTX>  public synchronized Random CaMeL Grab CaMeL Array CaMeL Item remove CaMeL Random ( ) { while ( true ) { if ( grab CaMeL Arrays . length == 0 ) return null ; int x = rand . next CaMeL Int ( grab CaMeL Arrays . length ) ; Remove CaMeL Random CaMeL With CaMeL Client r@@ ga = grab CaMeL Arrays [ x ] ; Random CaMeL Grab CaMeL Array CaMeL Item item = r@@ ga . remove CaMeL Random ( ) ; if ( r@@ ga . is CaMeL Empty ( ) || item == null ) { Object client = r@@ ga . get CaMeL Client ( ) ; grab CaMeL Arrays CaMeL By CaMeL Client . remove ( client ) ; Random CaMeL Grab CaMeL Array CaMeL With CaMeL Client [ ] new CaMeL Array = new Random CaMeL Grab CaMeL Array CaMeL With CaMeL Client [ grab CaMeL Arrays . length - 1 ] ; if ( x > 0 ) System . arraycopy ( grab CaMeL Arrays , 0 , new CaMeL Array , 0 , x ) ; if ( x < grab CaMeL Arrays . length - 1 ) System . arraycopy ( grab CaMeL Arrays , x + 1 , new CaMeL Array , x , grab CaMeL Arrays . length - ( x + 1 ) ) ; grab CaMeL Arrays = new CaMeL Array ; } if ( item == null ) continue ; if ( item . is CaMeL Finished ( ) ) continue ; return item ; } }	if ( r@@ ga . is CaMeL Empty ( ) || ( item == null ) ) {
i CaMeL Code CaMeL Top = add CaMeL Short ( index , i CaMeL Code CaMeL Top ) ; last CaMeL String CaMeL Index = index ;  <CTX>  private int add CaMeL String ( String str , int i CaMeL Code CaMeL Top ) { int index = its CaMeL Strings . get ( str , - 1 ) ; if ( index == - 1 ) { index = its CaMeL Strings . size ( ) ; its CaMeL Strings . put ( str , index ) ; } i CaMeL Code CaMeL Top = add CaMeL Short ( index , i CaMeL Code CaMeL Top ) ; last CaMeL String CaMeL Index = index ; return i CaMeL Code CaMeL Top ; }	i CaMeL Code CaMeL Top = add CaMeL Index ( index , i CaMeL Code CaMeL Top ) ; last CaMeL Add CaMeL String = str ;
get CaMeL Cell CaMeL Editor ( ) . add CaMeL Cell CaMeL Editor CaMeL Listener ( this ) ;  <CTX>  protected Accessible CaMeL J CaMeL Table ( ) { get CaMeL Model ( ) . add CaMeL Table CaMeL Model CaMeL Listener ( this ) ; get CaMeL Selection CaMeL Model ( ) . add CaMeL List CaMeL Selection CaMeL Listener ( this ) ; get CaMeL Column CaMeL Model ( ) . add CaMeL Column CaMeL Model CaMeL Listener ( this ) ; get CaMeL Cell CaMeL Editor ( ) . add CaMeL Cell CaMeL Editor CaMeL Listener ( this ) ; }	last CaMeL Selected CaMeL Row = get CaMeL Selected CaMeL Row ( ) ; last CaMeL Selected CaMeL Column = get CaMeL Selected CaMeL Column ( ) ; Table CaMeL Cell CaMeL Editor editor = get CaMeL Cell CaMeL Editor ( ) ; if ( editor != null ) editor . add CaMeL Cell CaMeL Editor CaMeL Listener ( this ) ;
* color . The fix is to send a fake WM _ SET@@ FOCUS event to cause  <CTX>  void set CaMeL Background CaMeL Pixel ( int pixel ) { if ( background == pixel ) return ; super . set CaMeL Background CaMeL Pixel ( pixel ) ; / * * Bug in Windows . Changing the background color of the Scale * widget and calling Invalidate CaMeL Rect ( ) still dra@@ ws with the old * color . The fix is to send a fake WM _ SET@@ FOCUS event to cause * it to redraw with the new background color . * / ignore CaMeL Focus = true ; OS . Send CaMeL Message ( handle , OS . WM _ SET@@ FOCUS , 0 , 0 ) ; ignore CaMeL Focus = false ; }	* color . The fix is to send a fake WM _ SIZE event to cause
{ acc . add ( attr ) ; }  <CTX>  void add CaMeL Namespace CaMeL Attributes ( Node context , Collection acc ) { Named CaMeL Node CaMeL Map attrs = context . get CaMeL Attributes ( ) ; if ( attrs != null ) { int attr CaMeL Len = attrs . get CaMeL Length ( ) ; for ( int i = 0 ; i < attr CaMeL Len ; i ++ ) { Node attr = attrs . item ( i ) ; if ( is CaMeL Namespace CaMeL Attribute ( attr ) ) { acc . add ( attr ) ; } } } }	acc . add ( attr ) ;
switch ( e CaMeL Derived CaMeL Structural CaMeL Feature CaMeL ID ( e CaMeL Feature ) )  <CTX>  public Object e CaMeL Get ( E CaMeL Structural CaMeL Feature e CaMeL Feature , boolean resolve ) { switch ( e CaMeL Derived CaMeL Structural CaMeL Feature CaMeL ID ( e CaMeL Feature ) ) { case Layout CaMeL Package . LEGEND _ _ CHILDREN : return get CaMeL Children ( ) ; case Layout CaMeL Package . LEGEND _ _ BOUNDS : return get CaMeL Bounds ( ) ; case Layout CaMeL Package . LEGEND _ _ ANCHOR : return get CaMeL Anchor ( ) ; case Layout CaMeL Package . LEGEND _ _ STRETCH : return get CaMeL Stretch ( ) ; case Layout CaMeL Package . LEGEND _ _ INSETS : return get CaMeL Insets ( ) ; case Layout CaMeL Package . LEGEND _ _ ROW : return new Integer ( get CaMeL Row ( ) ) ; case Layout CaMeL Package . LEGEND _ _ COLUMN : return new Integer ( get CaMeL Column ( ) ) ; case Layout CaMeL Package . LEGEND _ _ ROW@@ SPAN : return new Integer ( get CaMeL Rowspan ( ) ) ; case Layout CaMeL Package . LEGEND _ _ COLUMN@@ SPAN : return new Integer ( get CaMeL Colum@@ n@@ span ( ) ) ; case Layout CaMeL Package . LEGEND _ _ MIN _ SIZE : return get CaMeL Min CaMeL Size ( ) ; case Layout CaMeL Package . LEGEND _ _ OUTLINE : return get CaMeL Outline ( ) ; case Layout CaMeL Package . LEGEND _ _ BACKGROUND : return get CaMeL Background ( ) ; case Layout CaMeL Package . LEGEND _ _ VISIBLE : return is CaMeL Visible ( ) ? Boolean . TRUE : Boolean . FALSE ; case Layout CaMeL Package . LEGEND _ _ TRIGGERS : return get CaMeL Triggers ( ) ; case Layout CaMeL Package . LEGEND _ _ HORIZONTAL _ SPACING : return new Integer ( get CaMeL Horizontal CaMeL Spacing ( ) ) ; case Layout CaMeL Package . LEGEND _ _ VERTICAL _ SPACING : return new Integer ( get CaMeL Vertical CaMeL Spacing ( ) ) ; case Layout CaMeL Package . LEGEND _ _ CLIENT _ AREA : return get CaMeL Client CaMeL Area ( ) ; case Layout CaMeL Package . LEGEND _ _ TEXT : return get CaMeL Text ( ) ; case Layout CaMeL Package . LEGEND _ _ ORIENTATION : return get CaMeL Orientation ( ) ; case Layout CaMeL Package . LEGEND _ _ DIRECTION : return get CaMeL Direction ( ) ; case Layout CaMeL Package . LEGEND _ _ SEPARATOR : return get CaMeL Separator ( ) ; case Layout CaMeL Package . LEGEND _ _ POSITION : return get CaMeL Position ( ) ; case Layout CaMeL Package . LEGEND _ _ ITEM _ TYPE : return get CaMeL Item CaMeL Type ( ) ; case Layout CaMeL Package . LEGEND _ _ TITLE : return get CaMeL Title ( ) ; case Layout CaMeL Package . LEGEND _ _ TITLE _ POSITION : return get CaMeL Title CaMeL Position ( ) ; case Layout CaMeL Package . LEGEND _ _ SHOW _ VALUE : return is CaMeL Show CaMeL Value ( ) ? Boolean . TRUE : Boolean . FALSE ; case Layout CaMeL Package . LEGEND _ _ SHOW _ PERCENT : return is CaMeL Show CaMeL Percent ( ) ? Boolean . TRUE : Boolean . FALSE ; case Layout CaMeL Package . LEGEND _ _ SHOW _ TOTAL : return is CaMeL Show CaMeL Total ( ) ? Boolean . TRUE : Boolean . FALSE ; } return e CaMeL Dynamic CaMeL Get ( e CaMeL Feature , resolve ) ; }	switch ( feature CaMeL ID )
node . element = new String ( tag . name ) ;  <CTX>  public static void coerce CaMeL Node ( Lexer lexer , Node node , Dict tag ) { Node tmp = lexer . inferred CaMeL Tag ( tag . name ) ; Report . warning ( lexer , node , tmp , Report . OBSOLETE _ ELEMENT ) ; node . was = node . tag ; node . tag = tag ; node . type = Start CaMeL Tag ; node . implicit = true ; node . element = new String ( tag . name ) ; }	node . element = tag . name ;
} int span = ( int ) child . get CaMeL Preferred CaMeL Span ( flow CaMeL Axis ) ; if ( span > span CaMeL Left ) { offset = - 1 ;  <CTX>  protected int layout CaMeL Row ( Flow CaMeL View fv , int row CaMeL Index , int pos ) { int span CaMeL Left = fv . get CaMeL Flow CaMeL Span ( row CaMeL Index ) ; if ( span CaMeL Left <= 0 ) return - 1 ; int offset = pos ; View row = fv . get CaMeL View ( row CaMeL Index ) ; int flow CaMeL Axis = fv . get CaMeL Flow CaMeL Axis ( ) ; while ( span CaMeL Left > 0 ) { View child = create CaMeL View ( fv , offset , span CaMeL Left , row CaMeL Index ) ; if ( child == null ) { offset = - 1 ; break ; } int span = ( int ) child . get CaMeL Preferred CaMeL Span ( flow CaMeL Axis ) ; if ( span > span CaMeL Left ) { offset = - 1 ; break ; } row . append ( child ) ; span CaMeL Left -= span ; offset = child . get CaMeL End CaMeL Offset ( ) ; } return offset ; }	View view = create CaMeL View ( fv , offset , span , row CaMeL Index ) ; if ( view == null )
seed CaMeL From CaMeL External CaMeL Stuff ( ) ;  <CTX>  public void checkpoint ( ) { seed CaMeL From CaMeL External CaMeL Stuff ( ) ; }	seed CaMeL From CaMeL External CaMeL Stuff ( true ) ;
add CaMeL Item ( String item ) { add ( item ) ; }  <CTX>  add CaMeL Item ( String item ) { add ( item ) ; }	public synchronized void add CaMeL Item ( String item ) { add ( item ) ; }
java . lang . String folder CaMeL Id , java . lang . String name , java . lang . String title , java . lang . String description )  <CTX>  public static com . li@@ fer@@ ay . portlet . document@@ library . model . DL CaMeL File CaMeL Entry update CaMeL File CaMeL Entry ( java . lang . String folder CaMeL Id , java . lang . String name , java . lang . String title , java . lang . String description ) throws com . li@@ fer@@ ay . portal . Portal CaMeL Exception , java . rmi . Remote CaMeL Exception , com . li@@ fer@@ ay . portal . System CaMeL Exception { DL CaMeL File CaMeL Entry CaMeL Service dl CaMeL File CaMeL Entry CaMeL Service = DL CaMeL File CaMeL Entry CaMeL Service CaMeL Factory . get CaMeL Service ( ) ; return dl CaMeL File CaMeL Entry CaMeL Service . update CaMeL File CaMeL Entry ( folder CaMeL Id , name , title , description ) ; }	java . lang . String folder CaMeL Id , java . lang . String new CaMeL Folder CaMeL Id , java . lang . String name , java . lang . String source CaMeL File CaMeL Name , java . lang . String title , java . lang . String description , byte [ ] byte CaMeL Array )
newest CaMeL Successful CaMeL Build = new Build CaMeL Info ( newest CaMeL Successful CaMeL Logfile . get CaMeL Name ( ) ) ;  <CTX>  public void set CaMeL Project CaMeL Directory ( File directory ) { File newest CaMeL Logfile = Cru@@ ise CaMeL Control CaMeL Tag CaMeL Support . get CaMeL Latest CaMeL Log CaMeL File ( directory ) ; if ( newest CaMeL Logfile == null ) { newest CaMeL Build = null ; } else { try { newest CaMeL Build = new Build CaMeL Info ( newest CaMeL Logfile . get CaMeL Name ( ) ) ; } catch ( Parse CaMeL Exception pe ) { newest CaMeL Build = null ; } } File newest CaMeL Successful CaMeL Logfile = Cru@@ ise CaMeL Control CaMeL Tag CaMeL Support . get CaMeL Latest CaMeL Successful CaMeL Log CaMeL File ( directory ) ; if ( newest CaMeL Successful CaMeL Logfile == null ) { newest CaMeL Successful CaMeL Build = null ; } else { try { newest CaMeL Successful CaMeL Build = new Build CaMeL Info ( newest CaMeL Successful CaMeL Logfile . get CaMeL Name ( ) ) ; } catch ( Parse CaMeL Exception pe ) { newest CaMeL Build = null ; } } }	newest CaMeL Successful CaMeL Build = new Build CaMeL Info ( newest CaMeL Successful CaMeL Logfile ) ;
Inet CaMeL Address ( byte [ ] address , String hostname )  <CTX>  Inet CaMeL Address ( byte [ ] address , String hostname ) { addr = address ; host CaMeL Name = hostname ; if ( address != null ) family = get CaMeL Family ( address ) ; }	Inet CaMeL Address ( byte [ ] address )
create ( GDK _ WINDOW _ TYPE _ HINT _ DIALOG , true ) ;  <CTX>  void create ( ) { / / Create a decorated dialog window . create ( GDK _ WINDOW _ TYPE _ HINT _ DIALOG , true ) ; Dialog dialog = ( Dialog ) awt CaMeL Component ; gtk CaMeL Window CaMeL Set CaMeL Modal ( dialog . is CaMeL Modal ( ) ) ; set CaMeL Title ( dialog . get CaMeL Title ( ) ) ; set CaMeL Resizable ( dialog . is CaMeL Resizable ( ) ) ; }	create ( GDK _ WINDOW _ TYPE _ HINT _ DIALOG , ! ( ( Dialog ) awt CaMeL Component ) . is CaMeL Undecorated ( ) ) ;
if ( cool CaMeL Bar CaMeL Manager instanceof Cool CaMeL Bar CaMeL Manager ) { return ( ( Cool CaMeL Bar CaMeL Manager ) cool CaMeL Bar CaMeL Manager ) . create CaMeL Control ( composite ) ;  <CTX>  protected Control create CaMeL Cool CaMeL Bar CaMeL Control ( Composite composite ) { if ( cool CaMeL Bar CaMeL Manager instanceof Cool CaMeL Bar CaMeL Manager ) { return ( ( Cool CaMeL Bar CaMeL Manager ) cool CaMeL Bar CaMeL Manager ) . create CaMeL Control ( composite ) ; } return null ; }	if ( cool CaMeL Bar CaMeL Manager != null ) { return cool CaMeL Bar CaMeL Manager . create CaMeL Control ( composite ) ;
catch CaMeL Cond = new Node ( Token CaMeL Stream . PRIMARY , new Integer ( Token CaMeL Stream . TRUE ) ) ;  <CTX>  public Object create CaMeL Catch ( String var CaMeL Name , Object catch CaMeL Cond , Object stmts , int lineno ) { if ( catch CaMeL Cond == null ) catch CaMeL Cond = new Node ( Token CaMeL Stream . PRIMARY , new Integer ( Token CaMeL Stream . TRUE ) ) ; Node result = new Node ( Token CaMeL Stream . CATCH , ( Node ) create CaMeL Name ( var CaMeL Name ) , ( Node ) catch CaMeL Cond , ( Node ) stmts ) ; result . set CaMeL Datum ( new Integer ( lineno ) ) ; return result ; }	catch CaMeL Cond = new Node ( Token CaMeL Stream . PRIMARY , Token CaMeL Stream . TRUE ) ;
File module = module CaMeL Project . get CaMeL File ( ) ;  <CTX>  public String get CaMeL Module CaMeL Path CaMeL Adjustment ( Maven CaMeL Project module CaMeL Project ) throws IO CaMeL Exception { File module = module CaMeL Project . get CaMeL File ( ) ; if ( module == null ) { return null ; } module = module . get CaMeL Canonical CaMeL File ( ) ; if ( module CaMeL Files == null ) { module CaMeL Files = new Hash CaMeL Map ( ) ; List modules = get CaMeL Modules ( ) ; File my CaMeL File = get CaMeL File ( ) ; if ( my CaMeL File != null ) { File my CaMeL Dir = my CaMeL File . get CaMeL Canonical CaMeL File ( ) . get CaMeL Parent CaMeL File ( ) ; if ( modules != null ) { for ( Iterator it = modules . iterator ( ) ; it . has CaMeL Next ( ) ; ) { String module CaMeL Path = ( String ) it . next ( ) ; File module CaMeL File = new File ( my CaMeL Dir , module CaMeL Path ) . get CaMeL Canonical CaMeL File ( ) ; module CaMeL Files . put ( module CaMeL File , module CaMeL Path ) ; } } } } return ( String ) module CaMeL Files . get ( module ) ; }	String module = module CaMeL Project . get CaMeL Artifact CaMeL Id ( ) ;
q . set CaMeL Parameter ( i , query CaMeL Args [ i ] ) ;  <CTX>  public Object do CaMeL In CaMeL Hibernate ( Session session ) throws Hibernate CaMeL Exception , SQL CaMeL Exception { Query q = session . create CaMeL Query ( query ) ; Object [ ] query CaMeL Args = null ; if ( arguments . length > 1 ) { if ( arguments [ 1 ] instanceof List ) { query CaMeL Args = ( ( List ) arguments [ 1 ] ) . to CaMeL Array ( ) ; } else if ( arguments [ 1 ] . get CaMeL Class ( ) . is CaMeL Array ( ) ) { query CaMeL Args = ( Object [ ] ) arguments [ 1 ] ; } } if ( query CaMeL Args != null ) { for ( int i = 0 ; i < query CaMeL Args . length ; i ++ ) { q . set CaMeL Parameter ( i , query CaMeL Args [ i ] ) ; } } / / only want one result , could have used unique CaMeL Object here / / but it throws an exception if its not unique which is / / un@@ desi@@ rable q . set CaMeL Max CaMeL Results ( 1 ) ; List results = q . list ( ) ; if ( results . size ( ) > 0 ) return results . get ( 0 ) ; return null ; }	if ( query CaMeL Args [ 0 ] instanceof G CaMeL String ) { q . set CaMeL Parameter ( i , query CaMeL Args [ i ] . to CaMeL String ( ) ) ; } else { q . set CaMeL Parameter ( i , query CaMeL Args [ i ] ) ; }
return open CaMeL Thumb CaMeL Image ( id , 0 ) . get CaMeL Width ( ) ;  <CTX>  public int get CaMeL Thumb CaMeL Size CaMeL X ( String id ) throws Format CaMeL Exception , IO CaMeL Exception { return open CaMeL Thumb CaMeL Image ( id , 0 ) . get CaMeL Width ( ) ; }	if ( ! id . equals ( current CaMeL Id ) ) init CaMeL File ( id ) ; if ( ifds . length == 1 ) return super . get CaMeL Thumb CaMeL Size CaMeL X ( id ) ; return Tiff CaMeL Tools . get CaMeL IFD CaMeL Int CaMeL Value ( ifds [ 1 ] , Tiff CaMeL Tools . IMAGE _ WIDTH , false , 1 ) ;
result = new Boolean ( true ) ;  <CTX>  public void doit ( ) throws Processing CaMeL Exception { LEAV@@ ES _ COMPO@@ UNDS . get CaMeL Result ( ) ; get CaMeL Glyph CaMeL Inspector ( ) . process CaMeL Un@@ due CaMeL Stems ( ) ; result = new Boolean ( true ) ; get CaMeL Glyph CaMeL Inspector ( ) . evaluate CaMeL Glyphs ( Glyph CaMeL Inspector . get CaMeL Cleanup CaMeL Max CaMeL Grade ( ) ) ; }	result = Boolean . value CaMeL Of ( true ) ;
gd . vertical CaMeL Alignment = gd . BEGINNING ;  <CTX>  protected void do CaMeL Fill CaMeL Into CaMeL Grid ( Composite parent , int num CaMeL Columns ) { Control control = get CaMeL Label CaMeL Control ( parent ) ; Grid CaMeL Data gd = new Grid CaMeL Data ( ) ; gd . horizontal CaMeL Span = num CaMeL Columns ; control . set CaMeL Layout CaMeL Data ( gd ) ; list = get CaMeL List CaMeL Control ( parent ) ; gd = new Grid CaMeL Data ( Grid CaMeL Data . FILL _ HORIZONTAL ) ; gd . vertical CaMeL Alignment = gd . FILL ; gd . horizontal CaMeL Span = num CaMeL Columns - 1 ; gd . grab CaMeL Excess CaMeL Horizontal CaMeL Space = true ; list . set CaMeL Layout CaMeL Data ( gd ) ; button CaMeL Box = get CaMeL Button CaMeL Box CaMeL Control ( parent ) ; gd = new Grid CaMeL Data ( ) ; gd . vertical CaMeL Alignment = gd . BEGINNING ; button CaMeL Box . set CaMeL Layout CaMeL Data ( gd ) ; }	gd . vertical CaMeL Alignment = Grid CaMeL Data . BEGINNING ;
if ( element . is CaMeL Populated ( ) ) return get CaMeL Children ( element ) . length > 0 ; else {  <CTX>  public boolean has CaMeL Children ( Object o ) { if ( o instanceof Minimized CaMeL File CaMeL System CaMeL Element ) { Minimized CaMeL File CaMeL System CaMeL Element element = ( Minimized CaMeL File CaMeL System CaMeL Element ) o ; if ( element . is CaMeL Populated ( ) ) return get CaMeL Children ( element ) . length > 0 ; else { / / If we have not populated then wait until asked return true ; } } return false ; }	if ( element . is CaMeL Populated ( ) ) { return get CaMeL Children ( element ) . length > 0 ; } else {
return _ parent [ node ] ;  <CTX>  public int next ( ) { int node ; while ( ( node = _ source . next ( ) ) != END ) { String val = get CaMeL Node CaMeL Value ( node ) ; if ( _ value . equals ( val ) == _ op ) { return _ parent [ node ] ; } } return END ; }	if ( _ return CaMeL Type == RETURN _ CURRENT ) return return CaMeL Node ( node ) ; else return return CaMeL Node ( _ parent [ node ] ) ;
context . finish CaMeL Process ( context . get CaMeL Current CaMeL Process ( ) ) ; } else { context . enter CaMeL State ( destination ) ;  <CTX>  protected void follow CaMeL Transition ( Process CaMeL Context context , Transition transition ) throws Invalid CaMeL Motion CaMeL Exception { State destination = transition . get CaMeL Destination ( ) ; context . exit CaMeL State ( context . get CaMeL Current CaMeL State ( ) ) ; if ( destination == null ) { context . finish CaMeL Process ( context . get CaMeL Current CaMeL Process ( ) ) ; } else { context . enter CaMeL State ( destination ) ; } }	location . finish CaMeL Process ( context . get CaMeL Current CaMeL Process ( ) ) ;
Parsed CaMeL Class CaMeL Type create CaMeL Class CaMeL Type ( ) ;  <CTX>  Parsed CaMeL Class CaMeL Type create CaMeL Class CaMeL Type ( ) ;	Parsed CaMeL Class CaMeL Type create CaMeL Class CaMeL Type ( Lazy CaMeL Class CaMeL Initializer init ) ;
if ( ! can CaMeL Select || selected CaMeL Column CaMeL Name != null )  <CTX>  private void update CaMeL Buttons ( ) { boolean ok CaMeL Enable = false ; if ( ! can CaMeL Select || selected CaMeL Column CaMeL Name != null ) { ok CaMeL Enable = true ; } get CaMeL Ok CaMeL Button ( ) . set CaMeL Enabled ( ok CaMeL Enable ) ; int min = 0 ; int max = binding CaMeL Table . get CaMeL Table ( ) . get CaMeL Item CaMeL Count ( ) - 1 ; if ( ( min <= select CaMeL Index ) && ( select CaMeL Index <= max ) ) { btn CaMeL Del . set CaMeL Enabled ( true ) ; if ( btn CaMeL Edit != null ) btn CaMeL Edit . set CaMeL Enabled ( true ) ; } else { btn CaMeL Del . set CaMeL Enabled ( false ) ; if ( btn CaMeL Edit != null ) btn CaMeL Edit . set CaMeL Enabled ( false ) ; } binding CaMeL Table . get CaMeL Table ( ) . select ( select CaMeL Index ) ; }	if ( ! can CaMeL Select || ( selected CaMeL Column CaMeL Name != null && get CaMeL Data CaMeL Set CaMeL Name ( ) != null ) )
j@@ si . its CaMeL Data = new Interpreter CaMeL Data ( its CaMeL Data . security CaMeL Domain , its CaMeL Data . language CaMeL Version ) ; j@@ si . its CaMeL Data . parent CaMeL Data = its CaMeL Data ; j@@ si . its CaMeL Data . its CaMeL Source CaMeL File = its CaMeL Data . its CaMeL Source CaMeL File ; j@@ si . its CaMeL Data . encoded CaMeL Source = its CaMeL Data . encoded CaMeL Source ;  <CTX>  private void generate CaMeL Nested CaMeL Functions ( Context cx ) { int function CaMeL Count = script CaMeL Or CaMeL Fn . get CaMeL Function CaMeL Count ( ) ; if ( function CaMeL Count == 0 ) return ; Interpreter CaMeL Data [ ] array = new Interpreter CaMeL Data [ function CaMeL Count ] ; for ( int i = 0 ; i != function CaMeL Count ; i ++ ) { Function CaMeL Node def = script CaMeL Or CaMeL Fn . get CaMeL Function CaMeL Node ( i ) ; Interpreter j@@ si = new Interpreter ( ) ; j@@ si . compiler CaMeL Env = compiler CaMeL Env ; j@@ si . script CaMeL Or CaMeL Fn = def ; j@@ si . its CaMeL Data = new Interpreter CaMeL Data ( its CaMeL Data . security CaMeL Domain , its CaMeL Data . language CaMeL Version ) ; j@@ si . its CaMeL Data . parent CaMeL Data = its CaMeL Data ; j@@ si . its CaMeL Data . its CaMeL Source CaMeL File = its CaMeL Data . its CaMeL Source CaMeL File ; j@@ si . its CaMeL Data . encoded CaMeL Source = its CaMeL Data . encoded CaMeL Source ; j@@ si . its CaMeL Data . its CaMeL Check CaMeL This = def . get CaMeL Check CaMeL This ( ) ; j@@ si . its CaMeL In CaMeL Function CaMeL Flag = true ; j@@ si . generate CaMeL Function CaMeL I CaMeL Code ( cx ) ; array [ i ] = j@@ si . its CaMeL Data ; } its CaMeL Data . its CaMeL Nested CaMeL Functions = array ; }	j@@ si . its CaMeL Data = new Interpreter CaMeL Data ( its CaMeL Data ) ;
( ( Opt CaMeL Local CaMeL Variable ) the CaMeL Variables . get ( i ) ) . assign CaMeL Type ( Type CaMeL Event . Any CaMeL Type ) ;  <CTX>  void mark CaMeL Any CaMeL Type CaMeL Variables ( Variable CaMeL Table the CaMeL Variables ) { for ( int i = 0 ; i < the CaMeL Variables . size ( ) ; i ++ ) if ( its CaMeL Live CaMeL On CaMeL Entry CaMeL Set . test ( i ) ) ( ( Opt CaMeL Local CaMeL Variable ) the CaMeL Variables . get ( i ) ) . assign CaMeL Type ( Type CaMeL Event . Any CaMeL Type ) ; }	( ( Opt CaMeL Local CaMeL Variable ) the CaMeL Variables . get CaMeL Variable ( i ) ) . assign CaMeL Type ( Type CaMeL Event . Any CaMeL Type ) ;
this ( source , id , when , modifiers , key CaMeL Code , key CaMeL Char , KEY _ LOCATION _ UNKNOWN ) ;  <CTX>  public Key CaMeL Event ( Component source , int id , long when , int modifiers , int key CaMeL Code , char key CaMeL Char ) { this ( source , id , when , modifiers , key CaMeL Code , key CaMeL Char , KEY _ LOCATION _ UNKNOWN ) ; }	super ( source , id , when , modifiers ) ; this . key CaMeL Code = key CaMeL Code ; this . key CaMeL Char = key CaMeL Char ; this . key CaMeL Location = key CaMeL Location ; if ( ( id == KEY _ TYPED && ( key CaMeL Code != VK _ UNDEFINED || key CaMeL Char == CHAR _ UNDEFINED ) ) || key CaMeL Location < KEY _ LOCATION _ UNKNOWN || key CaMeL Location > KEY _ LOCATION _ NUMPAD ) throw new Illegal CaMeL Argument CaMeL Exception ( ) ;
return Ruby CaMeL Fixnum . new CaMeL Fixnum ( runtime , id ) ;  <CTX>  public Ruby CaMeL Fixnum to _ i ( ) { return Ruby CaMeL Fixnum . new CaMeL Fixnum ( runtime , id ) ; }	return get CaMeL Runtime ( ) . new CaMeL Fixnum ( id ) ;
return readers [ index ] . get CaMeL Size CaMeL Z ( id ) ;  <CTX>  public int get CaMeL Size CaMeL Z ( String id ) throws Format CaMeL Exception , IO CaMeL Exception { if ( ! id . equals ( current CaMeL Id ) ) init CaMeL File ( id ) ; return readers [ index ] . get CaMeL Size CaMeL Z ( id ) ; }	return readers [ current ] . get CaMeL Size CaMeL Z ( id ) ;
return Notation CaMeL Package . e CaMeL INSTANCE . get CaMeL Image CaMeL Style ( ) ; }  <CTX>  protected E CaMeL Class e CaMeL Static CaMeL Class ( ) { return Notation CaMeL Package . e CaMeL INSTANCE . get CaMeL Image CaMeL Style ( ) ; }	return Notation CaMeL Package . Literals . IMAGE _ STYLE ; }
if ( value instanceof Integer )  <CTX>  protected Object get CaMeL Distinct CaMeL Color CaMeL Property ( Design CaMeL Element CaMeL Handle handle , Design CaMeL Element CaMeL Handle parent CaMeL Handle , String name ) { Object value ; Object parent CaMeL Value ; value = handle . get CaMeL Property ( name ) ; parent CaMeL Value = parent CaMeL Handle . get CaMeL Property ( name ) ; boolean can CaMeL Inherit = Style CaMeL Design . can CaMeL Inherit ( name ) ; int int CaMeL Value = get CaMeL Color CaMeL Value ( value ) ; if ( value != null && ( ! can CaMeL Inherit || int CaMeL Value != get CaMeL Color CaMeL Value ( parent CaMeL Value ) ) && ( can CaMeL Inherit || int CaMeL Value != get CaMeL Color CaMeL Value ( Style CaMeL Design . get CaMeL Default CaMeL Value ( name ) ) ) ) { if ( value instanceof Integer ) { return String CaMeL Util . to CaMeL Rgb CaMeL Text ( int CaMeL Value ) ; } return value ; } return null ; }	int parent CaMeL Value = get CaMeL Color CaMeL Value ( parent CaMeL Handle . get CaMeL Property ( name ) ) ; if ( int CaMeL Value != parent CaMeL Value )
a CaMeL Dialog . show ( ) ;  <CTX>  public void action CaMeL Performed ( Action CaMeL Event e ) { Search CaMeL Directory CaMeL Dialog a CaMeL Dialog = new Search CaMeL Directory CaMeL Dialog ( get CaMeL Parent CaMeL Frame ( ) ) ; / / display the new card dialog a CaMeL Dialog . show ( ) ; a CaMeL Dialog . dispose ( ) ; }	a CaMeL Dialog . set CaMeL Visible ( true ) ;
if ( get CaMeL Control ( ) != null ) return ;  <CTX>  public void create CaMeL Control ( Composite parent ) { if ( get CaMeL Control ( ) != null ) return ; part CaMeL Reference . add CaMeL Property CaMeL Listener ( this ) ; / / Create view form . control = new Composite ( parent , SWT . NONE ) ; control . set CaMeL Layout ( new Fill CaMeL Layout ( ) ) ; / / the part should never be visible by default . It will be made visible / / by activation . This allows us to have views app@@ ear in tabs without / / bec@@ om@@ ing active by default . control . set CaMeL Visible ( false ) ; control . move CaMeL Above ( null ) ; / / Create a title bar . create CaMeL Title CaMeL Bar ( ) ; / / When the pane or any child gains focus , notify the workbench . control . add CaMeL Listener ( SWT . Activate , this ) ; control . add CaMeL Traverse CaMeL Listener ( traverse CaMeL Listener ) ; }	if ( get CaMeL Control ( ) != null ) { return ; }
Object instance = ( ( Native CaMeL Java CaMeL Object ) value ) . unwrap ( ) ;  <CTX>  public boolean has CaMeL Instance ( Scriptable value ) { if ( ! ( value instanceof Native CaMeL Java CaMeL Object ) ) return false ; Object instance = ( ( Native CaMeL Java CaMeL Object ) value ) . unwrap ( ) ; return cls . is CaMeL Instance ( instance ) ; }	Object instance = ( ( Wrapper ) value ) . unwrap ( ) ;
row CaMeL Data [ i ] = new Col CaMeL Data ( Tds CaMeL Data . read CaMeL Data ( in , columns [ i ] , read CaMeL Text CaMeL Mode ) , tds CaMeL Version ) ;  <CTX>  private void tds CaMeL Row CaMeL Token ( ) throws IO CaMeL Exception , Protocol CaMeL Exception { for ( int i = 0 ; i < columns . length ; i ++ ) { row CaMeL Data [ i ] = new Col CaMeL Data ( Tds CaMeL Data . read CaMeL Data ( in , columns [ i ] , read CaMeL Text CaMeL Mode ) , tds CaMeL Version ) ; } read CaMeL Text CaMeL Mode = false ; }	row CaMeL Data [ i ] = new Col CaMeL Data ( Tds CaMeL Data . read CaMeL Data ( connection , in , columns [ i ] , read CaMeL Text CaMeL Mode ) , tds CaMeL Version ) ;
result . add CaMeL Child CaMeL After ( incr CaMeL Target , body ) ;  <CTX>  private Node create CaMeL Loop ( int loop CaMeL Type , Node body , Node cond , Node init , Node incr , int lineno ) { Node . Target body CaMeL Target = new Node . Target ( ) ; Node . Target cond CaMeL Target = new Node . Target ( ) ; if ( loop CaMeL Type == LOOP _ FOR && cond . get CaMeL Type ( ) == Token . EMPTY ) { cond = new Node ( Token . TRUE ) ; } Node . Jump IFEQ = new Node . Jump ( Token . IFEQ , cond ) ; IFEQ . target = body CaMeL Target ; Node . Target break CaMeL Target = new Node . Target ( ) ; Node . Jump result = new Node . Jump ( Token . LOOP , lineno ) ; result . add CaMeL Child CaMeL To CaMeL Back ( body CaMeL Target ) ; result . add CaMeL Children CaMeL To CaMeL Back ( body ) ; if ( loop CaMeL Type == LOOP _ WHILE || loop CaMeL Type == LOOP _ FOR ) { / / propagate lineno to condition result . add CaMeL Children CaMeL To CaMeL Back ( new Node ( Token . EMPTY , lineno ) ) ; } result . add CaMeL Child CaMeL To CaMeL Back ( cond CaMeL Target ) ; result . add CaMeL Child CaMeL To CaMeL Back ( IFEQ ) ; result . add CaMeL Child CaMeL To CaMeL Back ( break CaMeL Target ) ; result . target = break CaMeL Target ; Node . Target continue CaMeL Target = cond CaMeL Target ; if ( loop CaMeL Type == LOOP _ WHILE || loop CaMeL Type == LOOP _ FOR ) { / / Just add a GOTO to the condition in the do . . while Node . Jump GOTO = new Node . Jump ( Token . GOTO ) ; GOTO . target = cond CaMeL Target ; result . add CaMeL Child CaMeL To CaMeL Front ( GOTO ) ; if ( loop CaMeL Type == LOOP _ FOR ) { if ( init . get CaMeL Type ( ) != Token . EMPTY ) { if ( init . get CaMeL Type ( ) != Token . VAR ) { init = new Node ( Token . EXPR _ VOID , init ) ; } result . add CaMeL Child CaMeL To CaMeL Front ( init ) ; } Node . Target incr CaMeL Target = new Node . Target ( ) ; result . add CaMeL Child CaMeL After ( incr CaMeL Target , body ) ; if ( incr . get CaMeL Type ( ) != Token . EMPTY ) { incr = new Node ( Token . EXPR _ VOID , incr ) ; result . add CaMeL Child CaMeL After ( incr , incr CaMeL Target ) ; } continue CaMeL Target = incr CaMeL Target ; } } result . set CaMeL Continue ( continue CaMeL Target ) ; return result ; }	loop . add CaMeL Child CaMeL After ( incr CaMeL Target , body ) ;
Render CaMeL Internal ( rw ) ;  <CTX>  public synchronized void Render ( ) { if ( ! rendering ) { rendering = true ; if ( ren . Visible CaMeL Actor CaMeL Count ( ) == 0 ) return ; if ( rw != null ) { if ( window@@ set == 0 ) { / / set the window id and the active camera cam = ren . Get CaMeL Active CaMeL Camera ( ) ; ren . Add CaMeL Light ( lgt ) ; lgt . Set CaMeL Position ( cam . Get CaMeL Position ( ) ) ; lgt . Set CaMeL Focal CaMeL Point ( cam . Get CaMeL Focal CaMeL Point ( ) ) ; Render CaMeL Create ( rw ) ; window@@ set = 1 ; } Render CaMeL Internal ( rw ) ; rendering = false ; } } }	Lock ( ) ; rw . Render ( ) ; Un CaMeL Lock ( ) ;
return Java CaMeL Util . convert CaMeL Java CaMeL To CaMeL Ruby ( ruby , proc . call ( Java CaMeL Util . convert CaMeL Java CaMeL To CaMeL Ruby ( ruby , args ) ) ) ;  <CTX>  public Object invoke ( Object recv , Method imethod , Object [ ] args ) { return Java CaMeL Util . convert CaMeL Java CaMeL To CaMeL Ruby ( ruby , proc . call ( Java CaMeL Util . convert CaMeL Java CaMeL To CaMeL Ruby ( ruby , args ) ) ) ; }	return Java CaMeL Util . convert CaMeL Java CaMeL To CaMeL Ruby ( ruby , proc . call ( Java CaMeL Util . convert CaMeL Java CaMeL Array CaMeL To CaMeL Ruby ( ruby , args ) ) ) ;
return Data CaMeL Package . e CaMeL INSTANCE . get CaMeL Number CaMeL Data CaMeL Element ( ) ;  <CTX>  protected E CaMeL Class e CaMeL Static CaMeL Class ( ) { return Data CaMeL Package . e CaMeL INSTANCE . get CaMeL Number CaMeL Data CaMeL Element ( ) ; }	return Data CaMeL Package . Literals . NUMBER _ DATA _ ELEMENT ;
if ( has CaMeL Been CaMeL Seen ( ) ) { return Browser CaMeL Constants . Default CaMeL Font ; }  <CTX>  public Font get CaMeL Text CaMeL Font ( ) { if ( has CaMeL Been CaMeL Seen ( ) ) { return Browser CaMeL Constants . Default CaMeL Font ; } else { return Browser CaMeL Constants . Default CaMeL Font CaMeL Bold ; } }	if ( is CaMeL Seen ( ) ) { return Browser CaMeL Constants . Default CaMeL Font ; }
throw XMPP CaMeL Error CaMeL Translator . translate ( iox ) ;  <CTX>  public void send ( final Container CaMeL Version container , final Map < Document CaMeL Version , Input CaMeL Stream > documents , final List < Jabber CaMeL Id > send CaMeL To , final Jabber CaMeL Id sent CaMeL By , final Calendar sent CaMeL On ) throws Smack CaMeL Exception { try { xmpp CaMeL Container . send ( container , documents , send CaMeL To , sent CaMeL By , sent CaMeL On ) ; } catch ( final IO CaMeL Exception iox ) { throw XMPP CaMeL Error CaMeL Translator . translate ( iox ) ; } }	throw translate CaMeL Error ( iox ) ;
Rectangle new CaMeL Bounds = Geometry . get CaMeL Extru@@ ded CaMeL Edge ( bounds , - S@@ ASH _ SIZE , opposite CaMeL Side ) ;  <CTX>  private void update CaMeL Fast CaMeL View CaMeL Sash CaMeL Bounds ( Rectangle bounds ) { int opposite CaMeL Side = Geometry . get CaMeL Opposite CaMeL Side ( side ) ; Rectangle new CaMeL Bounds = Geometry . get CaMeL Extru@@ ded CaMeL Edge ( bounds , - S@@ ASH _ SIZE , opposite CaMeL Side ) ; fast CaMeL View CaMeL Sash . set CaMeL Bounds ( new CaMeL Bounds ) ; fast CaMeL View CaMeL Sash . move CaMeL Above ( null ) ; }	Rectangle new CaMeL Bounds = Geometry . get CaMeL Extru@@ ded CaMeL Edge ( bounds , S@@ ASH _ SIZE , opposite CaMeL Side ) ;
return get CaMeL Editors ( filename , null ) ;  <CTX>  public I CaMeL Editor CaMeL Descriptor [ ] get CaMeL Editors ( String filename ) { return get CaMeL Editors ( filename , null ) ; }	return get CaMeL Editors ( filename , guess CaMeL At CaMeL Content CaMeL Type ( filename ) ) ;
return ( m _ action CaMeL Errors != null ) && ! m _ action CaMeL Errors . is CaMeL Empty ( ) ;  <CTX>  public synchronized boolean has CaMeL Action CaMeL Errors ( ) { return ( m _ action CaMeL Errors != null ) && ! m _ action CaMeL Errors . is CaMeL Empty ( ) ; }	return ( action CaMeL Errors != null ) && ! action CaMeL Errors . is CaMeL Empty ( ) ;
with CaMeL Single CaMeL Threaded CaMeL Workaround CaMeL Do ( display CaMeL On CaMeL Event CaMeL Dispatch CaMeL Thread CaMeL Action , display CaMeL Action , false ) ;  <CTX>  public void display ( ) { with CaMeL Single CaMeL Threaded CaMeL Workaround CaMeL Do ( display CaMeL On CaMeL Event CaMeL Dispatch CaMeL Thread CaMeL Action , display CaMeL Action , false ) ; }	maybe CaMeL Do CaMeL Single CaMeL Threaded CaMeL Workaround ( display CaMeL On CaMeL Event CaMeL Dispatch CaMeL Thread CaMeL Action , display CaMeL Action , false ) ;
interval CaMeL Base CaMeL Text . set CaMeL Enabled ( interval CaMeL Base CaMeL Button . get CaMeL Selection ( ) ) ;  <CTX>  public void widget CaMeL Selected ( Selection CaMeL Event e ) { interval CaMeL Base CaMeL Text . set CaMeL Enabled ( interval CaMeL Base CaMeL Button . get CaMeL Selection ( ) ) ; }	interval CaMeL Range . set CaMeL Enabled ( interval CaMeL Type . get CaMeL Selection CaMeL Index ( ) != 0 ) ; interval CaMeL Base CaMeL Button . set CaMeL Enabled ( interval CaMeL Type . get CaMeL Selection CaMeL Index ( ) != 0 && ( get CaMeL Column CaMeL Type ( ) != String . class ) ) ; interval CaMeL Base CaMeL Text . set CaMeL Enabled ( interval CaMeL Base CaMeL Button . get CaMeL Enabled ( ) && interval CaMeL Base CaMeL Button . get CaMeL Selection ( ) ) ;
else {  <CTX>  void consume CaMeL Excludes ( I CaMeL Configuration CaMeL Element element ) { Assert . is CaMeL True ( Navigator CaMeL Viewer CaMeL Descriptor . TAG _ EXCLUDES . equals ( element . get CaMeL Name ( ) ) ) ; I CaMeL Configuration CaMeL Element [ ] content CaMeL Extension CaMeL Patterns = element . get CaMeL Children ( TAG _ EXTENSION ) ; String pattern CaMeL String = null ; Pattern compiled CaMeL Pattern = null ; for ( int i = 0 ; i < content CaMeL Extension CaMeL Patterns . length ; i ++ ) { pattern CaMeL String = content CaMeL Extension CaMeL Patterns [ i ] . get CaMeL Attribute ( Navigator CaMeL Viewer CaMeL Descriptor . ATT _ PATTERN ) ; if ( pattern CaMeL String == null ) Navigator CaMeL Plugin . log CaMeL Error ( 0 , NLS . bind ( Common CaMeL Navigator CaMeL Messages . Attribute _ Missing _ Warning , new Object [ ] { Navigator CaMeL Viewer CaMeL Descriptor . ATT _ PATTERN , element . get CaMeL Declaring CaMeL Extension ( ) . get CaMeL Unique CaMeL Identifier ( ) , element . get CaMeL Declaring CaMeL Extension ( ) . get CaMeL Namespace ( ) } ) , null ) ; else { compiled CaMeL Pattern = Pattern . compile ( pattern CaMeL String ) ; exclude CaMeL Patterns . add ( compiled CaMeL Pattern ) ; } } }	} else {
Container CaMeL Transaction CaMeL Context ctx = prepare CaMeL Existing CaMeL B CaMeL New CaMeL A ( ) ;  <CTX>  public void test CaMeL B CaMeL Set CaMeL A CaMeL Existing CaMeL B CaMeL New CaMeL A ( ) throws Exception { Container CaMeL Transaction CaMeL Context ctx = prepare CaMeL Existing CaMeL B CaMeL New CaMeL A ( ) ; b . set CaMeL A ( a ) ; ctx . commit ( ) ; assert CaMeL State CaMeL Existing CaMeL B CaMeL New CaMeL A ( ) ; }	Transaction CaMeL Context ctx = prepare CaMeL Existing CaMeL B CaMeL New CaMeL A ( ) ;
new CaMeL X = check CaMeL Bounds ( new CaMeL X , m _ original CaMeL Image . get CaMeL Width ( this ) , this . get CaMeL Width ( ) ) ;  <CTX>  protected void set CaMeL Top CaMeL Left ( int x , int y ) { int new CaMeL X = x ; new CaMeL X = check CaMeL Bounds ( new CaMeL X , m _ original CaMeL Image . get CaMeL Width ( this ) , this . get CaMeL Width ( ) ) ; int new CaMeL Y = y ; new CaMeL Y = check CaMeL Bounds ( new CaMeL Y , m _ original CaMeL Image . get CaMeL Height ( this ) , this . get CaMeL Height ( ) ) ; set CaMeL Coords ( new CaMeL X , new CaMeL Y ) ; m _ control . set CaMeL Large CaMeL Coords ( new CaMeL X , new CaMeL Y ) ; }	new CaMeL X = check CaMeL Bounds ( new CaMeL X , m _ original CaMeL Image . get CaMeL Width ( this ) , this . get CaMeL Width ( ) , true ) ;
m _ inspection CaMeL Classes . add ( Unnecessary CaMeL Interface CaMeL Modifier CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Unnecessary CaMeL Enum CaMeL Modifier CaMeL Inspection . class ) ;  <CTX>  private void register CaMeL Verbose CaMeL Inspections ( ) { m _ inspection CaMeL Classes . add ( Unnecessary CaMeL Label CaMeL On CaMeL Break CaMeL Statement CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Unnecessary CaMeL Label CaMeL On CaMeL Continue CaMeL Statement CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Point@@ less CaMeL Boolean CaMeL Expression CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Replace CaMeL Assignment CaMeL With CaMeL Operator CaMeL Assignment CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Trivial CaMeL If CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Unnecessary CaMeL Conditional CaMeL Expression CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Constant CaMeL Conditional CaMeL Expression CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Constant CaMeL If CaMeL Statement CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Unnecessary CaMeL Parentheses CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Unnecessary CaMeL Local CaMeL Variable CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Unnecessary CaMeL This CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Unnecessary CaMeL Block CaMeL Statement CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Unnecessary CaMeL Interface CaMeL Modifier CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Unnecessary CaMeL Enum CaMeL Modifier CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Unnecessary CaMeL Return CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Unnecessary CaMeL Continue CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Unnecessary CaMeL Semicolon CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Unnecessary CaMeL Fully CaMeL Qualified CaMeL Name CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Unnecessary CaMeL Qualifier CaMeL For CaMeL This CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Unused CaMeL Label CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Redundant CaMeL Field CaMeL Initialization CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Redundant CaMeL Implements CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Extends CaMeL Object CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Type CaMeL Parameter CaMeL Extends CaMeL Object CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Point@@ less CaMeL Arithmetic CaMeL Expression CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Point@@ less CaMeL Bitwise CaMeL Expression CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Unnecessary CaMeL Super CaMeL Constructor CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Unnecessary CaMeL Constructor CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( For CaMeL Loop CaMeL Replaceable CaMeL By CaMeL While CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Unnecessary CaMeL Default CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Unnecessary CaMeL Boxing CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Unnecessary CaMeL Unboxing CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Unnecessary CaMeL Final CaMeL On CaMeL Parameter CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( Unnecessary CaMeL Final CaMeL On CaMeL Local CaMeL Variable CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( For CaMeL Can CaMeL Be CaMeL Foreach CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( While CaMeL Can CaMeL Be CaMeL Foreach CaMeL Inspection . class ) ; }	m _ inspection CaMeL Classes . add ( com . si@@ y@@ eh . ig . verbose . Unnecessary CaMeL Interface CaMeL Modifier CaMeL Inspection . class ) ; m _ inspection CaMeL Classes . add ( com . si@@ y@@ eh . ig . verbose . Unnecessary CaMeL Enum CaMeL Modifier CaMeL Inspection . class ) ;
get CaMeL File CaMeL Name CaMeL From CaMeL Jar CaMeL File ( jar ) ) ;  <CTX>  protected void ok CaMeL Pressed ( ) { Utility . set CaMeL Preference CaMeL Stored CaMeL Map ( Jdbc CaMeL Plugin . JAR _ MAP _ PREFERENCE _ KEY , jar CaMeL Map ) ; Utility . set CaMeL Preference CaMeL Stored CaMeL Map ( Jdbc CaMeL Plugin . DRIVER _ MAP _ PREFERENCE _ KEY , driver CaMeL Map ) ; for ( int i = 0 ; i < jars CaMeL To CaMeL Be CaMeL Copied . size ( ) ; i ++ ) { Jar CaMeL File jar = ( Jar CaMeL File ) jars CaMeL To CaMeL Be CaMeL Copied . get ( i ) ; jar . copy CaMeL Jar CaMeL To CaMeL ODA CaMeL Dir ( ) ; Utility . remove CaMeL Map CaMeL Entry CaMeL From CaMeL Preference CaMeL Stored CaMeL Map ( Jdbc CaMeL Plugin . DELETED _ JAR _ MAP _ PREFERENCE _ KEY , get CaMeL File CaMeL Name CaMeL From CaMeL Jar CaMeL File ( jar ) ) ; } for ( int i = 0 ; i < jars CaMeL To CaMeL Be CaMeL Deleted . size ( ) ; i ++ ) { Jar CaMeL File jar = ( Jar CaMeL File ) jars CaMeL To CaMeL Be CaMeL Deleted . get ( i ) ; jar . delete CaMeL Jar CaMeL From CaMeL ODA CaMeL Dir ( ) ; Utility . put CaMeL Preference CaMeL Stored CaMeL Map CaMeL Value ( Jdbc CaMeL Plugin . DELETED _ JAR _ MAP _ PREFERENCE _ KEY , get CaMeL File CaMeL Name CaMeL From CaMeL Jar CaMeL File ( jar ) , jar ) ; } refresh CaMeL Driver CaMeL Page ( ) ; super . ok CaMeL Pressed ( ) ; }	jar . get CaMeL File CaMeL Name ( ) ) ;
return ( Symbol CaMeL Table ) package CaMeL Table . get ( name ) ;  <CTX>  public static Symbol CaMeL Table make ( String name ) { return ( Symbol CaMeL Table ) package CaMeL Table . get ( name ) ; }	Symbol CaMeL Table p = ( Symbol CaMeL Table ) package CaMeL Table . get ( name ) ; if ( p == null ) { p = new Symbol CaMeL Table ( ) ; p . set CaMeL Name ( name ) ; package CaMeL Table . put ( name , p ) ; } return p ;
if ( is CaMeL Compatible CaMeL Class ( param CaMeL Types [ i ] , arguments [ i ] , include CaMeL Coerce ) ) continue ;  <CTX>  public static boolean is CaMeL Valid CaMeL Method ( Class [ ] param CaMeL Types , Class [ ] arguments , boolean include CaMeL Coerce ) { if ( arguments == null ) { return true ; } int size = arguments . length ; if ( ( size >= param CaMeL Types . length || size == param CaMeL Types . length - 1 ) && param CaMeL Types . length > 0 && param CaMeL Types [ param CaMeL Types . length - 1 ] . is CaMeL Array ( ) ) { / / first check normal number of parameters for ( int i = 0 ; i < param CaMeL Types . length - 1 ; i ++ ) { if ( is CaMeL Compatible CaMeL Class ( param CaMeL Types [ i ] , arguments [ i ] , include CaMeL Coerce ) ) continue ; return false ; } / / check v@@ arg@@ ed Class clazz = param CaMeL Types [ param CaMeL Types . length - 1 ] . get CaMeL Component CaMeL Type ( ) ; for ( int i = param CaMeL Types . length ; i < size ; i ++ ) { if ( is CaMeL Compatible CaMeL Class ( clazz , arguments [ i ] , include CaMeL Coerce ) ) continue ; return false ; } return true ; } else if ( param CaMeL Types . length == size ) { / / lets check the parameter types match for ( int i = 0 ; i < size ; i ++ ) { if ( is CaMeL Compatible CaMeL Class ( param CaMeL Types [ i ] , arguments [ i ] , include CaMeL Coerce ) ) continue ; return false ; } return true ; } else if ( param CaMeL Types . length == 1 && size == 0 ) { return true ; } return false ; }	if ( is CaMeL Assignable CaMeL From ( param CaMeL Types [ i ] , arguments [ i ] ) ) continue ;
return small CaMeL Fix CaMeL Nums [ ( int ) ival - min CaMeL Fix CaMeL Num ] ;  <CTX>  private Big CaMeL Integer canonicalize ( ) { if ( words != null && ( ival = Big CaMeL Integer . words CaMeL Needed ( words , ival ) ) <= 1 ) { if ( ival == 1 ) ival = words [ 0 ] ; words = null ; } if ( words == null && ival >= min CaMeL Fix CaMeL Num && ival <= max CaMeL Fix CaMeL Num ) return small CaMeL Fix CaMeL Nums [ ( int ) ival - min CaMeL Fix CaMeL Num ] ; return this ; }	return small CaMeL Fix CaMeL Nums [ ival - min CaMeL Fix CaMeL Num ] ;
initialize CaMeL Path ( p _ path ) ;  <CTX>  public void set CaMeL Path ( String p _ path ) throws Malformed CaMeL URI CaMeL Exception { if ( p _ path == null ) { m _ path = null ; m _ query CaMeL String = null ; m _ fragment = null ; } else { initialize CaMeL Path ( p _ path ) ; } }	initialize CaMeL Path ( p _ path , 0 ) ;
return ( I CaMeL Compilation CaMeL Unit ) cu . get CaMeL Original ( cu ) ; return cu ;  <CTX>  public static I CaMeL Compilation CaMeL Unit to CaMeL Original ( I CaMeL Compilation CaMeL Unit cu ) { if ( cu != null && cu . is CaMeL Working CaMeL Copy ( ) ) return ( I CaMeL Compilation CaMeL Unit ) cu . get CaMeL Original ( cu ) ; return cu ; }	return ( I CaMeL Member ) cu . get CaMeL Original ( member ) ; return member ;
Node CaMeL Identification CaMeL Service nis = ( Node CaMeL Identification CaMeL Service ) service CaMeL Broker . get CaMeL Service (  <CTX>  protected Servlet create CaMeL Servlet ( ) { Agent CaMeL Identification CaMeL Service ais = ( Agent CaMeL Identification CaMeL Service ) service CaMeL Broker . get CaMeL Service ( this , Agent CaMeL Identification CaMeL Service . class , null ) ; if ( ais != null ) { this . agent CaMeL Id = ais . get CaMeL Message CaMeL Address ( ) ; service CaMeL Broker . release CaMeL Service ( this , Agent CaMeL Identification CaMeL Service . class , ais ) ; } Node CaMeL Identification CaMeL Service nis = ( Node CaMeL Identification CaMeL Service ) service CaMeL Broker . get CaMeL Service ( this , Node CaMeL Identification CaMeL Service . class , null ) ; if ( nis != null ) { this . node CaMeL Id = nis . get CaMeL Message CaMeL Address ( ) ; service CaMeL Broker . release CaMeL Service ( this , Node CaMeL Identification CaMeL Service . class , nis ) ; } return new My CaMeL Servlet ( ) ; }	/ * Node CaMeL Identification CaMeL Service nis = ( Node CaMeL Identification CaMeL Service ) service CaMeL Broker . get CaMeL Service (
if ( is CaMeL Referenced ( n ) ) { String combined = combine ( n ) ;  <CTX>  private void delete ( Osm CaMeL Primitive osm ) { if ( osm instanceof Node ) { Node n = ( Node ) osm ; if ( is CaMeL Referenced ( n ) ) { String combined = combine ( n ) ; if ( combined != null ) { J CaMeL Option CaMeL Pane . show CaMeL Message CaMeL Dialog ( Main . main , combined ) ; return ; } } / / now , the node is@@ n t referenced any@@ more , so delete it . ds . nodes . remove ( n ) ; } else if ( osm instanceof Line CaMeL Segment ) { Linked CaMeL List < Track > tracks CaMeL To CaMeL Delete = new Linked CaMeL List < Track > ( ) ; for ( Track t : ds . tracks ( ) ) { t . remove ( ( Line CaMeL Segment ) osm ) ; if ( t . segments ( ) . is CaMeL Empty ( ) ) tracks CaMeL To CaMeL Delete . add ( t ) ; } for ( Track t : tracks CaMeL To CaMeL Delete ) ds . remove CaMeL Track ( t ) ; ds . destroy CaMeL Pending CaMeL Line CaMeL Segment ( ( Line CaMeL Segment ) osm ) ; } else if ( osm instanceof Track ) { ds . remove CaMeL Track ( ( Track ) osm ) ; for ( Line CaMeL Segment ls : ( ( Track ) osm ) . segments ( ) ) ds . add CaMeL Pending CaMeL Line CaMeL Segment ( ls ) ; } }	if ( is CaMeL Referenced ( n , ds ) ) { String combined = combine ( n , ds ) ;
Http CaMeL Servlet CaMeL Request request , Http CaMeL Servlet CaMeL Response response )  <CTX>  public Action CaMeL Forward execute ( Action CaMeL Mapping mapping , Action CaMeL Form form , Http CaMeL Servlet CaMeL Request request , Http CaMeL Servlet CaMeL Response response ) throws Exception { / / Call the deprecated method for backwards compatibility return ( perform ( mapping , form , request , response ) ) ; }	Servlet CaMeL Request request , Servlet CaMeL Response response )
Scalar CaMeL Parameter CaMeL Handle report CaMeL Param ) throws Semantic CaMeL Exception  <CTX>  private void update CaMeL Input CaMeL Parameter CaMeL Attrs CaMeL To CaMeL Report CaMeL Param ( Input CaMeL Parameter CaMeL Attributes input CaMeL Param CaMeL Attrs , Input CaMeL Parameter CaMeL Attributes cached CaMeL Input CaMeL Param CaMeL Attrs , Scalar CaMeL Parameter CaMeL Handle report CaMeL Param ) throws Semantic CaMeL Exception { if ( input CaMeL Param CaMeL Attrs == null ) return ; Input CaMeL Parameter CaMeL UI CaMeL Hints param CaMeL Ui CaMeL Hints = input CaMeL Param CaMeL Attrs . get CaMeL Ui CaMeL Hints ( ) ; if ( param CaMeL Ui CaMeL Hints != null && report CaMeL Param . get CaMeL Container ( ) instanceof Parameter CaMeL Group CaMeL Handle ) { Parameter CaMeL Group CaMeL Handle param CaMeL Group = ( Parameter CaMeL Group CaMeL Handle ) report CaMeL Param . get CaMeL Container ( ) ; Input CaMeL Parameter CaMeL UI CaMeL Hints cached CaMeL Param CaMeL Ui CaMeL Hints = cached CaMeL Input CaMeL Param CaMeL Attrs == null ? null : cached CaMeL Input CaMeL Param CaMeL Attrs . get CaMeL Ui CaMeL Hints ( ) ; String cached CaMeL Group CaMeL Prompt CaMeL Display CaMeL Name = cached CaMeL Param CaMeL Ui CaMeL Hints == null ? null : cached CaMeL Param CaMeL Ui CaMeL Hints . get CaMeL Group CaMeL Prompt CaMeL Display CaMeL Name ( ) ; String group CaMeL Prompt CaMeL Display CaMeL Name = param CaMeL Ui CaMeL Hints . get CaMeL Group CaMeL Prompt CaMeL Display CaMeL Name ( ) ; if ( cached CaMeL Group CaMeL Prompt CaMeL Display CaMeL Name == null || ! cached CaMeL Group CaMeL Prompt CaMeL Display CaMeL Name . equals ( group CaMeL Prompt CaMeL Display CaMeL Name ) ) param CaMeL Group . set CaMeL Display CaMeL Name ( param CaMeL Ui CaMeL Hints . get CaMeL Group CaMeL Prompt CaMeL Display CaMeL Name ( ) ) ; } update CaMeL Input CaMeL Element CaMeL Attrs CaMeL To CaMeL Report CaMeL Param ( input CaMeL Param CaMeL Attrs . get CaMeL Element CaMeL Attributes ( ) , cached CaMeL Input CaMeL Param CaMeL Attrs == null ? null : cached CaMeL Input CaMeL Param CaMeL Attrs . get CaMeL Element CaMeL Attributes ( ) , report CaMeL Param ) ; }	Scalar CaMeL Parameter CaMeL Handle report CaMeL Param , Oda CaMeL Data CaMeL Set CaMeL Handle set CaMeL Handle ) throws Semantic CaMeL Exception
ui . show ( ) ;  <CTX>  public static void main ( String argv [ ] ) { UI ui = new UI ( ) ; ui . show ( ) ; }	ui . set CaMeL Visible ( true ) ;
SQL CaMeL Exception CaMeL Handler . throw CaMeL SQL CaMeL Exception ( e ) ; throw e ;  <CTX>  public Big CaMeL Decimal get CaMeL Big CaMeL Decimal ( int parameter CaMeL Index ) throws SQL CaMeL Exception { try { return ( ( java . sql . Callable CaMeL Statement ) m _ stmt ) . get CaMeL Big CaMeL Decimal ( parameter CaMeL Index ) ; } catch ( SQL CaMeL Exception e ) { SQL CaMeL Exception CaMeL Handler . throw CaMeL SQL CaMeL Exception ( e ) ; throw e ; / / code should never get here , but just in case } }	throw m _ conn . wrap ( e ) ;
while ( cls != Object . class ) {  <CTX>  private String [ ] find CaMeL Inherited CaMeL String CaMeL Array ( Class cls , Class annotation CaMeL Class , String method CaMeL Name ) { Map < String , String > v CaMeL Result = new Hash CaMeL Map < String , String > ( ) ; while ( cls != Object . class ) { Annotation annotation = cls . get CaMeL Annotation ( annotation CaMeL Class ) ; if ( annotation != null ) { String [ ] g = ( String [ ] ) invoke CaMeL Method ( annotation , method CaMeL Name ) ; for ( String s : g ) { v CaMeL Result . put ( s , s ) ; } } cls = cls . get CaMeL Superclass ( ) ; } String [ ] result = v CaMeL Result . key CaMeL Set ( ) . to CaMeL Array ( new String [ v CaMeL Result . size ( ) ] ) ; return result ; }	while ( cls != null && cls != Object . class ) {
} catch ( Return CaMeL Jump r CaMeL Ex@@ cp@@ tn ) { result = r CaMeL Ex@@ cp@@ tn . get CaMeL Return CaMeL Value ( ) ;  <CTX>  public void visit CaMeL Iter CaMeL Node ( Iter CaMeL Node i CaMeL Visited ) { thread CaMeL Context . get CaMeL Block CaMeL Stack ( ) . push ( i CaMeL Visited . get CaMeL Var CaMeL Node ( ) , new Evaluate CaMeL Method ( i CaMeL Visited . get CaMeL Body CaMeL Node ( ) ) , self ) ; thread CaMeL Context . get CaMeL Iter CaMeL Stack ( ) . push ( Iter . ITER _ PRE ) ; try { while ( true ) { try { result = eval ( i CaMeL Visited . get CaMeL Iter CaMeL Node ( ) ) ; return ; } catch ( Retry CaMeL Jump r CaMeL Ex@@ cp@@ tn ) { } } } catch ( Return CaMeL Jump r CaMeL Ex@@ cp@@ tn ) { result = r CaMeL Ex@@ cp@@ tn . get CaMeL Return CaMeL Value ( ) ; } catch ( Break CaMeL Jump b CaMeL Ex@@ cp@@ tn ) { result = runtime . get CaMeL Nil ( ) ; } finally { thread CaMeL Context . get CaMeL Iter CaMeL Stack ( ) . pop ( ) ; thread CaMeL Context . get CaMeL Block CaMeL Stack ( ) . pop ( ) ; } }	/ * } catch ( Return CaMeL Jump r CaMeL Ex@@ cp@@ tn ) { result = r CaMeL Ex@@ cp@@ tn . get CaMeL Return CaMeL Value ( ) ; * /
} else if ( value CaMeL Changing CaMeL Listeners . size ( ) > 16 ) { Hash CaMeL Set listener CaMeL List = new Hash CaMeL Set ( ) ; listener CaMeL List . add CaMeL All ( value CaMeL Changing CaMeL Listeners ) ; value CaMeL Changing CaMeL Listeners = listener CaMeL List ;  <CTX>  public void add CaMeL Value CaMeL Changing CaMeL Listener ( I CaMeL Value CaMeL Changing CaMeL Listener listener ) { if ( value CaMeL Changing CaMeL Listeners == null ) { boolean had CaMeL Listeners = has CaMeL Listeners ( ) ; value CaMeL Changing CaMeL Listeners = new Array CaMeL List ( ) ; value CaMeL Changing CaMeL Listeners . add ( listener ) ; if ( ! had CaMeL Listeners ) { first CaMeL Listener CaMeL Added ( ) ; } } else if ( value CaMeL Changing CaMeL Listeners . size ( ) > 16 ) { Hash CaMeL Set listener CaMeL List = new Hash CaMeL Set ( ) ; listener CaMeL List . add CaMeL All ( value CaMeL Changing CaMeL Listeners ) ; value CaMeL Changing CaMeL Listeners = listener CaMeL List ; value CaMeL Changing CaMeL Listeners . add ( listener ) ; } }	} else {
( XML CaMeL Entity CaMeL Resolver ) f CaMeL Configuration . get CaMeL Entity CaMeL Resolver ( ) ;  <CTX>  public Entity CaMeL Resolver get CaMeL Entity CaMeL Resolver ( ) { Entity CaMeL Resolver entity CaMeL Resolver = null ; try { XML CaMeL Entity CaMeL Resolver xml CaMeL Entity CaMeL Resolver = ( XML CaMeL Entity CaMeL Resolver ) f CaMeL Configuration . get CaMeL Entity CaMeL Resolver ( ) ; if ( xml CaMeL Entity CaMeL Resolver != null && xml CaMeL Entity CaMeL Resolver instanceof Entity CaMeL Resolver CaMeL Wrapper ) { entity CaMeL Resolver = ( ( Entity CaMeL Resolver CaMeL Wrapper ) xml CaMeL Entity CaMeL Resolver ) . get CaMeL Entity CaMeL Resolver ( ) ; } } catch ( XML CaMeL Configuration CaMeL Exception e ) { / / do nothing } return entity CaMeL Resolver ; } / / get CaMeL Entity CaMeL Resolver ( ) : Entity CaMeL Resol@@ ver	( XML CaMeL Entity CaMeL Resolver ) f CaMeL Configuration . get CaMeL Property ( ENTITY _ RESOLVER ) ;
return annotation CaMeL Class . ends CaMeL With ( NONNULL _ ANNOTATION _ CLASS ) || annotation CaMeL Class . ends CaMeL With ( CHECK _ FOR _ NULL _ ANNOTATION _ CLASS ) || annotation CaMeL Class . ends CaMeL With ( PO@@ SSI@@ B@@ LY _ NULL _ ANNOTATION _ CLASS ) ;  <CTX>  private static boolean is CaMeL Non CaMeL Null CaMeL Annotation ( String annotation CaMeL Class ) { return annotation CaMeL Class . ends CaMeL With ( NONNULL _ ANNOTATION _ CLASS ) || annotation CaMeL Class . ends CaMeL With ( CHECK _ FOR _ NULL _ ANNOTATION _ CLASS ) || annotation CaMeL Class . ends CaMeL With ( PO@@ SSI@@ B@@ LY _ NULL _ ANNOTATION _ CLASS ) ; }	return annotation CaMeL Class . ends CaMeL With ( NONNULL _ ANNOTATION _ CLASS ) ;
tree . set CaMeL Type ( definitions . UNIT _ TYPE ) ;  <CTX>  public Val CaMeL Def Val CaMeL Def ( Symbol sym , Tree rhs ) { Val CaMeL Def tree = make . Val CaMeL Def ( sym . pos , sym , Type CaMeL Term ( sym . pos , sym . next CaMeL Type ( ) ) , rhs ) ; tree . set CaMeL Type ( definitions . UNIT _ TYPE ) ; return tree ; }	tree . set CaMeL Type ( Type . No CaMeL Type ) ;
this . ctx = O@@ mer@@ o CaMeL Context . get CaMeL Client CaMeL Context ( ) ;  <CTX>  public Service CaMeL Factory ( ) { this . ctx = O@@ mer@@ o CaMeL Context . get CaMeL Client CaMeL Context ( ) ; }	if ( get CaMeL Default CaMeL Context ( ) != null ) { this . ctx = O@@ mer@@ o CaMeL Context . get CaMeL Instance ( get CaMeL Default CaMeL Context ( ) ) ; }
return false ;  <CTX>  public boolean is CaMeL Boolean ( ) { return false ; }	return e . is CaMeL Boolean ( ) ;
Dependency d = new Dependency ( group CaMeL Id , artifact CaMeL Id , version , type ) ;  <CTX>  public File get CaMeL Artifact CaMeL File ( String group CaMeL Id , String artifact CaMeL Id , String version , String type ) { Dependency d = new Dependency ( group CaMeL Id , artifact CaMeL Id , version , type ) ; return get CaMeL Artifact CaMeL File ( d ) ; }	Dependency d = new Dependency ( group CaMeL Id , artifact CaMeL Id , version , type , Collections . EMPTY _ LIST ) ;
Parser CaMeL Rule target CaMeL Rule = get CaMeL Enclosing CaMeL Rule CaMeL At CaMeL Position ( text CaMeL Pane . get CaMeL Caret CaMeL Position ( ) ) ;  <CTX>  public void action CaMeL Performed ( Action CaMeL Event event ) { Parser CaMeL Rule target CaMeL Rule = get CaMeL Enclosing CaMeL Rule CaMeL At CaMeL Position ( text CaMeL Pane . get CaMeL Caret CaMeL Position ( ) ) ; int next CaMeL Rule CaMeL Index = parser . get CaMeL Rules ( ) . index CaMeL Of ( target CaMeL Rule ) + 1 ; Parser CaMeL Rule source CaMeL Rule = parser . get CaMeL Rule CaMeL At CaMeL Index ( next CaMeL Rule CaMeL Index ) ; if ( source CaMeL Rule != null ) { move CaMeL Rule ( source CaMeL Rule , target CaMeL Rule , true ) ; select CaMeL Next CaMeL Rule = true ; } }	Parser CaMeL Rule target CaMeL Rule = get CaMeL Enclosing CaMeL Rule CaMeL At CaMeL Position ( editor . get CaMeL Caret CaMeL Position ( ) ) ;
if ( _ test . get CaMeL Class CaMeL Loader ( ) != null )  <CTX>  protected Object build CaMeL Object CaMeL Model ( String builder CaMeL Name ) throws java . lang . Exception { Class builder CaMeL Class = null ; if ( _ test . get CaMeL Class CaMeL Loader ( ) != null ) builder CaMeL Class = _ test . get CaMeL Class CaMeL Loader ( ) . load CaMeL Class ( builder CaMeL Name ) ; else builder CaMeL Class = this . get CaMeL Class ( ) . get CaMeL Class CaMeL Loader ( ) . load CaMeL Class ( builder CaMeL Name ) ; Object CaMeL Model CaMeL Builder builder = ( Object CaMeL Model CaMeL Builder ) builder CaMeL Class . new CaMeL Instance ( ) ; return builder . build CaMeL Instance ( ) ; }	if ( _ test . get CaMeL Class CaMeL Loader ( ) != null ) {
Property CaMeL List property CaMeL List , F CaMeL Obj fo ) {  <CTX>  public Property convert CaMeL Property ( Property p , Property CaMeL List property CaMeL List , F CaMeL Obj fo ) { if ( p instanceof Number CaMeL Property ) { return p ; } if ( p instanceof Enum CaMeL Property ) { return new Enum CaMeL Number ( p ) ; } Number val = p . get CaMeL Number ( ) ; if ( val != null ) { return new Number CaMeL Property ( val ) ; } return convert CaMeL Property CaMeL Datatype ( p , property CaMeL List , fo ) ; }	Property CaMeL List property CaMeL List , F CaMeL Obj fo ) throws Property CaMeL Exception {
arguments . put ( Chain CaMeL Dynamic CaMeL Method . ARGUMENT _ ACTION , show CaMeL Action ) ; arguments . put ( Chain CaMeL Dynamic CaMeL Method . ARGUMENT _ MODEL , model ) ; arguments . put ( Chain CaMeL Dynamic CaMeL Method . ARGUMENT _ PARAMS , model ) ; return controller . invoke CaMeL Method ( Chain CaMeL Dynamic CaMeL Method . METHOD _ SIGNATURE , new Object [ ] { arguments } ) ;  <CTX>  public Object call ( Object [ ] args ) { Scaffold CaMeL Callback callback = new Default CaMeL Scaffold CaMeL Callback ( ) ; / / save Map model = this . scaff@@ old CaMeL Request CaMeL Handler . handle CaMeL Update ( request , response , callback ) ; if ( callback . is CaMeL Invoked ( ) ) { Closure show CaMeL Action = ( Closure ) controller . get CaMeL Property ( SHOW _ ACTION ) ; Map arguments = new Hash CaMeL Map ( ) ; arguments . put ( Chain CaMeL Dynamic CaMeL Method . ARGUMENT _ ACTION , show CaMeL Action ) ; arguments . put ( Chain CaMeL Dynamic CaMeL Method . ARGUMENT _ MODEL , model ) ; arguments . put ( Chain CaMeL Dynamic CaMeL Method . ARGUMENT _ PARAMS , model ) ; return controller . invoke CaMeL Method ( Chain CaMeL Dynamic CaMeL Method . METHOD _ SIGNATURE , new Object [ ] { arguments } ) ; } else { Map arguments = new Hash CaMeL Map ( ) ; arguments . put ( Render CaMeL Dynamic CaMeL Method . ARGUMENT _ VIEW , EDIT _ ACTION ) ; arguments . put ( Render CaMeL Dynamic CaMeL Method . ARGUMENT _ MODEL , model ) ; return controller . invoke CaMeL Method ( Render CaMeL Dynamic CaMeL Method . METHOD _ SIGNATURE , new Object [ ] { arguments } ) ; } }	arguments . put ( Redirect CaMeL Dynamic CaMeL Method . ARGUMENT _ ACTION , show CaMeL Action ) ; arguments . put ( Redirect CaMeL Dynamic CaMeL Method . ARGUMENT _ ID , model . get ( Redirect CaMeL Dynamic CaMeL Method . ARGUMENT _ ID ) ) ; return controller . invoke CaMeL Method ( Redirect CaMeL Dynamic CaMeL Method . METHOD _ SIGNATURE , new Object [ ] { arguments } ) ;
super ( message ) ;  <CTX>  public X CaMeL Path CaMeL Syntax CaMeL Exception ( String xpath , int position , String message ) { super ( message ) ; this . xpath = xpath ; this . position = position ; }	super ( e ) ;
e CaMeL Dynamic CaMeL Set ( e CaMeL Feature , new CaMeL Value ) ;  <CTX>  public void e CaMeL Set ( E CaMeL Structural CaMeL Feature e CaMeL Feature , Object new CaMeL Value ) { switch ( e CaMeL Derived CaMeL Structural CaMeL Feature CaMeL ID ( e CaMeL Feature ) ) { case Attribute CaMeL Package . JAVA _ NUMBER _ FORMAT _ SPECIFIER _ _ PATTERN : set CaMeL Pattern ( ( String ) new CaMeL Value ) ; return ; case Attribute CaMeL Package . JAVA _ NUMBER _ FORMAT _ SPECIFIER _ _ MULTIPLIER : set CaMeL Multiplier ( ( ( Double ) new CaMeL Value ) . double CaMeL Value ( ) ) ; return ; } e CaMeL Dynamic CaMeL Set ( e CaMeL Feature , new CaMeL Value ) ; }	super . e CaMeL Set ( feature CaMeL ID , new CaMeL Value ) ;
throw org . postgresql . Driver . not CaMeL Implemented ( ) ;  <CTX>  public java . sql . Result CaMeL Set get CaMeL Cross CaMeL Reference ( String primary CaMeL Catalog , String primary CaMeL Schema , String primary CaMeL Table , String foreign CaMeL Catalog , String foreign CaMeL Schema , String foreign CaMeL Table ) throws SQL CaMeL Exception { throw org . postgresql . Driver . not CaMeL Implemented ( ) ; }	return get CaMeL Imported CaMeL Exported CaMeL Keys ( primary CaMeL Catalog , primary CaMeL Schema , primary CaMeL Table , foreign CaMeL Table ) ;
export CaMeL Resource ( resource , 1 ) ;  <CTX>  protected void export CaMeL Resource ( I CaMeL Resource resource ) throws Interrupted CaMeL Exception { export CaMeL Resource ( resource , 1 ) ; }	export CaMeL Resource ( export CaMeL Resource , 1 ) ;
rebind ( orb . object _ to _ string ( fwd . forward ) ) ;  <CTX>  public void invoke CaMeL Interceptors ( Client CaMeL Request CaMeL Info CaMeL Impl info , short op ) throws Remarshal CaMeL Exception { Client CaMeL Interceptor CaMeL Iterator intercept _ iter = orb . get CaMeL Interceptor CaMeL Manager ( ) . get CaMeL Client CaMeL Iterator ( ) ; try { intercept _ iter . iterate ( info , op ) ; } catch ( org . omg . Portable CaMeL Interceptor . Forward CaMeL Request fwd ) { rebind ( orb . object _ to _ string ( fwd . forward ) ) ; throw new Remarshal CaMeL Exception ( ) ; } catch ( org . omg . CORBA . User CaMeL Exception ue ) { if ( logger . is CaMeL Error CaMeL Enabled ( ) ) logger . error ( ue . get CaMeL Message ( ) ) ; } }	rebind ( fwd . forward ) ;
view CaMeL Type = Layer CaMeL Utils . int CaMeL From CaMeL Properties ( properties , prefix + E@@ TOP@@ O CaMeL View CaMeL Type CaMeL Property , COLO@@ RED@@ SH@@ ADING ) ;  <CTX>  public void set CaMeL Properties ( String prefix , java . util . Properties properties ) { super . set CaMeL Properties ( prefix , properties ) ; path = properties . get CaMeL Property ( prefix + E@@ TOP@@ O CaMeL Path CaMeL Property ) ; o@@ pa@@ queness = Layer CaMeL Utils . int CaMeL From CaMeL Properties ( properties , prefix + O@@ pa@@ queness CaMeL Property , DEFAULT _ OPA@@ QU@@ EN@@ ESS ) ; view CaMeL Type = Layer CaMeL Utils . int CaMeL From CaMeL Properties ( properties , prefix + E@@ TOP@@ O CaMeL View CaMeL Type CaMeL Property , COLO@@ RED@@ SH@@ ADING ) ; slope CaMeL Adjust = Layer CaMeL Utils . int CaMeL From CaMeL Properties ( properties , prefix + E@@ TOP@@ O CaMeL Slope CaMeL Adjust CaMeL Property , DEFAULT _ SLO@@ PE _ ADJUST ) ; minute CaMeL Spacing = Layer CaMeL Utils . int CaMeL From CaMeL Properties ( properties , prefix + E@@ TOP@@ O CaMeL Minute CaMeL Spacing CaMeL Property , DEFAULT _ MINUTE _ SPACING ) ; }	view CaMeL Type = Prop CaMeL Utils . int CaMeL From CaMeL Properties ( properties , prefix + E@@ TOP@@ O CaMeL View CaMeL Type CaMeL Property , COLO@@ RED@@ SH@@ ADING ) ;
current CaMeL Loader = new Thumbnail CaMeL Loader ( component , browser . get CaMeL Images ( ) ) ;  <CTX>  void fire CaMeL Thumbnail CaMeL Loading ( ) { state = Hi CaMeL Viewer . LOADING _ THUMBN@@ AI@@ LS ; current CaMeL Loader = new Thumbnail CaMeL Loader ( component , browser . get CaMeL Images ( ) ) ; current CaMeL Loader . load ( ) ; }	current CaMeL Loader = new Thumbnail CaMeL Loader ( component , images ) ;
Promise lookup ( String s ) ;  <CTX>  Promise lookup ( String s ) ;	Promise lookup ( C _ Var [ ] vars , int index ) ;
suite . add CaMeL Test ( suite CaMeL For CaMeL Javadoc CaMeL Support ( level , test CaMeL Class , constructor , support ) ) ;  <CTX>  public static Test suite CaMeL For CaMeL Compliance CaMeL Level ( String level , Class test CaMeL Class ) { Test CaMeL Suite suite = new Test CaMeL Suite ( level ) ; try { Class [ ] param CaMeL Types = new Class [ ] { String . class } ; Constructor constructor = test CaMeL Class . get CaMeL Constructor ( param CaMeL Types ) ; / / Javadoc ENABLED String support = Compiler CaMeL Options . DISABLED ; if ( DOC _ COMMENT _ SUPPORT == null ) { suite . add CaMeL Test ( suite CaMeL For CaMeL Javadoc CaMeL Support ( level , test CaMeL Class , constructor , Compiler CaMeL Options . ENABLED ) ) ; } else { support = DOC _ COMMENT _ SUPPORT ; } / / Javadoc DISABLED suite . add CaMeL Test ( suite CaMeL For CaMeL Javadoc CaMeL Support ( level , test CaMeL Class , constructor , support ) ) ; } catch ( Exception e ) { throw new Runtime CaMeL Exception ( e ) ; } return suite ; }	suite . add CaMeL Test ( suite CaMeL For CaMeL Javadoc CaMeL Support ( level , test CaMeL Class , support ) ) ;
switch ( event . type ) { case SWT . Selection : if ( menu CaMeL Item . get CaMeL Selection ( ) ) { IDE . set CaMeL Default CaMeL Editor ( file , null ) ; try { I CaMeL Editor CaMeL Descriptor desc = IDE . get CaMeL Editor CaMeL Descriptor ( file ) ; ( ( Workbench CaMeL Page ) page ) . open CaMeL Editor ( new File CaMeL Editor CaMeL Input ( file ) , desc . get CaMeL Id ( ) , true , Workbench CaMeL Page . MATCH _ BOTH ) ; } catch ( Part CaMeL Init CaMeL Exception e ) { Dialog CaMeL Util . open CaMeL Error ( page . get CaMeL Workbench CaMeL Window ( ) . get CaMeL Shell ( ) , IDE CaMeL Workbench CaMeL Messages . Open CaMeL With CaMeL Menu _ dialog CaMeL Title , e . get CaMeL Message ( ) , e ) ; } } break ; } }  <CTX>  public void handle CaMeL Event ( Event event ) { switch ( event . type ) { case SWT . Selection : if ( menu CaMeL Item . get CaMeL Selection ( ) ) { IDE . set CaMeL Default CaMeL Editor ( file , null ) ; try { I CaMeL Editor CaMeL Descriptor desc = IDE . get CaMeL Editor CaMeL Descriptor ( file ) ; ( ( Workbench CaMeL Page ) page ) . open CaMeL Editor ( new File CaMeL Editor CaMeL Input ( file ) , desc . get CaMeL Id ( ) , true , Workbench CaMeL Page . MATCH _ BOTH ) ; } catch ( Part CaMeL Init CaMeL Exception e ) { Dialog CaMeL Util . open CaMeL Error ( page . get CaMeL Workbench CaMeL Window ( ) . get CaMeL Shell ( ) , IDE CaMeL Workbench CaMeL Messages . Open CaMeL With CaMeL Menu _ dialog CaMeL Title , e . get CaMeL Message ( ) , e ) ; } } break ; } }	switch ( event . type ) { case SWT . Selection : open CaMeL Editor ( entry , false ) ; break ; } }
if ( Marker CaMeL Util . is CaMeL Marker CaMeL Type ( marker , I CaMeL Marker . TASK ) ) return Marker CaMeL Util . get CaMeL Priority ( marker ) ;  <CTX>  private int get CaMeL Priority CaMeL Order ( I CaMeL Marker marker ) { if ( Marker CaMeL Util . is CaMeL Marker CaMeL Type ( marker , I CaMeL Marker . TASK ) ) return Marker CaMeL Util . get CaMeL Priority ( marker ) ; return - 1 ; }	if ( Marker CaMeL Util . is CaMeL Marker CaMeL Type ( marker , I CaMeL Marker . TASK ) ) { return Marker CaMeL Util . get CaMeL Priority ( marker ) ; }
if ( ( length = ast CaMeL Length CaMeL Stack [ ast CaMeL Length CaMeL Ptr -- ] ) != 0 ) {  <CTX>  protected void consume CaMeL Interface CaMeL Declaration ( ) { / / see consume CaMeL Class CaMeL Declaration in case of changes : duplicated code / / Interface CaMeL Declaration :: = Interface CaMeL Header Interface CaMeL Body int length ; if ( ( length = ast CaMeL Length CaMeL Stack [ ast CaMeL Length CaMeL Ptr -- ] ) != 0 ) { / / there are length declarations / / dispatch . . . . . ac@@ cor@@ ding to the type of the declarations dispatch CaMeL Declaration CaMeL Into ( length ) ; } Type CaMeL Declaration type CaMeL Decl = ( Type CaMeL Declaration ) ast CaMeL Stack [ ast CaMeL Ptr ] ; / / mark initializers with local type mark if needed mark CaMeL Initializers CaMeL With CaMeL Local CaMeL Type ( type CaMeL Decl ) ; / / convert constructor that do not have the type s name into methods type CaMeL Decl . check CaMeL Constructors ( this ) ; / / always add < clinit > ( will be remove at code gen time if empty ) if ( this . scanner . contains CaMeL Assert CaMeL Keyword ) { type CaMeL Decl . bits |= AST CaMeL Node . Add CaMeL Assertion CaMeL MASK ; } type CaMeL Decl . add CaMeL Clinit ( ) ; type CaMeL Decl . body CaMeL End = end CaMeL Statement CaMeL Position ; if ( length == 0 && ! contains CaMeL Comment ( type CaMeL Decl . body CaMeL Start , type CaMeL Decl . body CaMeL End ) ) { type CaMeL Decl . bits |= AST CaMeL Node . Undocumented CaMeL Empty CaMeL Block CaMeL MASK ; } type CaMeL Decl . declaration CaMeL Source CaMeL End = flush CaMeL Comments CaMeL Defined CaMeL Prior CaMeL To ( end CaMeL Statement CaMeL Position ) ; }	if ( ( length = this . ast CaMeL Length CaMeL Stack [ this . ast CaMeL Length CaMeL Ptr -- ] ) != 0 ) {
updater . do CaMeL Switch ( new File ( absolute CaMeL Path ) . get CaMeL Absolute CaMeL File ( ) , url , revision , ! get CaMeL Command CaMeL Line ( ) . has CaMeL Argument ( SVN CaMeL Argument . NON _ RECURSIVE ) ) ;  <CTX>  public void run ( final Print CaMeL Stream out , final Print CaMeL Stream err ) throws SVN CaMeL Exception { String url = get CaMeL Command CaMeL Line ( ) . get CaMeL URL ( 0 ) ; String absolute CaMeL Path = get CaMeL Command CaMeL Line ( ) . get CaMeL Path CaMeL At ( 0 ) ; SVN CaMeL Revision revision = parse CaMeL Revision ( get CaMeL Command CaMeL Line ( ) ) ; if ( ! revision . is CaMeL Valid ( ) ) { revision = SVN CaMeL Revision . HEAD ; } get CaMeL Client CaMeL Manager ( ) . set CaMeL Event CaMeL Handler ( new SVN CaMeL Command CaMeL Event CaMeL Processor ( out , err , false , false ) ) ; SVN CaMeL Update CaMeL Client updater = get CaMeL Client CaMeL Manager ( ) . get CaMeL Update CaMeL Client ( ) ; try { if ( get CaMeL Command CaMeL Line ( ) . has CaMeL Argument ( SVN CaMeL Argument . RE@@ LOC@@ ATE ) ) { updater . do CaMeL Relocate ( new File ( absolute CaMeL Path ) . get CaMeL Absolute CaMeL File ( ) , url , get CaMeL Command CaMeL Line ( ) . get CaMeL URL ( 1 ) , ! get CaMeL Command CaMeL Line ( ) . has CaMeL Argument ( SVN CaMeL Argument . NON _ RECURSIVE ) ) ; } else { updater . do CaMeL Switch ( new File ( absolute CaMeL Path ) . get CaMeL Absolute CaMeL File ( ) , url , revision , ! get CaMeL Command CaMeL Line ( ) . has CaMeL Argument ( SVN CaMeL Argument . NON _ RECURSIVE ) ) ; } } catch ( Throwable th ) { SVN CaMeL Debug CaMeL Log . log ( th ) ; println ( err , th . get CaMeL Message ( ) ) ; println ( err ) ; System . exit ( 1 ) ; } }	updater . do CaMeL Switch ( new File ( absolute CaMeL Path ) . get CaMeL Absolute CaMeL File ( ) , switch CaMeL URL , revision , ! get CaMeL Command CaMeL Line ( ) . has CaMeL Argument ( SVN CaMeL Argument . NON _ RECURSIVE ) ) ;
{ this . view = view ; this . agent CaMeL Ctrl = agent CaMeL Ctrl ; p CaMeL Nodes = new Tree CaMeL Map ( ) ; init CaMeL Listeners ( ) ; tree CaMeL Loaded = false ; }  <CTX>  Explorer CaMeL Pane CaMeL Manager ( Explorer CaMeL Pane view , Data CaMeL Manager CaMeL Ctrl agent CaMeL Ctrl ) { this . view = view ; this . agent CaMeL Ctrl = agent CaMeL Ctrl ; p CaMeL Nodes = new Tree CaMeL Map ( ) ; init CaMeL Listeners ( ) ; tree CaMeL Loaded = false ; }	{ this . view = view ; this . agent CaMeL Ctrl = agent CaMeL Ctrl ; p CaMeL Nodes = new Tree CaMeL Map ( ) ; c CaMeL D CaMeL Nodes = new Tree CaMeL Map ( ) ; init CaMeL Listeners ( ) ; tree CaMeL Loaded = false ; }
return _ default CaMeL Value ;  <CTX>  public long get CaMeL Default CaMeL Value ( ) { return _ default CaMeL Value ; }	return default CaMeL Value ;
String [ ] lines = new Document CaMeL Wrapper ( my CaMeL Document ) . get CaMeL Lines ( my CaMeL First CaMeL Changed CaMeL Line , my CaMeL Last CaMeL Changed CaMeL Line ) ; String [ ] u CaMeL Lines = new Document CaMeL Wrapper ( my CaMeL Up CaMeL To CaMeL Date CaMeL Document )  <CTX>  private List < Range > get CaMeL New CaMeL Changed CaMeL Ranges ( ) { String [ ] lines = new Document CaMeL Wrapper ( my CaMeL Document ) . get CaMeL Lines ( my CaMeL First CaMeL Changed CaMeL Line , my CaMeL Last CaMeL Changed CaMeL Line ) ; String [ ] u CaMeL Lines = new Document CaMeL Wrapper ( my CaMeL Up CaMeL To CaMeL Date CaMeL Document ) . get CaMeL Lines ( my CaMeL Up CaMeL To CaMeL Date CaMeL First CaMeL Line , my CaMeL Up CaMeL To CaMeL Date CaMeL Last CaMeL Line ) ; return new Ranges CaMeL Builder ( lines , u CaMeL Lines , my CaMeL First CaMeL Changed CaMeL Line , my CaMeL Up CaMeL To CaMeL Date CaMeL First CaMeL Line ) . get CaMeL Ranges ( ) ; }	List < String > lines = new Document CaMeL Wrapper ( my CaMeL Document ) . get CaMeL Lines ( my CaMeL First CaMeL Changed CaMeL Line , my CaMeL Last CaMeL Changed CaMeL Line ) ; List < String > u CaMeL Lines = new Document CaMeL Wrapper ( my CaMeL Up CaMeL To CaMeL Date CaMeL Document )
return VM _ Magic . address CaMeL As CaMeL Object CaMeL Array ( VM _ Address . from CaMeL Int ( slots [ slot ] ) ) ;  <CTX>  public static Object [ ] get CaMeL Slot CaMeL Contents CaMeL As CaMeL Object CaMeL Array ( int slot ) throws VM _ Pragma CaMeL Uninterruptible { / / - # if RVM _ FOR _ 64 _ ADDR return VM _ Magic . address CaMeL As CaMeL Object CaMeL Array ( VM _ Address . from CaMeL Long ( get CaMeL Slot CaMeL Contents CaMeL As CaMeL Long ( slot ) ) ) ; / / - # else return VM _ Magic . address CaMeL As CaMeL Object CaMeL Array ( VM _ Address . from CaMeL Int ( slots [ slot ] ) ) ; / / - # endif }	return VM _ Magic . address CaMeL As CaMeL Object CaMeL Array ( VM _ Address . from CaMeL Int CaMeL Zero CaMeL Extend ( slots [ slot ] ) ) ;
boolean reuse CaMeL Editor = Workbench CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Preference CaMeL Store ( ) . get CaMeL Boolean ( I CaMeL Preference CaMeL Constants . REUSE _ EDITORS _ BOOLEAN ) ;  <CTX>  public boolean should CaMeL Be CaMeL Visible ( ) { if ( editor CaMeL Pane == null ) { return false ; } boolean reuse CaMeL Editor = Workbench CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Preference CaMeL Store ( ) . get CaMeL Boolean ( I CaMeL Preference CaMeL Constants . REUSE _ EDITORS _ BOOLEAN ) ; return reuse CaMeL Editor ; }	I CaMeL Preference CaMeL Store store = Workbench CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Preference CaMeL Store ( ) ; boolean reuse CaMeL Editor = store . get CaMeL Boolean ( I CaMeL Preference CaMeL Constants . REUSE _ EDITORS _ BOOLEAN ) | store . get CaMeL Boolean ( I CaMeL Preference CaMeL Constants . EDITOR _ EXPERIMENTAL _ TAB _ BEHAVIOUR ) ;
if ( type == I CaMeL Resource . ROOT )  <CTX>  public static String get CaMeL Short CaMeL Container CaMeL Name ( I CaMeL Marker marker ) { try { Object path CaMeL Attribute = marker . get CaMeL Attribute ( Marker CaMeL View CaMeL Util . PATH _ ATTRIBUTE ) ; if ( path CaMeL Attribute != null ) return path CaMeL Attribute . to CaMeL String ( ) ; } catch ( Core CaMeL Exception exception ) { / / Log the exception and fall back . log ( exception ) ; } I CaMeL Resource resource = marker . get CaMeL Resource ( ) ; int type = resource . get CaMeL Type ( ) ; / / Cannot be project relative if it is the root or a project if ( type == I CaMeL Resource . PROJECT ) return resource . get CaMeL Name ( ) ; if ( type == I CaMeL Resource . ROOT ) return Marker CaMeL Messages . Util _ Workspace CaMeL Root ; String result = marker . get CaMeL Resource ( ) . get CaMeL Project CaMeL Relative CaMeL Path ( ) . remove CaMeL Last CaMeL Segments ( 1 ) . to CaMeL OS CaMeL String ( ) ; if ( result . trim ( ) . length ( ) == 0 ) return Marker CaMeL Messages . Util _ Project CaMeL Root ; return result ; }	if ( type == I CaMeL Resource . ROOT ) {
Open CaMeL File ( JS CaMeL Debugger db , Scriptable scope , String file CaMeL Name ) {  <CTX>  Open CaMeL File ( JS CaMeL Debugger db , Scriptable scope , String file CaMeL Name ) { this . scope = scope ; this . file CaMeL Name = file CaMeL Name ; this . db = db ; }	Open CaMeL File ( Main db , Scriptable scope , String file CaMeL Name ) {
( ( Main ) compiler ) . re CaMeL Join ( unit ) ;  <CTX>  protected void _ override ( F@@ j CaMeL Overri@@ deable instance , Compiler CaMeL Base compiler ) { F@@ j CaMeL Override CaMeL Class CaMeL Declaration . set CaMeL Overriding CaMeL Super CaMeL Class ( instance , compiler ) ; J CaMeL Compilation CaMeL Unit unit = ( J CaMeL Compilation CaMeL Unit ) compilation CaMeL Unit CaMeL Map . get ( instance ) ; ( ( Main ) compiler ) . re CaMeL Join ( unit ) ; }	( ( Main ) compiler ) . join ( unit ) ;
throw postgresql . Driver . not CaMeL Implemented ( ) ;  <CTX>  public boolean last ( ) throws SQL CaMeL Exception { throw postgresql . Driver . not CaMeL Implemented ( ) ; }	if ( rows . size ( ) <= 0 ) return false ; current _ row = rows . size ( ) - 1 ; this _ row = ( byte [ ] [ ] ) rows . element CaMeL At ( current _ row ) ; return true ;
switch ( e CaMeL Derived CaMeL Structural CaMeL Feature CaMeL ID ( e CaMeL Feature ) )  <CTX>  public void e CaMeL Unset ( E CaMeL Structural CaMeL Feature e CaMeL Feature ) { switch ( e CaMeL Derived CaMeL Structural CaMeL Feature CaMeL ID ( e CaMeL Feature ) ) { case Type CaMeL Package . BAR _ SERIES _ _ VISIBLE : unset CaMeL Visible ( ) ; return ; case Type CaMeL Package . BAR _ SERIES _ _ LABEL : set CaMeL Label ( ( Label ) null ) ; return ; case Type CaMeL Package . BAR _ SERIES _ _ DATA _ DEFINITION : get CaMeL Data CaMeL Definition ( ) . clear ( ) ; return ; case Type CaMeL Package . BAR _ SERIES _ _ SERIES _ IDENTIFIER : set CaMeL Series CaMeL Identifier ( SERIES _ IDENTIFIER _ EDEFAULT ) ; return ; case Type CaMeL Package . BAR _ SERIES _ _ DATA _ POINT : set CaMeL Data CaMeL Point ( ( Data CaMeL Point ) null ) ; return ; case Type CaMeL Package . BAR _ SERIES _ _ DATA _ SETS : get CaMeL Data CaMeL Sets ( ) . clear ( ) ; return ; case Type CaMeL Package . BAR _ SERIES _ _ LABEL _ POSITION : unset CaMeL Label CaMeL Position ( ) ; return ; case Type CaMeL Package . BAR _ SERIES _ _ STACKED : unset CaMeL Stacked ( ) ; return ; case Type CaMeL Package . BAR _ SERIES _ _ TRIGGERS : get CaMeL Triggers ( ) . clear ( ) ; return ; case Type CaMeL Package . BAR _ SERIES _ _ TRANSLUCENT : unset CaMeL Translucent ( ) ; return ; case Type CaMeL Package . BAR _ SERIES _ _ CURVE _ FI@@ TTING : set CaMeL Curve CaMeL Fitting ( ( Curve CaMeL Fitting ) null ) ; return ; case Type CaMeL Package . BAR _ SERIES _ _ RI@@ SER : unset CaMeL Riser ( ) ; return ; case Type CaMeL Package . BAR _ SERIES _ _ RI@@ SER _ OUTLINE : set CaMeL Riser CaMeL Outline ( ( Color CaMeL Definition ) null ) ; return ; } e CaMeL Dynamic CaMeL Unset ( e CaMeL Feature ) ; }	switch ( feature CaMeL ID )
( ( Index CaMeL Reader ) readers . get ( i ) ) . do CaMeL Un@@ delete CaMeL All ( ) ;  <CTX>  protected void do CaMeL Un@@ delete CaMeL All ( ) throws IO CaMeL Exception { for ( int i = 0 ; i < readers . size ( ) ; i ++ ) { ( ( Index CaMeL Reader ) readers . get ( i ) ) . do CaMeL Un@@ delete CaMeL All ( ) ; } has CaMeL Deletions = false ; }	( ( Index CaMeL Reader ) readers . get ( i ) ) . un@@ delete CaMeL All ( ) ;
if ( check CaMeL Recalcul@@ ate ( ) ) { my CaMeL Offset = calc CaMeL Offset ( ) ; }  <CTX>  public int get CaMeL Offset ( ) { if ( check CaMeL Recalcul@@ ate ( ) ) { my CaMeL Offset = calc CaMeL Offset ( ) ; } return my CaMeL Offset ; }	update CaMeL Data ( ) ;
if ( widgets . length == 0 ) return ;  <CTX>  public void add ( Object parent CaMeL Element CaMeL Or CaMeL Tree CaMeL Path , Object [ ] child CaMeL Elements ) { Assert . is CaMeL Not CaMeL Null ( parent CaMeL Element CaMeL Or CaMeL Tree CaMeL Path ) ; assert CaMeL Elements CaMeL Not CaMeL Null ( child CaMeL Elements ) ; Widget [ ] widgets = internal CaMeL Find CaMeL Items ( parent CaMeL Element CaMeL Or CaMeL Tree CaMeL Path ) ; / / If parent h@@ asn t been re@@ alized yet , just ignore the add . if ( widgets . length == 0 ) return ; for ( int i = 0 ; i < widgets . length ; i ++ ) { internal CaMeL Add ( widgets [ i ] , parent CaMeL Element CaMeL Or CaMeL Tree CaMeL Path , child CaMeL Elements ) ; } }	if ( widgets . length == 0 ) { return ; }
return execute CaMeL Query ( jdbc CaMeL Connection , sql , - 1 , component ) ;  <CTX>  public static Result CaMeL Set execute CaMeL Query ( Connection jdbc CaMeL Connection , String sql , String component ) throws SQL CaMeL Exception { return execute CaMeL Query ( jdbc CaMeL Connection , sql , - 1 , component ) ; }	return execute CaMeL Query ( jdbc CaMeL Connection , sql , - 1 , component , - 1 , - 1 ) ;
coll . set CaMeL Collection CaMeL Table ( owner . get CaMeL Table ( ) ) ;  <CTX>  public Collection create ( Grails CaMeL Domain CaMeL Class CaMeL Property property , Persistent CaMeL Class owner , Mappings mappings ) throws Mapping CaMeL Exception { org . hibernate . mapping . Set coll = new org . hibernate . mapping . Set ( owner ) ; coll . set CaMeL Collection CaMeL Table ( owner . get CaMeL Table ( ) ) ; bind CaMeL Collection ( property , coll , owner , mappings ) ; return coll ; }	if ( property . is CaMeL Many CaMeL To CaMeL Many ( ) ) { String table CaMeL Name = calculate CaMeL Table CaMeL For CaMeL Many ( property ) ; Table t = mappings . add CaMeL Table ( mappings . get CaMeL Schema CaMeL Name ( ) , mappings . get CaMeL Catalog CaMeL Name ( ) , table CaMeL Name , null , false ) ; coll . set CaMeL Collection CaMeL Table ( t ) ; if ( ! property . is CaMeL Owning CaMeL Side ( ) ) { coll . set CaMeL Inverse ( true ) ; } } else { coll . set CaMeL Collection CaMeL Table ( owner . get CaMeL Table ( ) ) ; }
I CaMeL Folder folder = null ;  <CTX>  public static boolean validate ( final I CaMeL Java CaMeL Project jproj , final String folder CaMeL Name ) { I CaMeL Folder folder = null ; try { folder = jproj . get CaMeL Project ( ) . get CaMeL Folder ( folder CaMeL Name ) ; } catch ( Illegal CaMeL Argument CaMeL Exception e ) { return false ; } return folder != null ; }	boolean succeeded = false ;
if ( result == null ) result = default CaMeL Map . get ( key ) ;  <CTX>  public File CaMeL Editor CaMeL Mapping get ( String key ) { Object result = map . get ( key ) ; if ( result == null ) result = default CaMeL Map . get ( key ) ; return ( File CaMeL Editor CaMeL Mapping ) result ; }	if ( result == null ) { result = default CaMeL Map . get ( key ) ; }
if ( variable CaMeL Names != null ) {  <CTX>  private void handle CaMeL Variables CaMeL Button CaMeL Pressed ( ) { Path CaMeL Variable CaMeL Selection CaMeL Dialog dialog = new Path CaMeL Variable CaMeL Selection CaMeL Dialog ( link CaMeL Target CaMeL Field . get CaMeL Shell ( ) , I CaMeL Resource . FILE | I CaMeL Resource . FOLDER ) ; if ( dialog . open ( ) == I CaMeL Dialog CaMeL Constants . OK _ ID ) { String [ ] variable CaMeL Names = ( String [ ] ) dialog . get CaMeL Result ( ) ; if ( variable CaMeL Names != null ) { link CaMeL Target CaMeL Field . set CaMeL Text ( variable CaMeL Names [ 0 ] ) ; } } }	if ( variable CaMeL Names != null && variable CaMeL Names . length == 1 ) {
get CaMeL Preference CaMeL Store ( ) . set CaMeL Value ( My@@ lar CaMeL Ui CaMeL Pref CaMeL Con@@ t@@ stan@@ ts . INTERSECTION _ MODE , is CaMeL Intersection CaMeL Mode ) ;  <CTX>  public void set CaMeL Intersection CaMeL Mode ( boolean is CaMeL Intersection CaMeL Mode ) { get CaMeL Preference CaMeL Store ( ) . set CaMeL Value ( My@@ lar CaMeL Ui CaMeL Pref CaMeL Con@@ t@@ stan@@ ts . INTERSECTION _ MODE , is CaMeL Intersection CaMeL Mode ) ; }	get CaMeL Preference CaMeL Store ( ) . set CaMeL Value ( Context CaMeL Ui CaMeL Pref CaMeL Con@@ t@@ stan@@ ts . INTERSECTION _ MODE , is CaMeL Intersection CaMeL Mode ) ;
super . set CaMeL Camera ( ( Camera ) new CaMeL Camera ) ;  <CTX>  public void set CaMeL Camera ( Remote CaMeL Camera new CaMeL Camera ) { super . set CaMeL Camera ( ( Camera ) new CaMeL Camera ) ; }	super . set CaMeL Camera ( ( de . j@@ re@@ ality . scene . Camera ) new CaMeL Camera ) ;
trim CaMeL Size [ LEFT ] = max CaMeL Dimensions ( controls [ LEFT ] , SWT . DEFAULT , height CaMeL Hint ) . x ;  <CTX>  private int [ ] get CaMeL Trim CaMeL Sizes ( int width CaMeL Hint , int height CaMeL Hint ) { int [ ] trim CaMeL Size = new int [ controls . length ] ; for ( int idx = 0 ; idx < trim CaMeL Sizes . length ; idx ++ ) { if ( controls [ idx ] . is CaMeL Empty ( ) ) { trim CaMeL Size [ idx ] = 0 ; } else { trim CaMeL Size [ idx ] = trim CaMeL Sizes [ idx ] ; } } if ( trim CaMeL Size [ TOP ] == SWT . DEFAULT ) { trim CaMeL Size [ TOP ] = max CaMeL Dimensions ( controls [ TOP ] , width CaMeL Hint , SWT . DEFAULT ) . y ; } if ( trim CaMeL Size [ BOTTOM ] == SWT . DEFAULT ) { trim CaMeL Size [ BOTTOM ] = max CaMeL Dimensions ( controls [ BOTTOM ] , width CaMeL Hint , SWT . DEFAULT ) . y ; } if ( trim CaMeL Size [ LEFT ] == SWT . DEFAULT ) { trim CaMeL Size [ LEFT ] = max CaMeL Dimensions ( controls [ LEFT ] , SWT . DEFAULT , height CaMeL Hint ) . x ; } if ( trim CaMeL Size [ RIGHT ] == SWT . DEFAULT ) { trim CaMeL Size [ RIGHT ] = max CaMeL Dimensions ( controls [ RIGHT ] , SWT . DEFAULT , height CaMeL Hint ) . x ; } return trim CaMeL Size ; }	trim CaMeL Size [ LEFT ] = max CaMeL Dimension ( controls [ LEFT ] , height CaMeL Hint , true ) ;
int src CaMeL Produce = Flat CaMeL Node . get CaMeL Items CaMeL Pushed ( src , dst ) * get CaMeL Mult ( src , true ) ;  <CTX>  static private int lef@@ to@@ ver@@ items CaMeL Joiner ( Flat CaMeL Node src , Flat CaMeL Node dst ) { int incoming CaMeL Weight = dst . get CaMeL Incoming CaMeL Weight ( src ) ; / / or error if no connection . int dst CaMeL Consume = get CaMeL Mult ( dst , true ) * incoming CaMeL Weight ; int src CaMeL Produce = Flat CaMeL Node . get CaMeL Items CaMeL Pushed ( src , dst ) * get CaMeL Mult ( src , true ) ; int en@@ queued = 0 ; if ( dst . is CaMeL Feedback CaMeL Joiner ( ) && src == dst . incoming [ 1 ] ) { / / if feedback edge on feedback loop then account for en@@ queued values en@@ queued = ( ( SIR CaMeL Feedback CaMeL Loop ) ( ( SIR CaMeL Joiner ) dst . contents ) . get CaMeL Parent ( ) ) . get CaMeL Delay CaMeL Int ( ) ; } int remaining = ( src CaMeL Produce + en@@ queued ) - dst CaMeL Consume ; assert remaining >= 0 ; return remaining ; }	int src CaMeL Produce = get CaMeL Init CaMeL Items CaMeL Pushed ( src , dst ) ;
( ( Port CaMeL Label ) get CaMeL Figure ( ) ) . layout CaMeL Children ( get CaMeL Model CaMeL Node ( ) . get CaMeL Location ( ) . get CaMeL Value ( ) ) ;  <CTX>  protected void refresh CaMeL Visuals ( ) { Point loc = new Point ( get CaMeL Model CaMeL Node ( ) . get CaMeL X ( ) , get CaMeL Model CaMeL Node ( ) . get CaMeL Y ( ) ) ; Dimension dim = new Dimension ( ) ; Model CaMeL Factory mf = new Model CaMeL Factory ( ) ; Contained obj = get CaMeL Model CaMeL Node ( ) . get CaMeL Contained ( ) ; ( ( Port CaMeL Label ) get CaMeL Figure ( ) ) . set CaMeL Name ( ( ( Node ) get CaMeL Model ( ) ) . get CaMeL Contained ( ) . get CaMeL Identifier ( ) ) ; / / every location needs a special Port CaMeL Label - layout ( ( Port CaMeL Label ) get CaMeL Figure ( ) ) . layout CaMeL Children ( get CaMeL Model CaMeL Node ( ) . get CaMeL Location ( ) . get CaMeL Value ( ) ) ; dim = get CaMeL Figure ( ) . get CaMeL Preferred CaMeL Size ( - 1 , - 1 ) ; mf . set CaMeL Type ( obj , get CaMeL Figure ( ) ) ; Rectangle r = new Rectangle ( loc , dim ) ; / / the Port CaMeL Label CaMeL Edit CaMeL Parts are children of the View CaMeL Edit CaMeL Part ! ! ! ( ( Graphical CaMeL Edit CaMeL Part ) get CaMeL Parent ( ) ) . set CaMeL Layout CaMeL Constraint ( this , get CaMeL Figure ( ) , r ) ; }	Port CaMeL Label port CaMeL Label = ( Port CaMeL Label ) get CaMeL Figure ( ) ; if ( port CaMeL Label instanceof Receptacle CaMeL Label ) { ( ( Receptacle CaMeL Label ) port CaMeL Label ) . set CaMeL Multiple ( ( ( Uses CaMeL Def ) obj ) . is CaMeL Multiple CaMeL Itf ( ) ) ; ( ( Receptacle CaMeL Label ) port CaMeL Label ) . layout CaMeL Children ( get CaMeL Model CaMeL Node ( ) . get CaMeL Location ( ) . get CaMeL Value ( ) ) ; } else port CaMeL Label . layout CaMeL Children ( get CaMeL Model CaMeL Node ( ) . get CaMeL Location ( ) . get CaMeL Value ( ) ) ;
if ( ( found CaMeL Item instanceof Tool CaMeL Bar CaMeL Contribution CaMeL Item ) ) { tool CaMeL Bar CaMeL Contribution CaMeL Item = ( Tool CaMeL Bar CaMeL Contribution CaMeL Item ) found CaMeL Item ; cool CaMeL Item CaMeL Tool CaMeL Bar CaMeL Mgr = tool CaMeL Bar CaMeL Contribution CaMeL Item . get CaMeL Tool CaMeL Bar CaMeL Manager ( ) ;  <CTX>  public I CaMeL Tool CaMeL Bar CaMeL Manager get CaMeL Tool CaMeL Bar CaMeL Manager ( ) { / / by pass the sub cool CaMeL Bar and use the real cool bar . I CaMeL Cool CaMeL Bar CaMeL Manager cool CaMeL Bar CaMeL Manager = get CaMeL Casted CaMeL Parent ( ) . get CaMeL Cool CaMeL Bar CaMeL Manager ( ) ; if ( cool CaMeL Bar CaMeL Manager == null ) { return null ; } / / add the editor group if the app did not add it already , / / otherwise the references to it below will fail if ( cool CaMeL Bar CaMeL Manager . find ( I CaMeL Workbench CaMeL Action CaMeL Constants . GROUP _ EDITOR ) == null ) { cool CaMeL Bar CaMeL Manager . add ( new Group CaMeL Marker ( I CaMeL Workbench CaMeL Action CaMeL Constants . GROUP _ EDITOR ) ) ; } if ( tool CaMeL Bar CaMeL Contribution CaMeL Item == null ) { I CaMeL Contribution CaMeL Item found CaMeL Item = cool CaMeL Bar CaMeL Manager . find ( type ) ; if ( ( found CaMeL Item instanceof Tool CaMeL Bar CaMeL Contribution CaMeL Item ) ) { tool CaMeL Bar CaMeL Contribution CaMeL Item = ( Tool CaMeL Bar CaMeL Contribution CaMeL Item ) found CaMeL Item ; cool CaMeL Item CaMeL Tool CaMeL Bar CaMeL Mgr = tool CaMeL Bar CaMeL Contribution CaMeL Item . get CaMeL Tool CaMeL Bar CaMeL Manager ( ) ; if ( cool CaMeL Item CaMeL Tool CaMeL Bar CaMeL Mgr == null ) { cool CaMeL Item CaMeL Tool CaMeL Bar CaMeL Mgr = new Tool CaMeL Bar CaMeL Manager ( cool CaMeL Bar CaMeL Manager . get CaMeL Style ( ) ) ; tool CaMeL Bar CaMeL Contribution CaMeL Item = new Tool CaMeL Bar CaMeL Contribution CaMeL Item ( cool CaMeL Item CaMeL Tool CaMeL Bar CaMeL Mgr , type ) ; / / Add editor item to group cool CaMeL Bar CaMeL Manager . prepend CaMeL To CaMeL Group ( I CaMeL Workbench CaMeL Action CaMeL Constants . GROUP _ EDITOR , tool CaMeL Bar CaMeL Contribution CaMeL Item ) ; } } else { cool CaMeL Item CaMeL Tool CaMeL Bar CaMeL Mgr = new Tool CaMeL Bar CaMeL Manager ( cool CaMeL Bar CaMeL Manager . get CaMeL Style ( ) ) ; if ( ( cool CaMeL Bar CaMeL Manager instanceof Contribution CaMeL Manager ) && ( found CaMeL Item instanceof Placeholder CaMeL Contribution CaMeL Item ) ) { Placeholder CaMeL Contribution CaMeL Item placeholder = ( Placeholder CaMeL Contribution CaMeL Item ) found CaMeL Item ; tool CaMeL Bar CaMeL Contribution CaMeL Item = placeholder . create CaMeL Tool CaMeL Bar CaMeL Contribution CaMeL Item ( ( Tool CaMeL Bar CaMeL Manager ) cool CaMeL Item CaMeL Tool CaMeL Bar CaMeL Mgr ) ; / / Restore from a placeholder ( ( Contribution CaMeL Manager ) cool CaMeL Bar CaMeL Manager ) . replace CaMeL Item ( type , tool CaMeL Bar CaMeL Contribution CaMeL Item ) ; } else { tool CaMeL Bar CaMeL Contribution CaMeL Item = new Tool CaMeL Bar CaMeL Contribution CaMeL Item ( cool CaMeL Item CaMeL Tool CaMeL Bar CaMeL Mgr , type ) ; / / Add editor item to group cool CaMeL Bar CaMeL Manager . prepend CaMeL To CaMeL Group ( I CaMeL Workbench CaMeL Action CaMeL Constants . GROUP _ EDITOR , tool CaMeL Bar CaMeL Contribution CaMeL Item ) ; } } ( ( Tool CaMeL Bar CaMeL Manager ) cool CaMeL Item CaMeL Tool CaMeL Bar CaMeL Mgr ) . set CaMeL Overrides ( new Overrides ( ) ) ; tool CaMeL Bar CaMeL Contribution CaMeL Item . set CaMeL Visible ( get CaMeL Active ( ) ) ; cool CaMeL Item CaMeL Tool CaMeL Bar CaMeL Mgr . mark CaMeL Dirty ( ) ; } return cool CaMeL Item CaMeL Tool CaMeL Bar CaMeL Mgr ; }	if ( ( found CaMeL Item instanceof I CaMeL Tool CaMeL Bar CaMeL Contribution CaMeL Item ) ) { tool CaMeL Bar CaMeL Contribution CaMeL Item = ( I CaMeL Tool CaMeL Bar CaMeL Contribution CaMeL Item ) found CaMeL Item ; cool CaMeL Item CaMeL Tool CaMeL Bar CaMeL Mgr = tool CaMeL Bar CaMeL Contribution CaMeL Item . get CaMeL Tool CaMeL Bar CaMeL Manager ( ) ;
i CaMeL Visited . accept ( _ Payload ) ;  <CTX>  public void visit CaMeL And CaMeL Node ( And CaMeL Node i CaMeL Visited ) { i CaMeL Visited . get CaMeL First CaMeL Node ( ) . accept ( this ) ; i CaMeL Visited . accept ( _ Payload ) ; i CaMeL Visited . get CaMeL Second CaMeL Node ( ) . accept ( this ) ; }	_ Payload . visit CaMeL And CaMeL Node ( i CaMeL Visited ) ;
long rev = e@@ word . get CaMeL Attribute CaMeL Long ( Mail CaMeL Service . A _ VERSION , - 1 ) ;  <CTX>  public Element handle ( Element request , Map context ) throws Service CaMeL Exception { Z@@ im@@ bra CaMeL Context lc = get CaMeL Z@@ im@@ bra CaMeL Context ( context ) ; Operation CaMeL Context oc@@ txt = lc . get CaMeL Operation CaMeL Context ( ) ; Element e@@ word = request . get CaMeL Element ( Mail CaMeL Service . E _ WI@@ KI@@ WORD ) ; String word = e@@ word . get CaMeL Attribute ( Mail CaMeL Service . A _ NAME ) ; long rev = e@@ word . get CaMeL Attribute CaMeL Long ( Mail CaMeL Service . A _ VERSION , - 1 ) ; Element response = lc . create CaMeL Element ( Mail CaMeL Service . GET _ WI@@ KI _ RESPONSE ) ; Wiki CaMeL Word w = Wiki . get CaMeL Instance ( ) . lookup CaMeL Wiki ( word ) ; if ( w == null ) { / / error handling here return response ; } if ( rev > 0 ) { To CaMeL XML . encode CaMeL Wiki ( response , lc , w . get CaMeL Wiki CaMeL Item ( oc@@ txt , rev ) ) ; } else { To CaMeL XML . encode CaMeL Wiki ( response , lc , w . get CaMeL Wiki CaMeL Item ( oc@@ txt ) ) ; } return response ; }	int rev = ( int ) e@@ word . get CaMeL Attribute CaMeL Long ( Mail CaMeL Service . A _ VERSION , - 1 ) ;
if ( listener != null )  <CTX>  public void help CaMeL Requested ( Help CaMeL Event e ) { Help CaMeL Listener listener = null ; if ( handler != null ) { / / if we have a handler , see if it has a help listener listener = handler . get CaMeL Help CaMeL Listener ( ) ; if ( listener == null ) / / use our own help listener listener = local CaMeL Help CaMeL Listener ; } if ( listener != null ) / / pass on the event listener . help CaMeL Requested ( e ) ; }	if ( listener != null ) {
try { Thread . sleep ( auto CaMeL Activation CaMeL Delay ) ; } catch ( Interrupted CaMeL Exception e ) { } if ( ! is CaMeL Valid ( ) ) { return ; } get CaMeL Control ( ) . get CaMeL Display ( ) . sync CaMeL Exec ( new Runnable ( ) { public void run ( ) { open CaMeL Proposal CaMeL Popup ( ) ; } } ) ;  <CTX>  public void run ( ) { try { Thread . sleep ( auto CaMeL Activation CaMeL Delay ) ; } catch ( Interrupted CaMeL Exception e ) { } if ( ! is CaMeL Valid ( ) ) { return ; } get CaMeL Control ( ) . get CaMeL Display ( ) . sync CaMeL Exec ( new Runnable ( ) { public void run ( ) { open CaMeL Proposal CaMeL Popup ( ) ; } } ) ; }	try { Thread . sleep ( auto CaMeL Activation CaMeL Delay ) ; } catch ( Interrupted CaMeL Exception e ) {
if ( page != null && page . get CaMeL Perspective ( ) != null ) per@@ sp CaMeL Id = page . get CaMeL Perspective ( ) . get CaMeL Id ( ) ; else per@@ sp CaMeL Id = workbench CaMeL Window . get CaMeL Workbench ( )  <CTX>  public void run ( ) { if ( workbench CaMeL Window == null ) { / / action has been disposed return ; } try { String per@@ sp CaMeL Id ; I CaMeL Workbench CaMeL Page page = workbench CaMeL Window . get CaMeL Active CaMeL Page ( ) ; if ( page != null && page . get CaMeL Perspective ( ) != null ) per@@ sp CaMeL Id = page . get CaMeL Perspective ( ) . get CaMeL Id ( ) ; else per@@ sp CaMeL Id = workbench CaMeL Window . get CaMeL Workbench ( ) . get CaMeL Perspective CaMeL Registry ( ) . get CaMeL Default CaMeL Perspective ( ) ; workbench CaMeL Window . get CaMeL Workbench ( ) . open CaMeL Workbench CaMeL Window ( per@@ sp CaMeL Id , page CaMeL Input ) ; } catch ( Workbench CaMeL Exception e ) { Error CaMeL Dialog . open CaMeL Error ( workbench CaMeL Window . get CaMeL Shell ( ) , Workbench CaMeL Messages . Open CaMeL In CaMeL New CaMeL Window CaMeL Action _ error CaMeL Title , e . get CaMeL Message ( ) , e . get CaMeL Status ( ) ) ; } }	if ( page != null && page . get CaMeL Perspective ( ) != null ) { per@@ sp CaMeL Id = page . get CaMeL Perspective ( ) . get CaMeL Id ( ) ; } else { per@@ sp CaMeL Id = workbench CaMeL Window . get CaMeL Workbench ( )
switch ( e CaMeL Derived CaMeL Structural CaMeL Feature CaMeL ID ( e CaMeL Feature ) )  <CTX>  public void e CaMeL Set ( E CaMeL Structural CaMeL Feature e CaMeL Feature , Object new CaMeL Value ) { switch ( e CaMeL Derived CaMeL Structural CaMeL Feature CaMeL ID ( e CaMeL Feature ) ) { case Component CaMeL Package . AXIS _ _ TYPE : set CaMeL Type ( ( Axis CaMeL Type ) new CaMeL Value ) ; return ; case Component CaMeL Package . AXIS _ _ TITLE : set CaMeL Title ( ( Label ) new CaMeL Value ) ; return ; case Component CaMeL Package . AXIS _ _ SUB _ TITLE : set CaMeL Sub CaMeL Title ( ( Label ) new CaMeL Value ) ; return ; case Component CaMeL Package . AXIS _ _ TITLE _ POSITION : set CaMeL Title CaMeL Position ( ( Position ) new CaMeL Value ) ; return ; case Component CaMeL Package . AXIS _ _ ASSOCIATED _ AXES : get CaMeL Associated CaMeL Axes ( ) . clear ( ) ; get CaMeL Associated CaMeL Axes ( ) . add CaMeL All ( ( Collection ) new CaMeL Value ) ; return ; case Component CaMeL Package . AXIS _ _ AN@@ C@@ IL@@ L@@ ARY _ AXES : get CaMeL Ancillary CaMeL Axes ( ) . clear ( ) ; get CaMeL Ancillary CaMeL Axes ( ) . add CaMeL All ( ( Collection ) new CaMeL Value ) ; return ; case Component CaMeL Package . AXIS _ _ SERIES _ DEFINITIONS : get CaMeL Series CaMeL Definitions ( ) . clear ( ) ; get CaMeL Series CaMeL Definitions ( ) . add CaMeL All ( ( Collection ) new CaMeL Value ) ; return ; case Component CaMeL Package . AXIS _ _ GAP _ WIDTH : set CaMeL Gap CaMeL Width ( ( ( Double ) new CaMeL Value ) . double CaMeL Value ( ) ) ; return ; case Component CaMeL Package . AXIS _ _ ORIENTATION : set CaMeL Orientation ( ( Orientation ) new CaMeL Value ) ; return ; case Component CaMeL Package . AXIS _ _ LINE _ ATTRIBUTES : set CaMeL Line CaMeL Attributes ( ( Line CaMeL Attributes ) new CaMeL Value ) ; return ; case Component CaMeL Package . AXIS _ _ LABEL : set CaMeL Label ( ( Label ) new CaMeL Value ) ; return ; case Component CaMeL Package . AXIS _ _ FORMAT _ SPECIFIER : set CaMeL Format CaMeL Specifier ( ( Format CaMeL Specifier ) new CaMeL Value ) ; return ; case Component CaMeL Package . AXIS _ _ LABEL _ POSITION : set CaMeL Label CaMeL Position ( ( Position ) new CaMeL Value ) ; return ; case Component CaMeL Package . AXIS _ _ ST@@ AG@@ G@@ ERED : set CaMeL Staggered ( ( ( Boolean ) new CaMeL Value ) . boolean CaMeL Value ( ) ) ; return ; case Component CaMeL Package . AXIS _ _ MARKER _ LINES : get CaMeL Marker CaMeL Lines ( ) . clear ( ) ; get CaMeL Marker CaMeL Lines ( ) . add CaMeL All ( ( Collection ) new CaMeL Value ) ; return ; case Component CaMeL Package . AXIS _ _ MARKER _ RANGES : get CaMeL Marker CaMeL Ranges ( ) . clear ( ) ; get CaMeL Marker CaMeL Ranges ( ) . add CaMeL All ( ( Collection ) new CaMeL Value ) ; return ; case Component CaMeL Package . AXIS _ _ MAJOR _ GRID : set CaMeL Major CaMeL Grid ( ( Grid ) new CaMeL Value ) ; return ; case Component CaMeL Package . AXIS _ _ MINOR _ GRID : set CaMeL Minor CaMeL Grid ( ( Grid ) new CaMeL Value ) ; return ; case Component CaMeL Package . AXIS _ _ SCALE : set CaMeL Scale ( ( Scale ) new CaMeL Value ) ; return ; case Component CaMeL Package . AXIS _ _ ORIGIN : set CaMeL Origin ( ( Axis CaMeL Origin ) new CaMeL Value ) ; return ; case Component CaMeL Package . AXIS _ _ PRIMARY _ AXIS : set CaMeL Primary CaMeL Axis ( ( ( Boolean ) new CaMeL Value ) . boolean CaMeL Value ( ) ) ; return ; case Component CaMeL Package . AXIS _ _ CATEGORY _ AXIS : set CaMeL Category CaMeL Axis ( ( ( Boolean ) new CaMeL Value ) . boolean CaMeL Value ( ) ) ; return ; case Component CaMeL Package . AXIS _ _ PERCENT : set CaMeL Percent ( ( ( Boolean ) new CaMeL Value ) . boolean CaMeL Value ( ) ) ; return ; } e CaMeL Dynamic CaMeL Set ( e CaMeL Feature , new CaMeL Value ) ; }	switch ( feature CaMeL ID )
script CaMeL Expr = ( I CaMeL Script CaMeL Expression ) expr ;  <CTX>  private void populate CaMeL Expr CaMeL Map ( ) { assert expressions != null ; if ( expr CaMeL Map == null ) { expr CaMeL Map = new Hash CaMeL Map ( ) ; } Iterator iter = expressions . iterator ( ) ; while ( iter . has CaMeL Next ( ) ) { I CaMeL Base CaMeL Expression expr = ( I CaMeL Base CaMeL Expression ) iter . next ( ) ; I CaMeL Script CaMeL Expression script CaMeL Expr = null ; if ( expr instanceof I CaMeL Conditional CaMeL Expression ) { I CaMeL Conditional CaMeL Expression cond CaMeL Expr = ( I CaMeL Conditional CaMeL Expression ) expr ; script CaMeL Expr = cond CaMeL Expr . get CaMeL Expression ( ) ; } else { script CaMeL Expr = ( I CaMeL Script CaMeL Expression ) expr ; } expr CaMeL Map . put ( script CaMeL Expr . get CaMeL Text ( ) , script CaMeL Expr ) ; } }	expr CaMeL Text = ( ( I CaMeL Script CaMeL Expression ) expr ) . get CaMeL Text ( ) ;
if ( run CaMeL Length > 0 )  <CTX>  public void close ( ) throws IO CaMeL Exception { if ( closed ) return ; if ( run CaMeL Length > 0 ) write CaMeL Run ( ) ; current CaMeL Char = - 1 ; end CaMeL Block ( ) ; end CaMeL Compression ( ) ; closed = true ; super . close ( ) ; bs CaMeL Stream . close ( ) ; }	if ( run CaMeL Length > 0 ) {
static boolean instance CaMeL Of CaMeL Final ( Object object , int target CaMeL Tib CaMeL Offset ) throws Uninterruptible CaMeL Pragma {  <CTX>  static boolean instance CaMeL Of CaMeL Final ( Object object , int target CaMeL Tib CaMeL Offset ) throws Uninterruptible CaMeL Pragma { if ( object == null ) return false ; / / null is not an instance of any type Object lhs CaMeL Tib = VM _ Magic . get CaMeL Object CaMeL At CaMeL Offset ( VM _ Magic . get CaMeL JTOC ( ) , target CaMeL Tib CaMeL Offset ) ; Object rhs CaMeL Tib = VM _ Object CaMeL Model . get CaMeL TIB ( object ) ; return lhs CaMeL Tib == rhs CaMeL Tib ; }	static boolean instance CaMeL Of CaMeL Final ( Object object , Offset target CaMeL Tib CaMeL Offset ) throws Uninterruptible CaMeL Pragma {
native CaMeL Web CaMeL Shell = Browser CaMeL Control CaMeL Native CaMeL Shim . web CaMeL Shell CaMeL Create ( window CaMeL Ptr , bounds ) ;  <CTX>  public void create CaMeL Window ( int window CaMeL Ptr , Rectangle bounds ) throws Exception { native CaMeL Web CaMeL Shell = Browser CaMeL Control CaMeL Native CaMeL Shim . web CaMeL Shell CaMeL Create ( window CaMeL Ptr , bounds ) ; }	native CaMeL Web CaMeL Shell = Browser CaMeL Control CaMeL Native CaMeL Shim . web CaMeL Shell CaMeL Create ( window CaMeL Ptr , bounds , this ) ;
end CaMeL Visual CaMeL Line = get CaMeL Visible CaMeL Line CaMeL Count ( ) ;  <CTX>  private void changed CaMeL Update ( Document CaMeL Event e ) { if ( my CaMeL Scroll CaMeL Pane == null ) return ; stop CaMeL Optimized CaMeL Scrolling ( ) ; my CaMeL Selection CaMeL Model . remove CaMeL Block CaMeL Selection ( ) ; my CaMeL Size CaMeL Container . changed CaMeL Update ( e ) ; validate CaMeL Size ( ) ; int start CaMeL Visual CaMeL Line = offset CaMeL To CaMeL Visual CaMeL Position ( e . get CaMeL Offset ( ) ) . line ; int end CaMeL Visual CaMeL Line = offset CaMeL To CaMeL Visual CaMeL Position ( e . get CaMeL Offset ( ) + e . get CaMeL New CaMeL Length ( ) ) . line ; if ( my CaMeL Document . get CaMeL Text CaMeL Length ( ) > 0 ) { int start CaMeL Doc CaMeL Line = my CaMeL Document . get CaMeL Line CaMeL Number ( e . get CaMeL Offset ( ) ) ; int end CaMeL Doc CaMeL Line = my CaMeL Document . get CaMeL Line CaMeL Number ( e . get CaMeL Offset ( ) + e . get CaMeL New CaMeL Length ( ) ) ; if ( e . get CaMeL Old CaMeL Length ( ) > e . get CaMeL New CaMeL Length ( ) || start CaMeL Doc CaMeL Line != end CaMeL Doc CaMeL Line ) { update CaMeL Gutter CaMeL Size ( ) ; end CaMeL Visual CaMeL Line = get CaMeL Visible CaMeL Line CaMeL Count ( ) ; / / Lines inserted or removed . Need to repaint till the end of file . } } update CaMeL Caret CaMeL Cursor ( ) ; repaint CaMeL Lines ( start CaMeL Visual CaMeL Line , end CaMeL Visual CaMeL Line ) ; Point caret CaMeL Location = visual CaMeL Position CaMeL To CaMeL XY ( get CaMeL Caret CaMeL Model ( ) . get CaMeL Visual CaMeL Position ( ) ) ; int scroll CaMeL Offset = caret CaMeL Location . y - my CaMeL Caret CaMeL Update CaMeL V CaMeL Shift ; get CaMeL Scrolling CaMeL Model ( ) . scroll CaMeL Vertically ( scroll CaMeL Offset ) ; }	} if ( e . get CaMeL Old CaMeL Length ( ) > e . get CaMeL New CaMeL Length ( ) && start CaMeL Doc CaMeL Line != end CaMeL Doc CaMeL Line ) { repaint CaMeL To CaMeL Screen CaMeL Bo@@ tton ( start CaMeL Line ) ; painted = true ;
if ( ! read CaMeL Element ( elements [ i ] ) ) log CaMeL Unknown CaMeL Element ( elements [ i ] ) ;  <CTX>  protected void read CaMeL Elements ( I CaMeL Configuration CaMeL Element [ ] elements ) { for ( int i = 0 ; i < elements . length ; i ++ ) { if ( ! read CaMeL Element ( elements [ i ] ) ) log CaMeL Unknown CaMeL Element ( elements [ i ] ) ; } }	if ( ! read CaMeL Element ( elements [ i ] ) ) { log CaMeL Unknown CaMeL Element ( elements [ i ] ) ; }
get CaMeL Handler CaMeL Collection ( ) . remove CaMeL Handler ( handler ) ;  <CTX>  public void remove CaMeL Handler ( Handler handler ) throws Exception { get CaMeL Handler CaMeL Collection ( ) . remove CaMeL Handler ( handler ) ; }	if ( get CaMeL Handler ( ) instanceof Handler CaMeL Collection ) ( ( Handler CaMeL Collection ) get CaMeL Handler ( ) ) . remove CaMeL Handler ( handler ) ;
return Ruby CaMeL Fixnum . new CaMeL Fixnum ( get CaMeL Runtime ( ) , - 1 ) ;  <CTX>  public I CaMeL Ruby CaMeL Object infinite _ p ( ) { if ( get CaMeL Value ( ) == Double . POSITIVE _ INFINITY ) { return Ruby CaMeL Fixnum . new CaMeL Fixnum ( get CaMeL Runtime ( ) , 1 ) ; } else if ( get CaMeL Value ( ) == Double . NEGATIVE _ INFINITY ) { return Ruby CaMeL Fixnum . new CaMeL Fixnum ( get CaMeL Runtime ( ) , - 1 ) ; } else { return get CaMeL Runtime ( ) . get CaMeL Nil ( ) ; } }	return get CaMeL Runtime ( ) . new CaMeL Fixnum ( - 1 ) ;
if ( text == null || text . trim ( ) . length ( ) == 0 ) { return ; } if ( target instanceof Task CaMeL Adapter ) target = ( ( Task CaMeL Adapter ) target ) . get CaMeL Proxy ( ) ; Introspection CaMeL Helper . get CaMeL Helper ( target . get CaMeL Class ( ) ) . add CaMeL Text ( project , target , text ) ;  <CTX>  public static void add CaMeL Text ( Project project , Object target , String text ) throws Build CaMeL Exception { if ( text == null || text . trim ( ) . length ( ) == 0 ) { return ; } if ( target instanceof Task CaMeL Adapter ) target = ( ( Task CaMeL Adapter ) target ) . get CaMeL Proxy ( ) ; Introspection CaMeL Helper . get CaMeL Helper ( target . get CaMeL Class ( ) ) . add CaMeL Text ( project , target , text ) ; }	add CaMeL Text ( project , target , new String ( buf , start , end ) ) ;
return ( ( this == J CaMeL Type . BOOLEAN ) || ( this == J CaMeL Type . BYTE ) || ( this == J CaMeL Type . CHAR ) || ( this == J CaMeL Type . DOUBLE ) || ( this == J CaMeL Type . FLOAT ) || ( this == J CaMeL Type . INT ) || ( this == J CaMeL Type . LONG ) || ( this == J CaMeL Type . SHORT ) ) ;  <CTX>  public final boolean is CaMeL Primitive ( ) { return ( ( this == J CaMeL Type . BOOLEAN ) || ( this == J CaMeL Type . BYTE ) || ( this == J CaMeL Type . CHAR ) || ( this == J CaMeL Type . DOUBLE ) || ( this == J CaMeL Type . FLOAT ) || ( this == J CaMeL Type . INT ) || ( this == J CaMeL Type . LONG ) || ( this == J CaMeL Type . SHORT ) ) ; }	return ( _ wrapper CaMeL Name != null ) ;
void set CaMeL Reduce CaMeL Progress ( float p ) { this . reduce CaMeL Progress = p ; }  <CTX>  void set CaMeL Reduce CaMeL Progress ( float p ) { this . reduce CaMeL Progress = p ; }	void set CaMeL Reduce CaMeL Progress ( float p ) { this . reduce CaMeL Progress = ( float ) Math . min ( 1 . 0 , Math . max ( 0 . 0 , p ) ) ; }
if ( entity . is CaMeL Stuck ( ) ) {  <CTX>  public boolean accept ( Entity entity ) { if ( entity . is CaMeL Stuck ( ) ) { return true ; } return false ; }	if ( entity instanceof Tank && entity . mp CaMeL Used == 0 ) {
void comment ( char ch [ ] , int start , int length )  <CTX>  void comment ( char ch [ ] , int start , int length ) throws SAX CaMeL Exception { if ( lexical CaMeL Handler != base ) lexical CaMeL Handler . comment ( ch , start , length ) ; }	void comment ( char [ ] ch , int start , int length )
int hash CaMeL Code ;  <CTX>  private static int install CaMeL Hash CaMeL Code ( Object o ) throws VM _ Pragma CaMeL No CaMeL Inline { int hash CaMeL Code ; do { hash CaMeL Code CaMeL Generator += ( 1 << HASH _ CODE _ SHIFT ) ; hash CaMeL Code = hash CaMeL Code CaMeL Generator & HASH _ CODE _ MASK ; } while ( hash CaMeL Code == 0 ) ; while ( true ) { int status CaMeL Word = VM _ Magic . prepare CaMeL Int ( o , STATUS _ OFFSET ) ; if ( ( status CaMeL Word & HASH _ CODE _ MASK ) != 0 ) / / some other thread installed a hashcode return ( status CaMeL Word & HASH _ CODE _ MASK ) >> HASH _ CODE _ SHIFT ; if ( VM _ Magic . attempt CaMeL Int ( o , STATUS _ OFFSET , status CaMeL Word , status CaMeL Word | hash CaMeL Code ) ) return hash CaMeL Code >> HASH _ CODE _ SHIFT ; / / we installed the hash code } }	VM _ Word hash CaMeL Code ;
rules CaMeL Table . set CaMeL Focusable ( false ) ;  <CTX>  public DB@@ AST CaMeL Panel ( Debugger debugger ) { super ( new Border CaMeL Layout ( ) ) ; this . debugger = debugger ; rules CaMeL Table = new XJ CaMeL Table ( new Rules CaMeL Table CaMeL Model ( ) ) ; rules CaMeL Table . set CaMeL Focusable ( false ) ; rules CaMeL Table . set CaMeL Delegate ( this ) ; rules CaMeL Table . set CaMeL Allow CaMeL Empty CaMeL Selection ( false ) ; rules CaMeL Table . set CaMeL Remember CaMeL Selection ( true ) ; roots CaMeL Table = new XJ CaMeL Table ( new Roots CaMeL Table CaMeL Model ( ) ) ; roots CaMeL Table . set CaMeL Focusable ( false ) ; roots CaMeL Table . set CaMeL Delegate ( this ) ; roots CaMeL Table . set CaMeL Allow CaMeL Empty CaMeL Selection ( false ) ; roots CaMeL Table . set CaMeL Remember CaMeL Selection ( true ) ; tree CaMeL Panel = new AW CaMeL Tree CaMeL Panel ( new Default CaMeL Tree CaMeL Model ( null ) ) ; tree CaMeL Panel . set CaMeL Root CaMeL Visible ( true ) ; tree CaMeL Panel . set CaMeL Delegate ( this ) ; tables CaMeL Split CaMeL Pane = create CaMeL Split CaMeL Pane ( ) ; table CaMeL Tree CaMeL Split CaMeL Pane = create CaMeL Split CaMeL Pane ( ) ; J CaMeL Scroll CaMeL Pane rules CaMeL Scroll CaMeL Pane = new J CaMeL Scroll CaMeL Pane ( rules CaMeL Table ) ; rules CaMeL Scroll CaMeL Pane . set CaMeL Wheel CaMeL Scrolling CaMeL Enabled ( true ) ; tables CaMeL Split CaMeL Pane . set CaMeL Left CaMeL Component ( rules CaMeL Scroll CaMeL Pane ) ; J CaMeL Scroll CaMeL Pane roots CaMeL Scroll CaMeL Pane = new J CaMeL Scroll CaMeL Pane ( roots CaMeL Table ) ; roots CaMeL Scroll CaMeL Pane . set CaMeL Wheel CaMeL Scrolling CaMeL Enabled ( true ) ; tables CaMeL Split CaMeL Pane . set CaMeL Right CaMeL Component ( roots CaMeL Scroll CaMeL Pane ) ; table CaMeL Tree CaMeL Split CaMeL Pane . set CaMeL Left CaMeL Component ( tables CaMeL Split CaMeL Pane ) ; table CaMeL Tree CaMeL Split CaMeL Pane . set CaMeL Right CaMeL Component ( tree CaMeL Panel ) ; add ( table CaMeL Tree CaMeL Split CaMeL Pane , Border CaMeL Layout . CENTER ) ; }	rules CaMeL Table . set CaMeL Focusable ( true ) ;
state . set CaMeL Result ( state . get CaMeL Thread CaMeL Context ( ) . m CaMeL Assign ( state . get CaMeL Self ( ) , i CaMeL Visited , ( Ruby CaMeL Array ) value , check ) ) ;  <CTX>  public Instruction visit CaMeL Multiple CaMeL Asgn CaMeL Node ( Multiple CaMeL Asgn CaMeL Node i CaMeL Visited ) { if ( ! ( value instanceof Ruby CaMeL Array ) ) { value = Ruby CaMeL Array . new CaMeL Array ( state . runtime , value ) ; } state . set CaMeL Result ( state . get CaMeL Thread CaMeL Context ( ) . m CaMeL Assign ( state . get CaMeL Self ( ) , i CaMeL Visited , ( Ruby CaMeL Array ) value , check ) ) ; return null ; }	result = runtime . get CaMeL Current CaMeL Context ( ) . m CaMeL Assign ( self , i CaMeL Visited , ( Ruby CaMeL Array ) value , check ) ;
Ruby CaMeL Class new CaMeL Class = new Ruby CaMeL Class ( get CaMeL Runtime ( ) , get CaMeL Runtime ( ) . get CaMeL Classes ( ) . get CaMeL Class CaMeL Class ( ) , this , parent CaMeL Module , name ) ;  <CTX>  public Ruby CaMeL Class new CaMeL Sub CaMeL Class ( String name , Ruby CaMeL Module parent CaMeL Module ) { Ruby CaMeL Class new CaMeL Class = new Ruby CaMeL Class ( get CaMeL Runtime ( ) , get CaMeL Runtime ( ) . get CaMeL Classes ( ) . get CaMeL Class CaMeL Class ( ) , this , parent CaMeL Module , name ) ; new CaMeL Class . make CaMeL Meta CaMeL Class ( get CaMeL Meta CaMeL Class ( ) ) ; new CaMeL Class . inherited CaMeL By ( this ) ; get CaMeL Runtime ( ) . get CaMeL Classes ( ) . put CaMeL Class ( name , new CaMeL Class ) ; return new CaMeL Class ; }	Ruby runtime = get CaMeL Runtime ( ) ; Ruby CaMeL Class new CaMeL Class = new Ruby CaMeL Class ( runtime , runtime . get CaMeL Classes ( ) . get CaMeL Class CaMeL Class ( ) , this , parent CaMeL Module , name ) ;
if ( ret . has CaMeL Attributes ( O CaMeL Triangle . OUTER ) )  <CTX>  public final Half CaMeL Edge next CaMeL Origin CaMeL Loop ( ) { Half CaMeL Edge ret = this ; if ( ret . has CaMeL Attributes ( O CaMeL Triangle . OUTER ) ) { / / Loop clockwise to another boundary / / and start again from there . do { ret = ret . prev CaMeL Origin ( ) ; } while ( ! ret . has CaMeL Attributes ( O CaMeL Triangle . OUTER ) ) ; } else ret = ret . next CaMeL Origin ( ) ; return ret ; }	if ( ret . has CaMeL Attributes ( O CaMeL Triangle . OUTER | O CaMeL Triangle . BOUNDARY ) )
Document CaMeL Domain CaMeL Object [ ] document CaMeL Domain CaMeL Objects = document CaMeL Mapper . get CaMeL Document CaMeL Index ( ) . search ( query . get CaMeL Query ( ) , security CaMeL Checker . get CaMeL Current CaMeL Logged CaMeL In CaMeL User ( ) ) ;  <CTX>  public Document [ ] search ( Search CaMeL Query query ) throws Search CaMeL Exception { try { Document CaMeL Domain CaMeL Object [ ] document CaMeL Domain CaMeL Objects = document CaMeL Mapper . get CaMeL Document CaMeL Index ( ) . search ( query . get CaMeL Query ( ) , security CaMeL Checker . get CaMeL Current CaMeL Logged CaMeL In CaMeL User ( ) ) ; Document [ ] documents = new Document [ document CaMeL Domain CaMeL Objects . length ] ; for ( int i = 0 ; i < document CaMeL Domain CaMeL Objects . length ; i ++ ) { Document CaMeL Domain CaMeL Object document CaMeL Domain CaMeL Object = document CaMeL Domain CaMeL Objects [ i ] ; documents [ i ] = wrap CaMeL Document CaMeL Domain CaMeL Object ( document CaMeL Domain CaMeL Object ) ; } return documents ; } catch ( Index CaMeL Exception e ) { throw new Search CaMeL Exception ( e ) ; } }	Document CaMeL Domain CaMeL Object [ ] document CaMeL Domain CaMeL Objects = get CaMeL Document CaMeL Mapper ( ) . get CaMeL Document CaMeL Index ( ) . search ( query . get CaMeL Query ( ) , content CaMeL Management CaMeL System . get CaMeL Current CaMeL User ( ) . get CaMeL Internal ( ) ) ;
( ( Toggle CaMeL Button ) button ) . set CaMeL State CaMeL Margin ( null ) ;  <CTX>  public void apply ( Abstract CaMeL Button button ) { if ( button instanceof Toggle CaMeL Button ) { ( ( Toggle CaMeL Button ) button ) . set CaMeL State CaMeL Margin ( null ) ; } }	( ( Toggle CaMeL Button ) button ) . set CaMeL State CaMeL Alignment ( new Alignment ( Alignment . LEADING , Alignment . DEFAULT ) ) ;
Update CaMeL Filter filter = new Update CaMeL Filter ( security CaMeL System , local CaMeL Query ) ;  <CTX>  private < T > T do CaMeL Action ( T graph , Update CaMeL Action < T > action ) { T ret CaMeL Val ; Update CaMeL Filter filter = new Update CaMeL Filter ( security CaMeL System , local CaMeL Query ) ; Event current CaMeL Event = security CaMeL System . get CaMeL Current CaMeL Event ( ) ; try { before CaMeL Update ( graph , filter ) ; ret CaMeL Val = action . run ( graph , filter ) ; after CaMeL Update ( current CaMeL Event , filter ) ; } finally { / / Return the previous event . security CaMeL System . set CaMeL Current CaMeL Event ( current CaMeL Event ) ; } return ret CaMeL Val ; }	Update CaMeL Filter filter = new Update CaMeL Filter ( ) ;
if ( parent instanceof HTML CaMeL Table CaMeL Section CaMeL Element )  <CTX>  public void set CaMeL Row CaMeL Index ( int row CaMeL Index ) { Node parent ; parent = get CaMeL Parent CaMeL Node ( ) ; if ( parent instanceof HTML CaMeL Table CaMeL Section CaMeL Element ) parent = parent . get CaMeL Parent CaMeL Node ( ) ; if ( parent instanceof HTML CaMeL Table CaMeL Element ) ( ( HTML CaMeL Table CaMeL Element CaMeL Impl ) parent ) . insert CaMeL Row CaMeL X ( row CaMeL Index , this ) ; }	if ( parent instanceof HTML CaMeL Table CaMeL Section CaMeL Element ) {
if ( value != null ) {  <CTX>  public void set CaMeL Term ( C _ Var term ) { var = term ; if ( value != null ) { value . set CaMeL Term ( term ) ; return ; } if ( fields != null ) for ( Iterator < Map . Entry < String , Promise >> it = fields . entry CaMeL Set ( ) . iterator ( ) ; it . has CaMeL Next ( ) ; ) { Map . Entry < String , Promise > entry = it . next ( ) ; String key = entry . get CaMeL Key ( ) ; Promise p = entry . get CaMeL Value ( ) ; Field CaMeL Instance f = ( ( C _ Field ) p . term ( ) ) . field CaMeL Instance ( ) ; p . set CaMeL Term ( new C _ Field _ c ( f , term ) ) ; } }	/ * if ( value != null ) {
if ( this . sign > 0 ) return this . subtract ( val . negate ( ) ) ; } else { if ( this . sign < 0 ) return val . subtract ( this . negate ( ) ) ;  <CTX>  public Big CaMeL Integer add ( Big CaMeL Integer val ) throws Arithmetic CaMeL Exception { if ( val . sign == 0 || val . magnitude . length == 0 ) return this ; if ( this . sign == 0 || this . magnitude . length == 0 ) return val ; if ( val . sign < 0 ) { if ( this . sign > 0 ) return this . subtract ( val . negate ( ) ) ; } else { if ( this . sign < 0 ) return val . subtract ( this . negate ( ) ) ; } / / both Big CaMeL Integers are either + ve or - ve ; set the sign later int [ ] mag , op ; if ( this . magnitude . length < val . magnitude . length ) { mag = new int [ val . magnitude . length + 1 ] ; System . arraycopy ( val . magnitude , 0 , mag , 1 , val . magnitude . length ) ; op = this . magnitude ; } else { mag = new int [ this . magnitude . length + 1 ] ; System . arraycopy ( this . magnitude , 0 , mag , 1 , this . magnitude . length ) ; op = val . magnitude ; } return new Big CaMeL Integer ( this . sign , add ( mag , op ) ) ; }	m += ( ( ( long ) a [ t CaMeL I ] ) & IMASK ) + ( ( ( long ) b [ v CaMeL I -- ] ) & IMASK ) ; a [ t CaMeL I -- ] = ( int ) m ; m >> >> >> >> >= 32 ;
if ( m _ trigger != other . m _ trigger )  <CTX>  public boolean equals ( Object other _ o ) { Constraint other = ( Constraint ) other _ o ; if ( ( m _ name == null && other . get CaMeL Name ( ) != null ) || ( m _ name != null && other . get CaMeL Name ( ) == null ) ) { return false ; } if ( m _ name != null && other . get CaMeL Name ( ) != null && ! m _ name . equals ( other . get CaMeL Name ( ) ) ) { return false ; } if ( m _ type != other . get CaMeL Type ( ) ) { return false ; } if ( ( m _ column == null && other . get CaMeL Column ( ) != null ) || ( m _ column != null && other . get CaMeL Column ( ) == null ) ) { return false ; } if ( m _ column != null && other . get CaMeL Column ( ) != null && ! m _ column . equals ( other . get CaMeL Column ( ) ) ) { return false ; } if ( ( m _ f@@ table == null && other . get CaMeL Foreign CaMeL Table ( ) != null ) || ( m _ f@@ table != null && other . get CaMeL Foreign CaMeL Table ( ) == null ) ) { return false ; } if ( m _ f@@ table != null && other . get CaMeL Foreign CaMeL Table ( ) != null && ! m _ f@@ table . equals ( other . get CaMeL Foreign CaMeL Table ( ) ) ) { return false ; } if ( ( m _ f@@ column == null && other . get CaMeL Foreign CaMeL Column ( ) != null ) || ( m _ f@@ column != null && other . get CaMeL Foreign CaMeL Column ( ) == null ) ) { return false ; } if ( m _ f@@ column != null && other . get CaMeL Foreign CaMeL Column ( ) != null && ! m _ f@@ column . equals ( other . get CaMeL Foreign CaMeL Column ( ) ) ) { return false ; } if ( m _ trigger != other . m _ trigger ) return false ; return true ; }	if ( ( m _ f@@ del@@ type == null && other . get CaMeL Foreign CaMeL Del CaMeL Type ( ) != null ) || ( m _ f@@ del@@ type != null && other . get CaMeL Foreign CaMeL Del CaMeL Type ( ) == null ) ) {
combo . deselect CaMeL All ( ) ; combo . clear CaMeL Selection ( ) ;  <CTX>  protected void list CaMeL Deselect CaMeL All ( ) { combo . deselect CaMeL All ( ) ; combo . clear CaMeL Selection ( ) ; }	if ( combo == null ) { c@@ combo . deselect CaMeL All ( ) ; c@@ combo . clear CaMeL Selection ( ) ; } else { combo . deselect CaMeL All ( ) ; combo . clear CaMeL Selection ( ) ; }
synchronized protected int in CaMeL Available ( ) throws IO CaMeL Exception {  <CTX>  synchronized protected int in CaMeL Available ( ) throws IO CaMeL Exception { if ( in _ eof ) return 0 ; check CaMeL Connected ( ) ; if ( in _ buf == null ) return 0 ; int total = in _ buf . length - in _ bufpos ; List CaMeL Iterator it = data . list CaMeL Iterator ( 0 ) ; while ( it . has CaMeL Next ( ) ) total += ( ( byte [ ] ) it . next ( ) ) . length ; return total ; }	synchronized private int in CaMeL Available ( ) throws IO CaMeL Exception {
clone . set CaMeL Frozen ( false ) ;  <CTX>  public I CaMeL Ruby CaMeL Object rb CaMeL Clone ( ) { I CaMeL Ruby CaMeL Object clone = get CaMeL Meta CaMeL Class ( ) . get CaMeL Real CaMeL Class ( ) . allocate ( ) ; clone . set CaMeL Meta CaMeL Class ( get CaMeL Meta CaMeL Class ( ) . get CaMeL Singleton CaMeL Class CaMeL Clone ( ) ) ; clone . set CaMeL Frozen ( false ) ; clone . init CaMeL Copy ( this ) ; if ( is CaMeL Frozen ( ) ) { clone . set CaMeL Frozen ( true ) ; } return clone ; }	clone . set CaMeL Taint ( this . is CaMeL Taint ( ) ) ;
dispose ( ) ;  <CTX>  public void run ( ) { if ( ! force ) { if ( ! show CaMeL Confirmation ( ) ) { save CaMeL All ( ) ; return ; } } save CaMeL All ( ) ; if ( ! can CaMeL Exit ( ) ) return ; dispose ( ) ; System . exit ( 0 ) ; }	dispose CaMeL Self ( ) ;
buffer CaMeL Map . put ( offset , buffer ) ;  <CTX>  private RA CaMeL Stream CaMeL Buffer get CaMeL Buffer ( long offset ) throws IO CaMeL Exception { / / If we already have a buffer allocated for that offset , just / / return it . RA CaMeL Stream CaMeL Buffer buffer = ( RA CaMeL Stream CaMeL Buffer ) buffer CaMeL Map . get ( offset ) ; if ( buffer != null ) return buffer ; / / If not , and MAX _ NUMBER _ OF _ STREAM _ BUFFER has not been reached , / / allocate a new buffer for it . if ( total CaMeL Buffer < IO CaMeL Util . MAX _ NUMBER _ OF _ STREAM _ BUFFER ) { buffer = new RA CaMeL Stream CaMeL Buffer ( this . random CaMeL File ) ; buffer . reset CaMeL Buffer ( offset ) ; total CaMeL Buffer ++ ; buffer CaMeL List . add ( buffer ) ; buffer CaMeL Map . put ( offset , buffer ) ; return buffer ; } / / If no buffer has been found , and MAX _ NUMBER _ OF _ STREAM _ BUFFER has / / been reached , reuse the buffer from the beginning of the list and / / put the buffer to the end of the list . buffer = ( RA CaMeL Stream CaMeL Buffer ) buffer CaMeL List . get ( 0 ) ; buffer . flush CaMeL Buffer ( ) ; buffer CaMeL Map . remove ( buffer . get CaMeL Offset ( ) ) ; buffer . reset CaMeL Buffer ( offset ) ; buffer CaMeL Map . put ( offset , buffer ) ; buffer CaMeL List . remove ( 0 ) ; buffer CaMeL List . add ( buffer ) ; return buffer ; }	buffer CaMeL Map . put ( offset CaMeL Key , buffer ) ;
if ( is CaMeL Constant ( lhs ) ) {  <CTX>  private static boolean is CaMeL Constant CaMeL Mask ( Psi CaMeL Expression expression ) { if ( expression == null ) { return false ; } if ( ! ( expression instanceof Psi CaMeL Binary CaMeL Expression ) ) { return false ; } final Psi CaMeL Binary CaMeL Expression binary CaMeL Expression = ( Psi CaMeL Binary CaMeL Expression ) expression ; final Psi CaMeL Java CaMeL Token sign = binary CaMeL Expression . get CaMeL Operation CaMeL Sign ( ) ; if ( sign == null ) { return false ; } final I CaMeL Element CaMeL Type token CaMeL Type = sign . get CaMeL Token CaMeL Type ( ) ; if ( ! token CaMeL Type . equals ( Java CaMeL Token CaMeL Type . OR ) && ! token CaMeL Type . equals ( Java CaMeL Token CaMeL Type . AND ) ) { return false ; } final Psi CaMeL Expression rhs = binary CaMeL Expression . get CaMeL R CaMeL Operand ( ) ; if ( is CaMeL Constant ( rhs ) ) { return true ; } final Psi CaMeL Expression lhs = binary CaMeL Expression . get CaMeL L CaMeL Operand ( ) ; if ( is CaMeL Constant ( lhs ) ) { return true ; } return false ; }	if ( Psi CaMeL Util . is CaMeL Constant CaMeL Expression ( lhs ) ) {
catch ( No CaMeL Such CaMeL Algorithm CaMeL Exception ignore )  <CTX>  public static final SSL CaMeL Context get CaMeL Instance ( String protocol ) throws No CaMeL Such CaMeL Algorithm CaMeL Exception { Provider [ ] provs = Security . get CaMeL Providers ( ) ; for ( int i = 0 ; i < provs . length ; i ++ ) { try { return get CaMeL Instance ( protocol , provs [ i ] ) ; } catch ( No CaMeL Such CaMeL Algorithm CaMeL Exception ignore ) { } } throw new No CaMeL Such CaMeL Algorithm CaMeL Exception ( protocol ) ; }	catch ( No CaMeL Such CaMeL Algorithm CaMeL Exception x )
int feature CaMeL ID , Class base CaMeL Class , Notification CaMeL Chain msgs )  <CTX>  public Notification CaMeL Chain e CaMeL Inverse CaMeL Remove ( Internal CaMeL E CaMeL Object other CaMeL End , int feature CaMeL ID , Class base CaMeL Class , Notification CaMeL Chain msgs ) { if ( feature CaMeL ID >= 0 ) { switch ( e CaMeL Derived CaMeL Structural CaMeL Feature CaMeL ID ( feature CaMeL ID , base CaMeL Class ) ) { case Layout CaMeL Package . LABEL _ BLOCK _ _ CHILDREN : return ( ( Internal CaMeL E CaMeL List ) get CaMeL Children ( ) ) . basic CaMeL Remove ( other CaMeL End , msgs ) ; case Layout CaMeL Package . LABEL _ BLOCK _ _ BOUNDS : return basic CaMeL Set CaMeL Bounds ( null , msgs ) ; case Layout CaMeL Package . LABEL _ BLOCK _ _ INSETS : return basic CaMeL Set CaMeL Insets ( null , msgs ) ; case Layout CaMeL Package . LABEL _ BLOCK _ _ MIN _ SIZE : return basic CaMeL Set CaMeL Min CaMeL Size ( null , msgs ) ; case Layout CaMeL Package . LABEL _ BLOCK _ _ OUTLINE : return basic CaMeL Set CaMeL Outline ( null , msgs ) ; case Layout CaMeL Package . LABEL _ BLOCK _ _ BACKGROUND : return basic CaMeL Set CaMeL Background ( null , msgs ) ; case Layout CaMeL Package . LABEL _ BLOCK _ _ TRIGGERS : return ( ( Internal CaMeL E CaMeL List ) get CaMeL Triggers ( ) ) . basic CaMeL Remove ( other CaMeL End , msgs ) ; case Layout CaMeL Package . LABEL _ BLOCK _ _ LABEL : return basic CaMeL Set CaMeL Label ( null , msgs ) ; default : return e CaMeL Dynamic CaMeL Inverse CaMeL Remove ( other CaMeL End , feature CaMeL ID , base CaMeL Class , msgs ) ; } } return e CaMeL Basic CaMeL Set CaMeL Container ( null , feature CaMeL ID , msgs ) ; }	int feature CaMeL ID , Notification CaMeL Chain msgs )
results = null ;  <CTX>  public void close ( ) { try { results . close ( ) ; results = null ; } catch ( SQL CaMeL Exception sqle ) { } }	if ( results != null ) results . close ( ) ; } catch ( SQL CaMeL Exception sqle ) { } try { if ( state@@ mt != null ) state@@ mt . close ( ) ; state@@ mt = null ;
kind CaMeL Active . put ( ( I CaMeL Markup CaMeL Kind ) labels [ i ] . get CaMeL Data ( ) , new Boolean ( checkboxes [ i ] . get CaMeL Selection ( ) ) ) ;  <CTX>  public void create CaMeL Part CaMeL Control ( Composite parent ) { reset ( ) ; scrollpane = new Scrolled CaMeL Composite ( parent , SWT . H _ SCROLL | SWT . V _ SCROLL | SWT . BORDER ) ; canvas = new Composite ( scrollpane , SWT . NONE ) ; scrollpane . set CaMeL Content ( canvas ) ; canvas . set CaMeL Layout ( layout ) ; / / commented out bec@@ ause double clic@@ king was gi@@ ving NP CaMeL Es from open CaMeL Aspect CaMeL Source / / label CaMeL Listener = new Mouse CaMeL Listener ( ) { / / public void mouse CaMeL Up ( Mouse CaMeL Event e ) { / / } / / public void mouse CaMeL Down ( Mouse CaMeL Event e ) { / / } / / public void mouse CaMeL Double CaMeL Click ( Mouse CaMeL Event e ) { / / for ( int i = 0 ; i < labels . length ; i ++ ) { / / if ( ( Label ) e . get CaMeL Source ( ) == labels [ i ] ) { / / Visualiser CaMeL Plugin . visu@@ aliser . open CaMeL Aspect CaMeL Source ( i ) ; / / return ; / / } / / } / / } / / } ; / * * Listener for colour buttons - if clicked produces a Color CaMeL Dialog * then re@@ dra@@ ws the square image with the chosen colour . * / selection CaMeL Listener = new Selection CaMeL Adapter ( ) { public void widget CaMeL Selected ( Selection CaMeL Event e ) { if ( e . get CaMeL Source ( ) instanceof Button ) { Button button = ( Button ) e . get CaMeL Source ( ) ; int location = 0 ; for ( int j = 0 ; j < buttons . length ; j ++ ) { if ( ( buttons [ j ] ) . equals ( button ) ) { location = j ; } } RGB rgb = color CaMeL Dialogs [ location ] . open ( ) ; if ( rgb == null ) { return ; } colors [ location ] = new Color ( buttons [ location ] . get CaMeL Display ( ) , rgb ) ; Image image = buttons [ location ] . get CaMeL Image ( ) ; draw CaMeL Image ( image , colors [ location ] ) ; buttons [ location ] . set CaMeL Image ( image ) ; if ( ! ( Visualiser CaMeL Plugin . visu@@ aliser == null ) ) { vmp . set CaMeL Color CaMeL For ( ( I CaMeL Markup CaMeL Kind ) labels [ location ] . get CaMeL Data ( ) , colors [ location ] ) ; Visualiser CaMeL Plugin . visu@@ aliser . draw ( ) ; } } } } ; / / Listener for checkboxes checkbox CaMeL Listener = new Selection CaMeL Adapter ( ) { public void widget CaMeL Selected ( Selection CaMeL Event e ) { if ( ! ( Visualiser CaMeL Plugin . visu@@ aliser == null ) ) { for ( int i = 0 ; i < colors . length ; i ++ ) { kind CaMeL Active . put ( ( I CaMeL Markup CaMeL Kind ) labels [ i ] . get CaMeL Data ( ) , new Boolean ( checkboxes [ i ] . get CaMeL Selection ( ) ) ) ; } Visualiser CaMeL Plugin . visu@@ aliser . update CaMeL Display ( false ) ; } } } ; make CaMeL Pull CaMeL Down CaMeL Actions ( ) ; contribute CaMeL To CaMeL Action CaMeL Bars ( ) ; Visualiser CaMeL Plugin . get CaMeL Default ( ) . set CaMeL Menu ( this ) ; }	kind CaMeL Active . put ( labels [ i ] . get CaMeL Data ( ) , new Boolean ( checkboxes [ i ] . get CaMeL Selection ( ) ) ) ;
stop CaMeL Cell CaMeL Editing ( ) ;  <CTX>  protected Component create CaMeL Text CaMeL Field ( ) { / / Populate the text field with the object s string value J CaMeL Text CaMeL Field txt CaMeL Field = new J CaMeL Text CaMeL Field ( m CaMeL Editor . get CaMeL As CaMeL Text ( ) ) ; txt CaMeL Field . set CaMeL Border ( Border CaMeL Factory . create CaMeL Empty CaMeL Border ( 0 , 0 , 0 , 0 ) ) ; txt CaMeL Field . add CaMeL Action CaMeL Listener ( new Action CaMeL Listener ( ) { public void action CaMeL Performed ( Action CaMeL Event evt ) { stop CaMeL Cell CaMeL Editing ( ) ; } } ) ; txt CaMeL Field . add CaMeL Focus CaMeL Listener ( new Focus CaMeL Adapter ( ) { public void focus CaMeL Lost ( Focus CaMeL Event evt ) { stop CaMeL Cell CaMeL Editing ( ) ; } } ) ; return txt CaMeL Field ; }	txt CaMeL Field . set CaMeL Background ( get CaMeL Parent ( ) . get CaMeL Background ( ) ) ; txt CaMeL Field . transfer CaMeL Focus CaMeL Up CaMeL Cycle ( ) ;
node = add CaMeL Element ( parent , name , dim . get CaMeL Class ( ) . get CaMeL Name ( ) , false , false ) ;  <CTX>  public Element write CaMeL Dimension ( Element parent , Object o , String name ) throws Exception { Element node ; Dimension dim ; / / for debugging only if ( DEBUG ) trace ( new Throwable ( ) , name ) ; dim = ( Dimension ) o ; node = add CaMeL Element ( parent , name , dim . get CaMeL Class ( ) . get CaMeL Name ( ) , false , false ) ; write CaMeL Double CaMeL To CaMeL XML ( node , dim . get CaMeL Width ( ) , VAL _ WIDTH ) ; write CaMeL Double CaMeL To CaMeL XML ( node , dim . get CaMeL Height ( ) , VAL _ HEIGHT ) ; return node ; }	node = add CaMeL Element ( parent , name , dim . get CaMeL Class ( ) . get CaMeL Name ( ) , false ) ;
boolean reuse CaMeL Editor = Workbench CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Preference CaMeL Store ( ) . get CaMeL Boolean ( I CaMeL Preference CaMeL Constants . REUSE _ EDITORS _ BOOLEAN ) ;  <CTX>  public boolean should CaMeL Be CaMeL Visible ( ) { if ( editor CaMeL Pane == null ) { return false ; } boolean reuse CaMeL Editor = Workbench CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Preference CaMeL Store ( ) . get CaMeL Boolean ( I CaMeL Preference CaMeL Constants . REUSE _ EDITORS _ BOOLEAN ) ; return reuse CaMeL Editor ; }	I CaMeL Preference CaMeL Store store = Workbench CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Preference CaMeL Store ( ) ; boolean reuse CaMeL Editor = store . get CaMeL Boolean ( I CaMeL Preference CaMeL Constants . REUSE _ EDITORS _ BOOLEAN ) | store . get CaMeL Boolean ( I CaMeL Preference CaMeL Constants . EDITOR _ EXPERIMENTAL _ TAB _ BEHAVIOUR ) ;
my CaMeL Model . set CaMeL Java CaMeL Template ( _ entry . get CaMeL Value ( ) ) ;  <CTX>  public void text CaMeL Value CaMeL Changed ( Form CaMeL Entry _ entry ) { my CaMeL Model . set CaMeL Java CaMeL Template ( _ entry . get CaMeL Value ( ) ) ; get CaMeL Editor ( ) . editor CaMeL Dirty CaMeL State CaMeL Changed ( ) ; }	my CaMeL Model . set CaMeL Destination ( _ entry . get CaMeL Value ( ) ) ;
&& target . get CaMeL Property ( target CaMeL Design , prop . get CaMeL Name ( ) ) == null )  <CTX>  static void resolve CaMeL Style ( Report CaMeL Design target CaMeL Design , Design CaMeL Element target , Design CaMeL Element source ) { assert target CaMeL Design != null && target != null && source != null ; assert target instanceof Styled CaMeL Element ; assert source instanceof Styled CaMeL Element ; Module source CaMeL Module = source . get CaMeL Root ( ) ; assert source CaMeL Module != null ; Design CaMeL Element style = ( ( Styled CaMeL Element ) source ) . get CaMeL Style ( source CaMeL Module ) ; / / handle only when the style is not local one but a library resource if ( style != null && style . get CaMeL Root ( ) != source CaMeL Module ) { Module root = style . get CaMeL Root ( ) ; assert root != null ; / / copy all the local values in the style I CaMeL Element CaMeL Defn defn = style . get CaMeL Defn ( ) ; Iterator iter = defn . get CaMeL Property CaMeL Iterator ( ) ; while ( iter . has CaMeL Next ( ) ) { Property CaMeL Defn prop = ( Property CaMeL Defn ) iter . next ( ) ; Object value = style . get CaMeL Local CaMeL Property ( root , prop . get CaMeL Name ( ) ) ; if ( value != null ) { / / only handle values that not set in the target element if ( target . get CaMeL Property CaMeL Defn ( prop . get CaMeL Name ( ) ) != null && target . get CaMeL Property ( target CaMeL Design , prop . get CaMeL Name ( ) ) == null ) target . set CaMeL Property ( prop . get CaMeL Name ( ) , value ) ; } } / / clear the style reference of the target element ( ( Styled CaMeL Element ) target ) . set CaMeL Style ( null ) ; } }	&& target . get CaMeL Local CaMeL Property ( target CaMeL Design , ( Element CaMeL Property CaMeL Defn ) prop ) == null )
set CaMeL Style CaMeL Attribute ( name , ( String ) new CaMeL Value ) ;  <CTX>  public void put ( final String name , final Scriptable start , final Object new CaMeL Value ) { / / Some calls to put will happ@@ en during the initialization of the / / superclass . / / At this point , we don t have enough information to do our own / / initialization / / so we have to just pass this call through to the superclass . if ( js CaMeL Element _ == null || ! STYLE _ ALLOWED _ PROPERTIES . contains ( name ) ) { super . put ( name , start , new CaMeL Value ) ; return ; } set CaMeL Style CaMeL Attribute ( name , ( String ) new CaMeL Value ) ; }	set CaMeL Style CaMeL Attribute ( name , style CaMeL Value ) ;
My@@ lar CaMeL Ui CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Preference CaMeL Store ( ) . set CaMeL Default ( ID , true ) ; update ( My@@ lar CaMeL Ui CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Preference CaMeL Store ( ) . get CaMeL Boolean ( ID ) ) ;  <CTX>  public Link CaMeL Active CaMeL Search CaMeL With CaMeL Editor CaMeL Action ( ) { super ( LABEL , I CaMeL Action . AS _ CHECK _ BOX ) ; INSTANCE = this ; set CaMeL Id ( ID ) ; set CaMeL Image CaMeL Descriptor ( My@@ lar CaMeL Images . LINK _ WITH _ EDITOR ) ; set CaMeL Text ( LABEL ) ; set CaMeL Tool CaMeL Tip CaMeL Text ( LABEL ) ; My@@ lar CaMeL Ui CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Preference CaMeL Store ( ) . set CaMeL Default ( ID , true ) ; update ( My@@ lar CaMeL Ui CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Preference CaMeL Store ( ) . get CaMeL Boolean ( ID ) ) ; }	Context CaMeL Ui CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Preference CaMeL Store ( ) . set CaMeL Default ( ID , true ) ; update ( Context CaMeL Ui CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Preference CaMeL Store ( ) . get CaMeL Boolean ( ID ) ) ;
return background != null ? background : parent . get CaMeL Background ( ) ;  <CTX>  public Color get CaMeL Background ( ) { return background != null ? background : parent . get CaMeL Background ( ) ; }	return ( ( background != null ) ? background : parent . get CaMeL Background ( ) ) ;
if ( VM . Verify CaMeL Assertions ) VM . assert ( VM . NOT _ REACHED ) ;  <CTX>  public static Object invoke CaMeL Method CaMeL Returning CaMeL Object ( INSTRUCTION [ ] code , int [ ] gprs , double [ ] f@@ prs , int [ ] sp@@ ills ) { if ( VM . Verify CaMeL Assertions ) VM . assert ( VM . NOT _ REACHED ) ; / / call site should have been hi@@ j@@ acked by magic in compiler return null ; }	if ( VM . Verify CaMeL Assertions ) VM . _ assert ( VM . NOT _ REACHED ) ;
if ( online CaMeL Project ( current CaMeL User , current CaMeL Project ) . equals ( current CaMeL Project ) ) {  <CTX>  public boolean access CaMeL Create ( Cms CaMeL User current CaMeL User , Cms CaMeL Project current CaMeL Project , Cms CaMeL Resource resource ) throws Cms CaMeL Exception { / / check , if this is the on@@ line@@ project if ( online CaMeL Project ( current CaMeL User , current CaMeL Project ) . equals ( current CaMeL Project ) ) { / / the online - project is not writeable ! return ( false ) ; } / / check the access to the project if ( ! access CaMeL Project ( current CaMeL User , current CaMeL Project , current CaMeL Project . get CaMeL Id ( ) ) ) { / / no access to the project ! return ( false ) ; } / / check if the resource belongs to the current project if ( resource . get CaMeL Project CaMeL Id ( ) != current CaMeL Project . get CaMeL Id ( ) ) { return false ; } / / is the resource locked ? if ( resource . is CaMeL Locked ( ) && ( resource . is CaMeL Locked CaMeL By ( ) != current CaMeL User . get CaMeL Id ( ) || ( resource . get CaMeL Locked CaMeL In CaMeL Project ( ) != current CaMeL Project . get CaMeL Id ( ) && current CaMeL Project . get CaMeL Flags ( ) != C _ PROJECT _ STATE _ INVISIBLE ) ) ) { / / resource locked by an@@ op@@ ther user , no creation allowed return ( false ) ; } / / check the rights for the current resource if ( ! ( access CaMeL Other ( resource , C _ ACCESS _ PUBLIC _ WRITE ) || access CaMeL Owner ( current CaMeL User , current CaMeL Project , resource , C _ ACCESS _ OWNER _ WRITE ) || access CaMeL Group ( current CaMeL User , current CaMeL Project , resource , C _ ACCESS _ GROUP _ WRITE ) ) ) { / / no write access to this resource ! return false ; } / / read the parent folder if ( resource . get CaMeL Parent ( ) != null ) { / / read CaMeL Folder without checking access resource = m _ db CaMeL Access . read CaMeL Folder ( resource . get CaMeL Project CaMeL Id ( ) , resource . get CaMeL Root CaMeL Name ( ) + resource . get CaMeL Parent ( ) ) ; } else { / / no parent folder ! return true ; } / / check the rights and if the resource is not locked do { if ( access CaMeL Other ( resource , C _ ACCESS _ PUBLIC _ READ ) || access CaMeL Owner ( current CaMeL User , current CaMeL Project , resource , C _ ACCESS _ OWNER _ READ ) || access CaMeL Group ( current CaMeL User , current CaMeL Project , resource , C _ ACCESS _ GROUP _ READ ) ) { / / is the resource locked ? if ( resource . is CaMeL Locked ( ) && resource . is CaMeL Locked CaMeL By ( ) != current CaMeL User . get CaMeL Id ( ) ) { / / resource locked by an@@ op@@ ther user , no creation allowed return ( false ) ; } / / read next resource if ( resource . get CaMeL Parent ( ) != null ) { / / read CaMeL Folder without checking access resource = m _ db CaMeL Access . read CaMeL Folder ( resource . get CaMeL Project CaMeL Id ( ) , resource . get CaMeL Root CaMeL Name ( ) + resource . get CaMeL Parent ( ) ) ; } } else { / / last check was negative return ( false ) ; } } while ( resource . get CaMeL Parent ( ) != null ) ; / / all checks are done positive return ( true ) ; }	if ( current CaMeL Project . is CaMeL Online CaMeL Project ( ) ) {
Boolean test = ( ( Scriptable CaMeL Object ) y ) . equivalent CaMeL Values ( x ) ; if ( test != null ) { return test . boolean CaMeL Value ( ) ;  <CTX>  public static boolean eq ( Object x , Object y ) { if ( x == null || x == Undefined . instance ) { if ( y == null || y == Undefined . instance ) { return true ; } if ( y instanceof Scriptable CaMeL Object ) { Boolean test = ( ( Scriptable CaMeL Object ) y ) . equivalent CaMeL Values ( x ) ; if ( test != null ) { return test . boolean CaMeL Value ( ) ; } } return false ; } else if ( x instanceof Number ) { return eq CaMeL Number ( ( ( Number ) x ) . double CaMeL Value ( ) , y ) ; } else if ( x instanceof String ) { return eq CaMeL String ( ( String ) x , y ) ; } else if ( x instanceof Boolean ) { boolean b = ( ( Boolean ) x ) . boolean CaMeL Value ( ) ; if ( y instanceof Boolean ) { return b == ( ( Boolean ) y ) . boolean CaMeL Value ( ) ; } if ( y instanceof Scriptable CaMeL Object ) { Boolean test = ( ( Scriptable CaMeL Object ) y ) . equivalent CaMeL Values ( x ) ; if ( test != null ) { return test . boolean CaMeL Value ( ) ; } } return eq CaMeL Number ( b ? 1 . 0 : 0 . 0 , y ) ; } else if ( x instanceof Scriptable ) { if ( y instanceof Scriptable ) { / / Generic test also works for y == Undefined . instance if ( x == y ) { return true ; } if ( x instanceof Scriptable CaMeL Object ) { Boolean test = ( ( Scriptable CaMeL Object ) x ) . equivalent CaMeL Values ( y ) ; if ( test != null ) { return test . boolean CaMeL Value ( ) ; } } if ( y instanceof Scriptable CaMeL Object ) { Boolean test = ( ( Scriptable CaMeL Object ) y ) . equivalent CaMeL Values ( x ) ; if ( test != null ) { return test . boolean CaMeL Value ( ) ; } } if ( x instanceof Wrapper && y instanceof Wrapper ) { return ( ( Wrapper ) x ) . unwrap ( ) == ( ( Wrapper ) y ) . unwrap ( ) ; } return false ; } else if ( y instanceof Boolean ) { if ( x instanceof Scriptable CaMeL Object ) { Boolean test = ( ( Scriptable CaMeL Object ) x ) . equivalent CaMeL Values ( y ) ; if ( test != null ) { return test . boolean CaMeL Value ( ) ; } } double d = ( ( Boolean ) y ) . boolean CaMeL Value ( ) ? 1 . 0 : 0 . 0 ; return eq CaMeL Number ( d , x ) ; } else if ( y instanceof Number ) { return eq CaMeL Number ( ( ( Number ) y ) . double CaMeL Value ( ) , x ) ; } else if ( y instanceof String ) { return eq CaMeL String ( ( String ) y , x ) ; } return false ; } else { warn CaMeL About CaMeL Non CaMeL JS CaMeL Object ( x ) ; return x == y ; } }	Object test = ( ( Scriptable CaMeL Object ) y ) . equivalent CaMeL Values ( x ) ; if ( test != Scriptable . NOT _ FOUND ) { return ( ( Boolean ) test ) . boolean CaMeL Value ( ) ;
return Soap CaMeL Utils . get CaMeL Filters ( Search CaMeL Request CaMeL Factory . get CaMeL Visible CaMeL Requests ( user ) ) ;  <CTX>  public Remote CaMeL Filter [ ] get CaMeL Saved CaMeL Filters ( String token ) throws Exception { User user = token CaMeL Manager . retrieve CaMeL User ( token ) ; return Soap CaMeL Utils . get CaMeL Filters ( Search CaMeL Request CaMeL Factory . get CaMeL Visible CaMeL Requests ( user ) ) ; }	return Soap CaMeL Utils . get CaMeL Filters ( search CaMeL Request CaMeL Manager . get CaMeL Visible CaMeL Requests ( user ) ) ;
Oda CaMeL Data CaMeL Set . PRIVATE _ DRIVER _ PROPERTIES _ PROP , name ) ;  <CTX>  public String get CaMeL Private CaMeL Driver CaMeL Property ( String name ) { return Extended CaMeL Property CaMeL Helper . get CaMeL Extended CaMeL Property ( this , Oda CaMeL Data CaMeL Set . PRIVATE _ DRIVER _ PROPERTIES _ PROP , name ) ; }	I CaMeL Oda CaMeL Data CaMeL Set CaMeL Model . PRIVATE _ DRIVER _ PROPERTIES _ PROP , name ) ;
super ( conn , fields , tuples , status , update CaMeL Count , insert CaMeL OID ) ;  <CTX>  public Result CaMeL Set ( Connection conn , Field [ ] fields , Vector tuples , String status , int update CaMeL Count , int insert CaMeL OID ) { super ( conn , fields , tuples , status , update CaMeL Count , insert CaMeL OID ) ; }	super ( conn , fields , tuples , status , update CaMeL Count , insert CaMeL OID , binary CaMeL Cursor ) ;
values ) ;  <CTX>  private J CaMeL Block do CaMeL Unroll ( Unroll CaMeL Info info , J CaMeL For CaMeL Statement self ) { / / make a list of statements List statement CaMeL List = new Linked CaMeL List ( ) ; statement CaMeL List . add ( self . get CaMeL Init ( ) ) ; / / get the initial value of the counter int counter = info . init CaMeL Val ; / / simulate execution of the loop . . . while ( done ( counter , info ) ) { / / create new for statement , just to replace the variable J CaMeL For CaMeL Statement new CaMeL Self = ( J CaMeL For CaMeL Statement ) Object CaMeL Deep CaMeL Cloner . deep CaMeL Copy ( self ) ; / / get unroll info for < new CaMeL Self > Unroll CaMeL Info new CaMeL Info = get CaMeL Unroll CaMeL Info ( new CaMeL Self . get CaMeL Init ( ) , new CaMeL Self . get CaMeL Condition ( ) , new CaMeL Self . get CaMeL Increment ( ) , new CaMeL Self . get CaMeL Body ( ) , values ) ; / / replace ind@@ uction variable with its value current value Hashtable new CaMeL Constants = new Hashtable ( ) ; new CaMeL Constants . put ( new CaMeL Info . var , new J CaMeL Int CaMeL Literal ( counter ) ) ; / / do the replacement new CaMeL Self . get CaMeL Body ( ) . accept ( new Propagator ( new CaMeL Constants ) ) ; / / add to statement list statement CaMeL List . add ( new CaMeL Self . get CaMeL Body ( ) ) ; / / increment counter counter = increment CaMeL Counter ( counter , info ) ; } statement CaMeL List . add ( new J CaMeL Expression CaMeL Statement ( self . get CaMeL Token CaMeL Reference ( ) , new J CaMeL Assignment CaMeL Expression ( self . get CaMeL Token CaMeL Reference ( ) , new J CaMeL Local CaMeL Variable CaMeL Expression ( self . get CaMeL Token CaMeL Reference ( ) , info . var ) , new J CaMeL Int CaMeL Literal ( counter ) ) , null ) ) ; / / mark that we ve un@@ rolled this . has CaMeL Unrolled = true ; / / return new block instead of the for loop constants . remove ( info . var ) ; return new J CaMeL Block ( null , ( J CaMeL Statement [ ] ) statement CaMeL List . to CaMeL Array ( new J CaMeL Statement [ 0 ] ) , null ) ; }	values , constants ) ;
list CaMeL Double CaMeL Clicked ( event . get CaMeL Viewer ( ) . get CaMeL Selection ( ) ) ;  <CTX>  public void double CaMeL Click ( Double CaMeL Click CaMeL Event event ) { list CaMeL Double CaMeL Clicked ( event . get CaMeL Viewer ( ) . get CaMeL Selection ( ) ) ; }	tree CaMeL Double CaMeL Clicked ( event ) ;
return ( ( Bundle CaMeL Source CaMeL Viewer CaMeL Configuration ) get CaMeL Source CaMeL Viewer CaMeL Configuration ( ) ) . affects CaMeL Text CaMeL Presentation ( event ) || super . affects CaMeL Text CaMeL Presentation ( event ) ;  <CTX>  protected boolean affects CaMeL Text CaMeL Presentation ( Property CaMeL Change CaMeL Event event ) { return ( ( Bundle CaMeL Source CaMeL Viewer CaMeL Configuration ) get CaMeL Source CaMeL Viewer CaMeL Configuration ( ) ) . affects CaMeL Text CaMeL Presentation ( event ) || super . affects CaMeL Text CaMeL Presentation ( event ) ; }	return f CaMeL Configuration . affects CaMeL Text CaMeL Presentation ( event ) || super . affects CaMeL Text CaMeL Presentation ( event ) ;
unconditional CaMeL Deref CaMeL Param CaMeL Database = analysis CaMeL Context . get CaMeL Unconditional CaMeL Deref CaMeL Param CaMeL Database ( ) ; non CaMeL Null CaMeL Param CaMeL Database = analysis CaMeL Context . get CaMeL Non CaMeL Null CaMeL Param CaMeL Database ( ) ; check CaMeL For CaMeL Null CaMeL Param CaMeL Database = analysis CaMeL Context . get CaMeL Check CaMeL For CaMeL Null CaMeL Param CaMeL Database ( ) ; null CaMeL Return CaMeL Value CaMeL Annotation CaMeL Database = analysis CaMeL Context . get CaMeL Null CaMeL Return CaMeL Value CaMeL Annotation CaMeL Database ( ) ; check CaMeL Unconditional CaMeL Deref = is CaMeL Database CaMeL Non CaMeL Empty ( unconditional CaMeL Deref CaMeL Param CaMeL Database ) ; check CaMeL Param CaMeL Annotations = is CaMeL Database CaMeL Non CaMeL Empty ( non CaMeL Null CaMeL Param CaMeL Database ) && is CaMeL Database CaMeL Non CaMeL Empty ( check CaMeL For CaMeL Null CaMeL Param CaMeL Database ) ; check CaMeL Return CaMeL Value CaMeL Annotations = is CaMeL Database CaMeL Non CaMeL Empty ( null CaMeL Return CaMeL Value CaMeL Annotation CaMeL Database ) ; check CaMeL Call CaMeL Sites = check CaMeL Unconditional CaMeL Deref || check CaMeL Param CaMeL Annotations ; check CaMeL Call CaMeL Sites CaMeL Or CaMeL Return CaMeL Instructions = check CaMeL Call CaMeL Sites || check CaMeL Return CaMeL Value CaMeL Annotations ;  <CTX>  private void check CaMeL Databases ( ) { Analysis CaMeL Context analysis CaMeL Context = Analysis CaMeL Context . current CaMeL Analysis CaMeL Context ( ) ; unconditional CaMeL Deref CaMeL Param CaMeL Database = analysis CaMeL Context . get CaMeL Unconditional CaMeL Deref CaMeL Param CaMeL Database ( ) ; non CaMeL Null CaMeL Param CaMeL Database = analysis CaMeL Context . get CaMeL Non CaMeL Null CaMeL Param CaMeL Database ( ) ; check CaMeL For CaMeL Null CaMeL Param CaMeL Database = analysis CaMeL Context . get CaMeL Check CaMeL For CaMeL Null CaMeL Param CaMeL Database ( ) ; null CaMeL Return CaMeL Value CaMeL Annotation CaMeL Database = analysis CaMeL Context . get CaMeL Null CaMeL Return CaMeL Value CaMeL Annotation CaMeL Database ( ) ; check CaMeL Unconditional CaMeL Deref = is CaMeL Database CaMeL Non CaMeL Empty ( unconditional CaMeL Deref CaMeL Param CaMeL Database ) ; check CaMeL Param CaMeL Annotations = is CaMeL Database CaMeL Non CaMeL Empty ( non CaMeL Null CaMeL Param CaMeL Database ) && is CaMeL Database CaMeL Non CaMeL Empty ( check CaMeL For CaMeL Null CaMeL Param CaMeL Database ) ; check CaMeL Return CaMeL Value CaMeL Annotations = is CaMeL Database CaMeL Non CaMeL Empty ( null CaMeL Return CaMeL Value CaMeL Annotation CaMeL Database ) ; check CaMeL Call CaMeL Sites = check CaMeL Unconditional CaMeL Deref || check CaMeL Param CaMeL Annotations ; check CaMeL Call CaMeL Sites CaMeL Or CaMeL Return CaMeL Instructions = check CaMeL Call CaMeL Sites || check CaMeL Return CaMeL Value CaMeL Annotations ; }	unconditional CaMeL Deref CaMeL Param CaMeL Database = analysis CaMeL Context . get CaMeL Unconditional CaMeL Deref CaMeL Param CaMeL Database ( ) ;
return get CaMeL Text CaMeL Value ( res ) ;  <CTX>  private String get CaMeL String ( String key , String catalogue CaMeL Id , String default CaMeL Value ) { final Node res = get CaMeL Node ( catalogue CaMeL Id , key ) ; if ( res == null ) { return default CaMeL Value ; } return get CaMeL Text CaMeL Value ( res ) ; }	return res . to CaMeL String ( ) ;
return get CaMeL Bool CaMeL Representation ( get CaMeL Task CaMeL Message CaMeL Members ( ) ) ;  <CTX>  public String get CaMeL Task CaMeL Message CaMeL Members CaMeL String ( ) { return get CaMeL Bool CaMeL Representation ( get CaMeL Task CaMeL Message CaMeL Members ( ) ) ; }	return String . value CaMeL Of ( get CaMeL Task CaMeL Message CaMeL Members ( ) ) ;
return pos + 1 ;  <CTX>  public long get CaMeL Pos ( ) { return pos + 1 ; }	return pos ;
if ( root == null )  <CTX>  public Relationship CaMeL Info [ ] compute CaMeL Relation ( ) { Array CaMeL List list = new Array CaMeL List ( ) ; if ( root == null ) return new Relationship CaMeL Info [ 0 ] ; Relationship CaMeL Info r = new Relationship CaMeL Info ( ) ; r . part = root . compute CaMeL Relation ( list ) ; list . add ( 0 , r ) ; Relationship CaMeL Info [ ] result = new Relationship CaMeL Info [ list . size ( ) ] ; list . to CaMeL Array ( result ) ; return result ; }	if ( tree CaMeL Root == null )
char token , String name , Annotation annotation  <CTX>  static public Atomic CaMeL Symbol create CaMeL Symbol ( char token , String name , Annotation annotation ) { Atomic CaMeL Symbol as = new Fundamental CaMeL Atomic CaMeL Symbol ( name , token , annotation ) ; return as ; }	String name , Annotation annotation
int lo = Math . min ( index 0 , index 1 ) ; int hi = Math . max ( index 0 , index 1 ) ;  <CTX>  public void set CaMeL Selection CaMeL Interval ( int index 0 , int index 1 ) { if ( index 0 == - 1 || index 1 == - 1 ) return ; Bit CaMeL Set old CaMeL Sel = ( Bit CaMeL Set ) sel . clone ( ) ; sel . clear ( ) ; if ( selection CaMeL Mode == SINGLE _ SELECTION ) index 0 = index 1 ; int lo = Math . min ( index 0 , index 1 ) ; int hi = Math . max ( index 0 , index 1 ) ; sel . set ( lo , hi + 1 ) ; / / update the anchor CaMeL Selection CaMeL Index and lead CaMeL Selection CaMeL Index variables set CaMeL Anchor CaMeL Selection CaMeL Index ( index 0 ) ; lead CaMeL Selection CaMeL Index = index 1 ; fire CaMeL Difference ( sel , old CaMeL Sel ) ; }	int lo = Math . min ( anchor , lead ) ; int hi = Math . max ( anchor , lead ) ;
return Ruby CaMeL Fixnum . new CaMeL Fixnum ( runtime , microseconds ( ) ) ;  <CTX>  public Ruby CaMeL Integer usec ( ) { return Ruby CaMeL Fixnum . new CaMeL Fixnum ( runtime , microseconds ( ) ) ; }	return get CaMeL Runtime ( ) . new CaMeL Fixnum ( microseconds ( ) ) ;
get CaMeL Service ( ) . add CaMeL Resources ( company CaMeL Id , group CaMeL Id , user CaMeL Id , name , prim CaMeL Key , portlet CaMeL Actions , add CaMeL Community CaMeL Permissions , add CaMeL Guest CaMeL Permissions ) ;  <CTX>  public void add CaMeL Resources ( java . lang . String company CaMeL Id , java . lang . String group CaMeL Id , java . lang . String user CaMeL Id , java . lang . String name , java . lang . String prim CaMeL Key , boolean portlet CaMeL Actions , boolean add CaMeL Community CaMeL Permissions , boolean add CaMeL Guest CaMeL Permissions ) throws com . li@@ fer@@ ay . portal . Portal CaMeL Exception , com . li@@ fer@@ ay . portal . System CaMeL Exception { get CaMeL Service ( ) . add CaMeL Resources ( company CaMeL Id , group CaMeL Id , user CaMeL Id , name , prim CaMeL Key , portlet CaMeL Actions , add CaMeL Community CaMeL Permissions , add CaMeL Guest CaMeL Permissions ) ; }	get CaMeL Service ( ) . add CaMeL Resources ( company CaMeL Id , group CaMeL Id , name , portlet CaMeL Actions ) ;
modifiers CaMeL Source CaMeL Start >= 0 ? modifiers CaMeL Source CaMeL Start : scanner . start CaMeL Position ) ;  <CTX>  protected void consume CaMeL Default CaMeL Modifiers ( ) { check CaMeL Comment ( ) ; / / might update modifiers with Acc CaMeL Deprecated push CaMeL On CaMeL Int CaMeL Stack ( modifiers ) ; / / modifiers push CaMeL On CaMeL Int CaMeL Stack ( modifiers CaMeL Source CaMeL Start >= 0 ? modifiers CaMeL Source CaMeL Start : scanner . start CaMeL Position ) ; reset CaMeL Modifiers ( ) ; }	this . modifiers CaMeL Source CaMeL Start >= 0 ? this . modifiers CaMeL Source CaMeL Start : this . scanner . start CaMeL Position ) ;
int b = instream . read ( ) ; if ( b == 1 ) { arg = new Ping CaMeL Rsp ( ) ; arg . read CaMeL From ( instream ) ; }  <CTX>  public void read CaMeL From ( Data CaMeL Input CaMeL Stream instream ) throws IO CaMeL Exception , Illegal CaMeL Access CaMeL Exception , Instantiation CaMeL Exception { type = instream . read CaMeL Byte ( ) ; int b = instream . read ( ) ; if ( b == 1 ) { arg = new Ping CaMeL Rsp ( ) ; arg . read CaMeL From ( instream ) ; } }	arg = ( Ping CaMeL Rsp ) Util . read CaMeL Streamable ( Ping CaMeL Rsp . class , instream ) ;
Search CaMeL Constraints get CaMeL Leaf CaMeL Child ( ) {  <CTX>  Search CaMeL Constraints get CaMeL Leaf CaMeL Child ( ) { for ( I CaMeL Constraints n : m CaMeL Sub CaMeL Nodes ) if ( n . get CaMeL Node CaMeL Type ( ) == Node CaMeL Type . LEAF ) return ( Search CaMeL Constraints ) n ; Search CaMeL Constraints c = new Search CaMeL Constraints ( ) ; m CaMeL Sub CaMeL Nodes . add ( c ) ; return c ; }	Leaf CaMeL Node get CaMeL Leaf CaMeL Child ( ) {
Underlying CaMeL Data data = prepare CaMeL Create ( TYPE _ DOCUMENT , id , folder , volume CaMeL Id , filename , creator , type , contents , ( Document ) parent , null ) ;  <CTX>  static Document create ( int id , Folder folder , short volume CaMeL Id , String filename , String creator , String type , byte [ ] contents , Mail CaMeL Item parent ) throws Service CaMeL Exception { assert ( id != Mailbox . ID _ AUTO _ INCREMENT ) ; assert ( parent instanceof Document ) ; Underlying CaMeL Data data = prepare CaMeL Create ( TYPE _ DOCUMENT , id , folder , volume CaMeL Id , filename , creator , type , contents , ( Document ) parent , null ) ; if ( parent != null ) data . parent CaMeL Id = parent . get CaMeL Id ( ) ; Mailbox mbox = folder . get CaMeL Mailbox ( ) ; data . content CaMeL Changed ( mbox ) ; Db CaMeL Mail CaMeL Item . create ( mbox , data ) ; Document doc = new Document ( mbox , data ) ; doc . finish CaMeL Creation ( parent ) ; / / doc . reindex ( ) ; return doc ; }	Underlying CaMeL Data data = prepare CaMeL Create ( TYPE _ DOCUMENT , id , folder , volume CaMeL Id , filename , creator , type , pd , ( Document ) parent , null ) ;
if ( sen@@ ior == null ) { final int cur@@ ri@@ cular CaMeL Year = registration . get CaMeL Cur@@ ri@@ cular CaMeL Year ( ) ; if ( cur@@ ri@@ cular CaMeL Year == degree . get CaMeL Degree CaMeL Type ( ) . get CaMeL Years ( ) ) { sen@@ ior = new Sen@@ ior ( registration ) ; } else { return null ; } } return sen@@ ior ;  <CTX>  public Sen@@ ior run ( Person person ) { Sen@@ ior sen@@ ior = null ; final Registration registration = person . get CaMeL Student CaMeL By CaMeL Type ( Degree CaMeL Type . DEGREE ) ; if ( registration == null ) { return null ; } final Student CaMeL Cur@@ ri@@ cular CaMeL Plan student CaMeL Cur@@ ri@@ cular CaMeL Plan = registration . get CaMeL Active CaMeL Student CaMeL Cur@@ ri@@ cular CaMeL Plan ( ) ; if ( student CaMeL Cur@@ ri@@ cular CaMeL Plan == null ) { return null ; } final Degree CaMeL Cur@@ ri@@ cular CaMeL Plan degree CaMeL Cur@@ ri@@ cular CaMeL Plan = student CaMeL Cur@@ ri@@ cular CaMeL Plan . get CaMeL Degree CaMeL Cur@@ ri@@ cular CaMeL Plan ( ) ; final Degree degree = degree CaMeL Cur@@ ri@@ cular CaMeL Plan . get CaMeL Degree ( ) ; sen@@ ior = registration . get CaMeL Sen@@ ior ( ) ; if ( sen@@ ior == null ) { final int cur@@ ri@@ cular CaMeL Year = registration . get CaMeL Cur@@ ri@@ cular CaMeL Year ( ) ; if ( cur@@ ri@@ cular CaMeL Year == degree . get CaMeL Degree CaMeL Type ( ) . get CaMeL Years ( ) ) { sen@@ ior = new Sen@@ ior ( registration ) ; } else { return null ; } } return sen@@ ior ; }	if ( sen@@ ior == null ) { final int cur@@ ri@@ cular CaMeL Year = registration . get CaMeL Cur@@ ri@@ cular CaMeL Year ( ) ; if ( cur@@ ri@@ cular CaMeL Year == degree . get CaMeL Degree CaMeL Type ( ) . get CaMeL Years ( ) ) { sen@@ ior = new Sen@@ ior ( registration ) ; } else { return null ; }
return new File CaMeL Chooser CaMeL Home CaMeL Folder CaMeL Icon ( ) ;  <CTX>  public static Icon get CaMeL File CaMeL Chooser CaMeL Home CaMeL Folder CaMeL Icon ( ) { return new File CaMeL Chooser CaMeL Home CaMeL Folder CaMeL Icon ( ) ; }	if ( file CaMeL Chooser CaMeL Home CaMeL Folder CaMeL Icon == null ) file CaMeL Chooser CaMeL Home CaMeL Folder CaMeL Icon = new File CaMeL Chooser CaMeL Home CaMeL Folder CaMeL Icon ( ) ; return file CaMeL Chooser CaMeL Home CaMeL Folder CaMeL Icon ;
return equivalent CaMeL Values ( obj ) . boolean CaMeL Value ( ) ;  <CTX>  public boolean equals ( Object obj ) { if ( ! ( obj instanceof Namespace ) ) return false ; return equivalent CaMeL Values ( obj ) . boolean CaMeL Value ( ) ; }	return equals ( ( Namespace ) obj ) ;
temp [ temp . length - 1 ] = value 0 ;  <CTX>  public void add CaMeL Selection CaMeL Path ( Tree CaMeL Path value 0 ) { if ( ! is CaMeL Path CaMeL Selected ( value 0 ) ) { if ( is CaMeL Selection CaMeL Empty ( ) ) set CaMeL Selection CaMeL Path ( value 0 ) ; else { Tree CaMeL Path [ ] temp = new Tree CaMeL Path [ selection . length + 1 ] ; System . arraycopy ( selection , 0 , temp , 0 , selection . length ) ; temp [ temp . length - 1 ] = value 0 ; selection = new Tree CaMeL Path [ temp . length ] ; System . arraycopy ( temp , 0 , selection , 0 , temp . length ) ; } lead CaMeL Path = value 0 ; fire CaMeL Value CaMeL Changed ( new Tree CaMeL Selection CaMeL Event ( this , value 0 , true , lead CaMeL Path , value 0 ) ) ; } }	temp [ temp . length - 1 ] = path ;
return ( Bio CaMeL Module ) ( my CaMeL Producer ) ;  <CTX>  public Bio CaMeL Module get CaMeL Input CaMeL Module ( ) { return ( Bio CaMeL Module ) ( my CaMeL Producer ) ; }	return my CaMeL Producer ;
if ( c == null || c . is CaMeL Disposed ( ) ) return ;  <CTX>  public void run ( ) { ignore CaMeL Entries -- ; Editor CaMeL Site site = ( Editor CaMeL Site ) ( part . get CaMeL Editor CaMeL Site ( ) ) ; Control c = site . get CaMeL Pane ( ) . get CaMeL Control ( ) ; if ( c == null || c . is CaMeL Disposed ( ) ) return ; Navigation CaMeL History CaMeL Entry e = get CaMeL Entry ( active CaMeL Entry ) ; if ( e != null && part . get CaMeL Editor CaMeL Input ( ) != e . editor CaMeL Info . editor CaMeL Input ) update CaMeL Entry ( e ) ; add CaMeL Entry ( part , true ) ; }	if ( c == null || c . is CaMeL Disposed ( ) ) { return ; }
java . lang . String company CaMeL Id , java . lang . String name , java . lang . String type CaMeL Id , java . lang . String scope , java . lang . String prim CaMeL Key )  <CTX>  public com . li@@ fer@@ ay . portal . model . Resource get CaMeL Resource ( java . lang . String company CaMeL Id , java . lang . String name , java . lang . String type CaMeL Id , java . lang . String scope , java . lang . String prim CaMeL Key ) throws com . li@@ fer@@ ay . portal . Portal CaMeL Exception , com . li@@ fer@@ ay . portal . System CaMeL Exception ;	java . lang . String resource CaMeL Id )
if ( feature . equals ( Constants . LOAD _ DTD _ GRAMMAR _ FEATURE ) ) {  <CTX>  protected void check CaMeL Feature ( String feature CaMeL Id ) throws XML CaMeL Configuration CaMeL Exception { / / / / Xerces Features / / if ( feature CaMeL Id . starts CaMeL With ( Constants . XERCES _ FEATURE _ PREFIX ) ) { String feature = feature CaMeL Id . substring ( Constants . XERCES _ FEATURE _ PREFIX . length ( ) ) ; / / / / http : / / apache . org / xml / features / validation / dynamic / / Allows the parser to validate a document only when it / / contains a grammar . Validation is tur@@ ned on / off based / / on each document instance , automatically . / / if ( feature . equals ( Constants . DYNAMIC _ VALIDATION _ FEATURE ) ) { return ; } / / / / http : / / apache . org / xml / features / validation / default - attribute - values / / if ( feature . equals ( Constants . DEFAULT _ ATTRIBUTE _ VALUES _ FEATURE ) ) { / / RE@@ VISIT short type = XML CaMeL Configuration CaMeL Exception . NOT _ SUPPORTED ; throw new XML CaMeL Configuration CaMeL Exception ( type , feature CaMeL Id ) ; } / / / / http : / / apache . org / xml / features / validation / default - attribute - values / / if ( feature . equals ( Constants . VALIDATE _ CONTENT _ MODELS _ FEATURE ) ) { / / RE@@ VISIT short type = XML CaMeL Configuration CaMeL Exception . NOT _ SUPPORTED ; throw new XML CaMeL Configuration CaMeL Exception ( type , feature CaMeL Id ) ; } / / / / http : / / apache . org / xml / features / validation / non@@ validating / load - dtd - grammar / / if ( feature . equals ( Constants . LOAD _ DTD _ GRAMMAR _ FEATURE ) ) { return ; } / / / / http : / / apache . org / xml / features / validation / non@@ validating / load - external - dtd / / if ( feature . equals ( Constants . LOAD _ EXTERNAL _ DTD _ FEATURE ) ) { return ; } / / / / http : / / apache . org / xml / features / validation / default - attribute - values / / if ( feature . equals ( Constants . VALIDATE _ DATATYPES _ FEATURE ) ) { short type = XML CaMeL Configuration CaMeL Exception . NOT _ SUPPORTED ; throw new XML CaMeL Configuration CaMeL Exception ( type , feature CaMeL Id ) ; } } / / / / Not recognized / / super . check CaMeL Feature ( feature CaMeL Id ) ; } / / check CaMeL Feature ( String )	if ( feature CaMeL Id . region CaMeL Matches ( prefix CaMeL Length , Constants . LOAD _ DTD _ GRAMMAR _ FEATURE , 0 , Constants . LOAD _ DTD _ GRAMMAR _ FEATURE . length ( ) ) ) {
if ( peers == 0 || conns == 0 || ( peers - conns ) > MAX _ DIS@@ CONN _ PEER _ ALERT _ THRESHOLD || conns > MAX _ CONN _ ALERT _ THRESHOLD || peers > MAX _ PEER _ ALERT _ THRESHOLD || ( n . b@@ w@@ limit CaMeL Delay CaMeL Alert CaMeL Relevant && b@@ w@@ limit CaMeL Delay CaMeL Time > Node . MAX _ B@@ W@@ LIMIT _ DELAY _ TIME _ ALERT _ THRESHOLD ) || ( n . node CaMeL Average CaMeL Ping CaMeL Alert CaMeL Relevant && node CaMeL Average CaMeL Ping CaMeL Time > Node . MAX _ NODE _ AVERAGE _ PING _ TIME _ ALERT _ THRESHOLD ) )  <CTX>  public short get CaMeL Priority CaMeL Class ( ) { if ( peers == 0 || conns == 0 || ( peers - conns ) > MAX _ DIS@@ CONN _ PEER _ ALERT _ THRESHOLD || conns > MAX _ CONN _ ALERT _ THRESHOLD || peers > MAX _ PEER _ ALERT _ THRESHOLD || ( n . b@@ w@@ limit CaMeL Delay CaMeL Alert CaMeL Relevant && b@@ w@@ limit CaMeL Delay CaMeL Time > Node . MAX _ B@@ W@@ LIMIT _ DELAY _ TIME _ ALERT _ THRESHOLD ) || ( n . node CaMeL Average CaMeL Ping CaMeL Alert CaMeL Relevant && node CaMeL Average CaMeL Ping CaMeL Time > Node . MAX _ NODE _ AVERAGE _ PING _ TIME _ ALERT _ THRESHOLD ) ) return User CaMeL Alert . CRITICAL _ ERROR ; return User CaMeL Alert . ERROR ; }	if ( ( peers == 0 ) || ( conns == 0 ) || ( ( peers - conns ) > MAX _ DIS@@ CONN _ PEER _ ALERT _ THRESHOLD ) || ( conns > MAX _ CONN _ ALERT _ THRESHOLD ) || ( peers > MAX _ PEER _ ALERT _ THRESHOLD ) || ( n . b@@ w@@ limit CaMeL Delay CaMeL Alert CaMeL Relevant && ( b@@ w@@ limit CaMeL Delay CaMeL Time > Node . MAX _ B@@ W@@ LIMIT _ DELAY _ TIME _ ALERT _ THRESHOLD ) ) || ( n . node CaMeL Average CaMeL Ping CaMeL Alert CaMeL Relevant && ( node CaMeL Average CaMeL Ping CaMeL Time > Node . MAX _ NODE _ AVERAGE _ PING _ TIME _ ALERT _ THRESHOLD ) ) )
my CaMeL Ssh CaMeL Settings CaMeL Panel = new Ssh CaMeL Connection CaMeL Settings CaMeL Panel ( ) ;  <CTX>  public Ext CaMeL Connection CaMeL Dual CaMeL Panel ( ) { my CaMeL Ext CaMeL Settings CaMeL Panel = new Ext CaMeL Connection CaMeL Settings CaMeL Panel ( ) ; my CaMeL Ssh CaMeL Settings CaMeL Panel = new Ssh CaMeL Connection CaMeL Settings CaMeL Panel ( ) ; my CaMeL Dual CaMeL Panel . add ( my CaMeL Ext CaMeL Settings CaMeL Panel . get CaMeL Panel ( ) , EXT ) ; my CaMeL Dual CaMeL Panel . add ( my CaMeL Ssh CaMeL Settings CaMeL Panel . get CaMeL Panel ( ) , SSH ) ; my CaMeL Panel . add ( my CaMeL Use CaMeL Internal CaMeL Implementation CaMeL Check CaMeL Box , Border CaMeL Layout . NORTH ) ; my CaMeL Panel . add ( my CaMeL Dual CaMeL Panel , Border CaMeL Layout . CENTER ) ; my CaMeL Use CaMeL Internal CaMeL Implementation CaMeL Check CaMeL Box . add CaMeL Action CaMeL Listener ( new Action CaMeL Listener ( ) { public void action CaMeL Performed ( Action CaMeL Event e ) { update CaMeL Page ( ) ; } } ) ; }	my CaMeL Ssh CaMeL Settings CaMeL Panel = new Ssh CaMeL Connection CaMeL Settings CaMeL Panel ( root CaMeL Provider ) ;
closure . call ( new Integer ( i ) ) ;  <CTX>  public static void times ( Number self , Closure closure ) { for ( int i = 0 , size = self . int CaMeL Value ( ) ; i < size ; i ++ ) { closure . call ( new Integer ( i ) ) ; if ( closure . get CaMeL Directive ( ) == Closure . DONE ) { break ; } } }	closure . call CaMeL Special ( new Integer ( i ) ) ;
check ( DECLARATIONS , Field CaMeL Declaration CaMeL Pattern . class , field ) ;  <CTX>  public void accept CaMeL Field ( IAST CaMeL Field field ) { check ( DECLARATIONS , Field CaMeL Declaration CaMeL Pattern . class , field ) ; }	check ( DECLARATIONS , field ) ;
if ( result != null && result . unschedule CaMeL Firing CaMeL Trigger ( ) ) return INSTRUCTION _ SET _ TRIGGER _ COMPLETE ;  <CTX>  public int execution CaMeL Complete ( Job CaMeL Execution CaMeL Context job CaMeL Ctx , Job CaMeL Execution CaMeL Exception result ) { if ( result != null && result . re@@ fire CaMeL Immediately ( ) ) return INSTRUCTION _ RE _ EXECUTE _ JOB ; if ( result != null && result . unschedule CaMeL Firing CaMeL Trigger ( ) ) return INSTRUCTION _ SET _ TRIGGER _ COMPLETE ; if ( result != null && result . unschedule CaMeL All CaMeL Triggers ( ) ) return INSTRUCTION _ SET _ ALL _ JOB _ TRIGGERS _ COMPLETE ; if ( ! may CaMeL Fire CaMeL Again ( ) ) return INSTRUCTION _ DELETE _ TRIGGER ; return INSTRUCTION _ NOOP ; }	if ( result != null && result . unschedule CaMeL Firing CaMeL Trigger ( ) ) { return INSTRUCTION _ SET _ TRIGGER _ COMPLETE ; }
abstract public void remove CaMeL Node CaMeL Change CaMeL Listener ( Node CaMeL Change CaMeL Listener listener ) ;  <CTX>  abstract public void remove CaMeL Node CaMeL Change CaMeL Listener ( Node CaMeL Change CaMeL Listener listener ) ;	public abstract void remove CaMeL Node CaMeL Change CaMeL Listener ( Node CaMeL Change CaMeL Listener listener ) ;
String [ ] ter@@ rains = { hex CaMeL Model . get CaMeL Terrain ( ) } ; new Show CaMeL All CaMeL Recru@@ its ( master CaMeL Frame , ter@@ rains , last CaMeL Point , hex CaMeL Model . get CaMeL Label ( ) , scroll CaMeL Pane ) ;  <CTX>  public void action CaMeL Performed ( Action CaMeL Event e ) { GUI CaMeL Master CaMeL Hex hex = get CaMeL Hex CaMeL Containing CaMeL Point ( last CaMeL Point ) ; if ( hex != null ) { Master CaMeL Hex hex CaMeL Model = hex . get CaMeL Master CaMeL Hex CaMeL Model ( ) ; String [ ] ter@@ rains = { hex CaMeL Model . get CaMeL Terrain ( ) } ; new Show CaMeL All CaMeL Recru@@ its ( master CaMeL Frame , ter@@ rains , last CaMeL Point , hex CaMeL Model . get CaMeL Label ( ) , scroll CaMeL Pane ) ; } }	new Show CaMeL Recru@@ its ( master CaMeL Frame , hex CaMeL Model . get CaMeL Terrain ( ) , last CaMeL Point , hex CaMeL Model . get CaMeL Label ( ) , scroll CaMeL Pane ) ;
int displacement = ( i CaMeL Code [ pc ] << 8 ) + ( i CaMeL Code [ pc + 1 ] & 0 x CaMeL FF ) ;  <CTX>  private static int get CaMeL Target ( byte [ ] i CaMeL Code , int pc ) { int displacement = ( i CaMeL Code [ pc ] << 8 ) + ( i CaMeL Code [ pc + 1 ] & 0 x CaMeL FF ) ; return pc - 1 + displacement ; }	int displacement = get CaMeL Short ( i CaMeL Code , pc ) ;
if ( root CaMeL Tag CaMeL Name != null ) { final Dom CaMeL File CaMeL Description < T > description = Container CaMeL Util . find ( my CaMeL Dom CaMeL Manager . get CaMeL File CaMeL Descriptions ( root CaMeL Tag CaMeL Name ) , my CaMeL Condition ) ;  <CTX>  private Dom CaMeL File CaMeL Description < T > find CaMeL File CaMeL Description ( final String root CaMeL Tag CaMeL Name , Module module ) { my CaMeL Condition . module = module ; if ( root CaMeL Tag CaMeL Name != null ) { final Dom CaMeL File CaMeL Description < T > description = Container CaMeL Util . find ( my CaMeL Dom CaMeL Manager . get CaMeL File CaMeL Descriptions ( root CaMeL Tag CaMeL Name ) , my CaMeL Condition ) ; if ( description != null ) { return description ; } } return Container CaMeL Util . find ( my CaMeL Dom CaMeL Manager . get CaMeL Accepting CaMeL Other CaMeL Root CaMeL Tag CaMeL Name CaMeL Descriptions ( root CaMeL Tag CaMeL Name ) , my CaMeL Condition ) ; }	final Char CaMeL Sequence text = get CaMeL File CaMeL Start CaMeL Text ( ) ; if ( text != null && contains CaMeL Root CaMeL Tags ( text . to CaMeL String ( ) ) || root CaMeL Tag CaMeL Name . get CaMeL Value ( ) != null ) { final Dom CaMeL File CaMeL Description < T > description = Container CaMeL Util . find ( my CaMeL Dom CaMeL Manager . get CaMeL File CaMeL Descriptions ( root CaMeL Tag CaMeL Name . get CaMeL Value ( ) ) , my CaMeL Condition ) ;
make CaMeL Forced CaMeL Stri@@ kes ( ) ;  <CTX>  public void act CaMeL On CaMeL Hex ( Battle CaMeL Hex hex ) { switch ( get CaMeL Phase ( ) ) { case MOVE : if ( ch@@ it CaMeL Selected ) { get CaMeL Critter ( 0 ) . move CaMeL To CaMeL Hex ( hex ) ; ch@@ it CaMeL Selected = false ; } highlight CaMeL Movable CaMeL Ch@@ its ( ) ; break ; case FI@@ GHT : case STRIKE@@ BACK : if ( get CaMeL Car@@ ry CaMeL Damage ( ) > 0 ) { apply CaMeL Car@@ ri@@ es ( hex . get CaMeL Critter ( ) ) ; } else if ( ch@@ it CaMeL Selected ) { get CaMeL Critter ( 0 ) . strike ( hex . get CaMeL Critter ( ) ) ; ch@@ it CaMeL Selected = false ; } if ( get CaMeL Car@@ ry CaMeL Damage ( ) == 0 ) { if ( game != null ) { Player player = game . get CaMeL Active CaMeL Player ( ) ; if ( player . get CaMeL Option ( Game . auto CaMeL Forced CaMeL Strike ) ) { make CaMeL Forced CaMeL Stri@@ kes ( ) ; } } highlight CaMeL Ch@@ its CaMeL With CaMeL Targets ( ) ; } break ; default : break ; } }	make CaMeL Forced CaMeL Stri@@ kes ( false ) ;
return access CaMeL Modes . contains ( access ) ;  <CTX>  public boolean cached CaMeL Is CaMeL Authorized ( String object CaMeL Name , String access , int policy CaMeL Update CaMeL Counter ) { if ( ! ALLOW _ ACCESS _ CACHING ) { return false ; } if ( policy CaMeL Update CaMeL Counter != _ policy CaMeL Update CaMeL Counter ) { flush CaMeL Authorization CaMeL Cache ( ) ; _ policy CaMeL Update CaMeL Counter = policy CaMeL Update CaMeL Counter ; return false ; } Set access CaMeL Modes = ( Set ) _ descriptors . get ( object CaMeL Name ) ; if ( access CaMeL Modes == null ) { return false ; } else { return access CaMeL Modes . contains ( access ) ; } }	for ( int i = 0 ; i < access . length ; i ++ ) { if ( ! access CaMeL Modes . contains ( access [ i ] ) ) { return false ; } } return true ;
high CaMeL Priority CaMeL Button CaMeL Action CaMeL Performed ( evt ) ;  <CTX>  public void action CaMeL Performed ( java . awt . event . Action CaMeL Event evt ) { high CaMeL Priority CaMeL Button CaMeL Action CaMeL Performed ( evt ) ; }	full CaMeL Descriptions CaMeL Item CaMeL Action CaMeL Performed ( evt ) ;
super . handle CaMeL Drop ( ) ;  <CTX>  protected void handle CaMeL Drop ( ) { final Object template = Template CaMeL Transfer . get CaMeL Instance ( ) . get CaMeL Template ( ) ; Assert . is CaMeL Not CaMeL Null ( template ) ; Assert . is CaMeL True ( handle CaMeL Validate CaMeL Drag ( template ) ) ; update CaMeL Target CaMeL Request ( ) ; update CaMeL Target CaMeL Edit CaMeL Part ( ) ; Abstract CaMeL Tool CaMeL Handle CaMeL Extends pre CaMeL Handle = null ; String trans CaMeL Name = null ; if ( template instanceof String ) { trans CaMeL Name = TRANS _ LABEL _ CREATE _ ELEMENT ; pre CaMeL Handle = Base CaMeL Palette CaMeL Factory . get CaMeL Abstract CaMeL Tool CaMeL Handle CaMeL Extends CaMeL From CaMeL Palette CaMeL Name ( template ) ; } else if ( handle CaMeL Validate CaMeL Insert ( template ) ) { trans CaMeL Name = Insert CaMeL In CaMeL Layout CaMeL Action . DISPLAY _ TEXT ; Object object CaMeL Type = get CaMeL Factory ( template ) . get CaMeL Object CaMeL Type ( ) ; if ( object CaMeL Type instanceof Data CaMeL Set CaMeL Handle ) { pre CaMeL Handle = new Data CaMeL Set CaMeL Tool CaMeL Extends ( ) ; } else if ( object CaMeL Type instanceof Data CaMeL Set CaMeL Item CaMeL Model ) { pre CaMeL Handle = new Data CaMeL Set CaMeL Column CaMeL Tool CaMeL Extends ( ) ; } else if ( object CaMeL Type instanceof Scalar CaMeL Parameter CaMeL Handle ) { pre CaMeL Handle = new Parameter CaMeL Tool CaMeL Extends ( ) ; } } else if ( handle CaMeL Validate CaMeL Library ( template ) ) { pre CaMeL Handle = new Library CaMeL Elements CaMeL Tool CaMeL Handle CaMeL Extends ( ( Design CaMeL Element CaMeL Handle ) get CaMeL Single CaMeL Transfer CaMeL Data ( template ) ) ; } if ( pre CaMeL Handle != null ) { Session CaMeL Handle CaMeL Adapter . get CaMeL Instance ( ) . get CaMeL Report CaMeL Design CaMeL Handle ( ) . get CaMeL Command CaMeL Stack ( ) . start CaMeL Trans ( trans CaMeL Name ) ; pre CaMeL Handle . set CaMeL Request ( this . get CaMeL Create CaMeL Request ( ) ) ; pre CaMeL Handle . set CaMeL Target CaMeL Edit CaMeL Part ( get CaMeL Target CaMeL Edit CaMeL Part ( ) ) ; Command command = this . get CaMeL Command ( ) ; if ( command != null && command . can CaMeL Execute ( ) ) { if ( ! ( pre CaMeL Handle . pre CaMeL Handle CaMeL Mouse CaMeL Up ( ) ) ) { Session CaMeL Handle CaMeL Adapter . get CaMeL Instance ( ) . get CaMeL Report CaMeL Design CaMeL Handle ( ) . get CaMeL Command CaMeL Stack ( ) . rollback ( ) ; return ; } } super . handle CaMeL Drop ( ) ; Session CaMeL Handle CaMeL Adapter . get CaMeL Instance ( ) . get CaMeL Report CaMeL Design CaMeL Handle ( ) . get CaMeL Command CaMeL Stack ( ) . commit ( ) ; select CaMeL Added CaMeL Object ( ) ; } }	boolean is CaMeL Theme = false ; if ( pre CaMeL Handle instanceof Library CaMeL Elements CaMeL Tool CaMeL Handle CaMeL Extends && template instanceof Object [ ] ) { Object [ ] objs = ( Object [ ] ) template ; if ( objs . length == 1 && objs [ 0 ] instanceof Theme CaMeL Handle ) { is CaMeL Theme = true ; } } if ( is CaMeL Theme == false ) { super . handle CaMeL Drop ( ) ; }
if ( input CaMeL State . guessing == 0 ) { ast CaMeL Factory . add CaMeL AST CaMeL Child ( current CaMeL AST , return CaMeL AST ) ; } if ( input CaMeL State . guessing == 0 ) { type _ AST = ( AST ) current CaMeL AST . root ; }  <CTX>  public final void type ( ) throws Recognition CaMeL Exception , Token CaMeL Stream CaMeL Exception { return CaMeL AST = null ; AST CaMeL Pair current CaMeL AST = new AST CaMeL Pair ( ) ; AST type _ AST = null ; switch ( LA ( 1 ) ) { case IDENT : { class CaMeL Or CaMeL Interface CaMeL Type ( false ) ; if ( input CaMeL State . guessing == 0 ) { ast CaMeL Factory . add CaMeL AST CaMeL Child ( current CaMeL AST , return CaMeL AST ) ; } if ( input CaMeL State . guessing == 0 ) { type _ AST = ( AST ) current CaMeL AST . root ; } break ; } case LITERAL _ void : case LITERAL _ boolean : case LITERAL _ byte : case LITERAL _ char : case LITERAL _ short : case LITERAL _ int : case LITERAL _ float : case LITERAL _ long : case LITERAL _ double : case LITERAL _ any : { built CaMeL In CaMeL Type ( ) ; if ( input CaMeL State . guessing == 0 ) { ast CaMeL Factory . add CaMeL AST CaMeL Child ( current CaMeL AST , return CaMeL AST ) ; } if ( input CaMeL State . guessing == 0 ) { type _ AST = ( AST ) current CaMeL AST . root ; } break ; } default : { throw new No CaMeL Viable CaMeL Alt CaMeL Exception ( LT ( 1 ) , get CaMeL Filename ( ) ) ; } } return CaMeL AST = type _ AST ; }	ast CaMeL Factory . add CaMeL AST CaMeL Child ( current CaMeL AST , return CaMeL AST ) ; type _ AST = ( AST ) current CaMeL AST . root ;
Block get CaMeL Root CaMeL Block ( ) ;  <CTX>  Block get CaMeL Root CaMeL Block ( ) ;	@ Not CaMeL Null Block get CaMeL Root CaMeL Block ( ) ;
Type receiver CaMeL Type = type CaMeL Frame . get CaMeL Instance ( invoke CaMeL Instruction , cpg ) ;  <CTX>  public static Set < X CaMeL Method > resolve CaMeL Method CaMeL Call CaMeL Targets ( Invoke CaMeL Instruction invoke CaMeL Instruction , Type CaMeL Frame type CaMeL Frame , Constant CaMeL Pool CaMeL Gen cpg ) throws Dataflow CaMeL Analysis CaMeL Exception , Class CaMeL Not CaMeL Found CaMeL Exception { if ( invoke CaMeL Instruction . get CaMeL Opcode ( ) == Constants . INVOKESTATIC ) { Hash CaMeL Set < X CaMeL Method > result = new Hash CaMeL Set < X CaMeL Method > ( ) ; result . add ( new Static CaMeL Method ( invoke CaMeL Instruction . get CaMeL Class CaMeL Name ( cpg ) , invoke CaMeL Instruction . get CaMeL Name ( cpg ) , invoke CaMeL Instruction . get CaMeL Signature ( cpg ) , Constants . ACC _ STATIC | Constants . ACC _ PUBLIC ) ) ; return result ; } if ( ! type CaMeL Frame . is CaMeL Valid ( ) ) { return new Hash CaMeL Set < X CaMeL Method > ( ) ; } Type receiver CaMeL Type = type CaMeL Frame . get CaMeL Instance ( invoke CaMeL Instruction , cpg ) ; if ( ! ( receiver CaMeL Type instanceof Reference CaMeL Type ) ) { return new Hash CaMeL Set < X CaMeL Method > ( ) ; } / / XXX : check whe@@ ther or not type is exact return resolve CaMeL Method CaMeL Call CaMeL Targets ( ( Reference CaMeL Type ) receiver CaMeL Type , invoke CaMeL Instruction , cpg , false ) ; }	int instance CaMeL Slot = type CaMeL Frame . get CaMeL Instance CaMeL Slot ( invoke CaMeL Instruction , cpg ) ; Type receiver CaMeL Type = type CaMeL Frame . get CaMeL Value ( instance CaMeL Slot ) ;
new VO CaMeL Table CaMeL Writer ( Data CaMeL Format . BINARY , true ) . write CaMeL Star CaMeL Table ( table , ostrm , null ) ;  <CTX>  public void run ( ) { try { new VO CaMeL Table CaMeL Writer ( Data CaMeL Format . BINARY , true ) . write CaMeL Star CaMeL Table ( table , ostrm , null ) ; } catch ( IO CaMeL Exception e ) { / / may well catch an exception if the reader stops reading } finally { try { ostrm . close ( ) ; } catch ( IO CaMeL Exception e ) { / / no action } } }	outputter . transfer CaMeL Table ( table , ostrm ) ;
get CaMeL Font CaMeL Metrics ( Font font ) ;  <CTX>  get CaMeL Font CaMeL Metrics ( Font font ) ;	get CaMeL Font CaMeL Metrics ( ) { return ( get CaMeL Font CaMeL Metrics ( get CaMeL Font ( ) ) ) ; }
else if ( location > jc . get CaMeL Size ( ) . width )  <CTX>  public void set CaMeL Divider CaMeL Location ( J CaMeL Split CaMeL Pane jc , int location ) { location = valid CaMeL Location ( location ) ; Container p = jc . get CaMeL Parent ( ) ; Dimension right CaMeL Pref CaMeL Size = jc . get CaMeL Right CaMeL Component ( ) . get CaMeL Preferred CaMeL Size ( ) ; if ( get CaMeL Orientation ( ) == 0 && location > jc . get CaMeL Size ( ) . height ) { location = jc . get CaMeL Size ( ) . height ; while ( p != null ) { p . set CaMeL Size ( p . get CaMeL Width ( ) , p . get CaMeL Height ( ) + right CaMeL Pref CaMeL Size . height ) ; p = p . get CaMeL Parent ( ) ; } } else if ( location > jc . get CaMeL Size ( ) . width ) { location = jc . get CaMeL Size ( ) . width ; while ( p != null ) { p . set CaMeL Size ( p . get CaMeL Width ( ) + right CaMeL Pref CaMeL Size . width , p . get CaMeL Height ( ) ) ; p = p . get CaMeL Parent ( ) ; } } set CaMeL Last CaMeL Drag CaMeL Location ( get CaMeL Divider CaMeL Location ( split CaMeL Pane ) ) ; split CaMeL Pane . set CaMeL Last CaMeL Divider CaMeL Location ( get CaMeL Divider CaMeL Location ( split CaMeL Pane ) ) ; int [ ] tmp CaMeL Sizes = layout CaMeL Manager . get CaMeL Sizes ( ) ; tmp CaMeL Sizes [ 0 ] = location - layout CaMeL Manager . get CaMeL Initial CaMeL Location ( split CaMeL Pane . get CaMeL Insets ( ) ) ; tmp CaMeL Sizes [ 1 ] = layout CaMeL Manager . get CaMeL Available CaMeL Size ( split CaMeL Pane . get CaMeL Size ( ) , split CaMeL Pane . get CaMeL Insets ( ) ) - tmp CaMeL Sizes [ 0 ] ; layout CaMeL Manager . set CaMeL Sizes ( tmp CaMeL Sizes ) ; split CaMeL Pane . revalidate ( ) ; split CaMeL Pane . repaint ( ) ; }	else if ( location > size . width )
if ( entry . is CaMeL Getter CaMeL Entry ) { list . add ( entry . field ) ;  <CTX>  private static I CaMeL Field [ ] get CaMeL Getter CaMeL Fields ( Object [ ] result ) { Collection list = new Array CaMeL List ( 0 ) ; Object each = null ; Getter CaMeL Setter CaMeL Entry entry = null ; for ( int i = 0 ; i < result . length ; i ++ ) { each = result [ i ] ; if ( ( each instanceof Getter CaMeL Setter CaMeL Entry ) ) { entry = ( Getter CaMeL Setter CaMeL Entry ) each ; if ( entry . is CaMeL Getter CaMeL Entry ) { list . add ( entry . field ) ; } } } return ( I CaMeL Field [ ] ) list . to CaMeL Array ( new I CaMeL Field [ list . size ( ) ] ) ; }	if ( entry . f CaMeL Getter CaMeL Entry ) { list . add ( entry . f CaMeL Field ) ;
return js _ Na CaMeL N _ date _ str ;  <CTX>  private static String to CaMeL Locale _ helper ( double t , java . text . Date CaMeL Format formatter ) { if ( t != t ) return js _ Na CaMeL N _ date _ str ; java . util . Date temp@@ date = new Date ( ( long ) t ) ; return formatter . format ( temp@@ date ) ; }	return js CaMeL Function _ Na CaMeL N _ date _ str ;
if ( ret != null )  <CTX>  public region union ( region r ) { assert r != null ; assert r . rank == rank ; region ret = null ; if ( r instanceof Multi CaMeL Dim CaMeL Region ) { Multi CaMeL Dim CaMeL Region rc = ( Multi CaMeL Dim CaMeL Region ) r ; region [ ] d = new region [ rank ] ; for ( int i = 0 ; ret == null && i < d . length ; ++ i ) { d [ i ] = dims _ [ i ] . union ( rc . dims _ [ i ] ) ; if ( d [ i ] . size ( ) == 0 ) ret = new Empty CaMeL Region ( rank ) ; } if ( ret != null ) ret = new Multi CaMeL Dim CaMeL Region ( d ) ; } else { ret = Arbitrary CaMeL Region . union ( this , r ) ; } return ret ; }	if ( ret == null )
return new Byte CaMeL Array CaMeL Input CaMeL Stream ( source CaMeL File . get CaMeL Data ( ) ) ;  <CTX>  public Input CaMeL Stream open CaMeL Source ( String package CaMeL Name , String file CaMeL Name ) throws IO CaMeL Exception { Source CaMeL File source CaMeL File = find CaMeL Source CaMeL File ( package CaMeL Name , file CaMeL Name ) ; return new Byte CaMeL Array CaMeL Input CaMeL Stream ( source CaMeL File . get CaMeL Data ( ) ) ; }	return source CaMeL File . get CaMeL Input CaMeL Stream ( ) ;
wc CaMeL Client . do CaMeL Info ( my CaMeL Base CaMeL File , revision , recursive , this ) ;  <CTX>  public final void run ( final Print CaMeL Stream out , Print CaMeL Stream err ) throws SVN CaMeL Exception { final boolean recursive = get CaMeL Command CaMeL Line ( ) . has CaMeL Argument ( SVN CaMeL Argument . RECURSIVE ) ; SVN CaMeL Revision revision = SVN CaMeL Revision . UNDEFINED ; if ( get CaMeL Command CaMeL Line ( ) . has CaMeL Argument ( SVN CaMeL Argument . RECURSIVE ) ) { revision = SVN CaMeL Revision . parse ( ( String ) get CaMeL Command CaMeL Line ( ) . get CaMeL Argument CaMeL Value ( SVN CaMeL Argument . REVISION ) ) ; } SVNWC CaMeL Client wc CaMeL Client = get CaMeL Client CaMeL Manager ( ) . get CaMeL WC CaMeL Client ( ) ; my CaMeL Out = out ; for ( int i = 0 ; i < get CaMeL Command CaMeL Line ( ) . get CaMeL Path CaMeL Count ( ) ; i ++ ) { my CaMeL Base CaMeL File = new File ( get CaMeL Command CaMeL Line ( ) . get CaMeL Path CaMeL At ( i ) ) ; wc CaMeL Client . do CaMeL Info ( my CaMeL Base CaMeL File , revision , recursive , this ) ; } my CaMeL Base CaMeL File = null ; for ( int i = 0 ; i < get CaMeL Command CaMeL Line ( ) . get CaMeL URL CaMeL Count ( ) ; i ++ ) { String url = get CaMeL Command CaMeL Line ( ) . get CaMeL URL ( i ) ; SVN CaMeL Revision peg = get CaMeL Command CaMeL Line ( ) . get CaMeL Peg CaMeL Revision ( i ) ; wc CaMeL Client . do CaMeL Info ( SVNURL . parse CaMeL URI CaMeL Encoded ( url ) , peg , revision , recursive , this ) ; } }	SVN CaMeL Revision peg = get CaMeL Command CaMeL Line ( ) . get CaMeL Path CaMeL Peg CaMeL Revision ( i ) ; wc CaMeL Client . do CaMeL Info ( my CaMeL Base CaMeL File , peg , revision , recursive , this ) ;
Tasks CaMeL Ui CaMeL Plugin . get CaMeL Synchronization CaMeL Manager ( ) . synch CaMeL Now ( 0 , null ) ;  <CTX>  public void run ( I CaMeL Action action ) { Tasks CaMeL Ui CaMeL Plugin . get CaMeL Synchronization CaMeL Manager ( ) . synch CaMeL Now ( 0 , null ) ; }	Tasks CaMeL Ui CaMeL Plugin . get CaMeL Synchronization CaMeL Scheduler ( ) . synch CaMeL Now ( 0 , null ) ;
get CaMeL Requesting CaMeL Scheme ( ) { return ( scheme ) ; }  <CTX>  get CaMeL Requesting CaMeL Scheme ( ) { return ( scheme ) ; }	protected final String get CaMeL Requesting CaMeL Scheme ( ) { return scheme ; }
return new Local CaMeL Quick CaMeL Fix [ 0 ] ;  <CTX>  private Local CaMeL Quick CaMeL Fix [ ] create CaMeL Fixes ( Psi CaMeL Element location ) { if ( ! on CaMeL The CaMeL Fly && inspection . build CaMeL Quick CaMeL Fixes CaMeL Only CaMeL For CaMeL On CaMeL The CaMeL Fly CaMeL Errors ( ) ) { return new Local CaMeL Quick CaMeL Fix [ 0 ] ; } final Inspection CaMeL Gadgets CaMeL Fix [ ] fixes = inspection . build CaMeL Fixes ( location ) ; if ( fixes != null ) { return fixes ; } final Inspection CaMeL Gadgets CaMeL Fix fix = inspection . build CaMeL Fix ( location ) ; if ( fix == null ) { return new Local CaMeL Quick CaMeL Fix [ 0 ] ; } return new Inspection CaMeL Gadgets CaMeL Fix [ ] { fix } ; }	return null ;
I CaMeL Editor CaMeL Part editor CaMeL Part = page . open CaMeL Editor ( new Report CaMeL Editor CaMeL Input ( file ) ,  <CTX>  public void run ( ) { I CaMeL Workbench workbench = Platform CaMeL UI . get CaMeL Workbench ( ) ; I CaMeL Workbench CaMeL Window window = workbench . get CaMeL Active CaMeL Workbench CaMeL Window ( ) ; I CaMeL Workbench CaMeL Page page = window . get CaMeL Active CaMeL Page ( ) ; try { I CaMeL Editor CaMeL Part editor CaMeL Part = page . open CaMeL Editor ( new Report CaMeL Editor CaMeL Input ( file ) , I CaMeL Report CaMeL Editor CaMeL Con@@ tants . LIBRARY _ EDITOR _ ID , true ) ; Module CaMeL Handle model = Session CaMeL Handle CaMeL Adapter . get CaMeL Instance ( ) . get CaMeL Report CaMeL Design CaMeL Handle ( ) ; if ( Report CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Enable CaMeL Comment CaMeL Preference ( ) ) { model . set CaMeL String CaMeL Property ( Module CaMeL Handle . COMMENTS _ PROP , Report CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Comment CaMeL Preference ( ) ) ; model . save ( ) ; editor CaMeL Part . do CaMeL Save ( null ) ; } } catch ( Exception e ) { Exception CaMeL Handler . handle ( e ) ; } }	page . open CaMeL Editor ( new Report CaMeL Editor CaMeL Input ( file ) ,
get CaMeL Parent ( ) . insert CaMeL Child ( this , get CaMeL Role _ ( ) , this , true ) ;  <CTX>  public void add CaMeL Prev CaMeL Sibling ( S CaMeL Node new CaMeL Sibling ) { get CaMeL Parent ( ) . insert CaMeL Child ( this , get CaMeL Role _ ( ) , this , true ) ; }	get CaMeL Parent ( ) . insert CaMeL Child ( this , get CaMeL Role _ ( ) , new CaMeL Sibling , true ) ;
list . set CaMeL Content CaMeL Provider ( new Per@@ sp CaMeL Content CaMeL Provider ( filtering ) ) ;  <CTX>  private Table CaMeL Viewer create CaMeL Viewer ( Composite parent , boolean filtering ) { / / Add perspective list . Table CaMeL Viewer list = new Table CaMeL Viewer ( parent , SWT . H _ SCROLL | SWT . V _ SCROLL | SWT . BORDER ) ; list . get CaMeL Table ( ) . set CaMeL Font ( parent . get CaMeL Font ( ) ) ; list . set CaMeL Label CaMeL Provider ( new Perspective CaMeL Label CaMeL Provider ( ) ) ; list . set CaMeL Content CaMeL Provider ( new Per@@ sp CaMeL Content CaMeL Provider ( filtering ) ) ; list . set CaMeL Sorter ( new Viewer CaMeL Sorter ( ) ) ; list . set CaMeL Input ( per@@ sp CaMeL Reg ) ; list . add CaMeL Selection CaMeL Changed CaMeL Listener ( this ) ; list . add CaMeL Double CaMeL Click CaMeL Listener ( new I CaMeL Double CaMeL Click CaMeL Listener ( ) { public void double CaMeL Click ( Double CaMeL Click CaMeL Event event ) { handle CaMeL Double CaMeL Click CaMeL Event ( ) ; } } ) ; return list ; }	list . set CaMeL Content CaMeL Provider ( new Per@@ sp CaMeL Content CaMeL Provider ( ) ) ;
( ( Opt CaMeL Local CaMeL Variable ) the CaMeL Variables . get ( i ) ) . assign CaMeL Type ( Type CaMeL Event . Any CaMeL Type ) ;  <CTX>  void mark CaMeL Any CaMeL Type CaMeL Variables ( Variable CaMeL Table the CaMeL Variables ) { for ( int i = 0 ; i < the CaMeL Variables . size ( ) ; i ++ ) if ( its CaMeL Live CaMeL On CaMeL Entry CaMeL Set . test ( i ) ) ( ( Opt CaMeL Local CaMeL Variable ) the CaMeL Variables . get ( i ) ) . assign CaMeL Type ( Type CaMeL Event . Any CaMeL Type ) ; }	( ( Opt CaMeL Local CaMeL Variable ) the CaMeL Variables . get CaMeL Variable ( i ) ) . assign CaMeL Type ( Type CaMeL Event . Any CaMeL Type ) ;
message CaMeL Event CaMeL Producer . notify CaMeL Listeners ( request , Message CaMeL Event . REQUEST _ RECEIVED , body CaMeL ID ) ;  <CTX>  protected void internal CaMeL Receive CaMeL Request ( Request request ) throws java . io . IO CaMeL Exception { if ( message CaMeL Event CaMeL Producer != null ) message CaMeL Event CaMeL Producer . notify CaMeL Listeners ( request , Message CaMeL Event . REQUEST _ RECEIVED , body CaMeL ID ) ; request CaMeL Receiver . receive CaMeL Request ( request , this ) ; }	message CaMeL Event CaMeL Producer . notify CaMeL Listeners ( request , Message CaMeL Event . REQUEST _ RECEIVED , body CaMeL ID , get CaMeL Request CaMeL Queue ( ) . size ( ) + 1 ) ;
Enter CaMeL Interrupt ( Main main , Stack CaMeL Frame last CaMeL Frame , String thread CaMeL Title ,  <CTX>  Enter CaMeL Interrupt ( Main main , Stack CaMeL Frame last CaMeL Frame , String thread CaMeL Title , String alert CaMeL Message ) { this . main = main ; this . last CaMeL Frame = last CaMeL Frame ; this . thread CaMeL Title = thread CaMeL Title ; this . alert CaMeL Message = alert CaMeL Message ; }	Enter CaMeL Interrupt ( Debug CaMeL Gui debug CaMeL Gui , Stack CaMeL Frame last CaMeL Frame , String thread CaMeL Title ,
if ( ! array CaMeL Assigned ) super . visit CaMeL Element ( element ) ;  <CTX>  public void visit CaMeL Element ( Psi CaMeL Element element ) { if ( ! array CaMeL Assigned ) super . visit CaMeL Element ( element ) ; }	if ( ! array CaMeL Assigned ) { super . visit CaMeL Element ( element ) ; }
String result = title ; if ( part != null ) result = part . get CaMeL Title ( ) ; return Util . safe CaMeL String ( result ) ;  <CTX>  public String get CaMeL Title ( ) { String result = title ; if ( part != null ) result = part . get CaMeL Title ( ) ; return Util . safe CaMeL String ( result ) ; }	return Util . safe CaMeL String ( title ) ;
if ( marker CaMeL Severity == I CaMeL Marker . SEVERITY _ ERROR )  <CTX>  private boolean select CaMeL By CaMeL Severity ( Problem CaMeL Marker item ) { if ( select CaMeL By CaMeL Severity ) { int marker CaMeL Severity = item . get CaMeL Severity ( ) ; if ( marker CaMeL Severity == I CaMeL Marker . SEVERITY _ ERROR ) return ( severity & SEVERITY _ ERROR ) > 0 ; else if ( marker CaMeL Severity == I CaMeL Marker . SEVERITY _ WARNING ) return ( severity & SEVERITY _ WARNING ) > 0 ; else if ( marker CaMeL Severity == I CaMeL Marker . SEVERITY _ INFO ) return ( severity & SEVERITY _ INFO ) > 0 ; } return true ; }	if ( marker CaMeL Severity == I CaMeL Marker . SEVERITY _ ERROR ) {
List listener CaMeL List = ( List ) _ listener CaMeL Class CaMeL Model CaMeL Events CaMeL Map . get ( get CaMeL Key ( model CaMeL Class , event CaMeL Name ) ) ;  <CTX>  private void execute CaMeL Remove CaMeL Class CaMeL Model CaMeL Event CaMeL Listener ( M CaMeL Element CaMeL Listener listener , Class model CaMeL Class , String event CaMeL Name ) { List listener CaMeL List = ( List ) _ listener CaMeL Class CaMeL Model CaMeL Events CaMeL Map . get ( get CaMeL Key ( model CaMeL Class , event CaMeL Name ) ) ; if ( listener CaMeL List == null ) return ; listener CaMeL List . remove ( listener ) ; if ( listener CaMeL List . is CaMeL Empty ( ) ) _ listener CaMeL Class CaMeL Model CaMeL Events CaMeL Map . remove ( get CaMeL Key ( model CaMeL Class , event CaMeL Name ) ) ; }	Set listener CaMeL List = ( Set ) _ listener CaMeL Class CaMeL Model CaMeL Events CaMeL Map . get ( get CaMeL Key ( model CaMeL Class , event CaMeL Name ) ) ;
notify ( ) ;  <CTX>  private void add CaMeL Change ( Change changes ) { synchronized ( _ elements ) { _ elements . add ( changes ) ; notify ( ) ; } }	_ elements . notify ( ) ;
Processor CaMeL Definition main CaMeL Processor CaMeL Definition = Init CaMeL Utils . get CaMeL Definition CaMeL From CaMeL Map ( new Servlet CaMeL Init CaMeL Map ( this ) , Processor CaMeL Service . MAIN _ PROCESSOR _ PROPERTY _ PREFIX ,  <CTX>  public void init ( ) throws Servlet CaMeL Exception { try { / / Make sure the Web app context is initialized Servlet CaMeL Context servlet CaMeL Context = get CaMeL Servlet CaMeL Context ( ) ; web CaMeL App CaMeL Context = Web CaMeL App CaMeL Context . instance ( servlet CaMeL Context ) ; / / Try to obtain a local processor definition Processor CaMeL Definition main CaMeL Processor CaMeL Definition = Init CaMeL Utils . get CaMeL Definition CaMeL From CaMeL Map ( new Servlet CaMeL Init CaMeL Map ( this ) , Processor CaMeL Service . MAIN _ PROCESSOR _ PROPERTY _ PREFIX , Processor CaMeL Service . MAIN _ PROCESSOR _ INPUT _ PROPERTY _ PREFIX ) ; / / Try to obtain a processor definition from the properties if ( main CaMeL Processor CaMeL Definition == null ) main CaMeL Processor CaMeL Definition = Init CaMeL Utils . get CaMeL Definition CaMeL From CaMeL Properties ( Processor CaMeL Service . MAIN _ PROCESSOR _ PROPERTY _ PREFIX , Processor CaMeL Service . MAIN _ PROCESSOR _ INPUT _ PROPERTY _ PREFIX ) ; / / Try to obtain a processor definition from the context if ( main CaMeL Processor CaMeL Definition == null ) main CaMeL Processor CaMeL Definition = Init CaMeL Utils . get CaMeL Definition CaMeL From CaMeL Servlet CaMeL Context ( servlet CaMeL Context , Processor CaMeL Service . MAIN _ PROCESSOR _ PROPERTY _ PREFIX , Processor CaMeL Service . MAIN _ PROCESSOR _ INPUT _ PROPERTY _ PREFIX ) ; / / Create and initialize service processor CaMeL Service = new Processor CaMeL Service ( ) ; processor CaMeL Service . init ( main CaMeL Processor CaMeL Definition ) ; } catch ( Exception e ) { throw new Servlet CaMeL Exception ( OXF CaMeL Exception . get CaMeL Root CaMeL Throwable ( e ) ) ; } }	Processor CaMeL Definition main CaMeL Processor CaMeL Definition ; { main CaMeL Processor CaMeL Definition = Init CaMeL Utils . get CaMeL Definition CaMeL From CaMeL Map ( new Servlet CaMeL Init CaMeL Map ( this ) , Processor CaMeL Service . MAIN _ PROCESSOR _ PROPERTY _ PREFIX , Processor CaMeL Service . MAIN _ PROCESSOR _ INPUT _ PROPERTY _ PREFIX ) ; if ( main CaMeL Processor CaMeL Definition == null ) main CaMeL Processor CaMeL Definition = Init CaMeL Utils . get CaMeL Definition CaMeL From CaMeL Properties ( Processor CaMeL Service . MAIN _ PROCESSOR _ PROPERTY _ PREFIX ,
return Ruby CaMeL String . new CaMeL String ( get CaMeL Runtime ( ) , field . get CaMeL Name ( ) ) ;  <CTX>  public Ruby CaMeL String name ( ) { return Ruby CaMeL String . new CaMeL String ( get CaMeL Runtime ( ) , field . get CaMeL Name ( ) ) ; }	return get CaMeL Runtime ( ) . new CaMeL String ( field . get CaMeL Name ( ) ) ;
Input CaMeL Stream source = SVN CaMeL File CaMeL Util . DUMMY _ IN ;  <CTX>  private byte [ ] get CaMeL Next CaMeL Text CaMeL Chunk ( int start CaMeL Index ) throws SVN CaMeL Exception { Byte CaMeL Array CaMeL Output CaMeL Stream target = new Byte CaMeL Array CaMeL Output CaMeL Stream ( ) ; Byte CaMeL Array CaMeL Output CaMeL Stream data = new Byte CaMeL Array CaMeL Output CaMeL Stream ( ) ; Input CaMeL Stream source = SVN CaMeL File CaMeL Util . DUMMY _ IN ; for ( List CaMeL Iterator states = my CaMeL Rep CaMeL State CaMeL List . list CaMeL Iterator ( start CaMeL Index + 1 ) ; states . has CaMeL Previous ( ) ; ) { FS CaMeL Representation CaMeL State state = ( FS CaMeL Representation CaMeL State ) states . previous ( ) ; data . reset ( ) ; SVN CaMeL Diff CaMeL Window window = null ; try { window = read CaMeL Window ( state , my CaMeL Chunk CaMeL Index , data ) ; } catch ( IO CaMeL Exception ioe ) { SVN CaMeL Error CaMeL Message err = SVN CaMeL Error CaMeL Message . create ( SVN CaMeL Error CaMeL Code . IO _ ERROR , ioe . get CaMeL Localized CaMeL Message ( ) ) ; SVN CaMeL Error CaMeL Manager . error ( err , ioe ) ; } SVN CaMeL Diff CaMeL Window CaMeL Apply CaMeL Baton apply CaMeL Baton = SVN CaMeL Diff CaMeL Window CaMeL Apply CaMeL Baton . create ( source , target , null ) ; window . apply ( apply CaMeL Baton , new Byte CaMeL Array CaMeL Input CaMeL Stream ( data . to CaMeL Byte CaMeL Array ( ) ) ) ; if ( states . has CaMeL Previous ( ) ) { source = new Byte CaMeL Array CaMeL Input CaMeL Stream ( target . to CaMeL Byte CaMeL Array ( ) ) ; target . reset ( ) ; } } my CaMeL Chunk CaMeL Index ++ ; return target . to CaMeL Byte CaMeL Array ( ) ; }	byte [ ] target CaMeL View = null ; byte [ ] source CaMeL View = null ;
&& ! dialog . get CaMeL Shell ( ) . is CaMeL Disposed ( ) ) parent = dialog . get CaMeL Shell ( ) ;  <CTX>  public void handle CaMeL Exception ( Throwable t ) { try { exception CaMeL Count ++ ; if ( exception CaMeL Count > 1 ) { if ( closing ) { return ; } Shell parent = default CaMeL Parent ; if ( dialog != null && dialog . get CaMeL Shell ( ) != null && ! dialog . get CaMeL Shell ( ) . is CaMeL Disposed ( ) ) parent = dialog . get CaMeL Shell ( ) ; Message CaMeL Box box = new Message CaMeL Box ( parent , SWT . ICON _ ERROR | SWT . YES | SWT . NO | SWT . SYSTEM _ MODAL ) ; box . set CaMeL Text ( MSG _ FATAL _ ERROR _ Recursive CaMeL Title ) ; box . set CaMeL Message ( Message CaMeL Format . format ( MSG _ FATAL _ ERROR , new Object [ ] { MSG _ FATAL _ ERROR _ Recursive } ) ) ; int result = box . open ( ) ; if ( result == SWT . YES ) { close CaMeL Workbench ( ) ; } } else { if ( open CaMeL Question CaMeL Dialog ( t ) ) { close CaMeL Workbench ( ) ; } } } finally { exception CaMeL Count -- ; } }	&& ! dialog . get CaMeL Shell ( ) . is CaMeL Disposed ( ) ) { parent = dialog . get CaMeL Shell ( ) ; }
EMIT ( MIR _ Binary CaMeL Acc . create ( IA 32 _ SUB , R ( lowlhs CaMeL Reg ) , R ( lowrhs CaMeL Reg ) ) ) ; EMIT ( MIR _ Binary CaMeL Acc . mutate ( s , IA 32 _ SBB , R ( lhs CaMeL Reg ) , R ( rhs CaMeL Reg ) ) ) ;  <CTX>  protected final void LONG _ SUB ( OPT _ Instruction s , OPT _ Register CaMeL Operand result , OPT _ Operand value ) { OPT _ Register lhs CaMeL Reg = result . register ; OPT _ Register lowlhs CaMeL Reg = regpool . get CaMeL Second CaMeL Reg ( lhs CaMeL Reg ) ; if ( value instanceof OPT _ Register CaMeL Operand ) { OPT _ Register rhs CaMeL Reg = ( ( OPT _ Register CaMeL Operand ) value ) . register ; OPT _ Register lowrhs CaMeL Reg = regpool . get CaMeL Second CaMeL Reg ( rhs CaMeL Reg ) ; EMIT ( MIR _ Binary CaMeL Acc . create ( IA 32 _ SUB , R ( lowlhs CaMeL Reg ) , R ( lowrhs CaMeL Reg ) ) ) ; EMIT ( MIR _ Binary CaMeL Acc . mutate ( s , IA 32 _ SBB , R ( lhs CaMeL Reg ) , R ( rhs CaMeL Reg ) ) ) ; } else { OPT _ Long CaMeL Constant CaMeL Operand rhs = ( OPT _ Long CaMeL Constant CaMeL Operand ) value ; int low = rhs . lower 32 ( ) ; int high = rhs . upper 32 ( ) ; if ( low == 0 ) { EMIT ( MIR _ Binary CaMeL Acc . mutate ( s , IA 32 _ SUB , R ( lhs CaMeL Reg ) , IC ( high ) ) ) ; } else { EMIT ( MIR _ Binary CaMeL Acc . create ( IA 32 _ SUB , R ( lowlhs CaMeL Reg ) , IC ( low ) ) ) ; EMIT ( MIR _ Binary CaMeL Acc . mutate ( s , IA 32 _ SBB , R ( lhs CaMeL Reg ) , IC ( high ) ) ) ; } } }	EMIT ( MIR _ Binary CaMeL Acc . create ( IA 32 _ SUB , new OPT _ Register CaMeL Operand ( lowlhs CaMeL Reg , VM _ Type CaMeL Reference . Int ) , new OPT _ Register CaMeL Operand ( lowrhs CaMeL Reg , VM _ Type CaMeL Reference . Int ) ) ) ; EMIT ( MIR _ Binary CaMeL Acc . mutate ( s , IA 32 _ SBB , new OPT _ Register CaMeL Operand ( lhs CaMeL Reg , VM _ Type CaMeL Reference . Int ) , new OPT _ Register CaMeL Operand ( rhs CaMeL Reg , VM _ Type CaMeL Reference . Int ) ) ) ;
return ( Package [ ] ) this . pkgs . to CaMeL Array ( new Package [ this . pkgs . size ( ) ] ) ;  <CTX>  public Package [ ] get CaMeL Packages ( ) { return ( Package [ ] ) this . pkgs . to CaMeL Array ( new Package [ this . pkgs . size ( ) ] ) ; }	return ( Package [ ] ) this . pkgs . values ( ) . to CaMeL Array ( new Package [ this . pkgs . size ( ) ] ) ;
boolean force CaMeL Update = element instanceof I CaMeL Query CaMeL Hit ;  <CTX>  public void run ( ) { I CaMeL Selection selection = viewer . get CaMeL Selection ( ) ; Object element = ( ( I CaMeL Structured CaMeL Selection ) selection ) . get CaMeL First CaMeL Element ( ) ; if ( element instanceof I CaMeL Task || element instanceof I CaMeL Query CaMeL Hit ) { final I CaMeL Task task ; if ( element instanceof I CaMeL Query CaMeL Hit ) { task = ( ( I CaMeL Query CaMeL Hit ) element ) . get CaMeL Or CaMeL Create CaMeL Corresponding CaMeL Task ( ) ; } else { task = ( I CaMeL Task ) element ; } boolean force CaMeL Update = element instanceof I CaMeL Query CaMeL Hit ; final Abstract CaMeL Repository CaMeL Client client = My@@ lar CaMeL Task CaMeL List CaMeL Plugin . get CaMeL Repository CaMeL Manager ( ) . get CaMeL Repository CaMeL Client ( task . get CaMeL Repository CaMeL Kind ( ) ) ; if ( ! task . is CaMeL Local ( ) && client != null ) { Job refresh CaMeL Job = client . synchronize ( task , force CaMeL Update ) ; if ( refresh CaMeL Job == null ) { Task CaMeL List CaMeL Ui CaMeL Util . open CaMeL Editor ( task ) ; } else { refresh CaMeL Job . add CaMeL Job CaMeL Change CaMeL Listener ( new I CaMeL Job CaMeL Change CaMeL Listener ( ) { public void done ( I CaMeL Job CaMeL Change CaMeL Event event ) { Task CaMeL List CaMeL Ui CaMeL Util . open CaMeL Editor ( task ) ; } public void about CaMeL To CaMeL Run ( I CaMeL Job CaMeL Change CaMeL Event event ) { / / ignore } public void awake ( I CaMeL Job CaMeL Change CaMeL Event event ) { / / ignore } public void running ( I CaMeL Job CaMeL Change CaMeL Event event ) { / / ignore } public void scheduled ( I CaMeL Job CaMeL Change CaMeL Event event ) { / / ignore } public void sleep@@ ing ( I CaMeL Job CaMeL Change CaMeL Event event ) { / / ignore } } ) ; } } else { Task CaMeL List CaMeL Ui CaMeL Util . open CaMeL Editor ( task ) ; } } else if ( element instanceof I CaMeL Task CaMeL Category ) { Task CaMeL List CaMeL Ui CaMeL Util . open CaMeL Editor ( ( I CaMeL Task CaMeL Category ) element ) ; } else if ( element instanceof I CaMeL Repository CaMeL Query ) { I CaMeL Repository CaMeL Query query = ( I CaMeL Repository CaMeL Query ) element ; Abstract CaMeL Repository CaMeL Client client = My@@ lar CaMeL Task CaMeL List CaMeL Plugin . get CaMeL Repository CaMeL Manager ( ) . get CaMeL Repository CaMeL Client ( query . get CaMeL Repository CaMeL Kind ( ) ) ; client . open CaMeL Edit CaMeL Query CaMeL Dialog ( query ) ; } }	boolean force CaMeL Update = false ;
step CaMeL Meta . distribu@@ tes = false ;  <CTX>  public void widget CaMeL Selected ( Selection CaMeL Event e ) { step CaMeL Meta . distribu@@ tes = false ; spoon . refresh CaMeL Graph ( ) ; spoon . refresh CaMeL Tree ( ) ; }	step CaMeL Meta . distribu@@ tes = true ;
return new Array CaMeL List ( ( ( View ) model ) . get CaMeL Children ( ) ) ;  <CTX>  protected List get CaMeL Model CaMeL Children ( ) { Object model = get CaMeL Model ( ) ; if ( model != null && model instanceof View ) { return new Array CaMeL List ( ( ( View ) model ) . get CaMeL Children ( ) ) ; } return Collections . EMPTY _ LIST ; }	return ( ( View ) model ) . get CaMeL Children ( ) ;
return super . get CaMeL Process CaMeL Versions ( ) ; }  <CTX>  public I CaMeL Process CaMeL Versions get CaMeL Process CaMeL Versions ( ) { return super . get CaMeL Process CaMeL Versions ( ) ; }	return this . process CaMeL Versions ; }
int get CaMeL Month CaMeL Of CaMeL Year ( long millis , int year ) { long month CaMeL Zero CaMeL Based = ( millis - get CaMeL Year CaMeL Millis ( year ) ) / MILLIS _ PER _ MONTH ; return ( ( int ) month CaMeL Zero CaMeL Based ) + 1 ;  <CTX>  int get CaMeL Month CaMeL Of CaMeL Year ( long millis , int year ) { long month CaMeL Zero CaMeL Based = ( millis - get CaMeL Year CaMeL Millis ( year ) ) / MILLIS _ PER _ MONTH ; return ( ( int ) month CaMeL Zero CaMeL Based ) + 1 ; }	int get CaMeL Month CaMeL Of CaMeL Year ( long millis ) { return ( get CaMeL Day CaMeL Of CaMeL Year ( millis ) - 1 ) / MONTH _ LENGTH + 1 ;
return Endian CaMeL Util . read CaMeL Swapped CaMeL Unsigned CaMeL Short ( m _ input ) ;  <CTX>  public int read CaMeL Unsigned CaMeL Short ( ) throws IO CaMeL Exception , EOF CaMeL Exception { return Endian CaMeL Util . read CaMeL Swapped CaMeL Unsigned CaMeL Short ( m _ input ) ; }	return Endian CaMeL Utils . read CaMeL Swapped CaMeL Unsigned CaMeL Short ( m _ input ) ;
_ compiler CaMeL Error CaMeL Panel . reset ( ) ; if ( in CaMeL Debug CaMeL Mode ( ) ) { _ model . get CaMeL Active CaMeL Document ( ) . check CaMeL If CaMeL Class CaMeL File CaMeL In CaMeL Sync ( ) ; _ update CaMeL Debug CaMeL Status ( ) ; } hourglass CaMeL Off ( ) ;  <CTX>  public void run ( ) { _ compiler CaMeL Error CaMeL Panel . reset ( ) ; if ( in CaMeL Debug CaMeL Mode ( ) ) { _ model . get CaMeL Active CaMeL Document ( ) . check CaMeL If CaMeL Class CaMeL File CaMeL In CaMeL Sync ( ) ; _ update CaMeL Debug CaMeL Status ( ) ; } hourglass CaMeL Off ( ) ; }	_ junit CaMeL Error CaMeL Panel . get CaMeL Error CaMeL List CaMeL Pane ( ) . test CaMeL Ended ( name , was CaMeL Successful , caused CaMeL Error ) ; _ junit CaMeL Error CaMeL Panel . progress CaMeL Step ( was CaMeL Successful ) ;
if ( ! changed && ( tab . x != x || tab . y != y ) ) changed = true ;  <CTX>  private boolean set CaMeL Item CaMeL Location ( ) { if ( items . length == 0 ) return false ; Rectangle area = super . get CaMeL Client CaMeL Area ( ) ; int x = area . x ; int y = area . y + border CaMeL Top ; if ( on CaMeL Bottom ) y = Math . max ( 0 , area . y + area . height - border CaMeL Bottom - tab CaMeL Height ) ; boolean changed = false ; for ( int i = top CaMeL Tab CaMeL Index - 1 ; i >= 0 ; i -- ) { / / if the first visible tab is not the first tab C CaMeL Tab CaMeL Item tab = items [ i ] ; x -= tab . width ; if ( ! changed && ( tab . x != x || tab . y != y ) ) changed = true ; / / layout tab items from right to left th@@ us ma@@ king them invisible tab . x = x ; tab . y = y ; } x = area . x + border CaMeL Left ; for ( int i = top CaMeL Tab CaMeL Index ; i < items . length ; i ++ ) { / / continue lay@@ ing out remaining , visible items left to right C CaMeL Tab CaMeL Item tab = items [ i ] ; tab . x = x ; tab . y = y ; x = x + tab . width ; } set CaMeL Button CaMeL Bounds ( ) ; return changed ; }	if ( ! changed && ( tab . x != x || tab . y != y ) ) { changed = true ; }
if ( child CaMeL Entries != null ) for ( int i = 0 ; i < child CaMeL Entries . length ; i ++ ) {  <CTX>  public void dispose ( ) { if ( editor != null ) { editor . dispose ( ) ; editor = null ; } / / recursive call to dispose children if ( child CaMeL Entries != null ) for ( int i = 0 ; i < child CaMeL Entries . length ; i ++ ) { / / an error in a property source may cause refresh CaMeL Child CaMeL Entries / / to fail . Since the Workbench handles su@@ ch errors we / / can be left in a state where a child entry is null . if ( child CaMeL Entries [ i ] != null ) child CaMeL Entries [ i ] . dispose ( ) ; } }	Property CaMeL Sheet CaMeL Entry [ ] entries CaMeL To CaMeL Dispose = child CaMeL Entries ; child CaMeL Entries = null ; if ( entries CaMeL To CaMeL Dispose != null ) for ( int i = 0 ; i < entries CaMeL To CaMeL Dispose . length ; i ++ ) {
Iterator iter = get CaMeL If CaMeL Map ( ) . values ( ) . iterator ( ) ; while ( iter . has CaMeL Next ( ) ) { If CaMeL Info if CaMeL Info = ( If CaMeL Info ) iter . next ( ) ; if ( ! if CaMeL Info . get CaMeL Oid CaMeL List ( ) . is CaMeL Empty ( ) ) { return true ; } } return false ;  <CTX>  boolean has CaMeL Data CaMeL To CaMeL Collect ( ) { if ( ! get CaMeL Node CaMeL Info ( ) . get CaMeL Attribute CaMeL List ( ) . is CaMeL Empty ( ) ) return true ; Iterator iter = get CaMeL If CaMeL Map ( ) . values ( ) . iterator ( ) ; while ( iter . has CaMeL Next ( ) ) { If CaMeL Info if CaMeL Info = ( If CaMeL Info ) iter . next ( ) ; if ( ! if CaMeL Info . get CaMeL Oid CaMeL List ( ) . is CaMeL Empty ( ) ) { return true ; } } return false ; }	return has CaMeL Interface CaMeL Data CaMeL Tool@@ lect ( ) ;
set CaMeL Ruby CaMeL Class ( type ) ;  <CTX>  public Ruby CaMeL Class make CaMeL Meta CaMeL Class ( Ruby CaMeL Class type ) { type = type . new CaMeL Singleton CaMeL Class ( ) ; set CaMeL Ruby CaMeL Class ( type ) ; type . attach CaMeL Singleton CaMeL Class ( this ) ; return type ; }	set CaMeL Internal CaMeL Class ( type ) ;
Organizer right CaMeL Organizer = ( Organizer ) get CaMeL Child ( Split CaMeL Pane . RIGHT _ ORGANIZ@@ ER ) ;  <CTX>  public void finalizz ( ) throws Exception { Organizer right CaMeL Organizer = ( Organizer ) get CaMeL Child ( Split CaMeL Pane . RIGHT _ ORGANIZ@@ ER ) ; remove CaMeL Child ( Split CaMeL Pane . RIGHT _ ORGANIZ@@ ER ) ; destroy CaMeL Child ( right CaMeL Organizer ) ; Organizer left CaMeL Organizer = ( Organizer ) get CaMeL Child ( Split CaMeL Pane . LEFT _ ORGANIZ@@ ER ) ; remove CaMeL Child ( Split CaMeL Pane . LEFT _ ORGANIZ@@ ER ) ; destroy CaMeL Child ( left CaMeL Organizer ) ; super . finalizz ( ) ; }	Display CaMeL Item right CaMeL Display CaMeL Item = ( Display CaMeL Item ) get CaMeL Child ( Split CaMeL Pane . RIGHT _ ORGANIZ@@ ER ) ;
return get CaMeL Runtime ( ) . new CaMeL Array ( args ) ;  <CTX>  public I CaMeL Ruby CaMeL Object create ( I CaMeL Ruby CaMeL Object [ ] args ) { return get CaMeL Runtime ( ) . new CaMeL Array ( args ) ; }	Ruby CaMeL Array array = ( Ruby CaMeL Array ) allocate CaMeL Object ( ) ; array . set CaMeL Meta CaMeL Class ( this ) ; if ( args . length > 1 ) { for ( int i = 0 ; i < args . length ; i ++ ) { array . add ( args [ i ] ) ; } } return array ;
j CaMeL Menu CaMeL Item CaMeL Add CaMeL File CaMeL To CaMeL Project CaMeL Action CaMeL Performed ( evt ) ;  <CTX>  public void action CaMeL Performed ( java . awt . event . Action CaMeL Event evt ) { j CaMeL Menu CaMeL Item CaMeL Add CaMeL File CaMeL To CaMeL Project CaMeL Action CaMeL Performed ( evt ) ; }	j CaMeL Menu CaMeL Item CaMeL Make CaMeL Resource CaMeL Action CaMeL Performed ( evt ) ;
get CaMeL Level ( ) ) ;  <CTX>  private void check CaMeL Switch CaMeL Expr ( ) { check CaMeL Expression CaMeL Subtree ( ( Detail CaMeL AST ) get CaMeL Main CaMeL Ast ( ) . find CaMeL First CaMeL Token ( Token CaMeL Types . LPAREN ) . get CaMeL Next CaMeL Sibling ( ) , get CaMeL Level ( ) ) ; }	get CaMeL Level ( ) , false , false ) ;
return _ is CaMeL Null ;  <CTX>  public boolean is CaMeL Null ( ) { return _ is CaMeL Null ; }	return _ data == null ;
viewer . update ( element , null ) ;  <CTX>  protected void set CaMeL Value ( Object element , Object value ) { do CaMeL Set CaMeL Value ( element , value ) ; viewer . update ( element , null ) ; }	get CaMeL Viewer ( ) . update ( element , null ) ;
if ( ! ( last CaMeL Argument instanceof Psi CaMeL Array CaMeL Initializer CaMeL Expression ) ) {  <CTX>  private static void make CaMeL Method CaMeL Calls CaMeL Varargs ( Psi CaMeL Element element ) throws Incorrect CaMeL Operation CaMeL Exception { final Psi CaMeL Method method = ( Psi CaMeL Method ) element . get CaMeL Parent ( ) ; final Query < Psi CaMeL Reference > query = References CaMeL Search . search ( method , method . get CaMeL Use CaMeL Scope ( ) , false ) ; for ( Psi CaMeL Reference reference : query ) { final Psi CaMeL Method CaMeL Call CaMeL Expression method CaMeL Call CaMeL Expression = ( Psi CaMeL Method CaMeL Call CaMeL Expression ) reference . get CaMeL Element ( ) ; final Psi CaMeL Expression CaMeL List argument CaMeL List = method CaMeL Call CaMeL Expression . get CaMeL Argument CaMeL List ( ) ; final Psi CaMeL Expression [ ] arguments = argument CaMeL List . get CaMeL Expressions ( ) ; if ( arguments . length == 0 ) { continue ; } final Psi CaMeL Expression last CaMeL Argument = arguments [ arguments . length - 1 ] ; if ( ! ( last CaMeL Argument instanceof Psi CaMeL Array CaMeL Initializer CaMeL Expression ) ) { continue ; } final Psi CaMeL Array CaMeL Initializer CaMeL Expression array CaMeL Initializer CaMeL Expression = ( Psi CaMeL Array CaMeL Initializer CaMeL Expression ) last CaMeL Argument ; final Psi CaMeL Expression [ ] initializers = array CaMeL Initializer CaMeL Expression . get CaMeL Initializers ( ) ; last CaMeL Argument . delete ( ) ; for ( Psi CaMeL Expression initializer : initializers ) { argument CaMeL List . add ( initializer ) ; } } }	if ( ! ( last CaMeL Argument instanceof Psi CaMeL New CaMeL Expression ) ) {
return new DF ( dir@@ path ) . get CaMeL Capacity ( ) ;  <CTX>  public long get CaMeL Capacity ( ) throws IO CaMeL Exception { return new DF ( dir@@ path ) . get CaMeL Capacity ( ) ; }	return disk CaMeL Usage . get CaMeL Capacity ( ) ;
text CaMeL Area . grab CaMeL Focus ( ) ;  <CTX>  public void run ( ) { text CaMeL Area . grab CaMeL Focus ( ) ; }	text CaMeL Area . request CaMeL Focus ( ) ;
return read CaMeL Ancestor ( res@@ our@@ cename , Cms CaMeL Resource CaMeL Filter . require CaMeL Type ( type ) ) ;  <CTX>  public Cms CaMeL Folder read CaMeL Ancestor ( String res@@ our@@ cename , int type ) throws Cms CaMeL Exception { return read CaMeL Ancestor ( res@@ our@@ cename , Cms CaMeL Resource CaMeL Filter . require CaMeL Type ( type ) ) ; }	Cms CaMeL Resource resource = read CaMeL Resource ( res@@ our@@ cename , Cms CaMeL Resource CaMeL Filter . ALL ) ; return m _ security CaMeL Manager . read CaMeL Ancestor ( m _ context , resource , filter ) ;
boolean is CaMeL Writable ( int column ) throws SQL CaMeL Exception ;  <CTX>  boolean is CaMeL Writable ( int column ) throws SQL CaMeL Exception ;	boolean is CaMeL Writable ( int column CaMeL Index ) throws SQL CaMeL Exception ;
if ( input CaMeL State . guessing == 0 ) { in _ AST = ast CaMeL Factory . create ( in ) ; ast CaMeL Factory . make CaMeL AST CaMeL Root ( current CaMeL AST , in _ AST ) ; }  <CTX>  public final void postfix CaMeL Expression ( ) throws Recognition CaMeL Exception , Token CaMeL Stream CaMeL Exception { return CaMeL AST = null ; AST CaMeL Pair current CaMeL AST = new AST CaMeL Pair ( ) ; AST postfix CaMeL Expression _ AST = null ; Token in = null ; AST in _ AST = null ; Token de = null ; AST de _ AST = null ; boolean zz ; / * ignored * / { switch ( LA ( 1 ) ) { case IDENT : case LPAREN : case LITERAL _ super : case LITERAL _ this : case STRING _ LITERAL : case DOLLAR : case STRING _ CTOR _ START : case LITERAL _ new : case LITERAL _ true : case LITERAL _ false : case LITERAL _ null : case NUM _ INT : case NUM _ FLOAT : case NUM _ LONG : case NUM _ DOUBLE : case NUM _ BIG _ INT : case NUM _ BIG _ DECIMAL : { zz = path CaMeL Expression ( ) ; if ( input CaMeL State . guessing == 0 ) { ast CaMeL Factory . add CaMeL AST CaMeL Child ( current CaMeL AST , return CaMeL AST ) ; } break ; } case LBRACK : case LCURLY : { path CaMeL Expression CaMeL From CaMeL Brackets ( ) ; if ( input CaMeL State . guessing == 0 ) { ast CaMeL Factory . add CaMeL AST CaMeL Child ( current CaMeL AST , return CaMeL AST ) ; } break ; } default : { throw new No CaMeL Viable CaMeL Alt CaMeL Exception ( LT ( 1 ) , get CaMeL Filename ( ) ) ; } } } { switch ( LA ( 1 ) ) { case INC : { in = LT ( 1 ) ; if ( input CaMeL State . guessing == 0 ) { in _ AST = ast CaMeL Factory . create ( in ) ; ast CaMeL Factory . make CaMeL AST CaMeL Root ( current CaMeL AST , in _ AST ) ; } match ( INC ) ; if ( input CaMeL State . guessing == 0 ) { in _ AST . set CaMeL Type ( POST _ INC ) ; } break ; } case DEC : { de = LT ( 1 ) ; if ( input CaMeL State . guessing == 0 ) { de _ AST = ast CaMeL Factory . create ( de ) ; ast CaMeL Factory . make CaMeL AST CaMeL Root ( current CaMeL AST , de _ AST ) ; } match ( DEC ) ; if ( input CaMeL State . guessing == 0 ) { de _ AST . set CaMeL Type ( POST _ DEC ) ; } break ; } case EOF : case RBRACK : case QUESTION : case LT : case COMMA : case GT : case SR : case BSR : case STAR : case LITERAL _ as : case RPAREN : case ASSIGN : case BAND : case RCURLY : case SEMI : case NLS : case LITERAL _ default : case TRIPLE _ DOT : case CLOSURE _ OP : case LOR : case BOR : case COLON : case LITERAL _ else : case LITERAL _ in : case PLUS : case MINUS : case LITERAL _ case : case PLUS _ ASSIGN : case MINUS _ ASSIGN : case STAR _ ASSIGN : case DIV _ ASSIGN : case MOD _ ASSIGN : case SR _ ASSIGN : case BSR _ ASSIGN : case SL _ ASSIGN : case BAND _ ASSIGN : case BXOR _ ASSIGN : case BOR _ ASSIGN : case STAR _ STAR _ ASSIGN : case LAND : case BXOR : case REGEX _ FIND : case REGEX _ MATCH : case NOT _ EQUAL : case EQUAL : case COMPARE _ TO : case LE : case GE : case LITERAL _ instanceof : case SL : case RANGE _ INCLUSIVE : case DIV : case MOD : case STAR _ STAR : { break ; } default : { throw new No CaMeL Viable CaMeL Alt CaMeL Exception ( LT ( 1 ) , get CaMeL Filename ( ) ) ; } } } if ( input CaMeL State . guessing == 0 ) { postfix CaMeL Expression _ AST = ( AST ) current CaMeL AST . root ; } return CaMeL AST = postfix CaMeL Expression _ AST ; }	in _ AST = ast CaMeL Factory . create ( in ) ; ast CaMeL Factory . make CaMeL AST CaMeL Root ( current CaMeL AST , in _ AST ) ;
catch ( Interrupted CaMeL Exception ex ) {  <CTX>  public void up ( Event evt ) { try { m _ up CaMeL Queue . put ( evt ) ; } catch ( Interrupted CaMeL Exception ex ) { / / this is ok } }	catch ( Queue CaMeL Closed CaMeL Exception ex ) {
return sip CaMeL Header instanceof Alert CaMeL Info || sip CaMeL Header instanceof In CaMeL Reply CaMeL To || sip CaMeL Header instanceof Authorization || sip CaMeL Header instanceof Max CaMeL Forwards || sip CaMeL Header instanceof User CaMeL Agent || sip CaMeL Header instanceof Priority || sip CaMeL Header instanceof Proxy CaMeL Authorization || sip CaMeL Header instanceof Proxy CaMeL Require || sip CaMeL Header instanceof Proxy CaMeL Require CaMeL List || sip CaMeL Header instanceof Route || sip CaMeL Header instanceof Route CaMeL List || sip CaMeL Header instanceof Subject ;  <CTX>  public static boolean is CaMeL Request CaMeL Header ( SIP CaMeL Header sip CaMeL Header ) { return sip CaMeL Header instanceof Alert CaMeL Info || sip CaMeL Header instanceof In CaMeL Reply CaMeL To || sip CaMeL Header instanceof Authorization || sip CaMeL Header instanceof Max CaMeL Forwards || sip CaMeL Header instanceof User CaMeL Agent || sip CaMeL Header instanceof Priority || sip CaMeL Header instanceof Proxy CaMeL Authorization || sip CaMeL Header instanceof Proxy CaMeL Require || sip CaMeL Header instanceof Proxy CaMeL Require CaMeL List || sip CaMeL Header instanceof Route || sip CaMeL Header instanceof Route CaMeL List || sip CaMeL Header instanceof Subject ; }	return sip CaMeL Header instanceof Alert CaMeL Info || sip CaMeL Header instanceof In CaMeL Reply CaMeL To || sip CaMeL Header instanceof Authorization || sip CaMeL Header instanceof Max CaMeL Forwards || sip CaMeL Header instanceof User CaMeL Agent || sip CaMeL Header instanceof Priority || sip CaMeL Header instanceof Proxy CaMeL Authorization || sip CaMeL Header instanceof Proxy CaMeL Require || sip CaMeL Header instanceof Proxy CaMeL Require CaMeL List || sip CaMeL Header instanceof Route || sip CaMeL Header instanceof Route CaMeL List || sip CaMeL Header instanceof Subject || sip CaMeL Header instanceof SIP CaMeL If CaMeL Match ;
if ( hi . from _ entry . get CaMeL Name ( ) . equals CaMeL Ignore CaMeL Case ( name ) || hi . to _ entry . get CaMeL Name ( ) . equals CaMeL Ignore CaMeL Case ( name ) ) { count ++ ; }  <CTX>  public Job CaMeL Hop CaMeL Meta [ ] get CaMeL All CaMeL Job CaMeL Hops CaMeL Using ( String name ) { int count = 0 ; for ( int i = 0 ; i < nr CaMeL Job CaMeL Hops ( ) ; i ++ ) { Job CaMeL Hop CaMeL Meta hi = get CaMeL Job CaMeL Hop ( i ) ; if ( hi . from _ entry . get CaMeL Name ( ) . equals CaMeL Ignore CaMeL Case ( name ) || hi . to _ entry . get CaMeL Name ( ) . equals CaMeL Ignore CaMeL Case ( name ) ) { count ++ ; } } Job CaMeL Hop CaMeL Meta retval [ ] = new Job CaMeL Hop CaMeL Meta [ count ] ; count = 0 ; for ( int i = 0 ; i < nr CaMeL Job CaMeL Hops ( ) ; i ++ ) { Job CaMeL Hop CaMeL Meta hi = get CaMeL Job CaMeL Hop ( i ) ; if ( hi . from _ entry . get CaMeL Name ( ) . equals CaMeL Ignore CaMeL Case ( name ) || hi . to _ entry . get CaMeL Name ( ) . equals CaMeL Ignore CaMeL Case ( name ) ) { retval [ count ] = hi ; count ++ ; } } return retval ; }	if ( hi . from _ entry != null && hi . to _ entry != null ) { if ( hi . from _ entry . get CaMeL Name ( ) . equals CaMeL Ignore CaMeL Case ( name ) || hi . to _ entry . get CaMeL Name ( ) . equals CaMeL Ignore CaMeL Case ( name ) ) { hops . add ( hi ) ; } }
if ( object == null ) return ; object . set CaMeL Waiting CaMeL For CaMeL Request ( false ) ;  <CTX>  public void object CaMeL Waiting CaMeL By CaMeL Ne@@ ce@@ ssi@@ ty ( Unique CaMeL ID id , Spy CaMeL Event spy CaMeL Event ) { if ( ! controller . is CaMeL Monitoring ( ) ) return ; Active CaMeL Object object = find CaMeL Active CaMeL Object ( id ) ; if ( object == null ) return ; object . set CaMeL Waiting CaMeL For CaMeL Request ( false ) ; communication CaMeL Event CaMeL Listener . object CaMeL Waiting CaMeL By CaMeL Ne@@ ce@@ ssi@@ ty ( object , spy CaMeL Event ) ; }	if ( object == null ) { return ; } object . set CaMeL Serving CaMeL Status ( object . get CaMeL Serving CaMeL Status ( ) == Active CaMeL Object . STATUS _ SERV@@ ING _ REQUEST ? Active CaMeL Object . STATUS _ WAITING _ BY _ N@@ EC@@ ES@@ SITY _ WHILE _ SERV@@ ING : Active CaMeL Object . STATUS _ WAITING _ BY _ N@@ EC@@ ES@@ SITY _ WHILE _ ACTIVE ) ;
if ( is CaMeL Subtree CaMeL Enabled ( ) ) { deactivate CaMeL All ( get CaMeL Source CaMeL Document ( ) ) ; } else { deactivate ( get CaMeL Source CaMeL Document ( ) ) ; }  <CTX>  protected void do CaMeL Execute ( ) throws Exception { super . do CaMeL Execute ( ) ; if ( is CaMeL Subtree CaMeL Enabled ( ) ) { deactivate CaMeL All ( get CaMeL Source CaMeL Document ( ) ) ; } else { deactivate ( get CaMeL Source CaMeL Document ( ) ) ; } }	deactivate ( get CaMeL Source CaMeL Document ( ) ) ;
return Selec@@ ti@@ ob CaMeL Object ;  <CTX>  protected List get CaMeL Selection CaMeL Object ( ) { return Selec@@ ti@@ ob CaMeL Object ; }	return selec@@ ti@@ ob CaMeL Object ;
Vector folders = cms . get CaMeL Sub CaMeL Folders ( get CaMeL Config CaMeL File ( cms ) . get CaMeL Pic CaMeL Gallery CaMeL Path ( ) ) ;  <CTX>  public Vector get CaMeL Files ( Cms CaMeL Object cms ) throws Cms CaMeL Exception { Vector gall@@ eries = new Vector ( ) ; Vector folders = cms . get CaMeL Sub CaMeL Folders ( get CaMeL Config CaMeL File ( cms ) . get CaMeL Pic CaMeL Gallery CaMeL Path ( ) ) ; int num CaMeL Folders = folders . size ( ) ; for ( int i = 0 ; i < num CaMeL Folders ; i ++ ) { Cms CaMeL Resource curr CaMeL Folder = ( Cms CaMeL Resource ) folders . element CaMeL At ( i ) ; gall@@ eries . add CaMeL Element ( curr CaMeL Folder ) ; } return gall@@ eries ; }	Vector folders = cms . get CaMeL Sub CaMeL Folders ( get CaMeL Config CaMeL File ( cms ) . get CaMeL Html CaMeL Gallery CaMeL Path ( ) ) ;
return node . get CaMeL Child ( i ) ;  <CTX>  public Suffix CaMeL Node get CaMeL Child ( Suffix CaMeL Node node , int i ) { if ( ! node . has CaMeL Child ( i ) ) { node . add CaMeL Child ( this , i , new Simple CaMeL Node ( alphabet . size ( ) ) ) ; } return node . get CaMeL Child ( i ) ; }	int index = index CaMeL For CaMeL Res ( r ) ; return get CaMeL Child ( node , index ) ;
if ( adaptable . equals ( I CaMeL Context CaMeL Provider . class ) )  <CTX>  public Object get CaMeL Adapter ( Class adaptable ) { if ( adaptable . equals ( I CaMeL Context CaMeL Provider . class ) ) return context CaMeL Provider ; if ( adaptable . equals ( I CaMeL Show CaMeL In CaMeL Source . class ) ) { return new I CaMeL Show CaMeL In CaMeL Source ( ) { public Show CaMeL In CaMeL Context get CaMeL Show CaMeL In CaMeL Context ( ) { I CaMeL Selection selection = get CaMeL Viewer ( ) . get CaMeL Selection ( ) ; if ( ! ( selection instanceof I CaMeL Structured CaMeL Selection ) ) return null ; I CaMeL Structured CaMeL Selection structured = ( I CaMeL Structured CaMeL Selection ) selection ; Iterator marker CaMeL Iterator = structured . iterator ( ) ; List new CaMeL Selection = new Array CaMeL List ( ) ; while ( marker CaMeL Iterator . has CaMeL Next ( ) ) { Concrete CaMeL Marker element = ( Concrete CaMeL Marker ) marker CaMeL Iterator . next ( ) ; new CaMeL Selection . add ( element . get CaMeL Resource ( ) ) ; } return new Show CaMeL In CaMeL Context ( get CaMeL Viewer ( ) . get CaMeL Input ( ) , new Structured CaMeL Selection ( new CaMeL Selection ) ) ; } } ; } return super . get CaMeL Adapter ( adaptable ) ; }	if ( adaptable . equals ( I CaMeL Context CaMeL Provider . class ) ) {
. get CaMeL Content CaMeL Provider ( ) ) ;  <CTX>  private I CaMeL Tree CaMeL Content CaMeL Provider [ ] extract CaMeL Content CaMeL Providers ( Set the CaMeL Descriptor CaMeL Instances ) { if ( the CaMeL Descriptor CaMeL Instances . size ( ) == 0 ) return NO _ CONTENT _ PROVIDERS ; List result CaMeL Providers CaMeL List = new Array CaMeL List ( ) ; for ( Iterator itr = the CaMeL Descriptor CaMeL Instances . iterator ( ) ; itr . has CaMeL Next ( ) ; ) result CaMeL Providers CaMeL List . add ( ( ( Navigator CaMeL Content CaMeL Extension ) itr . next ( ) ) . get CaMeL Content CaMeL Provider ( ) ) ; return ( I CaMeL Tree CaMeL Content CaMeL Provider [ ] ) result CaMeL Providers CaMeL List . to CaMeL Array ( new I CaMeL Tree CaMeL Content CaMeL Provider [ result CaMeL Providers CaMeL List . size ( ) ] ) ; }	. internal CaMeL Get CaMeL Content CaMeL Provider ( ) ) ;
ungroup CaMeL Primitive ( pre , false ) ;  <CTX>  public void draw CaMeL Image ( Image CaMeL Render CaMeL Event pre ) throws Chart CaMeL Exception { group CaMeL Primitive ( pre , false ) ; super . draw CaMeL Image ( pre ) ; ungroup CaMeL Primitive ( pre , false ) ; }	iv CaMeL Renderer . ungroup CaMeL Primitive ( pre , false ) ;
Service service = ( Service ) services . get ( wsdl CaMeL Url ) ; if ( service != null ) {  <CTX>  protected synchronized Service get CaMeL Service ( U@@ MO CaMeL Event event ) throws Exception { String wsdl CaMeL Url = get CaMeL Wsdl CaMeL Url ( event ) ; Service service = ( Service ) services . get ( wsdl CaMeL Url ) ; if ( service != null ) { services . put ( wsdl CaMeL Url , service ) ; } else { service = create CaMeL Service ( event ) ; } return service ; }	Service service = ( Service ) services . get ( wsdl CaMeL Url ) ; if ( service == null ) { service = create CaMeL Service ( event ) ;
return this . name ;  <CTX>  public String get CaMeL Name ( ) { return this . name ; }	return m _ name ;
if ( sashes . left == null ) sashes . left = sash ;  <CTX>  void find CaMeL S@@ ashes ( Layout CaMeL Tree child , Part CaMeL Pane . S@@ ashes sashes ) { Sash sash = ( Sash ) get CaMeL Sash ( ) . get CaMeL Control ( ) ; boolean left CaMeL Or CaMeL Top = children [ 0 ] == child ; if ( sash != null ) { Layout CaMeL Part CaMeL Sash part CaMeL Sash = get CaMeL Sash ( ) ; / / If the child is in the left , the sash / / is in the ri@@ gth and so on . if ( left CaMeL Or CaMeL Top ) { if ( part CaMeL Sash . is CaMeL Vertical ( ) ) { if ( sashes . right == null ) sashes . right = sash ; } else { if ( sashes . bottom == null ) sashes . bottom = sash ; } } else { if ( part CaMeL Sash . is CaMeL Vertical ( ) ) { if ( sashes . left == null ) sashes . left = sash ; } else { if ( sashes . top == null ) sashes . top = sash ; } } } if ( get CaMeL Parent ( ) != null ) get CaMeL Parent ( ) . find CaMeL S@@ ashes ( this , sashes ) ; }	if ( sashes . left == null ) { sashes . left = sash ; }
Calendar result = Calendar . get CaMeL Instance ( ) ; result . set CaMeL Time ( this . get CaMeL Start CaMeL Time CaMeL Date ( ) ) ; return result ;  <CTX>  public Calendar get CaMeL Start CaMeL Time ( ) { Calendar result = Calendar . get CaMeL Instance ( ) ; result . set CaMeL Time ( this . get CaMeL Start CaMeL Time CaMeL Date ( ) ) ; return result ; }	if ( this . get CaMeL Start CaMeL Time CaMeL Date ( ) != null ) { Calendar result = Calendar . get CaMeL Instance ( ) ; result . set CaMeL Time ( this . get CaMeL Start CaMeL Time CaMeL Date ( ) ) ; return result ; } return null ;
return Ruby CaMeL Fixnum . new CaMeL Fixnum ( get CaMeL Ruby ( ) , end [ ( int ) index . get CaMeL Value ( ) ] ) ;  <CTX>  public Ruby CaMeL Object end ( Ruby CaMeL Fixnum index ) { if ( out CaMeL Of CaMeL Bounds ( index ) ) { return get CaMeL Ruby ( ) . get CaMeL Nil ( ) ; } return Ruby CaMeL Fixnum . new CaMeL Fixnum ( get CaMeL Ruby ( ) , end [ ( int ) index . get CaMeL Value ( ) ] ) ; }	return Ruby CaMeL Fixnum . new CaMeL Fixnum ( get CaMeL Ruby ( ) , end [ ( int ) index . get CaMeL Long CaMeL Value ( ) ] ) ;
switch ( f . method CaMeL Id ) {  <CTX>  public Object exec CaMeL Method ( Id CaMeL Function f , Context cx , Scriptable scope , Scriptable this CaMeL Obj , Object [ ] args ) { if ( prototype CaMeL Flag ) { switch ( f . method CaMeL Id ) { case Id _ constructor : return js CaMeL Constructor ( cx , scope , args ) ; case Id _ to CaMeL String : { Base CaMeL Function re@@ alf = real CaMeL Function ( this CaMeL Obj , f ) ; int indent = Script CaMeL Runtime . to CaMeL Int 32 ( args , 0 ) ; return re@@ alf . decompile ( indent , 0 ) ; } case Id _ to CaMeL Source : { Base CaMeL Function re@@ alf = real CaMeL Function ( this CaMeL Obj , f ) ; int indent = 0 ; int flags = Decompiler . TO _ SOURCE _ FLAG ; if ( args . length != 0 ) { indent = Script CaMeL Runtime . to CaMeL Int 32 ( args [ 0 ] ) ; if ( indent >= 0 ) { flags = 0 ; } else { indent = 0 ; } } return re@@ alf . decompile ( indent , flags ) ; } case Id _ apply : case Id _ call : return apply CaMeL Or CaMeL Call ( f . method CaMeL Id == Id _ apply , cx , scope , this CaMeL Obj , args ) ; } } return super . exec CaMeL Method ( f , cx , scope , this CaMeL Obj , args ) ; }	int method CaMeL Id = f . method CaMeL Id ( ) ; switch ( method CaMeL Id ) {
event . get CaMeL DNS ( ) . request CaMeL Service CaMeL Info ( event . get CaMeL Type ( ) , event . get CaMeL Name ( ) , 0 ) ;  <CTX>  public void service CaMeL Added ( Service CaMeL Event event ) { event . get CaMeL DNS ( ) . request CaMeL Service CaMeL Info ( event . get CaMeL Type ( ) , event . get CaMeL Name ( ) , 0 ) ; }	synchronized ( infos ) { event . get CaMeL DNS ( ) . request CaMeL Service CaMeL Info ( event . get CaMeL Type ( ) , event . get CaMeL Name ( ) , 0 ) ; }
this ( s , null ) ;  <CTX>  public Class CaMeL Not CaMeL Found CaMeL Exception ( String s ) { this ( s , null ) ; }	this ( null ) ;
content CaMeL Queue . clear ( ) ; } else { while ( ! content CaMeL Queue . is CaMeL Empty ( ) ) run CaMeL Once ( ( String ) content CaMeL Queue . remove ( 0 ) ) ; }  <CTX>  public void run ( ) { if ( should CaMeL Reset ) { run CaMeL Once ( null ) ; content CaMeL Queue . clear ( ) ; } else { while ( ! content CaMeL Queue . is CaMeL Empty ( ) ) run CaMeL Once ( ( String ) content CaMeL Queue . remove ( 0 ) ) ; } this . should CaMeL Reset = false ; this . should CaMeL Scroll = true ; this . is CaMeL Queued = false ; }	while ( ! content CaMeL Queue . is CaMeL Empty ( ) ) run CaMeL Once ( ( String ) content CaMeL Queue . remove ( 0 ) ) ;
if ( block )  <CTX>  public int open ( ) { if ( shell == null || shell . is CaMeL Disposed ( ) ) { shell = null ; / / create the window create ( ) ; } / / limit the shell size to the display size constrain CaMeL Shell CaMeL Size ( ) ; / / open the window shell . open ( ) ; / / run the event loop if specified if ( block ) run CaMeL Event CaMeL Loop ( shell ) ; return return CaMeL Code ; }	if ( block ) {
requires [ i ] . resolve ( ) ;  <CTX>  public final void resolve ( ) throws Plugin CaMeL Exception { if ( ! resolved ) { for ( int i = 0 ; i < extensions . length ; i ++ ) { extensions [ i ] . resolve ( ) ; } for ( int i = 0 ; i < extension CaMeL Points . length ; i ++ ) { extension CaMeL Points [ i ] . resolve ( ) ; } for ( int i = 0 ; i < requires . length ; i ++ ) { requires [ i ] . resolve ( ) ; } if ( runtime != null ) { runtime . resolve ( ) ; } resolved = true ; } }	requires [ i ] . resolve ( registry ) ;
tmf CaMeL Spi . engine CaMeL Init ( store ) ;  <CTX>  public final void init ( Key CaMeL Store store ) throws Key CaMeL Store CaMeL Exception { tmf CaMeL Spi . engine CaMeL Init ( store ) ; }	tmf CaMeL Spi . engine CaMeL Init ( params ) ;
descriptor CaMeL Handle = new Integer ( next CaMeL Handle ( ) ) ;  <CTX>  private Object CaMeL Stream CaMeL Class read CaMeL New CaMeL Class CaMeL Desc ( boolean unshared ) throws Class CaMeL Not CaMeL Found CaMeL Exception , IO CaMeL Exception { / / So read . . . ( ) methods can be used by / / subclasses during read CaMeL Class CaMeL Descriptor ( ) primitive CaMeL Data = input ; Integer old CaMeL Handle = descriptor CaMeL Handle ; descriptor CaMeL Handle = new Integer ( next CaMeL Handle ( ) ) ; Object CaMeL Stream CaMeL Class new CaMeL Class CaMeL Desc = read CaMeL Class CaMeL Descriptor ( ) ; if ( descriptor CaMeL Handle != null ) { register CaMeL Object CaMeL Read ( new CaMeL Class CaMeL Desc , descriptor CaMeL Handle , unshared ) ; } descriptor CaMeL Handle = old CaMeL Handle ; primitive CaMeL Data = empty CaMeL Stream ; / / We need to map class CaMeL Desc to class . try { new CaMeL Class CaMeL Desc . set CaMeL Class ( resolve CaMeL Class ( new CaMeL Class CaMeL Desc ) ) ; / / Check S@@ UI CaMeL Ds verify CaMeL SU@@ ID ( new CaMeL Class CaMeL Desc ) ; / / Check base name of the class verify CaMeL Base CaMeL Name ( new CaMeL Class CaMeL Desc ) ; } catch ( Class CaMeL Not CaMeL Found CaMeL Exception e ) { if ( must CaMeL Resolve ) { throw e ; / / Just continue , the class may not be required } } / / Resolve the field signatures using the class loader of the / / resolved class Object CaMeL Stream CaMeL Field [ ] fields = new CaMeL Class CaMeL Desc . get CaMeL Load CaMeL Fields ( ) ; fields = ( null == fields ? new Object CaMeL Stream CaMeL Field [ ] { } : fields ) ; Class CaMeL Loader loader = new CaMeL Class CaMeL Desc . for CaMeL Class ( ) == null ? caller CaMeL Class CaMeL Loader : new CaMeL Class CaMeL Desc . for CaMeL Class ( ) . get CaMeL Class CaMeL Loader ( ) ; for ( Object CaMeL Stream CaMeL Field element : fields ) { element . resolve ( loader ) ; } / / Consume unread class annotation data and TC _ ENDB@@ LOCK@@ DATA discard CaMeL Data ( ) ; checked CaMeL Set CaMeL Super CaMeL Class CaMeL Desc ( new CaMeL Class CaMeL Desc , read CaMeL Class CaMeL Desc ( ) ) ; return new CaMeL Class CaMeL Desc ; }	descriptor CaMeL Handle = Integer . value CaMeL Of ( next CaMeL Handle ( ) ) ;
if ( comparer == null )  <CTX>  protected boolean equals ( Object element CaMeL A , Object element CaMeL B ) { if ( comparer == null ) return element CaMeL A == null ? element CaMeL B == null : element CaMeL A . equals ( element CaMeL B ) ; else return element CaMeL A == null ? element CaMeL B == null : comparer . equals ( element CaMeL A , element CaMeL B ) ; }	if ( comparer == null ) {
add CaMeL Byte CaMeL Code ( Byte CaMeL Code . DCMPG ) ; add CaMeL Byte CaMeL Code ( Byte CaMeL Code . IFLT , true CaMeL GOTO ) ;  <CTX>  private void gen CaMeL Simple CaMeL Compare ( int type , int true CaMeL GOTO , int false CaMeL GOTO ) { switch ( type ) { case Token . LE : add CaMeL Byte CaMeL Code ( Byte CaMeL Code . DCMPG ) ; add CaMeL Byte CaMeL Code ( Byte CaMeL Code . IFLE , true CaMeL GOTO ) ; break ; case Token . GE : add CaMeL Byte CaMeL Code ( Byte CaMeL Code . DCMPL ) ; add CaMeL Byte CaMeL Code ( Byte CaMeL Code . IFGE , true CaMeL GOTO ) ; break ; case Token . LT : add CaMeL Byte CaMeL Code ( Byte CaMeL Code . DCMPG ) ; add CaMeL Byte CaMeL Code ( Byte CaMeL Code . IFLT , true CaMeL GOTO ) ; break ; case Token . GT : add CaMeL Byte CaMeL Code ( Byte CaMeL Code . DCMPL ) ; add CaMeL Byte CaMeL Code ( Byte CaMeL Code . IFGT , true CaMeL GOTO ) ; break ; default : bad CaMeL Tree ( ) ; } if ( false CaMeL GOTO != - 1 ) add CaMeL Byte CaMeL Code ( Byte CaMeL Code . GOTO , false CaMeL GOTO ) ; }	cfw . add ( Byte CaMeL Code . DCMPG ) ; cfw . add ( Byte CaMeL Code . IFLT , true CaMeL GOTO ) ;
I CaMeL Style area CaMeL Style = root . get CaMeL Style ( ) ; set CaMeL Offset CaMeL X ( get CaMeL Dimension CaMeL Value ( area CaMeL Style . get CaMeL Property ( Style CaMeL Constants . STYLE _ BORDER _ LEFT _ WIDTH ) ) + get CaMeL Dimension CaMeL Value ( area CaMeL Style . get CaMeL Property ( Style CaMeL Constants . STYLE _ PADDING _ LEFT ) ) ) ; set CaMeL Offset CaMeL Y ( is CaMeL First ? ( get CaMeL Dimension CaMeL Value ( area CaMeL Style . get CaMeL Property ( Style CaMeL Constants . STYLE _ BORDER _ TOP _ WIDTH ) ) + get CaMeL Dimension CaMeL Value ( area CaMeL Style . get CaMeL Property ( Style CaMeL Constants . STYLE _ PADDING _ TOP ) ) ) : 0 ) ;  <CTX>  protected void new CaMeL Context ( ) { create CaMeL Root ( ) ; / / validate CaMeL Box CaMeL Property ( root . get CaMeL Style ( ) ) ; if ( null != parent ) { / / support user defined width int max = parent . get CaMeL Max CaMeL Ava CaMeL Width ( ) - parent . get CaMeL Current CaMeL IP ( ) ; if ( content != null ) { int specified CaMeL Width = get CaMeL Dimension CaMeL Value ( content . get CaMeL Width ( ) ) ; if ( specified CaMeL Width > 0 ) { max = Math . min ( max , specified CaMeL Width ) ; } } root . set CaMeL Allocated CaMeL Width ( max ) ; set CaMeL Max CaMeL Ava CaMeL Width ( root . get CaMeL Content CaMeL Width ( ) ) ; root . set CaMeL Allocated CaMeL Height ( parent . get CaMeL Max CaMeL Ava CaMeL Height ( ) - parent . get CaMeL Current CaMeL BP ( ) ) ; set CaMeL Max CaMeL Ava CaMeL Height ( root . get CaMeL Content CaMeL Height ( ) ) ; } / / initialize offset CaMeL X and offset CaMeL Y I CaMeL Style area CaMeL Style = root . get CaMeL Style ( ) ; set CaMeL Offset CaMeL X ( get CaMeL Dimension CaMeL Value ( area CaMeL Style . get CaMeL Property ( Style CaMeL Constants . STYLE _ BORDER _ LEFT _ WIDTH ) ) + get CaMeL Dimension CaMeL Value ( area CaMeL Style . get CaMeL Property ( Style CaMeL Constants . STYLE _ PADDING _ LEFT ) ) ) ; set CaMeL Offset CaMeL Y ( is CaMeL First ? ( get CaMeL Dimension CaMeL Value ( area CaMeL Style . get CaMeL Property ( Style CaMeL Constants . STYLE _ BORDER _ TOP _ WIDTH ) ) + get CaMeL Dimension CaMeL Value ( area CaMeL Style . get CaMeL Property ( Style CaMeL Constants . STYLE _ PADDING _ TOP ) ) ) : 0 ) ; / / can be removed ? set CaMeL Current CaMeL BP ( 0 ) ; set CaMeL Current CaMeL IP ( 0 ) ; }	set CaMeL Offset CaMeL X ( root . get CaMeL Content CaMeL X ( ) ) ; set CaMeL Offset CaMeL Y ( is CaMeL First ? root . get CaMeL Content CaMeL Y ( ) : 0 ) ;
switch ( e CaMeL Derived CaMeL Structural CaMeL Feature CaMeL ID ( e CaMeL Feature ) )  <CTX>  public void e CaMeL Unset ( E CaMeL Structural CaMeL Feature e CaMeL Feature ) { switch ( e CaMeL Derived CaMeL Structural CaMeL Feature CaMeL ID ( e CaMeL Feature ) ) { case Type CaMeL Package . STOCK _ SERIES _ _ VISIBLE : unset CaMeL Visible ( ) ; return ; case Type CaMeL Package . STOCK _ SERIES _ _ LABEL : set CaMeL Label ( ( Label ) null ) ; return ; case Type CaMeL Package . STOCK _ SERIES _ _ DATA _ DEFINITION : get CaMeL Data CaMeL Definition ( ) . clear ( ) ; return ; case Type CaMeL Package . STOCK _ SERIES _ _ SERIES _ IDENTIFIER : set CaMeL Series CaMeL Identifier ( SERIES _ IDENTIFIER _ EDEFAULT ) ; return ; case Type CaMeL Package . STOCK _ SERIES _ _ DATA _ POINT : set CaMeL Data CaMeL Point ( ( Data CaMeL Point ) null ) ; return ; case Type CaMeL Package . STOCK _ SERIES _ _ DATA _ SETS : get CaMeL Data CaMeL Sets ( ) . clear ( ) ; return ; case Type CaMeL Package . STOCK _ SERIES _ _ LABEL _ POSITION : unset CaMeL Label CaMeL Position ( ) ; return ; case Type CaMeL Package . STOCK _ SERIES _ _ STACKED : unset CaMeL Stacked ( ) ; return ; case Type CaMeL Package . STOCK _ SERIES _ _ TRIGGERS : get CaMeL Triggers ( ) . clear ( ) ; return ; case Type CaMeL Package . STOCK _ SERIES _ _ TRANSLUCENT : unset CaMeL Translucent ( ) ; return ; case Type CaMeL Package . STOCK _ SERIES _ _ CURVE _ FI@@ TTING : set CaMeL Curve CaMeL Fitting ( ( Curve CaMeL Fitting ) null ) ; return ; case Type CaMeL Package . STOCK _ SERIES _ _ FILL : set CaMeL Fill ( ( Fill ) null ) ; return ; case Type CaMeL Package . STOCK _ SERIES _ _ LINE _ ATTRIBUTES : set CaMeL Line CaMeL Attributes ( ( Line CaMeL Attributes ) null ) ; return ; } e CaMeL Dynamic CaMeL Unset ( e CaMeL Feature ) ; }	switch ( feature CaMeL ID )
new CaMeL Type CaMeL Ids . add ( ( ( IAST CaMeL Type CaMeL Id ) type CaMeL Ids . get ( i ) ) . to CaMeL String ( ) ) ;  <CTX>  public IAST CaMeL Exception CaMeL Specification create CaMeL Exception CaMeL Specification ( IAST CaMeL Scope scope , List type CaMeL Ids ) throws AST CaMeL Semantic CaMeL Exception { List new CaMeL Type CaMeL Ids = new Array CaMeL List ( ) ; if ( type CaMeL Ids != null ) { int size = type CaMeL Ids . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) new CaMeL Type CaMeL Ids . add ( ( ( IAST CaMeL Type CaMeL Id ) type CaMeL Ids . get ( i ) ) . to CaMeL String ( ) ) ; } return new AST CaMeL Exception CaMeL Specification ( new CaMeL Type CaMeL Ids ) ; }	new CaMeL Type CaMeL Ids . add ( type CaMeL Ids . get ( i ) ) ;
i CaMeL Visited . accept ( _ Payload ) ;  <CTX>  public void visit CaMeL Args CaMeL Node ( Args CaMeL Node i CaMeL Visited ) { i CaMeL Visited . accept ( _ Payload ) ; Node l CaMeL Opt CaMeL Node = i CaMeL Visited . get CaMeL Opt CaMeL Node ( ) ; if ( l CaMeL Opt CaMeL Node != null ) { l CaMeL Opt CaMeL Node . accept ( this ) ; } }	_ Payload . visit CaMeL Args CaMeL Node ( i CaMeL Visited ) ;
return new Discover CaMeL Properties CaMeL Rowset ( request , handler ) ;  <CTX>  public Rowset get CaMeL Rowset ( Xmla CaMeL Request request , Xmla CaMeL Handler handler ) { return new Discover CaMeL Properties CaMeL Rowset ( request , handler ) ; }	return new Discover CaMeL Schema CaMeL Row@@ sets CaMeL Rowset ( request , handler ) ;
class CaMeL Names = new Obj CaMeL To CaMeL Int CaMeL Map ( ) ;  <CTX>  public IR CaMeL Factory create CaMeL IR CaMeL Factory ( Context cx , Token CaMeL Stream ts ) { if ( name CaMeL Helper == null ) { name CaMeL Helper = ( Opt CaMeL Class CaMeL Name CaMeL Helper ) Class CaMeL Name CaMeL Helper . get ( cx ) ; class CaMeL Names = new Obj CaMeL To CaMeL Int CaMeL Map ( ) ; } return new IR CaMeL Factory ( this , ts ) ; }	its CaMeL Use CaMeL Dynamic CaMeL Scope = cx . has CaMeL Compile CaMeL Functions CaMeL With CaMeL Dynamic CaMeL Scope ( ) ; generate CaMeL Debug CaMeL Info = ( ! cx . is CaMeL Generating CaMeL Debug CaMeL Changed ( ) || cx . is CaMeL Generating CaMeL Debug ( ) ) ; language CaMeL Version = cx . get CaMeL Language CaMeL Version ( ) ;
boolean optimized CaMeL Transform = ( transform CaMeL Type & ( Affine CaMeL Transform . TYPE _ TRANSLATION | Affine CaMeL Transform . TYPE _ IDENTITY ) ) != 0 ;  <CTX>  private void update CaMeL Optimization ( ) { int transform CaMeL Type = transform . get CaMeL Type ( ) ; boolean optimized CaMeL Transform = ( transform CaMeL Type & ( Affine CaMeL Transform . TYPE _ TRANSLATION | Affine CaMeL Transform . TYPE _ IDENTITY ) ) != 0 ; is CaMeL Optimized = clip instanceof Rectangle && optimized CaMeL Transform && paint instanceof Color && composite == Alpha CaMeL Composite . Src CaMeL Over && stroke . equals ( new Basic CaMeL Stroke ( ) ) ; }	boolean optimized CaMeL Transform = false ; if ( transform CaMeL Type == Affine CaMeL Transform . TYPE _ IDENTITY || transform CaMeL Type == Affine CaMeL Transform . TYPE _ TRANSLATION ) optimized CaMeL Transform = true ;
if ( get CaMeL Node ( ) . get CaMeL Node CaMeL Type ( ) == get CaMeL Node ( ) . ELEMENT _ NODE ) {  <CTX>  public boolean is CaMeL Element ( ) { if ( this . node == null ) { return false ; } if ( get CaMeL Node ( ) . get CaMeL Node CaMeL Type ( ) == get CaMeL Node ( ) . ELEMENT _ NODE ) { return true ; } return false ; }	if ( get CaMeL Node ( ) . get CaMeL Node CaMeL Type ( ) == Node . ELEMENT _ NODE ) {
i CaMeL Visited . accept ( _ Payload ) ;  <CTX>  public void visit CaMeL Until CaMeL Node ( Until CaMeL Node i CaMeL Visited ) { i CaMeL Visited . accept ( _ Payload ) ; }	_ Payload . visit CaMeL Until CaMeL Node ( i CaMeL Visited ) ;
} else if ( selected CaMeL Object instanceof I CaMeL Query CaMeL Hit ) { task = ( ( I CaMeL Query CaMeL Hit ) selected CaMeL Object ) . get CaMeL Or CaMeL Create CaMeL Corresponding CaMeL Task ( ) ;  <CTX>  public boolean perform CaMeL Drop ( Object data ) { I CaMeL Structured CaMeL Selection selection = ( ( I CaMeL Structured CaMeL Selection ) Task CaMeL List CaMeL View . get CaMeL Default ( ) . get CaMeL Viewer ( ) . get CaMeL Selection ( ) ) ; for ( Iterator iter = selection . iterator ( ) ; iter . has CaMeL Next ( ) ; ) { Object selected CaMeL Object = iter . next ( ) ; if ( selected CaMeL Object instanceof I CaMeL Task ) { content CaMeL Provider . add CaMeL Task ( ( I CaMeL Task ) selected CaMeL Object ) ; update CaMeL Labels ( ) ; continue ; } else if ( selected CaMeL Object instanceof I CaMeL Task CaMeL List CaMeL Element ) { / / if ( My@@ lar CaMeL Task CaMeL List CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Handler CaMeL For CaMeL Element ( ( I CaMeL Task CaMeL List CaMeL Element ) selected CaMeL Object ) != null ) { I CaMeL Task task = null ; if ( selected CaMeL Object instanceof I CaMeL Task ) { task = ( I CaMeL Task ) selected CaMeL Object ; } else if ( selected CaMeL Object instanceof I CaMeL Query CaMeL Hit ) { task = ( ( I CaMeL Query CaMeL Hit ) selected CaMeL Object ) . get CaMeL Or CaMeL Create CaMeL Corresponding CaMeL Task ( ) ; } if ( task != null ) { content CaMeL Provider . add CaMeL Task ( task ) ; update CaMeL Labels ( ) ; continue ; } / / } } else { return false ; } } table CaMeL Viewer . refresh ( ) ; return true ; }	} else if ( selected CaMeL Object instanceof Abstract CaMeL Query CaMeL Hit ) { task = ( ( Abstract CaMeL Query CaMeL Hit ) selected CaMeL Object ) . get CaMeL Or CaMeL Create CaMeL Corresponding CaMeL Task ( ) ;
Node CaMeL Component node = ( Node CaMeL Component ) iter . next ( ) ; Console CaMeL Tree CaMeL Object cto = new Console CaMeL Tree CaMeL Object ( node ) ;  <CTX>  private void add CaMeL Unassigned CaMeL Nodes CaMeL From CaMeL Experiment ( ) { Set unassigned CaMeL Nodes = new Tree CaMeL Set ( base CaMeL Component CaMeL Comparator ) ; Host CaMeL Component [ ] hosts = experiment . get CaMeL Hosts ( ) ; Node CaMeL Component [ ] nodes = experiment . get CaMeL Nodes ( ) ; unassigned CaMeL Nodes . add CaMeL All ( Arrays . as CaMeL List ( nodes ) ) ; for ( int i = 0 ; i < hosts . length ; i ++ ) unassigned CaMeL Nodes . remove CaMeL All ( Arrays . as CaMeL List ( hosts [ i ] . get CaMeL Nodes ( ) ) ) ; Default CaMeL Mutable CaMeL Tree CaMeL Node root = ( Default CaMeL Mutable CaMeL Tree CaMeL Node ) node CaMeL Tree . get CaMeL Model ( ) . get CaMeL Root ( ) ; Default CaMeL Tree CaMeL Model model = ( Default CaMeL Tree CaMeL Model ) node CaMeL Tree . get CaMeL Model ( ) ; Iterator iter = unassigned CaMeL Nodes . iterator ( ) ; while ( iter . has CaMeL Next ( ) ) { Node CaMeL Component node = ( Node CaMeL Component ) iter . next ( ) ; Console CaMeL Tree CaMeL Object cto = new Console CaMeL Tree CaMeL Object ( node ) ; Default CaMeL Mutable CaMeL Tree CaMeL Node new CaMeL Node CaMeL Tree CaMeL Node = new Default CaMeL Mutable CaMeL Tree CaMeL Node ( cto , true ) ; model . insert CaMeL Node CaMeL Into ( new CaMeL Node CaMeL Tree CaMeL Node , root , root . get CaMeL Child CaMeL Count ( ) ) ; Agent CaMeL Component [ ] agents = node . get CaMeL Agents ( ) ; for ( int j = 0 ; j < agents . length ; j ++ ) { Agent CaMeL Component agent CaMeL Component = agents [ j ] ; cto = new Console CaMeL Tree CaMeL Object ( agent CaMeL Component ) ; Default CaMeL Mutable CaMeL Tree CaMeL Node new CaMeL Agent CaMeL Node = new Default CaMeL Mutable CaMeL Tree CaMeL Node ( cto , false ) ; model . insert CaMeL Node CaMeL Into ( new CaMeL Agent CaMeL Node , new CaMeL Node CaMeL Tree CaMeL Node , new CaMeL Node CaMeL Tree CaMeL Node . get CaMeL Child CaMeL Count ( ) ) ; } } }	Node CaMeL Component node CaMeL Component = ( Node CaMeL Component ) iter . next ( ) ; Console CaMeL Tree CaMeL Object cto = new Console CaMeL Tree CaMeL Object ( node CaMeL Component ) ;
Assert . assert ( - 1 != native CaMeL RDF CaMeL Node ) ;  <CTX>  public Enumeration children ( ) { Assert . assert ( - 1 != native CaMeL RDF CaMeL Node ) ; Enumeration enum = null ; enum = new RDF CaMeL Enumeration ( native CaMeL Web CaMeL Shell , this ) ; return enum ; }	Assert . assert _ it ( - 1 != native CaMeL RDF CaMeL Node ) ;
this . element = element ;  <CTX>  public Tools CaMeL Settings CaMeL Block ( Build CaMeL Property CaMeL Page parent , Object element ) { super ( Managed CaMeL Builder CaMeL UI CaMeL Messages . get CaMeL Resource CaMeL String ( SETTINGS _ LABEL ) ) ; super . set CaMeL Container ( parent ) ; this . parent = parent ; config CaMeL To CaMeL Page CaMeL List CaMeL Map = new Hash CaMeL Map ( ) ; this . element = element ; settings CaMeL Store = new Build CaMeL Tool CaMeL Settings CaMeL Preference CaMeL Store ( this ) ; }	this . property CaMeL Object = element ;
|| ( a CaMeL AST . get CaMeL Parent ( ) . get CaMeL Type ( ) != Token CaMeL Types . TYP@@ EC@@ AST ) )  <CTX>  public void visit CaMeL Token ( Detail CaMeL AST a CaMeL AST ) { / / Str@@ ange logic in this method to guard ag@@ ainst checking RPAREN tokens / / that are associated with a TYP@@ EC@@ AST token . if ( a CaMeL AST . get CaMeL Type ( ) != Token CaMeL Types . RPAREN ) { if ( ! is CaMeL Prece@@ eds CaMeL Empty CaMeL For CaMeL Init ( a CaMeL AST ) ) { process CaMeL Left ( a CaMeL AST ) ; } } else if ( ( a CaMeL AST . get CaMeL Parent ( ) == null ) || ( a CaMeL AST . get CaMeL Parent ( ) . get CaMeL Type ( ) != Token CaMeL Types . TYP@@ EC@@ AST ) ) { if ( ! is CaMeL Follows CaMeL Empty CaMeL For CaMeL Iterator ( a CaMeL AST ) ) { process CaMeL Right ( a CaMeL AST ) ; } } }	|| ( a CaMeL AST . get CaMeL Parent ( ) . get CaMeL Type ( ) != Token CaMeL Types . TYP@@ EC@@ AST ) || ( a CaMeL AST . get CaMeL Parent ( ) . find CaMeL First CaMeL Token ( Token CaMeL Types . RPAREN ) != a CaMeL AST ) )
if ( message == null )  <CTX>  public static I CaMeL Status error CaMeL Status ( Throwable exception ) { String message = exception . get CaMeL Localized CaMeL Message ( ) ; if ( message == null ) message = EMPTY _ STRING ; return new Status ( I CaMeL Status . ERROR , IDE CaMeL Workbench CaMeL Plugin . IDE _ WORK@@ BENCH , I CaMeL Status . ERROR , message , exception ) ; }	if ( message == null ) {
return get CaMeL Property CaMeL As CaMeL Float ( PERCEN@@ T@@ THRO@@ UG@@ H@@ PUT ) ;  <CTX>  public float get CaMeL Percent CaMeL Throughput ( ) { return get CaMeL Property CaMeL As CaMeL Float ( PERCEN@@ T@@ THRO@@ UG@@ H@@ PUT ) ; }	return get CaMeL Property CaMeL As CaMeL String ( PERCEN@@ T@@ THRO@@ UG@@ H@@ PUT ) ;
int offset )  <CTX>  final public static Address align CaMeL Allocation ( Address region , int alignment , int offset ) throws Inline CaMeL Pragma { return align CaMeL Allocation ( region , alignment , offset , MIN _ ALIGNMENT ) ; }	int offset , int known CaMeL Alignment )
if ( has CaMeL Failed CaMeL OK )  <CTX>  public void run ( ) { get CaMeL Button ( I CaMeL Dialog CaMeL Constants . OK _ ID ) . set CaMeL Enabled ( false ) ; error CaMeL Occurred = false ; boolean has CaMeL Failed CaMeL OK = false ; try { / / Notify all the pages and give them a chance to abort Iterator nodes = preference CaMeL Manager . get CaMeL Elements ( Preference CaMeL Manager . PRE _ ORDER ) . iterator ( ) ; while ( nodes . has CaMeL Next ( ) ) { I CaMeL Preference CaMeL Node node = ( I CaMeL Preference CaMeL Node ) nodes . next ( ) ; I CaMeL Preference CaMeL Page page = node . get CaMeL Page ( ) ; if ( page != null ) { if ( ! page . perform CaMeL Ok ( ) ) { has CaMeL Failed CaMeL OK = true ; return ; } } } } catch ( Exception e ) { handle CaMeL Exception ( e ) ; } finally { / / D@@ on t bo@@ ther closing if the OK failed if ( has CaMeL Failed CaMeL OK ) return ; if ( ! error CaMeL Occurred ) / / Give subclasses the choice to save the state of the / / preference pages . handle CaMeL Save ( ) ; close ( ) ; } }	if ( has CaMeL Failed CaMeL OK ) { set CaMeL Return CaMeL Code ( FAILED ) ; get CaMeL Button ( I CaMeL Dialog CaMeL Constants . OK _ ID ) . set CaMeL Enabled ( true ) ;
. have CaMeL Active CaMeL Contexts CaMeL Changed ( ) , false , false , false , false , false , false , null , null , null ) ) ;  <CTX>  public final void context CaMeL Manager CaMeL Changed ( final Context CaMeL Manager CaMeL Event event ) { fire CaMeL Command CaMeL Manager CaMeL Changed ( new Command CaMeL Manager CaMeL Event ( this , event . have CaMeL Active CaMeL Contexts CaMeL Changed ( ) , false , false , false , false , false , false , null , null , null ) ) ; }	. is CaMeL Active CaMeL Contexts CaMeL Changed ( ) , false , false , false , false , false , false , null , null , null ) ) ;
if ( _ generated CaMeL Source CaMeL Folder == null ) { _ generated CaMeL Source CaMeL Folder = get CaMeL Generated CaMeL Source CaMeL Folder ( ) ; _ generated CaMeL Source CaMeL Folder . refresh CaMeL Local ( I CaMeL Resource . DEPTH _ INFINITE , progress CaMeL Monitor ) ; if ( ! _ generated CaMeL Source CaMeL Folder . exists ( ) ) _ generated CaMeL Source CaMeL Folder . create ( true , false , progress CaMeL Monitor ) ;  <CTX>  private I CaMeL Folder ensure CaMeL Generated CaMeL Source CaMeL Folder ( I CaMeL Java CaMeL Project java CaMeL Project , I CaMeL Progress CaMeL Monitor progress CaMeL Monitor ) throws Core CaMeL Exception { if ( _ generated CaMeL Source CaMeL Folder == null ) { _ generated CaMeL Source CaMeL Folder = get CaMeL Generated CaMeL Source CaMeL Folder ( ) ; _ generated CaMeL Source CaMeL Folder . refresh CaMeL Local ( I CaMeL Resource . DEPTH _ INFINITE , progress CaMeL Monitor ) ; if ( ! _ generated CaMeL Source CaMeL Folder . exists ( ) ) _ generated CaMeL Source CaMeL Folder . create ( true , false , progress CaMeL Monitor ) ; / / / / make sure _ _ generated _ src dir is on the cp if not already / / update CaMeL Project CaMeL Classpath ( java CaMeL Project , _ generated CaMeL Source CaMeL Folder , progress CaMeL Monitor ) ; } return _ generated CaMeL Source CaMeL Folder ; }	I CaMeL Folder src CaMeL Folder = get CaMeL Generated CaMeL Source CaMeL Folder ( ) ; src CaMeL Folder . refresh CaMeL Local ( I CaMeL Resource . DEPTH _ INFINITE , progress CaMeL Monitor ) ; if ( ! src CaMeL Folder . exists ( ) ) src CaMeL Folder . create ( true , false , progress CaMeL Monitor ) ;
Local CaMeL Vcs vcs = Local CaMeL Vcs CaMeL Component . get CaMeL Instance ( my CaMeL Project ) . get CaMeL Local CaMeL Vcs ( ) ;  <CTX>  private void init CaMeL Model ( Virtual CaMeL File f ) { Local CaMeL Vcs vcs = Local CaMeL Vcs CaMeL Component . get CaMeL Instance ( my CaMeL Project ) . get CaMeL Local CaMeL Vcs ( ) ; my CaMeL Model = create CaMeL Model CaMeL For ( f , vcs ) ; }	Local CaMeL Vcs vcs = Local CaMeL Vcs CaMeL Component . get CaMeL Local CaMeL Vcs CaMeL For ( my CaMeL Project ) ;
int value = read ( ) ;  <CTX>  public final byte read CaMeL Byte ( ) throws IO CaMeL Exception { int value = read ( ) ; if ( value == - 1 ) { throw new EOF CaMeL Exception ( ) ; } return ( ( byte ) value ) ; }	final int value = read ( ) ;
return Long . to CaMeL String ( ( long ) r + o 1 ) ;  <CTX>  public Object get CaMeL Value CaMeL At ( int row , int col ) { int r = row - 1 ; int c = col - 1 ; if ( r >= 0 && r < rows && c >= 0 && c < cols ) { long p 0 = o 0 + ( ( long ) c ) ; long p 1 = o 1 + ( ( long ) rows - 1 - r ) ; long [ ] pos = new long [ ] { p 0 , p 1 } ; int index = ( int ) shape . position CaMeL To CaMeL Offset ( pos ) ; return cg . get CaMeL Value CaMeL At ( index ) ; } else { if ( ( r < 0 || r >= rows ) && ( c >= 0 && c < cols ) ) { return Long . to CaMeL String ( ( long ) c + o 0 ) ; } else if ( ( c < 0 || c >= cols ) && ( r >= 0 && r < rows ) ) { return Long . to CaMeL String ( ( long ) r + o 1 ) ; } else { return null ; } } }	long p 1 = o 1 + ( ( long ) rows - 1 - r ) ; return Long . to CaMeL String ( p 1 ) ;
r@@ log = runtime CaMeL Logger ; introspector = new Introspector ( r@@ log ) ;  <CTX>  public void set CaMeL Runtime CaMeL Logger ( Runtime CaMeL Logger runtime CaMeL Logger ) { r@@ log = runtime CaMeL Logger ; introspector = new Introspector ( r@@ log ) ; }	set CaMeL Log ( new Runtime CaMeL Logger CaMeL Log ( runtime CaMeL Logger ) ) ;
if ( context . is CaMeL In CaMeL Factory ( ) && ( expression CaMeL Results != null ) )  <CTX>  protected void access CaMeL Row ( Row CaMeL Design row , I CaMeL Content CaMeL Emitter emitter , Expression CaMeL Results expression CaMeL Results ) { if ( row CaMeL Closed ) { I CaMeL Row CaMeL Content row CaMeL Content = report . create CaMeL Row CaMeL Content ( ) ; row CaMeL Content . set CaMeL Row CaMeL ID ( row CaMeL Id ++ ) ; assert ( row CaMeL Content instanceof Row CaMeL Content ) ; I CaMeL Content parent = context . get CaMeL Content ( ) ; context . push CaMeL Content ( row CaMeL Content ) ; initialize CaMeL Content ( parent , row , row CaMeL Content ) ; process CaMeL Style ( row , row CaMeL Content ) ; process CaMeL Visibility ( row , row CaMeL Content ) ; process CaMeL Bookmark ( row , row CaMeL Content ) ; process CaMeL Action ( row , row CaMeL Content ) ; if ( need CaMeL Page CaMeL Break ) { row CaMeL Content . get CaMeL Style ( ) . set CaMeL Property ( I CaMeL Style . STYLE _ PAGE _ BREAK _ BEFORE , I CaMeL Style . SOFT _ VALUE ) ; need CaMeL Page CaMeL Break = false ; } if ( context . is CaMeL In CaMeL Factory ( ) && ( expression CaMeL Results != null ) ) { Detail CaMeL Row CaMeL Script CaMeL Executor . handle CaMeL On CaMeL Create ( ( Row CaMeL Content ) row CaMeL Content , expression CaMeL Results , context ) ; } if ( emitter != null ) { emitter . start CaMeL Row ( row CaMeL Content ) ; } row CaMeL Closed = false ; } for ( int j = 0 ; j < row . get CaMeL Cell CaMeL Count ( ) ; j ++ ) { Cell CaMeL Design cell = row . get CaMeL Cell ( j ) ; if ( cell != null ) { I CaMeL Cell CaMeL Content cell CaMeL Content = report . create CaMeL Cell CaMeL Content ( ) ; assert ( cell CaMeL Content instanceof Cell CaMeL Content ) ; I CaMeL Content parent = context . get CaMeL Content ( ) ; context . push CaMeL Content ( cell CaMeL Content ) ; initialize CaMeL Content ( parent , cell , cell CaMeL Content ) ; cell CaMeL Content . set CaMeL Column ( cell . get CaMeL Column ( ) ) ; cell CaMeL Content . set CaMeL Col CaMeL Span ( cell . get CaMeL Col CaMeL Span ( ) ) ; cell CaMeL Content . set CaMeL Row CaMeL Span ( cell . get CaMeL Row CaMeL Span ( ) ) ; process CaMeL Style ( cell , cell CaMeL Content ) ; process CaMeL Visibility ( cell , cell CaMeL Content ) ; process CaMeL Bookmark ( cell , cell CaMeL Content ) ; process CaMeL Action ( cell , cell CaMeL Content ) ; if ( context . is CaMeL In CaMeL Factory ( ) ) { Cell CaMeL Script CaMeL Executor . handle CaMeL On CaMeL Create ( ( Cell CaMeL Content ) cell CaMeL Content , expression CaMeL Results , context ) ; } if ( emitter != null ) { emitter . start CaMeL Cell ( cell CaMeL Content ) ; } for ( int m = 0 ; m < cell . get CaMeL Content CaMeL Count ( ) ; m ++ ) { Report CaMeL Item CaMeL Design item = cell . get CaMeL Content ( m ) ; if ( item != null ) { if ( layout CaMeL Emitter != null ) { item . accept ( this . visitor , layout CaMeL Emitter . get CaMeL Cell CaMeL Emitter ( ) ) ; } else { item . accept ( this . visitor , emitter ) ; } } } if ( emitter != null ) { emitter . end CaMeL Cell ( cell CaMeL Content ) ; } context . pop CaMeL Content ( ) ; } } boolean close CaMeL Row = true ; if ( close CaMeL Row ) { emitter . end CaMeL Row ( ( I CaMeL Row CaMeL Content ) context . get CaMeL Content ( ) ) ; context . pop CaMeL Content ( ) ; row CaMeL Closed = true ; } }	if ( context . is CaMeL In CaMeL Factory ( ) )
Abstract CaMeL Body . remove CaMeL Body CaMeL Event CaMeL Listener ( body CaMeL Event CaMeL Listener ) ;  <CTX>  void remove CaMeL Body CaMeL Event CaMeL Listener ( ) { Abstract CaMeL Body . remove CaMeL Body CaMeL Event CaMeL Listener ( body CaMeL Event CaMeL Listener ) ; }	Local CaMeL Body CaMeL Store . get CaMeL Instance ( ) . remove CaMeL Body CaMeL Event CaMeL Listener ( body CaMeL Event CaMeL Listener ) ;
if ( icon CaMeL Name == null ) return null ;  <CTX>  public Image CaMeL Descriptor get CaMeL Image CaMeL Descriptor ( ) { if ( image CaMeL Descriptor == null ) { String icon CaMeL Name = configuration CaMeL Element . get CaMeL Attribute ( I CaMeL Workbench CaMeL Registry CaMeL Constants . ATT _ ICON ) ; if ( icon CaMeL Name == null ) return null ; image CaMeL Descriptor = Abstract CaMeL UI CaMeL Plugin . image CaMeL Descriptor CaMeL From CaMeL Plugin ( configuration CaMeL Element . get CaMeL Namespace ( ) , icon CaMeL Name ) ; } return image CaMeL Descriptor ; }	if ( icon CaMeL Name == null ) { return null ; }
set CaMeL Value CaMeL At ( a _ Object , li _ row , 1 ) ;  <CTX>  public int add CaMeL Value ( Object a _ Object ) { int li _ row = add ( ) ; set CaMeL Value CaMeL At ( a _ Object , li _ row , 1 ) ; return li _ row ; }	try { set CaMeL Value CaMeL At ( a _ Object , li _ row , 1 ) ; } catch ( Component CaMeL Data CaMeL Exception l _ Component CaMeL Data CaMeL Exception ) { delete ( li _ row ) ; }
String res CaMeL Nav = I CaMeL Page CaMeL Layout . ID _ RES _ NAV ; String prob CaMeL View = I CaMeL Page CaMeL Layout . ID _ PROBLEM _ VIEW ; return new Test CaMeL Drop CaMeL Location [ ] {  <CTX>  private Test CaMeL Drop CaMeL Location [ ] get CaMeL Common CaMeL Drop CaMeL Targets ( I CaMeL Workbench CaMeL Window CaMeL Provider drag CaMeL Source ) { String res CaMeL Nav = I CaMeL Page CaMeL Layout . ID _ RES _ NAV ; String prob CaMeL View = I CaMeL Page CaMeL Layout . ID _ PROBLEM _ VIEW ; return new Test CaMeL Drop CaMeL Location [ ] { / / Test dragging to the edges of the workbench window new Window CaMeL Drop CaMeL Target ( drag CaMeL Source , SWT . TOP ) , new Window CaMeL Drop CaMeL Target ( drag CaMeL Source , SWT . BOTTOM ) , new Window CaMeL Drop CaMeL Target ( drag CaMeL Source , SWT . LEFT ) , new Window CaMeL Drop CaMeL Target ( drag CaMeL Source , SWT . RIGHT ) } ; }	Test CaMeL Drop CaMeL Location [ ] targets = {
} catch ( Instantiation CaMeL Exception e ) { ex = e ; } catch ( Illegal CaMeL Access CaMeL Exception e ) { ex = e ;  <CTX>  protected Delegator new CaMeL Instance ( ) { Exception ex ; try { return ( Delegator ) this . get CaMeL Class ( ) . new CaMeL Instance ( ) ; } catch ( Instantiation CaMeL Exception e ) { ex = e ; } catch ( Illegal CaMeL Access CaMeL Exception e ) { ex = e ; } throw Wrapped CaMeL Exception . wrap CaMeL Exception ( ex ) ; }	} catch ( Exception ex ) { throw Script CaMeL Runtime . throw CaMeL As CaMeL Unchecked CaMeL Exception ( ex ) ;
Ruby CaMeL Class super CaMeL Class = ( Ruby CaMeL Class ) load CaMeL Class ( java CaMeL Class . get CaMeL Superclass ( ) , null ) ;  <CTX>  private Ruby CaMeL Class create CaMeL Ruby CaMeL Class ( Class java CaMeL Class , String ruby CaMeL Name ) { Ruby CaMeL Class super CaMeL Class = ( Ruby CaMeL Class ) load CaMeL Class ( java CaMeL Class . get CaMeL Superclass ( ) , null ) ; Ruby CaMeL Class ruby CaMeL Class = ruby . define CaMeL Class ( ruby CaMeL Name , super CaMeL Class ) ; loaded CaMeL Java CaMeL Classes . put ( java CaMeL Class , ruby CaMeL Class ) ; define CaMeL Wrapper CaMeL Methods ( java CaMeL Class , ruby CaMeL Class , true ) ; define CaMeL Constants ( java CaMeL Class , ruby CaMeL Class ) ; define CaMeL Fields ( java CaMeL Class , ruby CaMeL Class ) ; add CaMeL Default CaMeL Modules ( ruby CaMeL Class ) ; return ruby CaMeL Class ; }	Class java CaMeL Super CaMeL Class = java CaMeL Class . get CaMeL Superclass ( ) ; Ruby CaMeL Class super CaMeL Class ; if ( java CaMeL Super CaMeL Class != null ) { super CaMeL Class = ( Ruby CaMeL Class ) load CaMeL Class ( java CaMeL Super CaMeL Class , null ) ; } else { super CaMeL Class = ruby . get CaMeL Classes ( ) . get CaMeL Object CaMeL Class ( ) ; }
return Ruby CaMeL Boolean . new CaMeL Boolean ( get CaMeL Runtime ( ) , thread CaMeL Local CaMeL Variables . contains CaMeL Key ( name ) ) ;  <CTX>  public Ruby CaMeL Boolean has _ key ( I CaMeL Ruby CaMeL Object key ) { String name = key CaMeL Name ( key ) ; return Ruby CaMeL Boolean . new CaMeL Boolean ( get CaMeL Runtime ( ) , thread CaMeL Local CaMeL Variables . contains CaMeL Key ( name ) ) ; }	return get CaMeL Runtime ( ) . new CaMeL Boolean ( thread CaMeL Local CaMeL Variables . contains CaMeL Key ( name ) ) ;
Iterator it = components . iterator ( ) ; while ( it . has CaMeL Next ( ) ) { ( ( J CaMeL Component ) it . next ( ) ) . set CaMeL Enabled ( enabled ) ; }  <CTX>  public void update ( boolean enabled ) { Iterator it = components . iterator ( ) ; while ( it . has CaMeL Next ( ) ) { ( ( J CaMeL Component ) it . next ( ) ) . set CaMeL Enabled ( enabled ) ; } }	menu CaMeL Item . set CaMeL Enabled ( enabled ) ;
assert CaMeL Not CaMeL Same ( 0 , atf . get CaMeL Size ( ) ) ;  <CTX>  public void test CaMeL Atom CaMeL Type CaMeL Factory ( ) { assert CaMeL True ( atf != null ) ; assert CaMeL Not CaMeL Same ( 0 , atf . get CaMeL Size ( ) ) ; }	assert CaMeL Not CaMeL Same ( new Integer ( 0 ) , new Integer ( atf . get CaMeL Size ( ) ) ) ;
Object listeners = context CaMeL Listeners ;  <CTX>  private void run CaMeL Listeners ( int reason ) { Object listeners = context CaMeL Listeners ; for ( int i = 0 ; ; ++ i ) { Context CaMeL Listener l ; l = ( Context CaMeL Listener ) Kit . get CaMeL Listener ( listeners , i ) ; if ( l == null ) break ; switch ( reason ) { case CONTEXT _ CREATED _ EVENT : l . context CaMeL Created ( this ) ; break ; case CONTEXT _ ENTER _ EVENT : l . context CaMeL Entered ( this ) ; break ; case CONTEXT _ EXIT _ EVENT : l . context CaMeL Exited ( this ) ; break ; case CONTEXT _ RELEASED _ EVENT : l . context CaMeL Released ( this ) ; break ; default : Kit . code CaMeL Bug ( ) ; } } }	Object listeners = static CaMeL Listeners ;
int top CaMeL Margin CaMeL Height = Property CaMeL Util . get CaMeL Dimension CaMeL Value ( style . get CaMeL Property ( Style CaMeL Constants . STYLE _ MARGIN _ TOP ) ) ; int bottom CaMeL Margin CaMeL Height = Property CaMeL Util . get CaMeL Dimension CaMeL Value ( style . get CaMeL Property ( Style CaMeL Constants . STYLE _ MARGIN _ BOTTOM ) ) ; int result = 0 ; if ( top CaMeL Margin CaMeL Height >= 0 ) result = height + top CaMeL Margin CaMeL Height ; if ( bottom CaMeL Margin CaMeL Height >= 0 ) result = result + bottom CaMeL Margin CaMeL Height ; return result ;  <CTX>  public int get CaMeL Allocated CaMeL Height ( ) { int top CaMeL Margin CaMeL Height = Property CaMeL Util . get CaMeL Dimension CaMeL Value ( style . get CaMeL Property ( Style CaMeL Constants . STYLE _ MARGIN _ TOP ) ) ; int bottom CaMeL Margin CaMeL Height = Property CaMeL Util . get CaMeL Dimension CaMeL Value ( style . get CaMeL Property ( Style CaMeL Constants . STYLE _ MARGIN _ BOTTOM ) ) ; int result = 0 ; if ( top CaMeL Margin CaMeL Height >= 0 ) result = height + top CaMeL Margin CaMeL Height ; if ( bottom CaMeL Margin CaMeL Height >= 0 ) result = result + bottom CaMeL Margin CaMeL Height ; return result ; }	return height + Property CaMeL Util . get CaMeL Dimension CaMeL Value ( style . get CaMeL Property ( Style CaMeL Constants . STYLE _ MARGIN _ TOP ) ) + Property CaMeL Util . get CaMeL Dimension CaMeL Value ( style . get CaMeL Property ( Style CaMeL Constants . STYLE _ MARGIN _ BOTTOM ) ) ;
switch ( e CaMeL Derived CaMeL Structural CaMeL Feature CaMeL ID ( e CaMeL Feature ) )  <CTX>  public boolean e CaMeL Is CaMeL Set ( E CaMeL Structural CaMeL Feature e CaMeL Feature ) { switch ( e CaMeL Derived CaMeL Structural CaMeL Feature CaMeL ID ( e CaMeL Feature ) ) { case Type CaMeL Package . BAR _ SERIES _ _ VISIBLE : return is CaMeL Set CaMeL Visible ( ) ; case Type CaMeL Package . BAR _ SERIES _ _ LABEL : return label != null ; case Type CaMeL Package . BAR _ SERIES _ _ DATA _ DEFINITION : return data CaMeL Definition != null && ! data CaMeL Definition . is CaMeL Empty ( ) ; case Type CaMeL Package . BAR _ SERIES _ _ SERIES _ IDENTIFIER : return SERIES _ IDENTIFIER _ EDEFAULT == null ? series CaMeL Identifier != null : ! SERIES _ IDENTIFIER _ EDEFAULT . equals ( series CaMeL Identifier ) ; case Type CaMeL Package . BAR _ SERIES _ _ DATA _ POINT : return data CaMeL Point != null ; case Type CaMeL Package . BAR _ SERIES _ _ DATA _ SETS : return data CaMeL Sets != null && ! data CaMeL Sets . is CaMeL Empty ( ) ; case Type CaMeL Package . BAR _ SERIES _ _ LABEL _ POSITION : return is CaMeL Set CaMeL Label CaMeL Position ( ) ; case Type CaMeL Package . BAR _ SERIES _ _ STACKED : return is CaMeL Set CaMeL Stacked ( ) ; case Type CaMeL Package . BAR _ SERIES _ _ TRIGGERS : return triggers != null && ! triggers . is CaMeL Empty ( ) ; case Type CaMeL Package . BAR _ SERIES _ _ TRANSLUCENT : return is CaMeL Set CaMeL Translucent ( ) ; case Type CaMeL Package . BAR _ SERIES _ _ CURVE _ FI@@ TTING : return curve CaMeL Fitting != null ; case Type CaMeL Package . BAR _ SERIES _ _ RI@@ SER : return is CaMeL Set CaMeL Riser ( ) ; case Type CaMeL Package . BAR _ SERIES _ _ RI@@ SER _ OUTLINE : return ri@@ ser CaMeL Outline != null ; } return e CaMeL Dynamic CaMeL Is CaMeL Set ( e CaMeL Feature ) ; }	switch ( feature CaMeL ID )
super ( configuration ) ;  <CTX>  public Cms CaMeL Select CaMeL Widget ( List configuration ) { super ( configuration ) ; }	super ( ) ;
rule CaMeL Array [ i ] = Workspace CaMeL Undo CaMeL Support . get CaMeL Workspace CaMeL Rule CaMeL Factory ( )  <CTX>  protected I CaMeL Scheduling CaMeL Rule get CaMeL Undo CaMeL Scheduling CaMeL Rule ( ) { I CaMeL Scheduling CaMeL Rule [ ] rule CaMeL Array = new I CaMeL Scheduling CaMeL Rule [ resources . length ] ; for ( int i = 0 ; i < resources . length ; i ++ ) { rule CaMeL Array [ i ] = Workspace CaMeL Undo CaMeL Support . get CaMeL Workspace CaMeL Rule CaMeL Factory ( ) . delete CaMeL Rule ( resources [ i ] ) ; } return Multi CaMeL Rule . combine ( rule CaMeL Array ) ; }	rule CaMeL Array [ i ] = Workspace CaMeL Undo CaMeL Util . get CaMeL Workspace CaMeL Rule CaMeL Factory ( )
view CaMeL Bug CaMeL Details CaMeL Item CaMeL Action CaMeL Performed ( evt ) ;  <CTX>  public void action CaMeL Performed ( java . awt . event . Action CaMeL Event evt ) { view CaMeL Bug CaMeL Details CaMeL Item CaMeL Action CaMeL Performed ( evt ) ; }	view CaMeL Console CaMeL Item CaMeL Action CaMeL Performed ( evt ) ;
Assert . assert ( - 1 != native CaMeL Web CaMeL Shell ) ;  <CTX>  public void back ( ) { my CaMeL Factory . throw CaMeL Exception CaMeL If CaMeL Not CaMeL Initialized ( ) ; Assert . assert ( - 1 != native CaMeL Web CaMeL Shell ) ; synchronized ( my CaMeL Browser CaMeL Control ) { native CaMeL Back ( native CaMeL Web CaMeL Shell ) ; }	Assert . assert _ it ( - 1 != native CaMeL Web CaMeL Shell ) ;
if ( methods [ i ] . get CaMeL Name ( ) . equals ( method CaMeL Name ) ) { method = methods [ i ] ; break ;  <CTX>  public Method find CaMeL Operation ( Axis CaMeL Operation op , Class Impl CaMeL Class ) { Method method = null ; String method CaMeL Name = op . get CaMeL Name ( ) . get CaMeL Local CaMeL Part ( ) ; Method [ ] methods = Impl CaMeL Class . get CaMeL Methods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { if ( methods [ i ] . get CaMeL Name ( ) . equals ( method CaMeL Name ) ) { method = methods [ i ] ; break ; } } return method ; }	if ( methods [ i ] . get CaMeL Name ( ) . equals ( method CaMeL Name ) && methods [ i ] . get CaMeL Parameter CaMeL Types ( ) . length == 1 && OM CaMeL Element . class . get CaMeL Name ( ) . equals ( methods [ i ] . get CaMeL Parameter CaMeL Types ( ) [ 0 ] . get CaMeL Name ( ) ) ) { return methods [ i ] ;
m CaMeL Ids = new int [ 1 ] ; m CaMeL Ids [ 0 ] = id ;  <CTX>  public Get CaMeL Item CaMeL Operation ( Session session , Operation CaMeL Context oc , Mailbox mbox , Requester req , int id , byte type ) throws Service CaMeL Exception { super ( session , oc , mbox , req , LOAD ) ; m CaMeL Ids = new int [ 1 ] ; m CaMeL Ids [ 0 ] = id ; m CaMeL Type = type ; m CaMeL Path = null ; }	m CaMeL Ids = new int [ ] { id } ;
File module CaMeL File = new File ( my CaMeL Dir , module CaMeL Path ) . get CaMeL Canonical CaMeL File ( ) ; module CaMeL Files . put ( module CaMeL File , module CaMeL Path ) ; }  <CTX>  public String get CaMeL Module CaMeL Path CaMeL Adjustment ( Maven CaMeL Project module CaMeL Project ) throws IO CaMeL Exception { File module = module CaMeL Project . get CaMeL File ( ) ; if ( module == null ) { return null ; } module = module . get CaMeL Canonical CaMeL File ( ) ; if ( module CaMeL Files == null ) { module CaMeL Files = new Hash CaMeL Map ( ) ; List modules = get CaMeL Modules ( ) ; File my CaMeL File = get CaMeL File ( ) ; if ( my CaMeL File != null ) { File my CaMeL Dir = my CaMeL File . get CaMeL Canonical CaMeL File ( ) . get CaMeL Parent CaMeL File ( ) ; if ( modules != null ) { for ( Iterator it = modules . iterator ( ) ; it . has CaMeL Next ( ) ; ) { String module CaMeL Path = ( String ) it . next ( ) ; File module CaMeL File = new File ( my CaMeL Dir , module CaMeL Path ) . get CaMeL Canonical CaMeL File ( ) ; module CaMeL Files . put ( module CaMeL File , module CaMeL Path ) ; } } } } return ( String ) module CaMeL Files . get ( module ) ; }	module CaMeL Adjustments . put ( module CaMeL Name , adjustment ) ;
return box ;  <CTX>  public Data CaMeL Bounds get CaMeL Data CaMeL Bounds ( ) { Data CaMeL Bounds box = null ; ES@@ RI CaMeL Bounding CaMeL Box bounds = new ES@@ RI CaMeL Bounding CaMeL Box ( ) ; Iterator sii = spatial CaMeL Indexes . iterator ( ) ; while ( sii . has CaMeL Next ( ) ) { Spatial CaMeL Index si = ( Spatial CaMeL Index ) sii . next ( ) ; if ( si != null ) { ES@@ RI CaMeL Bounding CaMeL Box bounding CaMeL Box = spatial CaMeL Index . get CaMeL Bounds ( ) ; if ( bounds != null ) { bounds . add CaMeL Bounds ( bounding CaMeL Box ) ; } } } return box ; }	return new Data CaMeL Bounds ( bounds . min . x , bounds . min . y , bounds . max . x , bounds . max . y ) ;
( download CaMeL Source ? branch . download CaMeL Source CaMeL Size : branch . download CaMeL Size ) ) ) ;  <CTX>  void install ( Roster roster , String install CaMeL Directory , boolean download CaMeL Source ) { if ( installed != null ) roster . add CaMeL Operation ( new Roster . Remove ( installed ) ) ; Branch branch = get CaMeL Compatible CaMeL Branch ( ) ; if ( branch . obsolete ) return ; / / branch . satisfy CaMeL Dependencies ( roster , install CaMeL Directory , / / download CaMeL Source ) ; if ( installed != null ) { install CaMeL Directory = Misc CaMeL Utilities . get CaMeL Parent CaMeL Of CaMeL Path ( installed ) ; } roster . add CaMeL Operation ( new Roster . Install ( ( download CaMeL Source ? branch . download CaMeL Source : branch . download ) , install CaMeL Directory , ( download CaMeL Source ? branch . download CaMeL Source CaMeL Size : branch . download CaMeL Size ) ) ) ; }	( download CaMeL Source ? branch . download CaMeL Source CaMeL Size : branch . download CaMeL Size ) ) ;
if ( part instanceof I CaMeL Editor CaMeL Part )  <CTX>  public void part CaMeL Activated ( I CaMeL Workbench CaMeL Part part ) { if ( part instanceof I CaMeL Editor CaMeL Part ) link CaMeL To CaMeL Editor ( ( I CaMeL Editor CaMeL Part ) part ) ; }	if ( part instanceof I CaMeL Editor CaMeL Part ) {
super ( project , XML _ FILE , get CaMeL Ch@@ ameleon CaMeL Type CaMeL By CaMeL File ( file ) , file ) ;  <CTX>  public Xml CaMeL File CaMeL Impl ( Project project , Virtual CaMeL File file ) { super ( project , XML _ FILE , get CaMeL Ch@@ ameleon CaMeL Type CaMeL By CaMeL File ( file ) , file ) ; }	super ( project , get CaMeL Element CaMeL Type ( file . get CaMeL File CaMeL Type ( ) ) , get CaMeL Ch@@ ameleon CaMeL Type CaMeL By CaMeL File ( file ) , file ) ;
Node node = Node CaMeL Utils . get CaMeL Next CaMeL Variation ( m _ current CaMeL Node ) ;  <CTX>  public void cb CaMeL Next CaMeL Variation ( ) { Node node = Node CaMeL Utils . get CaMeL Next CaMeL Variation ( m _ current CaMeL Node ) ; if ( node != null ) cb CaMeL Goto CaMeL Node ( node ) ; }	Node node = Node CaMeL Util . get CaMeL Next CaMeL Variation ( m _ current CaMeL Node ) ;
this ( PORT _ RECV , addr , port ) ;  <CTX>  public UDP CaMeL Can CaMeL Socket ( Inet CaMeL Address addr , int port ) throws IO CaMeL Exception { this ( PORT _ RECV , addr , port ) ; }	this ( PORT _ RECV ) ;
if ( get CaMeL Model ( ) . is CaMeL Enabled ( ) ) popup CaMeL Menu . set CaMeL Visible ( popup ) ;  <CTX>  public void set CaMeL Popup CaMeL Menu CaMeL Visible ( boolean popup ) { if ( get CaMeL Model ( ) . is CaMeL Enabled ( ) ) popup CaMeL Menu . set CaMeL Visible ( popup ) ; }	if ( popup != is CaMeL Popup CaMeL Menu CaMeL Visible ( ) && ( is CaMeL Enabled ( ) || ! popup ) ) { if ( popup && is CaMeL Showing ( ) ) { Point loc = menu CaMeL Location == null ? get CaMeL Popup CaMeL Menu CaMeL Origin ( ) : menu CaMeL Location ; get CaMeL Popup CaMeL Menu ( ) . show ( this , loc . x , loc . y ) ;
this ( hostname , port , secure , 0 , 0 ) ;  <CTX>  public HTTP CaMeL Connection ( String hostname , int port , boolean secure ) { this ( hostname , port , secure , 0 , 0 ) ; }	this ( hostname , HTTP _ PORT , false , 0 , 0 ) ;
return new Literal CaMeL Constraint ( field , extractor , evaluator ) ;  <CTX>  private Field CaMeL Constraint get CaMeL Literal CaMeL Constraint ( final Column column , final String field CaMeL Name , final Object field CaMeL Value , final Evaluator evaluator ) { final Class clazz = ( ( Class CaMeL Object CaMeL Type ) column . get CaMeL Object CaMeL Type ( ) ) . get CaMeL Class CaMeL Type ( ) ; final Field CaMeL Extractor extractor = new Class CaMeL Field CaMeL Extractor ( clazz , field CaMeL Name ) ; final Field CaMeL Value field = new Mock CaMeL Field ( field CaMeL Value ) ; return new Literal CaMeL Constraint ( field , extractor , evaluator ) ; }	return new Literal CaMeL Constraint ( extractor , evaluator , field ) ;
return p == null ? null : new File ( f , p ) ;  <CTX>  private static File get CaMeL Parent CaMeL File ( File f ) { String p = f . get CaMeL Parent ( ) ; return p == null ? null : new File ( f , p ) ; }	return p == null ? null : new File ( p ) ;
void visit CaMeL Bean CaMeL Definition ( Bean CaMeL Definition bean CaMeL Definition ) throws Beans CaMeL Exception ;  <CTX>  void visit CaMeL Bean CaMeL Definition ( Bean CaMeL Definition bean CaMeL Definition ) throws Beans CaMeL Exception ;	void visit CaMeL Bean CaMeL Definition ( String bean CaMeL Name , Bean CaMeL Definition bean CaMeL Definition , Object data ) throws Beans CaMeL Exception ;
column CaMeL Descr . add CaMeL Descr ( bound CaMeL Variable CaMeL Descr ) ;  <CTX>  public Object end ( final String uri , final String local CaMeL Name ) throws SAX CaMeL Exception { final Configuration config = this . xml CaMeL Package CaMeL Reader . end CaMeL Configuration ( ) ; final Bound CaMeL Variable CaMeL Descr bound CaMeL Variable CaMeL Descr = ( Bound CaMeL Variable CaMeL Descr ) this . xml CaMeL Package CaMeL Reader . get CaMeL Current ( ) ; final Linked CaMeL List parents = this . xml CaMeL Package CaMeL Reader . get CaMeL Parents ( ) ; final List CaMeL Iterator it = parents . list CaMeL Iterator ( parents . size ( ) ) ; it . previous ( ) ; final Column CaMeL Descr column CaMeL Descr = ( Column CaMeL Descr ) it . previous ( ) ; column CaMeL Descr . add CaMeL Descr ( bound CaMeL Variable CaMeL Descr ) ; return null ; }	column CaMeL Descr . add CaMeL Descr ( variable CaMeL Descr ) ;
try { s = lookup CaMeL Qualified CaMeL Name ( scope CaMeL To CaMeL Symbol ( scope ) , d@@ uple , new Array CaMeL List ( ) , false ) ; } catch ( AST CaMeL Semantic CaMeL Exception e ) {  <CTX>  public IAST CaMeL Node lookup CaMeL Symbol CaMeL In CaMeL Context ( IAST CaMeL Scope scope , I CaMeL Token CaMeL D@@ uple d@@ uple ) throws AST CaMeL Not CaMeL Implemented CaMeL Exception { I CaMeL Symbol s = null ; try { s = lookup CaMeL Qualified CaMeL Name ( scope CaMeL To CaMeL Symbol ( scope ) , d@@ uple , new Array CaMeL List ( ) , false ) ; } catch ( AST CaMeL Semantic CaMeL Exception e ) { } if ( s == null ) return null ; return s . get CaMeL AST CaMeL Extension ( ) . get CaMeL Primary CaMeL Declaration ( ) ; }	if ( reference == null ) { try { s = lookup CaMeL Qualified CaMeL Name ( scope CaMeL To CaMeL Symbol ( scope ) , d@@ uple , new Array CaMeL List ( ) , false ) ; } catch ( AST CaMeL Semantic CaMeL Exception e ) { } } else { if ( reference instanceof AST CaMeL Expression ) { AST CaMeL Expression expression = ( AST CaMeL Expression ) reference ; if ( expression . get CaMeL Expression CaMeL Kind ( ) == IAST CaMeL Expression . Kind . ID _ EXPRESSION ) { try { s = lookup CaMeL Qualified CaMeL Name ( scope CaMeL To CaMeL Symbol ( scope ) , d@@ uple , new Array CaMeL List ( ) , false ) ; } catch ( AST CaMeL Semantic CaMeL Exception e 1 ) { } } else { AST CaMeL Expression owner CaMeL Expression = expression . find CaMeL Owner CaMeL Expression CaMeL For CaMeL ID CaMeL Expression ( d@@ uple ) ; if ( owner CaMeL Expression == null ) return null ; if ( owner CaMeL Expression . get CaMeL Expression CaMeL Kind ( ) . is CaMeL Postfix CaMeL Member CaMeL Reference ( ) ) { try { s = lookup CaMeL Qualified CaMeL Name ( get CaMeL Search CaMeL Scope ( owner CaMeL Expression . get CaMeL Expression CaMeL Kind ( ) , owner CaMeL Expression . get CaMeL LHS CaMeL Expression ( ) , scope CaMeL To CaMeL Symbol ( scope ) ) , d@@ uple , new Array CaMeL List ( ) , false ) ; } catch ( AST CaMeL Semantic CaMeL Exception e ) { return null ; } } else { try { s = lookup CaMeL Qualified CaMeL Name ( scope CaMeL To CaMeL Symbol ( scope ) , d@@ uple , new Array CaMeL List ( ) , false ) ; } catch ( AST CaMeL Semantic CaMeL Exception e 1 ) { } } } }
nf . add CaMeL Child CaMeL To CaMeL Back ( pn , function ( ts , false ) ) ;  <CTX>  private Object parse CaMeL Function CaMeL Body ( Token CaMeL Stream ts ) throws IO CaMeL Exception { int old@@ flags = ts . flags ; ts . flags &= ~ ( Token CaMeL Stream . T@@ SF _ RETURN _ EXPR | Token CaMeL Stream . T@@ SF _ RETURN _ VOID ) ; ts . flags |= Token CaMeL Stream . T@@ SF _ FUNCTION ; Object pn = nf . create CaMeL Block ( ts . get CaMeL Lineno ( ) ) ; try { int tt ; while ( ( tt = ts . peek CaMeL Token ( ) ) > ts . EOF && tt != ts . RC ) { if ( tt == Token CaMeL Stream . FUNCTION ) { ts . get CaMeL Token ( ) ; nf . add CaMeL Child CaMeL To CaMeL Back ( pn , function ( ts , false ) ) ; } else { nf . add CaMeL Child CaMeL To CaMeL Back ( pn , statement ( ts ) ) ; } } } catch ( Java CaMeL Script CaMeL Exception e ) { this . ok = false ; } finally { / / also in finally block : / / flush CaMeL New CaMeL Lines , clear CaMeL Pushback . ts . flags = old@@ flags ; } return pn ; }	n = function ( ts , Function CaMeL Node . FUNCTION _ STATEMENT ) ;
if ( subscription . get CaMeL Receive CaMeL Posts CaMeL By CaMeL Email ( ) ) { if ( subscriber . get CaMeL Email ( ) == null ) { subscription . set CaMeL Receive CaMeL Posts CaMeL By CaMeL Email ( false ) ; } else {  <CTX>  private void notify CaMeL Email CaMeL Subscribers ( Conversation CaMeL Message conversation CaMeL Message ) { Set < Person > readers = conversation CaMeL Message . get CaMeL Conversation CaMeL Thread ( ) . get CaMeL Forum ( ) . get CaMeL Readers CaMeL Group ( ) . get CaMeL Elements ( ) ; Set < String > email CaMeL Addresses CaMeL To CaMeL Send CaMeL Message = new Hash CaMeL Set < String > ( ) ; Set < Forum CaMeL Subscription > subscriptions CaMeL To CaMeL Remove = new Hash CaMeL Set < Forum CaMeL Subscription > ( ) ; for ( Forum CaMeL Subscription subscription : conversation CaMeL Message . get CaMeL Conversation CaMeL Thread ( ) . get CaMeL Forum ( ) . get CaMeL Forum CaMeL Subscriptions ( ) ) { Person subscriber = subscription . get CaMeL Person ( ) ; if ( ! readers . contains ( subscriber ) ) { subscriptions CaMeL To CaMeL Remove . add ( subscription ) ; } if ( subscription . get CaMeL Receive CaMeL Posts CaMeL By CaMeL Email ( ) ) { if ( subscriber . get CaMeL Email ( ) == null ) { subscription . set CaMeL Receive CaMeL Posts CaMeL By CaMeL Email ( false ) ; } else { email CaMeL Addresses CaMeL To CaMeL Send CaMeL Message . add ( subscriber . get CaMeL Email ( ) ) ; } } } for ( Forum CaMeL Subscription subscription CaMeL To CaMeL Remove : subscriptions CaMeL To CaMeL Remove ) { conversation CaMeL Message . get CaMeL Conversation CaMeL Thread ( ) . get CaMeL Forum ( ) . remove CaMeL Forum CaMeL Subscriptions ( subscription CaMeL To CaMeL Remove ) ; subscription CaMeL To CaMeL Remove . delete ( ) ; } if ( ! email CaMeL Addresses CaMeL To CaMeL Send CaMeL Message . is CaMeL Empty ( ) ) { String email CaMeL Subject = get CaMeL Email CaMeL Formatted CaMeL Subject ( conversation CaMeL Message . get CaMeL Conversation CaMeL Thread ( ) ) ; String email CaMeL Body = get CaMeL Email CaMeL Formatted CaMeL Body ( conversation CaMeL Message ) ; Email CaMeL Sender . send ( get CaMeL Email CaMeL From ( ) , get CaMeL Email CaMeL From CaMeL Address ( ) , new Array CaMeL List < String > ( ) , new Array CaMeL List < String > ( ) , email CaMeL Addresses CaMeL To CaMeL Send CaMeL Message , email CaMeL Subject , email CaMeL Body ) ; } }	email CaMeL Addresses CaMeL To CaMeL Send CaMeL Message . add ( subscriber . get CaMeL Email ( ) ) ; } } }
. find CaMeL Posting CaMeL Rule CaMeL By CaMeL Event CaMeL Type CaMeL And CaMeL Date ( get CaMeL Event CaMeL Type ( ) , when CaMeL Registered ) ;  <CTX>  protected Posting CaMeL Rule get CaMeL Posting CaMeL Rule ( Date CaMeL Time when CaMeL Registered ) { return get CaMeL Administrative CaMeL Office ( ) . get CaMeL Service CaMeL Agreement CaMeL Template ( ) . find CaMeL Posting CaMeL Rule CaMeL By CaMeL Event CaMeL Type CaMeL And CaMeL Date ( get CaMeL Event CaMeL Type ( ) , when CaMeL Registered ) ; }	. find CaMeL Posting CaMeL Rule CaMeL By CaMeL Event CaMeL Type CaMeL And CaMeL Date ( get CaMeL Event CaMeL Type ( ) , get CaMeL When CaMeL Occured ( ) ) ;
if ( Arrays . equals ( element CaMeL Qualified CaMeL Name , final CaMeL D@@ uple . to CaMeL Qualified CaMeL Name ( ) ) ) return context CaMeL Node ;  <CTX>  protected IAST CaMeL Node lookup CaMeL Node ( I CaMeL Token CaMeL D@@ uple final CaMeL D@@ uple ) { if ( context CaMeL Node == null ) return null ; if ( context CaMeL Node instanceof IAST CaMeL Declaration ) { if ( context CaMeL Node instanceof IAST CaMeL Off@@ se@@ table CaMeL Named CaMeL Element ) { if ( ( ( IAST CaMeL Off@@ se@@ table CaMeL Named CaMeL Element ) context CaMeL Node ) . get CaMeL Name ( ) . equals ( final CaMeL D@@ uple . to CaMeL String ( ) ) ) return context CaMeL Node ; } if ( context CaMeL Node instanceof IAST CaMeL Qualified CaMeL Name CaMeL Element ) { String [ ] element CaMeL Qualified CaMeL Name = ( ( IAST CaMeL Qualified CaMeL Name CaMeL Element ) context CaMeL Node ) . get CaMeL Fully CaMeL Qualified CaMeL Name ( ) ; if ( Arrays . equals ( element CaMeL Qualified CaMeL Name , final CaMeL D@@ uple . to CaMeL Qualified CaMeL Name ( ) ) ) return context CaMeL Node ; } try { if ( our CaMeL Kind == IAST CaMeL Completion CaMeL Node . Completion CaMeL Kind . NEW _ TYPE _ REFERENCE ) { if ( context CaMeL Node instanceof IAST CaMeL Variable ) { IAST CaMeL Initializer CaMeL Clause initializer = ( ( IAST CaMeL Variable ) context CaMeL Node ) . get CaMeL Initializer CaMeL Clause ( ) ; if ( initializer != null ) { IAST CaMeL Expression owner CaMeL Expression = initializer . find CaMeL Expression CaMeL For CaMeL D@@ uple ( final CaMeL D@@ uple ) ; return ast CaMeL Factory . lookup CaMeL Symbol CaMeL In CaMeL Context ( our CaMeL Scope , final CaMeL D@@ uple , owner CaMeL Expression ) ; } } } return ast CaMeL Factory . lookup CaMeL Symbol CaMeL In CaMeL Context ( our CaMeL Scope , final CaMeL D@@ uple , null ) ; } catch ( AST CaMeL Not CaMeL Implemented CaMeL Exception e ) { return null ; } } else if ( context CaMeL Node instanceof IAST CaMeL Expression ) { try { return ast CaMeL Factory . lookup CaMeL Symbol CaMeL In CaMeL Context ( our CaMeL Scope , final CaMeL D@@ uple , context CaMeL Node ) ; } catch ( AST CaMeL Not CaMeL Implemented CaMeL Exception e ) { return null ; } } return null ; }	if ( Arrays . equals ( element CaMeL Qualified CaMeL Name , final CaMeL D@@ uple . to CaMeL Qualified CaMeL Name ( ) ) ) { IAST CaMeL Node decl CaMeL Node = null ; if ( context CaMeL Node instanceof I CaMeL Symbol CaMeL Owner ) { I CaMeL Symbol CaMeL Owner owner = ( I CaMeL Symbol CaMeL Owner ) context CaMeL Node ; if ( owner . get CaMeL Symbol ( ) != null && owner . get CaMeL Symbol ( ) . get CaMeL AST CaMeL Extension ( ) != null ) { decl CaMeL Node = owner . get CaMeL Symbol ( ) . get CaMeL AST CaMeL Extension ( ) . get CaMeL Primary CaMeL Declaration ( ) ; } } return ( decl CaMeL Node != null ) ? decl CaMeL Node : context CaMeL Node ; }
obj . add CaMeL As CaMeL Prototype ( cx , scope , sealed ) ;  <CTX>  public static void init ( Context cx , Scriptable scope , boolean sealed ) { Native CaMeL Array obj = new Native CaMeL Array ( ) ; obj . add CaMeL As CaMeL Prototype ( cx , scope , sealed ) ; }	obj . prototype CaMeL Flag = true ; obj . add CaMeL As CaMeL Prototype ( MAX _ PROTOTYPE _ ID , cx , scope , sealed ) ;
Event CaMeL Handling CaMeL Strategy event CaMeL Handling CaMeL Strategy , Io CaMeL Filter CaMeL Chain CaMeL Builder filter CaMeL Chain CaMeL Builder ) { super ( net@@ working CaMeL Options , filter CaMeL Chain CaMeL Builder ) ;  <CTX>  public Initiator CaMeL Io CaMeL Handler ( Session quickfix CaMeL Session , Networking CaMeL Options net@@ working CaMeL Options , Event CaMeL Handling CaMeL Strategy event CaMeL Handling CaMeL Strategy , Io CaMeL Filter CaMeL Chain CaMeL Builder filter CaMeL Chain CaMeL Builder ) { super ( net@@ working CaMeL Options , filter CaMeL Chain CaMeL Builder ) ; this . quickfix CaMeL Session = quickfix CaMeL Session ; this . event CaMeL Handling CaMeL Strategy = event CaMeL Handling CaMeL Strategy ; }	Event CaMeL Handling CaMeL Strategy event CaMeL Handling CaMeL Strategy ) { super ( net@@ working CaMeL Options ) ;
int last CaMeL Item = size ( ) ;  <CTX>  public Object remove CaMeL LRU ( ) { int last CaMeL Item = size ( ) ; Object key = bubble CaMeL List . remove ( last CaMeL Item ) ; Value CaMeL Position CaMeL Pair pair = remove CaMeL Pair ( key ) ; return key ; }	int last CaMeL Item = size ( ) - 1 ;
id CaMeL Map . put ( name , elements [ j ] . get CaMeL Attribute ( ATTR _ ID ) ) ;  <CTX>  private void initialize CaMeL Formatters ( ) { id CaMeL Map = new Hash CaMeL Map ( ) ; id CaMeL Map . put ( NONE , null ) ; I CaMeL Extension CaMeL Point point = Platform . get CaMeL Extension CaMeL Registry ( ) . get CaMeL Extension CaMeL Point ( C CaMeL Core CaMeL Plugin . PLUGIN _ ID , C CaMeL Core CaMeL Plugin . FORMATTER _ EXT@@ POINT _ ID ) ; if ( point != null ) { I CaMeL Extension [ ] exts = point . get CaMeL Extensions ( ) ; for ( int i = 0 ; i < exts . length ; i ++ ) { I CaMeL Configuration CaMeL Element [ ] elements = exts [ i ] . get CaMeL Configuration CaMeL Elements ( ) ; for ( int j = 0 ; j < elements . length ; ++ j ) { String name = elements [ j ] . get CaMeL Attribute ( ATTR _ NAME ) ; id CaMeL Map . put ( name , elements [ j ] . get CaMeL Attribute ( ATTR _ ID ) ) ; } } } }	String id = elements [ j ] . get CaMeL Attribute ( ATTR _ ID ) ; id CaMeL Map . put ( name , id ) ;
close CaMeL Client CaMeL Socket ( ) ;  <CTX>  public void run ( ) { try { synchronized ( mutex ) { if ( client _ sock == null ) return ; in = client _ sock . get CaMeL Input CaMeL Stream ( ) ; } while ( ( in . read ( ) ) != - 1 ) { } } catch ( IO CaMeL Exception io _ ex 1 ) { } finally { close CaMeL Client CaMeL Socket ( ) ; synchronized ( clients ) { clients . remove ( this ) ; } } }	Socket sock = client _ sock ; if ( sock != null && ! sock . is CaMeL Closed ( ) ) close CaMeL Client CaMeL Socket ( ) ;
return super . get CaMeL Row CaMeL Count ( ) - n@@ tail _ + i@@ row ;  <CTX>  private long translate CaMeL Row ( long i@@ row ) { return super . get CaMeL Row CaMeL Count ( ) - n@@ tail _ + i@@ row ; }	return super . get CaMeL Row CaMeL Count ( ) - get CaMeL Row CaMeL Count ( ) + i@@ row ;
assert CaMeL Equals ( iter . next ( ) , dest [ i ] , 0 f ) ;  <CTX>  public void test CaMeL To CaMeL Just CaMeL Big CaMeL Enough CaMeL Byte CaMeL Array ( ) { Byte CaMeL List list = make CaMeL Full CaMeL Byte CaMeL List ( ) ; byte [ ] dest = new byte [ list . size ( ) ] ; assert CaMeL Same ( dest , list . to CaMeL Array ( dest ) ) ; int i = 0 ; for ( Byte CaMeL Iterator iter = list . iterator ( ) ; iter . has CaMeL Next ( ) ; i ++ ) { assert CaMeL Equals ( iter . next ( ) , dest [ i ] , 0 f ) ; } }	assert CaMeL Equals ( iter . next ( ) , dest [ i ] ) ;
req . set CaMeL Request ( service . retrieve CaMeL Scheduled CaMeL SI CaMeL Events ( SI CaMeL Service . FROM _ CACHE _ OR _ STREAM , null , req , null , time , time ) ) ;  <CTX>  public javax . tv . service . SI CaMeL Request retrieve CaMeL Future CaMeL Program CaMeL Event ( java . util . Date time , javax . tv . service . SI CaMeL Requestor requestor ) throws javax . tv . service . SI CaMeL Exception { javax . tv . service . Org CaMeL Dvb CaMeL Si CaMeL Request CaMeL Adapter req = new javax . tv . service . Org CaMeL Dvb CaMeL Si CaMeL Request CaMeL Adapter ( requestor ) ; req . set CaMeL Request ( service . retrieve CaMeL Scheduled CaMeL SI CaMeL Events ( SI CaMeL Service . FROM _ CACHE _ OR _ STREAM , null , req , null , time , time ) ) ; return req ; }	try { req . set CaMeL Request ( service . retrieve CaMeL Scheduled CaMeL SI CaMeL Events ( SI CaMeL Service . FROM _ CACHE _ OR _ STREAM , null , req , null , time , time ) ) ; } catch ( org . dvb . si . SI CaMeL Illegal CaMeL Argument CaMeL Exception ex ) { ex . print CaMeL Stack CaMeL Trace ( ) ; }
job . set CaMeL Property ( Progress CaMeL Manager . PROPERTY _ IN _ DIALOG , new Boolean ( true ) ) ; return super . open ( ) ;  <CTX>  public int open ( ) { job . set CaMeL Property ( Progress CaMeL Manager . PROPERTY _ IN _ DIALOG , new Boolean ( true ) ) ; return super . open ( ) ; }	if ( job . get CaMeL State ( ) == Job . RUNNING ) { job . set CaMeL Property ( Progress CaMeL Manager . PROPERTY _ IN _ DIALOG , new Boolean ( true ) ) ; return super . open ( ) ; } add CaMeL Listener CaMeL To CaMeL Open ( ) ; return CANCEL ;
if ( has CaMeL Target CaMeL Builder ( project ) ) {  <CTX>  public boolean visit ( I CaMeL Resource CaMeL Delta delta ) { if ( delta == null ) { return false ; } I CaMeL Resource resource = delta . get CaMeL Resource ( ) ; if ( resource . get CaMeL Type ( ) == I CaMeL Resource . PROJECT ) { I CaMeL Project project = ( I CaMeL Project ) resource ; int flags = delta . get CaMeL Flags ( ) ; int delta CaMeL Kind = delta . get CaMeL Kind ( ) ; if ( delta CaMeL Kind == I CaMeL Resource CaMeL Delta . ADDED ) { if ( has CaMeL Target CaMeL Builder ( project ) ) { f CaMeL Projects . add ( project ) ; notify CaMeL Listeners ( new Make CaMeL Target CaMeL Event ( Make CaMeL Target CaMeL Manager . this , Make CaMeL Target CaMeL Event . PROJECT _ ADDED , project ) ) ; } } else if ( delta CaMeL Kind == I CaMeL Resource CaMeL Delta . REMOVED ) { if ( f CaMeL Projects . contains ( project ) ) { delete CaMeL Targets ( project ) ; f CaMeL Projects . remove ( project ) ; notify CaMeL Listeners ( new Make CaMeL Target CaMeL Event ( Make CaMeL Target CaMeL Manager . this , Make CaMeL Target CaMeL Event . PROJECT _ REMOVED , project ) ) ; } } else if ( delta CaMeL Kind == I CaMeL Resource CaMeL Delta . CHANGED ) { if ( 0 != ( flags & I CaMeL Resource CaMeL Delta . DESCRIPTION ) ) { if ( f CaMeL Projects . contains ( project ) && ! has CaMeL Target CaMeL Builder ( project ) ) { f CaMeL Projects . remove ( project ) ; project CaMeL Map . remove ( project ) ; notify CaMeL Listeners ( new Make CaMeL Target CaMeL Event ( Make CaMeL Target CaMeL Manager . this , Make CaMeL Target CaMeL Event . PROJECT _ REMOVED , project ) ) ; } else if ( ! f CaMeL Projects . contains ( project ) && has CaMeL Target CaMeL Builder ( project ) ) { f CaMeL Projects . add ( project ) ; notify CaMeL Listeners ( new Make CaMeL Target CaMeL Event ( Make CaMeL Target CaMeL Manager . this , Make CaMeL Target CaMeL Event . PROJECT _ ADDED , project ) ) ; } } if ( 0 != ( flags & I CaMeL Resource CaMeL Delta . OPEN ) ) { if ( ! project . is CaMeL Open ( ) && f CaMeL Projects . contains ( project ) ) { f CaMeL Projects . remove ( project ) ; project CaMeL Map . remove ( project ) ; notify CaMeL Listeners ( new Make CaMeL Target CaMeL Event ( Make CaMeL Target CaMeL Manager . this , Make CaMeL Target CaMeL Event . PROJECT _ REMOVED , project ) ) ; } else if ( project . is CaMeL Open ( ) && has CaMeL Target CaMeL Builder ( project ) && ! f CaMeL Projects . contains ( project ) ) { f CaMeL Projects . add ( project ) ; notify CaMeL Listeners ( new Make CaMeL Target CaMeL Event ( Make CaMeL Target CaMeL Manager . this , Make CaMeL Target CaMeL Event . PROJECT _ ADDED , project ) ) ; } } } return false ; } return resource instanceof I CaMeL Workspace CaMeL Root ; }	if ( has CaMeL Target CaMeL Builder ( project ) && ! f CaMeL Projects . contains ( project ) ) {
return e CaMeL Dynamic CaMeL Get ( e CaMeL Feature , resolve ) ;  <CTX>  public Object e CaMeL Get ( E CaMeL Structural CaMeL Feature e CaMeL Feature , boolean resolve ) { switch ( e CaMeL Derived CaMeL Structural CaMeL Feature CaMeL ID ( e CaMeL Feature ) ) { case Component CaMeL Package . CURVE _ FI@@ TTING _ _ LINE _ ATTRIBUTES : return get CaMeL Line CaMeL Attributes ( ) ; case Component CaMeL Package . CURVE _ FI@@ TTING _ _ LABEL : return get CaMeL Label ( ) ; case Component CaMeL Package . CURVE _ FI@@ TTING _ _ LABEL _ ANCHOR : return get CaMeL Label CaMeL Anchor ( ) ; } return e CaMeL Dynamic CaMeL Get ( e CaMeL Feature , resolve ) ; }	return super . e CaMeL Get ( feature CaMeL ID , resolve , core CaMeL Type ) ;
m _ driver CaMeL Manager . export CaMeL Resources ( this , m _ context , export CaMeL File , export CaMeL Paths , include CaMeL System , exclude CaMeL Unchanged ) ;  <CTX>  public void export CaMeL Resources ( String export CaMeL File , String [ ] export CaMeL Paths , boolean include CaMeL System , boolean exclude CaMeL Unchanged ) throws Cms CaMeL Exception { / / export the resources m _ driver CaMeL Manager . export CaMeL Resources ( this , m _ context , export CaMeL File , export CaMeL Paths , include CaMeL System , exclude CaMeL Unchanged ) ; }	m _ driver CaMeL Manager . export CaMeL Resources ( this , m _ context , export CaMeL File , export CaMeL Paths ) ;
if ( ( method . get CaMeL No@@ ex ( ) & no@@ ex ) == 0 ) {  <CTX>  public int execute ( Object key , Object value , Object arg ) { / / cast args String id = ( String ) key ; I CaMeL Callable method = ( I CaMeL Callable ) value ; Ruby CaMeL Array ary = ( Ruby CaMeL Array ) arg ; if ( ( method . get CaMeL No@@ ex ( ) & no@@ ex ) == 0 ) { Ruby CaMeL String name = Ruby CaMeL String . new CaMeL String ( get CaMeL Runtime ( ) , id ) ; if ( ! ary . includes ( name ) ) { if ( method == null ) { ary . append ( get CaMeL Runtime ( ) . get CaMeL Nil ( ) ) ; } ary . append ( name ) ; } } else if ( method instanceof Evaluate CaMeL Method && ( ( Evaluate CaMeL Method ) method ) . get CaMeL Node ( ) instanceof Z CaMeL Super CaMeL Node ) { ary . append ( get CaMeL Runtime ( ) . get CaMeL Nil ( ) ) ; ary . append ( Ruby CaMeL String . new CaMeL String ( get CaMeL Runtime ( ) , id ) ) ; } return Ruby CaMeL Map CaMeL Method . CONTINUE ; }	if ( method . get CaMeL Visibility ( ) == no@@ ex ) {
get CaMeL Model CaMeL Adapt CaMeL Helper ( ) . mark CaMeL Dirty ( true ) ;  <CTX>  public void insert CaMeL Row ( int row CaMeL Number , int parent CaMeL Row CaMeL Number ) throws Semantic CaMeL Exception { trans CaMeL Star ( TRANS _ LABEL _ INSERT _ ROW ) ; Assert . is CaMeL Legal ( row CaMeL Number != 0 ) ; int real CaMeL Row CaMeL Number = row CaMeL Number > 0 ? parent CaMeL Row CaMeL Number + row CaMeL Number : parent CaMeL Row CaMeL Number + row CaMeL Number + 1 ; int shift CaMeL Pos = row CaMeL Number > 0 ? row CaMeL Number : row CaMeL Number + 1 ; Row CaMeL Handle row = ( Row CaMeL Handle ) get CaMeL Row ( parent CaMeL Row CaMeL Number ) ; Row CaMeL Handle CaMeL Adapter adapt = Handle CaMeL Adapter CaMeL Factory . get CaMeL Instance ( ) . get CaMeL Row CaMeL Handle CaMeL Adapter ( row ) ; Row CaMeL Handle copy = ( Row CaMeL Handle ) adapt . copy ( ) ; Table CaMeL Handle CaMeL Adapter . Row CaMeL UI CaMeL Infomation row CaMeL Info = get CaMeL Row CaMeL Info ( row ) ; List row CaMeL List = row CaMeL Info . get CaMeL All CaMeL Children ( ) ; int row CaMeL Size = row CaMeL List . size ( ) ; for ( int i = 0 ; i < row CaMeL Size ; i ++ ) { Cell CaMeL Handle parent CaMeL Cell = ( Cell CaMeL Handle ) row CaMeL List . get ( i ) ; Cell CaMeL Handle cell = get CaMeL Cell CaMeL Handle CaMeL Copy ( parent CaMeL Cell ) ; copy . get CaMeL Slot ( Row CaMeL Handle . CONTENT _ SLOT ) . add ( cell ) ; } Slot CaMeL Handle parent CaMeL Handle = row . get CaMeL Container CaMeL Slot CaMeL Handle ( ) ; parent CaMeL Handle . add ( ( copy ) ) ; int pos = parent CaMeL Handle . find CaMeL Posn ( row ) ; parent CaMeL Handle . shift ( copy , pos + shift CaMeL Pos ) ; Row CaMeL Handle CaMeL Adapter copy CaMeL Adapt = Handle CaMeL Adapter CaMeL Factory . get CaMeL Instance ( ) . get CaMeL Row CaMeL Handle CaMeL Adapter ( copy ) ; List copy CaMeL Children = copy CaMeL Adapt . get CaMeL Children ( ) ; get CaMeL Model CaMeL Adapt CaMeL Helper ( ) . mark CaMeL Dirty ( true ) ; Table CaMeL Handle CaMeL Adapter . Row CaMeL UI CaMeL Infomation info = get CaMeL Row CaMeL Info ( copy ) ; List list = info . get CaMeL All CaMeL Children ( ) ; List temp = new Array CaMeL List ( ) ; int size = list . size ( ) ; List has CaMeL Adjust = new Array CaMeL List ( ) ; for ( int i = 0 ; i < size ; i ++ ) { Object fill CaMeL Cell = list . get ( i ) ; Cell CaMeL Handle CaMeL Adapter cell CaMeL Adapt = Handle CaMeL Adapter CaMeL Factory . get CaMeL Instance ( ) . get CaMeL Cell CaMeL Handle CaMeL Adapter ( fill CaMeL Cell ) ; if ( cell CaMeL Adapt . get CaMeL Row CaMeL Number ( ) != real CaMeL Row CaMeL Number ) { if ( ! has CaMeL Adjust . contains ( fill CaMeL Cell ) ) { cell CaMeL Adapt . set CaMeL Row CaMeL Span ( cell CaMeL Adapt . get CaMeL Row CaMeL Span ( ) + 1 ) ; has CaMeL Adjust . add ( fill CaMeL Cell ) ; } temp . add ( new Integer ( i ) ) ; } } int copy CaMeL Row CaMeL Size = copy CaMeL Children . size ( ) ; for ( int i = 0 ; i < copy CaMeL Row CaMeL Size ; i ++ ) { if ( temp . contains ( new Integer ( i ) ) ) { ( ( Cell CaMeL Handle ) copy CaMeL Children . get ( i ) ) . drop ( ) ; } } trans CaMeL End ( ) ; }	if ( get CaMeL Model CaMeL Adapt CaMeL Helper ( ) != null ) { get CaMeL Model CaMeL Adapt CaMeL Helper ( ) . mark CaMeL Dirty ( true ) ; }
} else if ( parent instanceof I CaMeL Task CaMeL Query ) { I CaMeL Task CaMeL Query t = ( I CaMeL Task CaMeL Query ) parent ;  <CTX>  public boolean has CaMeL Children ( Object parent ) { if ( parent instanceof I CaMeL Task CaMeL Category ) { I CaMeL Task CaMeL Category cat = ( I CaMeL Task CaMeL Category ) parent ; return cat . get CaMeL Children ( ) != null && cat . get CaMeL Children ( ) . size ( ) > 0 ; } else if ( parent instanceof Task ) { Task t = ( Task ) parent ; return t . get CaMeL Children ( ) != null && t . get CaMeL Children ( ) . size ( ) > 0 ; } else if ( parent instanceof I CaMeL Task CaMeL Query ) { I CaMeL Task CaMeL Query t = ( I CaMeL Task CaMeL Query ) parent ; return t . get CaMeL Hits ( ) != null && t . get CaMeL Hits ( ) . size ( ) > 0 ; } return false ; }	} else if ( parent instanceof I CaMeL Repository CaMeL Query ) { I CaMeL Repository CaMeL Query t = ( I CaMeL Repository CaMeL Query ) parent ;
if ( data instanceof I CaMeL Property CaMeL Sheet CaMeL Entry ) entries . add ( data ) ;  <CTX>  public I CaMeL Selection get CaMeL Selection ( ) { if ( tree . get CaMeL Selection CaMeL Count ( ) == 0 ) return Structured CaMeL Selection . EMPTY ; Tree CaMeL Item [ ] sel = tree . get CaMeL Selection ( ) ; List entries = new Array CaMeL List ( sel . length ) ; for ( int i = 0 ; i < sel . length ; i ++ ) { Tree CaMeL Item ti = sel [ i ] ; Object data = ti . get CaMeL Data ( ) ; if ( data instanceof I CaMeL Property CaMeL Sheet CaMeL Entry ) entries . add ( data ) ; } return new Structured CaMeL Selection ( entries ) ; }	if ( data instanceof I CaMeL Property CaMeL Sheet CaMeL Entry ) { entries . add ( data ) ; }
return big CaMeL Norm ( get CaMeL Runtime ( ) , value . and ( ( ( Ruby CaMeL Bignum ) other ) . value ) ) ;  <CTX>  public Ruby CaMeL Numeric op _ and ( Ruby CaMeL Numeric other ) { if ( other instanceof Ruby CaMeL Bignum ) { return big CaMeL Norm ( get CaMeL Runtime ( ) , value . and ( ( ( Ruby CaMeL Bignum ) other ) . value ) ) ; } return big CaMeL Norm ( get CaMeL Runtime ( ) , get CaMeL Value ( ) . and ( new CaMeL Bignum ( get CaMeL Runtime ( ) , other . get CaMeL Long CaMeL Value ( ) ) . get CaMeL Value ( ) ) ) ; }	return big CaMeL Norm ( get CaMeL Runtime ( ) , value . and ( ( ( Ruby CaMeL Bignum ) other ) . value ) ) ; } else if ( other instanceof Ruby CaMeL Numeric ) { return big CaMeL Norm ( get CaMeL Runtime ( ) , get CaMeL Value ( ) . and ( new CaMeL Bignum ( get CaMeL Runtime ( ) , ( ( Ruby CaMeL Numeric ) other ) . get CaMeL Long CaMeL Value ( ) ) . get CaMeL Value ( ) ) ) ;
File new CaMeL File = new File ( source . get CaMeL Parent CaMeL File ( ) , dialog . get CaMeL Value ( ) ) ;  <CTX>  private Workspace CaMeL Modify CaMeL Operation save CaMeL New CaMeL File CaMeL Operation ( ) { return new Workspace CaMeL Modify CaMeL Operation ( ) { public void execute ( final I CaMeL Progress CaMeL Monitor monitor ) throws Core CaMeL Exception { Input CaMeL Dialog dialog = new Input CaMeL Dialog ( client CaMeL Frame . get CaMeL Shell ( ) , FILE _ PROMP@@ TER _ TITLE , FILE _ PROMP@@ TER _ MESSAGE , source . get CaMeL Name ( ) , null ) ; dialog . set CaMeL Block CaMeL On CaMeL Open ( true ) ; dialog . open ( ) ; if ( dialog . get CaMeL Return CaMeL Code ( ) == dialog . OK ) { File new CaMeL File = new File ( source . get CaMeL Parent CaMeL File ( ) , dialog . get CaMeL Value ( ) ) ; if ( save CaMeL File ( new CaMeL File ) ) { I CaMeL File new CaMeL Resource = resource . get CaMeL Workspace ( ) . get CaMeL Root ( ) . get CaMeL File CaMeL For CaMeL Location ( new Path ( new CaMeL File . get CaMeL Absolute CaMeL Path ( ) ) ) ; if ( new CaMeL Resource != null ) { source CaMeL Changed ( new CaMeL Resource ) ; new CaMeL Resource . refresh CaMeL Local ( I CaMeL Resource . DEPTH _ ZERO , monitor ) ; } } else { display CaMeL Error CaMeL Dialog ( SAVE _ ERROR _ TITLE , SAVE _ ERROR _ MESSAGE + new CaMeL File . get CaMeL Name ( ) ) ; return ; } } } } ; }	String project CaMeL Name = new CaMeL Path . segment ( 0 ) ; new CaMeL Path = new CaMeL Path . remove CaMeL First CaMeL Segments ( 1 ) ; I CaMeL Project project = resource . get CaMeL Workspace ( ) . get CaMeL Root ( ) . get CaMeL Project ( project CaMeL Name ) ; new CaMeL Path = project . get CaMeL Location ( ) . append ( new CaMeL Path ) ; File new CaMeL File = new CaMeL Path . to CaMeL File ( ) ;
get CaMeL Extents ( ) . width - ( margin . left + border . left + padding . left ) - ( margin . right + border . right + padding . right ) , get CaMeL Extents ( ) . height - ( margin . top + border . top + padding . top ) - ( margin . bottom + border . bottom + padding . bottom ) ) ;  <CTX>  public void shrink CaMeL Extents ( Box block ) { extents _ stack . push ( get CaMeL Extents ( ) ) ; Border border = block . border ; Border padding = block . padding ; Border margin = block . margin ; Rectangle rect = new Rectangle ( 0 , 0 , get CaMeL Extents ( ) . width - ( margin . left + border . left + padding . left ) - ( margin . right + border . right + padding . right ) , get CaMeL Extents ( ) . height - ( margin . top + border . top + padding . top ) - ( margin . bottom + border . bottom + padding . bottom ) ) ; set CaMeL Extents ( rect ) ; }	get CaMeL Extents ( ) . width - block . total CaMeL Horizontal CaMeL Padding ( ) , get CaMeL Extents ( ) . height - block . total CaMeL Vertical CaMeL Padding ( ) ) ;
return Ruby CaMeL Boolean . new CaMeL Boolean ( get CaMeL Runtime ( ) , Modifier . is CaMeL Final ( field . get CaMeL Modifiers ( ) ) ) ;  <CTX>  public Ruby CaMeL Boolean final _ p ( ) { return Ruby CaMeL Boolean . new CaMeL Boolean ( get CaMeL Runtime ( ) , Modifier . is CaMeL Final ( field . get CaMeL Modifiers ( ) ) ) ; }	return get CaMeL Runtime ( ) . new CaMeL Boolean ( Modifier . is CaMeL Final ( field . get CaMeL Modifiers ( ) ) ) ;
if ( ! problem . get CaMeL Reco@@ vering ( ) && ! problem . get CaMeL Ill@@ ness ( ) . get CaMeL Recovery CaMeL Treatment ( ) . get CaMeL Self CaMeL Admin@@ ister ( ) ) {  <CTX>  public boolean has CaMeL Waiting CaMeL Pati@@ ents ( ) { if ( ! pa@@ ti@@ ents . is CaMeL Empty ( ) ) { Iterator iter = pa@@ ti@@ ents . iterator ( ) ; while ( iter . has CaMeL Next ( ) ) { Health CaMeL Problem problem = ( Health CaMeL Problem ) iter . next ( ) ; if ( ! problem . get CaMeL Reco@@ vering ( ) && ! problem . get CaMeL Ill@@ ness ( ) . get CaMeL Recovery CaMeL Treatment ( ) . get CaMeL Self CaMeL Admin@@ ister ( ) ) { return true ; } } } return false ; }	if ( problem . get CaMeL A@@ waiting CaMeL Treatment ( ) ) {
List < Bulk CaMeL Entry CaMeL Account CaMeL Fee CaMeL Action CaMeL View > bulk CaMeL Entry CaMeL Customer CaMeL Fee CaMeL Views ) {  <CTX>  public static Bulk CaMeL Entry CaMeL View build CaMeL Bulk CaMeL Entry ( List < Customer CaMeL BO > all CaMeL Customers , Customer CaMeL View parent CaMeL Customer CaMeL View , Date transaction CaMeL Date , List < Bulk CaMeL Entry CaMeL Inst@@ all@@ ment CaMeL View > bulk CaMeL Entry CaMeL Lo@@ an CaMeL Views , List < Bulk CaMeL Entry CaMeL Inst@@ all@@ ment CaMeL View > bulk CaMeL Entry CaMeL Customer CaMeL Views , List < Bulk CaMeL Entry CaMeL Account CaMeL Fee CaMeL Action CaMeL View > bulk CaMeL Entry CaMeL Lo@@ an CaMeL Fee CaMeL Views , List < Bulk CaMeL Entry CaMeL Account CaMeL Fee CaMeL Action CaMeL View > bulk CaMeL Entry CaMeL Customer CaMeL Fee CaMeL Views ) { Customer CaMeL BO parent CaMeL Customer = get CaMeL Customer ( parent CaMeL Customer CaMeL View . get CaMeL Customer CaMeL Id ( ) , all CaMeL Customers ) ; return build CaMeL Bulk CaMeL Entry ( all CaMeL Customers , parent CaMeL Customer , parent CaMeL Customer CaMeL View , transaction CaMeL Date , bulk CaMeL Entry CaMeL Lo@@ an CaMeL Views , bulk CaMeL Entry CaMeL Customer CaMeL Views , bulk CaMeL Entry CaMeL Lo@@ an CaMeL Fee CaMeL Views , bulk CaMeL Entry CaMeL Customer CaMeL Fee CaMeL Views ) ; }	List < Bulk CaMeL Entry CaMeL Account CaMeL Fee CaMeL Action CaMeL View > bulk CaMeL Entry CaMeL Customer CaMeL Fee CaMeL Views , List < Bulk CaMeL Entry CaMeL Client CaMeL Attendance CaMeL View > bulk CaMeL Entry CaMeL Client CaMeL Attendance CaMeL Views ) {
my CaMeL Modified CaMeL Property CaMeL Names = new Hash CaMeL Set ( ) ;  <CTX>  public Rad CaMeL Component ( final Module module , final Class a CaMeL Class , final String id ) { LOG . assert CaMeL True ( module != null ) ; LOG . assert CaMeL True ( a CaMeL Class != null ) ; LOG . assert CaMeL True ( id != null ) ; my CaMeL Module = module ; my CaMeL Class = a CaMeL Class ; my CaMeL Id = id ; my CaMeL Change CaMeL Support = new Property CaMeL Change CaMeL Support ( this ) ; my CaMeL Constraints = new Grid CaMeL Constraints ( ) ; my CaMeL Modified CaMeL Property CaMeL Names = new Hash CaMeL Set ( ) ; try { final Constructor constructor = my CaMeL Class . get CaMeL Constructor ( new Class [ 0 ] ) ; constructor . set CaMeL Accessible ( true ) ; my CaMeL Delegee = ( J CaMeL Component ) constructor . new CaMeL Instance ( Array CaMeL Util . EMPTY _ OBJECT _ ARRAY ) ; } catch ( Exception e ) { throw new Runtime CaMeL Exception ( e ) ; } my CaMeL Delegee . put CaMeL Client CaMeL Property ( CLIENT _ PROP _ RAD _ COMPONENT , this ) ; }	my CaMeL Modified CaMeL Property CaMeL Names = new Hash CaMeL Set < String > ( ) ;
return _ cfb ;  <CTX>  public int get CaMeL Stack CaMeL Frame ( ) { return _ cfb ; }	return _ current CaMeL Frame CaMeL Bottom ;
expand CaMeL To CaMeL Default CaMeL Level ( ) ;  <CTX>  public void handle CaMeL Selection CaMeL Changed ( I CaMeL Selection selection ) { if ( this . selection != null && this . selection . equals ( selection ) ) return ; this . selection = selection ; de CaMeL Register CaMeL Listeners ( ) ; list = get CaMeL Model CaMeL List ( selection ) ; Group CaMeL Element CaMeL Handle handle = DE CaMeL Util . get CaMeL Multi CaMeL Selection CaMeL Handle ( list ) ; if ( handle != null && ! handle . is CaMeL Same CaMeL Type ( ) ) { viewer . set CaMeL Input ( null ) ; return ; } viewer . set CaMeL Input ( handle ) ; set CaMeL Title CaMeL Display CaMeL Name ( handle ) ; register CaMeL Listeners ( ) ; expand CaMeL To CaMeL Default CaMeL Level ( ) ; }	Object element = handle . get CaMeL Elements ( ) . get ( 0 ) ; if ( element instanceof Design CaMeL Element CaMeL Handle ) { I CaMeL Memento memento = viewer CaMeL Memento . get CaMeL Child ( Property CaMeL Memento CaMeL Util . get CaMeL Element CaMeL Type ( ( Design CaMeL Element CaMeL Handle ) element ) ) ; if ( memento == null ) { expand CaMeL To CaMeL Default CaMeL Level ( ) ; if ( viewer . get CaMeL Tree ( ) . get CaMeL Item CaMeL Count ( ) > 0 ) { Views CaMeL Memento element CaMeL Memento = ( Views CaMeL Memento ) viewer CaMeL Memento . create CaMeL Child ( Property CaMeL Memento CaMeL Util . get CaMeL Element CaMeL Type ( ( Design CaMeL Element CaMeL Handle ) element ) , Memento CaMeL Element . Type _ Element ) ; element CaMeL Memento . get CaMeL Memento CaMeL Element ( ) . set CaMeL Value ( new Integer ( 0 ) ) ; } } else if ( memento instanceof Views CaMeL Memento ) { expand CaMeL To CaMeL Default CaMeL Level ( ) ; expand CaMeL Tree CaMeL From CaMeL Memento ( ( Views CaMeL Memento ) memento ) ; } }
return get CaMeL Look CaMeL And CaMeL Feel CaMeL Defaults ( ) . get CaMeL UI ( target ) ;  <CTX>  public static Component CaMeL UI get CaMeL UI ( J CaMeL Component target ) { return get CaMeL Look CaMeL And CaMeL Feel CaMeL Defaults ( ) . get CaMeL UI ( target ) ; }	Component CaMeL UI ui = null ; if ( user CaMeL UI CaMeL Defaults != null && user CaMeL UI CaMeL Defaults . get ( target . get CaMeL UI CaMeL Class CaMeL ID ( ) ) != null ) ui = user CaMeL UI CaMeL Defaults . get CaMeL UI ( target ) ; if ( ui == null ) ui = current CaMeL UI CaMeL Defaults . get CaMeL UI ( target ) ; return ui ;
Roster CaMeL Entry ( String user , String name , XMPP CaMeL Connection connection ) {  <CTX>  Roster CaMeL Entry ( String user , String name , XMPP CaMeL Connection connection ) { this . user = user ; this . name = name ; this . connection = connection ; }	Roster CaMeL Entry ( String user , String name , Roster CaMeL Packet . Item CaMeL Type type , XMPP CaMeL Connection connection ) {
return null ;  <CTX>  private String get CaMeL Column CaMeL Name ( String expression ) { for ( Iterator iter = column CaMeL List . iterator ( ) ; iter . has CaMeL Next ( ) ; ) { Result CaMeL Set CaMeL Column CaMeL Handle cached CaMeL Column = ( Result CaMeL Set CaMeL Column CaMeL Handle ) iter . next ( ) ; if ( DE CaMeL Util . get CaMeL Expression ( cached CaMeL Column ) . equals ( expression ) ) { return cached CaMeL Column . get CaMeL Column CaMeL Name ( ) ; } } return null ; }	return expression ;
if ( query != null ) { Abstract CaMeL Repository CaMeL Connector connector = Tasks CaMeL Ui CaMeL Plugin . get CaMeL Repository CaMeL Manager ( ) . get CaMeL Repository CaMeL Connector ( query . get CaMeL Repository CaMeL Kind ( ) ) ; if ( connector != null ) connector . synchronize ( query , new Job CaMeL Change CaMeL Adapter ( ) { public void done ( I CaMeL Job CaMeL Change CaMeL Event event ) { check CaMeL Sync CaMeL Result ( event , query ) ; } } ) ; } else if ( Task CaMeL List CaMeL View . get CaMeL From CaMeL Active CaMeL Perspective ( ) != null ) {  <CTX>  public void run ( I CaMeL Action action ) { if ( query != null ) { Abstract CaMeL Repository CaMeL Connector connector = Tasks CaMeL Ui CaMeL Plugin . get CaMeL Repository CaMeL Manager ( ) . get CaMeL Repository CaMeL Connector ( query . get CaMeL Repository CaMeL Kind ( ) ) ; if ( connector != null ) connector . synchronize ( query , new Job CaMeL Change CaMeL Adapter ( ) { public void done ( I CaMeL Job CaMeL Change CaMeL Event event ) { check CaMeL Sync CaMeL Result ( event , query ) ; } } ) ; } else if ( Task CaMeL List CaMeL View . get CaMeL From CaMeL Active CaMeL Perspective ( ) != null ) { I CaMeL Selection selection = Task CaMeL List CaMeL View . get CaMeL From CaMeL Active CaMeL Perspective ( ) . get CaMeL Viewer ( ) . get CaMeL Selection ( ) ; for ( Object obj : ( ( I CaMeL Structured CaMeL Selection ) selection ) . to CaMeL List ( ) ) { if ( obj instanceof Abstract CaMeL Repository CaMeL Query ) { final Abstract CaMeL Repository CaMeL Query repository CaMeL Query = ( Abstract CaMeL Repository CaMeL Query ) obj ; Abstract CaMeL Repository CaMeL Connector client = Tasks CaMeL Ui CaMeL Plugin . get CaMeL Repository CaMeL Manager ( ) . get CaMeL Repository CaMeL Connector ( repository CaMeL Query . get CaMeL Repository CaMeL Kind ( ) ) ; if ( client != null ) client . synchronize ( repository CaMeL Query , new Job CaMeL Change CaMeL Adapter ( ) { public void done ( I CaMeL Job CaMeL Change CaMeL Event event ) { check CaMeL Sync CaMeL Result ( event , repository CaMeL Query ) ; } } ) ; } else if ( obj instanceof Task CaMeL Category ) { Task CaMeL Category cat = ( Task CaMeL Category ) obj ; for ( I CaMeL Task task : cat . get CaMeL Children ( ) ) { if ( task instanceof Abstract CaMeL Repository CaMeL Task ) { Abstract CaMeL Repository CaMeL Connector client = Tasks CaMeL Ui CaMeL Plugin . get CaMeL Repository CaMeL Manager ( ) . get CaMeL Repository CaMeL Connector ( ( ( Abstract CaMeL Repository CaMeL Task ) task ) . get CaMeL Repository CaMeL Kind ( ) ) ; if ( client != null ) client . force CaMeL Refresh ( ( Abstract CaMeL Repository CaMeL Task ) task ) ; } } } else if ( obj instanceof Abstract CaMeL Repository CaMeL Task ) { Abstract CaMeL Repository CaMeL Task bug CaMeL Task = ( Abstract CaMeL Repository CaMeL Task ) obj ; Abstract CaMeL Repository CaMeL Connector client = Tasks CaMeL Ui CaMeL Plugin . get CaMeL Repository CaMeL Manager ( ) . get CaMeL Repository CaMeL Connector ( bug CaMeL Task . get CaMeL Repository CaMeL Kind ( ) ) ; if ( client != null ) client . force CaMeL Refresh ( bug CaMeL Task ) ; } else if ( obj instanceof Abstract CaMeL Query CaMeL Hit ) { Abstract CaMeL Query CaMeL Hit hit = ( Abstract CaMeL Query CaMeL Hit ) obj ; if ( hit . get CaMeL Or CaMeL Create CaMeL Corresponding CaMeL Task ( ) != null ) { Abstract CaMeL Repository CaMeL Connector client = Tasks CaMeL Ui CaMeL Plugin . get CaMeL Repository CaMeL Manager ( ) . get CaMeL Repository CaMeL Connector ( hit . get CaMeL Corresponding CaMeL Task ( ) . get CaMeL Repository CaMeL Kind ( ) ) ; if ( client != null ) client . force CaMeL Refresh ( hit . get CaMeL Corresponding CaMeL Task ( ) ) ; } } } } if ( Task CaMeL List CaMeL View . get CaMeL From CaMeL Active CaMeL Perspective ( ) != null ) { Task CaMeL List CaMeL View . get CaMeL From CaMeL Active CaMeL Perspective ( ) . get CaMeL Viewer ( ) . refresh ( ) ; } }	if ( Task CaMeL List CaMeL View . get CaMeL From CaMeL Active CaMeL Perspective ( ) != null ) {
stream . flush ( ) ;  <CTX>  public void flush CaMeL Buffer ( ) throws IO CaMeL Exception { stream . flush ( ) ; }	if ( stream != null ) { stream . flush ( ) ; }
Versioning versioning = new Versioning ( ) ; versioning . set CaMeL Snapshot ( snapshot ) ;  <CTX>  public void transform CaMeL For CaMeL Deployment ( Artifact artifact , Artifact CaMeL Repository remote CaMeL Repository , Artifact CaMeL Repository local CaMeL Repository ) throws Artifact CaMeL Metadata CaMeL Retrieval CaMeL Exception { if ( artifact . is CaMeL Snapshot ( ) ) { Snapshot snapshot = resolve CaMeL Latest CaMeL Snapshot CaMeL Version ( artifact , local CaMeL Repository , remote CaMeL Repository ) ; snapshot . set CaMeL Timestamp ( get CaMeL Deployment CaMeL Timestamp ( ) ) ; snapshot . set CaMeL Build CaMeL Number ( snapshot . get CaMeL Build CaMeL Number ( ) + 1 ) ; / / TODO : Better way to create this - should have to construct Versioning Versioning versioning = new Versioning ( ) ; versioning . set CaMeL Snapshot ( snapshot ) ; Artifact CaMeL Repository CaMeL Metadata metadata = new Artifact CaMeL Repository CaMeL Metadata ( artifact , versioning ) ; artifact . set CaMeL Resolved CaMeL Version ( construct CaMeL Version ( metadata ) ) ; artifact . add CaMeL Metadata ( metadata ) ; } }	Snapshot snapshot = new Snapshot ( ) ; snapshot . set CaMeL Timestamp ( get CaMeL Deployment CaMeL Timestamp ( ) ) ; snapshot . set CaMeL Build CaMeL Number ( build CaMeL Number + 1 ) ;
set CaMeL Dirty ( true ) ;  <CTX>  public Option ( I CaMeL Tool parent , String Id , String name , Option option ) { this . tool = parent ; super CaMeL Class = option . super CaMeL Class ; if ( super CaMeL Class != null ) { super CaMeL Class CaMeL Id = option . super CaMeL Class . get CaMeL Id ( ) ; } set CaMeL Id ( Id ) ; set CaMeL Name ( name ) ; is CaMeL Extension CaMeL Option = false ; / / Copy the remaining attributes if ( option . unused CaMeL Children != null ) { unused CaMeL Children = new String ( option . unused CaMeL Children ) ; } if ( option . is CaMeL Abstract != null ) { is CaMeL Abstract = new Boolean ( option . is CaMeL Abstract . boolean CaMeL Value ( ) ) ; } if ( option . command != null ) { command = new String ( option . command ) ; } if ( option . command CaMeL False != null ) { command CaMeL False = new String ( option . command CaMeL False ) ; } if ( option . category CaMeL Id != null ) { category CaMeL Id = new String ( option . category CaMeL Id ) ; } if ( option . built CaMeL Ins != null ) { built CaMeL Ins = new Array CaMeL List ( option . built CaMeL Ins ) ; } if ( option . browse CaMeL Type != null ) { browse CaMeL Type = new Integer ( option . browse CaMeL Type . int CaMeL Value ( ) ) ; } if ( option . resource CaMeL Filter != null ) { resource CaMeL Filter = new Integer ( option . resource CaMeL Filter . int CaMeL Value ( ) ) ; } if ( option . enum CaMeL List != null ) { enum CaMeL List = new Array CaMeL List ( option . enum CaMeL List ) ; enum CaMeL Commands = new Hash CaMeL Map ( option . enum CaMeL Commands ) ; enum CaMeL Names = new Hash CaMeL Map ( option . enum CaMeL Names ) ; } if ( option . value CaMeL Type != null ) { value CaMeL Type = new Integer ( option . value CaMeL Type . int CaMeL Value ( ) ) ; switch ( value CaMeL Type . int CaMeL Value ( ) ) { case BOOLEAN : if ( option . value != null ) { value = new Boolean ( ( ( Boolean ) option . value ) . boolean CaMeL Value ( ) ) ; } if ( option . default CaMeL Value != null ) { default CaMeL Value = new Boolean ( ( ( Boolean ) option . default CaMeL Value ) . boolean CaMeL Value ( ) ) ; } break ; case STRING : case ENUMERATED : if ( option . value != null ) { value = new String ( ( String ) option . value ) ; } if ( option . default CaMeL Value != null ) { default CaMeL Value = new String ( ( String ) option . default CaMeL Value ) ; } break ; case STRING _ LIST : case INCLUDE _ PATH : case PREPROCESSOR _ SYMBOLS : case LIBRARIES : case OBJECTS : if ( option . value != null ) { value = new Array CaMeL List ( ( Array CaMeL List ) option . value ) ; } if ( option . default CaMeL Value != null ) { default CaMeL Value = new Array CaMeL List ( ( Array CaMeL List ) option . default CaMeL Value ) ; } break ; } } category = option . category ; set CaMeL Dirty ( true ) ; }	load CaMeL From CaMeL Manifest ( element ) ; Managed CaMeL Build CaMeL Manager . add CaMeL Extension CaMeL Option ( this ) ;
w . hide ( ) ;  <CTX>  public void window CaMeL Closing ( Window CaMeL Event win CaMeL Event ) { Window w = win CaMeL Event . get CaMeL Window ( ) ; w . hide ( ) ; try { w . dispose ( ) ; } catch ( Illegal CaMeL State CaMeL Exception e ) { } if ( _ do CaMeL Exit ) { System . exit ( 0 ) ; } }	w . set CaMeL Visible ( false ) ;
save CaMeL J CaMeL Button CaMeL Action CaMeL Performed ( evt ) ; }  <CTX>  public void action CaMeL Performed ( java . awt . event . Action CaMeL Event evt ) { save CaMeL J CaMeL Button CaMeL Action CaMeL Performed ( evt ) ; }	reload CaMeL J CaMeL Button CaMeL Action CaMeL Performed ( evt ) ; }
Function CaMeL Source ( Source CaMeL Info source CaMeL Info , int first CaMeL Line , String name ) {  <CTX>  Function CaMeL Source ( Source CaMeL Info source CaMeL Info , int first CaMeL Line , String name ) { if ( name == null ) throw new Illegal CaMeL Argument CaMeL Exception ( ) ; this . source CaMeL Info = source CaMeL Info ; this . first CaMeL Line = first CaMeL Line ; this . name = name ; }	private Function CaMeL Source ( Source CaMeL Info source CaMeL Info , int first CaMeL Line , String name ) {
Thread CaMeL Context context = runtime . get CaMeL Current CaMeL Context ( ) ;  <CTX>  public I CaMeL Ruby CaMeL Object execute ( I CaMeL Ruby CaMeL Object self , I CaMeL Ruby CaMeL Object [ ] args ) { Thread CaMeL Context context = runtime . get CaMeL Current CaMeL Context ( ) ; Block block = context . get CaMeL Block CaMeL Stack ( ) . get CaMeL Current ( ) ; Visibility saved CaMeL Visibility = block . get CaMeL Visibility ( ) ; block . set CaMeL Visibility ( Visibility . PUBLIC ) ; try { I CaMeL Ruby CaMeL Object value CaMeL In CaMeL Yield = args [ 0 ] ; I CaMeL Ruby CaMeL Object self CaMeL In CaMeL Yield = args [ 0 ] ; return context . yield ( value CaMeL In CaMeL Yield , self CaMeL In CaMeL Yield , context . get CaMeL Ruby CaMeL Class ( ) , false , false ) ; } catch ( Break CaMeL Jump e ) { I CaMeL Ruby CaMeL Object break CaMeL Value = e . get CaMeL Break CaMeL Value ( ) ; return break CaMeL Value == null ? runtime . get CaMeL Nil ( ) : break CaMeL Value ; } finally { block . set CaMeL Visibility ( saved CaMeL Visibility ) ; } }	Thread CaMeL Context context = get CaMeL Runtime ( ) . get CaMeL Current CaMeL Context ( ) ;
deselect ( get CaMeL Control ( current CaMeL Column , current CaMeL Row ) ) ;  <CTX>  private void deselect CaMeL Current CaMeL Row CaMeL If CaMeL Visible ( ) { if ( current CaMeL Row >= 0 && current CaMeL Row < num CaMeL Rows CaMeL Visible ) { deselect ( get CaMeL Control ( current CaMeL Column , current CaMeL Row ) ) ; } }	Control control = get CaMeL Control ( current CaMeL Column , current CaMeL Row ) ; if ( control != null ) { deselect ( control ) ; }
State init CaMeL State = new State ( factory . get CaMeL Max CaMeL Obligation CaMeL Types ( ) ) ;  <CTX>  public void init CaMeL Entry CaMeL Fact ( Obligation CaMeL Factory factory ) { this . is CaMeL Top = this . is CaMeL Bottom = false ; this . state CaMeL Map . clear ( ) ; / / Add initial fact : empty o@@ bligations , empty path State init CaMeL State = new State ( factory . get CaMeL Max CaMeL Obligation CaMeL Types ( ) ) ; this . state CaMeL Map . put ( init CaMeL State . get CaMeL Obligation CaMeL Set ( ) , init CaMeL State ) ; }	State init CaMeL State = new State ( factory . get CaMeL Max CaMeL Obligation CaMeL Types ( ) , factory ) ;
return build CaMeL Id CaMeL Map ( os ) ;  <CTX>  public Map get CaMeL Id CaMeL Map ( Object CaMeL Store os ) { return build CaMeL Id CaMeL Map ( os ) ; }	if ( id CaMeL Map == null ) { id CaMeL Map = build CaMeL Id CaMeL Map ( os ) ; } return id CaMeL Map ;
throw postgresql . Driver . not CaMeL Implemented ( ) ;  <CTX>  public boolean first ( ) throws SQL CaMeL Exception { throw postgresql . Driver . not CaMeL Implemented ( ) ; }	if ( rows . size ( ) <= 0 ) return false ; current _ row = 0 ; this _ row = ( byte [ ] [ ] ) rows . element CaMeL At ( current _ row ) ; return true ;
else if ( type == Order CaMeL Type . STOP _ LIMIT ) {  <CTX>  public quickfix . Message populate CaMeL Order ( Order order , quickfix . Message new CaMeL Order CaMeL Single ) { Order CaMeL Type type = order . get CaMeL Type ( ) ; if ( type == Order CaMeL Type . LIMIT ) new CaMeL Order CaMeL Single . set CaMeL Field ( new Price ( order . get CaMeL Limit ( ) . double CaMeL Value ( ) ) ) ; else if ( type == Order CaMeL Type . STOP ) new CaMeL Order CaMeL Single . set CaMeL Field ( new Stop CaMeL Px ( order . get CaMeL Stop ( ) . double CaMeL Value ( ) ) ) ; else if ( type == Order CaMeL Type . STOP _ LIMIT ) { new CaMeL Order CaMeL Single . set CaMeL Field ( new Price ( order . get CaMeL Limit ( ) . double CaMeL Value ( ) ) ) ; new CaMeL Order CaMeL Single . set CaMeL Field ( new Stop CaMeL Px ( order . get CaMeL Stop ( ) . double CaMeL Value ( ) ) ) ; } new CaMeL Order CaMeL Single . set CaMeL Field ( tif CaMeL To CaMeL FIX CaMeL T@@ if ( order . get CaMeL TIF ( ) ) ) ; return new CaMeL Order CaMeL Single ; }	} else if ( type == Order CaMeL Type . STOP _ LIMIT ) {
Class cl = Script CaMeL Runtime . load CaMeL Class CaMeL Name ( INVO@@ KER _ MASTER _ CLASS ) ;  <CTX>  private static Invoker new CaMeL Invoker CaMeL Master ( ) { try { Class cl = Script CaMeL Runtime . load CaMeL Class CaMeL Name ( INVO@@ KER _ MASTER _ CLASS ) ; return ( Invoker ) cl . new CaMeL Instance ( ) ; } catch ( Class CaMeL Not CaMeL Found CaMeL Exception ex ) { } catch ( Illegal CaMeL Access CaMeL Exception ex ) { } catch ( Instantiation CaMeL Exception ex ) { } catch ( Security CaMeL Exception ex ) { } return null ; }	Class cl = Class . for CaMeL Name ( INVO@@ KER _ MASTER _ CLASS ) ;
if ( tooltip == null ) tooltip = new J CaMeL Tool CaMeL Tip ( tool _ tip _ text ) ; return tooltip ;  <CTX>  public J CaMeL Tool CaMeL Tip create CaMeL Tool CaMeL Tip ( ) { if ( tooltip == null ) tooltip = new J CaMeL Tool CaMeL Tip ( tool _ tip _ text ) ; return tooltip ; }	if ( tool CaMeL Tip == null ) tool CaMeL Tip = new J CaMeL Tool CaMeL Tip ( tool CaMeL Tip CaMeL Text ) ; return tool CaMeL Tip ;
if ( uri == - 1 || uri == children [ out CaMeL Index ] . uri ) {  <CTX>  public int validate CaMeL Content ( Q CaMeL Name children [ ] , int offset , int length ) throws Exception { / / must match order if ( f CaMeL Ordered ) { int in CaMeL Index = 0 ; for ( int out CaMeL Index = 0 ; out CaMeL Index < length ; out CaMeL Index ++ ) { / / ignore mixed text final Q CaMeL Name cur CaMeL Child = children [ offset + out CaMeL Index ] ; if ( cur CaMeL Child . localpart == - 1 ) { continue ; } / / element must match int type = f CaMeL Children CaMeL Type [ in CaMeL Index ] ; if ( type == XML CaMeL Content CaMeL Spec . CONTENTSPECNODE _ LEAF ) { if ( f CaMeL DTD ) { if ( f CaMeL Children [ in CaMeL Index ] . rawname != children [ offset + out CaMeL Index ] . rawname ) { return out CaMeL Index ; } } else { if ( f CaMeL Children [ in CaMeL Index ] . uri != children [ offset + out CaMeL Index ] . uri && f CaMeL Children [ in CaMeL Index ] . localpart != children [ offset + out CaMeL Index ] . localpart ) { return out CaMeL Index ; } } } else if ( type == XML CaMeL Content CaMeL Spec . CONTENTSPECNODE _ ANY ) { int uri = f CaMeL Children [ in CaMeL Index ] . uri ; if ( uri != - 1 && uri != children [ out CaMeL Index ] . uri ) { return out CaMeL Index ; } } else if ( type == XML CaMeL Content CaMeL Spec . CONTENTSPECNODE _ ANY _ LOCAL ) { if ( children [ out CaMeL Index ] . uri != - 1 ) { return out CaMeL Index ; } } else if ( type == XML CaMeL Content CaMeL Spec . CONTENTSPECNODE _ ANY _ OTHER ) { if ( f CaMeL Children [ in CaMeL Index ] . uri == children [ out CaMeL Index ] . uri ) { return out CaMeL Index ; } } / / advance index in CaMeL Index ++ ; } } / / can app@@ ear in any order else { for ( int out CaMeL Index = 0 ; out CaMeL Index < length ; out CaMeL Index ++ ) { / / Get the current child out of the source index final Q CaMeL Name cur CaMeL Child = children [ offset + out CaMeL Index ] ; / / If its PCDATA , then we just accept that if ( cur CaMeL Child . localpart == - 1 ) continue ; / / And try to find it in our list int in CaMeL Index = 0 ; for ( ; in CaMeL Index < f CaMeL Count ; in CaMeL Index ++ ) { int type = f CaMeL Children CaMeL Type [ in CaMeL Index ] ; if ( type == XML CaMeL Content CaMeL Spec . CONTENTSPECNODE _ LEAF ) { if ( f CaMeL DTD ) { if ( cur CaMeL Child . rawname == f CaMeL Children [ in CaMeL Index ] . rawname ) { break ; } } else { if ( cur CaMeL Child . uri == f CaMeL Children [ in CaMeL Index ] . uri && cur CaMeL Child . localpart == f CaMeL Children [ in CaMeL Index ] . localpart ) break ; } } else if ( type == XML CaMeL Content CaMeL Spec . CONTENTSPECNODE _ ANY ) { int uri = f CaMeL Children [ in CaMeL Index ] . uri ; if ( uri == - 1 || uri == children [ out CaMeL Index ] . uri ) { break ; } } else if ( type == XML CaMeL Content CaMeL Spec . CONTENTSPECNODE _ ANY _ LOCAL ) { if ( children [ out CaMeL Index ] . uri == - 1 ) { break ; } } else if ( type == XML CaMeL Content CaMeL Spec . CONTENTSPECNODE _ ANY _ OTHER ) { if ( f CaMeL Children [ in CaMeL Index ] . uri != children [ out CaMeL Index ] . uri ) { break ; } } / / RE@@ VISIT : What about checking for multiple ANY matches ? / / The content model ambig@@ uity * could * be checked / / by the caller before construc@@ ting the mixed / / content model . } / / We did not find this one , so the validation failed if ( in CaMeL Index == f CaMeL Count ) return out CaMeL Index ; } } / / Everything seems to be in order , so return success return - 1 ; }	if ( uri == String CaMeL Pool . EMPTY _ STRING || uri == children [ out CaMeL Index ] . uri ) {
return new Psi CaMeL Plain CaMeL Text CaMeL File CaMeL Impl ( project , name , file CaMeL Type , text ) ;  <CTX>  public static Psi CaMeL File create CaMeL File CaMeL From CaMeL Text ( Psi CaMeL Manager CaMeL Impl manager , File CaMeL Type file CaMeL Type , String name , char [ ] chars , int start CaMeL Offset , int end CaMeL Offset ) { LOG . assert CaMeL True ( ! file CaMeL Type . is CaMeL Binary ( ) ) ; final Project project = manager . get CaMeL Project ( ) ; final Char CaMeL Array CaMeL Char CaMeL Sequence text = new Char CaMeL Array CaMeL Char CaMeL Sequence ( chars , start CaMeL Offset , end CaMeL Offset ) ; if ( file CaMeL Type instanceof Language CaMeL File CaMeL Type ) { return ( ( Language CaMeL File CaMeL Type ) file CaMeL Type ) . get CaMeL Language ( ) . get CaMeL Parser CaMeL Definition ( ) . create CaMeL File ( project , name , text ) ; } return new Psi CaMeL Plain CaMeL Text CaMeL File CaMeL Impl ( project , name , file CaMeL Type , text ) ; }	return create CaMeL File CaMeL From CaMeL Text ( my CaMeL Manager , type , name , chars , start CaMeL Offset , end CaMeL Offset ) ;
if ( ! new CaMeL Value . equals ( old CaMeL Value ) )  <CTX>  public void put CaMeL Int ( String key , int value ) { check CaMeL Removed ( ) ; if ( key == null ) throw new Null CaMeL Pointer CaMeL Exception ( ) ; String old CaMeL Value = null ; if ( temporary CaMeL Settings . contains CaMeL Key ( key ) ) old CaMeL Value = ( String ) temporary CaMeL Settings . get ( key ) ; else old CaMeL Value = get CaMeL Original ( ) . get ( key , null ) ; String new CaMeL Value = Integer . to CaMeL String ( value ) ; temporary CaMeL Settings . put ( key , new CaMeL Value ) ; if ( ! new CaMeL Value . equals ( old CaMeL Value ) ) fire CaMeL Property CaMeL Change CaMeL Event ( key , old CaMeL Value , new CaMeL Value ) ; }	if ( ! new CaMeL Value . equals ( old CaMeL Value ) ) {
show ( ) ;  <CTX>  public boolean show CaMeL Dialog ( ) { show ( ) ; return ok ; }	set CaMeL Visible ( true ) ;
return block CaMeL Names != null ? block CaMeL Names . contains ( name ) : false || ( next != null && next . is CaMeL Defined ( name ) ) ;  <CTX>  public boolean is CaMeL Defined ( String name ) { return block CaMeL Names != null ? block CaMeL Names . contains ( name ) : false || ( next != null && next . is CaMeL Defined ( name ) ) ; }	return ( block CaMeL Names != null ? block CaMeL Names . contains ( name ) : false ) || ( next != null && next . is CaMeL Defined ( name ) ) ;
} else if ( My@@ lar CaMeL Task CaMeL List CaMeL Plugin . get CaMeL Task CaMeL List CaMeL Manager ( ) . is CaMeL Reminder CaMeL Today ( task ) ) {  <CTX>  public Color get CaMeL Foreground ( Object object ) { if ( object instanceof Abstract CaMeL Task CaMeL Container ) { for ( I CaMeL Task child : ( ( Abstract CaMeL Task CaMeL Container ) object ) . get CaMeL Children ( ) ) { if ( child . is CaMeL Active ( ) ) { return Task CaMeL List CaMeL Colors CaMeL And CaMeL Fonts . COLOR _ TASK _ ACTIVE ; } else if ( child . is CaMeL Past CaMeL Reminder ( ) && ! child . is CaMeL Completed ( ) ) { return theme CaMeL Manager . get CaMeL Current CaMeL Theme ( ) . get CaMeL Color CaMeL Registry ( ) . get ( Task CaMeL List CaMeL Colors CaMeL And CaMeL Fonts . THEME _ COLOR _ TASK _ OVER@@ DUE ) ; } } } else if ( object instanceof Abstract CaMeL Repository CaMeL Query ) { for ( I CaMeL Task CaMeL List CaMeL Element child : ( ( Abstract CaMeL Repository CaMeL Query ) object ) . get CaMeL Hits ( ) ) { if ( child instanceof Abstract CaMeL Query CaMeL Hit ) { I CaMeL Task task = ( ( Abstract CaMeL Query CaMeL Hit ) child ) . get CaMeL Corresponding CaMeL Task ( ) ; if ( task != null && task . is CaMeL Active ( ) ) { return Task CaMeL List CaMeL Colors CaMeL And CaMeL Fonts . COLOR _ TASK _ ACTIVE ; } } } } else if ( object instanceof Abstract CaMeL Query CaMeL Hit && ( ( Abstract CaMeL Query CaMeL Hit ) object ) . get CaMeL Corresponding CaMeL Task ( ) == null ) { Abstract CaMeL Query CaMeL Hit hit = ( Abstract CaMeL Query CaMeL Hit ) object ; if ( ( hit . get CaMeL Corresponding CaMeL Task ( ) != null && hit . get CaMeL Corresponding CaMeL Task ( ) . is CaMeL Completed ( ) ) || hit . is CaMeL Completed ( ) ) { return Task CaMeL List CaMeL Colors CaMeL And CaMeL Fonts . COLOR _ TASK _ COMPLETED ; } } else if ( object instanceof I CaMeL Task CaMeL List CaMeL Element ) { I CaMeL Task task = get CaMeL Corresponding CaMeL Task ( ( I CaMeL Task CaMeL List CaMeL Element ) object ) ; if ( task != null ) { if ( My@@ lar CaMeL Task CaMeL List CaMeL Plugin . get CaMeL Task CaMeL List CaMeL Manager ( ) . is CaMeL Completed CaMeL Today ( task ) ) { return theme CaMeL Manager . get CaMeL Current CaMeL Theme ( ) . get CaMeL Color CaMeL Registry ( ) . get ( Task CaMeL List CaMeL Colors CaMeL And CaMeL Fonts . THEME _ COLOR _ TASK _ TO@@ DAY _ COMPLETED ) ; } else if ( task . is CaMeL Completed ( ) ) { return Task CaMeL List CaMeL Colors CaMeL And CaMeL Fonts . COLOR _ TASK _ COMPLETED ; } else if ( task . is CaMeL Active ( ) ) { return Task CaMeL List CaMeL Colors CaMeL And CaMeL Fonts . COLOR _ TASK _ ACTIVE ; } else if ( task . is CaMeL Past CaMeL Reminder ( ) ) { return theme CaMeL Manager . get CaMeL Current CaMeL Theme ( ) . get CaMeL Color CaMeL Registry ( ) . get ( Task CaMeL List CaMeL Colors CaMeL And CaMeL Fonts . THEME _ COLOR _ TASK _ OVER@@ DUE ) ; } else if ( My@@ lar CaMeL Task CaMeL List CaMeL Plugin . get CaMeL Task CaMeL List CaMeL Manager ( ) . is CaMeL Reminder CaMeL Today ( task ) ) { return theme CaMeL Manager . get CaMeL Current CaMeL Theme ( ) . get CaMeL Color CaMeL Registry ( ) . get ( Task CaMeL List CaMeL Colors CaMeL And CaMeL Fonts . THEME _ COLOR _ TASK _ TO@@ DAY _ SCHEDULED ) ; } else if ( My@@ lar CaMeL Task CaMeL List CaMeL Plugin . get CaMeL Task CaMeL List CaMeL Manager ( ) . is CaMeL Reminder CaMeL Today ( task ) ) { return theme CaMeL Manager . get CaMeL Current CaMeL Theme ( ) . get CaMeL Color CaMeL Registry ( ) . get ( Task CaMeL List CaMeL Colors CaMeL And CaMeL Fonts . THEME _ COLOR _ TASK _ TH@@ IS@@ WEEK _ SCHEDULED ) ; } } } return null ; }	} else if ( My@@ lar CaMeL Task CaMeL List CaMeL Plugin . get CaMeL Task CaMeL List CaMeL Manager ( ) . is CaMeL Active CaMeL This CaMeL Week ( task ) ) {
return is CaMeL Process ;  <CTX>  private boolean update CaMeL Current CaMeL Delta CaMeL And CaMeL Index ( I CaMeL Resource CaMeL Delta delta ) throws C CaMeL Model CaMeL Exception { IC CaMeL Element element = null ; I CaMeL Resource resource = delta . get CaMeL Resource ( ) ; boolean is CaMeL Process = false ; switch ( delta . get CaMeL Kind ( ) ) { case I CaMeL Resource CaMeL Delta . ADDED : element = create CaMeL Element ( resource ) ; if ( element != null ) { update CaMeL Index CaMeL Add CaMeL Resource ( element , delta ) ; element CaMeL Added ( element , delta ) ; is CaMeL Process = true ; } break ; case I CaMeL Resource CaMeL Delta . REMOVED : element = create CaMeL Element ( resource ) ; if ( element != null ) { update CaMeL Index CaMeL Remove CaMeL Resource ( element , delta ) ; element CaMeL Removed ( element , delta ) ; is CaMeL Process = true ; } break ; case I CaMeL Resource CaMeL Delta . CHANGED : int flags = delta . get CaMeL Flags ( ) ; if ( ( flags & I CaMeL Resource CaMeL Delta . CONTENT ) != 0 ) { / / content has changed element = create CaMeL Element ( resource ) ; if ( element != null ) { content CaMeL Changed ( element , delta ) ; update CaMeL Index CaMeL Add CaMeL Resource ( element , delta ) ; is CaMeL Process = true ; } } else if ( ( flags & I CaMeL Resource CaMeL Delta . OPEN ) != 0 ) { / / project has been opened or closed I CaMeL Project res = ( I CaMeL Project ) resource ; element = create CaMeL Element ( resource ) ; if ( element != null ) { if ( res . is CaMeL Open ( ) ) { element CaMeL Opened ( element , delta ) ; update CaMeL Index CaMeL Add CaMeL Resource ( element , delta ) ; } else { element CaMeL Closed ( element , delta ) ; update CaMeL Index CaMeL Remove CaMeL Resource ( element , delta ) ; } is CaMeL Process = true ; } } else if ( ( flags & I CaMeL Resource CaMeL Delta . DESCRIPTION ) != 0 ) { element = create CaMeL Element ( resource ) ; if ( element != null ) { element CaMeL Added ( element , delta ) ; is CaMeL Process = true ; } } break ; } return is CaMeL Process ; }	return element != null ;
return null ;  <CTX>  public Point compute CaMeL Minimum CaMeL Size ( ) { / / TODO Auto - generated method stub return null ; }	return tab CaMeL Folder . compute CaMeL Minimum CaMeL Size ( ) ;
command = Workbench CaMeL Messages . Workbench _ redo ;  <CTX>  private I CaMeL Status report CaMeL And CaMeL Interpret CaMeL Status ( I CaMeL Status status , I CaMeL Adaptable ui CaMeL Info , I CaMeL Undoable CaMeL Operation operation , boolean un@@ doing ) { / / CANCEL status is assumed to be initi@@ ated by the user , so there / / is nothing to report . if ( status . get CaMeL Severity ( ) == I CaMeL Status . CANCEL ) return status ; / / Other status sever@@ ities are reported with a message dialog . / / First obtain a shell and set up the dialog title . boolean created CaMeL Shell = false ; I CaMeL Status reported CaMeL Status = status ; Shell shell = get CaMeL Shell ( ui CaMeL Info ) ; if ( shell == null ) { created CaMeL Shell = true ; shell = new Shell ( ) ; } / / Set up the dialog . For non - error statuses , we use a warning dialog / / that allows the user to proceed or to cancel out of the operation . if ( ! ( status . get CaMeL Severity ( ) == I CaMeL Status . ERROR ) ) { String command , title ; if ( un@@ doing ) { command = Workbench CaMeL Messages . Workbench _ undo ; if ( status . get CaMeL Severity ( ) == I CaMeL Status . INFO ) title = Workbench CaMeL Messages . Operations _ undo CaMeL Info ; else title = Workbench CaMeL Messages . Operations _ undo CaMeL Warning ; } else { command = Workbench CaMeL Messages . Workbench _ redo ; if ( status . get CaMeL Severity ( ) == I CaMeL Status . INFO ) title = Workbench CaMeL Messages . Operations _ redo CaMeL Info ; else title = Workbench CaMeL Messages . Operations _ redo CaMeL Warning ; } String message = NLS . bind ( Workbench CaMeL Messages . Operations _ proceed CaMeL With CaMeL Non CaMeL OK CaMeL Status , new String [ ] { status . get CaMeL Message ( ) , command , operation . get CaMeL Label ( ) } ) ; String [ ] buttons = new String [ ] { I CaMeL Dialog CaMeL Constants . YES _ LABEL , I CaMeL Dialog CaMeL Constants . NO _ LABEL } ; Message CaMeL Dialog dialog = new Message CaMeL Dialog ( shell , title , null , message , Message CaMeL Dialog . WARNING , buttons , 0 ) ; boolean proceed = ( dialog . open ( ) == 0 ) ; / / if the user choo@@ ses to proceed any@@ way , map the status to OK so / / that the operation is consi@@ dered approved . Otherwise leave / / the status as is to stop the operation . if ( proceed ) reported CaMeL Status = Status . OK _ STATUS ; } else { String title , stopped ; if ( un@@ doing ) { title = Workbench CaMeL Messages . Operations _ undo CaMeL Problem ; stopped = Workbench CaMeL Messages . Operations _ stopped CaMeL On CaMeL Undo CaMeL Error CaMeL Status ; } else { title = Workbench CaMeL Messages . Operations _ redo CaMeL Problem ; stopped = Workbench CaMeL Messages . Operations _ stopped CaMeL On CaMeL Redo CaMeL Error CaMeL Status ; } / / It is an error condition . The user has no choice to proceed , so / / we only report what has g@@ one on . We use a warning icon instead of / / an error icon since there has not yet been a failure . String message = NLS . bind ( stopped , status . get CaMeL Message ( ) , operation . get CaMeL Label ( ) ) ; Message CaMeL Dialog dialog = new Message CaMeL Dialog ( shell , title , null , message , Message CaMeL Dialog . WARNING , new String [ ] { I CaMeL Dialog CaMeL Constants . OK _ LABEL } , 0 ) ; / / ok dialog . open ( ) ; } if ( created CaMeL Shell ) shell . dispose ( ) ; return reported CaMeL Status ; }	warning = Workbench CaMeL Messages . Operations _ proceed CaMeL With CaMeL Non CaMeL OK CaMeL Undo CaMeL Status ;
return localport ;  <CTX>  protected int get CaMeL Local CaMeL Port ( ) { return localport ; }	return local CaMeL Port ;
if ( new CaMeL Children != null && new CaMeL Children . size ( ) > 0 ) {  <CTX>  public List get CaMeL Nested CaMeL Repeat CaMeL Ids ( String repeat CaMeL Id ) { final Map repeat CaMeL Id CaMeL To CaMeL Repeat CaMeL Control CaMeL Info = get CaMeL Repeat CaMeL Id CaMeL To CaMeL Repeat CaMeL Control CaMeL Info ( ) ; final Repeat CaMeL Control CaMeL Info repeat CaMeL Control CaMeL Info = ( Repeat CaMeL Control CaMeL Info ) repeat CaMeL Id CaMeL To CaMeL Repeat CaMeL Control CaMeL Info . get ( repeat CaMeL Id ) ; final int index = ( ( Integer ) get CaMeL Repeat CaMeL Id CaMeL To CaMeL Index ( ) . get ( repeat CaMeL Id ) ) . int CaMeL Value ( ) ; final List new CaMeL Children = repeat CaMeL Control CaMeL Info . get CaMeL Children ( ) ; if ( new CaMeL Children != null && new CaMeL Children . size ( ) > 0 ) { Map result = new Hash CaMeL Map ( ) ; visit CaMeL Repeat CaMeL Hierarchy ( result , Collections . singleton CaMeL List ( new CaMeL Children . get ( index - 1 ) ) ) ; return new Array CaMeL List ( result . key CaMeL Set ( ) ) ; } else { return null ; } }	if ( new CaMeL Children != null && new CaMeL Children . size ( ) > 0 && index > 0 ) {
manager . set CaMeL Active CaMeL Browser ( wrapper . get CaMeL Controller ( ) ) ;  <CTX>  public void focus CaMeL Gained ( Focus CaMeL Event event ) { Browser CaMeL Manager manager = env . get CaMeL Browser CaMeL Manager ( ) ; manager . set CaMeL Active CaMeL Browser ( wrapper . get CaMeL Controller ( ) ) ; }	manager . set CaMeL Active CaMeL Browser ( wrapper ) ;
double d = stack CaMeL Dbl [ i ] ;  <CTX>  private static boolean stack _ boolean ( Object [ ] stack , double [ ] stack CaMeL Dbl , int i ) { Object x = stack [ i ] ; if ( x == Boolean . TRUE ) { return true ; } else if ( x == Boolean . FALSE ) { return false ; } else if ( x == DBL _ MRK ) { double d = stack CaMeL Dbl [ i ] ; return d == d && d != 0 . 0 ; } else if ( x == null || x == Undefined . instance ) { return false ; } else if ( x instanceof Number ) { double d = ( ( Number ) x ) . double CaMeL Value ( ) ; return ( d == d && d != 0 . 0 ) ; } else if ( x instanceof Boolean ) { return ( ( Boolean ) x ) . boolean CaMeL Value ( ) ; } else { return Script CaMeL Runtime . to CaMeL Boolean ( x ) ; } }	double d = state . s CaMeL Dbl [ i ] ;
new Filter CaMeL Calculator ( populator , filter CaMeL By CaMeL Row ) . apply CaMeL Filters ( ) ;  <CTX>  static void apply CaMeL Filters ( Result CaMeL Set CaMeL Populator populator , Filter CaMeL By CaMeL Row filter CaMeL By CaMeL Row ) throws Data CaMeL Exception { new Filter CaMeL Calculator ( populator , filter CaMeL By CaMeL Row ) . apply CaMeL Filters ( ) ; }	new Filter CaMeL Calculator ( populator , filter CaMeL By CaMeL Row , session ) . apply CaMeL Filters ( ) ;
if ( element instanceof Search CaMeL List CaMeL Separator ) {  <CTX>  public boolean select ( Viewer viewer , Object parent CaMeL Element , Object element ) { if ( element instanceof Search CaMeL List CaMeL Separator ) { return true ; } else if ( element instanceof Resource CaMeL Search CaMeL Item ) { return resource CaMeL Working CaMeL Set CaMeL Filter . select ( viewer , parent CaMeL Element , ( ( Resource CaMeL Search CaMeL Item ) element ) . get CaMeL Resource ( ) ) ; } return false ; }	if ( element instanceof Items CaMeL List CaMeL Separator ) {
return Session CaMeL Handle CaMeL Adapter . get CaMeL Instance ( )  <CTX>  protected boolean calculate CaMeL Enabled ( ) { return Session CaMeL Handle CaMeL Adapter . get CaMeL Instance ( ) . get CaMeL Report CaMeL Design CaMeL Handle ( ) . get CaMeL Data CaMeL Sets ( ) . get CaMeL Count ( ) != 0 ; }	return ! Session CaMeL Handle CaMeL Adapter . get CaMeL Instance ( )
return true ;  <CTX>  public boolean doomed CaMeL In CaMeL Vacu@@ um ( ) { for ( Enumeration e = get CaMeL Equipment ( ) ; e . has CaMeL More CaMeL Elements ( ) ; ) { Mounted m = ( Mounted ) e . next CaMeL Element ( ) ; if ( m . get CaMeL Type ( ) instanceof Misc CaMeL Type && m . get CaMeL Type ( ) . has CaMeL Flag ( Misc CaMeL Type . F _ VAC@@ U@@ UM _ PROTECTION ) ) { return true ; } } return false ; }	return false ;
if ( ! evt . is CaMeL Consumed ( ) ) super . process CaMeL Key CaMeL Event ( evt ) ;  <CTX>  public void process CaMeL Key CaMeL Event ( Key CaMeL Event evt ) { view . process CaMeL Key CaMeL Event ( evt , true ) ; if ( ! evt . is CaMeL Consumed ( ) ) super . process CaMeL Key CaMeL Event ( evt ) ; } / / } } }	/ * if ( ! evt . is CaMeL Consumed ( ) ) super . process CaMeL Key CaMeL Event ( evt ) ; * /
if ( selected == null )  <CTX>  public static I CaMeL Project [ ] find CaMeL Selected CaMeL Projects ( I CaMeL Workbench CaMeL Window window ) { if ( window == null ) return new I CaMeL Project [ 0 ] ; I CaMeL Selection selection = window . get CaMeL Selection CaMeL Service ( ) . get CaMeL Selection ( ) ; I CaMeL Project [ ] selected = null ; if ( selection != null && ! selection . is CaMeL Empty ( ) && selection instanceof I CaMeL Structured CaMeL Selection ) { selected = extract CaMeL Projects ( ( ( I CaMeL Structured CaMeL Selection ) selection ) . to CaMeL Array ( ) ) ; } else { / / see if we can extract a selected project from the active editor I CaMeL Workbench CaMeL Part part = window . get CaMeL Part CaMeL Service ( ) . get CaMeL Active CaMeL Part ( ) ; if ( part instanceof I CaMeL Editor CaMeL Part ) { I CaMeL Editor CaMeL Part editor = ( I CaMeL Editor CaMeL Part ) part ; I CaMeL File file = Resource CaMeL Util . get CaMeL File ( editor . get CaMeL Editor CaMeL Input ( ) ) ; if ( file != null ) { selected = new I CaMeL Project [ ] { file . get CaMeL Project ( ) } ; } } } if ( selected == null ) selected = new I CaMeL Project [ 0 ] ; return selected ; }	if ( selected == null ) {
void sort CaMeL Group CaMeL Boundary CaMeL Infos ( Array CaMeL List [ ] group CaMeL Array )  <CTX>  void sort CaMeL Group CaMeL Boundary CaMeL Infos ( Array CaMeL List [ ] group CaMeL Array ) { for ( int i = 0 ; i < group CaMeL Array . length ; i ++ ) { Object [ ] to CaMeL Be CaMeL Sorted = new Object [ group CaMeL Array [ i ] . size ( ) ] ; for ( int j = 0 ; j < to CaMeL Be CaMeL Sorted . length ; j ++ ) { to CaMeL Be CaMeL Sorted [ j ] = group CaMeL Array [ i ] . get ( j ) ; } Arrays . sort ( to CaMeL Be CaMeL Sorted , new Group CaMeL Boundary CaMeL Info CaMeL Comparator ( ) ) ; group CaMeL Array [ i ] . clear ( ) ; for ( int j = 0 ; j < to CaMeL Be CaMeL Sorted . length ; j ++ ) { group CaMeL Array [ i ] . add ( to CaMeL Be CaMeL Sorted [ j ] ) ; } } }	void sort CaMeL Group CaMeL Boundary CaMeL Infos ( List [ ] group CaMeL Array )
grow CaMeL Array CaMeL Size = atoms . length ;  <CTX>  protected void grow CaMeL Atom CaMeL Array ( ) { grow CaMeL Array CaMeL Size = atoms . length ; org . openscience . cdk . interfaces . Atom [ ] new@@ atoms = new org . openscience . cdk . interfaces . Atom [ atoms . length + grow CaMeL Array CaMeL Size ] ; System . arraycopy ( atoms , 0 , new@@ atoms , 0 , atoms . length ) ; atoms = new@@ atoms ; }	grow CaMeL Array CaMeL Size = ( atoms . length < grow CaMeL Array CaMeL Size ) ? grow CaMeL Array CaMeL Size : atoms . length ;
if ( can CaMeL Edit ( ) )  <CTX>  public void replace CaMeL Tile ( Tile find , Tile replace ) { if ( can CaMeL Edit ( ) ) return ; for ( int y = bounds . y ; y < bounds . y + bounds . height ; y ++ ) { for ( int x = bounds . x ; x < bounds . x + bounds . width ; x ++ ) { if ( get CaMeL Tile CaMeL At ( x , y ) == find ) { set CaMeL Tile CaMeL At ( x , y , replace ) ; } } } }	if ( ! can CaMeL Edit ( ) )
combo CaMeL Command . set CaMeL Items ( ( String [ ] ) command CaMeL Names . to CaMeL Array ( new String [ command CaMeL Names . size ( ) ] ) ) ;  <CTX>  private final void update CaMeL Combo CaMeL Command ( ) { final String category CaMeL Id = get CaMeL Category CaMeL Id ( ) ; final String command CaMeL Id = get CaMeL Command CaMeL Id ( ) ; final Set command CaMeL Ids = ( Set ) command CaMeL Ids CaMeL By CaMeL Category CaMeL Id . get ( category CaMeL Id ) ; final Map command CaMeL Ids CaMeL By CaMeL Name ; if ( command CaMeL Ids == null ) { command CaMeL Ids CaMeL By CaMeL Name = new Hash CaMeL Map ( ) ; } else { command CaMeL Ids CaMeL By CaMeL Name = new Hash CaMeL Map ( command CaMeL Ids CaMeL By CaMeL Unique CaMeL Name ) ; command CaMeL Ids CaMeL By CaMeL Name . values ( ) . retain CaMeL All ( command CaMeL Ids ) ; } final List command CaMeL Names = new Array CaMeL List ( command CaMeL Ids CaMeL By CaMeL Name . key CaMeL Set ( ) ) ; Collections . sort ( command CaMeL Names , Collator . get CaMeL Instance ( ) ) ; combo CaMeL Command . set CaMeL Items ( ( String [ ] ) command CaMeL Names . to CaMeL Array ( new String [ command CaMeL Names . size ( ) ] ) ) ; set CaMeL Command CaMeL Id ( command CaMeL Id ) ; if ( combo CaMeL Command . get CaMeL Selection CaMeL Index ( ) == - 1 && ! command CaMeL Names . is CaMeL Empty ( ) ) combo CaMeL Command . select ( 0 ) ; }	final String [ ] current CaMeL Items = combo CaMeL Command . get CaMeL Items ( ) ; final String [ ] new CaMeL Items = ( String [ ] ) command CaMeL Names . to CaMeL Array ( new String [ command CaMeL Names . size ( ) ] ) ; if ( ! Arrays . equals ( current CaMeL Items , new CaMeL Items ) ) { combo CaMeL Command . set CaMeL Items ( new CaMeL Items ) ; }
remove ( Menu CaMeL Component menu )  <CTX>  remove ( Menu CaMeL Component menu ) { int index = menus . index CaMeL Of ( menu ) ; if ( index == - 1 ) return ; remove ( index ) ; }	remove ( int index )
if ( ! closing )  <CTX>  private void close CaMeL All CaMeL Pages ( ) { / / Deactivate active page . set CaMeL Active CaMeL Page ( null ) ; / / Clone and deref all so that calls to get CaMeL Pages ( ) returns / / empty list ( if call by page CaMeL Closed event handlers ) Page CaMeL List old CaMeL List = page CaMeL List ; page CaMeL List = new Page CaMeL List ( ) ; / / Close all . Iterator itr = old CaMeL List . iterator ( ) ; while ( itr . has CaMeL Next ( ) ) { Workbench CaMeL Page page = ( Workbench CaMeL Page ) itr . next ( ) ; fire CaMeL Page CaMeL Closed ( page ) ; page . dispose ( ) ; } if ( ! closing ) show CaMeL Empty CaMeL Window CaMeL Contents ( ) ; }	if ( ! closing ) {
if ( is CaMeL Current CaMeL Page ( ) ) get CaMeL Container ( ) . update CaMeL Title CaMeL Bar ( ) ;  <CTX>  public void set CaMeL Description ( String description ) { super . set CaMeL Description ( description ) ; if ( is CaMeL Current CaMeL Page ( ) ) get CaMeL Container ( ) . update CaMeL Title CaMeL Bar ( ) ; }	if ( is CaMeL Current CaMeL Page ( ) ) { get CaMeL Container ( ) . update CaMeL Title CaMeL Bar ( ) ; }
Wizard CaMeL Action CaMeL Group . TYPE _ IMPORT ) ;  <CTX>  public void init ( I CaMeL Common CaMeL Action CaMeL Extension CaMeL Site a CaMeL Config ) { Assert . is CaMeL True ( ! disposed ) ; if ( a CaMeL Config . get CaMeL View CaMeL Site ( ) instanceof I CaMeL Common CaMeL Viewer CaMeL Workbench CaMeL Site ) { I CaMeL Workbench CaMeL Window window = ( ( I CaMeL Common CaMeL Viewer CaMeL Workbench CaMeL Site ) a CaMeL Config . get CaMeL View CaMeL Site ( ) ) . get CaMeL Workbench CaMeL Window ( ) ; import CaMeL Action = new Import CaMeL Resources CaMeL Action ( window ) ; export CaMeL Action = new Export CaMeL Resources CaMeL Action ( window ) ; import CaMeL Wizard CaMeL Action CaMeL Group = new Wizard CaMeL Action CaMeL Group ( window , Platform CaMeL UI . get CaMeL Workbench ( ) . get CaMeL Import CaMeL Wizard CaMeL Registry ( ) , Wizard CaMeL Action CaMeL Group . TYPE _ IMPORT ) ; export CaMeL Wizard CaMeL Action CaMeL Group = new Wizard CaMeL Action CaMeL Group ( window , Platform CaMeL UI . get CaMeL Workbench ( ) . get CaMeL Export CaMeL Wizard CaMeL Registry ( ) , Wizard CaMeL Action CaMeL Group . TYPE _ EXPORT ) ; contribute = true ; } }	Wizard CaMeL Action CaMeL Group . TYPE _ IMPORT , an CaMeL Extension CaMeL Site . get CaMeL Content CaMeL Service ( ) ) ;
if ( val . magnitude . length > i )  <CTX>  public Big CaMeL Integer xor ( Big CaMeL Integer val ) { int [ ] result ; if ( magnitude . length > val . magnitude . length ) { result = new int [ magnitude . length ] ; } else { result = new int [ val . magnitude . length ] ; } for ( int i = 0 ; i < result . length ; i ++ ) { int index = result . length - i - 1 ; if ( magnitude . length > i ) { result [ index ] = magnitude [ magnitude . length - i - 1 ] ; } if ( val . magnitude . length > i ) { result [ index ] ^= val . magnitude [ val . magnitude . length - i - 1 ] ; } else { result [ index ] ^= 0 ; } } int res CaMeL Sign = 1 ; if ( sign < 0 || val . sign < 0 ) { res CaMeL Sign = - 1 ; } return new Big CaMeL Integer ( res CaMeL Sign , result ) ; }	if ( val . sign < 0 )
if ( is CaMeL Byte CaMeL Array ) byte CaMeL Array CaMeL Stream CaMeL Escape CaMeL Set . set ( stream CaMeL Construction . get CaMeL Position ( ) ) ;  <CTX>  public void add CaMeL Stream CaMeL Construction ( Instruction CaMeL Handle stream CaMeL Construction , boolean is CaMeL Byte CaMeL Array ) { stream CaMeL Construction CaMeL Set . set ( stream CaMeL Construction . get CaMeL Position ( ) ) ; if ( is CaMeL Byte CaMeL Array ) byte CaMeL Array CaMeL Stream CaMeL Escape CaMeL Set . set ( stream CaMeL Construction . get CaMeL Position ( ) ) ; }	if ( is CaMeL Un@@ interesting ) un@@ interesting CaMeL Stream CaMeL Escape CaMeL Set . set ( stream CaMeL Construction . get CaMeL Position ( ) ) ;
Impact impact = ( Impact ) imp@@ acts . get ( i ) ;  <CTX>  private List get CaMeL Agents CaMeL In CaMeL Imp@@ acts ( ) { List agents = new Array CaMeL List ( ) ; for ( int i = 0 ; i < imp@@ acts . size ( ) ; i ++ ) { Impact impact = ( Impact ) imp@@ acts . get ( i ) ; agents . add CaMeL All ( Arrays . as CaMeL List ( impact . get CaMeL Agents ( ) ) ) ; } return agents ; }	Impact CaMeL Component impact = ( Impact CaMeL Component ) imp@@ acts . get ( i ) ;
new CaMeL Input CaMeL Button . set CaMeL Enabled ( true ) ; new CaMeL List CaMeL Button . set CaMeL Enabled ( true ) ;  <CTX>  public void value CaMeL Changed ( Tree CaMeL Selection CaMeL Event event ) { if ( event . get CaMeL Path ( ) . get CaMeL Last CaMeL Path CaMeL Component ( ) instanceof Panel CaMeL Tree CaMeL Node ) { Panel CaMeL Tree CaMeL Node node = ( Panel CaMeL Tree CaMeL Node ) event . get CaMeL Path ( ) . get CaMeL Last CaMeL Path CaMeL Component ( ) ; splitter . set CaMeL Right CaMeL Component ( node . get CaMeL Panel ( ) ) ; if ( node instanceof Inputs CaMeL Root CaMeL Node ) { load CaMeL Inputs CaMeL Button . set CaMeL Enabled ( false ) ; new CaMeL Input CaMeL Button . set CaMeL Enabled ( false ) ; new CaMeL List CaMeL Button . set CaMeL Enabled ( false ) ; remove CaMeL Button . set CaMeL Enabled ( false ) ; } else if ( node instanceof Input CaMeL Port CaMeL Node ) { load CaMeL Inputs CaMeL Button . set CaMeL Enabled ( true ) ; new CaMeL Input CaMeL Button . set CaMeL Enabled ( true ) ; new CaMeL List CaMeL Button . set CaMeL Enabled ( true ) ; remove CaMeL Button . set CaMeL Enabled ( false ) ; } else { load CaMeL Inputs CaMeL Button . set CaMeL Enabled ( true ) ; new CaMeL Input CaMeL Button . set CaMeL Enabled ( true ) ; new CaMeL List CaMeL Button . set CaMeL Enabled ( true ) ; remove CaMeL Button . set CaMeL Enabled ( true ) ; } } else { if ( splitter . get CaMeL Right CaMeL Component ( ) != null ) { splitter . remove ( splitter . get CaMeL Right CaMeL Component ( ) ) ; } load CaMeL Inputs CaMeL Button . set CaMeL Enabled ( false ) ; new CaMeL Input CaMeL Button . set CaMeL Enabled ( false ) ; new CaMeL List CaMeL Button . set CaMeL Enabled ( false ) ; remove CaMeL Button . set CaMeL Enabled ( false ) ; } splitter . validate ( ) ; }	new CaMeL Input CaMeL Button . set CaMeL Enabled ( can CaMeL Add CaMeL Inputs ( ( Input CaMeL List CaMeL Node ) node ) ) ; new CaMeL List CaMeL Button . set CaMeL Enabled ( can CaMeL Add CaMeL Lists ( ( Input CaMeL List CaMeL Node ) node ) ) ;
class CaMeL File . stop CaMeL Method ( ( short ) ( locals CaMeL Max + 1 ) , vars ) ;  <CTX>  private void finish CaMeL Method ( Context cx , Variable CaMeL Table vars ) { class CaMeL File . stop CaMeL Method ( ( short ) ( locals CaMeL Max + 1 ) , vars ) ; context CaMeL Local = - 1 ; }	Opt CaMeL Local CaMeL Variable [ ] array = Opt CaMeL Local CaMeL Variable . to CaMeL Array ( vars ) ; class CaMeL File . stop CaMeL Method ( ( short ) ( locals CaMeL Max + 1 ) , array ) ;
return MOVE _ REDUCED ;  <CTX>  private static byte get CaMeL Type CaMeL From CaMeL Tib ( OPT _ Instruction s ) { if ( CF _ TIB ) { OPT _ Operand tib CaMeL Op = Unary . get CaMeL Val ( s ) ; if ( tib CaMeL Op . is CaMeL TIB CaMeL Constant ( ) ) { OPT _ TIB CaMeL Constant CaMeL Operand tib = tib CaMeL Op . as CaMeL TIB CaMeL Constant ( ) ; Move . mutate ( s , REF _ MOVE , Unary . get CaMeL Clear CaMeL Result ( s ) , new OPT _ Object CaMeL Constant CaMeL Operand ( tib . value , Offset . zero ( ) ) ) ; return MOVE _ REDUCED ; } } return UNCHANGED ; }	return Def CaMeL Use CaMeL Effect . MOVE _ FOLDED ;
String ret CaMeL Str = Native CaMeL Normalizer . normalize ( str , normalization CaMeL Mode , err CaMeL Code ) ; if ( Error CaMeL Code . is CaMeL Failure ( err CaMeL Code [ 0 ] ) ) { throw Error CaMeL Code . get CaMeL Exception ( err CaMeL Code [ 0 ] ) ;  <CTX>  public static String normalize ( String str , int normalization CaMeL Mode ) throws Exception { synchronized ( err CaMeL Code ) { if ( ! check ( normalization CaMeL Mode ) ) { throw Error CaMeL Code . get CaMeL Exception ( Error CaMeL Code . U _ ILLEGAL _ ARGUMENT _ ERROR ) ; } String ret CaMeL Str = Native CaMeL Normalizer . normalize ( str , normalization CaMeL Mode , err CaMeL Code ) ; if ( Error CaMeL Code . is CaMeL Failure ( err CaMeL Code [ 0 ] ) ) { throw Error CaMeL Code . get CaMeL Exception ( err CaMeL Code [ 0 ] ) ; } return ret CaMeL Str ; } }	int error CaMeL Code = Native CaMeL Normalizer . normalize ( str , normalization CaMeL Mode , ret CaMeL Str ) ; if ( Error CaMeL Code . is CaMeL Failure ( error CaMeL Code ) ) { throw Error CaMeL Code . get CaMeL Exception ( error CaMeL Code ) ;
return get CaMeL Runtime ( ) . new CaMeL Fixnum ( to CaMeL String ( ) . hash CaMeL Code ( ) ) ;  <CTX>  public Ruby CaMeL Fixnum hash ( ) { return get CaMeL Runtime ( ) . new CaMeL Fixnum ( to CaMeL String ( ) . hash CaMeL Code ( ) ) ; }	return get CaMeL Runtime ( ) . new CaMeL Fixnum ( hash CaMeL Code ( ) ) ;
return Ruby CaMeL Boolean . new CaMeL Boolean ( get CaMeL Runtime ( ) , Modifier . is CaMeL Final ( field . get CaMeL Modifiers ( ) ) ) ;  <CTX>  public Ruby CaMeL Boolean final _ p ( ) { return Ruby CaMeL Boolean . new CaMeL Boolean ( get CaMeL Runtime ( ) , Modifier . is CaMeL Final ( field . get CaMeL Modifiers ( ) ) ) ; }	return get CaMeL Runtime ( ) . new CaMeL Boolean ( Modifier . is CaMeL Final ( field . get CaMeL Modifiers ( ) ) ) ;
return tracker . succeeded CaMeL Blocks ( ) . length ;  <CTX>  public int fetched CaMeL Blocks ( ) { return tracker . succeeded CaMeL Blocks ( ) . length ; }	return tracker . succeeded CaMeL Blocks CaMeL Length ( ) ;
if ( base CaMeL Val != null ) {  <CTX>  public void attr CaMeL Added ( Attr node , String newv ) { if ( base CaMeL Val != null ) { base CaMeL Val . invalidate ( ) ; } }	if ( ! changing && base CaMeL Val != null ) {
if ( sp == null || sr == null || m CaMeL Cursors . size ( ) == 0 )  <CTX>  private void do CaMeL Search CaMeL Previous ( String [ ] args ) throws Service CaMeL Exception { Z CaMeL Search CaMeL Params sp = m CaMeL Search CaMeL Params ; Z CaMeL Search CaMeL Result sr = m CaMeL Search CaMeL Result ; if ( sp == null || sr == null || m CaMeL Cursors . size ( ) == 0 ) return ; m CaMeL Cursors . pop ( ) ; sp . set CaMeL Cursor ( m CaMeL Cursors . size ( ) > 0 ? m CaMeL Cursors . peek ( ) : null ) ; do CaMeL Search ( sp ) ; }	if ( sp == null || sr == null || m CaMeL Search CaMeL Cursors . size ( ) == 0 )
Map map = view . get CaMeL All CaMeL Attributes ( ) ; Rectangle cell CaMeL Bounds = Graph CaMeL Constants . get CaMeL Bounds ( map ) ; Rectangle editing CaMeL Bounds = editor CaMeL Component . get CaMeL Bounds ( ) ; Graph CaMeL Constants . set CaMeL Bounds ( map , new Rectangle ( cell CaMeL Bounds . x , cell CaMeL Bounds . y , editing CaMeL Bounds . width , editing CaMeL Bounds . height ) ) ;  <CTX>  public boolean stop CaMeL Cell CaMeL Editing ( ) { / / set the size of a vertex to that of an editor . Cell CaMeL View view = graph . get CaMeL Graph CaMeL Layout CaMeL Cache ( ) . get CaMeL Mapping ( graph . get CaMeL Editing CaMeL Cell ( ) , false ) ; Map map = view . get CaMeL All CaMeL Attributes ( ) ; Rectangle cell CaMeL Bounds = Graph CaMeL Constants . get CaMeL Bounds ( map ) ; Rectangle editing CaMeL Bounds = editor CaMeL Component . get CaMeL Bounds ( ) ; Graph CaMeL Constants . set CaMeL Bounds ( map , new Rectangle ( cell CaMeL Bounds . x , cell CaMeL Bounds . y , editing CaMeL Bounds . width , editing CaMeL Bounds . height ) ) ; return super . stop CaMeL Cell CaMeL Editing ( ) ; }	if ( view != null ) { Map map = view . get CaMeL All CaMeL Attributes ( ) ; Rectangle cell CaMeL Bounds = Graph CaMeL Constants . get CaMeL Bounds ( map ) ; Rectangle editing CaMeL Bounds = editor CaMeL Component . get CaMeL Bounds ( ) ; Graph CaMeL Constants . set CaMeL Bounds ( map , new Rectangle ( cell CaMeL Bounds . x , cell CaMeL Bounds . y , editing CaMeL Bounds . width , editing CaMeL Bounds . height ) ) ; }
Ruby CaMeL Module ruby CaMeL Class = ( Ruby CaMeL Module ) class CaMeL Stack . peek ( ) ; if ( ruby CaMeL Class . is CaMeL Included ( ) ) { return ( ( Included CaMeL Module CaMeL Wrapper ) ruby CaMeL Class ) . get CaMeL Delegate ( ) ;  <CTX>  public Ruby CaMeL Module get CaMeL Ruby CaMeL Class ( ) { if ( class CaMeL Stack . empty ( ) ) { return null ; } Ruby CaMeL Module ruby CaMeL Class = ( Ruby CaMeL Module ) class CaMeL Stack . peek ( ) ; if ( ruby CaMeL Class . is CaMeL Included ( ) ) { return ( ( Included CaMeL Module CaMeL Wrapper ) ruby CaMeL Class ) . get CaMeL Delegate ( ) ; } return ruby CaMeL Class ; }	if ( parent CaMeL Module . is CaMeL Included ( ) ) { return ( ( Included CaMeL Module CaMeL Wrapper ) parent CaMeL Module ) . get CaMeL Delegate ( ) ;
return 32 ;  <CTX>  public int get CaMeL Max CaMeL Column CaMeL Name CaMeL Length ( ) throws SQL CaMeL Exception { return 32 ; }	return NAME _ SIZE ;
get CaMeL History ( ) . dispose ( undo CaMeL Context , true , false , false ) ;  <CTX>  void flush ( ) { get CaMeL History ( ) . dispose ( undo CaMeL Context , true , false , false ) ; }	get CaMeL History ( ) . dispose ( get CaMeL Undo CaMeL Context ( ) , true , false , false ) ;
my CaMeL Depend@@ ance CaMeL Contains CaMeL LF = formatter . contains CaMeL Line CaMeL Feeds ( my CaMeL Depend@@ ance ) ;  <CTX>  public void refresh ( Format CaMeL Processor formatter ) { my CaMeL Depend@@ ance CaMeL Contains CaMeL LF = formatter . contains CaMeL Line CaMeL Feeds ( my CaMeL Depend@@ ance ) ; }	my CaMeL Depend@@ ance CaMeL Contains CaMeL LF = my CaMeL Line CaMeL Feed CaMeL Was CaMeL Used || formatter . contains CaMeL Line CaMeL Feeds ( my CaMeL Depend@@ ance ) ;
log . error ( ex ) ;  <CTX>  public void send CaMeL Clear CaMeL Panel CaMeL Msg ( ) { int tmp [ ] = new int [ 1 ] ; tmp [ 0 ] = 0 ; Draw CaMeL Command comm = new Draw CaMeL Command ( Draw CaMeL Command . CLEAR ) ; Object CaMeL Output CaMeL Stream os ; try { out . reset ( ) ; os = new Object CaMeL Output CaMeL Stream ( out ) ; os . write CaMeL Object ( comm ) ; os . flush ( ) ; data _ channel . send ( new Message ( null , null , out . to CaMeL Byte CaMeL Array ( ) ) ) ; } catch ( Exception ex ) { log . error ( ex ) ; } }	System . err . println ( ex ) ;
this ( ) ; this . entry CaMeL Nr = nr ;  <CTX>  public Result ( int nr ) { this ( ) ; this . entry CaMeL Nr = nr ; }	nr CaMeL Errors = 0 L ; nr CaMeL Lines CaMeL Input = 0 L ; nr CaMeL Lines CaMeL Output = 0 L ; nr CaMeL Lines CaMeL Updated = 0 L ; nr CaMeL Lines CaMeL Read = 0 L ; nr CaMeL Lines CaMeL Written = 0 L ; result = false ; exit CaMeL Status = 0 ; rows = null ; interesting CaMeL Files = new Array CaMeL List ( ) ; stopped = false ; entry CaMeL Nr = 0 ;
node = add CaMeL Element ( parent , name , saver . get CaMeL Class ( ) . get CaMeL Name ( ) , false , false ) ;  <CTX>  public Element write CaMeL Bean CaMeL Saver ( Element parent , Object o , String name ) throws Exception { Element node ; weka . gui . beans . Saver saver ; File file ; / / for debugging only if ( DEBUG ) trace ( new Throwable ( ) , name ) ; saver = ( weka . gui . beans . Saver ) o ; node = add CaMeL Element ( parent , name , saver . get CaMeL Class ( ) . get CaMeL Name ( ) , false , false ) ; invoke CaMeL Write CaMeL To CaMeL XML ( node , saver . get CaMeL Saver ( ) , VAL _ SAVER ) ; return node ; }	node = add CaMeL Element ( parent , name , saver . get CaMeL Class ( ) . get CaMeL Name ( ) , false ) ;
if ( I CaMeL Chem CaMeL File . class . is CaMeL Instance ( class CaMeL Object ) ) return true ;  <CTX>  public boolean accepts ( Class class CaMeL Object ) { if ( I CaMeL Chem CaMeL File . class . is CaMeL Instance ( class CaMeL Object ) ) return true ; return false ; }	Class [ ] interfaces = class CaMeL Object . get CaMeL Interfaces ( ) ; for ( int i = 0 ; i < interfaces . length ; i ++ ) { if ( I CaMeL Chem CaMeL File . class . equals ( interfaces [ i ] ) ) return true ; }
get CaMeL Parameter CaMeL Position ( exp CaMeL List , wrapped CaMeL Exp ) ;  <CTX>  public void visit CaMeL Expression CaMeL List ( Psi CaMeL Expression CaMeL List exp CaMeL List ) { final Java CaMeL Resolve CaMeL Result result = find CaMeL Called CaMeL Method ( exp CaMeL List ) ; final Psi CaMeL Method method = ( Psi CaMeL Method ) result . get CaMeL Element ( ) ; if ( method == null ) { expected CaMeL Type = null ; } else { final int parameter CaMeL Position = get CaMeL Parameter CaMeL Position ( exp CaMeL List , wrapped CaMeL Exp ) ; expected CaMeL Type = get CaMeL Type CaMeL Of CaMeL Parameter ( result , parameter CaMeL Position ) ; } }	get CaMeL Parameter CaMeL Position ( expression CaMeL List , wrapped CaMeL Expression ) ;
return this . mapped CaMeL Port ;  <CTX>  public int get CaMeL Port ( ) { return this . mapped CaMeL Port ; }	return this . port ;
return ( Class ) cls ;  <CTX>  public Class find CaMeL Class ( String name ) throws Class CaMeL Not CaMeL Found CaMeL Exception { Object cls = class CaMeL Map . get ( name ) ; if ( cls == null ) throw new Class CaMeL Not CaMeL Found CaMeL Exception ( name ) ; return ( Class ) cls ; }	return cls ;
My@@ lar CaMeL Ui CaMeL Plugin . get CaMeL Default ( ) . set CaMeL Filter CaMeL In CaMeL Complete CaMeL Mode ( is CaMeL Checked ( ) ) ;  <CTX>  public void run ( ) { My@@ lar CaMeL Ui CaMeL Plugin . get CaMeL Default ( ) . set CaMeL Filter CaMeL In CaMeL Complete CaMeL Mode ( is CaMeL Checked ( ) ) ; if ( is CaMeL Checked ( ) ) { viewer . add CaMeL Filter ( in CaMeL Complete CaMeL Filter ) ; filter CaMeL Complete CaMeL Task . set CaMeL Checked ( false ) ; viewer . remove CaMeL Filter ( complete CaMeL Filter ) ; } else { viewer . remove CaMeL Filter ( in CaMeL Complete CaMeL Filter ) ; } viewer . refresh ( ) ; }	My@@ lar CaMeL Tasks CaMeL Plugin . get CaMeL Default ( ) . set CaMeL Filter CaMeL In CaMeL Complete CaMeL Mode ( is CaMeL Checked ( ) ) ;
this . endian = endian ; return this ;  <CTX>  public final Byte CaMeL Buffer order ( Byte CaMeL Order endian ) { this . endian = endian ; return this ; }	return endian ;
if ( ! found ) return s ;  <CTX>  public static String remove CaMeL White CaMeL Spaces ( String s ) { / / check for no whitespace ( common case ) boolean found = false ; int ws CaMeL Index = - 1 ; int size = s . length ( ) ; for ( int i = 0 ; i < size ; i ++ ) { found = Character . is CaMeL Whitespace ( s . char CaMeL At ( i ) ) ; if ( found ) { ws CaMeL Index = i ; break ; } } if ( ! found ) return s ; String CaMeL Buffer result = new String CaMeL Buffer ( s . substring ( 0 , ws CaMeL Index ) ) ; for ( int i = ws CaMeL Index + 1 ; i < size ; i ++ ) { char ch = s . char CaMeL At ( i ) ; if ( ! Character . is CaMeL Whitespace ( ch ) ) result . append ( ch ) ; } return result . to CaMeL String ( ) ; }	if ( ! found ) { return s ; }
get CaMeL Runtime ( ) . yield ( Ruby CaMeL String . new CaMeL String ( get CaMeL Runtime ( ) , contents [ i ] ) ) ;  <CTX>  public I CaMeL Ruby CaMeL Object each ( ) { String [ ] contents = snapshot ; for ( int i = 0 ; i < contents . length ; i ++ ) { get CaMeL Runtime ( ) . yield ( Ruby CaMeL String . new CaMeL String ( get CaMeL Runtime ( ) , contents [ i ] ) ) ; } return this ; }	get CaMeL Runtime ( ) . yield ( get CaMeL Runtime ( ) . new CaMeL String ( contents [ i ] ) ) ;
return new Dimension ( width , height ) ;  <CTX>  public Dimension get CaMeL Size ( ) { return new Dimension ( width , height ) ; }	return size ( ) ;
if ( db != null && ! db . has CaMeL Transactions ( ) )  <CTX>  void release CaMeL Db CaMeL Handle ( isc _ db _ handle db , FB CaMeL Connection CaMeL Request CaMeL Info cr@@ i ) throws GDS CaMeL Exception { synchronized ( db ) { if ( db != null && ! db . has CaMeL Transactions ( ) ) { gds . isc _ detach _ database ( db ) ; } } }	Linked CaMeL List free CaMeL Db CaMeL Handles = null ; synchronized ( cr@@ i CaMeL To CaMeL Free CaMeL Db CaMeL Handles CaMeL Map )
/ interval CaMeL Range ) ) ;  <CTX>  public Object calculate ( Object value ) { if ( value == null ) { return new Double ( - 1 ) ; } if ( interval CaMeL Start == null ) { return new Double ( Math . floor ( Date CaMeL Time CaMeL Util . diff CaMeL Month ( default CaMeL Start , ( Date ) value ) / interval CaMeL Range ) ) ; } else { if ( Date CaMeL Time CaMeL Util . diff CaMeL Month ( ( Date ) interval CaMeL Start , ( Date ) value ) < 0 ) { return new Double ( - 1 ) ; } else { return new Double ( Math . floor ( Date CaMeL Time CaMeL Util . diff CaMeL Month ( ( Date ) interval CaMeL Start , ( Date ) value ) / interval CaMeL Range ) ) ; } } }	/ get CaMeL Date CaMeL Interval CaMeL Range ( ) ) ) ;
x . set CaMeL Path ( p ) ;  <CTX>  private static boolean mkdirs ( File x ) { if ( x . is CaMeL Directory ( ) ) return true ; String p = x . get CaMeL Path ( ) ; String parent = x . get CaMeL Parent ( ) ; if ( parent != null ) { x . set CaMeL Path ( parent ) ; if ( ! mkdirs ( x ) ) return false ; x . set CaMeL Path ( p ) ; } return x . mkdir ( ) ; }	x . path = p ;
J CaMeL Layered CaMeL Pane layered CaMeL Pane ;  <CTX>  private void cleanup CaMeL UI ( ) { J CaMeL Layered CaMeL Pane layered CaMeL Pane ; try { / / Return focus back to the previous focused component if we need to do it and / / previous focused compon@@ en is showing . if ( my CaMeL Previously CaMeL Focused CaMeL Component instanceof J CaMeL Component && my CaMeL Previously CaMeL Focused CaMeL Component . is CaMeL Showing ( ) ) { final J CaMeL Component _ component = ( J CaMeL Component ) my CaMeL Previously CaMeL Focused CaMeL Component ; Layout CaMeL Focus CaMeL Traversal CaMeL Policy CaMeL Ext . set CaMeL Overriden CaMeL Default CaMeL Component ( _ component ) ; } if ( my CaMeL Previously CaMeL Focused CaMeL Component != null ) { my CaMeL Previously CaMeL Focused CaMeL Component . request CaMeL Focus ( ) ; } layered CaMeL Pane = my CaMeL Text CaMeL Field CaMeL Panel . get CaMeL Root CaMeL Pane ( ) . get CaMeL Layered CaMeL Pane ( ) ; layered CaMeL Pane . remove ( my CaMeL List CaMeL Scroll CaMeL Pane ) ; layered CaMeL Pane . remove ( my CaMeL Text CaMeL Field CaMeL Panel ) ; } finally { Layout CaMeL Focus CaMeL Traversal CaMeL Policy CaMeL Ext . set CaMeL Overriden CaMeL Default CaMeL Component ( null ) ; } layered CaMeL Pane . validate ( ) ; layered CaMeL Pane . repaint ( ) ; }	J CaMeL Layered CaMeL Pane layered CaMeL Pane = null ;
Interpreted CaMeL Function result = new Interpreted CaMeL Function ( its CaMeL Data , cx ) ;  <CTX>  generate CaMeL Function CaMeL I CaMeL Code ( Context cx , Scriptable scope , Function CaMeL Node the CaMeL Function , Object security CaMeL Domain ) { its CaMeL Function CaMeL List = ( Vector ) the CaMeL Function . get CaMeL Prop ( Node . FUNCTION _ PROP ) ; if ( its CaMeL Function CaMeL List != null ) generate CaMeL Nested CaMeL Functions ( scope , cx , security CaMeL Domain ) ; Object [ ] reg CaMeL Exp CaMeL Literals = null ; Vector regexps = ( Vector ) the CaMeL Function . get CaMeL Prop ( Node . REGEXP _ PROP ) ; if ( regexps != null ) reg CaMeL Exp CaMeL Literals = generate CaMeL Reg CaMeL Exp CaMeL Literals ( cx , scope , regexps ) ; Variable CaMeL Table var CaMeL Table = the CaMeL Function . get CaMeL Variable CaMeL Table ( ) ; boolean needs CaMeL Activation = the CaMeL Function . requires CaMeL Activation ( ) || ( cx . is CaMeL Generating CaMeL Debug CaMeL Changed ( ) && cx . is CaMeL Generating CaMeL Debug ( ) ) ; generate CaMeL I CaMeL Code CaMeL From CaMeL Tree ( the CaMeL Function . get CaMeL Last CaMeL Child ( ) , var CaMeL Table , needs CaMeL Activation , security CaMeL Domain ) ; its CaMeL Data . its CaMeL Name = the CaMeL Function . get CaMeL Function CaMeL Name ( ) ; its CaMeL Data . its CaMeL Source CaMeL File = ( String ) the CaMeL Function . get CaMeL Prop ( Node . SOUR@@ CEN@@ AME _ PROP ) ; its CaMeL Data . its CaMeL Source = ( String ) the CaMeL Function . get CaMeL Prop ( Node . SOURCE _ PROP ) ; its CaMeL Data . its CaMeL Nested CaMeL Functions = its CaMeL Nested CaMeL Functions ; its CaMeL Data . its CaMeL Reg CaMeL Exp CaMeL Literals = reg CaMeL Exp CaMeL Literals ; if ( print CaMeL I CaMeL Code ) dump CaMeL I CaMeL Code ( its CaMeL Data ) ; Interpreted CaMeL Function result = new Interpreted CaMeL Function ( its CaMeL Data , cx ) ; if ( cx . debugger != null ) { cx . debugger . handle CaMeL Compilation CaMeL Done ( cx , result , debug CaMeL Source ) ; } return result ; }	String [ ] arg CaMeL Names = its CaMeL Variable CaMeL Table . get CaMeL All CaMeL Names ( ) ; short arg CaMeL Count = ( short ) its CaMeL Variable CaMeL Table . get CaMeL Parameter CaMeL Count ( ) ; Interpreted CaMeL Function result = new Interpreted CaMeL Function ( cx , its CaMeL Data , arg CaMeL Names , arg CaMeL Count ) ;
return e CaMeL Dynamic CaMeL Get ( e CaMeL Feature , resolve ) ;  <CTX>  public Object e CaMeL Get ( E CaMeL Structural CaMeL Feature e CaMeL Feature , boolean resolve ) { switch ( e CaMeL Derived CaMeL Structural CaMeL Feature CaMeL ID ( e CaMeL Feature ) ) { case Attribute CaMeL Package . INSETS _ _ TOP : return new Double ( get CaMeL Top ( ) ) ; case Attribute CaMeL Package . INSETS _ _ LEFT : return new Double ( get CaMeL Left ( ) ) ; case Attribute CaMeL Package . INSETS _ _ BOTTOM : return new Double ( get CaMeL Bottom ( ) ) ; case Attribute CaMeL Package . INSETS _ _ RIGHT : return new Double ( get CaMeL Right ( ) ) ; } return e CaMeL Dynamic CaMeL Get ( e CaMeL Feature , resolve ) ; }	return super . e CaMeL Get ( feature CaMeL ID , resolve , core CaMeL Type ) ;
return new Bookmark CaMeL Entry CaMeL Impl ( native CaMeL Node , your CaMeL Parent ) ;  <CTX>  protected RDF CaMeL Tree CaMeL Node new CaMeL RDF CaMeL Tree CaMeL Node ( int native CaMeL Node , RDF CaMeL Tree CaMeL Node your CaMeL Parent ) { return new Bookmark CaMeL Entry CaMeL Impl ( native CaMeL Node , your CaMeL Parent ) ; }	return new Bookmark CaMeL Entry CaMeL Impl ( native CaMeL Web CaMeL Shell , native CaMeL Node , your CaMeL Parent ) ;
return false ;  <CTX>  public boolean are CaMeL Focus CaMeL Traversal CaMeL Keys CaMeL Set ( int id ) { if ( id != Keyboard CaMeL Focus CaMeL Manager . FORWARD _ TRAVERSAL _ KEYS && id != Keyboard CaMeL Focus CaMeL Manager . BACKWARD _ TRAVERSAL _ KEYS && id != Keyboard CaMeL Focus CaMeL Manager . UP _ CYCLE _ TRAVERSAL _ KEYS && id != Keyboard CaMeL Focus CaMeL Manager . DOWN _ CYCLE _ TRAVERSAL _ KEYS ) throw new Illegal CaMeL Argument CaMeL Exception ( ) ; return false ; }	return focus CaMeL Traversal CaMeL Keys != null && focus CaMeL Traversal CaMeL Keys [ id ] != null ;
this . code = code ; this . PC = code . length ; read CaMeL PC = PC ; }  <CTX>  public void set CaMeL Code ( byte [ ] code ) { this . code = code ; this . PC = code . length ; read CaMeL PC = PC ; }	this . code = code ; this . PC = code . length ; }
if ( Task CaMeL List CaMeL View . get CaMeL Default ( ) != null )  <CTX>  public void property CaMeL Change ( Property CaMeL Change CaMeL Event event ) { if ( event . get CaMeL Property ( ) . equals ( Task CaMeL List CaMeL Preference CaMeL Constants . MULTIPLE _ ACTIVE _ TASKS ) ) { Task CaMeL List CaMeL View . get CaMeL Default ( ) . toggle CaMeL Previous CaMeL Action ( ! get CaMeL Prefs ( ) . get CaMeL Boolean ( Task CaMeL List CaMeL Preference CaMeL Constants . MULTIPLE _ ACTIVE _ TASKS ) ) ; Task CaMeL List CaMeL View . get CaMeL Default ( ) . toggle CaMeL Next CaMeL Action ( ! get CaMeL Prefs ( ) . get CaMeL Boolean ( Task CaMeL List CaMeL Preference CaMeL Constants . MULTIPLE _ ACTIVE _ TASKS ) ) ; Task CaMeL List CaMeL View . get CaMeL Default ( ) . clear CaMeL Task CaMeL History ( ) ; } if ( event . get CaMeL Property ( ) . equals ( My@@ lar CaMeL Preference CaMeL Con@@ t@@ stan@@ ts . PREF _ DATA _ DIR ) ) { if ( event . get CaMeL Old CaMeL Value ( ) instanceof String ) { String new CaMeL Dir CaMeL Path = My@@ lar CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Data CaMeL Directory ( ) ; String task CaMeL List CaMeL File CaMeL Path = new CaMeL Dir CaMeL Path + File . separator + DEFAULT _ TASK _ LIST _ FILE ; get CaMeL Task CaMeL List CaMeL Save CaMeL Manager ( ) . save CaMeL Task CaMeL List CaMeL And CaMeL Contexts ( ) ; get CaMeL Task CaMeL List CaMeL Manager ( ) . set CaMeL Task CaMeL List CaMeL File ( new File ( task CaMeL List CaMeL File CaMeL Path ) ) ; get CaMeL Task CaMeL List CaMeL Manager ( ) . reset CaMeL Task CaMeL List ( ) ; get CaMeL Task CaMeL List CaMeL Manager ( ) . read CaMeL Existing CaMeL Or CaMeL Create CaMeL New CaMeL List ( ) ; if ( Task CaMeL List CaMeL View . get CaMeL Default ( ) != null ) Task CaMeL List CaMeL View . get CaMeL Default ( ) . clear CaMeL Task CaMeL History ( ) ; } } }	if ( Task CaMeL List CaMeL View . get CaMeL Default ( ) != null ) {
Object lhs = stack [ stack CaMeL Top - 1 ] ; if ( lhs == DBL _ MRK ) lhs = double CaMeL Wrap ( s CaMeL Dbl [ stack CaMeL Top - 1 ] ) ;  <CTX>  private static int do _ get CaMeL Elem ( Object [ ] stack , double [ ] s CaMeL Dbl , int stack CaMeL Top , Context cx , Scriptable scope ) { Object lhs = stack [ stack CaMeL Top - 1 ] ; if ( lhs == DBL _ MRK ) lhs = double CaMeL Wrap ( s CaMeL Dbl [ stack CaMeL Top - 1 ] ) ; Object result ; Object id = stack [ stack CaMeL Top ] ; if ( id != DBL _ MRK ) { result = Script CaMeL Runtime . get CaMeL Object CaMeL Elem ( lhs , id , cx , scope ) ; } else { double val = s CaMeL Dbl [ stack CaMeL Top ] ; if ( lhs == null || lhs == Undefined . instance ) { throw Script CaMeL Runtime . undef CaMeL Read CaMeL Error ( lhs , Script CaMeL Runtime . to CaMeL String ( val ) ) ; } Scriptable obj = ( lhs instanceof Scriptable ) ? ( Scriptable ) lhs : Script CaMeL Runtime . to CaMeL Object ( cx , scope , lhs ) ; int index = ( int ) val ; if ( index == val ) { result = Script CaMeL Runtime . get CaMeL Object CaMeL Index ( obj , index , cx ) ; } else { String s = Script CaMeL Runtime . to CaMeL String ( val ) ; result = Script CaMeL Runtime . get CaMeL Object CaMeL Prop ( obj , s , cx ) ; } } -- stack CaMeL Top ; stack [ stack CaMeL Top ] = result ; return stack CaMeL Top ; }	Object lhs = state . stack [ i ] ; if ( lhs == DBL _ MRK ) lhs = double CaMeL Wrap ( state . s CaMeL Dbl [ i ] ) ;
return value ;  <CTX>  public void save CaMeL Array ( I CaMeL Object [ ] graph ) { do CaMeL Action ( graph , new Update CaMeL Action < I CaMeL Object [ ] > ( ) { @ Override public I CaMeL Object [ ] run ( I CaMeL Object [ ] value , Update CaMeL Filter filter ) { I CaMeL Object [ ] copy = new I CaMeL Object [ value . length ] ; for ( int i = 0 ; i < value . length ; i ++ ) { copy [ i ] = internal CaMeL Save ( value [ i ] , filter ) ; } return value ; } } ) ; }	return copy ;
Source CaMeL Info source CaMeL Info ( ) {  <CTX>  Source CaMeL Info source CaMeL Info ( ) { return f@@ source . source CaMeL Info ( ) ; }	public Source CaMeL Info source CaMeL Info ( ) {
re = new Native CaMeL Reg CaMeL Exp ( scope , src , opt ) ;  <CTX>  private static Object match CaMeL Or CaMeL Replace ( Context cx , Scriptable this CaMeL Obj , Object [ ] args , Function fun CaMeL Obj , Glob CaMeL Data data ) throws Java CaMeL Script CaMeL Exception { Native CaMeL Reg CaMeL Exp re ; String str = Script CaMeL Runtime . to CaMeL String ( this CaMeL Obj ) ; data . str = str ; Reg CaMeL Exp CaMeL Impl re CaMeL Impl = Reg CaMeL Exp CaMeL Impl . get CaMeL Reg CaMeL Exp CaMeL Impl ( cx ) ; if ( args [ 0 ] instanceof Native CaMeL Reg CaMeL Exp ) { re = ( Native CaMeL Reg CaMeL Exp ) args [ 0 ] ; } else { String src = Script CaMeL Runtime . to CaMeL String ( args [ 0 ] ) ; String opt ; if ( data . optarg < args . length ) { args [ 0 ] = src ; opt = Script CaMeL Runtime . to CaMeL String ( args [ data . optarg ] ) ; } else { opt = null ; } Scriptable scope = Scriptable CaMeL Object . get CaMeL Top CaMeL Level CaMeL Scope ( fun CaMeL Obj ) ; re = new Native CaMeL Reg CaMeL Exp ( scope , src , opt ) ; } data . regexp = re ; data . global = ( re . get CaMeL Flags ( ) & Native CaMeL Reg CaMeL Exp . G@@ LOB ) != 0 ; int [ ] indexp = { 0 } ; Object result = null ; if ( data . mode == Glob CaMeL Data . G@@ LOB _ SEARCH ) { result = re . execute CaMeL Reg CaMeL Exp ( fun CaMeL Obj , str , indexp , true ) ; if ( result != null && result . equals ( Boolean . TRUE ) ) result = new Integer ( re CaMeL Impl . left CaMeL Context . length ) ; else result = new Integer ( - 1 ) ; } else if ( data . global ) { re . set CaMeL Last CaMeL Index ( 0 ) ; for ( int count = 0 ; indexp [ 0 ] <= str . length ( ) ; count ++ ) { result = re . execute CaMeL Reg CaMeL Exp ( fun CaMeL Obj , str , indexp , true ) ; if ( result == null || ! result . equals ( Boolean . TRUE ) ) break ; data . do CaMeL Global ( fun CaMeL Obj , count ) ; if ( re CaMeL Impl . last CaMeL Match . length == 0 ) { if ( indexp [ 0 ] == str . length ( ) ) break ; indexp [ 0 ] ++ ; } } } else { result = re . execute CaMeL Reg CaMeL Exp ( fun CaMeL Obj , str , indexp , data . mode == Glob CaMeL Data . G@@ LOB _ REPLACE ) ; } return result ; }	re = new Native CaMeL Reg CaMeL Exp ( cx , scope , src , opt ) ;
if ( Event CaMeL Util . is CaMeL Dr@@ am@@ a@@ tical CaMeL Change ( events ) ) { project CaMeL Pane . rebuild CaMeL Tree ( new Runnable ( ) { public void run ( ) { S CaMeL Model CaMeL Event CaMeL Visitor visitor = new S CaMeL Model CaMeL Event CaMeL Visitor ( ) { public void visit CaMeL Root CaMeL Event ( S CaMeL Model CaMeL Root CaMeL Event event ) { S CaMeL Model CaMeL Tree CaMeL Node . this . update ( ) ; }  <CTX>  public void model CaMeL Changed CaMeL In CaMeL Command ( final List < S CaMeL Model CaMeL Event > events , Editor CaMeL Context editor CaMeL Context ) { Project CaMeL Pane project CaMeL Pane = get CaMeL Operation CaMeL Context ( ) . get CaMeL Component ( Project CaMeL Pane . class ) ; if ( Event CaMeL Util . is CaMeL Dr@@ am@@ a@@ tical CaMeL Change ( events ) ) { project CaMeL Pane . rebuild CaMeL Tree ( new Runnable ( ) { public void run ( ) { S CaMeL Model CaMeL Event CaMeL Visitor visitor = new S CaMeL Model CaMeL Event CaMeL Visitor ( ) { public void visit CaMeL Root CaMeL Event ( S CaMeL Model CaMeL Root CaMeL Event event ) { S CaMeL Model CaMeL Tree CaMeL Node . this . update ( ) ; } public void visit CaMeL Child CaMeL Event ( S CaMeL Model CaMeL Child CaMeL Event event ) { update CaMeL Tree CaMeL With CaMeL Root ( event . get CaMeL Parent ( ) ) ; } public void visit CaMeL Property CaMeL Event ( S CaMeL Model CaMeL Property CaMeL Event event ) { } public void visit CaMeL Reference CaMeL Event ( S CaMeL Model CaMeL Reference CaMeL Event event ) { } } ; for ( S CaMeL Model CaMeL Event event : events ) { event . accept ( visitor ) ; } / / ( ( Default CaMeL Tree CaMeL Model ) my CaMeL Tree . get CaMeL Model ( ) ) . node CaMeL Structure CaMeL Changed ( S CaMeL Model CaMeL Tree CaMeL Node . this . get CaMeL Parent ( ) ) ; } } ) ; } }	project CaMeL Pane . rebuild CaMeL Tree ( new Runnable ( ) { public void run ( ) { S CaMeL Model CaMeL Event CaMeL Visitor visitor = new S CaMeL Model CaMeL Event CaMeL Visitor ( ) { public void visit CaMeL Root CaMeL Event ( S CaMeL Model CaMeL Root CaMeL Event event ) { S CaMeL Model CaMeL Tree CaMeL Node . this . update ( ) ; }
if ( rt . get CaMeL State ( ) == Reduced CaMeL Model CaMeL States . FREE && Character . is CaMeL Whitespace ( text . char CaMeL At ( index + keyword . length ( ) ) ) ) {  <CTX>  private synchronized int _ find CaMeL Keyword CaMeL At CaMeL Toplevel ( String keyword , String text , int text CaMeL Offset ) { int old CaMeL Location = get CaMeL Current CaMeL Location ( ) ; int index = 0 ; boolean done = false ; while ( ! done ) { index = text . index CaMeL Of ( keyword , index ) ; if ( index == - 1 ) { / / not found done = true ; break ; } else { / / found a match , check quality set CaMeL Current CaMeL Location ( text CaMeL Offset + index ) ; / / check that the keyword is not in a comment and is fol@@ lowed by whitespace Reduced CaMeL Token rt = _ reduced . current CaMeL Token ( ) ; if ( rt . get CaMeL State ( ) == Reduced CaMeL Model CaMeL States . FREE && Character . is CaMeL Whitespace ( text . char CaMeL At ( index + keyword . length ( ) ) ) ) { / / if ( ! _ is CaMeL Commented CaMeL Or CaMeL Space ( index , text ) ) { done = true ; if ( ! pos CaMeL Not CaMeL In CaMeL Block ( index ) ) { / / in a paren phrase , g@@ one too far index = - 1 ; } } else { index ++ ; / / move past so we can search again } } } set CaMeL Current CaMeL Location ( old CaMeL Location ) ; return index ; }	int index CaMeL Past CaMeL Keyword = index + keyword . length ( ) ; if ( index CaMeL Past CaMeL Keyword < text . length ( ) ) { if ( rt . get CaMeL State ( ) == Reduced CaMeL Model CaMeL States . FREE && Character . is CaMeL Whitespace ( text . char CaMeL At ( index CaMeL Past CaMeL Keyword ) ) ) { done = true ; if ( ! pos CaMeL Not CaMeL In CaMeL Block ( index ) ) { index = - 1 ; } } else { index ++ ; } } else { index = - 1 ;
Arc CaMeL Render CaMeL Event are = new Arc CaMeL Render CaMeL Event ( source ) ;  <CTX>  public Primitive CaMeL Render CaMeL Event copy ( ) throws Chart CaMeL Exception { Arc CaMeL Render CaMeL Event are = new Arc CaMeL Render CaMeL Event ( source ) ; if ( outline != null ) { are . set CaMeL Outline ( Line CaMeL Attributes CaMeL Impl . copy CaMeL Instance ( outline ) ) ; } if ( if CaMeL Background != null ) { are . set CaMeL Background ( ( Fill ) Ecore CaMeL Util . copy ( if CaMeL Background ) ) ; } if ( lo CaMeL Top CaMeL Left != null ) { are . set CaMeL Top CaMeL Left ( Location CaMeL Impl . copy CaMeL Instance ( lo CaMeL Top CaMeL Left ) ) ; } are . set CaMeL Style ( i CaMeL Style ) ; are . set CaMeL Width ( d CaMeL Width ) ; are . set CaMeL Height ( d CaMeL Height ) ; are . set CaMeL Start CaMeL Angle ( d CaMeL Start CaMeL In CaMeL Degrees ) ; are . set CaMeL End CaMeL Angle ( d CaMeL Extent CaMeL In CaMeL Degrees ) ; are . set CaMeL Inner CaMeL Radius ( d CaMeL Inner CaMeL Radius ) ; are . set CaMeL Outer CaMeL Radius ( d CaMeL Outer CaMeL Radius ) ; return are ; }	Arc CaMeL Render CaMeL Event are = new Arc CaMeL Render CaMeL Event ( ( Structure CaMeL Source ) source ) ;
Display . get CaMeL Current ( ) . async CaMeL Exec ( new Update CaMeL Request ( ) ) ;  <CTX>  protected void queue CaMeL Work ( ) { if ( ! update CaMeL Queued ) { Display . get CaMeL Current ( ) . async CaMeL Exec ( new Update CaMeL Request ( ) ) ; update CaMeL Queued = true ; } }	Display display = Display . get CaMeL Current ( ) == null ? Display . get CaMeL Default ( ) : Display . get CaMeL Current ( ) ; display . async CaMeL Exec ( new Update CaMeL Request ( ) ) ;
delegate . set CaMeL Disable CaMeL Message CaMeL Timestamp ( disable CaMeL Message CaMeL Timestamp ) ;  <CTX>  public void set CaMeL Disable CaMeL Message CaMeL Timestamp ( boolean disable CaMeL Message CaMeL Timestamp ) throws JMS CaMeL Exception { check CaMeL Pre CaMeL Conditions ( ) ; delegate . set CaMeL Disable CaMeL Message CaMeL Timestamp ( disable CaMeL Message CaMeL Timestamp ) ; }	_ delegate . set CaMeL Disable CaMeL Message CaMeL Timestamp ( disable CaMeL Message CaMeL Timestamp ) ;
Set referencing CaMeL Relationships = new Property CaMeL List CaMeL Set ( ) ;  <CTX>  public Set get CaMeL Referencing CaMeL Relationships ( ) { Set referencing CaMeL Relationships = new Property CaMeL List CaMeL Set ( ) ; Iterator models CaMeL Iter = get CaMeL Model ( ) . get CaMeL Model CaMeL Group ( ) . get CaMeL Models ( ) . iterator ( ) ; while ( models CaMeL Iter . has CaMeL Next ( ) ) { EO CaMeL Model model = ( EO CaMeL Model ) models CaMeL Iter . next ( ) ; Iterator entities CaMeL Iter = model . get CaMeL Entities ( ) . iterator ( ) ; while ( entities CaMeL Iter . has CaMeL Next ( ) ) { EO CaMeL Entity entity = ( EO CaMeL Entity ) entities CaMeL Iter . next ( ) ; if ( ! entity . equals ( this ) ) { Iterator relationships CaMeL Iter = entity . get CaMeL Relationships ( ) . iterator ( ) ; while ( relationships CaMeL Iter . has CaMeL Next ( ) ) { EO CaMeL Relationship relationship = ( EO CaMeL Relationship ) relationships CaMeL Iter . next ( ) ; if ( relationship . is CaMeL Related CaMeL To ( this ) ) { referencing CaMeL Relationships . add ( relationship ) ; } } } } } return referencing CaMeL Relationships ; }	Set referencing CaMeL Relationships = new Hash CaMeL Set ( ) ;
request . set CaMeL Attribute ( Document CaMeL Composer . REQUEST _ ATTRIBUTE _ OR _ PARAMETER _ _ FLOW , flow CaMeL Session CaMeL Attribute CaMeL Name ) ;  <CTX>  private void dispatch CaMeL To CaMeL Publisher CaMeL User CaMeL Browser ( Http CaMeL Servlet CaMeL Request request , Http CaMeL Servlet CaMeL Response response ) throws IO CaMeL Exception , Servlet CaMeL Exception { final String flow CaMeL Session CaMeL Attribute CaMeL Name = Http CaMeL Session CaMeL Utils . get CaMeL Session CaMeL Attribute CaMeL Name CaMeL From CaMeL Request ( request , Document CaMeL Composer . REQUEST _ ATTRIBUTE _ OR _ PARAMETER _ _ FLOW ) ; dispatch CaMeL To CaMeL User CaMeL Browser ( request , response , true , new User CaMeL Finder . Select CaMeL User CaMeL Command ( ) { public void select CaMeL User ( User CaMeL Domain CaMeL Object selected CaMeL User , Http CaMeL Servlet CaMeL Request request , Http CaMeL Servlet CaMeL Response response ) throws Servlet CaMeL Exception , IO CaMeL Exception { document . set CaMeL Publisher ( selected CaMeL User ) ; request . set CaMeL Attribute ( Document CaMeL Composer . REQUEST _ ATTRIBUTE _ OR _ PARAMETER _ _ FLOW , flow CaMeL Session CaMeL Attribute CaMeL Name ) ; dispatch CaMeL To CaMeL First CaMeL Page ( request , response ) ; } } ) ; }	request . set CaMeL Attribute ( REQUEST _ ATTRIBUTE _ OR _ PARAMETER _ _ FLOW , flow CaMeL Session CaMeL Attribute CaMeL Name ) ;
return ( int ) ( ( ( bytes [ 0 ] & 0 xff ) << 8 ) | ( 0 xff & bytes [ 1 ] ) ) ;  <CTX>  static public int to CaMeL Unsigned CaMeL Short ( byte [ ] bytes , boolean big CaMeL Endian ) { if ( bytes . length == 1 ) { return ( int ) ( 0 xff & bytes [ 0 ] ) ; } else if ( big CaMeL Endian ) { return ( int ) ( ( ( bytes [ 0 ] & 0 xff ) << 8 ) | ( 0 xff & bytes [ 1 ] ) ) ; } else { return ( int ) ( ( ( bytes [ 1 ] & 0 xff ) << 8 ) | ( 0 xff & bytes [ 0 ] ) ) ; } }	return ( ( bytes [ 0 ] & 0 xff ) << 8 ) | ( 0 xff & bytes [ 1 ] ) ;
un@@ usable CaMeL Adapters . add ( parameter CaMeL Types [ i ] ) ;  <CTX>  private List get CaMeL All CaMeL Satisfiable CaMeL Constructors ( List constructors , Pico CaMeL Container pico CaMeL Container ) throws Pico CaMeL Introspection CaMeL Exception , Assignability CaMeL Registration CaMeL Exception , Not CaMeL Concrete CaMeL Registration CaMeL Exception { List satis@@ fiable CaMeL Constructors = new Array CaMeL List ( ) ; Set un@@ usable CaMeL Adapters = new Hash CaMeL Set ( ) ; for ( Iterator iterator = constructors . iterator ( ) ; iterator . has CaMeL Next ( ) ; ) { boolean failed CaMeL Dependency = false ; Constructor constructor = ( Constructor ) iterator . next ( ) ; Class [ ] parameter CaMeL Types = constructor . get CaMeL Parameter CaMeL Types ( ) ; Parameter [ ] current CaMeL Parameters = parameters != null ? parameters : create CaMeL Default CaMeL Parameters ( parameter CaMeL Types , pico CaMeL Container ) ; for ( int i = 0 ; i < current CaMeL Parameters . length ; i ++ ) { Component CaMeL Adapter adapter = current CaMeL Parameters [ i ] . resolve CaMeL Adapter ( pico CaMeL Container ) ; if ( adapter == null ) { failed CaMeL Dependency = true ; un@@ usable CaMeL Adapters . add ( parameter CaMeL Types [ i ] ) ; } else { / / we can t depend on our@@ self if ( adapter . equals ( this ) ) { failed CaMeL Dependency = true ; un@@ usable CaMeL Adapters . add ( parameter CaMeL Types [ i ] ) ; } if ( get CaMeL Component CaMeL Key ( ) . equals ( adapter . get CaMeL Component CaMeL Key ( ) ) ) { failed CaMeL Dependency = true ; un@@ usable CaMeL Adapters . add ( parameter CaMeL Types [ i ] ) ; } } } if ( ! failed CaMeL Dependency ) { satis@@ fiable CaMeL Constructors . add ( constructor ) ; } } if ( satis@@ fiable CaMeL Constructors . is CaMeL Empty ( ) ) { throw new Unsatisfiable CaMeL Dependencies CaMeL Exception ( get CaMeL Component CaMeL Implementation ( ) , un@@ usable CaMeL Adapters ) ; } return satis@@ fiable CaMeL Constructors ; }	unsatisfiable CaMeL Dependency CaMeL Types . add ( parameter CaMeL Types [ i ] ) ;
if ( member CaMeL Defn . get CaMeL Type CaMeL Code ( ) == Property CaMeL Type . NAME _ TYPE )  <CTX>  private List do CaMeL Check CaMeL Structure CaMeL List ( Module module , Design CaMeL Element element , I CaMeL Property CaMeL Defn prop CaMeL Defn , List list , I CaMeL Structure to CaMeL Add ) { boolean check CaMeL List = to CaMeL Add == null ; List error CaMeL List = new Array CaMeL List ( ) ; if ( list == null || list . size ( ) == 0 ) return error CaMeL List ; assert prop CaMeL Defn != null ; assert prop CaMeL Defn . get CaMeL Type CaMeL Code ( ) == Property CaMeL Type . STRUCT _ TYPE ; / / Get the unique member wh@@ ose value should be unique in the / / structure list . / / The type of unique member is name property type . / / Note : The first unique member is consi@@ dered . Property CaMeL Defn unique CaMeL Member = null ; Iterator iter = prop CaMeL Defn . get CaMeL Struct CaMeL Defn ( ) . get CaMeL Property CaMeL Iterator ( ) ; while ( iter . has CaMeL Next ( ) ) { Property CaMeL Defn member CaMeL Defn = ( Property CaMeL Defn ) iter . next ( ) ; if ( member CaMeL Defn . get CaMeL Type CaMeL Code ( ) == Property CaMeL Type . NAME _ TYPE ) { unique CaMeL Member = member CaMeL Defn ; break ; } } Hash CaMeL Set values = new Hash CaMeL Set ( ) ; / / Check whe@@ ther there two structure has the same value of / / the unique member . for ( int i = 0 ; i < list . size ( ) ; i ++ ) { Structure struct = ( Structure ) list . get ( i ) ; if ( check CaMeL List ) error CaMeL List . add CaMeL All ( struct . validate ( module , element ) ) ; if ( unique CaMeL Member != null ) { String value = ( String ) struct . get CaMeL Property ( module , unique CaMeL Member ) ; if ( values . contains ( value ) ) { if ( check CaMeL List ) error CaMeL List . add ( new Property CaMeL Value CaMeL Exception ( element , prop CaMeL Defn , value , Property CaMeL Value CaMeL Exception . DESIGN _ EXCEPTION _ VALUE _ EXISTS ) ) ; } else { values . add ( value ) ; } } } / / If the to CaMeL Add structure is added the structure list , check whe@@ ther / / there is a structure in the list has the same value of the unique / / member . if ( unique CaMeL Member != null && to CaMeL Add != null ) { String value = ( String ) to CaMeL Add . get CaMeL Property ( module , unique CaMeL Member ) ; if ( values . contains ( value ) ) { error CaMeL List . add ( new Property CaMeL Value CaMeL Exception ( element , prop CaMeL Defn . get CaMeL Name ( ) , value , Property CaMeL Value CaMeL Exception . DESIGN _ EXCEPTION _ VALUE _ EXISTS ) ) ; } } return error CaMeL List ; }	Iterator iter = prop CaMeL Defn . get CaMeL Struct CaMeL Defn ( ) . get CaMeL Property CaMeL Iterator ( ) ; while ( iter . has CaMeL Next ( ) )
if ( mode . equals CaMeL Ignore CaMeL Case ( C _ COPY@@ MODE _ SIBLING ) ) {  <CTX>  public void set CaMeL Dialog CaMeL Copy CaMeL Folder CaMeL Mode ( String mode ) { int copy CaMeL Mode = I _ Cms CaMeL Constants . C _ COPY _ AS _ NEW ; if ( mode . equals CaMeL Ignore CaMeL Case ( C _ COPY@@ MODE _ SIBLING ) ) { copy CaMeL Mode = I _ Cms CaMeL Constants . C _ COPY _ AS _ SIBLING ; } else if ( mode . equals CaMeL Ignore CaMeL Case ( C _ COPY@@ MODE _ PRESERVE ) ) { copy CaMeL Mode = I _ Cms CaMeL Constants . C _ COPY _ PRESERVE _ SIBLING ; } set CaMeL Dialog CaMeL Copy CaMeL Folder CaMeL Mode ( copy CaMeL Mode ) ; }	if ( mode . equals CaMeL Ignore CaMeL Case ( COPY@@ MODE _ SIBLING ) ) {
if ( suggest CaMeL Reset )  <CTX>  public void remove CaMeL Extension ( I CaMeL Extension extension , Object [ ] objects ) { boolean suggest CaMeL Reset = false ; for ( int i = 0 ; i < objects . length ; i ++ ) { if ( objects [ i ] instanceof Dirty CaMeL Perspective CaMeL Marker ) { String id = ( ( Dirty CaMeL Perspective CaMeL Marker ) objects [ i ] ) . perspective CaMeL Id ; if ( ! dirty CaMeL Perspectives . remove ( id ) ) / / if we are dirty , cancel the dirty state dirty CaMeL Perspectives . add ( id ) ; / / otherwise we will be dirty Perspective CaMeL Descriptor per@@ sp = ( Perspective CaMeL Descriptor ) get CaMeL Perspective ( ) ; if ( per@@ sp == null || per@@ sp . has CaMeL Custom CaMeL Definition ( ) ) continue ; if ( per@@ sp . get CaMeL Id ( ) . equals ( id ) ) suggest CaMeL Reset = true ; } } if ( suggest CaMeL Reset ) suggest CaMeL Reset ( ) ; }	if ( suggest CaMeL Reset ) {
d = Math . ceil ( d ) ; break ;  <CTX>  public Real CaMeL Num to CaMeL Int ( int rounding _ mode ) { double d = double CaMeL Value ( ) ; switch ( rounding _ mode ) { case FLOOR : d = Math . floor ( d ) ; break ; case CEILING : d = Math . ceil ( d ) ; break ; case TRUNCATE : d = d < 0 . 0 ? Math . ceil ( d ) : Math . floor ( d ) ; break ; case ROUND : d -= Math . IEE CaMeL Eremainder ( d , 1 . 0 ) ; break ; } return new D CaMeL F@@ lo CaMeL Num ( d ) ; }	return Math . ceil ( d ) ;
if ( ! adaptee . is CaMeL Initialised ( ) ) {  <CTX>  public void engine CaMeL Next CaMeL Bytes ( byte [ ] bytes ) { if ( ! adaptee . is CaMeL Initialised ( ) ) { this . engine CaMeL Set CaMeL Seed ( new byte [ 0 ] ) ; } try { adaptee . next CaMeL Bytes ( bytes , 0 , bytes . length ) ; } catch ( Limit CaMeL Reached CaMeL Exception ignored ) { } }	if ( ! adaptee . is CaMeL Initialised ( ) )
return aci . current ( ) ;  <CTX>  public char previous ( ) { if ( get CaMeL Index ( ) > begin ) { return aci . previous ( ) ; } else { return aci . current ( ) ; } }	return Character CaMeL Iterator . DONE ;
if ( b@@ rought CaMeL To CaMeL Top )  <CTX>  public void bring CaMeL To CaMeL Top ( I CaMeL Workbench CaMeL Part part ) { / / Sanity check . Perspective per@@ sp = get CaMeL Active CaMeL Perspective ( ) ; if ( per@@ sp == null || ! cer@@ tify CaMeL Part ( part ) ) return ; / / If zoomed then ignore . if ( is CaMeL Zoomed ( ) && part CaMeL Change CaMeL A@@ ffects CaMeL Zoom ( part ) ) return ; / / Move part . boolean b@@ rought CaMeL To CaMeL Top = false ; if ( part instanceof I CaMeL Editor CaMeL Part ) { b@@ rought CaMeL To CaMeL Top = get CaMeL Editor CaMeL Manager ( ) . set CaMeL Visible CaMeL Editor ( ( I CaMeL Editor CaMeL Part ) part , false ) ; if ( last CaMeL Active CaMeL Editor != null && b@@ rought CaMeL To CaMeL Top ) { String new CaMeL ID = part . get CaMeL Site ( ) . get CaMeL Id ( ) ; String old CaMeL ID = last CaMeL Active CaMeL Editor . get CaMeL Site ( ) . get CaMeL Id ( ) ; if ( new CaMeL ID != old CaMeL ID ) { deactivate CaMeL Last CaMeL Editor ( ) ; last CaMeL Active CaMeL Editor = null ; update CaMeL Action CaMeL Bars ( ) ; } } } else if ( part instanceof I CaMeL View CaMeL Part ) { b@@ rought CaMeL To CaMeL Top = per@@ sp . bring CaMeL To CaMeL Top ( ( I CaMeL View CaMeL Part ) part ) ; } if ( b@@ rought CaMeL To CaMeL Top ) fire CaMeL Part CaMeL Brought CaMeL To CaMeL Top ( part ) ; }	if ( b@@ rought CaMeL To CaMeL Top ) { activation CaMeL List . set CaMeL Active ( part ) ;
Object old ; if ( value != null ) old = super . put ( key , value ) ; else old = super . remove ( key ) ;  <CTX>  public Object put ( Object key , Object value ) { Object old ; if ( value != null ) old = super . put ( key , value ) ; else old = super . remove ( key ) ; if ( key instanceof String && old != value ) fire CaMeL Property CaMeL Change ( ( String ) key , old , value ) ; return old ; }	Object old = check CaMeL And CaMeL Put ( key , value ) ;
m CaMeL Was CaMeL On CaMeL Air = Program CaMeL Utilities . is CaMeL On CaMeL Air ( this ) ; return m CaMeL Was CaMeL On CaMeL Air ;  <CTX>  public boolean is CaMeL On CaMeL Air ( ) { m CaMeL Was CaMeL On CaMeL Air = Program CaMeL Utilities . is CaMeL On CaMeL Air ( this ) ; return m CaMeL Was CaMeL On CaMeL Air ; }	return Program CaMeL Utilities . is CaMeL On CaMeL Air ( this ) ;
queue . add CaMeL Last ( token ) ; }  <CTX>  public void push ( Object token ) { queue . add CaMeL Last ( token ) ; }	try { queue [ ++ rear ] = token ; items ++ ; } catch ( Array CaMeL Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception ex ) { Object [ ] hold CaMeL Queue = new Object [ max + max CaMeL Increment ] ; System . arraycopy ( queue , 0 , hold CaMeL Queue , 0 , max ) ; queue = hold CaMeL Queue ; max += max CaMeL Increment ; queue [ rear ] = token ; items ++ ; } }
void translate CaMeL From ( Series source CaMeL Series , Chart chart ) ;  <CTX>  void translate CaMeL From ( Series source CaMeL Series , Chart chart ) ;	void translate CaMeL From ( Series source CaMeL Series , int i CaMeL Series CaMeL Definition CaMeL Index , Chart chart ) ;
Elf . Symbol [ ] ret = ( Elf . Symbol [ ] ) v . to CaMeL Array ( new Elf . Symbol [ 0 ] ) ; Arrays . sort ( ret , new Symbol CaMeL Sort CaMeL Compare ( ) ) ; return ret ; }  <CTX>  public Elf . Symbol [ ] get CaMeL External CaMeL Objects ( ) throws IO CaMeL Exception { Vector v = new Vector ( ) ; load CaMeL Symbols ( ) ; load CaMeL Sections ( ) ; for ( int i = 0 ; i < dyn@@ syms . length ; i ++ ) { if ( dyn@@ syms [ i ] . st _ bind ( ) == Elf . Symbol . ST@@ B _ GLOBAL && dyn@@ syms [ i ] . st _ type ( ) == Elf . Symbol . ST@@ T _ OBJECT ) { int idx = dyn@@ syms [ i ] . st _ sh@@ ndx ; if ( idx < 0 ) continue ; if ( sections [ idx ] . sh _ type == Elf . Section . SH@@ T _ NULL ) v . add ( dyn@@ syms [ i ] ) ; } } Elf . Symbol [ ] ret = ( Elf . Symbol [ ] ) v . to CaMeL Array ( new Elf . Symbol [ 0 ] ) ; Arrays . sort ( ret , new Symbol CaMeL Sort CaMeL Compare ( ) ) ; return ret ; }	if ( sections [ idx ] . sh _ type == Elf . Section . SH@@ T _ NULL ) v . add ( dyn@@ syms [ i ] ) ; } } Elf . Symbol [ ] ret = ( Elf . Symbol [ ] ) v . to CaMeL Array ( new Elf . Symbol [ 0 ] ) ; Arrays . sort ( ret , new Symbol CaMeL Sort CaMeL Compare ( ) ) ; return ret ; }
Tree [ ] new CaMeL Class CaMeL Parents = gen . mk CaMeL Parent CaMeL Constr@@ s ( class CaMeL Def . pos , new CaMeL Parents , parent CaMeL Args ) ;  <CTX>  protected Tree make CaMeL Class ( Class CaMeL Def class CaMeL Def ) { Symbol iface CaMeL Sym = class CaMeL Def . symbol ( ) ; Symbol class CaMeL Sym = phase . get CaMeL Class CaMeL Symbol ( iface CaMeL Sym ) ; Tree CaMeL List new CaMeL Class CaMeL Body = new Tree CaMeL List ( ) ; Template class CaMeL Impl = class CaMeL Def . impl ; Tree [ ] class CaMeL Body = class CaMeL Impl . body ; Map class CaMeL Member CaMeL Map = phase . get CaMeL Class CaMeL Member CaMeL Map ( class CaMeL Sym ) ; assert this CaMeL Type CaMeL Subst == null ; this CaMeL Type CaMeL Subst = new Type . Subst CaMeL This CaMeL Map ( iface CaMeL Sym , class CaMeL Sym ) ; for ( int i = 0 ; i < class CaMeL Body . length ; ++ i ) { Tree t = class CaMeL Body [ i ] ; Symbol t CaMeL Sym = t . symbol ( ) ; if ( t . defines CaMeL Symbol ( ) && ! ( class CaMeL Member CaMeL Map . contains CaMeL Key ( t CaMeL Sym ) || t CaMeL Sym . is CaMeL Constructor ( ) ) ) continue ; Tree new CaMeL T = transform ( t ) ; if ( t . defines CaMeL Symbol ( ) && class CaMeL Member CaMeL Map . contains CaMeL Key ( t CaMeL Sym ) ) new CaMeL T . set CaMeL Symbol ( ( Symbol ) class CaMeL Member CaMeL Map . get ( t CaMeL Sym ) ) ; new CaMeL Class CaMeL Body . append ( new CaMeL T ) ; } this CaMeL Type CaMeL Subst = null ; Tree [ ] [ ] old CaMeL Parent CaMeL Args = extract CaMeL Parent CaMeL Args ( class CaMeL Impl . parents ) ; Tree [ ] [ ] parent CaMeL Args = new Tree [ old CaMeL Parent CaMeL Args . length + 1 ] [ ] ; System . arraycopy ( old CaMeL Parent CaMeL Args , 0 , parent CaMeL Args , 0 , old CaMeL Parent CaMeL Args . length ) ; parent CaMeL Args [ old CaMeL Parent CaMeL Args . length ] = Tree . EMPTY _ ARRAY ; global . next CaMeL Phase ( ) ; Type [ ] new CaMeL Parents = class CaMeL Sym . parents ( ) ; global . prev CaMeL Phase ( ) ; Tree [ ] new CaMeL Class CaMeL Parents = gen . mk CaMeL Parent CaMeL Constr@@ s ( class CaMeL Def . pos , new CaMeL Parents , parent CaMeL Args ) ; Symbol local = class CaMeL Def . impl . symbol ( ) ; local . set CaMeL Owner ( class CaMeL Sym ) ; return gen . Class CaMeL Def ( class CaMeL Sym , new CaMeL Class CaMeL Parents , local , new CaMeL Class CaMeL Body . to CaMeL Array ( ) ) ; }	new CaMeL Parents [ new CaMeL Parents . length - 1 ] = gen . mk CaMeL Parent CaMeL Constr ( class CaMeL Def . pos , iface CaMeL Type ) ;
image . set CaMeL Source CaMeL And CaMeL Clear CaMeL Size ( new Image CaMeL Domain CaMeL Object . File CaMeL Document CaMeL Image CaMeL Source ( document CaMeL Mapper . get CaMeL Document CaMeL Reference ( file CaMeL Document . get CaMeL Id ( ) ) ) ) ;  <CTX>  private void go CaMeL To CaMeL Image CaMeL Adder ( final Document CaMeL Mapper document CaMeL Mapper , final Text CaMeL Document CaMeL Domain CaMeL Object document , User CaMeL Domain CaMeL Object user , final Image CaMeL Domain CaMeL Object image , final int image CaMeL Index , Http CaMeL Servlet CaMeL Request request , Http CaMeL Servlet CaMeL Response response ) throws IO CaMeL Exception , Servlet CaMeL Exception { File CaMeL Document CaMeL Domain CaMeL Object file CaMeL Document = ( File CaMeL Document CaMeL Domain CaMeL Object ) document CaMeL Mapper . create CaMeL Document CaMeL Of CaMeL Type CaMeL From CaMeL Parent ( Document CaMeL Domain CaMeL Object . DOCTYPE _ FILE , document , user ) ; final Edit CaMeL File CaMeL Document CaMeL Page CaMeL Flow . Array CaMeL Mime CaMeL Type CaMeL Restriction mime CaMeL Type CaMeL Restriction = new Edit CaMeL File CaMeL Document CaMeL Page CaMeL Flow . Array CaMeL Mime CaMeL Type CaMeL Restriction ( IMAGE _ MIME _ TYPES , ERROR _ MESSAGE _ _ _ ONLY _ ALLOWED _ TO _ UPLOAD _ IMAGES ) ; Document CaMeL Page CaMeL Flow . Save CaMeL Document CaMeL Command save CaMeL New CaMeL Image CaMeL File CaMeL Document = new Create CaMeL Document CaMeL Page CaMeL Flow . Save CaMeL Document CaMeL Command ( ) { public void save CaMeL Document ( Document CaMeL Domain CaMeL Object document , User CaMeL Domain CaMeL Object user ) { File CaMeL Document CaMeL Domain CaMeL Object file CaMeL Document = ( File CaMeL Document CaMeL Domain CaMeL Object ) document ; Map files = file CaMeL Document . get CaMeL Files ( ) ; for ( Iterator iterator = files . values ( ) . iterator ( ) ; iterator . has CaMeL Next ( ) ; ) { File CaMeL Document CaMeL Domain CaMeL Object . File CaMeL Document CaMeL File file = ( File CaMeL Document CaMeL Domain CaMeL Object . File CaMeL Document CaMeL File ) iterator . next ( ) ; file . set CaMeL Created CaMeL As CaMeL Image ( true ) ; } File CaMeL Document CaMeL Domain CaMeL Object . File CaMeL Document CaMeL File file = ( File CaMeL Document CaMeL Domain CaMeL Object . File CaMeL Document CaMeL File ) files . values ( ) . iterator ( ) . next ( ) ; if ( null != file ) { file CaMeL Document . set CaMeL Headline ( file . get CaMeL Filename ( ) ) ; file CaMeL Document . set CaMeL Status ( Document CaMeL Domain CaMeL Object . STATUS _ PUBLICATION _ APPRO@@ VED ) ; document CaMeL Mapper . save CaMeL New CaMeL Document ( document , user ) ; image . set CaMeL Source CaMeL And CaMeL Clear CaMeL Size ( new Image CaMeL Domain CaMeL Object . File CaMeL Document CaMeL Image CaMeL Source ( document CaMeL Mapper . get CaMeL Document CaMeL Reference ( file CaMeL Document . get CaMeL Id ( ) ) ) ) ; } } } ; Dispatch CaMeL Command return CaMeL To CaMeL Image CaMeL Edit CaMeL Page CaMeL Command = new Dispatch CaMeL Command ( ) { public void dispatch ( Http CaMeL Servlet CaMeL Request request , Http CaMeL Servlet CaMeL Response response ) throws IO CaMeL Exception , Servlet CaMeL Exception { go CaMeL To CaMeL Image CaMeL Edit CaMeL Page ( document , image CaMeL Index , image , request , response ) ; } } ; Document CaMeL Page CaMeL Flow page CaMeL Flow = new Edit CaMeL File CaMeL Document CaMeL Page CaMeL Flow ( file CaMeL Document , get CaMeL Servlet CaMeL Context ( ) , return CaMeL To CaMeL Image CaMeL Edit CaMeL Page CaMeL Command , save CaMeL New CaMeL Image CaMeL File CaMeL Document , mime CaMeL Type CaMeL Restriction ) ; page CaMeL Flow . dispatch ( request , response ) ; }	image . set CaMeL Source CaMeL And CaMeL Clear CaMeL Size ( new Image CaMeL Domain CaMeL Object . File CaMeL Document CaMeL Image CaMeL Source ( document CaMeL Mapper . get CaMeL Document CaMeL Reference ( file CaMeL Document ) ) ) ;
Operation CaMeL History CaMeL Event . ABOUT _ TO _ UNDO , this , operation ) ;  <CTX>  protected void notify CaMeL About CaMeL To CaMeL Undo ( I CaMeL Undoable CaMeL Operation operation ) { Operation CaMeL History CaMeL Event event = new Operation CaMeL History CaMeL Event ( Operation CaMeL History CaMeL Event . ABOUT _ TO _ UNDO , this , operation ) ; for ( int i = 0 ; i < f CaMeL Listeners . size ( ) ; i ++ ) ( ( I CaMeL Operation CaMeL History CaMeL Listener ) f CaMeL Listeners . get ( i ) ) . history CaMeL Notification ( event ) ; }	Operation CaMeL History CaMeL Event . ABOUT _ TO _ UNDO , this , op ) ; pre CaMeL Notify CaMeL Operation ( op , event ) ;
this . input = input ; return reset ( ) ;  <CTX>  public Matcher reset ( Char CaMeL Sequence input ) { this . input = input ; return reset ( ) ; }	position = 0 ; match = null ; return this ;
view CaMeL Form CaMeL Top CaMeL Left CaMeL Proxy . set CaMeL Target ( null ) ;  <CTX>  public void set CaMeL Top CaMeL Left ( Control top CaMeL Left ) { if ( top CaMeL Left CaMeL Cache . get CaMeL Control ( ) == top CaMeL Left ) { return ; } remove CaMeL Dispose CaMeL Listener ( top CaMeL Left CaMeL Cache . get CaMeL Control ( ) ) ; top CaMeL Left CaMeL Cache . set CaMeL Control ( top CaMeL Left ) ; / / The top - left control always go@@ es directly in the View CaMeL Form if ( top CaMeL Left != null ) { top CaMeL Left . add CaMeL Dispose CaMeL Listener ( pre@@ mature CaMeL Dispose CaMeL Listener ) ; view CaMeL Form CaMeL Top CaMeL Left CaMeL Proxy . set CaMeL Target ( top CaMeL Left CaMeL Cache ) ; view CaMeL Form . set CaMeL Top CaMeL Left ( view CaMeL Form CaMeL Top CaMeL Left CaMeL Proxy . get CaMeL Control ( ) ) ; } else { view CaMeL Form CaMeL Top CaMeL Left CaMeL Proxy . set CaMeL Target ( null ) ; view CaMeL Form . set CaMeL Top CaMeL Left ( null ) ; } }	view CaMeL Form CaMeL Top CaMeL Left CaMeL Proxy . set CaMeL Target CaMeL Control ( null ) ;
return new Cached CaMeL Result CaMeL Set ( this , result CaMeL Metadata , rs ) ;  <CTX>  public I CaMeL Result CaMeL Iterator execute ( ) throws Data CaMeL Exception { assert oda CaMeL Statement != null ; this . set CaMeL Input CaMeL Parameter CaMeL Binding ( ) ; / / Execute the prepared statement if ( ! oda CaMeL Statement . execute ( ) ) throw new Data CaMeL Exception ( Resource CaMeL Constants . NO _ RESULT _ SET ) ; Result CaMeL Set rs = oda CaMeL Statement . get CaMeL Result CaMeL Set ( ) ; / / If we did not get a result set metadata at prepare ( ) time , get it now if ( result CaMeL Metadata == null ) { result CaMeL Metadata = rs . get CaMeL Meta CaMeL Data ( ) ; if ( result CaMeL Metadata == null ) throw new Data CaMeL Exception ( Resource CaMeL Constants . METADATA _ NOT _ AVAILABLE ) ; } / / Initialize Cached CaMeL Result CaMeL Set using the ODA result set if ( Data CaMeL Set CaMeL Cache CaMeL Manager . get CaMeL Instance ( ) . does CaMeL Save CaMeL To CaMeL Cache ( ) == false ) return new Cached CaMeL Result CaMeL Set ( this , result CaMeL Metadata , rs ) ; else return new Cached CaMeL Result CaMeL Set ( this , result CaMeL Metadata , new Data CaMeL Set CaMeL Result CaMeL Cache ( rs , result CaMeL Metadata ) ) ; }	return new Cached CaMeL Result CaMeL Set ( this , result CaMeL Metadata , rs , event CaMeL Handler ) ;
instance . add ( path , members ) ;  <CTX>  public static void add ( String text , String path ) { Ruby CaMeL Members members = Ruby CaMeL Parser . get CaMeL Members ( text , path , null , true ) ; instance . add ( path , members ) ; }	if ( ! members . contains CaMeL Errors ( ) ) { instance . add ( path , members ) ; }
Collections . sort ( prop CaMeL List , new Comple@@ ti@@ tion CaMeL Proposal CaMeL Comparator ( ) ) ;  <CTX>  public void add CaMeL Template CaMeL Proposals ( I CaMeL Text CaMeL Viewer viewer , int document CaMeL Offset , List prop CaMeL List ) { I CaMeL Completion CaMeL Proposal [ ] template CaMeL Proposals = compute CaMeL Completion CaMeL Proposals ( viewer , document CaMeL Offset ) ; for ( int j = 0 ; j < template CaMeL Proposals . length ; j ++ ) { prop CaMeL List . add ( template CaMeL Proposals [ j ] ) ; } Collections . sort ( prop CaMeL List , new Comple@@ ti@@ tion CaMeL Proposal CaMeL Comparator ( ) ) ; }	Collections . sort ( prop CaMeL List , new Completion CaMeL Proposal CaMeL Comparator ( ) ) ;
return new Big CaMeL Decimal ( ( ( Double ) obj ) . double CaMeL Value ( ) ) . set CaMeL Scale ( 16 , Big CaMeL Decimal . ROUND _ DOWN ) ;  <CTX>  public Object convert ( Object obj , String param ) { return new Big CaMeL Decimal ( ( ( Double ) obj ) . double CaMeL Value ( ) ) . set CaMeL Scale ( 16 , Big CaMeL Decimal . ROUND _ DOWN ) ; }	return new Big CaMeL Decimal ( ( ( Double ) obj ) . to CaMeL String ( ) ) ;
if ( ! is CaMeL List CaMeL Index CaMeL Expression ( ref , collection ) ) { index CaMeL Variable CaMeL Used CaMeL Only CaMeL As CaMeL Index = false ; }  <CTX>  public void visit CaMeL Reference CaMeL Expression ( @ Not CaMeL Null Psi CaMeL Reference CaMeL Expression ref ) { if ( ! index CaMeL Variable CaMeL Used CaMeL Only CaMeL As CaMeL Index ) { return ; } super . visit CaMeL Reference CaMeL Expression ( ref ) ; final Psi CaMeL Element element = ref . resolve ( ) ; if ( ! index CaMeL Variable . equals ( element ) ) { return ; } if ( ! is CaMeL List CaMeL Index CaMeL Expression ( ref , collection ) ) { index CaMeL Variable CaMeL Used CaMeL Only CaMeL As CaMeL Index = false ; } }	if ( collection . equals ( element ) && ! is CaMeL List CaMeL Reference CaMeL In CaMeL Index CaMeL Expression ( ref , collection ) ) { index CaMeL Variable CaMeL Used CaMeL Only CaMeL As CaMeL Index = false ; }
_ interactions CaMeL Pane . request CaMeL Focus ( ) ;  <CTX>  public void request CaMeL Focus ( ) { _ interactions CaMeL Pane . request CaMeL Focus ( ) ; }	_ console CaMeL Pane . request CaMeL Focus ( ) ;
case Id _ to CaMeL String : return real CaMeL This ( this CaMeL Obj , f ) . js CaMeL Function _ to CaMeL String ( to CaMeL Base ( args , 0 ) ) ;  <CTX>  public Object exec CaMeL Method ( int method CaMeL Id , Id CaMeL Function f , Context cx , Scriptable scope , Scriptable this CaMeL Obj , Object [ ] args ) throws Java CaMeL Script CaMeL Exception { switch ( method CaMeL Id ) { case Id _ constructor : return js CaMeL Constructor ( args , this CaMeL Obj == null ) ; case Id _ to CaMeL String : return real CaMeL This ( this CaMeL Obj , f ) . js CaMeL Function _ to CaMeL String ( to CaMeL Base ( args , 0 ) ) ; case Id _ value CaMeL Of : return wrap _ double ( real CaMeL This ( this CaMeL Obj , f ) . js CaMeL Function _ value CaMeL Of ( ) ) ; case Id _ to CaMeL Locale CaMeL String : return real CaMeL This ( this CaMeL Obj , f ) . js CaMeL Function _ to CaMeL Locale CaMeL String ( to CaMeL Base ( args , 0 ) ) ; case Id _ to CaMeL Fixed : return real CaMeL This ( this CaMeL Obj , f ) . js CaMeL Function _ to CaMeL Fixed ( cx , args ) ; case Id _ to CaMeL Exponential : return real CaMeL This ( this CaMeL Obj , f ) . js CaMeL Function _ to CaMeL Exponential ( cx , args ) ; case Id _ to CaMeL Precision : return real CaMeL This ( this CaMeL Obj , f ) . js CaMeL Function _ to CaMeL Precision ( cx , args ) ; } return super . exec CaMeL Method ( method CaMeL Id , f , cx , scope , this CaMeL Obj , args ) ; }	case Id _ value CaMeL Of : return wrap _ double ( real CaMeL This ( this CaMeL Obj , f ) . js CaMeL Function _ value CaMeL Of ( ) ) ;
holder = holder CaMeL Factory . create CaMeL Holder ( official _ type ) ;  <CTX>  public void from _ any ( Any an _ any ) throws Type CaMeL Mismatch , Invalid CaMeL Value { check CaMeL Type ( official _ type , an _ any . type ( ) ) ; Streamable a _ holder = an _ any . extract _ Streamable ( ) ; if ( a _ holder == null ) { throw new Invalid CaMeL Value ( IS@@ NULL ) ; } else if ( a _ holder instanceof universal CaMeL Holder ) { holder = holder CaMeL Factory . create CaMeL Holder ( official _ type ) ; if ( holder == null ) holder = holder CaMeL Factory . create CaMeL Holder ( final _ type ) ; if ( holder == null ) holder = ( ( universal CaMeL Holder ) a _ holder ) . Clone ( ) ; else { Input CaMeL Stream in = an _ any . create _ input _ stream ( ) ; holder . _ read ( in ) ; try { in . close ( ) ; } catch ( IO CaMeL Exception ex ) { throw new Unexpected ( ex ) ; } } } else { try { Input CaMeL Stream in = an _ any . create _ input _ stream ( ) ; holder = ( Streamable ) a _ holder . get CaMeL Class ( ) . new CaMeL Instance ( ) ; holder . _ read ( in ) ; in . close ( ) ; } catch ( Exception ex ) { Type CaMeL Mismatch t = new Type CaMeL Mismatch ( ) ; t . init CaMeL Cause ( ex ) ; throw t ; } } value CaMeL Changed ( ) ; }	holder = Holder CaMeL Locator . create CaMeL Holder ( official _ type ) ;
resolved = structure ;  <CTX>  public void resolve ( Structure structure ) { name = null ; resolved = structure ; }	resolved = ( Structure ) structure ;
return field _ 1 _ footer _ len ;  <CTX>  public byte get CaMeL Footer CaMeL Length ( ) { return field _ 1 _ footer _ len ; }	return ( short ) ( 0 x CaMeL FF & field _ 1 _ footer _ len ) ;
if ( jq . Bootstr@@ apping ) return obj _ trav . get CaMeL Instance CaMeL Field CaMeL Value ( o , f ) ;  <CTX>  public static Object getfield ( Object o , jq _ Instance CaMeL Field f ) { if ( jq . Bootstr@@ apping ) return obj _ trav . get CaMeL Instance CaMeL Field CaMeL Value ( o , f ) ; jq _ Type t = f . get CaMeL Type ( ) ; if ( t . is CaMeL Reference CaMeL Type ( ) ) return getfield _ A ( o , f ) ; if ( t == jq _ Primitive . INT ) return new Integer ( getfield _ I ( o , f ) ) ; if ( t == jq _ Primitive . FLOAT ) return new Float ( getfield _ F ( o , f ) ) ; if ( t == jq _ Primitive . LONG ) return new Long ( getfield _ L ( o , f ) ) ; if ( t == jq _ Primitive . DOUBLE ) return new Double ( getfield _ D ( o , f ) ) ; if ( t == jq _ Primitive . BYTE ) return new Byte ( getfield _ B ( o , f ) ) ; if ( t == jq _ Primitive . CHAR ) return new Character ( getfield _ C ( o , f ) ) ; if ( t == jq _ Primitive . SHORT ) return new Short ( getfield _ S ( o , f ) ) ; if ( t == jq _ Primitive . BOOLEAN ) return new Boolean ( getfield _ Z ( o , f ) ) ; jq . UNREACHABLE ( ) ; return null ; }	if ( ! jq . Running CaMeL Native ) return obj _ trav . get CaMeL Instance CaMeL Field CaMeL Value ( o , f ) ;
{ super ( ) ; extended CaMeL Meta CaMeL Data = Extended CaMeL Meta CaMeL Data . INSTANCE ; }  <CTX>  public Type CaMeL Resource CaMeL Factory CaMeL Impl ( ) { super ( ) ; extended CaMeL Meta CaMeL Data = Extended CaMeL Meta CaMeL Data . INSTANCE ; }	{ super ( ) ; }
if ( ! modifiable )  <CTX>  public String get CaMeL Private CaMeL Key ( ) { if ( ! modifiable ) return null ; return private CaMeL Key ; }	if ( ! this . modifiable )
Element CaMeL Defn obj = ( ( Element CaMeL Defn ) type ) . parent ;  <CTX>  public boolean is CaMeL Kind CaMeL Of ( I CaMeL Element CaMeL Defn type ) { if ( type == this ) return true ; if ( type == null ) return false ; Element CaMeL Defn obj = ( ( Element CaMeL Defn ) type ) . parent ; while ( obj != null ) { if ( obj == this ) return true ; obj = obj . parent ; } return false ; }	Element CaMeL Defn obj = this . parent ;
sink . text ( caption ) ;  <CTX>  protected void table CaMeL Caption ( String caption ) { sink . table CaMeL Caption ( ) ; sink . text ( caption ) ; sink . table CaMeL Caption _ ( ) ; }	text ( caption ) ;
boolean string CaMeL Is CaMeL Compilable CaMeL Unit ( String str ) {  <CTX>  boolean string CaMeL Is CaMeL Compilable CaMeL Unit ( String str ) { Dim CaMeL I CaMeL Proxy action = new Dim CaMeL I CaMeL Proxy ( this , I@@ PROXY _ STRING _ IS _ COMPI@@ LABLE ) ; action . text = str ; action . with CaMeL Context ( ) ; return action . boolean CaMeL Result ; }	public boolean string CaMeL Is CaMeL Compilable CaMeL Unit ( String str ) {
return 0 ;  <CTX>  public int get CaMeL Selection CaMeL Mode ( ) { return 0 ; / / TODO }	return selection CaMeL Mode ;
Iterator itr = listeners . iterator ( ) ; while ( itr . has CaMeL Next ( ) ) { Thread CaMeL Listener listener = ( Thread CaMeL Listener ) itr . next ( ) ;  <CTX>  synchronized void notify CaMeL Right CaMeL Given ( Scheduler scheduler ) { String id = scheduler . get CaMeL Name ( ) ; Iterator itr = listeners . iterator ( ) ; while ( itr . has CaMeL Next ( ) ) { Thread CaMeL Listener listener = ( Thread CaMeL Listener ) itr . next ( ) ; listener . right CaMeL Given ( id ) ; } }	for ( int i = 0 , n = listeners . size ( ) ; i < n ; i ++ ) { Thread CaMeL Listener listener = ( Thread CaMeL Listener ) listeners . get ( i ) ;
return context . declaration . get CaMeL Extractor ( ) . get CaMeL Double CaMeL Value ( left ) < ( ( Double CaMeL Variable CaMeL Context CaMeL Entry ) context ) . right ;  <CTX>  public boolean evaluate CaMeL Cached CaMeL Right ( final Variable CaMeL Context CaMeL Entry context , final Object left ) { / / TODO : we are not handling delta right now . . . maybe we should return context . declaration . get CaMeL Extractor ( ) . get CaMeL Double CaMeL Value ( left ) < ( ( Double CaMeL Variable CaMeL Context CaMeL Entry ) context ) . right ; }	return context . get CaMeL Variable CaMeL Declaration ( ) . get CaMeL Extractor ( ) . get CaMeL Double CaMeL Value ( left ) < ( ( Double CaMeL Variable CaMeL Context CaMeL Entry ) context ) . right ;
if ( Oda CaMeL Data CaMeL Source . PRIVATE _ DRIVER _ PROPERTIES _ PROP  <CTX>  Extended CaMeL Property CaMeL State ( Module CaMeL Parser CaMeL Handler the CaMeL Handler , Design CaMeL Element element , Property CaMeL Defn prop CaMeL Defn , Array CaMeL List list ) { super ( the CaMeL Handler , element , prop CaMeL Defn , list ) ; / / till now , there is structure ODA CaMeL Property can be written as / / ex - property . if ( Oda CaMeL Data CaMeL Source . PRIVATE _ DRIVER _ PROPERTIES _ PROP . equals CaMeL Ignore CaMeL Case ( prop CaMeL Defn . get CaMeL Name ( ) ) ) struct = new Extended CaMeL Property ( ) ; else handler . get CaMeL Error CaMeL Handler ( ) . semantic CaMeL Error ( new Design CaMeL Parser CaMeL Exception ( Design CaMeL Parser CaMeL Exception . DESIGN _ EXCEPTION _ WRONG _ EXTENDED _ PROPERTY _ TYPE ) ) ; }	if ( I CaMeL Oda CaMeL Data CaMeL Source CaMeL Model . PRIVATE _ DRIVER _ PROPERTIES _ PROP
return ( pos < array . length ) ;  <CTX>  public boolean has CaMeL Next ( ) { return ( pos < array . length ) ; }	return ( pos < size ) ;
Ruby CaMeL Numeric other = numeric CaMeL Value ( num ) ; if ( other instanceof Ruby CaMeL Float ) { return Ruby CaMeL Float . new CaMeL Float ( get CaMeL Runtime ( ) , get CaMeL Double CaMeL Value ( ) ) . op _ mul ( other ) ; } return big CaMeL Norm ( get CaMeL Runtime ( ) , get CaMeL Value ( ) . multiply ( big CaMeL Int CaMeL Value ( other ) ) ) ;  <CTX>  public Ruby CaMeL Numeric op _ mul ( I CaMeL Ruby CaMeL Object num ) { Ruby CaMeL Numeric other = numeric CaMeL Value ( num ) ; if ( other instanceof Ruby CaMeL Float ) { return Ruby CaMeL Float . new CaMeL Float ( get CaMeL Runtime ( ) , get CaMeL Double CaMeL Value ( ) ) . op _ mul ( other ) ; } return big CaMeL Norm ( get CaMeL Runtime ( ) , get CaMeL Value ( ) . multiply ( big CaMeL Int CaMeL Value ( other ) ) ) ; }	return numeric CaMeL Value ( num ) . multiply CaMeL With ( this ) ;
this ( new com . ex@@ edi@@ o . cope . Attribute CaMeL Value [ ] { new com . ex@@ edi@@ o . cope . Attribute CaMeL Value ( Delete CaMeL Item . name , name ) , } ) ; throw CaMeL Initial CaMeL Mandatory CaMeL Violation CaMeL Exception ( ) ; } / * *  <CTX>  * / public Delete CaMeL Item ( final java . lang . String name ) throws com . ex@@ edi@@ o . cope . Mandatory CaMeL Violation CaMeL Exception { this ( new com . ex@@ edi@@ o . cope . Attribute CaMeL Value [ ] { new com . ex@@ edi@@ o . cope . Attribute CaMeL Value ( Delete CaMeL Item . name , name ) , } ) ; throw CaMeL Initial CaMeL Mandatory CaMeL Violation CaMeL Exception ( ) ; } / * *	this ( ) ; this . name = name ; }
String file CaMeL Name )  <CTX>  Generic CaMeL Module CaMeL Parser CaMeL Handler ( Design CaMeL Session the CaMeL Session , URL system CaMeL ID , String file CaMeL Name ) { super ( the CaMeL Session , file CaMeL Name ) ; this . system CaMeL ID = system CaMeL ID ; this . file CaMeL Name = file CaMeL Name ; }	String file CaMeL Name , Module CaMeL Option options )
Interfaces CaMeL Script CaMeL Writer ( Network CaMeL Settings configuration )  <CTX>  Interfaces CaMeL Script CaMeL Writer ( Network CaMeL Settings configuration ) { super ( ) ; this . configuration = configuration ; }	Interfaces CaMeL Script CaMeL Writer ( Network CaMeL Settings settings )
Data CaMeL Handler annotate CaMeL Data CaMeL Objects ( Tree CaMeL Image CaMeL Display [ ] nodes )  <CTX>  Data CaMeL Handler annotate CaMeL Data CaMeL Objects ( Tree CaMeL Image CaMeL Display [ ] nodes ) { Object uo ; Set to CaMeL Annotate = new Hash CaMeL Set ( ) ; for ( int i = 0 ; i < nodes . length ; i ++ ) { uo = nodes [ i ] . get CaMeL User CaMeL Object ( ) ; if ( uo instanceof Data CaMeL Object ) to CaMeL Annotate . add ( uo ) ; } data CaMeL Handler = Annotator CaMeL Factory . get CaMeL Annotator ( to CaMeL Annotate , Tree CaMeL Viewer CaMeL Agent . get CaMeL Registry ( ) ) ; return data CaMeL Handler ; }	Data CaMeL Handler annotate CaMeL Data CaMeL Objects ( J CaMeL Frame owner , Tree CaMeL Image CaMeL Display [ ] nodes )
try { Thread . current CaMeL Thread ( ) . set CaMeL Context CaMeL Class CaMeL Loader ( Portal CaMeL Class CaMeL Loader CaMeL Util . get CaMeL Class CaMeL Loader ( ) ) ; _ servlet CaMeL Context CaMeL Listener . context CaMeL Initialized ( sce ) ; } finally { Thread . current CaMeL Thread ( ) . set CaMeL Context CaMeL Class CaMeL Loader ( context CaMeL Class CaMeL Loader ) ; }  <CTX>  public void context CaMeL Initialized ( Servlet CaMeL Context CaMeL Event sce ) { Class CaMeL Loader context CaMeL Class CaMeL Loader = Thread . current CaMeL Thread ( ) . get CaMeL Context CaMeL Class CaMeL Loader ( ) ; try { Thread . current CaMeL Thread ( ) . set CaMeL Context CaMeL Class CaMeL Loader ( Portal CaMeL Class CaMeL Loader CaMeL Util . get CaMeL Class CaMeL Loader ( ) ) ; _ servlet CaMeL Context CaMeL Listener . context CaMeL Initialized ( sce ) ; } finally { Thread . current CaMeL Thread ( ) . set CaMeL Context CaMeL Class CaMeL Loader ( context CaMeL Class CaMeL Loader ) ; } }	Portal CaMeL In@@ itable CaMeL Util . init ( this ) ;
set CaMeL Title CaMeL Label ( ( ( I CaMeL Working CaMeL Set ) new CaMeL Value ) . get CaMeL Label ( ) ) ;  <CTX>  public void property CaMeL Change ( Property CaMeL Change CaMeL Event event ) { String property = event . get CaMeL Property ( ) ; if ( Working CaMeL Set CaMeL Filter CaMeL Action CaMeL Group . CHANGE _ WORKING _ SET . equals ( property ) ) { Object new CaMeL Value = event . get CaMeL New CaMeL Value ( ) ; if ( new CaMeL Value instanceof I CaMeL Working CaMeL Set ) { working CaMeL Set CaMeL Filter . set CaMeL Working CaMeL Set ( ( I CaMeL Working CaMeL Set ) new CaMeL Value ) ; set CaMeL Title CaMeL Label ( ( ( I CaMeL Working CaMeL Set ) new CaMeL Value ) . get CaMeL Label ( ) ) ; } else if ( new CaMeL Value == null ) { working CaMeL Set CaMeL Filter . set CaMeL Working CaMeL Set ( null ) ; set CaMeL Title CaMeL Label ( null ) ; } schedule CaMeL Refresh ( ) ; } }	set CaMeL Subtitle ( ( ( I CaMeL Working CaMeL Set ) new CaMeL Value ) . get CaMeL Label ( ) ) ;
on CaMeL Internal CaMeL Model CaMeL Changed ( ) ;  <CTX>  public final void model CaMeL Changed ( ) { / / Call user code on CaMeL Internal CaMeL Model CaMeL Changed ( ) ; on CaMeL Model CaMeL Changed ( ) ; }	internal CaMeL On CaMeL Model CaMeL Changed ( ) ;
Base CaMeL Output CaMeL Plugin plugin ;  <CTX>  public Base CaMeL Output CaMeL Plugin get CaMeL Output CaMeL Plugin ( final URI request CaMeL URI ) { Base CaMeL Output CaMeL Plugin plugin ; final String [ ] names = this . context . get CaMeL Bean CaMeL Names CaMeL For CaMeL Type ( plugin . get CaMeL Class ( ) ) ; for ( int i = 0 ; i < names . length ; i = i + 1 ) { plugin = ( Base CaMeL Output CaMeL Plugin ) this . context . get CaMeL Bean ( names [ i ] ) ; if ( plugin . is CaMeL Match ( request CaMeL URI ) ) { break ; } else { plugin = null ; } } if ( plugin == null ) { plugin = new Base CaMeL Output CaMeL Plugin ( ) ; } return plugin ; }	Base CaMeL Output CaMeL Plugin plugin = null ;
String local CaMeL Name ) ;  <CTX>  public boolean has CaMeL Attribute CaMeL NS ( String namespace CaMeL URI , String local CaMeL Name ) ;	String local CaMeL Name ) throws DOM CaMeL Exception ;
boolean user CaMeL Has CaMeL Right CaMeL To CaMeL Edit ( IMC CaMeL Service CaMeL Interface im@@ cref , int meta CaMeL Id ,  <CTX>  boolean user CaMeL Has CaMeL Right CaMeL To CaMeL Edit ( IMC CaMeL Service CaMeL Interface im@@ cref , int meta CaMeL Id , im@@ code . server . user . User CaMeL Domain CaMeL Object user ) { Document CaMeL Mapper document CaMeL Mapper = im@@ cref . get CaMeL Document CaMeL Mapper ( ) ; Document CaMeL Domain CaMeL Object document = document CaMeL Mapper . get CaMeL Document ( meta CaMeL Id ) ; return document CaMeL Mapper . user CaMeL Has CaMeL At CaMeL Least CaMeL Document CaMeL Read CaMeL Permission ( user , document ) && im@@ cref . check CaMeL Doc CaMeL Admin CaMeL Rights ( meta CaMeL Id , user ) ; }	boolean user CaMeL Has CaMeL Right CaMeL To CaMeL Edit ( Imcms CaMeL Services im@@ cref , int meta CaMeL Id ,
Member member = get CaMeL Member CaMeL Arg ( evaluator , args , 0 , true ) ; Member [ ] children = evaluator . get CaMeL Schema CaMeL Reader ( ) . get CaMeL Member CaMeL Children ( member ) ; return ( children . length == 0 ) ? member . get CaMeL Hierarchy ( ) . get CaMeL Null CaMeL Member ( ) : children [ 0 ] ;  <CTX>  public Object evaluate ( Evaluator evaluator , Exp [ ] args ) { Member member = get CaMeL Member CaMeL Arg ( evaluator , args , 0 , true ) ; Member [ ] children = evaluator . get CaMeL Schema CaMeL Reader ( ) . get CaMeL Member CaMeL Children ( member ) ; return ( children . length == 0 ) ? member . get CaMeL Hierarchy ( ) . get CaMeL Null CaMeL Member ( ) : children [ 0 ] ; }	Dimension dimension = get CaMeL Dimension CaMeL Arg ( evaluator , args , 0 , true ) ; return evaluator . get CaMeL Context ( dimension ) ;
Editor editor = Globals . cur CaMeL Editor ( ) ; J CaMeL Component c = editor . get CaMeL J CaMeL Component ( ) ;  <CTX>  public void run ( ) { Editor editor = Globals . cur CaMeL Editor ( ) ; J CaMeL Component c = editor . get CaMeL J CaMeL Component ( ) ; c . scroll CaMeL Rect CaMeL To CaMeL Visible ( r ) ; }	Editor the CaMeL Editor = Globals . cur CaMeL Editor ( ) ; J CaMeL Component c = the CaMeL Editor . get CaMeL J CaMeL Component ( ) ;
channel CaMeL Context , admin CaMeL Properties , qos CaMeL Properties , key ) ;  <CTX>  public Sequence CaMeL Proxy CaMeL Pull CaMeL Supplier CaMeL Impl ( Abstract CaMeL Admin my CaMeL Admin CaMeL Servant , Channel CaMeL Context channel CaMeL Context , Property CaMeL Manager admin CaMeL Properties , Property CaMeL Manager qos CaMeL Properties , Integer key ) throws Unsupported CaMeL Qo CaMeL S { super ( my CaMeL Admin CaMeL Servant , channel CaMeL Context , admin CaMeL Properties , qos CaMeL Properties , key ) ; set CaMeL Proxy CaMeL Type ( Proxy CaMeL Type . PULL _ STRUCTUR@@ ED ) ; }	channel CaMeL Context ) ;
o . atoms = ( Atom [ ] ) o . atoms . clone ( ) ;  <CTX>  public Object clone ( ) { Bond o = null ; try { o = ( Bond ) super . clone ( ) ; } catch ( Exception e ) { e . print CaMeL Stack CaMeL Trace ( System . err ) ; } o . atoms = ( Atom [ ] ) o . atoms . clone ( ) ; return o ; }	o . atoms = ( Atom [ ] ) atoms . clone ( ) ;
home CaMeL Dir = Mule CaMeL Manager . get CaMeL Configuration ( ) . get CaMeL Working CaMeL Direc@@ to@@ y ( ) + DEFAULT _ AXIS _ HOME ;  <CTX>  public String get CaMeL Home CaMeL Dir ( ) { if ( home CaMeL Dir == null ) { home CaMeL Dir = Mule CaMeL Manager . get CaMeL Configuration ( ) . get CaMeL Working CaMeL Direc@@ to@@ y ( ) + DEFAULT _ AXIS _ HOME ; } return home CaMeL Dir ; }	home CaMeL Dir = Mule CaMeL Manager . get CaMeL Configuration ( ) . get CaMeL Working CaMeL Directory ( ) + DEFAULT _ AXIS _ HOME ;
assert defn != null ;  <CTX>  public final boolean can CaMeL Contain ( Module module , int slot CaMeL Id , I CaMeL Element CaMeL Defn defn ) { assert defn != null ; boolean ret CaMeL Value = can CaMeL Contain CaMeL In CaMeL Rom ( slot CaMeL Id , defn ) ; if ( ! ret CaMeL Value ) return false ; / / if the root of element is included by report / library . Do not allow / / drop . if ( is CaMeL Root CaMeL Included CaMeL By CaMeL Module ( ) ) return false ; if ( ! can CaMeL Contain CaMeL Template CaMeL Element ( module , slot CaMeL Id , defn ) ) return false ; / / Can not change structure of child element or a virtual element ( / / inside the child ) . if ( is CaMeL Virtual CaMeL Element ( ) || get CaMeL Extends CaMeL Name ( ) != null ) return false ; / / special cases check table header containment . Design CaMeL Element tmp CaMeL Container = this ; while ( tmp CaMeL Container != null ) { if ( tmp CaMeL Container instanceof Listing CaMeL Element || tmp CaMeL Container instanceof Master CaMeL Page ) { List errors = tmp CaMeL Container . check CaMeL Content ( module , this , slot CaMeL Id , defn ) ; return errors . is CaMeL Empty ( ) ; } tmp CaMeL Container = tmp CaMeL Container . get CaMeL Container ( ) ; } return ret CaMeL Value ; }	boolean ret CaMeL Value = can CaMeL Contain CaMeL In CaMeL Rom ( slot CaMeL Id , element . get CaMeL Defn ( ) ) ; if ( ! ret CaMeL Value ) return false ;
} else {  <CTX>  private Indent get CaMeL Child CaMeL Default CaMeL Indent ( ) { if ( my CaMeL Node . get CaMeL Element CaMeL Type ( ) == Element CaMeL Type . HTML _ DOCUMENT ) { return Formatter . get CaMeL Instance ( ) . get CaMeL None CaMeL Indent ( ) ; } else { return null ; } }	} if ( my CaMeL Node . get CaMeL Element CaMeL Type ( ) == Element CaMeL Type . DUMMY _ HOLDER ) { return Formatter . get CaMeL Instance ( ) . get CaMeL None CaMeL Indent ( ) ; } else {
Provider CaMeL Factory . create CaMeL Provider ( slot CaMeL Handle . get CaMeL Element CaMeL Handle ( ) ) . perform CaMeL Request ( model , request ) ; return request ;  <CTX>  protected Request insert CaMeL Element ( ) throws Exception { Request request = new Request ( I CaMeL Request CaMeL Constants . REQUEST _ TYPE _ INSERT ) ; Map extends CaMeL Data = new Hash CaMeL Map ( ) ; extends CaMeL Data . put ( I CaMeL Request CaMeL Constants . REQUEST _ KEY _ INSERT _ SLOT , slot CaMeL Handle ) ; extends CaMeL Data . put ( I CaMeL Request CaMeL Constants . REQUEST _ KEY _ INSERT _ TYPE , insert CaMeL Type ) ; extends CaMeL Data . put ( I CaMeL Request CaMeL Constants . REQUEST _ KEY _ INSERT _ POSITION , Insert CaMeL Action . BELOW ) ; request . set CaMeL Extended CaMeL Data ( extends CaMeL Data ) ; Provider CaMeL Factory . create CaMeL Provider ( slot CaMeL Handle . get CaMeL Element CaMeL Handle ( ) ) . perform CaMeL Request ( model , request ) ; return request ; }	if ( Provider CaMeL Factory . create CaMeL Provider ( slot CaMeL Handle . get CaMeL Element CaMeL Handle ( ) ) . perform CaMeL Request ( model , request ) ) { return request ; } return null ;
Model . get CaMeL Extension CaMeL Mechanisms CaMeL Helper ( ) . set CaMeL Stereo CaMeL Type ( x@@ tor ,  <CTX>  X@@ tor CaMeL Modeler ( String stereotype CaMeL Name ) { / / FIX@@ ME : this will fail when we try to process definitions made / / outside of the class definition ! assert Model . get CaMeL Facade ( ) . is CaMeL A CaMeL Class ( context CaMeL Stack . peek ( ) ) ; x@@ tor = build CaMeL Operation ( context CaMeL Stack . peek ( ) , get CaMeL Void ( ) ) ; Model . get CaMeL Extension CaMeL Mechanisms CaMeL Helper ( ) . set CaMeL Stereo CaMeL Type ( x@@ tor , get CaMeL Stereotype ( x@@ tor , stereotype CaMeL Name ) ) ; context CaMeL Stack . push ( x@@ tor ) ; }	Model . get CaMeL Extension CaMeL Mechanisms CaMeL Helper ( ) . add CaMeL Copy CaMeL Stereotype ( x@@ tor ,
super ( parent , context , true ) ;  <CTX>  public Axis CaMeL Text CaMeL Sheet ( Composite parent , Chart CaMeL Wizard CaMeL Context context , Axis axis , int axis CaMeL Type ) { super ( parent , context , true ) ; this . axis = axis ; this . axis CaMeL Type = axis CaMeL Type ; cmp CaMeL Top = get CaMeL Component ( parent ) ; }	super ( title , context , true ) ;
if ( object instanceof Style CaMeL Range ) style = ( Style CaMeL Range ) object ; else return false ; if ( this . start != style . start ) return false ; if ( this . length != style . length ) return false ; return similar CaMeL To ( style ) ;  <CTX>  public boolean equals ( Object object ) { Style CaMeL Range style ; if ( object == this ) return true ; if ( object instanceof Style CaMeL Range ) style = ( Style CaMeL Range ) object ; else return false ; if ( this . start != style . start ) return false ; if ( this . length != style . length ) return false ; return similar CaMeL To ( style ) ; }	if ( object instanceof Style CaMeL Range ) { Style CaMeL Range style = ( Style CaMeL Range ) object ; if ( this . start != style . start ) return false ; if ( this . length != style . length ) return false ; return similar CaMeL To ( style ) ; } return false ;
return File CaMeL Editor CaMeL Manager . get CaMeL Instance ( get CaMeL Project ( ) ) . open CaMeL Text CaMeL Editor ( get CaMeL Descriptor ( ) , focus ) ;  <CTX>  private Editor open CaMeL Text CaMeL Editor ( boolean focus ) { return File CaMeL Editor CaMeL Manager . get CaMeL Instance ( get CaMeL Project ( ) ) . open CaMeL Text CaMeL Editor ( get CaMeL Descriptor ( ) , focus ) ; }	final Open CaMeL File CaMeL Descriptor descriptor = get CaMeL Descriptor ( ) ; if ( descriptor != null ) { return File CaMeL Editor CaMeL Manager . get CaMeL Instance ( get CaMeL Project ( ) ) . open CaMeL Text CaMeL Editor ( descriptor , focus ) ; } return null ;
scaled CaMeL Image = null ;  <CTX>  public void set CaMeL Image ( Buffered CaMeL Image img ) { orig CaMeL Image = img ; scaled CaMeL Image = null ; repaint ( ) ; }	xform CaMeL Image = null ;
initial _ mbrs . notify ( ) ;  <CTX>  public boolean handle CaMeL Up CaMeL Event ( Event evt ) { Vector tmp ; switch ( evt . get CaMeL Type ( ) ) { case Event . FIND _ INITIAL _ M@@ BRS _ OK : tmp = ( Vector ) evt . get CaMeL Arg ( ) ; synchronized ( initial _ mbrs ) { if ( tmp != null && tmp . size ( ) > 0 ) for ( int i = 0 ; i < tmp . size ( ) ; i ++ ) initial _ mbrs . add CaMeL Element ( tmp . element CaMeL At ( i ) ) ; initial _ mbrs _ received = true ; initial _ mbrs . notify ( ) ; } return false ; / / don t pass up the stack } return true ; }	initial _ mbrs . notify CaMeL All ( ) ;
Q CaMeL Name service CaMeL Name , String class CaMeL Name , Q CaMeL Name op CaMeL Name ) { return create CaMeL Simple CaMeL Service ( service CaMeL Name , new Raw CaMeL XM@@ LIN CaMeL Out CaMeL Message CaMeL Re@@ ce@@ vi@@ er ( ) , class CaMeL Name , op CaMeL Name ) ; }  <CTX>  public static Axis CaMeL Service create CaMeL Simple CaMeL Service ( Q CaMeL Name service CaMeL Name , String class CaMeL Name , Q CaMeL Name op CaMeL Name ) { return create CaMeL Simple CaMeL Service ( service CaMeL Name , new Raw CaMeL XM@@ LIN CaMeL Out CaMeL Message CaMeL Re@@ ce@@ vi@@ er ( ) , class CaMeL Name , op CaMeL Name ) ; }	Q CaMeL Name service CaMeL Name , Message CaMeL Receiver message CaMeL Receiver , String class CaMeL Name , Q CaMeL Name op CaMeL Name ) { Axis CaMeL Service service = new Axis CaMeL Service ( service CaMeL Name ) ; service . set CaMeL Class CaMeL Loader ( Thread . current CaMeL Thread ( ) . get CaMeL Context CaMeL Class CaMeL Loader ( ) ) ; service . add CaMeL Parameter ( new Parameter CaMeL Impl ( Abstract CaMeL Message CaMeL Receiver . SERVICE _ CLASS , class CaMeL Name ) ) ; Axis CaMeL Operation axis CaMeL Op = new Axis CaMeL Operation ( op CaMeL Name ) ; axis CaMeL Op . set CaMeL Message CaMeL Rec@@ ie@@ ver ( message CaMeL Receiver ) ; service . add CaMeL Operation ( axis CaMeL Op ) ; return service ; }
return get CaMeL Runtime ( ) . get CaMeL True ( ) ;  <CTX>  public I CaMeL Ruby CaMeL Object equal ( I CaMeL Ruby CaMeL Object other ) { if ( other == this ) { return get CaMeL Runtime ( ) . get CaMeL True ( ) ; } if ( ! ( other instanceof Ruby CaMeL Regexp ) ) { return get CaMeL Runtime ( ) . get CaMeL False ( ) ; } Ruby CaMeL Regexp re = ( Ruby CaMeL Regexp ) other ; check CaMeL Initialized ( ) ; if ( ! re . source ( ) . get CaMeL Value ( ) . equals ( pattern ) ) { return get CaMeL Runtime ( ) . get CaMeL False ( ) ; } if ( matcher . get CaMeL Case@@ fold ( ) ^ re . matcher . get CaMeL Case@@ fold ( ) ) { return get CaMeL Runtime ( ) . get CaMeL False ( ) ; } return get CaMeL Runtime ( ) . get CaMeL True ( ) ; }	return Ruby CaMeL Boolean . new CaMeL Boolean ( get CaMeL Runtime ( ) , ! ( matcher . get CaMeL Case@@ fold ( ) ^ re . matcher . get CaMeL Case@@ fold ( ) ) ) ;
Object [ ] tmp = table . values ( ) . to CaMeL Array ( ) ; I CaMeL Ruby CaMeL Object [ ] array = new I CaMeL Ruby CaMeL Object [ tmp . length ] ; for ( int i = 0 ; i < tmp . length ; i ++ ) { array [ i ] = ( I CaMeL Ruby CaMeL Object ) ( ( Weak CaMeL Symbol CaMeL Entry ) tmp [ i ] ) . get ( ) ; }  <CTX>  public I CaMeL Ruby CaMeL Object [ ] all _ symbols ( ) { Object [ ] tmp = table . values ( ) . to CaMeL Array ( ) ; I CaMeL Ruby CaMeL Object [ ] array = new I CaMeL Ruby CaMeL Object [ tmp . length ] ; for ( int i = 0 ; i < tmp . length ; i ++ ) { array [ i ] = ( I CaMeL Ruby CaMeL Object ) ( ( Weak CaMeL Symbol CaMeL Entry ) tmp [ i ] ) . get ( ) ; } return array ; }	int length = table . size ( ) ; I CaMeL Ruby CaMeL Object [ ] array = new I CaMeL Ruby CaMeL Object [ length ] ; System . arraycopy ( table . values ( ) . to CaMeL Array ( ) , 0 , array , 0 , length ) ;
if ( Method CaMeL Helper . is CaMeL Public CaMeL Static ( method ) ) {  <CTX>  public void register CaMeL Static CaMeL Methods ( Class methods CaMeL Class ) { Method [ ] methods = methods CaMeL Class . get CaMeL Methods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; if ( Method CaMeL Helper . is CaMeL Public CaMeL Static ( method ) ) { Class [ ] param CaMeL Types = method . get CaMeL Parameter CaMeL Types ( ) ; if ( param CaMeL Types . length > 0 ) { Class owner = param CaMeL Types [ 0 ] ; get CaMeL Meta CaMeL Class ( owner ) . add CaMeL New CaMeL Static CaMeL Instance CaMeL Method ( method ) ; } } } }	if ( Method CaMeL Helper . is CaMeL Static ( method ) ) {
editor . menu CaMeL Run . run CaMeL Interpreter ( ) ;  <CTX>  public void handle CaMeL Menu CaMeL Run ( int item CaMeL Tag ) { switch ( item CaMeL Tag ) { case MI _ RUN _ INTERPRETER : editor . menu CaMeL Run . run CaMeL Interpreter ( ) ; break ; case MI _ DEBUG : editor . menu CaMeL Run . debug ( ) ; break ; case MI _ BUILD _ AND _ DEBUG : editor . menu CaMeL Run . build CaMeL And CaMeL Debug ( ) ; break ; case MI _ DEBUG _ REMOTE : editor . menu CaMeL Run . debug CaMeL Remote ( ) ; break ; case MI _ DEBUG _ SHOW _ INFO _ PANEL : editor . menu CaMeL Run . toggle CaMeL Information CaMeL Panel ( ) ; editor . refresh CaMeL Main CaMeL Menu CaMeL Bar ( ) ; break ; case MI _ DEBUG _ SHOW _ OUTPUT _ PANEL : editor . menu CaMeL Run . toggle CaMeL Output CaMeL Panel ( ) ; editor . refresh CaMeL Main CaMeL Menu CaMeL Bar ( ) ; break ; } }	editor . menu CaMeL Debugger . run CaMeL Interpreter ( ) ;
} catch ( Break CaMeL Exception b CaMeL Ex@@ cp@@ tn ) {  <CTX>  public Ruby CaMeL Object eval ( Ruby ruby , Ruby CaMeL Object self ) { while ( get CaMeL Condition CaMeL Node ( ) . eval ( ruby , self ) . is CaMeL True ( ) ) { while ( true ) { try { get CaMeL Body CaMeL Node ( ) . eval ( ruby , self ) ; break ; } catch ( Redo CaMeL Exception r CaMeL Ex@@ cp@@ tn ) { } catch ( Next CaMeL Exception n CaMeL Ex@@ cp@@ tn ) { break ; } catch ( Break CaMeL Exception b CaMeL Ex@@ cp@@ tn ) { return ruby . get CaMeL Nil ( ) ; } } } return ruby . get CaMeL Nil ( ) ; }	} catch ( Break CaMeL Jump b CaMeL Ex@@ cp@@ tn ) {
this . activity CaMeL Scheduler , this . activity ) ) ;  <CTX>  public void next ( ) { this . activity CaMeL Scheduler . set CaMeL Activity CaMeL State ( new Activity CaMeL Presentation CaMeL State ( this . activity CaMeL Scheduler , this . activity ) ) ; }	this . activity CaMeL Scheduler , this . activity , true ) ) ;
new Progress CaMeL Monitor CaMeL Dialog ( get CaMeL Shell ( ) ) . run ( fork , cancelable , runnable ) ;  <CTX>  public void run ( boolean fork , boolean cancelable , I CaMeL Runnable CaMeL With CaMeL Progress runnable ) throws Invocation CaMeL Target CaMeL Exception , Interrupted CaMeL Exception { new Progress CaMeL Monitor CaMeL Dialog ( get CaMeL Shell ( ) ) . run ( fork , cancelable , runnable ) ; }	new Progress CaMeL Monitor CaMeL Jobs CaMeL Dialog ( get CaMeL Shell ( ) ) . run ( fork , cancelable , runnable ) ;
if ( ! data . show CaMeL On CaMeL Focus || control . is CaMeL Focus CaMeL Control ( ) )  <CTX>  public void show CaMeL Decoration ( Field CaMeL Decoration decoration ) { Field CaMeL Decoration CaMeL Data data = get CaMeL Decoration CaMeL Data ( decoration ) ; if ( data == null ) return ; / / record the fact that client would like it to be visible data . visible = true ; / / even if it is sup@@ posed to be shown , if the field does not have focus , / / do not show it ( yet ) if ( ! data . show CaMeL On CaMeL Focus || control . is CaMeL Focus CaMeL Control ( ) ) set CaMeL Visible ( data , true ) ; }	if ( ! data . show CaMeL On CaMeL Focus || control . is CaMeL Focus CaMeL Control ( ) ) {
String new CaMeL Result = adapted CaMeL Decorators [ i ] . decorate CaMeL Text ( result , element ) ;  <CTX>  public String decorate CaMeL Text ( String text , Object element ) { Decorator CaMeL Definition [ ] decorators = get CaMeL Decorators CaMeL For ( element ) ; String result = text ; for ( int i = 0 ; i < decorators . length ; i ++ ) { String new CaMeL Result = decorators [ i ] . decorate CaMeL Text ( result , element ) ; if ( new CaMeL Result != null ) result = new CaMeL Result ; } / / Get any adap@@ tions to I CaMeL Resource Object adapted = get CaMeL Resource CaMeL Adapter ( element ) ; if ( adapted != null ) { Decorator CaMeL Definition [ ] adapted CaMeL Decorators = get CaMeL Decorators CaMeL For ( adapted ) ; for ( int i = 0 ; i < adapted CaMeL Decorators . length ; i ++ ) { if ( adapted CaMeL Decorators [ i ] . is CaMeL Adaptable ( ) ) { String new CaMeL Result = adapted CaMeL Decorators [ i ] . decorate CaMeL Text ( result , element ) ; if ( new CaMeL Result != null ) result = new CaMeL Result ; } } } return result ; }	String new CaMeL Result = adapted CaMeL Decorators [ i ] . decorate CaMeL Text ( result , adapted ) ;
switch ( e CaMeL Derived CaMeL Structural CaMeL Feature CaMeL ID ( feature CaMeL ID , base CaMeL Class ) ) { case Component CaMeL Package . CURVE _ FI@@ TTING _ _ LINE _ ATTRIBUTES : return basic CaMeL Set CaMeL Line CaMeL Attributes ( null , msgs ) ; case Component CaMeL Package . CURVE _ FI@@ TTING _ _ LABEL : return basic CaMeL Set CaMeL Label ( null , msgs ) ; default : return e CaMeL Dynamic CaMeL Inverse CaMeL Remove ( other CaMeL End , feature CaMeL ID , base CaMeL Class , msgs ) ; }  <CTX>  public Notification CaMeL Chain e CaMeL Inverse CaMeL Remove ( Internal CaMeL E CaMeL Object other CaMeL End , int feature CaMeL ID , Class base CaMeL Class , Notification CaMeL Chain msgs ) { if ( feature CaMeL ID >= 0 ) { switch ( e CaMeL Derived CaMeL Structural CaMeL Feature CaMeL ID ( feature CaMeL ID , base CaMeL Class ) ) { case Component CaMeL Package . CURVE _ FI@@ TTING _ _ LINE _ ATTRIBUTES : return basic CaMeL Set CaMeL Line CaMeL Attributes ( null , msgs ) ; case Component CaMeL Package . CURVE _ FI@@ TTING _ _ LABEL : return basic CaMeL Set CaMeL Label ( null , msgs ) ; default : return e CaMeL Dynamic CaMeL Inverse CaMeL Remove ( other CaMeL End , feature CaMeL ID , base CaMeL Class , msgs ) ; } } return e CaMeL Basic CaMeL Set CaMeL Container ( null , feature CaMeL ID , msgs ) ; }	case Component CaMeL Package . CURVE _ FI@@ TTING _ _ LINE _ ATTRIBUTES : return basic CaMeL Set CaMeL Line CaMeL Attributes ( null , msgs ) ; case Component CaMeL Package . CURVE _ FI@@ TTING _ _ LABEL : return basic CaMeL Set CaMeL Label ( null , msgs ) ;
I CaMeL Ruby CaMeL Object result = z@@ stream . deflate ( str , new Long ( FINISH ) ) ;  <CTX>  public static I CaMeL Ruby CaMeL Object s _ deflate ( I CaMeL Ruby CaMeL Object caller , String str , int level ) throws Unsupported CaMeL Encoding CaMeL Exception , Data CaMeL Format CaMeL Exception , IO CaMeL Exception { Zlib CaMeL Deflate z@@ stream = new Zlib CaMeL Deflate ( caller , level , MAX _ W@@ BITS , DEF _ MEM _ LEVEL , Deflater . DEFAULT _ STRATEGY ) ; I CaMeL Ruby CaMeL Object result = z@@ stream . deflate ( str , new Long ( FINISH ) ) ; z@@ stream . close ( ) ; return result ; }	I CaMeL Ruby CaMeL Object result = z@@ stream . deflate ( str , FINISH ) ;
switch ( get CaMeL On CaMeL Resource ( ) ) { case ON _ ANY _ RESOURCE : { unfiltered = find CaMeL Markers ( new I CaMeL Resource [ ] { Resources CaMeL Plugin . get CaMeL Workspace ( ) . get CaMeL Root ( ) } , I CaMeL Resource . DEPTH _ INFINITE , limit , mon , ignore CaMeL Exceptions ) ; break ; } case ON _ SELECTED _ RESOURCE _ ONLY : { unfiltered = find CaMeL Markers ( focus CaMeL Resource , I CaMeL Resource . DEPTH _ ZERO , limit , mon , ignore CaMeL Exceptions ) ; break ; } case ON _ SELECTED _ RESOURCE _ AND _ CHILDREN : { unfiltered = find CaMeL Markers ( focus CaMeL Resource , I CaMeL Resource . DEPTH _ INFINITE , limit , mon , ignore CaMeL Exceptions ) ; break ; } case ON _ ANY _ RESOURCE _ OF _ SAME _ PROJECT : { unfiltered = find CaMeL Markers ( get CaMeL Projects ( focus CaMeL Resource ) , I CaMeL Resource . DEPTH _ INFINITE , limit , mon , ignore CaMeL Exceptions ) ; break ; } case ON _ WORKING _ SET : { unfiltered = find CaMeL Markers ( get CaMeL Resources CaMeL In CaMeL Working CaMeL Set ( ) , I CaMeL Resource . DEPTH _ INFINITE , limit , mon , ignore CaMeL Exceptions ) ; }  <CTX>  Concrete CaMeL Marker [ ] find CaMeL Markers ( I CaMeL Progress CaMeL Monitor mon , boolean ignore CaMeL Exceptions ) throws Core CaMeL Exception { List unfiltered = Collections . EMPTY _ LIST ; if ( ! is CaMeL Enabled ( ) ) { unfiltered = find CaMeL Markers ( new I CaMeL Resource [ ] { Resources CaMeL Plugin . get CaMeL Workspace ( ) . get CaMeL Root ( ) } , I CaMeL Resource . DEPTH _ INFINITE , - 1 , mon , ignore CaMeL Exceptions ) ; } else { / / int limit = get CaMeL Filter CaMeL On CaMeL Marker CaMeL Limit ( ) ? get CaMeL Marker CaMeL Limit ( ) + 1 : - 1 ; int limit = - 1 ; switch ( get CaMeL On CaMeL Resource ( ) ) { case ON _ ANY _ RESOURCE : { unfiltered = find CaMeL Markers ( new I CaMeL Resource [ ] { Resources CaMeL Plugin . get CaMeL Workspace ( ) . get CaMeL Root ( ) } , I CaMeL Resource . DEPTH _ INFINITE , limit , mon , ignore CaMeL Exceptions ) ; break ; } case ON _ SELECTED _ RESOURCE _ ONLY : { unfiltered = find CaMeL Markers ( focus CaMeL Resource , I CaMeL Resource . DEPTH _ ZERO , limit , mon , ignore CaMeL Exceptions ) ; break ; } case ON _ SELECTED _ RESOURCE _ AND _ CHILDREN : { unfiltered = find CaMeL Markers ( focus CaMeL Resource , I CaMeL Resource . DEPTH _ INFINITE , limit , mon , ignore CaMeL Exceptions ) ; break ; } case ON _ ANY _ RESOURCE _ OF _ SAME _ PROJECT : { unfiltered = find CaMeL Markers ( get CaMeL Projects ( focus CaMeL Resource ) , I CaMeL Resource . DEPTH _ INFINITE , limit , mon , ignore CaMeL Exceptions ) ; break ; } case ON _ WORKING _ SET : { unfiltered = find CaMeL Markers ( get CaMeL Resources CaMeL In CaMeL Working CaMeL Set ( ) , I CaMeL Resource . DEPTH _ INFINITE , limit , mon , ignore CaMeL Exceptions ) ; } } } if ( unfiltered == null ) { unfiltered = Collections . EMPTY _ LIST ; } return ( Concrete CaMeL Marker [ ] ) unfiltered . to CaMeL Array ( new Concrete CaMeL Marker [ unfiltered . size ( ) ] ) ; }	Collection subtypes = Arrays . as CaMeL List ( type . get CaMeL All CaMeL Sub CaMeL Types ( ) ) ; if ( selected CaMeL Types . contains CaMeL All ( subtypes ) ) { types CaMeL To CaMeL Search . remove CaMeL All ( subtypes ) ; include CaMeL All CaMeL Subtypes . add ( type ) ;
set CaMeL Button CaMeL Action CaMeL Performed ( evt ) ;  <CTX>  public void action CaMeL Performed ( java . awt . event . Action CaMeL Event evt ) { set CaMeL Button CaMeL Action CaMeL Performed ( evt ) ; }	port CaMeL Text CaMeL Field CaMeL Action CaMeL Performed ( evt ) ;
Iterator iter = get CaMeL WS CaMeL Artifact CaMeL Edits CaMeL Iterator ( ) ;  <CTX>  public List get CaMeL Workspace CaMeL W@@ SI@@ L CaMeL Files ( ) { List result = new Array CaMeL List ( ) ; Iterator iter = get CaMeL WS CaMeL Artifact CaMeL Edits CaMeL Iterator ( ) ; while ( iter . has CaMeL Next ( ) ) { WSDD CaMeL Artifact CaMeL Edit artifact CaMeL Edit = ( WSDD CaMeL Artifact CaMeL Edit ) iter . next ( ) ; List files = artifact CaMeL Edit . get CaMeL W@@ SI@@ L CaMeL Resources ( ) ; for ( int j = 0 ; j < files . size ( ) ; j ++ ) { I CaMeL File file = ( I CaMeL File ) files . get ( j ) ; if ( file != null && W@@ SI@@ L _ EXT . equals ( file . get CaMeL File CaMeL Extension ( ) ) ) result . add ( file ) ; } } return result ; }	Iterator iter = get CaMeL WS CaMeL Artifact CaMeL Edits ( ) . iterator ( ) ;
Inet CaMeL With CaMeL Port [ ] in@@ et@@ ps = new Inet CaMeL With CaMeL Port [ size ] ;  <CTX>  public static Inet CaMeL With CaMeL Port [ ] pop CaMeL Array CaMeL Inet CaMeL With CaMeL Port ( Message message ) { int size = message . pop CaMeL Int ( ) ; Inet CaMeL With CaMeL Port [ ] in@@ et@@ ps = new Inet CaMeL With CaMeL Port [ size ] ; for ( int i = 0 ; i < in@@ et@@ ps . length ; i ++ ) { in@@ et@@ ps [ i ] = Inet CaMeL With CaMeL Port . pop ( message ) ; } return in@@ et@@ ps ; }	Inet CaMeL Socket CaMeL Address [ ] in@@ et@@ ps = new Inet CaMeL Socket CaMeL Address [ size ] ;
dispose ( ) ;  <CTX>  public void action CaMeL Performed ( Action CaMeL Event evt ) { Object source = evt . get CaMeL Source ( ) ; if ( source instanceof J CaMeL Radio CaMeL Button ) update CaMeL Enabled ( ) ; if ( source == directory CaMeL Choose ) { File directory = new File ( directory CaMeL Path . get CaMeL Text ( ) ) ; J CaMeL File CaMeL Chooser chooser = new J CaMeL File CaMeL Chooser ( directory . get CaMeL Parent ( ) ) ; chooser . set CaMeL File CaMeL Selection CaMeL Mode ( J CaMeL File CaMeL Chooser . DIRECTORIES _ ONLY ) ; chooser . set CaMeL Selected CaMeL File ( directory ) ; if ( chooser . show CaMeL Open CaMeL Dialog ( Multi CaMeL File CaMeL Search CaMeL Dialog . this ) == J CaMeL File CaMeL Chooser . APPROVE _ OPTION ) directory CaMeL Path . set CaMeL Text ( chooser . get CaMeL Selected CaMeL File ( ) . get CaMeL Path ( ) ) ; } else if ( source == ok ) { is CaMeL OK = true ; dispose ( ) ; } else if ( source == cancel ) dispose ( ) ; }	cancel ( ) ;
int new _ index = search CaMeL List . get CaMeL Selected CaMeL Index ( ) + e . get CaMeL Wheel CaMeL Rotation ( ) ; int list _ size = search CaMeL List . get CaMeL Model ( ) . get CaMeL Size ( ) ;  <CTX>  public void mouse CaMeL Wheel CaMeL Moved ( Mouse CaMeL Wheel CaMeL Event e ) { int new _ index = search CaMeL List . get CaMeL Selected CaMeL Index ( ) + e . get CaMeL Wheel CaMeL Rotation ( ) ; int list _ size = search CaMeL List . get CaMeL Model ( ) . get CaMeL Size ( ) ; if ( new _ index < list _ size && new _ index >= 0 ) { search CaMeL List . set CaMeL Selected CaMeL Index ( new _ index ) ; search CaMeL List . ensure CaMeL Index CaMeL Is CaMeL Visible ( new _ index ) ; } }	int new _ index = browse CaMeL List . get CaMeL Selected CaMeL Index ( ) + e . get CaMeL Wheel CaMeL Rotation ( ) ; int list _ size = browse CaMeL List . get CaMeL Model ( ) . get CaMeL Size ( ) ;
this . set CaMeL Renderer ( Ad@@ ven@@ ture CaMeL Result . get CaMeL Equipment CaMeL Renderer ( ) ) ;  <CTX>  public Change CaMeL Combo CaMeL Box ( Lockable CaMeL List CaMeL Model slot ) { super ( slot ) ; this . set CaMeL Renderer ( Ad@@ ven@@ ture CaMeL Result . get CaMeL Equipment CaMeL Renderer ( ) ) ; }	set CaMeL Renderer ( Ad@@ ven@@ ture CaMeL Result . get CaMeL Equipment CaMeL Renderer ( ) ) ; add CaMeL Action CaMeL Listener ( new Change CaMeL Item CaMeL Listener ( ) ) ;
Property CaMeL Group CaMeL Schedule schedule = new Property CaMeL Group CaMeL Schedule ( this ) ; schedule . lock CaMeL P CaMeL Gs ( key ) ; return schedule ;  <CTX>  public Property CaMeL Group CaMeL Schedule lock ( Object key ) { Property CaMeL Group CaMeL Schedule schedule = new Property CaMeL Group CaMeL Schedule ( this ) ; schedule . lock CaMeL P CaMeL Gs ( key ) ; return schedule ; }	if ( _ locked == null ) { _ locked = new _ Locked ( key , this ) ; } return _ locked ;
Roster CaMeL Entry ( String user , String name , XMPP CaMeL Connection connection ) {  <CTX>  Roster CaMeL Entry ( String user , String name , XMPP CaMeL Connection connection ) { this . user = user ; this . name = name ; this . connection = connection ; }	Roster CaMeL Entry ( String user , String name , Roster CaMeL Packet . Item CaMeL Type type , XMPP CaMeL Connection connection ) {
ex = Script CaMeL Runtime . unwrap CaMeL Java CaMeL Script CaMeL Exception ( ( Java CaMeL Script CaMeL Exception ) ex ) ; } else if ( ex instanceof Ecma CaMeL Error ) {  <CTX>  private static Object unwrap CaMeL Exception ( Object ex ) { for ( ; ; ) { if ( ex instanceof Java CaMeL Script CaMeL Exception ) { ex = Script CaMeL Runtime . unwrap CaMeL Java CaMeL Script CaMeL Exception ( ( Java CaMeL Script CaMeL Exception ) ex ) ; } else if ( ex instanceof Ecma CaMeL Error ) { ex = ( ( Ecma CaMeL Error ) ex ) . get CaMeL Error CaMeL Object ( ) ; } else if ( ex instanceof Native CaMeL Java CaMeL Object ) { ex = ( ( Native CaMeL Java CaMeL Object ) ex ) . unwrap ( ) ; break ; } else if ( ex instanceof Wrapped CaMeL Exception ) { Object w = ( ( Wrapped CaMeL Exception ) ex ) . unwrap ( ) ; if ( w instanceof Throwable ) { ex = w ; continue ; } break ; } else { break ; } } return ex ; }	ex = ( ( Java CaMeL Script CaMeL Exception ) ex ) . get CaMeL Value ( ) ; } else if ( ex instanceof Ecma CaMeL Error ) {
throws Persistence CaMeL Exception , Object CaMeL Modified CaMeL Exception {  <CTX>  public final void update ( final Transaction CaMeL Context tx , final OID oid , final Object object , final Access CaMeL Mode suggested CaMeL Access CaMeL Mode , final Object field ) throws Persistence CaMeL Exception , Object CaMeL Modified CaMeL Exception { Class CaMeL Molder field CaMeL Class CaMeL Molder = _ field CaMeL Molder . get CaMeL Field CaMeL Class CaMeL Molder ( ) ; Lock CaMeL Engine field CaMeL Engine = _ field CaMeL Molder . get CaMeL Field CaMeL Lock CaMeL Engine ( ) ; if ( _ field CaMeL Molder . is CaMeL Dependent ( ) ) { if ( ! _ field CaMeL Molder . is CaMeL Lazy ( ) ) { Iterator itor = Class CaMeL Molder CaMeL Helper . get CaMeL Iterator ( _ field CaMeL Molder . get CaMeL Value ( object , tx . get CaMeL Class CaMeL Loader ( ) ) ) ; Array CaMeL List v = ( Array CaMeL List ) field ; Array CaMeL List new CaMeL Set CaMeL Of CaMeL Ids = new Array CaMeL List ( ) ; / / iterate the collection of this data object field while ( itor . has CaMeL Next ( ) ) { Object element = itor . next ( ) ; Object actual CaMeL Identity = field CaMeL Class CaMeL Molder . get CaMeL Actual CaMeL Identity ( tx , element ) ; new CaMeL Set CaMeL Of CaMeL Ids . add ( actual CaMeL Identity ) ; if ( v != null && v . contains ( actual CaMeL Identity ) ) { if ( ! tx . is CaMeL Recorded ( element ) ) { tx . mark CaMeL Update ( field CaMeL Engine , field CaMeL Class CaMeL Molder , element , oid ) ; } } else { / * * if ( ! tx . is CaMeL Recorded ( element ) ) tx . mark CaMeL Create ( * field CaMeL Engine , field CaMeL Class CaMeL Molder , element , oid ) ; * / } } if ( v != null ) { for ( int j = 0 , l = v . size ( ) ; j < l ; j ++ ) { if ( ! new CaMeL Set CaMeL Of CaMeL Ids . contains ( v . get ( j ) ) ) { / / load all the dependent object in cache for / / modification / / check at commit time . Proposed CaMeL Object proposed CaMeL Value = new Proposed CaMeL Object ( ) ; tx . load ( oid . get CaMeL Lock CaMeL Engine ( ) , field CaMeL Class CaMeL Molder , v . get ( j ) , proposed CaMeL Value , suggested CaMeL Access CaMeL Mode ) ; } } } } else { / / Array CaMeL List av@@ list = ( Array CaMeL List ) fields [ i ] ; field CaMeL Class CaMeL Molder = _ field CaMeL Molder . get CaMeL Field CaMeL Class CaMeL Molder ( ) ; field CaMeL Engine = _ field CaMeL Molder . get CaMeL Field CaMeL Lock CaMeL Engine ( ) ; / / Relation CaMeL Collection relcol = new Relation CaMeL Collection ( tx , oid , / / field CaMeL Engine , field CaMeL Class CaMeL Molder , access CaMeL Mode , av@@ list ) ; } } else if ( tx . is CaMeL Auto CaMeL Store ( ) ) { Iterator itor = Class CaMeL Molder CaMeL Helper . get CaMeL Iterator ( _ field CaMeL Molder . get CaMeL Value ( object , tx . get CaMeL Class CaMeL Loader ( ) ) ) ; Array CaMeL List v = ( Array CaMeL List ) field ; Array CaMeL List new CaMeL Set CaMeL Of CaMeL Ids = new Array CaMeL List ( ) ; / / iterate the collection of this data object field while ( itor . has CaMeL Next ( ) ) { Object element = itor . next ( ) ; Object actual CaMeL Identity = field CaMeL Class CaMeL Molder . get CaMeL Actual CaMeL Identity ( tx , element ) ; new CaMeL Set CaMeL Of CaMeL Ids . add ( actual CaMeL Identity ) ; if ( v != null && v . contains ( actual CaMeL Identity ) ) { if ( ! tx . is CaMeL Recorded ( element ) ) { tx . mark CaMeL Update ( field CaMeL Engine , field CaMeL Class CaMeL Molder , element , null ) ; } } else { if ( ! tx . is CaMeL Recorded ( element ) ) { tx . mark CaMeL Update ( field CaMeL Engine , field CaMeL Class CaMeL Molder , element , null ) ; } } } / / load all old objects for comparison in the pre CaMeL Store state if ( v != null ) { for ( int j = 0 , l = v . size ( ) ; j < l ; j ++ ) { if ( ! new CaMeL Set CaMeL Of CaMeL Ids . contains ( v . get ( j ) ) ) { / / load all the dependent object in cache for / / modification / / check at commit time . Proposed CaMeL Object proposed CaMeL Value = new Proposed CaMeL Object ( ) ; tx . load ( oid . get CaMeL Lock CaMeL Engine ( ) , field CaMeL Class CaMeL Molder , v . get ( j ) , proposed CaMeL Value , suggested CaMeL Access CaMeL Mode ) ; } } } } }	throws Persistence CaMeL Exception {
super ( position ) ;  <CTX>  public Defs CaMeL Node ( I CaMeL Source CaMeL Position position , Node receiver CaMeL Node , String name , Node args CaMeL Node , Scope CaMeL Node body CaMeL Node ) { super ( position ) ; this . receiver CaMeL Node = receiver CaMeL Node ; this . name = name . intern ( ) ; this . args CaMeL Node = args CaMeL Node ; this . body CaMeL Node = body CaMeL Node ; }	super ( position , Node CaMeL Types . DEF@@ S@@ NODE ) ;
hide ( ) ;  <CTX>  public void action CaMeL Performed ( Action CaMeL Event e ) { if ( e . get CaMeL Action CaMeL Command ( ) . equals ( m _ ok . get CaMeL Text ( ) ) || e . get CaMeL Action CaMeL Command ( ) . equals ( m _ cancel . get CaMeL Text ( ) ) ) { m _ aborted = ! e . get CaMeL Action CaMeL Command ( ) . equals ( m _ ok . get CaMeL Text ( ) ) ; hide ( ) ; } else if ( e . get CaMeL Action CaMeL Command ( ) . equals ( m _ sel CaMeL All . get CaMeL Text ( ) ) ) { for ( int i = 0 ; i < m _ selections . length ; i ++ ) { m _ selections [ i ] . set CaMeL Selected ( true ) ; } } else if ( e . get CaMeL Action CaMeL Command ( ) . equals ( m _ sel CaMeL None . get CaMeL Text ( ) ) ) { for ( int i = 0 ; i < m _ selections . length ; i ++ ) { m _ selections [ i ] . set CaMeL Selected ( false ) ; } } }	set CaMeL Visible ( false ) ;
my CaMeL Connection . open ( this ) ; authenticate ( ) ;  <CTX>  private void open CaMeL Connection ( ) throws SVN CaMeL Exception { lock ( ) ; ISVN CaMeL Connector connector = SVN CaMeL Repository CaMeL Factory CaMeL Impl . get CaMeL Connector CaMeL Factory ( ) . create CaMeL Connector ( this ) ; my CaMeL Connection = new SVN CaMeL Connection ( connector ) ; my CaMeL Connection . open ( this ) ; authenticate ( ) ; }	try { my CaMeL Connection . open ( this ) ; authenticate ( ) ; } finally { my CaMeL Realm = my CaMeL Connection . get CaMeL Realm ( ) ; }
return 32 ;  <CTX>  public int get CaMeL Max CaMeL Cursor CaMeL Name CaMeL Length ( ) throws SQL CaMeL Exception { return 32 ; }	return NAME _ SIZE ;
if ( ! HAS _ NEXT _ METHOD . equals ( method CaMeL Name ) ) {  <CTX>  private static boolean is CaMeL Has CaMeL Next ( Psi CaMeL Expression condition , String iterator ) { if ( ! ( condition instanceof Psi CaMeL Method CaMeL Call CaMeL Expression ) ) { return false ; } final Psi CaMeL Method CaMeL Call CaMeL Expression call = ( Psi CaMeL Method CaMeL Call CaMeL Expression ) condition ; final Psi CaMeL Expression CaMeL List argument CaMeL List = call . get CaMeL Argument CaMeL List ( ) ; if ( argument CaMeL List == null ) { return false ; } final Psi CaMeL Expression [ ] args = argument CaMeL List . get CaMeL Expressions ( ) ; if ( args . length != 0 ) { return false ; } final Psi CaMeL Reference CaMeL Expression method CaMeL Expression = call . get CaMeL Method CaMeL Expression ( ) ; if ( method CaMeL Expression == null ) { return false ; } final String method CaMeL Name = method CaMeL Expression . get CaMeL Reference CaMeL Name ( ) ; if ( ! HAS _ NEXT _ METHOD . equals ( method CaMeL Name ) ) { return false ; } final Psi CaMeL Expression qualifier = method CaMeL Expression . get CaMeL Qualifier CaMeL Expression ( ) ; if ( qualifier == null ) { return true ; } final String target = qualifier . get CaMeL Text ( ) ; return iterator . equals ( target ) ; }	if ( ! Hardcoded CaMeL Method CaMeL Constants . HAS _ NEXT . equals ( method CaMeL Name ) ) {
if ( header . local CaMeL Seq CaMeL ID != NULL _ ID ) pass CaMeL Up ( new Event ( Event . MSG , msg ) ) ;  <CTX>  private void _ deliver CaMeL B@@ cast ( ) { Message msg ; Header header ; synchronized ( up CaMeL Tbl ) { while ( ( msg = ( Message ) up CaMeL Tbl . remove ( new Long ( seq CaMeL ID + 1 ) ) ) != null ) { header = ( Header ) msg . remove CaMeL Header ( get CaMeL Name ( ) ) ; if ( header . local CaMeL Seq CaMeL ID != NULL _ ID ) pass CaMeL Up ( new Event ( Event . MSG , msg ) ) ; ++ seq CaMeL ID ; } } / / synchronized ( up CaMeL Tbl ) }	if ( header . local CaMeL Sequence CaMeL ID != NULL _ ID ) pass CaMeL Up ( new Event ( Event . MSG , msg ) ) ;
boolean exists = ( tuple . get CaMeL Linked CaMeL Tuples ( ) != null && ! tuple . get CaMeL Linked CaMeL Tuples ( ) . is CaMeL Empty ( ) ) ;  <CTX>  public void modify CaMeL Tuple ( final Rete CaMeL Tuple tuple , final Propagation CaMeL Context context , final Reteoo CaMeL Working CaMeL Memory working CaMeL Memory ) { final Linked CaMeL List memory = ( Linked CaMeL List ) working CaMeL Memory . get CaMeL Node CaMeL Memory ( this ) ; boolean exists = ( tuple . get CaMeL Linked CaMeL Tuples ( ) != null && ! tuple . get CaMeL Linked CaMeL Tuples ( ) . is CaMeL Empty ( ) ) ; if ( exists ) { / / Remove the tuple so it can be read@@ ded to the top of the list memory . remove ( tuple ) ; } final boolean allowed = this . condition . is CaMeL Allowed ( tuple , working CaMeL Memory ) ; if ( allowed ) { memory . add ( tuple ) ; if ( ! exists ) { propagate CaMeL Assert CaMeL Tuple ( tuple , context , working CaMeL Memory ) ; } else { propagate CaMeL Modify CaMeL Tuple ( tuple , context , working CaMeL Memory ) ; } } else { propagate CaMeL Retract CaMeL Tuple ( tuple , context , working CaMeL Memory ) ; } }	boolean exists = ( tuple . get CaMeL Child CaMeL Entries ( ) != null && ! tuple . get CaMeL Child CaMeL Entries ( ) . is CaMeL Empty ( ) ) ;
set CaMeL Layer ( Default CaMeL Annotation . INFO _ LAYER + 1 ) ;  <CTX>  public Problem CaMeL Annotation ( I CaMeL Problem problem , I CaMeL Compilation CaMeL Unit cu ) { f CaMeL Problem = problem ; f CaMeL Compilation CaMeL Unit = cu ; if ( I CaMeL Problem . Task == f CaMeL Problem . get CaMeL ID ( ) ) { set CaMeL Type ( Java CaMeL Marker CaMeL Annotation . TASK _ ANNOTATION _ TYPE ) ; set CaMeL Layer ( Default CaMeL Annotation . TASK _ LAYER + 1 ) ; } else if ( f CaMeL Problem . is CaMeL Warning ( ) ) { set CaMeL Type ( Java CaMeL Marker CaMeL Annotation . WARNING _ ANNOTATION _ TYPE ) ; set CaMeL Layer ( Default CaMeL Annotation . WARNING _ LAYER + 1 ) ; } else if ( f CaMeL Problem . is CaMeL Error ( ) ) { set CaMeL Type ( Java CaMeL Marker CaMeL Annotation . ERROR _ ANNOTATION _ TYPE ) ; set CaMeL Layer ( Default CaMeL Annotation . ERROR _ LAYER + 1 ) ; } else { set CaMeL Type ( Java CaMeL Marker CaMeL Annotation . INFO _ ANNOTATION _ TYPE ) ; set CaMeL Layer ( Default CaMeL Annotation . INFO _ LAYER + 1 ) ; } }	set CaMeL Layer ( Annotation CaMeL Layer CaMeL Lookup . INFO _ LAYER + 1 ) ;
m _ target CaMeL Instance = target CaMeL Instance ;  <CTX>  public void set CaMeL Target CaMeL Instance ( final Object target CaMeL Instance ) { m _ target CaMeL Instance = target CaMeL Instance ; }	m _ target CaMeL Instance CaMeL Ref = new Weak CaMeL Reference ( target CaMeL Instance ) ;
if ( get CaMeL Site ( ) . is CaMeL Closeable ( part ) )  <CTX>  private C CaMeL Tab CaMeL Item create CaMeL Part CaMeL Tab ( I CaMeL Presentable CaMeL Part part , int tab CaMeL Index ) { C CaMeL Tab CaMeL Item tab CaMeL Item ; int style = SWT . NONE ; if ( get CaMeL Site ( ) . is CaMeL Closeable ( part ) ) style |= SWT . CLOSE ; tab CaMeL Item = pane CaMeL Folder . create CaMeL Item ( style , tab CaMeL Index ) ; tab CaMeL Item . set CaMeL Data ( TAB _ DATA , part ) ; part . add CaMeL Property CaMeL Listener ( child CaMeL Property CaMeL Change CaMeL Listener ) ; tab CaMeL Item . add CaMeL Dispose CaMeL Listener ( tab CaMeL Dispose CaMeL Listener ) ; init CaMeL Tab ( tab CaMeL Item , part ) ; return tab CaMeL Item ; }	if ( get CaMeL Site ( ) . is CaMeL Closeable ( part ) ) {
return Ruby CaMeL String . new CaMeL String ( get CaMeL Runtime ( ) , method . get CaMeL Name ( ) ) ;  <CTX>  public Ruby CaMeL String name ( ) { return Ruby CaMeL String . new CaMeL String ( get CaMeL Runtime ( ) , method . get CaMeL Name ( ) ) ; }	return get CaMeL Runtime ( ) . new CaMeL String ( method . get CaMeL Name ( ) ) ;
Double percentage , Advise CaMeL Type advise CaMeL Type ) throws Excep@@ cao CaMeL Persiste@@ n@@ cia {  <CTX>  public void run ( Integer teacher CaMeL ID , Integer execution CaMeL Period CaMeL ID , final Integer student CaMeL Number , Double percentage , Advise CaMeL Type advise CaMeL Type ) throws Excep@@ cao CaMeL Persiste@@ n@@ cia { I CaMeL Sup@@ or@@ te CaMeL Persiste@@ n@@ te persistent CaMeL Support = Persistence CaMeL Support CaMeL Factory . get CaMeL Default CaMeL Persistence CaMeL Support ( ) ; I CaMeL Teacher teacher = ( I CaMeL Teacher ) persistent CaMeL Support . get CaMeL I CaMeL Persistent CaMeL Teacher ( ) . read CaMeL By CaMeL OID ( Teacher . class , teacher CaMeL ID ) ; I CaMeL Execution CaMeL Period execution CaMeL Period = ( I CaMeL Execution CaMeL Period ) persistent CaMeL Support . get CaMeL I CaMeL Persistent CaMeL Execution CaMeL Period ( ) . read CaMeL By CaMeL OID ( Execution CaMeL Period . class , execution CaMeL Period CaMeL ID ) ; List < I CaMeL Student > students = persistent CaMeL Support . get CaMeL I CaMeL Persistent CaMeL Student ( ) . read CaMeL All ( ) ; I CaMeL Student student = ( I CaMeL Student ) Collection CaMeL Utils . find ( students , new Predicate ( ) { public boolean evaluate ( Object arg 0 ) { I CaMeL Student temp CaMeL Student = ( I CaMeL Student ) arg 0 ; return temp CaMeL Student . get CaMeL Number ( ) . equals ( student CaMeL Number ) ; } } ) ; I CaMeL Teacher CaMeL Service teacher CaMeL Service = teacher . get CaMeL Teacher CaMeL Service CaMeL By CaMeL Execution CaMeL Period ( execution CaMeL Period ) ; if ( teacher CaMeL Service == null ) { teacher CaMeL Service = Domain CaMeL Factory . make CaMeL Teacher CaMeL Service ( teacher , execution CaMeL Period ) ; } List < I CaMeL Advise > advi@@ ses = student . get CaMeL Advi@@ ses CaMeL By CaMeL Teacher ( teacher ) ; I CaMeL Advise advise = null ; if ( advi@@ ses == null || advi@@ ses . is CaMeL Empty ( ) ) { advise = Domain CaMeL Factory . make CaMeL Advise ( teacher , student , advise CaMeL Type , execution CaMeL Period , execution CaMeL Period ) ; } else { advise = advi@@ ses . iterator ( ) . next ( ) ; } I CaMeL Teacher CaMeL Advise CaMeL Service teacher CaMeL Advise CaMeL Service = advise . get CaMeL Teacher CaMeL Advise CaMeL Service CaMeL By CaMeL Execution CaMeL Period ( execution CaMeL Period ) ; if ( teacher CaMeL Advise CaMeL Service == null ) { teacher CaMeL Advise CaMeL Service = Domain CaMeL Factory . make CaMeL Teacher CaMeL Advise CaMeL Service ( teacher CaMeL Service , advise , percentage ) ; } else { teacher CaMeL Advise CaMeL Service . update CaMeL Percentage ( percentage ) ; } }	Double percentage , Advise CaMeL Type advise CaMeL Type ) throws Excep@@ cao CaMeL Persiste@@ n@@ cia , F@@ enix CaMeL Service CaMeL Exception {
Scriptable scope = cx . new CaMeL Object ( parent CaMeL Scope ) ; scope . set CaMeL Parent CaMeL Scope ( parent CaMeL Scope ) ; scope . set CaMeL Prototype ( parent CaMeL Scope ) ;  <CTX>  Scriptable new CaMeL Sub CaMeL Scope ( Scriptable parent CaMeL Scope ) { if ( parent CaMeL Scope == null ) parent CaMeL Scope = shared CaMeL Scope ; Context cx = Context . enter ( ) ; try { Scriptable scope = cx . new CaMeL Object ( parent CaMeL Scope ) ; scope . set CaMeL Parent CaMeL Scope ( parent CaMeL Scope ) ; scope . set CaMeL Prototype ( parent CaMeL Scope ) ; return scope ; } finally { Context . exit ( ) ; } }	Scriptable scope = cx . new CaMeL Object ( parent CaMeL And CaMeL Proto CaMeL Scope ) ; scope . set CaMeL Parent CaMeL Scope ( parent CaMeL And CaMeL Proto CaMeL Scope ) ; scope . set CaMeL Prototype ( parent CaMeL And CaMeL Proto CaMeL Scope ) ;
if ( ! is CaMeL Non CaMeL Displayable CaMeL Job ( info . get CaMeL Job ( ) , listener . shows CaMeL Debug ( ) ) ) listener . add CaMeL Job ( info ) ;  <CTX>  public void add CaMeL Job CaMeL Info ( Job CaMeL Info info ) { Group CaMeL Info group = info . get CaMeL Group CaMeL Info ( ) ; if ( group != null ) refresh CaMeL Group ( group ) ; jobs . put ( info . get CaMeL Job ( ) , info ) ; synchronized ( listeners CaMeL Key ) { for ( int i = 0 ; i < listeners . length ; i ++ ) { I CaMeL Job CaMeL Progress CaMeL Manager CaMeL Listener listener = listeners [ i ] ; if ( ! is CaMeL Non CaMeL Displayable CaMeL Job ( info . get CaMeL Job ( ) , listener . shows CaMeL Debug ( ) ) ) listener . add CaMeL Job ( info ) ; } } }	if ( ! is CaMeL Non CaMeL Displayable CaMeL Job ( info . get CaMeL Job ( ) , listener . shows CaMeL Debug ( ) ) ) { listener . add CaMeL Job ( info ) ; }
user CaMeL Supplied CaMeL Optimizer CaMeL Overrides , close CaMeL Cleanup ) ;  <CTX>  public Nested CaMeL Loop CaMeL Left CaMeL Outer CaMeL Join CaMeL Result CaMeL Set ( No CaMeL Put CaMeL Result CaMeL Set left CaMeL Result CaMeL Set , int left CaMeL Num CaMeL Cols , No CaMeL Put CaMeL Result CaMeL Set right CaMeL Result CaMeL Set , int right CaMeL Num CaMeL Cols , Activation activation , Generated CaMeL Method restriction , int result CaMeL Set CaMeL Number , Generated CaMeL Method empty CaMeL Row CaMeL Fun , boolean was CaMeL Right CaMeL Outer CaMeL Join , boolean one CaMeL Row CaMeL Right CaMeL Side , boolean not CaMeL Exists CaMeL Right CaMeL Side , double optimizer CaMeL Estimated CaMeL Row CaMeL Count , double optimizer CaMeL Estimated CaMeL Cost , String user CaMeL Supplied CaMeL Optimizer CaMeL Overrides , Generated CaMeL Method close CaMeL Cleanup ) { super ( left CaMeL Result CaMeL Set , left CaMeL Num CaMeL Cols , right CaMeL Result CaMeL Set , right CaMeL Num CaMeL Cols , activation , restriction , result CaMeL Set CaMeL Number , one CaMeL Row CaMeL Right CaMeL Side , not CaMeL Exists CaMeL Right CaMeL Side , optimizer CaMeL Estimated CaMeL Row CaMeL Count , optimizer CaMeL Estimated CaMeL Cost , user CaMeL Supplied CaMeL Optimizer CaMeL Overrides , close CaMeL Cleanup ) ; this . empty CaMeL Row CaMeL Fun = empty CaMeL Row CaMeL Fun ; this . was CaMeL Right CaMeL Outer CaMeL Join = was CaMeL Right CaMeL Outer CaMeL Join ; }	user CaMeL Supplied CaMeL Optimizer CaMeL Overrides ) ;
return flags ;  <CTX>  get CaMeL Flags ( ) { return flags ; }	return byte CaMeL Array CaMeL To CaMeL String ( flags ) ;
this . resource CaMeL Name = resource CaMeL Name ;  <CTX>  public void set CaMeL Resource CaMeL Name ( String resource CaMeL Name ) { this . resource CaMeL Name = resource CaMeL Name ; }	m _ resource CaMeL Name = resource CaMeL Name ;
Iterator iterator = f CaMeL Activated CaMeL Plugins . key CaMeL Set ( ) . iterator ( ) ; while ( iterator . has CaMeL Next ( ) ) { String plugin CaMeL Id = ( String ) iterator . next ( ) ; Plugin object = ( Plugin ) f CaMeL Activated CaMeL Plugins . get ( plugin CaMeL Id ) ; object . shut CaMeL Down ( ) ;  <CTX>  private void shot CaMeL Down CaMeL Activated CaMeL Plugins ( ) throws Plugin CaMeL Runtime CaMeL Exception { Iterator iterator = f CaMeL Activated CaMeL Plugins . key CaMeL Set ( ) . iterator ( ) ; while ( iterator . has CaMeL Next ( ) ) { String plugin CaMeL Id = ( String ) iterator . next ( ) ; Plugin object = ( Plugin ) f CaMeL Activated CaMeL Plugins . get ( plugin CaMeL Id ) ; object . shut CaMeL Down ( ) ; } }	Iterator iterator = f CaMeL Activated CaMeL Plugins . key CaMeL Set ( ) . iterator ( ) ; while ( iterator . has CaMeL Next ( ) ) { String plugin CaMeL Id = ( String ) iterator . next ( ) ; Plugin object = ( Plugin ) f CaMeL Activated CaMeL Plugins . get ( plugin CaMeL Id ) ; object . shut CaMeL Down ( ) ; }
return Property CaMeL Util . get CaMeL Dimension CaMeL Value ( cell CaMeL Area CaMeL Style  <CTX>  public int resolve CaMeL Bottom CaMeL Border ( Cell CaMeL Area cell ) { I CaMeL Style table CaMeL Style = table CaMeL Content . get CaMeL Computed CaMeL Style ( ) ; I CaMeL Style row CaMeL Style = ( last CaMeL Row == null ? null : last CaMeL Row CaMeL Area . get CaMeL Content ( ) . get CaMeL Computed CaMeL Style ( ) ) ; I CaMeL Style column CaMeL Style = get CaMeL Column CaMeL Style ( cell . get CaMeL Column CaMeL ID ( ) ) ; I CaMeL Style cell CaMeL Content CaMeL Style = cell . get CaMeL Content ( ) . get CaMeL Computed CaMeL Style ( ) ; I CaMeL Style cell CaMeL Area CaMeL Style = cell . get CaMeL Style ( ) ; b@@ cr . resolve CaMeL Table CaMeL Bottom CaMeL Border ( table CaMeL Style , row CaMeL Style , column CaMeL Style , cell CaMeL Content CaMeL Style , cell CaMeL Area CaMeL Style ) ; return Property CaMeL Util . get CaMeL Dimension CaMeL Value ( cell CaMeL Area CaMeL Style . get CaMeL Property ( Style CaMeL Constants . STYLE _ BORDER _ BOTTOM _ WIDTH ) ) ; }	return get CaMeL Dimension CaMeL Value ( cell CaMeL Area CaMeL Style
return RECOGNIZED _ FEATURES ;  <CTX>  public String [ ] get CaMeL Recognized CaMeL Features ( ) { return RECOGNIZED _ FEATURES ; } / / get CaMeL Recognized CaMeL Features ( ) : String [ ]	return ( String [ ] ) ( RECOGNIZED _ FEATURES . clone ( ) ) ;
this . add CaMeL Change CaMeL Listener ( listener ) ;  <CTX>  public Data CaMeL Proxy ( Data CaMeL Context context , Data CaMeL Proxy CaMeL State CaMeL Change CaMeL Listener listener ) { this . context = context ; this . add CaMeL Change CaMeL Listener ( listener ) ; }	if ( listener != null ) this . add CaMeL Change CaMeL Listener ( listener ) ;
if ( type instanceof Tuple CaMeL Type ) { Tuple CaMeL Type tuple CaMeL Type = ( Tuple CaMeL Type ) type ;  <CTX>  private static void add CaMeL Types ( final Type type , List list ) { if ( type instanceof Tuple CaMeL Type ) { Tuple CaMeL Type tuple CaMeL Type = ( Tuple CaMeL Type ) type ; for ( int i = 0 ; i < tuple CaMeL Type . element CaMeL Types . length ; i ++ ) { add CaMeL Types ( tuple CaMeL Type . element CaMeL Types [ i ] , list ) ; } } else { list . add ( type ) ; } }	if ( type instanceof Set CaMeL Type ) { Set CaMeL Type set CaMeL Type = ( Set CaMeL Type ) type ; add CaMeL Types ( set CaMeL Type . get CaMeL Element CaMeL Type ( ) , list ) ; } else if ( type instanceof Tuple CaMeL Type ) { Tuple CaMeL Type tuple CaMeL Type = ( Tuple CaMeL Type ) type ;
this . get CaMeL Candidates ( ) . add ( candidate CaMeL Gene ) ;  <CTX>  public void add CaMeL Candidate ( Candidate CaMeL Gene candidate CaMeL Gene ) { if ( this . get CaMeL Candidates ( ) == null ) this . set CaMeL Candidates ( new Hash CaMeL Set ( ) ) ; this . get CaMeL Candidates ( ) . add ( candidate CaMeL Gene ) ; }	this . get CaMeL Candidates ( ) . add ( cg CaMeL New ) ;
if ( Workbench CaMeL Activity CaMeL Helper . filter CaMeL Item ( node ) )  <CTX>  protected I CaMeL Preference CaMeL Node find CaMeL Node CaMeL Matching ( String node CaMeL Id ) { I CaMeL Preference CaMeL Node node = super . find CaMeL Node CaMeL Matching ( node CaMeL Id ) ; if ( Workbench CaMeL Activity CaMeL Helper . filter CaMeL Item ( node ) ) return null ; return node ; }	if ( Workbench CaMeL Activity CaMeL Helper . filter CaMeL Item ( node ) ) {
score CaMeL Count += food CaMeL Count ( cell ) ;  <CTX>  private void update CaMeL Objects ( ) { score CaMeL Count = 0 ; Cell cell ; java . awt . Point location = new java . awt . Point ( ) ; for ( location . x = 0 ; location . x < size ; ++ location . x ) { for ( location . y = 0 ; location . y < size ; ++ location . y ) { cell = get CaMeL Cell ( location ) ; cell . update ( this , location ) ; score CaMeL Count += food CaMeL Count ( cell ) ; } } }	score CaMeL Count += points CaMeL Count ( cell ) ; food CaMeL Count += cell . get CaMeL All CaMeL With CaMeL Property ( Names . k CaMeL Property CaMeL Edible ) . size ( ) ;
Design CaMeL Element CaMeL Handle data CaMeL Item CaMeL Handle = Insert CaMeL In CaMeL Layout CaMeL Util . perform CaMeL Insert ( column CaMeL List . get ( index ) ,  <CTX>  protected void ok CaMeL Pressed ( ) { try { input CaMeL Group . set CaMeL Name ( name CaMeL Editor . get CaMeL Text ( ) ) ; String new CaMeL Toc = UI CaMeL Util . convert CaMeL To CaMeL Model CaMeL String ( toc CaMeL Editor . get CaMeL Text ( ) , true ) ; if ( new CaMeL Toc != input CaMeL Group . get CaMeL Toc CaMeL Expression ( ) ) { if ( new CaMeL Toc == null || ! new CaMeL Toc . equals ( input CaMeL Group . get CaMeL Toc CaMeL Expression ( ) ) ) { input CaMeL Group . set CaMeL Toc CaMeL Expression ( new CaMeL Toc ) ; } } int index = key CaMeL Chooser . get CaMeL Selection CaMeL Index ( ) ; String old CaMeL Key = input CaMeL Group . get CaMeL Key CaMeL Expr ( ) ; String new CaMeL Key = get CaMeL Key CaMeL Expression ( ) ; input CaMeL Group . set CaMeL Key CaMeL Expr ( new CaMeL Key ) ; if ( new CaMeL Key != null && ! new CaMeL Key . equals ( old CaMeL Key ) ) { Slot CaMeL Handle slot CaMeL Handle = null ; if ( input CaMeL Group instanceof List CaMeL Group CaMeL Handle ) { slot CaMeL Handle = input CaMeL Group . get CaMeL Header ( ) ; } else if ( input CaMeL Group instanceof Table CaMeL Group CaMeL Handle ) { if ( input CaMeL Group . get CaMeL Header ( ) . get CaMeL Count ( ) != 0 ) { Row CaMeL Handle row CaMeL Handle = ( ( Row CaMeL Handle ) input CaMeL Group . get CaMeL Header ( ) . get ( 0 ) ) ; Cell CaMeL Handle cell CaMeL Handle = ( Cell CaMeL Handle ) row CaMeL Handle . get CaMeL Cells ( ) . get ( 0 ) ; slot CaMeL Handle = cell CaMeL Handle . get CaMeL Content ( ) ; } } if ( slot CaMeL Handle != null ) { Design CaMeL Element CaMeL Handle data CaMeL Item CaMeL Handle = Insert CaMeL In CaMeL Layout CaMeL Util . perform CaMeL Insert ( column CaMeL List . get ( index ) , slot CaMeL Handle , input CaMeL Group . get CaMeL Container ( ) ) ; slot CaMeL Handle . add ( data CaMeL Item CaMeL Handle ) ; } } index = interval CaMeL Type . get CaMeL Selection CaMeL Index ( ) ; input CaMeL Group . set CaMeL Interval ( interval CaMeL Choices [ index ] . get CaMeL Name ( ) ) ; if ( index != 0 ) { input CaMeL Group . set CaMeL Interval CaMeL Range ( interval CaMeL Range . get CaMeL Selection ( ) ) ; } if ( input CaMeL Group instanceof Table CaMeL Group CaMeL Handle ) { if ( include CaMeL Header . get CaMeL Selection ( ) != input CaMeL Group . has CaMeL Header ( ) ) { / / the include header status changed if ( include CaMeL Header . get CaMeL Selection ( ) ) { / / from unchecked to checked input CaMeL Group . get CaMeL Header ( ) . add ( create CaMeL Row ( ) ) ; } else { / / from checked to unchecked , clear the slot input CaMeL Group . clear CaMeL Contents ( Group CaMeL Handle . HEADER _ SLOT ) ; } } if ( include CaMeL Footer . get CaMeL Selection ( ) != input CaMeL Group . has CaMeL Footer ( ) ) { / / the include footer status changed if ( include CaMeL Footer . get CaMeL Selection ( ) ) { / / from unchecked to checked input CaMeL Group . get CaMeL Footer ( ) . add ( create CaMeL Row ( ) ) ; } else { / / from checked to unchecked , clear the slot input CaMeL Group . clear CaMeL Contents ( Group CaMeL Handle . FOOTER _ SLOT ) ; } } } if ( ascending . get CaMeL Selection ( ) ) { input CaMeL Group . set CaMeL Sort CaMeL Direction ( Design CaMeL Choice CaMeL Constants . SORT _ DIRECTION _ ASC ) ; } else { input CaMeL Group . set CaMeL Sort CaMeL Direction ( Design CaMeL Choice CaMeL Constants . SORT _ DIRECTION _ DESC ) ; } } catch ( Semantic CaMeL Exception e ) { Exception CaMeL Handler . handle ( e ) ; return ; } set CaMeL Result ( input CaMeL Group ) ; super . ok CaMeL Pressed ( ) ; }	Design CaMeL Element CaMeL Handle data CaMeL Item CaMeL Handle = Insert CaMeL In CaMeL Layout CaMeL Util . perform CaMeL Insert ( new CaMeL Key CaMeL Expr . trim ( ) ,
super ( null , null , null , null , ENDPOINT _ TYPE _ SENDER _ AND _ RECEIVER , 0 , null , new Hash CaMeL Map ( ) ) ;  <CTX>  public Mule CaMeL Endpoint ( ) { super ( null , null , null , null , ENDPOINT _ TYPE _ SENDER _ AND _ RECEIVER , 0 , null , new Hash CaMeL Map ( ) ) ; }	super ( null , null , null , null , ENDPOINT _ TYPE _ SENDER _ AND _ RECEIVER , 0 , null , null ) ;
x . set CaMeL Javadoc ( ( Javadoc ) value ) ;  <CTX>  public void set ( AST CaMeL Node value ) { x . set CaMeL Javadoc ( ( Javadoc ) value ) ; }	x . set CaMeL Body ( ( Block ) value ) ;
Assert . assert ( - 1 != native CaMeL RDF CaMeL Node ) ;  <CTX>  public Enumeration children ( ) { Assert . assert ( - 1 != native CaMeL RDF CaMeL Node ) ; Enumeration enum = null ; enum = new RDF CaMeL Enumeration ( native CaMeL Web CaMeL Shell , this ) ; return enum ; }	Assert . assert _ it ( - 1 != native CaMeL RDF CaMeL Node ) ;
save CaMeL Project CaMeL Item CaMeL Action CaMeL Performed ( evt ) ;  <CTX>  public void action CaMeL Performed ( java . awt . event . Action CaMeL Event evt ) { save CaMeL Project CaMeL Item CaMeL Action CaMeL Performed ( evt ) ; }	exit CaMeL Item CaMeL Action CaMeL Performed ( evt ) ;
user CaMeL Agent . handle CaMeL Element ( elt , data ) ;  <CTX>  public void run ( ) { user CaMeL Agent . handle CaMeL Element ( elt , data ) ; }	user CaMeL Agent . register CaMeL Extension ( ext ) ;
text CaMeL Document CaMeL Domain CaMeL Object . set CaMeL Archived CaMeL Datetime ( new Date ( 0 ) ) ; assert CaMeL False ( internal CaMeL User . can CaMeL Edit ( text CaMeL Document CaMeL Domain CaMeL Object ) ) ; assert CaMeL True ( internal CaMeL User . can CaMeL Access ( text CaMeL Document CaMeL Domain CaMeL Object ) ) ;  <CTX>  public void test CaMeL Menu CaMeL Get CaMeL Documents CaMeL Includes CaMeL Archived ( ) throws Exception { internal CaMeL User . add CaMeL Role ( read CaMeL Role ) ; text CaMeL Document CaMeL Domain CaMeL Object . set CaMeL Archived CaMeL Datetime ( new Date ( 0 ) ) ; assert CaMeL False ( internal CaMeL User . can CaMeL Edit ( text CaMeL Document CaMeL Domain CaMeL Object ) ) ; assert CaMeL True ( internal CaMeL User . can CaMeL Access ( text CaMeL Document CaMeL Domain CaMeL Object ) ) ; assert CaMeL True ( menu . get CaMeL Documents ( ) . length > 0 ) ; }	text CaMeL Document . set CaMeL Archived CaMeL Datetime ( new Date ( 0 ) ) ; assert CaMeL False ( internal CaMeL User . can CaMeL Edit ( text CaMeL Document ) ) ; assert CaMeL True ( internal CaMeL User . can CaMeL Access ( text CaMeL Document ) ) ;
if ( resource CaMeL Type == I CaMeL Resource . ROOT ) res = root ; else if ( resource CaMeL Type == I CaMeL Resource . PROJECT ) res = root . get CaMeL Project ( file CaMeL Name ) ; else if ( resource CaMeL Type == I CaMeL Resource . FOLDER ) res = root . get CaMeL Folder ( new Path ( file CaMeL Name ) ) ; else if ( resource CaMeL Type == I CaMeL Resource . FILE ) res = root . get CaMeL File ( new Path ( file CaMeL Name ) ) ;  <CTX>  public I CaMeL Adaptable create CaMeL Element ( I CaMeL Memento memento ) { / / Get the file name . String file CaMeL Name = memento . get CaMeL String ( TAG _ PATH ) ; if ( file CaMeL Name == null ) return null ; I CaMeL Workspace CaMeL Root root = Resources CaMeL Plugin . get CaMeL Workspace ( ) . get CaMeL Root ( ) ; String type = memento . get CaMeL String ( TAG _ TYPE ) ; if ( type == null ) { / / Old format memento . Create an I CaMeL Resource using find CaMeL Member . / / Will return null for resources in closed projects . res = root . find CaMeL Member ( new Path ( file CaMeL Name ) ) ; } else { int resource CaMeL Type = Integer . parse CaMeL Int ( type ) ; if ( resource CaMeL Type == I CaMeL Resource . ROOT ) res = root ; else if ( resource CaMeL Type == I CaMeL Resource . PROJECT ) res = root . get CaMeL Project ( file CaMeL Name ) ; else if ( resource CaMeL Type == I CaMeL Resource . FOLDER ) res = root . get CaMeL Folder ( new Path ( file CaMeL Name ) ) ; else if ( resource CaMeL Type == I CaMeL Resource . FILE ) res = root . get CaMeL File ( new Path ( file CaMeL Name ) ) ; } return res ; }	if ( resource CaMeL Type == I CaMeL Resource . ROOT ) { res = root ; } else if ( resource CaMeL Type == I CaMeL Resource . PROJECT ) { res = root . get CaMeL Project ( file CaMeL Name ) ; } else if ( resource CaMeL Type == I CaMeL Resource . FOLDER ) { res = root . get CaMeL Folder ( new Path ( file CaMeL Name ) ) ; } else if ( resource CaMeL Type == I CaMeL Resource . FILE ) { res = root . get CaMeL File ( new Path ( file CaMeL Name ) ) ; }
last . put ( self , new Integer ( nodes . size ( ) ) ) ;  <CTX>  private void build CaMeL Nodes CaMeL List ( ) { / / add dummy start node nodes . add ( new Dummy CaMeL Node ( ) ) ; / / add nodes in stream SIR CaMeL Iterator it = Iter CaMeL Factory . create CaMeL Iter ( str ) ; it . accept ( new Empty CaMeL Stream CaMeL Visitor ( ) { public void pre CaMeL Visit CaMeL Stream ( SIR CaMeL Stream self , SIR CaMeL Iterator iter ) { first . put ( self , new Integer ( nodes . size ( ) ) ) ; } public void post CaMeL Visit CaMeL Stream ( SIR CaMeL Stream self , SIR CaMeL Iterator iter ) { last . put ( self , new Integer ( nodes . size ( ) ) ) ; } public void visit CaMeL Filter ( SIR CaMeL Filter self , SIR CaMeL Filter CaMeL Iter iter ) { nodes . add ( self ) ; } public void pre CaMeL Visit CaMeL Feedback CaMeL Loop ( SIR CaMeL Feedback CaMeL Loop self , SIR CaMeL Feedback CaMeL Loop CaMeL Iter iter ) { super . pre CaMeL Visit CaMeL Feedback CaMeL Loop ( self , iter ) ; nodes . add ( self . get CaMeL Joiner ( ) ) ; } public void post CaMeL Visit CaMeL Split CaMeL Join ( SIR CaMeL Split CaMeL Join self , SIR CaMeL Split CaMeL Join CaMeL Iter iter ) { nodes . add ( self . get CaMeL Joiner ( ) ) ; super . post CaMeL Visit CaMeL Split CaMeL Join ( self , iter ) ; } } ) ; / / add dummy end node nodes . add ( new Dummy CaMeL Node ( ) ) ; }	last . put ( self , new Integer ( nodes . size ( ) - 1 ) ) ;
if ( a [ i ] != b . char CaMeL At ( i ) ) {  <CTX>  public static boolean equals ( char [ ] a , String b ) { int len = a . length ; if ( len != b . length ( ) ) { return false ; } for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( a [ i ] != b . char CaMeL At ( i ) ) { return false ; } } return true ; }	if ( a [ i ] != b [ i ] ) {
get CaMeL Thread CaMeL Reference ( ) . pop CaMeL Frames ( stack CaMeL Frame . get CaMeL Stack CaMeL Frame ( ) ) ;  <CTX>  public void pop CaMeL Frames ( Stack CaMeL Frame CaMeL Proxy CaMeL Impl stack CaMeL Frame ) throws Evaluate CaMeL Exception { Debugger CaMeL Manager CaMeL Thread CaMeL Impl . assert CaMeL Is CaMeL Manager CaMeL Thread ( ) ; try { get CaMeL Thread CaMeL Reference ( ) . pop CaMeL Frames ( stack CaMeL Frame . get CaMeL Stack CaMeL Frame ( ) ) ; } catch ( Internal CaMeL Exception e ) { throw Evaluate CaMeL Exception CaMeL Util . create CaMeL Evaluate CaMeL Exception ( e ) ; } catch ( Incompatible CaMeL Thread CaMeL State CaMeL Exception e ) { throw Evaluate CaMeL Exception CaMeL Util . create CaMeL Evaluate CaMeL Exception ( e ) ; } finally { clear CaMeL Caches ( ) ; get CaMeL Virtual CaMeL Machine CaMeL Proxy ( ) . clear CaMeL Caches ( ) ; } }	thread CaMeL Ref . pop CaMeL Frames ( stack CaMeL Frame . get CaMeL Stack CaMeL Frame ( ) ) ;
long count = 1 ;  <CTX>  public void apply ( Call CaMeL Context ctx ) throws Throwable { Object values = ctx . get CaMeL Next CaMeL Arg ( ) ; Procedure proc = ( Procedure ) ctx . get CaMeL Next CaMeL Arg ( ) ; long count = 1 ; int index = 0 ; Consumer out = ctx . consumer ; for ( ; ; ) { int next = Values . next CaMeL Index ( values , index ) ; if ( next < 0 ) break ; Object value = Values . next CaMeL Value ( values , index ) ; if ( matches ( proc . apply 1 ( value ) , count ) ) out . write CaMeL Object ( value ) ; count ++ ; index = next ; } }	long count = 0 ;
i CaMeL Array [ i ] = get CaMeL Sample ( x , y , 0 , data ) ;  <CTX>  public int [ ] get CaMeL Pixel ( int x , int y , int [ ] i CaMeL Array , Data CaMeL Buffer data ) { if ( i CaMeL Array == null ) i CaMeL Array = new int [ num CaMeL Bands ] ; for ( int i = 0 ; i < num CaMeL Bands ; i ++ ) i CaMeL Array [ i ] = get CaMeL Sample ( x , y , 0 , data ) ; return i CaMeL Array ; }	i CaMeL Array [ i ] = get CaMeL Sample ( x , y , i , data ) ;
else if ( offse@@ table instanceof Macro ) { create CaMeL Macro ( translation CaMeL Unit , ( Macro ) offse@@ table ) ; } else if ( offse@@ table instanceof Declaration ) { generate CaMeL Model CaMeL Elements ( translation CaMeL Unit , ( Declaration ) offse@@ table ) ;  <CTX>  protected void generate CaMeL Model CaMeL Elements ( Translation CaMeL Unit tu ) { Iterator i = tu . iterate CaMeL Off@@ se@@ table CaMeL Elements ( ) ; while ( i . has CaMeL Next ( ) ) { I CaMeL Off@@ se@@ table offse@@ table = ( I CaMeL Off@@ se@@ table ) i . next ( ) ; if ( offse@@ table instanceof Inclusion ) { create CaMeL Inclusion ( translation CaMeL Unit , ( Inclusion ) offse@@ table ) ; } else if ( offse@@ table instanceof Macro ) { create CaMeL Macro ( translation CaMeL Unit , ( Macro ) offse@@ table ) ; } else if ( offse@@ table instanceof Declaration ) { generate CaMeL Model CaMeL Elements ( translation CaMeL Unit , ( Declaration ) offse@@ table ) ; } } }	else if ( offse@@ table instanceof IAST CaMeL Macro ) { create CaMeL Macro ( translation CaMeL Unit , ( IAST CaMeL Macro ) offse@@ table ) ; } else if ( offse@@ table instanceof IAST CaMeL Declaration ) { try { generate CaMeL Model CaMeL Elements ( translation CaMeL Unit , ( IAST CaMeL Declaration ) offse@@ table ) ; } catch ( AST CaMeL Not CaMeL Implemented CaMeL Exception e ) { }
res = f CaMeL Source CaMeL Locator . get CaMeL Source CaMeL Element ( stack CaMeL Frame ) ;  <CTX>  public Object get CaMeL Source CaMeL Element ( I CaMeL Stack CaMeL Frame stack CaMeL Frame ) { Object res = cache CaMeL Lookup ( stack CaMeL Frame ) ; if ( res == null ) { res = f CaMeL Source CaMeL Locator . get CaMeL Source CaMeL Element ( stack CaMeL Frame ) ; if ( res instanceof List ) { List list = ( List ) res ; if ( list . size ( ) != 0 ) { Source CaMeL Selection CaMeL Dialog dialog = create CaMeL Source CaMeL Selection CaMeL Dialog ( list ) ; dialog . open ( ) ; Object [ ] objs = dialog . get CaMeL Result ( ) ; res = ( objs != null && objs . length > 0 ) ? objs [ 0 ] : null ; if ( res != null ) cache CaMeL Source CaMeL Element ( stack CaMeL Frame , res , dialog . always CaMeL Map CaMeL To CaMeL Selection ( ) ) ; } else res = null ; } } if ( res == null ) { I CaMeL Stack CaMeL Frame CaMeL Info frame CaMeL Info = ( I CaMeL Stack CaMeL Frame CaMeL Info ) stack CaMeL Frame . get CaMeL Adapter ( I CaMeL Stack CaMeL Frame CaMeL Info . class ) ; if ( frame CaMeL Info != null && frame CaMeL Info . get CaMeL File ( ) != null && frame CaMeL Info . get CaMeL File ( ) . length ( ) > 0 ) { res = new File CaMeL Not CaMeL Found CaMeL Element ( stack CaMeL Frame ) ; } else / / don t show in editor { res = new No CaMeL Symbol CaMeL Or CaMeL Source CaMeL Element ( stack CaMeL Frame ) ; } } return res ; }	res = get CaMeL C CaMeL Source CaMeL Locator ( ) . get CaMeL Source CaMeL Element ( stack CaMeL Frame ) ;
Vector new CaMeL Vect = new Vector ( ) ;  <CTX>  public Vector make CaMeL Vector ( String [ ] string CaMeL Array ) { Vector new CaMeL Vect = new Vector ( ) ; int c = 0 ; try { for ( c = 0 ; c < string CaMeL Array . length ; c ++ ) { / / this should throw an expec@@ tion when we hit the end string CaMeL Array [ c ] = string CaMeL Array [ c ] . trim ( ) ; new CaMeL Vect . add ( string CaMeL Array [ c ] ) ; } } catch ( Array CaMeL Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception e ) { / / we re done . . . return the vector return new CaMeL Vect ; } return new CaMeL Vect ; / / just to make sure ; - ? }	Vector < String > new CaMeL Vect = new Vector < String > ( ) ;
if ( ( arg . flags ( ) & ARG _ OUT . value ) != 0 ) { arg . value ( ) . read _ value ( input , arg . value ( ) . type ( ) ) ; } } catch ( Bounds ex ) { Unexpected . error ( ex ) ; } }  <CTX>  public void invoke ( ) { Invoke CaMeL Handler handler = object . get CaMeL Handler ( operation ( ) , cookie , false ) ; if ( handler instanceof dyn CaMeL Imp CaMeL Handler ) { Dynamic CaMeL Implementation dyn = ( ( dyn CaMeL Imp CaMeL Handler ) handler ) . servant ; if ( server CaMeL Request == null ) server CaMeL Request = new Local CaMeL Server CaMeL Request ( this ) ; try { poa . m _ orb . curren@@ ts . put ( Thread . current CaMeL Thread ( ) , this ) ; dyn . invoke ( server CaMeL Request ) ; } finally { poa . m _ orb . curren@@ ts . remove ( Thread . current CaMeL Thread ( ) ) ; } } else { org . omg . CORBA . portable . Input CaMeL Stream input = v _ invoke ( handler ) ; if ( ! exception CaMeL Reply ) { Named CaMeL Value arg ; / / Read return value , if set . if ( m _ result != null ) { m _ result . value ( ) . read _ value ( input , m _ result . value ( ) . type ( ) ) ; } / / Read returned parameters , if set . if ( m _ args != null ) for ( int i = 0 ; i < m _ args . count ( ) ; i ++ ) { try { arg = m _ args . item ( i ) ; / / Both ARG _ INOUT and ARG _ OUT have this binary flag set . if ( ( arg . flags ( ) & ARG _ OUT . value ) != 0 ) { arg . value ( ) . read _ value ( input , arg . value ( ) . type ( ) ) ; } } catch ( Bounds ex ) { Unexpected . error ( ex ) ; } } } else / / User exception reply { / / Prepare an Any that will hold the exception . gnu CaMeL Any exc = new gnu CaMeL Any ( ) ; exc . insert _ Streamable ( new stream CaMeL Ready CaMeL Holder ( input ) ) ; Unknown CaMeL User CaMeL Exception un@@ uex = new Unknown CaMeL User CaMeL Exception ( exc ) ; m _ environment . exception ( un@@ uex ) ; } } }	if ( ( arg . flags ( ) & ARG _ OUT . value ) != 0 ) { arg . value ( ) . read _ value ( input , arg . value ( ) . type ( ) ) ; } } catch ( Bounds ex ) { Unexpected . error ( ex ) ; } } }
My@@ lar CaMeL Tasks CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Contributor ( ) != null && My@@ lar CaMeL Tasks CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Contributor ( ) . accepts CaMeL Item ( ( I CaMeL Task CaMeL List CaMeL Element ) selected CaMeL Object ) ) { My@@ lar CaMeL Tasks CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Contributor ( ) . task CaMeL Completed ( ( I CaMeL Task ) selected CaMeL Object ) ;  <CTX>  public void run ( ) { / / My@@ lar CaMeL Plugin . get CaMeL Default ( ) . action CaMeL Observed ( this ) ; Object selected CaMeL Object = ( ( I CaMeL Structured CaMeL Selection ) this . view . get CaMeL Viewer ( ) . get CaMeL Selection ( ) ) . get CaMeL First CaMeL Element ( ) ; if ( selected CaMeL Object instanceof I CaMeL Task && My@@ lar CaMeL Tasks CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Contributor ( ) != null && My@@ lar CaMeL Tasks CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Contributor ( ) . accepts CaMeL Item ( ( I CaMeL Task CaMeL List CaMeL Element ) selected CaMeL Object ) ) { My@@ lar CaMeL Tasks CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Contributor ( ) . task CaMeL Completed ( ( I CaMeL Task ) selected CaMeL Object ) ; } else if ( selected CaMeL Object instanceof Task ) { ( ( Task ) selected CaMeL Object ) . set CaMeL Completed ( true ) ; } this . view . get CaMeL Viewer ( ) . refresh ( ) ; }	My@@ lar CaMeL Tasks CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Contributor CaMeL For CaMeL Element ( ( I CaMeL Task ) selected CaMeL Object ) != null ) { My@@ lar CaMeL Tasks CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Contributor CaMeL For CaMeL Element ( ( I CaMeL Task ) selected CaMeL Object ) . task CaMeL Completed ( ( I CaMeL Task ) selected CaMeL Object ) ;
return file CaMeL Name ;  <CTX>  public String get CaMeL File CaMeL Name ( ) { return file CaMeL Name ; }	return log CaMeL File . get CaMeL Name ( ) ;
result . append ( Ruby CaMeL Array . new CaMeL Array ( get CaMeL Runtime ( ) , key , value ) ) ;  <CTX>  public Ruby CaMeL Array to _ a ( ) { Ruby CaMeL Array result = Ruby CaMeL Array . new CaMeL Array ( get CaMeL Runtime ( ) , length ( ) ) ; for ( Iterator iter = value CaMeL Map . entry CaMeL Set ( ) . iterator ( ) ; iter . has CaMeL Next ( ) ; ) { Map . Entry entry = ( Map . Entry ) iter . next ( ) ; I CaMeL Ruby CaMeL Object key = ( I CaMeL Ruby CaMeL Object ) entry . get CaMeL Key ( ) ; I CaMeL Ruby CaMeL Object value = ( I CaMeL Ruby CaMeL Object ) entry . get CaMeL Value ( ) ; result . append ( Ruby CaMeL Array . new CaMeL Array ( get CaMeL Runtime ( ) , key , value ) ) ; } return result ; }	result . append ( get CaMeL Runtime ( ) . new CaMeL Array ( key , value ) ) ;
grid . set CaMeL Border ( Style CaMeL Util . next CaMeL Border CaMeL Style ( grid . get CaMeL Border ( ) ) ) ;  <CTX>  public void action CaMeL Performed ( Action CaMeL Event e ) { grid . set CaMeL Border ( Style CaMeL Util . next CaMeL Border CaMeL Style ( grid . get CaMeL Border ( ) ) ) ; }	grid . set CaMeL Border ( Style CaMeL Util . next CaMeL Border CaMeL Size ( grid . get CaMeL Border ( ) ) ) ;
rs CaMeL Meta ) ;  <CTX>  private static void populate CaMeL Odi CaMeL Result CaMeL Set ( Result CaMeL Set CaMeL Populator populator , Odi CaMeL Result CaMeL Set CaMeL Wrapper rs CaMeL Wrapper , Sort CaMeL Spec sort CaMeL Spec ) throws Data CaMeL Exception { Object result CaMeL Source = rs CaMeL Wrapper . get CaMeL Wrapped CaMeL Odi CaMeL Result CaMeL Set ( ) ; assert result CaMeL Source != null ; Result CaMeL Set CaMeL Cache smart CaMeL Cache = null ; Base CaMeL Query query = populator . get CaMeL Query ( ) ; I CaMeL Result CaMeL Class rs CaMeL Meta = populator . get CaMeL Result CaMeL Set CaMeL Metadata ( ) ; if ( result CaMeL Source instanceof Result CaMeL Set ) { smart CaMeL Cache = new Smart CaMeL Cache ( new Cache CaMeL Request ( query . get CaMeL Max CaMeL Rows ( ) , query . get CaMeL Fetch CaMeL Events ( ) , sort CaMeL Spec , populator . get CaMeL Event CaMeL Handler ( ) , query . get CaMeL Distinct CaMeL Value CaMeL Flag ( ) ) , ( Result CaMeL Set ) result CaMeL Source , rs CaMeL Meta ) ; } else if ( result CaMeL Source instanceof I CaMeL Custom CaMeL Data CaMeL Set ) { smart CaMeL Cache = new Smart CaMeL Cache ( new Cache CaMeL Request ( query . get CaMeL Max CaMeL Rows ( ) , query . get CaMeL Fetch CaMeL Events ( ) , sort CaMeL Spec , populator . get CaMeL Event CaMeL Handler ( ) , query . get CaMeL Distinct CaMeL Value CaMeL Flag ( ) ) , new Odi CaMeL Adapter ( ( I CaMeL Custom CaMeL Data CaMeL Set ) result CaMeL Source ) , rs CaMeL Meta ) ; } else if ( result CaMeL Source instanceof I CaMeL Data CaMeL Set CaMeL Populator ) { smart CaMeL Cache = new Smart CaMeL Cache ( new Cache CaMeL Request ( query . get CaMeL Max CaMeL Rows ( ) , query . get CaMeL Fetch CaMeL Events ( ) , sort CaMeL Spec , populator . get CaMeL Event CaMeL Handler ( ) , query . get CaMeL Distinct CaMeL Value CaMeL Flag ( ) ) , new Odi CaMeL Adapter ( ( I CaMeL Data CaMeL Set CaMeL Populator ) result CaMeL Source ) , rs CaMeL Meta ) ; } else if ( result CaMeL Source instanceof Data CaMeL Set CaMeL Result CaMeL Cache ) { smart CaMeL Cache = new Smart CaMeL Cache ( new Cache CaMeL Request ( query . get CaMeL Max CaMeL Rows ( ) , query . get CaMeL Fetch CaMeL Events ( ) , sort CaMeL Spec , populator . get CaMeL Event CaMeL Handler ( ) , false ) , / / must be true new Odi CaMeL Adapter ( ( Data CaMeL Set CaMeL Result CaMeL Cache ) result CaMeL Source ) , rs CaMeL Meta ) ; } else if ( result CaMeL Source instanceof I CaMeL Result CaMeL Iterator ) { smart CaMeL Cache = new Smart CaMeL Cache ( new Cache CaMeL Request ( query . get CaMeL Max CaMeL Rows ( ) , query . get CaMeL Fetch CaMeL Events ( ) , sort CaMeL Spec , populator . get CaMeL Event CaMeL Handler ( ) , false ) , / / must be true new Odi CaMeL Adapter ( ( I CaMeL Result CaMeL Iterator ) result CaMeL Source ) , rs CaMeL Meta ) ; } else if ( result CaMeL Source instanceof Object [ ] ) { Object [ ] obs = ( Object [ ] ) result CaMeL Source ; smart CaMeL Cache = new Smart CaMeL Cache ( new Cache CaMeL Request ( query . get CaMeL Max CaMeL Rows ( ) , query . get CaMeL Fetch CaMeL Events ( ) , sort CaMeL Spec , populator . get CaMeL Event CaMeL Handler ( ) , false ) , / / must be true ( Result CaMeL Set CaMeL Cache ) obs [ 0 ] , ( ( int [ ] ) obs [ 1 ] ) [ 0 ] , ( ( int [ ] ) obs [ 1 ] ) [ 1 ] , rs CaMeL Meta ) ; } populator . get CaMeL Group CaMeL Processor CaMeL Manager ( ) . get CaMeL Group CaMeL Calculation CaMeL Util ( ) . set CaMeL Result CaMeL Set CaMeL Cache ( smart CaMeL Cache ) ; populator . set CaMeL Cache ( smart CaMeL Cache ) ; }	rs CaMeL Meta , session ) ;
EO CaMeL Enterprise CaMeL Object eo = ( EO CaMeL Enterprise CaMeL Object ) display CaMeL Group ( ) . all CaMeL Objects ( ) . object CaMeL At CaMeL Index ( 0 ) ; return eo . editing CaMeL Context ( ) ;  <CTX>  public EO CaMeL Editing CaMeL Context editing CaMeL Context ( ) { EO CaMeL Enterprise CaMeL Object eo = ( EO CaMeL Enterprise CaMeL Object ) display CaMeL Group ( ) . all CaMeL Objects ( ) . object CaMeL At CaMeL Index ( 0 ) ; return eo . editing CaMeL Context ( ) ; }	return display CaMeL Group ( ) . data CaMeL Source ( ) . editing CaMeL Context ( ) ;
Pet CaMeL Name pn = user . get CaMeL Pet CaMeL Name CaMeL DB ( ) . get CaMeL By CaMeL Name ( req . get CaMeL Parameter ( Addresses CaMeL Servlet . PARAM _ NAME ) ) ;  <CTX>  private boolean handle CaMeL Addres@@ s@@ book ( User user , Http CaMeL Servlet CaMeL Request req ) { if ( ( ! user . get CaMeL Authenticated ( ) ) || ( empty ( Addresses CaMeL Servlet . PARAM _ ACTION ) ) ) { return false ; } String action = req . get CaMeL Parameter ( Addresses CaMeL Servlet . PARAM _ ACTION ) ; if ( Addresses CaMeL Servlet . ACTION _ ADD _ TAG . equals ( action ) ) { String name = req . get CaMeL Parameter ( Addresses CaMeL Servlet . PARAM _ NAME ) ; if ( ! user . get CaMeL Pet CaMeL Name CaMeL DB ( ) . contains CaMeL Name ( name ) ) { Pet CaMeL Name pn = new Pet CaMeL Name ( name , Addresses CaMeL Servlet . NET _ SYN@@ DIE , Addresses CaMeL Servlet . PROTO _ TAG , name ) ; user . get CaMeL Pet CaMeL Name CaMeL DB ( ) . add ( pn ) ; Blog CaMeL Manager . instance ( ) . save CaMeL User ( user ) ; } return false ; } else if ( ( Addresses CaMeL Servlet . ACTION _ ADD _ ARCHIVE . equals ( action ) ) || ( Addresses CaMeL Servlet . ACTION _ ADD _ B@@ LOG . equals ( action ) ) || ( Addresses CaMeL Servlet . ACTION _ ADD _ E@@ EP@@ SITE . equals ( action ) ) || ( Addresses CaMeL Servlet . ACTION _ ADD _ OTHER . equals ( action ) ) || ( Addresses CaMeL Servlet . ACTION _ ADD _ PEER . equals ( action ) ) ) { Pet CaMeL Name pn = build CaMeL New CaMeL Address ( req ) ; if ( ( pn != null ) && ( pn . get CaMeL Name ( ) != null ) && ( pn . get CaMeL Location ( ) != null ) && ( ! user . get CaMeL Pet CaMeL Name CaMeL DB ( ) . contains CaMeL Name ( pn . get CaMeL Name ( ) ) ) ) { user . get CaMeL Pet CaMeL Name CaMeL DB ( ) . add ( pn ) ; Blog CaMeL Manager . instance ( ) . save CaMeL User ( user ) ; update CaMeL Syn@@ di@@ cation ( user , pn . get CaMeL Location ( ) , ! empty ( req , Addresses CaMeL Servlet . PARAM _ SYN@@ DIC@@ ATE ) ) ; if ( pn . is CaMeL Member ( Filtered CaMeL Thread CaMeL Index . GROUP _ FAV@@ OR@@ ITE ) || pn . is CaMeL Member ( Filtered CaMeL Thread CaMeL Index . GROUP _ IGNORE ) ) return true ; else return false ; } else { / / not valid , ignore return false ; } } else if ( ( Addresses CaMeL Servlet . ACTION _ UPDATE _ ARCHIVE . equals ( action ) ) || ( Addresses CaMeL Servlet . ACTION _ UPDATE _ B@@ LOG . equals ( action ) ) || ( Addresses CaMeL Servlet . ACTION _ UPDATE _ E@@ EP@@ SITE . equals ( action ) ) || ( Addresses CaMeL Servlet . ACTION _ UPDATE _ OTHER . equals ( action ) ) || ( Addresses CaMeL Servlet . ACTION _ UPDATE _ PEER . equals ( action ) ) ) { return update CaMeL Address ( user , req ) ; } else if ( ( Addresses CaMeL Servlet . ACTION _ DELETE _ ARCHIVE . equals ( action ) ) || ( Addresses CaMeL Servlet . ACTION _ DELETE _ B@@ LOG . equals ( action ) ) || ( Addresses CaMeL Servlet . ACTION _ DELETE _ E@@ EP@@ SITE . equals ( action ) ) || ( Addresses CaMeL Servlet . ACTION _ DELETE _ OTHER . equals ( action ) ) || ( Addresses CaMeL Servlet . ACTION _ DELETE _ TAG . equals ( action ) ) || ( Addresses CaMeL Servlet . ACTION _ DELETE _ PEER . equals ( action ) ) ) { Pet CaMeL Name pn = user . get CaMeL Pet CaMeL Name CaMeL DB ( ) . get CaMeL By CaMeL Name ( req . get CaMeL Parameter ( Addresses CaMeL Servlet . PARAM _ NAME ) ) ; if ( pn != null ) { user . get CaMeL Pet CaMeL Name CaMeL DB ( ) . remove ( pn ) ; Blog CaMeL Manager . instance ( ) . save CaMeL User ( user ) ; update CaMeL Syn@@ di@@ cation ( user , pn . get CaMeL Location ( ) , false ) ; if ( pn . is CaMeL Member ( Filtered CaMeL Thread CaMeL Index . GROUP _ FAV@@ OR@@ ITE ) || pn . is CaMeL Member ( Filtered CaMeL Thread CaMeL Index . GROUP _ IGNORE ) ) return true ; else return false ; } else { return false ; } } else { / / not an addres@@ s@@ book op return false ; } }	String name = req . get CaMeL Parameter ( Addresses CaMeL Servlet . PARAM _ NAME ) ; Pet CaMeL Name pn = user . get CaMeL Pet CaMeL Name CaMeL DB ( ) . get CaMeL By CaMeL Name ( name ) ;
Date date = Time CaMeL Util . parse CaMeL Date ( date CaMeL Str ) ;  <CTX>  public void handle CaMeL DAV CaMeL Response ( DAV CaMeL Response child ) { String href = Path CaMeL Util . remove CaMeL Trailing CaMeL Slash ( child . get CaMeL Href ( ) ) ; href = Path CaMeL Util . decode ( href ) ; String name = Path CaMeL Util . tail ( href ) ; / / build di@@ ren@@ try SVN CaMeL Node CaMeL Kind kind = SVN CaMeL Node CaMeL Kind . FILE ; Object revision CaMeL Str = child . get CaMeL Property CaMeL Value ( DAV CaMeL Element . VERSION _ NAME ) ; long last CaMeL Revision = Long . parse CaMeL Long ( revision CaMeL Str . to CaMeL String ( ) ) ; String size CaMeL Str = ( String ) child . get CaMeL Property CaMeL Value ( DAV CaMeL Element . GET _ CONTENT _ LENGTH ) ; long size = size CaMeL Str == null ? 0 : Long . parse CaMeL Long ( size CaMeL Str ) ; if ( child . get CaMeL Property CaMeL Value ( DAV CaMeL Element . RESOURCE _ TYPE ) == DAV CaMeL Element . COLLECTION ) { kind = SVN CaMeL Node CaMeL Kind . DIR ; } String author = ( String ) child . get CaMeL Property CaMeL Value ( DAV CaMeL Element . CREATOR _ DISPLAY _ NAME ) ; String date CaMeL Str = ( String ) child . get CaMeL Property CaMeL Value ( DAV CaMeL Element . CREATION _ DATE ) ; Date date = Time CaMeL Util . parse CaMeL Date ( date CaMeL Str ) ; boolean has CaMeL Properties = false ; for ( Iterator props = child . properties ( ) ; props . has CaMeL Next ( ) ; ) { DAV CaMeL Element property = ( DAV CaMeL Element ) props . next ( ) ; if ( DAV CaMeL Element . SVN _ CUSTOM _ PROPERTY _ NAMESPACE . equals ( property . get CaMeL Namespace ( ) ) || DAV CaMeL Element . SVN _ SVN _ PROPERTY _ NAMESPACE . equals ( property ) ) { has CaMeL Properties = true ; break ; } } result [ 0 ] = new SVN CaMeL Dir CaMeL Entry ( name , kind , size , has CaMeL Properties , last CaMeL Revision , date , author ) ; }	Date date = date CaMeL Str != null ? Time CaMeL Util . parse CaMeL Date ( date CaMeL Str ) : null ;
if ( ! tree CaMeL Is CaMeL Disposed ) { Object data = item . get CaMeL Data ( ) ; if ( using CaMeL Element CaMeL Map ( ) && data != null ) { unmap CaMeL Element ( data , item ) ;  <CTX>  public void widget CaMeL Disposed ( Dispose CaMeL Event e ) { if ( ! tree CaMeL Is CaMeL Disposed ) { Object data = item . get CaMeL Data ( ) ; if ( using CaMeL Element CaMeL Map ( ) && data != null ) { unmap CaMeL Element ( data , item ) ; } } }	if ( ! tree CaMeL Is CaMeL Disposed ) { Object data = item . get CaMeL Data ( ) ; if ( using CaMeL Element CaMeL Map ( ) && data != null ) { unmap CaMeL Element ( data , item ) ; }
static private void stop CaMeL Update CaMeL Reset CaMeL And CaMeL Report ( ) {  <CTX>  static private void stop CaMeL Update CaMeL Reset CaMeL And CaMeL Report ( ) { if ( VM . Build CaMeL For CaMeL H@@ PM && enabled ) { / / - # if RVM _ WITH _ H@@ PM stop CaMeL Update CaMeL And CaMeL Reset ( ) ; Report ( ) ; / / - # endif } }	static private void stop CaMeL Update CaMeL Reset CaMeL And CaMeL Report ( ) throws VM _ Pragma CaMeL Uninterruptible {
return get CaMeL Formatted CaMeL Zone ( zone@@ id , pattern , daylight , date ) ;  <CTX>  public String get CaMeL Formatted CaMeL Zone ( String zone@@ id , String pattern , long date ) { Time CaMeL Zone tz = Time CaMeL Zone . get CaMeL Time CaMeL Zone ( zone@@ id ) ; long gmt CaMeL Offset 1 = tz . get CaMeL Offset ( date ) ; boolean daylight = tz . get CaMeL Raw CaMeL Offset ( ) == gmt CaMeL Offset 1 ; return get CaMeL Formatted CaMeL Zone ( zone@@ id , pattern , daylight , date ) ; }	return get CaMeL Formatted CaMeL Zone ( zone@@ id , pattern , daylight , gmt CaMeL Offset 1 ) ;
if ( f . matches CaMeL Dropped CaMeL Connection ( ) && f . _ source == ctx ) {  <CTX>  public void on CaMeL Disconnect ( Peer CaMeL Context ctx ) { synchronized ( _ filters ) { List CaMeL Iterator i = _ filters . list CaMeL Iterator ( ) ; while ( i . has CaMeL Next ( ) ) { Message CaMeL Filter f = ( Message CaMeL Filter ) i . next ( ) ; if ( f . matches CaMeL Dropped CaMeL Connection ( ) && f . _ source == ctx ) { f . on CaMeL Dropped CaMeL Connection ( ctx ) ; if ( f . dropped CaMeL Connection ( ) != null ) { synchronized ( f ) { f . notify CaMeL All ( ) ; } } } } } }	if ( f . matches CaMeL Dropped CaMeL Connection ( ) && ( f . _ source == ctx ) ) {
my CaMeL Operation CaMeL Context = new Generator CaMeL Tree CaMeL Node CaMeL Operation CaMeL Context ( generator , operation CaMeL Context ) ;  <CTX>  public Generator CaMeL Tree CaMeL Node ( String text , Generator generator , Ide CaMeL Main ide , MPS CaMeL Project project , I CaMeL Operation CaMeL Context operation CaMeL Context ) { super ( text ) ; my CaMeL Generator = generator ; my CaMeL IDE = ide ; my CaMeL Project = project ; my CaMeL Operation CaMeL Context = new Generator CaMeL Tree CaMeL Node CaMeL Operation CaMeL Context ( generator , operation CaMeL Context ) ; populate ( ) ; }	my CaMeL Operation CaMeL Context = Generator CaMeL Operation CaMeL Context . create CaMeL Context ( generator , operation CaMeL Context ) ;
int s@@ proc _ Section CaMeL Add ( final Table _ section section CaMeL Data ) {  <CTX>  int s@@ proc _ Section CaMeL Add ( final Table _ section section CaMeL Data ) { final SQL CaMeL Transaction transaction = sql CaMeL Processor . start CaMeL Transaction ( ) ; transaction . execute CaMeL And CaMeL Commit ( new Transaction CaMeL Content ( ) { public void execute ( ) throws SQL CaMeL Exception { Table _ section text CaMeL Docs CaMeL To CaMeL Be CaMeL Copied = select CaMeL From _ section ( transaction , new Integer ( section CaMeL Data . section _ id ) ) ; if ( null == text CaMeL Docs CaMeL To CaMeL Be CaMeL Copied ) { insert CaMeL Into _ sections ( transaction , section CaMeL Data ) ; } else { update _ sections ( transaction , section CaMeL Data ) ; } } } ) ; return transaction . get CaMeL Row CaMeL Count ( ) ; }	public int s@@ proc _ Section CaMeL Add ( final Table _ section section CaMeL Data ) {
Navigator CaMeL Content CaMeL Extension [ ] result CaMeL Instances = find CaMeL Content CaMeL Extensions CaMeL By CaMeL Trigger CaMeL Point ( an CaMeL Element ) ; return extract CaMeL Content CaMeL Providers ( result CaMeL Instances ) ;  <CTX>  public I CaMeL Tree CaMeL Content CaMeL Provider [ ] find CaMeL Parent CaMeL Content CaMeL Providers ( Object an CaMeL Element ) { Navigator CaMeL Content CaMeL Extension [ ] result CaMeL Instances = find CaMeL Content CaMeL Extensions CaMeL By CaMeL Trigger CaMeL Point ( an CaMeL Element ) ; return extract CaMeL Content CaMeL Providers ( result CaMeL Instances ) ; }	return extract CaMeL Content CaMeL Providers ( find CaMeL Content CaMeL Extensions CaMeL By CaMeL Trigger CaMeL Point ( an CaMeL Element ) ) ;
if ( result != null && result . unschedule CaMeL Firing CaMeL Trigger ( ) ) return INSTRUCTION _ SET _ TRIGGER _ COMPLETE ;  <CTX>  public int execution CaMeL Complete ( Job CaMeL Execution CaMeL Context context , Job CaMeL Execution CaMeL Exception result ) { if ( result != null && result . re@@ fire CaMeL Immediately ( ) ) return INSTRUCTION _ RE _ EXECUTE _ JOB ; if ( result != null && result . unschedule CaMeL Firing CaMeL Trigger ( ) ) return INSTRUCTION _ SET _ TRIGGER _ COMPLETE ; if ( result != null && result . unschedule CaMeL All CaMeL Triggers ( ) ) return INSTRUCTION _ SET _ ALL _ JOB _ TRIGGERS _ COMPLETE ; if ( ! may CaMeL Fire CaMeL Again ( ) ) return INSTRUCTION _ DELETE _ TRIGGER ; return INSTRUCTION _ NOOP ; }	if ( result != null && result . unschedule CaMeL Firing CaMeL Trigger ( ) ) { return INSTRUCTION _ SET _ TRIGGER _ COMPLETE ; }
super ( replacement CaMeL String , replacement CaMeL Offset , replacement CaMeL Length , image , display CaMeL String , relevance ) ; this . local CaMeL String = display CaMeL String ;  <CTX>  public Annotation CaMeL Tag CaMeL Proposal ( String replacement CaMeL String , int replacement CaMeL Offset , int replacement CaMeL Length , Image image , String display CaMeL String , int relevance ) { super ( replacement CaMeL String , replacement CaMeL Offset , replacement CaMeL Length , image , display CaMeL String , relevance ) ; this . local CaMeL String = display CaMeL String ; }	Assert . is CaMeL Not CaMeL Null ( replacement CaMeL String ) ; Assert . is CaMeL True ( replacement CaMeL Offset >= 0 ) ; Assert . is CaMeL True ( replacement CaMeL Length >= 0 ) ; set CaMeL Replacement CaMeL String ( replacement CaMeL String ) ; set CaMeL Replacement CaMeL Offset ( replacement CaMeL Offset ) ; set CaMeL Replacement CaMeL Length ( replacement CaMeL Length ) ; set CaMeL Image ( image ) ; set CaMeL Display CaMeL String ( display CaMeL String == null ? replacement CaMeL String : display CaMeL String ) ; set CaMeL Relevance ( relevance ) ; set CaMeL Cursor CaMeL Position ( replacement CaMeL String . length ( ) ) ; set CaMeL Sort CaMeL String ( display CaMeL String == null ? replacement CaMeL String : display CaMeL String ) ; this . local CaMeL String = replacement CaMeL String ;
return Ruby CaMeL Array . new CaMeL Array ( runtime , runtime . get CaMeL Load CaMeL Service ( ) . get CaMeL Loaded CaMeL Features ( ) ) ;  <CTX>  public I CaMeL Ruby CaMeL Object get ( ) { return Ruby CaMeL Array . new CaMeL Array ( runtime , runtime . get CaMeL Load CaMeL Service ( ) . get CaMeL Loaded CaMeL Features ( ) ) ; }	return runtime . new CaMeL Array ( runtime . get CaMeL Load CaMeL Service ( ) . get CaMeL Loaded CaMeL Features ( ) ) ;
return is CaMeL Subclass ( a CaMeL Class , ancestor CaMeL Name , new Hash CaMeL Set ( ) ) ;  <CTX>  public static boolean is CaMeL Subclass ( Psi CaMeL Class a CaMeL Class , String ancestor CaMeL Name ) { return is CaMeL Subclass ( a CaMeL Class , ancestor CaMeL Name , new Hash CaMeL Set ( ) ) ; }	final Psi CaMeL Manager psi CaMeL Manager = a CaMeL Class . get CaMeL Manager ( ) ; final Project project = psi CaMeL Manager . get CaMeL Project ( ) ; final Global CaMeL Search CaMeL Scope scope = Global CaMeL Search CaMeL Scope . all CaMeL Scope ( project ) ; final Psi CaMeL Class ancestor CaMeL Class = psi CaMeL Manager . find CaMeL Class ( ancestor CaMeL Name , scope ) ; return Inheritance CaMeL Util . is CaMeL Inheritor CaMeL Or CaMeL Self ( a CaMeL Class , ancestor CaMeL Class , false ) ;
return false ;  <CTX>  private boolean find CaMeL Servlet ( ) { Array CaMeL List component CaMeL Data = new Array CaMeL List ( ) ; Component CaMeL Data society CaMeL Data = experiment . get CaMeL Society CaMeL Component CaMeL Data ( ) ; Component CaMeL Data [ ] cdata = society CaMeL Data . get CaMeL Children ( ) ; for ( int i = 0 ; i < cdata . length ; i ++ ) component CaMeL Data . add ( cdata [ i ] ) ; for ( int i = 0 ; i < component CaMeL Data . size ( ) ; i ++ ) { Object o = component CaMeL Data . get ( i ) ; if ( o instanceof Agent CaMeL Component CaMeL Data ) { if ( has CaMeL Servlet ( ( Agent CaMeL Component CaMeL Data ) o ) ) return true ; } else { Component CaMeL Data [ ] tmp = ( ( Component CaMeL Data ) o ) . get CaMeL Children ( ) ; for ( int j = 0 ; j < tmp . length ; j ++ ) component CaMeL Data . add ( tmp [ j ] ) ; } } return false ; }	return null ;
if ( ! Util . equals ( this . image , part . get CaMeL Title CaMeL Image ( ) ) ) { fire CaMeL Property CaMeL Change ( I CaMeL Workbench CaMeL Part CaMeL Constants . PROP _ TITLE ) ; }  <CTX>  protected void refresh CaMeL From CaMeL Part ( ) { defer CaMeL Events ( true ) ; set CaMeL Part CaMeL Name ( compute CaMeL Part CaMeL Name ( ) ) ; set CaMeL Title ( compute CaMeL Title ( ) ) ; set CaMeL Content CaMeL Description ( compute CaMeL Content CaMeL Description ( ) ) ; set CaMeL Tool CaMeL Tip ( get CaMeL Raw CaMeL Tool CaMeL Tip ( ) ) ; if ( ! Util . equals ( this . image , part . get CaMeL Title CaMeL Image ( ) ) ) { fire CaMeL Property CaMeL Change ( I CaMeL Workbench CaMeL Part CaMeL Constants . PROP _ TITLE ) ; } defer CaMeL Events ( false ) ; }	set CaMeL Image CaMeL Descriptor ( compute CaMeL Image CaMeL Descriptor ( ) ) ;
byte CaMeL Buf = new byte [ len ] ; old CaMeL Position = buffer . position ( ) ; try { buffer . position ( offset ) ; buffer . get ( byte CaMeL Buf ) ; try { return new String ( byte CaMeL Buf , charset CaMeL Name ) ; } catch ( Unsupported CaMeL Encoding CaMeL Exception uex ) { } } finally { buffer . position ( old CaMeL Position ) ; } return null ;  <CTX>  private static String decode CaMeL Name ( int platform , int encoding , int language , Byte CaMeL Buffer buffer , int offset , int len ) { byte [ ] byte CaMeL Buf ; String charset CaMeL Name ; int old CaMeL Position ; charset CaMeL Name = get CaMeL Charset CaMeL Name ( platform , language , encoding ) ; if ( charset CaMeL Name == null ) return null ; byte CaMeL Buf = new byte [ len ] ; old CaMeL Position = buffer . position ( ) ; try { buffer . position ( offset ) ; buffer . get ( byte CaMeL Buf ) ; try { return new String ( byte CaMeL Buf , charset CaMeL Name ) ; } catch ( Unsupported CaMeL Encoding CaMeL Exception uex ) { } } finally { buffer . position ( old CaMeL Position ) ; } return null ; }	return decode CaMeL Name ( charset CaMeL Name , buffer , offset , len ) ;
Index newindex = tn . create CaMeL Index CaMeL Private ( col , name , unique ) ;  <CTX>  Index create CaMeL Index ( int col [ ] , Hsql CaMeL Name name , boolean unique ) throws SQL CaMeL Exception { if ( table . is CaMeL Empty ( ) || table . is CaMeL Indexing CaMeL Mutable ( ) ) { Index newindex = table . create CaMeL Index ( col , name , unique ) ; return newindex ; } else { Table tn = table . move CaMeL Definition ( null , null , table . get CaMeL Column CaMeL Count ( ) , 0 ) ; Index newindex = tn . create CaMeL Index CaMeL Private ( col , name , unique ) ; tn . move CaMeL Data ( table , table . get CaMeL Column CaMeL Count ( ) , 0 ) ; tn . update CaMeL Constraints ( table , table . get CaMeL Column CaMeL Count ( ) , 0 ) ; int index = table . d CaMeL Database . get CaMeL Table CaMeL Index ( table ) ; table . d CaMeL Database . get CaMeL Tables ( ) . set ( index , tn ) ; table = tn ; return newindex ; } }	Index newindex = tn . create CaMeL Index CaMeL Structure ( col , name , unique ) ;
if ( VM . Verify CaMeL Assertions && VM . running CaMeL VM ) VM . assert ( VM . NOT _ REACHED ) ;  <CTX>  static public VM _ Address max ( ) { if ( VM . Verify CaMeL Assertions && VM . running CaMeL VM ) VM . assert ( VM . NOT _ REACHED ) ; / / call site should have been hi@@ j@@ acked by magic in compiler return new VM _ Address ( - 1 ) ; }	if ( VM . Verify CaMeL Assertions && VM . running CaMeL VM ) VM . _ assert ( VM . NOT _ REACHED ) ;
extension CaMeL Image = provider . get ( PDE CaMeL Plugin CaMeL Images . DESC _ EXTENSION _ OBJ ) ; generic CaMeL Element CaMeL Image = provider  <CTX>  public void initialize CaMeL Images ( ) { PDE CaMeL Label CaMeL Provider provider = PDE CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Label CaMeL Provider ( ) ; extension CaMeL Image = provider . get ( PDE CaMeL Plugin CaMeL Images . DESC _ EXTENSION _ OBJ ) ; generic CaMeL Element CaMeL Image = provider . get ( PDE CaMeL Plugin CaMeL Images . DESC _ GENERIC _ XML _ OBJ ) ; }	f CaMeL Extension CaMeL Image = provider . get ( PDE CaMeL Plugin CaMeL Images . DESC _ EXTENSION _ OBJ ) ; f CaMeL Generic CaMeL Element CaMeL Image = provider
remove ( 0 ) ;  <CTX>  public void set CaMeL View ( Component v ) { while ( get CaMeL Component CaMeL Count ( ) > 0 ) remove ( 0 ) ; if ( v != null ) { add ( v ) ; fire CaMeL State CaMeL Changed ( ) ; } }	{ if ( view CaMeL Listener != null ) get CaMeL View ( ) . remove CaMeL Component CaMeL Listener ( view CaMeL Listener ) ; remove ( 0 ) ; }
set CaMeL Degree CaMeL Module ( null ) ; set CaMeL Course CaMeL Group ( null ) ; set CaMeL Begin CaMeL Execution CaMeL Period ( null ) ; set CaMeL End CaMeL Execution CaMeL Period ( null ) ;  <CTX>  public void delete ( ) { remove CaMeL Cur@@ ri@@ cular CaMeL Period ( ) ; set CaMeL Degree CaMeL Module ( null ) ; set CaMeL Course CaMeL Group ( null ) ; set CaMeL Begin CaMeL Execution CaMeL Period ( null ) ; set CaMeL End CaMeL Execution CaMeL Period ( null ) ; super . delete CaMeL Domain CaMeL Object ( ) ; }	remove CaMeL Degree CaMeL Module ( ) ; remove CaMeL Course CaMeL Group ( ) ; remove CaMeL Begin CaMeL Execution CaMeL Period ( ) ; remove CaMeL End CaMeL Execution CaMeL Period ( ) ;
cell CaMeL Height = list . get CaMeL Fixed CaMeL Cell CaMeL Height ( ) ; cell CaMeL Width = list . get CaMeL Fixed CaMeL Cell CaMeL Width ( ) ;  <CTX>  protected void update CaMeL Layout CaMeL State ( ) { int nrows = list . get CaMeL Model ( ) . get CaMeL Size ( ) ; cell CaMeL Height = - 1 ; cell CaMeL Width = - 1 ; if ( cell CaMeL Heights == null || cell CaMeL Heights . length != nrows ) cell CaMeL Heights = new int [ nrows ] ; if ( list . get CaMeL Fixed CaMeL Cell CaMeL Height ( ) == - 1 || list . get CaMeL Fixed CaMeL Cell CaMeL Width ( ) == - 1 ) { List CaMeL Cell CaMeL Renderer rend = list . get CaMeL Cell CaMeL Renderer ( ) ; for ( int i = 0 ; i < nrows ; ++ i ) { Component fl@@ yweight = rend . get CaMeL List CaMeL Cell CaMeL Renderer CaMeL Component ( list , list . get CaMeL Model ( ) . get CaMeL Element CaMeL At ( i ) , 0 , false , false ) ; Dimension dim = fl@@ yweight . get CaMeL Preferred CaMeL Size ( ) ; cell CaMeL Heights [ i ] = dim . height ; / / compute average cell height ( little hack here ) cell CaMeL Height = ( cell CaMeL Height * i + cell CaMeL Heights [ i ] ) / ( i + 1 ) ; cell CaMeL Width = Math . max ( cell CaMeL Width , dim . width ) ; if ( list . get CaMeL Layout CaMeL Orientation ( ) == J CaMeL List . VERTICAL ) cell CaMeL Width = Math . max ( cell CaMeL Width , list . get CaMeL Size ( ) . width ) ; } } else { cell CaMeL Height = list . get CaMeL Fixed CaMeL Cell CaMeL Height ( ) ; cell CaMeL Width = list . get CaMeL Fixed CaMeL Cell CaMeL Width ( ) ; } }	cell CaMeL Height = - 1 ; for ( int i = 0 ; i < nrows ; ++ i ) { Component fl@@ yweight = rend . get CaMeL List CaMeL Cell CaMeL Renderer CaMeL Component ( list , list . get CaMeL Model ( ) . get CaMeL Element CaMeL At ( i ) , i , list . is CaMeL Selected CaMeL Index ( i ) , list . get CaMeL Selection CaMeL Model ( ) . get CaMeL Anchor CaMeL Selection CaMeL Index ( ) == i ) ; Dimension dim = fl@@ yweight . get CaMeL Preferred CaMeL Size ( ) ; cell CaMeL Heights [ i ] = dim . height ; } } int fixed CaMeL Cell CaMeL Width = list . get CaMeL Fixed CaMeL Cell CaMeL Width ( ) ; if ( fixed CaMeL Cell CaMeL Width > 0 ) cell CaMeL Width = fixed CaMeL Cell CaMeL Width ; else { for ( int i = 0 ; i < nrows ; ++ i ) { Component fl@@ yweight = rend . get CaMeL List CaMeL Cell CaMeL Renderer CaMeL Component ( list , list . get CaMeL Model ( ) . get CaMeL Element CaMeL At ( i ) , i , list . is CaMeL Selected CaMeL Index ( i ) , list . get CaMeL Selection CaMeL Model ( ) . get CaMeL Anchor CaMeL Selection CaMeL Index ( ) == i ) ; Dimension dim = fl@@ yweight . get CaMeL Preferred CaMeL Size ( ) ; cell CaMeL Width = Math . max ( cell CaMeL Width , dim . width ) ; } if ( list . get CaMeL Layout CaMeL Orientation ( ) == J CaMeL List . VERTICAL ) cell CaMeL Width = Math . max ( cell CaMeL Width , list . get CaMeL Size ( ) . width ) ;
new CaMeL Time CaMeL Config . add CaMeL Time CaMeL Sync CaMeL Listener ( this ) ;  <CTX>  public void set CaMeL Time CaMeL Config ( Time CaMeL Range CaMeL Config new CaMeL Time CaMeL Config ) { time CaMeL Config . remove CaMeL Time CaMeL Sync CaMeL Listener ( this ) ; Iterator e = seismo@@ s . key CaMeL Set ( ) . iterator ( ) ; time CaMeL Finder = new CaMeL Time CaMeL Config . get CaMeL Time CaMeL Finder ( ) ; new CaMeL Time CaMeL Config . add CaMeL Time CaMeL Sync CaMeL Listener ( this ) ; while ( e . has CaMeL Next ( ) ) { Data CaMeL Set CaMeL Seismogram current = ( Data CaMeL Set CaMeL Seismogram ) e . next ( ) ; time CaMeL Config . remove CaMeL Seismogram ( current ) ; this . add CaMeL Seismogram ( current ) ; new CaMeL Time CaMeL Config . add CaMeL Seismogram ( current , ( ( Micro CaMeL Second CaMeL Time CaMeL Range ) seismo@@ s . get ( current ) ) . get CaMeL Begin CaMeL Time ( ) ) ; / / seismo@@ s . put ( current , new CaMeL Time CaMeL Config . get CaMeL Time CaMeL Range ( current ) ) ; } seismo@@ s = new CaMeL Time CaMeL Config . get CaMeL Data ( ) ; time CaMeL Config = new CaMeL Time CaMeL Config ; update CaMeL Time CaMeL Sync CaMeL Listeners ( ) ; }	/ * Iterator e = seismo@@ s . key CaMeL Set ( ) . iterator ( ) ;
if ( resource instanceof I CaMeL Project ) { active CaMeL Project = ( I CaMeL Project ) resource ; project CaMeL Name = active CaMeL Project . get CaMeL Project ( ) . get CaMeL Name ( ) ; x CaMeL Doc CaMeL Path = ( active CaMeL Project . get CaMeL Project ( ) . get CaMeL Location ( )  <CTX>  public void selection CaMeL Changed ( I CaMeL Workbench CaMeL Part part , I CaMeL Selection selection ) { if ( selection instanceof I CaMeL Structured CaMeL Selection ) { Object first = ( ( I CaMeL Structured CaMeL Selection ) selection ) . get CaMeL First CaMeL Element ( ) ; I CaMeL Resource resource = ( I CaMeL Resource ) first ; if ( resource instanceof I CaMeL Project ) { active CaMeL Project = ( I CaMeL Project ) resource ; project CaMeL Name = active CaMeL Project . get CaMeL Project ( ) . get CaMeL Name ( ) ; x CaMeL Doc CaMeL Path = ( active CaMeL Project . get CaMeL Project ( ) . get CaMeL Location ( ) . to CaMeL String ( ) + java . io . File . separator ) ; path = x CaMeL Doc CaMeL Path + get CaMeL Filename ( ) ; document = DOM CaMeL Utilities . load CaMeL DOM ( path ) ; tree CaMeL Viewer . set CaMeL Input ( document ) ; } } }	if ( resource != null ) { I CaMeL Project new CaMeL Active CaMeL Project = resource . get CaMeL Project ( ) ; if ( new CaMeL Active CaMeL Project != active CaMeL Project ) { active CaMeL Project = new CaMeL Active CaMeL Project ; project CaMeL Name = active CaMeL Project . get CaMeL Project ( ) . get CaMeL Name ( ) ; x CaMeL Doc CaMeL Path = ( active CaMeL Project . get CaMeL Project ( ) . get CaMeL Location ( )
if ( f CaMeL Range != null ) text CaMeL Editor . select CaMeL And CaMeL Reveal ( f CaMeL Range . get CaMeL Offset ( ) , f CaMeL Range . get CaMeL Length ( ) ) ; }  <CTX>  protected void reveal ( I CaMeL Text CaMeL Editor text CaMeL Editor ) { if ( f CaMeL Range != null ) text CaMeL Editor . select CaMeL And CaMeL Reveal ( f CaMeL Range . get CaMeL Offset ( ) , f CaMeL Range . get CaMeL Length ( ) ) ; }	if ( f CaMeL Range != null ) { text CaMeL Editor . select CaMeL And CaMeL Reveal ( f CaMeL Range . get CaMeL Offset ( ) , f CaMeL Range . get CaMeL Length ( ) ) ; } }
if ( parent != null ) return parent . get CaMeL Foreground ( ) ; return null ;  <CTX>  public Color get CaMeL Foreground ( ) { if ( foreground != null ) return foreground ; if ( parent != null ) return parent . get CaMeL Foreground ( ) ; return null ; }	return parent == null ? null : parent . get CaMeL Foreground ( ) ;
ldmf . clone CaMeL Instance ( ( Asset ) relationship . get CaMeL B ( ) ) : ldmf . clone CaMeL Instance ( ( Asset ) relationship . get CaMeL A ( ) ) ;  <CTX>  protected void report ( Relationship relationship ) { Asset send CaMeL To = ( ( ( Asset ) relationship . get CaMeL A ( ) ) . get CaMeL Key ( ) . equals ( my CaMeL Local CaMeL Asset . get CaMeL Key ( ) ) ) ? ldmf . clone CaMeL Instance ( ( Asset ) relationship . get CaMeL B ( ) ) : ldmf . clone CaMeL Instance ( ( Asset ) relationship . get CaMeL A ( ) ) ; Asset local CaMeL Clone = ldmf . clone CaMeL Instance ( my CaMeL Local CaMeL Asset ) ; List roles = new Array CaMeL List ( 1 ) ; Role role = ( ( ( Asset ) relationship . get CaMeL A ( ) ) . get CaMeL Key ( ) . equals ( my CaMeL Local CaMeL Asset . get CaMeL Key ( ) ) ) ? relationship . get CaMeL Role CaMeL A ( ) : relationship . get CaMeL Role CaMeL B ( ) ; roles . add ( role ) ; New CaMeL Task report CaMeL Task = create CaMeL Report CaMeL Task ( local CaMeL Clone , send CaMeL To , roles , relationship . get CaMeL Start CaMeL Time ( ) , relationship . get CaMeL End CaMeL Time ( ) ) ; publish CaMeL Add ( report CaMeL Task ) ; }	my CaMeL Planning CaMeL Factory . clone CaMeL Instance ( ( Asset ) relationship . get CaMeL B ( ) ) : my CaMeL Planning CaMeL Factory . clone CaMeL Instance ( ( Asset ) relationship . get CaMeL A ( ) ) ;
return x . get CaMeL Name ( ) ;  <CTX>  public AST CaMeL Node get ( ) { return x . get CaMeL Name ( ) ; }	return x . get CaMeL Qualifier ( ) ;
Object o = get CaMeL Item CaMeL Details ( ( Abstract CaMeL Search CaMeL Item ) element ) ;  <CTX>  private void refresh CaMeL Details ( ) { Structured CaMeL Selection selection = ( Structured CaMeL Selection ) list . get CaMeL Selection ( ) ; if ( selection . size ( ) == 1 ) { Object element = selection . get CaMeL First CaMeL Element ( ) ; if ( element instanceof Search CaMeL List CaMeL Separator ) { details CaMeL Content CaMeL Provider . set CaMeL Elements ( new Object [ 0 ] ) ; details . get CaMeL Table ( ) . set CaMeL Enabled ( false ) ; } else { Object o = get CaMeL Item CaMeL Details ( ( Abstract CaMeL Search CaMeL Item ) element ) ; details CaMeL Content CaMeL Provider . set CaMeL Elements ( new Object [ ] { o } ) ; details . get CaMeL Table ( ) . set CaMeL Enabled ( true ) ; } } else { details CaMeL Content CaMeL Provider . set CaMeL Elements ( new Object [ 0 ] ) ; details . get CaMeL Table ( ) . set CaMeL Enabled ( false ) ; } details . refresh ( ) ; }	Object o = get CaMeL Item CaMeL Details ( ( Abstract CaMeL List CaMeL Item ) element ) ;
Object result = ruby . eval CaMeL Script ( ( String ) expr , Object . class ) ;  <CTX>  public Object eval ( String file , int line , int col , Object expr ) throws BSF CaMeL Exception { String old CaMeL File = ruby . get CaMeL Source CaMeL File ( ) ; int old CaMeL Line = ruby . get CaMeL Source CaMeL Line ( ) ; ruby . set CaMeL Source CaMeL File ( file ) ; ruby . set CaMeL Source CaMeL Line ( line ) ; Object result = ruby . eval CaMeL Script ( ( String ) expr , Object . class ) ; ruby . set CaMeL Source CaMeL File ( old CaMeL File ) ; ruby . set CaMeL Source CaMeL Line ( old CaMeL Line ) ; return result ; }	try { Object result = ruby . eval CaMeL Script ( ( String ) expr , Object . class ) ;
set CaMeL Volume ( volume CaMeL Scale . get CaMeL Selection ( ) - VOLUME _ OFFSET ) ;  <CTX>  public void widget CaMeL Selected ( Selection CaMeL Event e ) { set CaMeL Volume ( volume CaMeL Scale . get CaMeL Selection ( ) - VOLUME _ OFFSET ) ; }	set CaMeL Volume ( volume CaMeL Scale . get CaMeL Selection ( ) * VOLUME _ RESOLUTION - VOLUME _ OFFSET ) ;
if ( ( ( Db CaMeL Object ) selection [ 0 ] . get CaMeL Data ( ) ) . get CaMeL Type ( ) == Db CaMeL Object . PROCEDURE _ TYPE )  <CTX>  public void drag CaMeL Start ( Drag CaMeL Source CaMeL Event event ) { Tree CaMeL Item [ ] selection = available CaMeL Db CaMeL Objects CaMeL Tree . get CaMeL Selection ( ) ; if ( selection . length > 0 && selection [ 0 ] . get CaMeL Data ( ) instanceof Db CaMeL Object ) { if ( ( ( Db CaMeL Object ) selection [ 0 ] . get CaMeL Data ( ) ) . get CaMeL Type ( ) == Db CaMeL Object . PROCEDURE _ TYPE ) { event . doit = false ; return ; } ; } else if ( selection . length <= 0 || selection [ 0 ] . get CaMeL Data ( ) == null ) { event . doit = false ; return ; } }	if ( selection [ 0 ] . get CaMeL Data ( ) instanceof Db CaMeL Object ) { if ( ( ( Db CaMeL Object ) selection [ 0 ] . get CaMeL Data ( ) ) . get CaMeL Type ( ) == Db CaMeL Object . PROCEDURE _ TYPE ) { event . doit = false ; return ; } } else if ( selection [ 0 ] . get CaMeL Data ( ) instanceof Procedure CaMeL Parameter )
return new Ruby CaMeL Fixnum ( get CaMeL Ruby ( ) , pos ) ;  <CTX>  public Ruby CaMeL Integer tell ( ) { return new Ruby CaMeL Fixnum ( get CaMeL Ruby ( ) , pos ) ; }	return Ruby CaMeL Fixnum . new CaMeL Fixnum ( get CaMeL Ruby ( ) , pos ) ;
return system . hash CaMeL Code ( ) ;  <CTX>  public int hash CaMeL Code ( ) { return system . hash CaMeL Code ( ) ; }	return uid . hash CaMeL Code ( ) ;
send CaMeL Request ( os , response _ expected ) ;  <CTX>  public void send CaMeL Request ( Message CaMeL Output CaMeL Stream os , Reply CaMeL Placeholder placeholder , int request _ id , boolean response _ expected ) { Integer key = new Integer ( request _ id ) ; synchronized ( replies ) { replies . put ( key , placeholder ) ; } send CaMeL Request ( os , response _ expected ) ; }	try { send CaMeL Request ( os , response _ expected ) ; } catch ( org . omg . CORBA . System CaMeL Exception e ) { synchronized ( replies ) { replies . remove ( key ) ; } throw e ; }
super ( ) ; table CaMeL Tree = tree ; hook CaMeL Control ( tree ) ; table CaMeL Tree CaMeL Editor = new Table CaMeL Tree CaMeL Editor ( table CaMeL Tree ) ; table CaMeL Viewer CaMeL Impl = new Table CaMeL Tree CaMeL Viewer CaMeL Impl ( this ) ; }  <CTX>  public Table CaMeL Tree CaMeL Viewer ( Table CaMeL Tree tree ) { super ( ) ; table CaMeL Tree = tree ; hook CaMeL Control ( tree ) ; table CaMeL Tree CaMeL Editor = new Table CaMeL Tree CaMeL Editor ( table CaMeL Tree ) ; table CaMeL Viewer CaMeL Impl = new Table CaMeL Tree CaMeL Viewer CaMeL Impl ( this ) ; }	super ( ) ; table CaMeL Tree = tree ; hook CaMeL Control ( tree ) ; table CaMeL Tree CaMeL Editor = new Table CaMeL Tree CaMeL Editor ( table CaMeL Tree ) ; table CaMeL Editor CaMeL Impl = new Table CaMeL Tree CaMeL Editor CaMeL Impl ( this ) ; }
set CaMeL List ( create CaMeL List ( list CaMeL Id , list CaMeL Name ) ) ;  <CTX>  protected A _ Cms CaMeL List CaMeL Dialog ( Cms CaMeL Jsp CaMeL Action CaMeL Element jsp , String list CaMeL Id , Cms CaMeL Message CaMeL Container list CaMeL Name , String sorted CaMeL Col CaMeL Id , String searchable CaMeL Col CaMeL Id ) { super ( jsp ) ; / / try to read the list from the session list CaMeL Recovery ( list CaMeL Id ) ; / / initialization if ( get CaMeL List ( ) == null ) { / / create the list set CaMeL List ( create CaMeL List ( list CaMeL Id , list CaMeL Name ) ) ; if ( searchable CaMeL Col CaMeL Id != null && get CaMeL List ( ) . get CaMeL Metadata ( ) . get CaMeL Column CaMeL Definition ( searchable CaMeL Col CaMeL Id ) != null ) { set CaMeL Search CaMeL Action ( list CaMeL Id , get CaMeL List ( ) . get CaMeL Metadata ( ) . get CaMeL Column CaMeL Definition ( searchable CaMeL Col CaMeL Id ) ) ; } / / set the number of items per page from the user settings get CaMeL List ( ) . set CaMeL Max CaMeL Items CaMeL Per CaMeL Page ( get CaMeL Settings ( ) . get CaMeL User CaMeL Settings ( ) . get CaMeL Explorer CaMeL File CaMeL Entries ( ) ) ; / / fill the content get CaMeL List ( ) . add CaMeL All CaMeL Items ( get CaMeL List CaMeL Items ( ) ) ; / / sort the list get CaMeL List ( ) . set CaMeL Sorted CaMeL Column ( sorted CaMeL Col CaMeL Id , get CaMeL Locale ( ) ) ; / / save the current state of the list list CaMeL Save ( ) ; } }	set CaMeL List ( new Cms CaMeL Html CaMeL List ( list CaMeL Id , list CaMeL Name , get CaMeL Metadata ( list CaMeL Id ) ) ) ;
if ( resource == null ) return null ; else if ( resource CaMeL Is CaMeL Type ( ( I CaMeL Resource ) resource , resource CaMeL Mask ) ) result . add ( resource ) ; } else return null ;  <CTX>  public static I CaMeL Structured CaMeL Selection all CaMeL Resources ( I CaMeL Structured CaMeL Selection selection , int resource CaMeL Mask ) { Iterator adap@@ tables = selection . iterator ( ) ; List result = new Array CaMeL List ( ) ; while ( adap@@ tables . has CaMeL Next ( ) ) { Object next = adap@@ tables . next ( ) ; if ( next instanceof I CaMeL Adaptable ) { Object resource = ( ( I CaMeL Adaptable ) next ) . get CaMeL Adapter ( I CaMeL Resource . class ) ; if ( resource == null ) return null ; else if ( resource CaMeL Is CaMeL Type ( ( I CaMeL Resource ) resource , resource CaMeL Mask ) ) result . add ( resource ) ; } else return null ; } return new Structured CaMeL Selection ( result ) ; }	if ( resource == null ) { return null ; } else if ( resource CaMeL Is CaMeL Type ( ( I CaMeL Resource ) resource , resource CaMeL Mask ) ) { result . add ( resource ) ; } } else { return null ; }
if ( handle instanceof Transition ) { return implementation . get CaMeL Uml CaMeL Package ( ) . get CaMeL State CaMeL Machines ( ) . get CaMeL A CaMeL State CaMeL Internal CaMeL Transition ( ) . get CaMeL State ( ( Transition ) handle ) ;  <CTX>  public Object get CaMeL State ( Object handle ) { if ( handle instanceof Transition ) { return implementation . get CaMeL Uml CaMeL Package ( ) . get CaMeL State CaMeL Machines ( ) . get CaMeL A CaMeL State CaMeL Internal CaMeL Transition ( ) . get CaMeL State ( ( Transition ) handle ) ; } return illegal CaMeL Argument CaMeL Object ( handle ) ; }	try { if ( handle instanceof Transition ) { return implementation . get CaMeL Uml CaMeL Package ( ) . get CaMeL State CaMeL Machines ( ) . get CaMeL A CaMeL State CaMeL Internal CaMeL Transition ( ) . get CaMeL State ( ( Transition ) handle ) ; } } catch ( Invalid CaMeL Object CaMeL Exception e ) { throw new Invalid CaMeL Element CaMeL Exception ( e ) ;
Object row = get CaMeL Row ( i + 1 ) ; Table CaMeL Handle CaMeL Adapter . Row CaMeL UI CaMeL Infomation info = get CaMeL Row CaMeL Info ( row ) ; delete CaMeL Cells . add ( info . get CaMeL All CaMeL Children ( ) . get ( column CaMeL Number - 1 ) ) ;  <CTX>  public void delete CaMeL Column ( int column CaMeL Number ) throws Semantic CaMeL Exception { trans CaMeL Star ( TRANS _ LABEL _ DELETE _ COLUMN ) ; int row CaMeL Count = get CaMeL Row CaMeL Count ( ) ; Column CaMeL Handle column = ( Column CaMeL Handle ) get CaMeL Column ( column CaMeL Number ) ; List delete CaMeL Cells = new Array CaMeL List ( ) ; for ( int i = 0 ; i < row CaMeL Count ; i ++ ) { Object row = get CaMeL Row ( i + 1 ) ; Table CaMeL Handle CaMeL Adapter . Row CaMeL UI CaMeL Infomation info = get CaMeL Row CaMeL Info ( row ) ; delete CaMeL Cells . add ( info . get CaMeL All CaMeL Children ( ) . get ( column CaMeL Number - 1 ) ) ; } List true CaMeL Delete CaMeL Cells = new Array CaMeL List ( ) ; int size = delete CaMeL Cells . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { Object cell = delete CaMeL Cells . get ( i ) ; Cell CaMeL Handle CaMeL Adapter cell CaMeL Adapt = Handle CaMeL Adapter CaMeL Factory . get CaMeL Instance ( ) . get CaMeL Cell CaMeL Handle CaMeL Adapter ( cell ) ; if ( cell CaMeL Adapt . get CaMeL Column CaMeL Number ( ) == column CaMeL Number && cell CaMeL Adapt . get CaMeL Column CaMeL Span ( ) == 1 && ! true CaMeL Delete CaMeL Cells . contains ( cell ) ) { true CaMeL Delete CaMeL Cells . add ( cell ) ; } } List temp = new Array CaMeL List ( ) ; for ( int i = 0 ; i < size ; i ++ ) { Object cell = delete CaMeL Cells . get ( i ) ; if ( ! true CaMeL Delete CaMeL Cells . contains ( cell ) && ! temp . contains ( cell ) ) { Cell CaMeL Handle CaMeL Adapter cell CaMeL Adapt = Handle CaMeL Adapter CaMeL Factory . get CaMeL Instance ( ) . get CaMeL Cell CaMeL Handle CaMeL Adapter ( cell ) ; cell CaMeL Adapt . set CaMeL Column CaMeL Span ( cell CaMeL Adapt . get CaMeL Column CaMeL Span ( ) - 1 ) ; temp . add ( cell ) ; } } size = true CaMeL Delete CaMeL Cells . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { Cell CaMeL Handle cell = ( Cell CaMeL Handle ) true CaMeL Delete CaMeL Cells . get ( i ) ; cell . drop ( ) ; } column . drop ( ) ; trans CaMeL End ( ) ; reload ( ) ; }	get CaMeL Table CaMeL Handle ( ) . drop ( ) ; return ;
} else if ( f CaMeL Value > b . f CaMeL Value ) {  <CTX>  public int compare CaMeL To ( Float b ) { if ( f CaMeL Value < b . f CaMeL Value ) { return - 1 ; } else if ( f CaMeL Value > b . f CaMeL Value ) { return 1 ; } else { return 0 ; } }	} else if ( value > b . value ) {
Goal g = intern CaMeL Goal ( new Visitor CaMeL Goal ( job , new Reach CaMeL Checker ( job , ts , nf ) ) { public Collection prerequisite CaMeL Goals ( Scheduler scheduler ) { List l = new Array CaMeL List ( ) ; l . add CaMeL All ( super . prerequisite CaMeL Goals ( scheduler ) ) ; l . add ( Type CaMeL Checked ( job ) ) ; l . add ( Constants CaMeL Checked ( job ) ) ; return l ; } } ) ;  <CTX>  public Goal Reachability CaMeL Checked ( final Job job ) { Type CaMeL System ts = ext CaMeL Info . type CaMeL System ( ) ; Node CaMeL Factory nf = ext CaMeL Info . node CaMeL Factory ( ) ; Goal g = intern CaMeL Goal ( new Visitor CaMeL Goal ( job , new Reach CaMeL Checker ( job , ts , nf ) ) { public Collection prerequisite CaMeL Goals ( Scheduler scheduler ) { List l = new Array CaMeL List ( ) ; l . add CaMeL All ( super . prerequisite CaMeL Goals ( scheduler ) ) ; l . add ( Type CaMeL Checked ( job ) ) ; l . add ( Constants CaMeL Checked ( job ) ) ; return l ; } } ) ; return g ; }	Goal g = Reachability CaMeL Checked . create ( this , job , ts , nf ) ;
this . report CaMeL Warnings = report CaMeL Warnings ;  <CTX>  public Tool CaMeL Error CaMeL Reporter ( boolean report CaMeL Warnings ) { this . report CaMeL Warnings = report CaMeL Warnings ; }	this ( report CaMeL Warnings , System . err ) ;
make CaMeL Tree CaMeL Node CaMeL Id ( tree CaMeL Level , sibling CaMeL Number ) , make CaMeL Tree CaMeL Node CaMeL Name ( tree CaMeL Level , sibling CaMeL Number ) ) ;  <CTX>  private void create CaMeL Descendant CaMeL Tree CaMeL Nodes ( Tree CaMeL Node parent , int tree CaMeL Level ) throws Tree CaMeL Not CaMeL Found CaMeL Exception { if ( tree CaMeL Level >= Constants . MAX _ TREE _ DEPTH ) { return ; } for ( int sibling CaMeL Number = 0 ; sibling CaMeL Number < Constants . MAX _ TREE _ WIDTH ; sibling CaMeL Number ++ ) { Tree CaMeL Node node = sign@@ et . new CaMeL Tree CaMeL Node ( parent . get CaMeL Tree ( ) , make CaMeL Tree CaMeL Node CaMeL Id ( tree CaMeL Level , sibling CaMeL Number ) , make CaMeL Tree CaMeL Node CaMeL Name ( tree CaMeL Level , sibling CaMeL Number ) ) ; create CaMeL Descendant CaMeL Tree CaMeL Nodes ( node , tree CaMeL Level + 1 ) ; } }	make CaMeL Tree CaMeL Node CaMeL Id ( tree CaMeL Level , parent , sibling CaMeL Number ) , make CaMeL Tree CaMeL Node CaMeL Name ( tree CaMeL Level , parent , sibling CaMeL Number ) ) ; parent . add CaMeL Child ( node ) ;
try { simple CaMeL Decl = callback . simple CaMeL Declaration CaMeL Begin ( container ) ; } catch ( Exception e ) { }  <CTX>  protected void simple CaMeL Declaration ( Object container ) throws Backtrack { Object simple CaMeL Decl = null ; try { simple CaMeL Decl = callback . simple CaMeL Declaration CaMeL Begin ( container ) ; } catch ( Exception e ) { } decl CaMeL Specifier CaMeL Seq ( simple CaMeL Decl , false ) ; Object declarator = null ; if ( LT ( 1 ) != Token . t CaMeL SEMI ) try { declarator = init CaMeL Declarator ( simple CaMeL Decl ) ; while ( LT ( 1 ) == Token . t CaMeL COMMA ) { consume ( ) ; try { init CaMeL Declarator ( simple CaMeL Decl ) ; } catch ( Backtrack b ) { throw b ; } } } catch ( Backtrack b ) { / / allowed to be empty } switch ( LT ( 1 ) ) { case Token . t CaMeL SEMI : consume ( ) ; break ; case Token . t CaMeL COLON : ctor CaMeL Initializer ( declarator ) ; / / Falling through on purpose case Token . t CaMeL LBRACE : Object function = null ; try { function = callback . function CaMeL Body CaMeL Begin ( simple CaMeL Decl ) ; } catch ( Exception e ) { } if ( quick CaMeL Parse ) { / / speed up the parser by skip@@ ing the body / / simp@@ ly look for matching brace and return consume ( Token . t CaMeL LBRACE ) ; int depth = 1 ; while ( depth > 0 ) { switch ( consume ( ) . get CaMeL Type ( ) ) { case Token . t CaMeL RBRACE : -- depth ; break ; case Token . t CaMeL LBRACE : ++ depth ; break ; } } } else { function CaMeL Body ( ) ; } try { callback . function CaMeL Body CaMeL End ( function ) ; } catch ( Exception e ) { } break ; default : break ; } try { callback . simple CaMeL Declaration CaMeL End ( simple CaMeL Decl ) ; } catch ( Exception e ) { } }	Token last CaMeL Token = null ; try { simple CaMeL Decl = callback . simple CaMeL Declaration CaMeL Begin ( container , LA ( 1 ) ) ; } catch ( Exception e ) { }
return null ;  <CTX>  public java . sql . Result CaMeL Set get CaMeL Exported CaMeL Keys ( String catalog , String schema , String table ) throws SQL CaMeL Exception { / / XXX - Not Implemented return null ; }	throw org . postgresql . Driver . not CaMeL Implemented ( ) ;
void mark CaMeL Update ( Object obj , Operation op ) { mark CaMeL Update ( obj ) ; Array CaMeL List ops = ( Array CaMeL List ) m _ operation CaMeL Map . get ( key ( obj ) ) ; ops . add ( op ) ;  <CTX>  void mark CaMeL Update ( Object obj , Operation op ) { mark CaMeL Update ( obj ) ; Array CaMeL List ops = ( Array CaMeL List ) m _ operation CaMeL Map . get ( key ( obj ) ) ; ops . add ( op ) ; }	void mark CaMeL Update ( Object obj ) { if ( ! has CaMeL Updates ( obj ) ) { m _ operation CaMeL Map . put ( key ( obj ) , new Array CaMeL List ( ) ) ; }
Plugin CaMeL Repository . get CaMeL Instance ( ) . get CaMeL Plugin CaMeL Instance ( get CaMeL Di@@ scri@@ ptor ( ) ) ;  <CTX>  public Object get CaMeL Extension CaMeL Instance ( ) throws Plugin CaMeL Runtime CaMeL Exception { / / Must synchronize here to make sure creation and initialization / / of a plugin instance and it extension instance are done by / / one and only one thread . / / The same is in Plugin CaMeL Repository . get CaMeL Plugin CaMeL Instance ( ) . / / Suggested by Ste@@ fan Gro@@ sch@@ up@@ f < sg @ media - style . com > synchronized ( get CaMeL Id ( ) ) { try { Plugin CaMeL Class CaMeL Loader loader = f CaMeL Descriptor . get CaMeL Class CaMeL Loader ( ) ; Class extension CaMeL Clazz = loader . load CaMeL Class ( get CaMeL Clazz ( ) ) ; / / lazy loading of Plugin in case there is no instance of the plugin / / already . Plugin CaMeL Repository . get CaMeL Instance ( ) . get CaMeL Plugin CaMeL Instance ( get CaMeL Di@@ scri@@ ptor ( ) ) ; Object object = extension CaMeL Clazz . new CaMeL Instance ( ) ; return object ; } catch ( Class CaMeL Not CaMeL Found CaMeL Exception e ) { throw new Plugin CaMeL Runtime CaMeL Exception ( e ) ; } catch ( Instantiation CaMeL Exception e ) { throw new Plugin CaMeL Runtime CaMeL Exception ( e ) ; } catch ( Illegal CaMeL Access CaMeL Exception e ) { throw new Plugin CaMeL Runtime CaMeL Exception ( e ) ; } } }	Plugin CaMeL Repository . get CaMeL Instance ( ) . get CaMeL Plugin CaMeL Instance ( get CaMeL Descriptor ( ) ) ;
i CaMeL Dpi CaMeL Resolution = _ d . get CaMeL DPI ( ) . x ;  <CTX>  public final int get CaMeL Dpi CaMeL Resolution ( ) { if ( i CaMeL Dpi CaMeL Resolution == 0 ) { i CaMeL Dpi CaMeL Resolution = _ d . get CaMeL DPI ( ) . x ; } return i CaMeL Dpi CaMeL Resolution ; }	( ( Display ) _ d ) . sync CaMeL Exec ( new Runnable ( ) { public void run ( ) { i CaMeL Dpi CaMeL Resolution = _ d . get CaMeL DPI ( ) . x ; } } ) ;
context . swap CaMeL Buffers ( ) ;  <CTX>  public void run ( ) { context . swap CaMeL Buffers ( ) ; }	offscreen CaMeL Context . swap CaMeL Buffers ( ) ;
m _ email = email ;  <CTX>  public void set CaMeL Email ( String email ) { m _ email = email ; }	this . email = email ;
browser . end CaMeL Request ( ) ;  <CTX>  public void run ( ) { switch ( type ) { case LIST _ DIRECTORY : list CaMeL Directory ( ) ; break ; case DELETE : delete ( ) ; break ; case RENAME : rename ( ) ; break ; case MK@@ DIR : mkdir ( ) ; break ; } browser . end CaMeL Request ( ) ; } / / } } }	if ( type != LIST _ DIRECTORY ) browser . end CaMeL Request ( ) ;
m _ label = label CaMeL Identifier . get CaMeL Text ( ) ;  <CTX>  private Label CaMeL Finder ( Psi CaMeL Labeled CaMeL Statement target ) { super ( ) ; final Psi CaMeL Identifier label CaMeL Identifier = target . get CaMeL Label CaMeL Identifier ( ) ; m _ label = label CaMeL Identifier . get CaMeL Text ( ) ; }	label = label CaMeL Identifier . get CaMeL Text ( ) ;
return f CaMeL Choices ;  <CTX>  public I CaMeL Completion CaMeL Proposal [ ] get CaMeL Choices ( ) { update CaMeL Choice CaMeL Positions ( ) ; return f CaMeL Choices ; }	return f CaMeL Proposals ;
input CaMeL Handle . set CaMeL Report CaMeL Name ( location CaMeL Editor . get CaMeL Text ( ) . trim ( ) ) ; for ( Iterator iter = binding CaMeL List . iterator ( ) ; iter . has CaMeL Next ( ) ; )  <CTX>  protected void ok CaMeL Pressed ( ) { try { / / Remove original settings input CaMeL Handle . set CaMeL URI ( null ) ; input CaMeL Handle . set CaMeL Target CaMeL Bookmark ( null ) ; input CaMeL Handle . set CaMeL Target CaMeL Window ( null ) ; input CaMeL Handle . set CaMeL Report CaMeL Name ( null ) ; input CaMeL Handle . set CaMeL Format CaMeL Type ( null ) ; input CaMeL Handle . get CaMeL Member ( Action . PARAM _ BINDINGS _ MEMBER ) . set CaMeL Value ( null ) ; if ( Design CaMeL Choice CaMeL Constants . ACTION _ LINK _ TYPE _ HYPERLINK . equals ( selected CaMeL Type ) ) { input CaMeL Handle . set CaMeL URI ( location CaMeL Editor . get CaMeL Text ( ) . trim ( ) ) ; input CaMeL Handle . set CaMeL Target CaMeL Window ( Choice CaMeL Set CaMeL Factory . get CaMeL Value CaMeL From CaMeL Choice CaMeL Set ( target CaMeL Chooser . get CaMeL Text ( ) , CHOIC@@ E@@ SET _ TARGET ) ) ; } else if ( Design CaMeL Choice CaMeL Constants . ACTION _ LINK _ TYPE _ BOOKMARK _ LINK . equals ( selected CaMeL Type ) ) { input CaMeL Handle . set CaMeL Target CaMeL Bookmark ( bookmark CaMeL Editor . get CaMeL Text ( ) . trim ( ) ) ; } else if ( Design CaMeL Choice CaMeL Constants . ACTION _ LINK _ TYPE _ DRI@@ LL _ THROUGH . equals ( selected CaMeL Type ) ) { input CaMeL Handle . set CaMeL Report CaMeL Name ( location CaMeL Editor . get CaMeL Text ( ) . trim ( ) ) ; for ( Iterator iter = binding CaMeL List . iterator ( ) ; iter . has CaMeL Next ( ) ; ) { input CaMeL Handle . add CaMeL Param CaMeL Binding ( ( Param CaMeL Binding ) iter . next ( ) ) ; } if ( ! String CaMeL Util . is CaMeL Blank ( bookmark CaMeL Editor . get CaMeL Text ( ) ) ) { input CaMeL Handle . set CaMeL Target CaMeL Bookmark ( bookmark CaMeL Editor . get CaMeL Text ( ) . trim ( ) ) ; } input CaMeL Handle . set CaMeL Target CaMeL Window ( Choice CaMeL Set CaMeL Factory . get CaMeL Value CaMeL From CaMeL Choice CaMeL Set ( target CaMeL Chooser . get CaMeL Text ( ) , CHOIC@@ E@@ SET _ TARGET ) ) ; input CaMeL Handle . set CaMeL Format CaMeL Type ( Choice CaMeL Set CaMeL Factory . get CaMeL Value CaMeL From CaMeL Choice CaMeL Set ( format CaMeL Chooser . get CaMeL Text ( ) , CHOIC@@ E@@ SET _ FORMAT ) ) ; } input CaMeL Handle . set CaMeL Link CaMeL Type ( selected CaMeL Type ) ; } catch ( Semantic CaMeL Exception e ) { Exception CaMeL Handler . handle ( e ) ; } set CaMeL Result ( input CaMeL Handle ) ; super . ok CaMeL Pressed ( ) ; }	if ( report CaMeL Design CaMeL Button . get CaMeL Selection ( ) )
if ( value == null )  <CTX>  public CSS CaMeL Value get CaMeL Property ( int index ) { CSS CaMeL Value value = ( CSS CaMeL Value ) vs . get ( new Integer ( index ) ) ; if ( value == null ) { return parent . get CaMeL Property ( index ) ; } return value ; }	if ( value == null && parent != null )
this . annotation . resolve ( this . scope ) ; } else { if ( ( this . modifiers & Acc CaMeL Public ) != 0 ) { this . scope . problem CaMeL Reporter ( ) . annotation CaMeL Missing ( this . source CaMeL Start , this . source CaMeL End ) ;  <CTX>  public void resolve ( ) { if ( binding == null ) { ignore CaMeL Further CaMeL Investigation = true ; return ; } try { if ( ( this . bits & Undocumented CaMeL Empty CaMeL Block CaMeL MASK ) != 0 ) { this . scope . problem CaMeL Reporter ( ) . un@@ documented CaMeL Empty CaMeL Block ( this . body CaMeL Start - 1 , this . body CaMeL End + 1 ) ; } / / check superclass & interfaces if ( binding . superclass != null ) / / watch out for Object ! ( and other roots ) if ( is CaMeL Type CaMeL Use CaMeL Deprecated ( binding . superclass , scope ) ) scope . problem CaMeL Reporter ( ) . deprecated CaMeL Type ( binding . superclass , superclass ) ; if ( super CaMeL Interfaces != null ) for ( int i = super CaMeL Interfaces . length ; -- i >= 0 ; ) if ( super CaMeL Interfaces [ i ] . resolved CaMeL Type != null ) if ( is CaMeL Type CaMeL Use CaMeL Deprecated ( super CaMeL Interfaces [ i ] . resolved CaMeL Type , scope ) ) scope . problem CaMeL Reporter ( ) . deprecated CaMeL Type ( super CaMeL Interfaces [ i ] . resolved CaMeL Type , super CaMeL Interfaces [ i ] ) ; max CaMeL Field CaMeL Count = 0 ; int last CaMeL Field CaMeL ID = - 1 ; if ( fields != null ) { for ( int i = 0 , count = fields . length ; i < count ; i ++ ) { Field CaMeL Declaration field = fields [ i ] ; if ( field . is CaMeL Field ( ) ) { if ( field . binding == null ) { / / still discover secondary errors if ( field . initialization != null ) field . initialization . resolve ( field . is CaMeL Static ( ) ? static CaMeL Initializer CaMeL Scope : initializer CaMeL Scope ) ; ignore CaMeL Further CaMeL Investigation = true ; continue ; } max CaMeL Field CaMeL Count ++ ; last CaMeL Field CaMeL ID = field . binding . id ; } else { / / initializer ( ( Initializer ) field ) . last CaMeL Field CaMeL ID = last CaMeL Field CaMeL ID + 1 ; } field . resolve ( field . is CaMeL Static ( ) ? static CaMeL Initializer CaMeL Scope : initializer CaMeL Scope ) ; } } if ( member CaMeL Types != null ) { for ( int i = 0 , count = member CaMeL Types . length ; i < count ; i ++ ) { member CaMeL Types [ i ] . resolve ( scope ) ; } } int missing CaMeL Abstract CaMeL Me@@ thod@@ s@@ length = this . missing CaMeL Abstract CaMeL Methods == null ? 0 : this . missing CaMeL Abstract CaMeL Methods . length ; int methods CaMeL Length = this . methods == null ? 0 : methods . length ; if ( ( methods CaMeL Length + missing CaMeL Abstract CaMeL Me@@ thod@@ s@@ length ) > 0 x CaMeL FFFF ) { scope . problem CaMeL Reporter ( ) . too CaMeL Many CaMeL Methods ( this ) ; } if ( methods != null ) { for ( int i = 0 , count = methods . length ; i < count ; i ++ ) { methods [ i ] . resolve ( scope ) ; } } / / Resolve annotation if ( this . annotation != null ) { this . annotation . resolve ( this . scope ) ; } else { if ( ( this . modifiers & Acc CaMeL Public ) != 0 ) { this . scope . problem CaMeL Reporter ( ) . annotation CaMeL Missing ( this . source CaMeL Start , this . source CaMeL End ) ; } } } catch ( Abort CaMeL Type e ) { this . ignore CaMeL Further CaMeL Investigation = true ; return ; } }	if ( this . scope != null ) { this . annotation . resolve ( this . scope ) ;
root . set CaMeL Allocated CaMeL Width ( max ) ;  <CTX>  protected void new CaMeL Context ( ) { create CaMeL Root ( ) ; / / validate CaMeL Box CaMeL Property ( root . get CaMeL Style ( ) ) ; if ( null != parent ) { / / support user defined width int max = parent . get CaMeL Max CaMeL Ava CaMeL Width ( ) - parent . get CaMeL Current CaMeL IP ( ) ; if ( content != null ) { int specified CaMeL Width = get CaMeL Dimension CaMeL Value ( content . get CaMeL Width ( ) ) ; if ( specified CaMeL Width > 0 ) { max = Math . min ( max , specified CaMeL Width ) ; } } root . set CaMeL Allocated CaMeL Width ( max ) ; set CaMeL Max CaMeL Ava CaMeL Width ( root . get CaMeL Content CaMeL Width ( ) ) ; root . set CaMeL Allocated CaMeL Height ( parent . get CaMeL Max CaMeL Ava CaMeL Height ( ) - parent . get CaMeL Current CaMeL BP ( ) ) ; set CaMeL Max CaMeL Ava CaMeL Height ( root . get CaMeL Content CaMeL Height ( ) ) ; } / / initialize offset CaMeL X and offset CaMeL Y I CaMeL Style area CaMeL Style = root . get CaMeL Style ( ) ; set CaMeL Offset CaMeL X ( get CaMeL Dimension CaMeL Value ( area CaMeL Style . get CaMeL Property ( Style CaMeL Constants . STYLE _ BORDER _ LEFT _ WIDTH ) ) + get CaMeL Dimension CaMeL Value ( area CaMeL Style . get CaMeL Property ( Style CaMeL Constants . STYLE _ PADDING _ LEFT ) ) ) ; set CaMeL Offset CaMeL Y ( is CaMeL First ? ( get CaMeL Dimension CaMeL Value ( area CaMeL Style . get CaMeL Property ( Style CaMeL Constants . STYLE _ BORDER _ TOP _ WIDTH ) ) + get CaMeL Dimension CaMeL Value ( area CaMeL Style . get CaMeL Property ( Style CaMeL Constants . STYLE _ PADDING _ TOP ) ) ) : 0 ) ; / / can be removed ? set CaMeL Current CaMeL BP ( 0 ) ; set CaMeL Current CaMeL IP ( 0 ) ; }	root . set CaMeL Allocated CaMeL Width ( max CaMeL W ) ;
href . parameters . put CaMeL All ( this . parameters ) ;  <CTX>  public Object clone ( ) { Href href = null ; try { href = ( Href ) super . clone ( ) ; } catch ( Clone CaMeL Not CaMeL Supported CaMeL Exception e ) { / / should never happ@@ en } href . parameters . put CaMeL All ( this . parameters ) ; return href ; }	href . parameters = new Hash CaMeL Map ( this . parameters ) ;
System . arraycopy ( _ heap , 0 , heap CaMeL Copy , 0 , _ heap . length ) ;  <CTX>  public Node CaMeL Iterator clone CaMeL Iterator ( ) { final Look CaMeL Ahead CaMeL Iterator [ ] heap CaMeL Copy = new Look CaMeL Ahead CaMeL Iterator [ _ heap . length ] ; try { final Union CaMeL Iterator clone = ( Union CaMeL Iterator ) super . clone ( ) ; System . arraycopy ( _ heap , 0 , heap CaMeL Copy , 0 , _ heap . length ) ; clone . set CaMeL Restartable ( false ) ; clone . _ heap = heap CaMeL Copy ; return clone . reset ( ) ; } catch ( Clone CaMeL Not CaMeL Supported CaMeL Exception e ) { Basis CaMeL Library . run CaMeL Time CaMeL Error ( Basis CaMeL Library . ITERATOR _ CLONE _ ERR , e . to CaMeL String ( ) ) ; return null ; } }	for ( int i = 0 ; i < _ free ; i ++ ) { heap CaMeL Copy [ i ] = _ heap [ i ] . clone CaMeL Iterator ( ) ; }
super ( source , id ) ; this . changed = changed ; this . changed CaMeL Parent = changed CaMeL Parent ; this . change CaMeL Flags = change CaMeL Flags ;  <CTX>  public Hierarchy CaMeL Event ( Component source , int id , Component changed , Container changed CaMeL Parent , long change CaMeL Flags ) { super ( source , id ) ; this . changed = changed ; this . changed CaMeL Parent = changed CaMeL Parent ; this . change CaMeL Flags = change CaMeL Flags ; }	this ( source , id , changed , changed CaMeL Parent , 0 ) ;
boolean place CaMeL Breakpoint ( int line ) { synchronized ( entries ) { if ( breakable CaMeL Line ( line ) ) { breakpoints [ line ] = true ; return true ; }  <CTX>  boolean place CaMeL Breakpoint ( int line ) { synchronized ( entries ) { if ( breakable CaMeL Line ( line ) ) { breakpoints [ line ] = true ; return true ; } } return false ; }	synchronized boolean place CaMeL Breakpoint ( int line ) { if ( breakable CaMeL Line ( line ) ) { breakpoints [ line ] = true ; return true ;
String ret = fc . get CaMeL Dialog CaMeL Title ( ) ; if ( ret != null ) return ret ; switch ( fc . get CaMeL Dialog CaMeL Type ( ) ) { case J CaMeL File CaMeL Chooser . OPEN _ DIALOG : ret = open CaMeL Button CaMeL Text ; break ; case J CaMeL File CaMeL Chooser . SAVE _ DIALOG : ret = save CaMeL Button CaMeL Text ; break ; default : ret = fc . get CaMeL Approve CaMeL Button CaMeL Text ( ) ; break ; } if ( ret == null ) ret = open CaMeL Button CaMeL Text ; return ret ;  <CTX>  public String get CaMeL Dialog CaMeL Title ( J CaMeL File CaMeL Chooser fc ) { String ret = fc . get CaMeL Dialog CaMeL Title ( ) ; if ( ret != null ) return ret ; switch ( fc . get CaMeL Dialog CaMeL Type ( ) ) { case J CaMeL File CaMeL Chooser . OPEN _ DIALOG : ret = open CaMeL Button CaMeL Text ; break ; case J CaMeL File CaMeL Chooser . SAVE _ DIALOG : ret = save CaMeL Button CaMeL Text ; break ; default : ret = fc . get CaMeL Approve CaMeL Button CaMeL Text ( ) ; break ; } if ( ret == null ) ret = open CaMeL Button CaMeL Text ; return ret ; }	String result = fc . get CaMeL Dialog CaMeL Title ( ) ; if ( result == null ) result = get CaMeL Approve CaMeL Button CaMeL Text ( fc ) ; return result ;
else if ( property . equals ( Constants . ENTITY _ MANAGER _ PROPERTY ) ) {  <CTX>  public void set CaMeL Property ( String property CaMeL Id , Object value ) throws XML CaMeL Configuration CaMeL Exception { / / Xerces properties if ( property CaMeL Id . starts CaMeL With ( Constants . XERCES _ PROPERTY _ PREFIX ) ) { String property = property CaMeL Id . substring ( Constants . XERCES _ PROPERTY _ PREFIX . length ( ) ) ; if ( property . equals ( Constants . SYMBOL _ TABLE _ PROPERTY ) ) { f CaMeL Symbol CaMeL Table = ( Symbol CaMeL Table ) value ; } else if ( property . equals ( Constants . ERROR _ REPORTER _ PROPERTY ) ) { f CaMeL Error CaMeL Reporter = ( XML CaMeL Error CaMeL Reporter ) value ; } else if ( property . equals ( Constants . ENTITY _ MANAGER _ PROPERTY ) ) { f CaMeL Entity CaMeL Manager = ( XML CaMeL Entity CaMeL Manager ) value ; } } } / / set CaMeL Property ( String , Object )	else if ( property CaMeL Id . region CaMeL Matches ( prefix CaMeL Length , Constants . ENTITY _ MANAGER _ PROPERTY , 0 , Constants . ENTITY _ MANAGER _ PROPERTY . length ( ) ) ) {
return ( Bio CaMeL Module ) ( my CaMeL Consumer ) ;  <CTX>  public Bio CaMeL Module get CaMeL Input CaMeL Module ( ) { return ( Bio CaMeL Module ) ( my CaMeL Consumer ) ; }	return my CaMeL Consumer ;
return Reference CaMeL Scope CaMeL Factory . create ( element ) ;  <CTX>  I CaMeL Java CaMeL Search CaMeL Scope get CaMeL Scope ( I CaMeL Java CaMeL Element element ) throws Java CaMeL Model CaMeL Exception { return Reference CaMeL Scope CaMeL Factory . create ( element ) ; }	return Reference CaMeL Scope CaMeL Factory . create CaMeL Workspace CaMeL Scope ( Java CaMeL Search CaMeL Page . get CaMeL Search CaMeL JRE ( ) ) ;
return get CaMeL Simple CaMeL Slot ( Table CaMeL Item . FOOTER _ SLOT ) ;  <CTX>  public Layout CaMeL Slot get CaMeL Footer ( ) { return get CaMeL Simple CaMeL Slot ( Table CaMeL Item . FOOTER _ SLOT ) ; }	return get CaMeL Simple CaMeL Slot ( I CaMeL Listing CaMeL Element CaMeL Model . FOOTER _ SLOT ) ;
return new Aspect CaMeL Score CaMeL Range ( Aspect CaMeL Score CaMeL Point . NEGATIVE _ INFINITY , Aspect CaMeL Score CaMeL Point . POSITIVE _ INFINITY ) ;  <CTX>  public Aspect CaMeL Score CaMeL Range get CaMeL Defined CaMeL Range ( ) { return new Aspect CaMeL Score CaMeL Range ( Aspect CaMeL Score CaMeL Point . NEGATIVE _ INFINITY , Aspect CaMeL Score CaMeL Point . POSITIVE _ INFINITY ) ; }	return new Aspect CaMeL Score CaMeL Range ( Aspect CaMeL Score CaMeL Point . get CaMeL NEGATIVE _ INFINITY ( aspect CaMeL Type ) , Aspect CaMeL Score CaMeL Point . get CaMeL POSITIVE _ INFINITY ( aspect CaMeL Type ) ) ;
Container CaMeL Slot groups = table . get CaMeL Slot ( Table CaMeL Item . GROUP _ SLOT ) ;  <CTX>  private void fills CaMeL Empty CaMeL Cells CaMeL For CaMeL Table ( ) { int column CaMeL Count = layout CaMeL Table . get CaMeL Column CaMeL Count ( ) ; Table CaMeL Item table = layout CaMeL Table . table ; fills CaMeL Empty CaMeL Cells CaMeL For CaMeL Slot ( table . get CaMeL Slot ( Table CaMeL Item . HEADER _ SLOT ) , layout CaMeL Table . get CaMeL Header ( ) , column CaMeL Count ) ; Container CaMeL Slot groups = table . get CaMeL Slot ( Table CaMeL Item . GROUP _ SLOT ) ; int group CaMeL Count = groups . get CaMeL Count ( ) ; for ( int i = 0 ; i < group CaMeL Count ; i ++ ) { Table CaMeL Group group = ( Table CaMeL Group ) groups . get CaMeL Content ( i ) ; fills CaMeL Empty CaMeL Cells CaMeL For CaMeL Slot ( group . get CaMeL Slot ( Table CaMeL Group . HEADER _ SLOT ) , layout CaMeL Table . get CaMeL Group CaMeL Headers ( ) . get CaMeL Layout CaMeL Slot ( i ) , column CaMeL Count ) ; } fills CaMeL Empty CaMeL Cells CaMeL For CaMeL Slot ( table . get CaMeL Slot ( Table CaMeL Item . DETAIL _ SLOT ) , layout CaMeL Table . get CaMeL Detail ( ) , column CaMeL Count ) ; / / the group level in the group is from 0 to group CaMeL Count - 1 ; / / the group level in the layout slot band is from group CaMeL Count - 1 to 0 . for ( int i = group CaMeL Count - 1 ; i >= 0 ; i -- ) { Table CaMeL Group group = ( Table CaMeL Group ) groups . get CaMeL Content ( group CaMeL Count - i - 1 ) ; fills CaMeL Empty CaMeL Cells CaMeL For CaMeL Slot ( group . get CaMeL Slot ( Table CaMeL Group . FOOTER _ SLOT ) , layout CaMeL Table . get CaMeL Group CaMeL Footers ( ) . get CaMeL Layout CaMeL Slot ( i ) , column CaMeL Count ) ; } fills CaMeL Empty CaMeL Cells CaMeL For CaMeL Slot ( table . get CaMeL Slot ( Table CaMeL Item . FOOTER _ SLOT ) , layout CaMeL Table . get CaMeL Footer ( ) , column CaMeL Count ) ; }	Container CaMeL Slot groups = table . get CaMeL Slot ( I CaMeL Listing CaMeL Element CaMeL Model . GROUP _ SLOT ) ;
Simple CaMeL Combo CaMeL Box CaMeL Model model = create CaMeL Enemy CaMeL Combo CaMeL Box CaMeL Model ( zero CaMeL Based ) ;  <CTX>  public static J CaMeL Combo CaMeL Box create CaMeL Enemy CaMeL Combo CaMeL Box ( boolean zero CaMeL Based , final Action CaMeL Listener al ) { Simple CaMeL Combo CaMeL Box CaMeL Model model = create CaMeL Enemy CaMeL Combo CaMeL Box CaMeL Model ( zero CaMeL Based ) ; final J CaMeL Combo CaMeL Box out = new J CaMeL Combo CaMeL Box ( model ) ; out . add CaMeL Action CaMeL Listener ( al ) ; model . add CaMeL List CaMeL Data CaMeL Listener ( new List CaMeL Data CaMeL Listener ( ) { public void contents CaMeL Changed ( List CaMeL Data CaMeL Event lde ) { if ( out . get CaMeL Selected CaMeL Index ( ) == - 1 ) { out . remove CaMeL Action CaMeL Listener ( al ) ; out . set CaMeL Selected CaMeL Index ( lde . get CaMeL Index 0 ( ) ) ; out . add CaMeL Action CaMeL Listener ( al ) ; } } public void interval CaMeL Added ( List CaMeL Data CaMeL Event arg 0 ) { } public void interval CaMeL Removed ( List CaMeL Data CaMeL Event arg 0 ) { } } ) ; return out ; }	Simple CaMeL Combo CaMeL Box CaMeL Model model = create CaMeL Enemy CaMeL Combo CaMeL Box CaMeL Model ( ) ;
return prop CaMeL Binding . get CaMeL Value ( ) ;  <CTX>  public String get CaMeL Property CaMeL Binding ( String prop CaMeL Name ) { Property CaMeL Binding prop CaMeL Binding = module . find CaMeL Property CaMeL Binding ( get CaMeL Element ( ) , prop CaMeL Name ) ; if ( prop CaMeL Binding == null ) return null ; return prop CaMeL Binding . get CaMeL Value ( ) ; }	Design CaMeL Element element = get CaMeL Element ( ) ; while ( element != null && element . get CaMeL Root ( ) != null ) { Property CaMeL Binding prop CaMeL Binding = element . get CaMeL Root ( ) . find CaMeL Property CaMeL Binding ( element , prop CaMeL Name ) ; if ( prop CaMeL Binding != null ) return prop CaMeL Binding . get CaMeL Value ( ) ; if ( element . is CaMeL Virtual CaMeL Element ( ) ) { element = element . get CaMeL Virtual CaMeL Parent ( ) ; } else { element = element . get CaMeL Extends CaMeL Element ( ) ; } } return null ;
if ( f CaMeL Update CaMeL Thread == null || f CaMeL Update CaMeL Thread . f CaMeL Stop )  <CTX>  public void set CaMeL Selection ( int [ ] selection ) { if ( selection == null || selection . length == 0 ) f CaMeL List . deselect CaMeL All ( ) ; else { / / If there is a current working update defer the setting if ( f CaMeL Update CaMeL Thread == null || f CaMeL Update CaMeL Thread . f CaMeL Stop ) f CaMeL List . set CaMeL Selection ( selection ) ; else f CaMeL Update CaMeL Thread . select CaMeL Indices ( selection ) ; } }	if ( f CaMeL Update CaMeL Thread == null || f CaMeL Update CaMeL Thread . f CaMeL Stop ) {
if ( value instanceof Element CaMeL Ref CaMeL Value ) value = ( ( Element CaMeL Ref CaMeL Value ) value ) . get CaMeL Name ( ) ; if ( value instanceof Struct CaMeL Ref CaMeL Value ) value = ( ( Struct CaMeL Ref CaMeL Value ) value ) . get CaMeL Name ( ) ;  <CTX>  public Object get CaMeL Value ( ) { Object value = get CaMeL Element ( ) . get CaMeL Property ( get CaMeL Module ( ) , prop CaMeL Defn ) ; if ( value instanceof Element CaMeL Ref CaMeL Value ) value = ( ( Element CaMeL Ref CaMeL Value ) value ) . get CaMeL Name ( ) ; if ( value instanceof Struct CaMeL Ref CaMeL Value ) value = ( ( Struct CaMeL Ref CaMeL Value ) value ) . get CaMeL Name ( ) ; return value ; }	if ( value instanceof Reference CaMeL Value ) return Model CaMeL Util . need CaMeL The CaMeL Namespace CaMeL Prefix ( ( Reference CaMeL Value ) value , get CaMeL Element ( ) . get CaMeL Root ( ) , get CaMeL Module ( ) ) ;
if ( m _ old CaMeL Status != new CaMeL Status ) {  <CTX>  public void update CaMeL Status ( Poll CaMeL Status new CaMeL Status ) { if ( ! get CaMeL Context ( ) . is CaMeL Service CaMeL Un@@ responsive CaMeL Enabled ( ) ) { if ( new CaMeL Status == Poll CaMeL Status . STATUS _ UN@@ RESPON@@ SIVE ) new CaMeL Status = Poll CaMeL Status . STATUS _ UP ; } if ( get CaMeL Status ( ) != new CaMeL Status ) { m _ old CaMeL Status = get CaMeL Status ( ) ; set CaMeL Status CaMeL Change CaMeL Time ( m _ poll CaMeL Config . get CaMeL Current CaMeL Time ( ) ) ; } super . update CaMeL Status ( new CaMeL Status ) ; if ( m _ old CaMeL Status != new CaMeL Status ) { get CaMeL Schedule ( ) . adjust CaMeL Schedule ( ) ; } }	if ( current CaMeL Status != new CaMeL Status ) {
Viewed CaMeL Message node = ( Viewed CaMeL Message ) path . get CaMeL Tip ( ) ;  <CTX>  public void folder CaMeL Selection CaMeL Changed ( Change CaMeL Event a CaMeL Event ) { Tree CaMeL Path path = null ; Enumeration selection = ( ( Folder CaMeL Panel ) a CaMeL Event . get CaMeL Source ( ) ) . get CaMeL Selection ( ) ; if ( selection . has CaMeL More CaMeL Elements ( ) ) { path = ( Tree CaMeL Path ) selection . next CaMeL Element ( ) ; } if ( path != null && ! selection . has CaMeL More CaMeL Elements ( ) ) { / / not multiple selection Viewed CaMeL Message node = ( Viewed CaMeL Message ) path . get CaMeL Tip ( ) ; f CaMeL Message . set CaMeL Message ( node . get CaMeL Message ( ) ) ; } else { f CaMeL Message . set CaMeL Message ( null ) ; } }	Viewed CaMeL Message node = ( Viewed CaMeL Message ) path . get CaMeL Path ( ) [ path . get CaMeL Path ( ) . length - 1 ] ;
write CaMeL Barrier ( src . add ( offset ) , tgt , src ) ;  <CTX>  public final void put CaMeL Field CaMeL Write CaMeL Barrier ( VM _ Address src , int offset , VM _ Address tgt ) throws VM _ Pragma CaMeL Inline { write CaMeL Barrier ( src . add ( offset ) , tgt , src ) ; }	write CaMeL Barrier ( src . add ( offset ) , tgt ) ;
if ( Psi CaMeL Tree CaMeL Util . get CaMeL Parent CaMeL Of CaMeL Type ( reference . get CaMeL Element ( ) ,  <CTX>  private boolean is CaMeL In CaMeL Synchronized CaMeL Context ( Psi CaMeL Reference reference ) { if ( Psi CaMeL Tree CaMeL Util . get CaMeL Parent CaMeL Of CaMeL Type ( reference . get CaMeL Element ( ) , Psi CaMeL Synchronized CaMeL Statement . class ) != null ) { return true ; } return false ; }	final Psi CaMeL Element element = reference . get CaMeL Element ( ) ; if ( Psi CaMeL Tree CaMeL Util . get CaMeL Parent CaMeL Of CaMeL Type ( element ,
io CaMeL Class = Ruby CaMeL IO . create CaMeL IO CaMeL Class ( runtime ) ;  <CTX>  public Ruby CaMeL Class get CaMeL Io CaMeL Class ( ) { if ( io CaMeL Class == null ) { io CaMeL Class = Ruby CaMeL IO . create CaMeL IO CaMeL Class ( runtime ) ; } return io CaMeL Class ; }	io CaMeL Class = new IO CaMeL Meta CaMeL Class ( runtime ) ;
d ) ;  <CTX>  private static Image CaMeL Icon load CaMeL Java CaMeL Internal ( Image CaMeL Icon r , Dimension d ) { Image scaled = null ; Dimension new CaMeL D = get CaMeL Size CaMeL Keep CaMeL Ratio ( new Dimension ( r . get CaMeL Icon CaMeL Width ( ) , r . get CaMeL Icon CaMeL Height ( ) ) , d ) ; scaled = r . get CaMeL Image ( ) . get CaMeL Scaled CaMeL Instance ( new CaMeL D . width , new CaMeL D . height , Image . SCALE _ FAST ) ; r . get CaMeL Image ( ) . flush ( ) ; r . set CaMeL Image ( scaled ) ; return r ; / * Iterator iter = Image CaMeL IO . get CaMeL Image CaMeL Readers ( iis ) ; if ( ! iter . has CaMeL Next ( ) ) { return null ; } Image CaMeL Reader reader = ( Image CaMeL Reader ) iter . next ( ) ; Image CaMeL Read CaMeL Param param = reader . get CaMeL Default CaMeL Read CaMeL Param ( ) ; reader . set CaMeL Input ( iis , true , false ) ; IIO CaMeL Metadata metadata = reader . get CaMeL Image CaMeL Metadata ( 0 ) ; String names [ ] = metadata . get CaMeL Metadata CaMeL Format CaMeL Names ( ) ; for ( int i = 0 ; i < names . length ; i ++ ) { display CaMeL Metadata ( metadata . get CaMeL As CaMeL Tree ( names [ i ] ) ) ; } param . set CaMeL Source CaMeL Render CaMeL Size ( d ) ; Buffered CaMeL Image image = ( Buffered CaMeL Image ) reader . read CaMeL As CaMeL Rendered CaMeL Image ( 0 , param ) ; return new Image CaMeL Icon ( image ) ; * / }	d , no CaMeL Stretch ) ; if ( new CaMeL D == null ) { return r ; }
} else if ( get CaMeL Double CaMeL Value ( ) < 0 . 0 ) {  <CTX>  public Ruby CaMeL Integer truncate ( ) { if ( get CaMeL Double CaMeL Value ( ) > 0 . 0 ) { return floor ( ) ; } else if ( get CaMeL Double CaMeL Value ( ) < 0 . 0 ) { return ceil ( ) ; } else { return Ruby CaMeL Fixnum . zero ( get CaMeL Runtime ( ) ) ; } }	} else if ( value < 0 . 0 ) {
super ( value , name ) ;  <CTX>  private Legend CaMeL Item CaMeL Type ( int value , String name ) { super ( value , name ) ; }	super ( value , name , literal ) ;
return ( ( Cell CaMeL Handle ) source ) . get CaMeL Content ( ) . get CaMeL Contents ( ) . size ( ) > 0 ;  <CTX>  protected boolean can CaMeL Drop ( Object source ) { if ( source == null ) { return false ; } if ( source instanceof Structured CaMeL Selection ) { return can CaMeL Drop ( ( ( Structured CaMeL Selection ) source ) . to CaMeL Array ( ) ) ; } if ( source instanceof Object [ ] ) { Object [ ] array = ( Object [ ] ) source ; if ( array . length == 0 ) { return false ; } / / If the container can drop , the children will be skipped for ( int i = 0 ; i < array . length ; i ++ ) { if ( DND CaMeL Util . check CaMeL Container CaMeL Exists ( array [ i ] , array ) ) continue ; if ( can CaMeL Drop ( array [ i ] ) ) return true ; } return false ; } source = DND CaMeL Util . unwrap CaMeL To CaMeL Model ( source ) ; if ( source instanceof Slot CaMeL Handle ) { Slot CaMeL Handle slot = ( Slot CaMeL Handle ) source ; Design CaMeL Element CaMeL Handle handle = slot . get CaMeL Element CaMeL Handle ( ) ; return slot . get CaMeL Contents ( ) . size ( ) > 0 && ( handle instanceof List CaMeL Handle || handle instanceof List CaMeL Group CaMeL Handle ) ; } if ( source instanceof Embedded CaMeL Image CaMeL Handle ) { return true ; } if ( source instanceof Cell CaMeL Handle ) { / / Cell CaMeL Handle is subclass of Report CaMeL Element CaMeL Handle return ( ( Cell CaMeL Handle ) source ) . get CaMeL Content ( ) . get CaMeL Contents ( ) . size ( ) > 0 ; } if ( source instanceof Master CaMeL Page CaMeL Handle ) { return false ; } else if ( source instanceof Report CaMeL Element CaMeL Handle ) { if ( ( ( Report CaMeL Element CaMeL Handle ) source ) . get CaMeL Root ( ) instanceof Library CaMeL Handle && Session CaMeL Handle CaMeL Adapter . get CaMeL Instance ( ) . get CaMeL Report CaMeL Design CaMeL Handle ( ) instanceof Report CaMeL Design CaMeL Handle ) { return false ; } return true ; } else return false ; / / return ( source instanceof Report CaMeL Element CaMeL Handle / / / / && ( Session CaMeL Handle CaMeL Adapter . get CaMeL Instance ( ) . get CaMeL Report CaMeL Design CaMeL Handle ( ) / / instanceof Library CaMeL Handle ) / / && ! ( source instanceof Master CaMeL Page CaMeL Handle ) ) ; }	return ( ( Cell CaMeL Handle ) source ) . get CaMeL Content ( ) . get CaMeL Contents ( ) . size ( ) > 0 && ( ( Cell CaMeL Handle ) source ) . can CaMeL Drop ( ) ;
U@@ MO CaMeL Encryption CaMeL Strategy s = ( U@@ MO CaMeL Encryption CaMeL Strategy ) digester . peek ( ) ; ( ( U@@ MO CaMeL Security CaMeL Manager ) digester . peek ( 1 ) ) . add CaMeL Encryption CaMeL Strategy ( name , s ) ;  <CTX>  public void end ( String endpoint CaMeL Name , String endpoint CaMeL Name 1 ) throws Exception { U@@ MO CaMeL Encryption CaMeL Strategy s = ( U@@ MO CaMeL Encryption CaMeL Strategy ) digester . peek ( ) ; ( ( U@@ MO CaMeL Security CaMeL Manager ) digester . peek ( 1 ) ) . add CaMeL Encryption CaMeL Strategy ( name , s ) ; }	U@@ MO CaMeL Transaction CaMeL Manager CaMeL Factory tx CaMeL Factory = ( U@@ MO CaMeL Transaction CaMeL Manager CaMeL Factory ) digester . pop ( ) ; digester . push ( tx CaMeL Factory . create ( ) ) ;
try {  <CTX>  public void update CaMeL Outer CaMeL Language CaMeL Elements ( final Set < Language > reparsed CaMeL Roots ) { for ( Map . Entry < Language , Psi CaMeL File > entry : my CaMeL Roots . entry CaMeL Set ( ) ) { final Psi CaMeL File psi CaMeL File = entry . get CaMeL Value ( ) ; final Language updated CaMeL Language = entry . get CaMeL Key ( ) ; if ( reparsed CaMeL Roots . contains ( updated CaMeL Language ) ) continue ; final Set < Weak CaMeL Reference < Outer CaMeL Language CaMeL Element >> list = my CaMeL Outer CaMeL Language CaMeL Elements . get ( psi CaMeL File ) ; if ( list == null ) / / not parsed yet continue ; try { my CaMeL Roots CaMeL In CaMeL Update . add ( psi CaMeL File ) ; final Iterator < Weak CaMeL Reference < Outer CaMeL Language CaMeL Element >> iterator = list . iterator ( ) ; Xml CaMeL Text prev CaMeL Text = null ; while ( iterator . has CaMeL Next ( ) ) { Weak CaMeL Reference < Outer CaMeL Language CaMeL Element > reference = iterator . next ( ) ; final Outer CaMeL Language CaMeL Element outer CaMeL Element = reference . get ( ) ; if ( outer CaMeL Element == null ) { iterator . remove ( ) ; continue ; } final File CaMeL Element file = Tree CaMeL Util . get CaMeL File CaMeL Element ( outer CaMeL Element ) ; if ( file == null || file . get CaMeL Psi ( ) != psi CaMeL File ) { iterator . remove ( ) ; continue ; } final Xml CaMeL Text next CaMeL Text = outer CaMeL Element . get CaMeL Following CaMeL Text ( ) ; final Text CaMeL Range text CaMeL Range = new Text CaMeL Range ( prev CaMeL Text != null ? prev CaMeL Text . get CaMeL Text CaMeL Range ( ) . get CaMeL End CaMeL Offset ( ) : 0 , next CaMeL Text != null ? next CaMeL Text . get CaMeL Text CaMeL Range ( ) . get CaMeL Start CaMeL Offset ( ) : get CaMeL Contents ( ) . length ( ) ) ; if ( ! text CaMeL Range . equals ( outer CaMeL Element . get CaMeL Text CaMeL Range ( ) ) ) { outer CaMeL Element . set CaMeL Range ( text CaMeL Range ) ; } prev CaMeL Text = next CaMeL Text ; } } finally { my CaMeL Roots CaMeL In CaMeL Update . remove ( psi CaMeL File ) ; check CaMeL Consiste@@ n@@ sy ( psi CaMeL File ) ; } } }	} try {
if ( fast CaMeL View CaMeL Bar CaMeL Control != null && ! fast CaMeL View CaMeL Bar CaMeL Control . is CaMeL Disposed ( ) )  <CTX>  public void run ( boolean fork , boolean cancelable , I CaMeL Runnable CaMeL With CaMeL Progress runnable ) throws Invocation CaMeL Target CaMeL Exception , Interrupted CaMeL Exception { I CaMeL Workbench CaMeL Context CaMeL Support context CaMeL Support = get CaMeL Workbench ( ) . get CaMeL Context CaMeL Support ( ) ; final boolean key CaMeL Filter CaMeL Enabled = context CaMeL Support . is CaMeL Key CaMeL Filter CaMeL Enabled ( ) ; Control fast CaMeL View CaMeL Bar CaMeL Control = get CaMeL Fast CaMeL View CaMeL Bar ( ) == null ? null : get CaMeL Fast CaMeL View CaMeL Bar ( ) . get CaMeL Control ( ) ; boolean fast CaMeL View CaMeL Bar CaMeL Was CaMeL Enabled = fast CaMeL View CaMeL Bar CaMeL Control == null ? false : fast CaMeL View CaMeL Bar CaMeL Control . get CaMeL Enabled ( ) ; Control perspective CaMeL Bar CaMeL Control = get CaMeL Perspective CaMeL Bar ( ) == null ? null : get CaMeL Perspective CaMeL Bar ( ) . get CaMeL Control ( ) ; boolean perspective CaMeL Bar CaMeL Was CaMeL Enabled = perspective CaMeL Bar CaMeL Control == null ? false : perspective CaMeL Bar CaMeL Control . get CaMeL Enabled ( ) ; try { if ( fast CaMeL View CaMeL Bar CaMeL Control != null && ! fast CaMeL View CaMeL Bar CaMeL Control . is CaMeL Disposed ( ) ) fast CaMeL View CaMeL Bar CaMeL Control . set CaMeL Enabled ( false ) ; if ( perspective CaMeL Bar CaMeL Control != null && ! perspective CaMeL Bar CaMeL Control . is CaMeL Disposed ( ) ) perspective CaMeL Bar CaMeL Control . set CaMeL Enabled ( false ) ; if ( key CaMeL Filter CaMeL Enabled ) context CaMeL Support . set CaMeL Key CaMeL Filter CaMeL Enabled ( false ) ; super . run ( fork , cancelable , runnable ) ; } finally { if ( fast CaMeL View CaMeL Bar CaMeL Control != null && ! fast CaMeL View CaMeL Bar CaMeL Control . is CaMeL Disposed ( ) ) fast CaMeL View CaMeL Bar CaMeL Control . set CaMeL Enabled ( fast CaMeL View CaMeL Bar CaMeL Was CaMeL Enabled ) ; if ( perspective CaMeL Bar CaMeL Control != null && ! perspective CaMeL Bar CaMeL Control . is CaMeL Disposed ( ) ) perspective CaMeL Bar CaMeL Control . set CaMeL Enabled ( perspective CaMeL Bar CaMeL Was CaMeL Enabled ) ; if ( key CaMeL Filter CaMeL Enabled ) context CaMeL Support . set CaMeL Key CaMeL Filter CaMeL Enabled ( true ) ; } }	if ( fast CaMeL View CaMeL Bar CaMeL Control != null && ! fast CaMeL View CaMeL Bar CaMeL Control . is CaMeL Disposed ( ) ) {
Shell parent = e . display . get CaMeL Active CaMeL Shell ( ) ; Advanced CaMeL Dialog dialog = new Advanced CaMeL Dialog ( parent ) ;  <CTX>  public void widget CaMeL Selected ( Selection CaMeL Event e ) { Shell parent = e . display . get CaMeL Active CaMeL Shell ( ) ; Advanced CaMeL Dialog dialog = new Advanced CaMeL Dialog ( parent ) ; dialog . open ( ) ; / / logic for updating the working copy is in the dialog class . }	Advanced CaMeL Dialog dialog = new Advanced CaMeL Dialog ( parent . get CaMeL Shell ( ) ) ;
return copy CaMeL Of CaMeL Old CaMeL Map . get ( key ) ;  <CTX>  public Object get CaMeL Old CaMeL Value ( Object key ) { return copy CaMeL Of CaMeL Old CaMeL Map . get ( key ) ; }	return old CaMeL Value ;
if ( ! m _ extracted . contains ( url ) ) { m _ extracted . add ( url ) ; try { String norm CaMeL Url = Url CaMeL Util . normalize CaMeL Url ( url ) ; if ( Base CaMeL Crawler . is CaMeL Supported CaMeL Url CaMeL Protocol ( norm CaMeL Url ) && m _ crawl CaMeL Spec . is CaMeL Included ( norm CaMeL Url ) ) { m _ in@@ cls . add ( norm CaMeL Url ) ; } else { m _ ex@@ cls . add ( norm CaMeL Url ) ; } } catch ( Malformed CaMeL URL CaMeL Exception e ) { m _ ex@@ cls . add ( url ) ;  <CTX>  public void found CaMeL Url ( String url ) { if ( ! m _ extracted . contains ( url ) ) { m _ extracted . add ( url ) ; try { String norm CaMeL Url = Url CaMeL Util . normalize CaMeL Url ( url ) ; if ( Base CaMeL Crawler . is CaMeL Supported CaMeL Url CaMeL Protocol ( norm CaMeL Url ) && m _ crawl CaMeL Spec . is CaMeL Included ( norm CaMeL Url ) ) { m _ in@@ cls . add ( norm CaMeL Url ) ; } else { m _ ex@@ cls . add ( norm CaMeL Url ) ; } } catch ( Malformed CaMeL URL CaMeL Exception e ) { m _ ex@@ cls . add ( url ) ; } } }	m _ extracted . add ( url ) ; try { String norm CaMeL Url = Url CaMeL Util . normalize CaMeL Url ( url ) ; if ( Base CaMeL Crawler . is CaMeL Supported CaMeL Url CaMeL Protocol ( norm CaMeL Url ) && m _ crawl CaMeL Spec . is CaMeL Included ( norm CaMeL Url ) ) { m _ in@@ cls . add ( norm CaMeL Url ) ;
int size = _ critics . size ( ) ; for ( int i = 0 ; i < size ; ++ i ) { Critic c = ( Critic ) _ critics . element CaMeL At ( i ) ; if ( c . contains CaMeL Knowledge CaMeL Type ( type ) ) return true ;  <CTX>  public boolean contains CaMeL Knowledge CaMeL Type ( String type ) { int size = _ critics . size ( ) ; for ( int i = 0 ; i < size ; ++ i ) { Critic c = ( Critic ) _ critics . element CaMeL At ( i ) ; if ( c . contains CaMeL Knowledge CaMeL Type ( type ) ) return true ; } return false ; }	int size = _ critics . size ( ) ; for ( int i = 0 ; i < size ; ++ i ) { Critic c = ( Critic ) _ critics . element CaMeL At ( i ) ; if ( c . contains CaMeL Knowledge CaMeL Type ( type ) ) return true ; } return false ;
try { initial _ mbrs . wait ( ) ; } catch ( Exception e ) {  <CTX>  void find CaMeL Initial CaMeL Members ( ) { Ping CaMeL Rsp ping _ rsp ; synchronized ( initial _ mbrs ) { initial _ mbrs . remove CaMeL All CaMeL Elements ( ) ; gms . pass CaMeL Down ( new Event ( Event . FIND _ INITIAL _ M@@ BRS ) ) ; try { initial _ mbrs . wait ( ) ; } catch ( Exception e ) { } for ( int i = 0 ; i < initial _ mbrs . size ( ) ; i ++ ) { ping _ rsp = ( Ping CaMeL Rsp ) initial _ mbrs . element CaMeL At ( i ) ; if ( ping _ rsp . own _ addr != null && gms . local _ addr != null && ping _ rsp . own _ addr . equals ( gms . local _ addr ) ) { initial _ mbrs . remove CaMeL Element CaMeL At ( i ) ; break ; } } } }	if ( initial _ mbrs _ received == false ) { try { initial _ mbrs . wait ( ) ; } catch ( Exception e ) { }
J CaMeL Label renderer = ( J CaMeL Label ) get CaMeL Cell CaMeL Renderer ( row , col ) . get CaMeL Table CaMeL Cell CaMeL Renderer CaMeL Component ( this , get CaMeL Model ( ) . get CaMeL Value CaMeL At ( row , col ) , false , false , row , col ) ;  <CTX>  public String get CaMeL Text CaMeL For CaMeL Cell ( int row , int col ) { / / note : this will only work bec@@ ause we know all the renderers are j@@ labels J CaMeL Label renderer = ( J CaMeL Label ) get CaMeL Cell CaMeL Renderer ( row , col ) . get CaMeL Table CaMeL Cell CaMeL Renderer CaMeL Component ( this , get CaMeL Model ( ) . get CaMeL Value CaMeL At ( row , col ) , false , false , row , col ) ; return renderer . get CaMeL Text ( ) ; }	J CaMeL Label renderer = ( J CaMeL Label ) get CaMeL Cell CaMeL Renderer ( row , col ) . get CaMeL Table CaMeL Cell CaMeL Renderer CaMeL Component ( this , get CaMeL Model ( ) . get CaMeL Value CaMeL At ( row , get CaMeL Column CaMeL Model ( ) . get CaMeL Column ( col ) . get CaMeL Model CaMeL Index ( ) ) , false , false , row , col ) ;
state CaMeL Estimation CaMeL Subscription = ( Incremental CaMeL Subscription ) get CaMeL Blackboard CaMeL Service ( ) . subscribe ( State CaMeL Estimation . pred ) ;  <CTX>  protected void setup CaMeL Subscriptions ( ) { diagno@@ ses CaMeL Wrapper CaMeL Subscription = ( Incremental CaMeL Subscription ) get CaMeL Blackboard CaMeL Service ( ) . subscribe ( new Unary CaMeL Predicate ( ) { public boolean execute ( Object o ) { if ( o instanceof Diagnoses CaMeL Wrapper ) { return true ; } return false ; } } ) ; actions CaMeL Wrapper CaMeL Subscription = ( Incremental CaMeL Subscription ) get CaMeL Blackboard CaMeL Service ( ) . subscribe ( new Unary CaMeL Predicate ( ) { public boolean execute ( Object o ) { if ( o instanceof Actions CaMeL Wrapper ) { return true ; } return false ; } } ) ; cost CaMeL Benefit CaMeL Evaluation CaMeL Subscription = ( Incremental CaMeL Subscription ) get CaMeL Blackboard CaMeL Service ( ) . subscribe ( Cost CaMeL Benefit CaMeL Evaluation . pred ) ; state CaMeL Estimation CaMeL Subscription = ( Incremental CaMeL Subscription ) get CaMeL Blackboard CaMeL Service ( ) . subscribe ( State CaMeL Estimation . pred ) ; }	state CaMeL Estimation CaMeL Subscription = null ;
set . add ( get CaMeL Class CaMeL Name ( ) ) ;  <CTX>  public void visit ( Constant CaMeL String s ) { String value = s . get CaMeL Bytes ( get CaMeL Constant CaMeL Pool ( ) ) ; if ( value . length ( ) < SIZE _ OF _ HUGE _ CONSTANT ) return ; String key = get CaMeL String CaMeL Key ( value ) ; Set < String > set = map . get ( key ) ; if ( set == null ) { set = new Hash CaMeL Set < String > ( ) ; map . put ( key , set ) ; } set . add ( get CaMeL Class CaMeL Name ( ) ) ; }	set . add ( get CaMeL Dotted CaMeL Class CaMeL Name ( ) ) ;
if ( node == null )  <CTX>  public I CaMeL Hyperlink [ ] detect CaMeL Hyperlinks ( I CaMeL Text CaMeL Viewer text CaMeL Viewer , I CaMeL Region region , boolean can CaMeL Show CaMeL Multiple CaMeL Hyperlinks ) { if ( region == null || can CaMeL Show CaMeL Multiple CaMeL Hyperlinks ) return null ; I CaMeL Document CaMeL Range element = f CaMeL Source CaMeL Page . get CaMeL Range CaMeL Element ( region . get CaMeL Offset ( ) ) ; if ( element == null ) return null ; if ( ! ( element instanceof I CaMeL Document CaMeL Attribute ) ) return null ; / / only highlight if we are ho@@ vering inside of the attribute value I CaMeL Document CaMeL Attribute attr = ( I CaMeL Document CaMeL Attribute ) element ; if ( attr . get CaMeL Value CaMeL Offset ( ) > region . get CaMeL Offset ( ) || attr . get CaMeL Value CaMeL Offset ( ) + attr . get CaMeL Value CaMeL Length ( ) - 1 < region . get CaMeL Offset ( ) ) return null ; / / consult schema to make sure attribute is of kind I CaMeL Meta CaMeL Attribute . JAVA I CaMeL Document CaMeL Node node = attr . get CaMeL Enclosing CaMeL Element ( ) ; while ( node != null && ! ( node instanceof I CaMeL Plugin CaMeL Extension ) ) node = node . get CaMeL Parent CaMeL Node ( ) ; if ( node == null ) return null ; I CaMeL Schema schema = PDE CaMeL Core . get CaMeL Default ( ) . get CaMeL Schema CaMeL Registry ( ) . get CaMeL Schema ( ( ( I CaMeL Plugin CaMeL Extension ) node ) . get CaMeL Point ( ) ) ; if ( schema == null ) return null ; I CaMeL Schema CaMeL Element s CaMeL Element = schema . find CaMeL Element ( attr . get CaMeL Enclosing CaMeL Element ( ) . get CaMeL XML CaMeL Tag CaMeL Name ( ) ) ; if ( s CaMeL Element == null ) return null ; I CaMeL Schema CaMeL Attribute s CaMeL Attr = s CaMeL Element . get CaMeL Attribute ( attr . get CaMeL Attribute CaMeL Name ( ) ) ; if ( s CaMeL Attr == null ) return null ; if ( ( ( I CaMeL Plugin CaMeL Attribute ) attr ) . get CaMeL Value ( ) . length ( ) == 0 ) return null ; if ( s CaMeL Attr . get CaMeL Kind ( ) == I CaMeL Meta CaMeL Attribute . JAVA ) { return new I CaMeL Hyperlink [ ] { new Java CaMeL Hyperlink ( new Region ( attr . get CaMeL Value CaMeL Offset ( ) , attr . get CaMeL Value CaMeL Length ( ) ) , ( ( I CaMeL Plugin CaMeL Extension ) node ) . get CaMeL Model ( ) . get CaMeL Underlying CaMeL Resource ( ) . get CaMeL Project ( ) , ( ( I CaMeL Plugin CaMeL Attribute ) attr ) . get CaMeL Value ( ) ) } ; } else if ( s CaMeL Attr . get CaMeL Kind ( ) == I CaMeL Meta CaMeL Attribute . RESOURCE ) { / / TODO select OR open resource in package explorer } return null ; }	if ( node == null || ! ( ( I CaMeL Plugin CaMeL Extension ) node ) . get CaMeL Model ( ) . is CaMeL Editable ( ) )
if ( programs [ i ] . get CaMeL Name ( ) . equals ( program CaMeL Name ) ) return programs [ i ] ;  <CTX>  private static Program find CaMeL Program ( String program CaMeL Name ) { Program [ ] programs = Program . get CaMeL Programs ( ) ; for ( int i = 0 ; i < programs . length ; i ++ ) { if ( programs [ i ] . get CaMeL Name ( ) . equals ( program CaMeL Name ) ) return programs [ i ] ; } return null ; }	if ( programs [ i ] . get CaMeL Name ( ) . equals ( program CaMeL Name ) ) { return programs [ i ] ; }
return null ;  <CTX>  private static Class find CaMeL Class ( Class CaMeL Loader loader , String class CaMeL Name ) { try { if ( loader != null ) { return loader . load CaMeL Class ( class CaMeL Name ) ; } else { return Script CaMeL Runtime . load CaMeL Class CaMeL Name ( class CaMeL Name ) ; } } catch ( Class CaMeL Not CaMeL Found CaMeL Exception ex ) { } catch ( Security CaMeL Exception ex ) { } return null ; }	return cl ;
super CaMeL Methods [ i ] . get CaMeL Containing CaMeL Class ( ) ;  <CTX>  private boolean is CaMeL Override CaMeL Of CaMeL Library CaMeL Method ( Psi CaMeL Method method ) { final Psi CaMeL Method [ ] super CaMeL Methods = Psi CaMeL Super CaMeL Method CaMeL Util . find CaMeL Super CaMeL Methods ( method ) ; for ( int i = 0 ; i < super CaMeL Methods . length ; i ++ ) { final Psi CaMeL Class containing CaMeL Class = super CaMeL Methods [ i ] . get CaMeL Containing CaMeL Class ( ) ; if ( containing CaMeL Class != null && Library CaMeL Util . class CaMeL Is CaMeL In CaMeL Library ( containing CaMeL Class ) ) { return true ; } } return false ; }	super CaMeL Method . get CaMeL Containing CaMeL Class ( ) ;
Set the CaMeL Descriptors ) { return extract CaMeL Descriptor CaMeL Instances ( the CaMeL Descriptors , true ) ;  <CTX>  private Navigator CaMeL Content CaMeL Extension [ ] extract CaMeL Descriptor CaMeL Instances ( Set the CaMeL Descriptors ) { return extract CaMeL Descriptor CaMeL Instances ( the CaMeL Descriptors , true ) ; }	Set the CaMeL Descriptors , boolean to CaMeL Load CaMeL All CaMeL If CaMeL Necessary ) { if ( the CaMeL Descriptors . size ( ) == 0 ) return NO _ CONTENT _ EXTENSIONS ; Set result CaMeL Instances = new Hash CaMeL Set ( ) ; for ( Iterator descriptor CaMeL Iter = the CaMeL Descriptors . iterator ( ) ; descriptor CaMeL Iter . has CaMeL Next ( ) ; ) { Navigator CaMeL Content CaMeL Extension extension = get CaMeL Extension ( ( Navigator CaMeL Content CaMeL Descriptor ) descriptor CaMeL Iter . next ( ) , to CaMeL Load CaMeL All CaMeL If CaMeL Necessary ) ; if ( extension != null ) { result CaMeL Instances . add ( extension ) ; } } Navigator CaMeL Content CaMeL Extension [ ] extensions = ( Navigator CaMeL Content CaMeL Extension [ ] ) result CaMeL Instances . to CaMeL Array ( new Navigator CaMeL Content CaMeL Extension [ result CaMeL Instances . size ( ) ] ) ; Arrays . sort ( extensions , EXTENSION _ COMPARATOR ) ; return extensions ;
tree . expand CaMeL Path ( new Tree CaMeL Path ( ( ( Default CaMeL Mutable CaMeL Tree CaMeL Node ) ( tree . get CaMeL Model ( ) ) . get CaMeL Root ( ) ) . get CaMeL Path ( ) ) ) ;  <CTX>  public void install CaMeL UI ( J CaMeL Component c ) { super . install CaMeL UI ( c ) ; install CaMeL Defaults ( ( J CaMeL Tree ) c ) ; tree = ( J CaMeL Tree ) c ; set CaMeL Model ( tree . get CaMeL Model ( ) ) ; tree . set CaMeL Root CaMeL Visible ( true ) ; tree . expand CaMeL Path ( new Tree CaMeL Path ( ( ( Default CaMeL Mutable CaMeL Tree CaMeL Node ) ( tree . get CaMeL Model ( ) ) . get CaMeL Root ( ) ) . get CaMeL Path ( ) ) ) ; tree CaMeL Selection CaMeL Model = tree . get CaMeL Selection CaMeL Model ( ) ; install CaMeL Listeners ( ) ; install CaMeL Keyboard CaMeL Actions ( ) ; complete CaMeL UI CaMeL Install ( ) ; }	tree . expand CaMeL Path ( new Tree CaMeL Path ( tree . get CaMeL Model ( ) . get CaMeL Root ( ) ) ) ;
int start = get CaMeL Line CaMeL Start CaMeL Offset ( caret CaMeL Line ) ; if ( caret == start )  <CTX>  public void go CaMeL To CaMeL Prev CaMeL Line ( boolean select ) { int magic = get CaMeL Magic CaMeL Caret CaMeL Position ( ) ; int prev CaMeL Line = fold CaMeL Visibility CaMeL Manager . get CaMeL Prev CaMeL Visible CaMeL Line ( caret CaMeL Line ) ; int new CaMeL Caret ; if ( prev CaMeL Line == - 1 ) { int start = get CaMeL Line CaMeL Start CaMeL Offset ( caret CaMeL Line ) ; if ( caret == start ) { get CaMeL Toolkit ( ) . beep ( ) ; return ; } else new CaMeL Caret = start ; } else new CaMeL Caret = get CaMeL Line CaMeL Start CaMeL Offset ( prev CaMeL Line ) + x CaMeL To CaMeL Offset ( prev CaMeL Line , magic + 1 ) ; if ( select ) extend CaMeL Selection ( caret , new CaMeL Caret ) ; else if ( ! multi ) select CaMeL None ( ) ; move CaMeL Caret CaMeL Position ( new CaMeL Caret ) ; set CaMeL Magic CaMeL Caret CaMeL Position ( magic ) ; } / / } } }	new CaMeL Caret = buffer . get CaMeL Line CaMeL Start CaMeL Offset ( caret CaMeL Line ) + x CaMeL To CaMeL Sub@@ region CaMeL Offset ( line CaMeL Infos [ sub@@ region - 1 ] , magic , true ) ; } else { int prev CaMeL Line = fold CaMeL Visibility CaMeL Manager . get CaMeL Prev CaMeL Visible CaMeL Line ( caret CaMeL Line ) ; if ( prev CaMeL Line == - 1 )
Options go = parent . get CaMeL Global CaMeL Options ( ) ; override CaMeL For CaMeL Class ( go , cd ) ; return go ;  <CTX>  public Options get CaMeL Options CaMeL For ( Class CaMeL Doc cd ) { Options go = parent . get CaMeL Global CaMeL Options ( ) ; override CaMeL For CaMeL Class ( go , cd ) ; return go ; }	if ( global CaMeL Options . matches CaMeL Hide CaMeL Expression ( cd . to CaMeL String ( ) ) || ! matcher . matches ( cd ) ) { return hide CaMeL Options ; } else if ( cd . equals ( this . cd ) ) { return center CaMeL Options ; } else if ( cd . containing CaMeL Package ( ) . equals ( this . cd . containing CaMeL Package ( ) ) ) { return package CaMeL Options ; } else { return global CaMeL Options ; }
dest . _ format . set CaMeL Omit CaMeL XML CaMeL Declaration ( src . _ format . get CaMeL Omit CaMeL XML CaMeL Declaration ( ) ) ; dest . f CaMeL Namespaces = src . f CaMeL Namespaces ; dest . f CaMeL DOM CaMeL Error CaMeL Handler = src . f CaMeL DOM CaMeL Error CaMeL Handler ;  <CTX>  private void copy CaMeL Settings ( XML CaMeL Serializer src , XML CaMeL Serializer dest ) { dest . _ format . set CaMeL Omit CaMeL XML CaMeL Declaration ( src . _ format . get CaMeL Omit CaMeL XML CaMeL Declaration ( ) ) ; dest . f CaMeL Namespaces = src . f CaMeL Namespaces ; dest . f CaMeL DOM CaMeL Error CaMeL Handler = src . f CaMeL DOM CaMeL Error CaMeL Handler ; dest . _ format . set CaMeL Encoding ( src . _ format . get CaMeL Encoding ( ) ) ; dest . _ format . set CaMeL Line CaMeL Separator ( src . _ format . get CaMeL Line CaMeL Separator ( ) ) ; dest . f CaMeL DOM CaMeL Filter = src . f CaMeL DOM CaMeL Filter ; / / and copy over all the entries in f CaMeL Features : Enumeration keys = src . f CaMeL Features . keys ( ) ; while ( keys . has CaMeL More CaMeL Elements ( ) ) { Object key = keys . next CaMeL Element ( ) ; Object val = src . f CaMeL Features . get ( key ) ; dest . f CaMeL Features . put ( key , val ) ; } } / / copy@@ setting@@ s	dest . f CaMeL DOM CaMeL Error CaMeL Handler = f CaMeL Error CaMeL Handler ;
return Ruby CaMeL Array . new CaMeL Array ( get CaMeL Runtime ( ) ,  <CTX>  public Ruby CaMeL Array coerce ( Ruby CaMeL Numeric other ) { if ( get CaMeL Meta CaMeL Class ( ) == other . get CaMeL Meta CaMeL Class ( ) ) { return Ruby CaMeL Array . new CaMeL Array ( get CaMeL Runtime ( ) , other , this ) ; } return Ruby CaMeL Array . new CaMeL Array ( get CaMeL Runtime ( ) , Ruby CaMeL Float . new CaMeL Float ( get CaMeL Runtime ( ) , other . get CaMeL Double CaMeL Value ( ) ) , Ruby CaMeL Float . new CaMeL Float ( get CaMeL Runtime ( ) , get CaMeL Double CaMeL Value ( ) ) ) ; }	return get CaMeL Runtime ( ) . new CaMeL Array (
this . label = original . get CaMeL Name ( ) ; this . id = original . get CaMeL Id ( ) ; this . category CaMeL Id = original . get CaMeL Category CaMeL Id ( ) ; this . description = original . get CaMeL Description ( ) ; this . is CaMeL Editable = original . is CaMeL Editable ( ) ; this . plugin CaMeL Id = original . get CaMeL Plugin CaMeL Id ( ) ; this . parsed CaMeL Value = value ;  <CTX>  public Color CaMeL Definition ( Color CaMeL Definition original , RGB value ) { this . label = original . get CaMeL Name ( ) ; this . id = original . get CaMeL Id ( ) ; this . category CaMeL Id = original . get CaMeL Category CaMeL Id ( ) ; this . description = original . get CaMeL Description ( ) ; this . is CaMeL Editable = original . is CaMeL Editable ( ) ; this . plugin CaMeL Id = original . get CaMeL Plugin CaMeL Id ( ) ; this . parsed CaMeL Value = value ; }	this . label = label ; this . id = id ; this . defaults CaMeL To = defaults CaMeL To ; this . raw CaMeL Value = value ; this . category CaMeL Id = category CaMeL Id ; this . description = description ; this . is CaMeL Editable = is CaMeL Editable ; this . plugin CaMeL Id = plugin CaMeL Id ;
int rule CaMeL Action = SPAN | REGEXP | ( ( no CaMeL Line CaMeL Break ) ? NO _ LINE _ BREAK : 0 ) | ( ( exclude CaMeL Match ) ? EXCLUDE _ MATCH : 0 ) | ( ( no CaMeL Word CaMeL Break ) ? NO _ WORD _ BREAK : 0 ) | ( ( no CaMeL Escape ) ? NO _ ESCAPE : 0 ) ; return new Parser CaMeL Rule ( rule CaMeL Action , hash CaMeL Char , start CaMeL Pos CaMeL Match , null , Pattern . compile ( start , ( ignore CaMeL Case ? Pattern . CASE _ INSENSITIVE : 0 ) ) , end CaMeL Pos CaMeL Match , end . to CaMeL Char CaMeL Array ( ) , delegate , id ) ;  <CTX>  public static final Parser CaMeL Rule create CaMeL Regexp CaMeL Span CaMeL Rule ( char hash CaMeL Char , int start CaMeL Pos CaMeL Match , String start , int end CaMeL Pos CaMeL Match , String end , Parser CaMeL Rule CaMeL Set delegate , byte id , boolean exclude CaMeL Match , boolean no CaMeL Line CaMeL Break , boolean no CaMeL Word CaMeL Break , boolean ignore CaMeL Case , boolean no CaMeL Escape ) throws Pattern CaMeL Syntax CaMeL Exception { int rule CaMeL Action = SPAN | REGEXP | ( ( no CaMeL Line CaMeL Break ) ? NO _ LINE _ BREAK : 0 ) | ( ( exclude CaMeL Match ) ? EXCLUDE _ MATCH : 0 ) | ( ( no CaMeL Word CaMeL Break ) ? NO _ WORD _ BREAK : 0 ) | ( ( no CaMeL Escape ) ? NO _ ESCAPE : 0 ) ; return new Parser CaMeL Rule ( rule CaMeL Action , hash CaMeL Char , start CaMeL Pos CaMeL Match , null , Pattern . compile ( start , ( ignore CaMeL Case ? Pattern . CASE _ INSENSITIVE : 0 ) ) , end CaMeL Pos CaMeL Match , end . to CaMeL Char CaMeL Array ( ) , delegate , id ) ; } / / } } }	return create CaMeL Regexp CaMeL Span CaMeL Rule ( String . value CaMeL Of ( hash CaMeL Char ) , start CaMeL Pos CaMeL Match , start , end CaMeL Pos CaMeL Match , end , delegate , id , exclude CaMeL Match , no CaMeL Line CaMeL Break , no CaMeL Word CaMeL Break , ignore CaMeL Case , no CaMeL Escape ) ;
Output CaMeL Format format = Output CaMeL Format . create CaMeL Pretty CaMeL Print ( ) ; XML CaMeL Writer writer = new XML CaMeL Writer ( resp . get CaMeL Output CaMeL Stream ( ) , format ) ; writer . write ( out CaMeL Msg ) ;  <CTX>  protected void send CaMeL Response ( Dav CaMeL Context ctxt , Document out CaMeL Msg ) throws IO CaMeL Exception { Http CaMeL Servlet CaMeL Response resp = ctxt . get CaMeL Response ( ) ; resp . set CaMeL Status ( ctxt . get CaMeL Status ( ) ) ; if ( out CaMeL Msg != null ) { resp . set CaMeL Content CaMeL Type ( Dav CaMeL Protocol . DAV _ CONTENT _ TYPE ) ; Output CaMeL Format format = Output CaMeL Format . create CaMeL Pretty CaMeL Print ( ) ; XML CaMeL Writer writer = new XML CaMeL Writer ( resp . get CaMeL Output CaMeL Stream ( ) , format ) ; writer . write ( out CaMeL Msg ) ; } ctxt . response CaMeL Sent ( ) ; }	Dav CaMeL Response resp CaMeL Msg = ctxt . get CaMeL Dav CaMeL Response ( ) ; resp CaMeL Msg . write CaMeL To ( resp . get CaMeL Output CaMeL Stream ( ) ) ;
return si@@ tuation . get CaMeL State ( ) . equals ( new State ( State . ACTIVE ) ) ;  <CTX>  public Re@@ im@@ bur@@ sement CaMeL Guide CaMeL Situation get CaMeL Active CaMeL Re@@ im@@ bur@@ sement CaMeL Guide CaMeL Situation ( ) { return ( Re@@ im@@ bur@@ sement CaMeL Guide CaMeL Situation ) Collection CaMeL Utils . find ( get CaMeL Re@@ im@@ bur@@ sement CaMeL Guide CaMeL Si@@ tu@@ ations ( ) , new Predicate ( ) { public boolean evaluate ( Object obj ) { Re@@ im@@ bur@@ sement CaMeL Guide CaMeL Situation si@@ tuation = ( Re@@ im@@ bur@@ sement CaMeL Guide CaMeL Situation ) obj ; return si@@ tuation . get CaMeL State ( ) . equals ( new State ( State . ACTIVE ) ) ; } } ) ; }	return si@@ tuation . get CaMeL State ( ) . get CaMeL State ( ) . equals ( State . ACTIVE ) ;
if ( name . to CaMeL Lower CaMeL Case ( ) . ends CaMeL With ( extension ) ) {  <CTX>  public boolean accept ( File dir , String name ) { if ( name . to CaMeL Lower CaMeL Case ( ) . ends CaMeL With ( extension ) ) { return true ; } return false ; }	String lower CaMeL Case CaMeL Name = name . to CaMeL Lower CaMeL Case ( ) ; if ( lower CaMeL Case CaMeL Name . ends CaMeL With ( SUFFIX _ STRING _ jar ) || lower CaMeL Case CaMeL Name . ends CaMeL With ( SUFFIX _ STRING _ zip ) ) {
append ( text ) ;  <CTX>  public void append CaMeL Text ( String text ) { append ( text ) ; }	Text CaMeL Area CaMeL Peer peer = ( Text CaMeL Area CaMeL Peer ) get CaMeL Peer ( ) ; if ( peer == null ) return ; peer . insert ( str , peer . get CaMeL Text ( ) . length ( ) ) ;
On@@ ion commands = type ( ) . commands ( state ) ; return ( Command ) commands . find ( Command . finder ( command CaMeL Name ) ) ;  <CTX>  public Command command ( String command CaMeL Name , State state ) { On@@ ion commands = type ( ) . commands ( state ) ; return ( Command ) commands . find ( Command . finder ( command CaMeL Name ) ) ; }	return command ( command CaMeL Name , start CaMeL State ( ) ) ;
Library lib = module . get CaMeL Visible CaMeL Library CaMeL With CaMeL Namespace ( lib CaMeL Reference . get CaMeL Library CaMeL Namespace ( ) ) ;  <CTX>  public Object get CaMeL Property ( Module module , Property CaMeL Defn prop CaMeL Defn ) { assert prop CaMeL Defn != null ; / / return local value first Object value = get CaMeL Local CaMeL Property ( module , prop CaMeL Defn ) ; if ( value != null ) return value ; / / first , read property values in local ; second , check the library / / reference and load the property values from it ; third , read default / / in ROM if ( lib CaMeL Reference != null && module != null ) { Referencable CaMeL Structure ref CaMeL Struct = lib CaMeL Reference . get CaMeL Target CaMeL Structure ( ) ; if ( ref CaMeL Struct != null ) { Library lib = module . get CaMeL Visible CaMeL Library CaMeL With CaMeL Namespace ( lib CaMeL Reference . get CaMeL Library CaMeL Namespace ( ) ) ; Module root = lib == null ? module : lib ; value = ref CaMeL Struct . get CaMeL Property ( root , prop CaMeL Defn ) ; if ( value != null ) return value ; } } if ( value == null ) return prop CaMeL Defn . get CaMeL Default ( ) ; return value ; }	Library lib = module . get CaMeL Library CaMeL With CaMeL Namespace ( lib CaMeL Reference . get CaMeL Library CaMeL Namespace ( ) , I CaMeL Module CaMeL Name CaMeL Space . ONE _ LEVEL ) ;
return native CaMeL Is CaMeL Leaf ( native CaMeL RDF CaMeL Node ) ;  <CTX>  public boolean is CaMeL Leaf ( ) { Assert . assert ( - 1 != native CaMeL RDF CaMeL Node ) ; return native CaMeL Is CaMeL Leaf ( native CaMeL RDF CaMeL Node ) ; }	return native CaMeL Is CaMeL Leaf ( native CaMeL Web CaMeL Shell , native CaMeL RDF CaMeL Node ) ;
catch CaMeL Cond = new Node ( Token CaMeL Stream . PRIMARY , new Integer ( Token CaMeL Stream . TRUE ) ) ;  <CTX>  public Object create CaMeL Catch ( String var CaMeL Name , Object catch CaMeL Cond , Object stmts , int lineno ) { if ( catch CaMeL Cond == null ) catch CaMeL Cond = new Node ( Token CaMeL Stream . PRIMARY , new Integer ( Token CaMeL Stream . TRUE ) ) ; Node result = new Node ( Token CaMeL Stream . CATCH , ( Node ) create CaMeL Name ( var CaMeL Name ) , ( Node ) catch CaMeL Cond , ( Node ) stmts ) ; result . set CaMeL Datum ( new Integer ( lineno ) ) ; return result ; }	catch CaMeL Cond = new Node ( Token CaMeL Stream . PRIMARY , Token CaMeL Stream . TRUE ) ;
if ( is CaMeL Zoomed ( ) ) zoom CaMeL Out ( ) ;  <CTX>  public void save CaMeL Perspective CaMeL As ( I CaMeL Perspective CaMeL Descriptor new CaMeL Desc ) { Perspective per@@ sp = get CaMeL Active CaMeL Perspective ( ) ; if ( per@@ sp == null ) return ; I CaMeL Perspective CaMeL Descriptor old CaMeL Desc = per@@ sp . get CaMeL Desc ( ) ; / / Always un@@ zoom . if ( is CaMeL Zoomed ( ) ) zoom CaMeL Out ( ) ; per@@ sp . save CaMeL Desc CaMeL As ( new CaMeL Desc ) ; window . fire CaMeL Perspective CaMeL Saved CaMeL As ( this , old CaMeL Desc , new CaMeL Desc ) ; }	if ( is CaMeL Zoomed ( ) ) { zoom CaMeL Out ( ) ; }
if ( xsi _ type != null ) return context . get CaMeL Type CaMeL Unmarshaller ( xsi _ type ) ;  <CTX>  public Type CaMeL Unmarshaller get CaMeL Type CaMeL Unmarshaller ( Unmarshal CaMeL Context CaMeL Impl context ) { final Q CaMeL Name xsi _ type = context . get CaMeL Xsi CaMeL Type ( ) ; if ( xsi _ type != null ) return context . get CaMeL Type CaMeL Unmarshaller ( xsi _ type ) ; if ( context . has CaMeL Xsi CaMeL Nil ( ) ) return Null CaMeL Unmarshaller . get CaMeL Instance ( ) ; return unmarshaller ; }	if ( xsi _ type != null ) { Type CaMeL Unmarshaller typed _ um = context . get CaMeL Type CaMeL Unmarshaller ( xsi _ type ) ; if ( typed _ um != null ) return typed _ um ; }
Set all CaMeL Cols = new Hash CaMeL Set ( ) ; all CaMeL Cols . add CaMeL All ( this . columns . values ( ) ) ;  <CTX>  public void destroy ( ) { Set all CaMeL Cols = new Hash CaMeL Set ( ) ; all CaMeL Cols . add CaMeL All ( this . columns . values ( ) ) ; / / Remove each column we have . This will recursively cause / / keys etc . to be removed . for ( Iterator i = all CaMeL Cols . iterator ( ) ; i . has CaMeL Next ( ) ; ) { Column c = ( Column ) i . next ( ) ; this . remove CaMeL Column ( c ) ; } }	Set all CaMeL Cols = new Hash CaMeL Set ( this . columns . values ( ) ) ;
return ( get CaMeL Preferred CaMeL Size ( get CaMeL Columns ( ) ) ) ;  <CTX>  preferred CaMeL Size ( ) { return ( get CaMeL Preferred CaMeL Size ( get CaMeL Columns ( ) ) ) ; }	return preferred CaMeL Size ( get CaMeL Columns ( ) ) ;
context . update CaMeL From CaMeL Fact CaMeL Handle ( handle ) ;  <CTX>  public void update CaMeL From CaMeL Fact CaMeL Handle ( final Internal CaMeL Fact CaMeL Handle handle ) { for ( Context CaMeL Entry context = this . contexts ; context != null ; context = context . get CaMeL Next ( ) ) { context . update CaMeL From CaMeL Fact CaMeL Handle ( handle ) ; } }	context . update CaMeL From CaMeL Fact CaMeL Handle ( working CaMeL Memory , handle ) ;
return delegate . get CaMeL Available CaMeL Models ( ) ;  <CTX>  public List get CaMeL Available CaMeL Models ( ) { return delegate . get CaMeL Available CaMeL Models ( ) ; }	List < Rendering CaMeL Model > models = delegate . get CaMeL Available CaMeL Models ( ) ; List result = new Array CaMeL List ( ) ; for ( Rendering CaMeL Model model : models ) { result . add ( copy CaMeL Rendering CaMeL Model ( model ) ) ; } return result ;
List list = ( List ) _ headers . get ( name ) ; return list ;  <CTX>  private List get CaMeL Header CaMeL List ( String name ) { List list = ( List ) _ headers . get ( name ) ; return list ; }	return ( List ) _ headers . get ( name . to CaMeL Upper CaMeL Case ( ) ) ;
requestor . accept CaMeL Field CaMeL Reference ( this ) ;  <CTX>  public void accept CaMeL Element ( I CaMeL Source CaMeL Element CaMeL Requestor requestor ) { requestor . accept CaMeL Field CaMeL Reference ( this ) ; }	try { requestor . accept CaMeL Field CaMeL Reference ( this ) ; } catch ( Exception e ) { / * do nothing * / }
void store ( Connection db ) throws SQL CaMeL Exception {  <CTX>  void store ( Connection db ) throws SQL CaMeL Exception { if ( m _ changed != 0 || m _ from CaMeL Db == false ) { if ( m _ from CaMeL Db ) update ( db ) ; else insert ( db ) ; } }	void store ( ) throws SQL CaMeL Exception {
try { position = buffer . create CaMeL Position ( pos ) ; } catch ( Bad CaMeL Location CaMeL Exception bl ) { Log . log ( Log . ERROR , this , bl ) ; }  <CTX>  void create CaMeL Position ( ) { try { position = buffer . create CaMeL Position ( pos ) ; } catch ( Bad CaMeL Location CaMeL Exception bl ) { Log . log ( Log . ERROR , this , bl ) ; } }	position = buffer . create CaMeL Position ( pos ) ;
result = Script CaMeL Runtime . eq CaMeL Number ( s CaMeL Dbl [ stack CaMeL Top + 1 ] , lhs ) ;  <CTX>  private static int do _ eq ( Object [ ] stack , double [ ] s CaMeL Dbl , int stack CaMeL Top , int op ) { -- stack CaMeL Top ; boolean result ; Object rhs = stack [ stack CaMeL Top + 1 ] ; Object lhs = stack [ stack CaMeL Top ] ; if ( rhs == DBL _ MRK ) { if ( lhs == DBL _ MRK ) { result = ( s CaMeL Dbl [ stack CaMeL Top ] == s CaMeL Dbl [ stack CaMeL Top + 1 ] ) ; } else { result = Script CaMeL Runtime . eq CaMeL Number ( s CaMeL Dbl [ stack CaMeL Top + 1 ] , lhs ) ; } } else { if ( lhs == DBL _ MRK ) { result = Script CaMeL Runtime . eq CaMeL Number ( s CaMeL Dbl [ stack CaMeL Top ] , rhs ) ; } else { result = Script CaMeL Runtime . eq ( lhs , rhs ) ; } } result ^= ( op == Token . NE ) ; stack [ stack CaMeL Top ] = ( result ) ? Boolean . TRUE : Boolean . FALSE ; return stack CaMeL Top ; }	result = Script CaMeL Runtime . eq CaMeL Number ( state . s CaMeL Dbl [ i + 1 ] , lhs ) ;
if ( buffer != null )  <CTX>  private static final String escape ( final String raw CaMeL Text ) { / / defer initialization of a String CaMeL Buffer until we know we need one String CaMeL Buffer buffer = null ; for ( int i = 0 ; i < raw CaMeL Text . length ( ) ; i ++ ) { char c = raw CaMeL Text . char CaMeL At ( i ) ; switch ( c ) { case Command CaMeL Manager . PARAMETER _ START _ CHAR : case Command CaMeL Manager . PARAMETER _ END _ CHAR : case Command CaMeL Manager . ID _ VALUE _ CHAR : case Command CaMeL Manager . PARAMETER _ SEPARATOR _ CHAR : case Command CaMeL Manager . ESCAPE _ CHAR : if ( buffer == null ) buffer = new String CaMeL Buffer ( raw CaMeL Text . substring ( 0 , i ) ) ; buffer . append ( Command CaMeL Manager . ESCAPE _ CHAR ) ; buffer . append ( c ) ; break ; default : if ( buffer != null ) buffer . append ( c ) ; break ; } } if ( buffer == null ) return raw CaMeL Text ; return buffer . to CaMeL String ( ) ; }	if ( buffer != null ) {
Person person = Person . read CaMeL Person CaMeL By CaMeL Username ( username ) ; List < Project CaMeL Access > accesses = Project CaMeL Access . get CaMeL All CaMeL By CaMeL Person CaMeL Username ( person ) ;  <CTX>  public List run ( String username , String cost CaMeL Center , String user CaMeL Number ) throws Excep@@ cao CaMeL Persiste@@ n@@ cia { List < Info CaMeL Ru@@ bric > info CaMeL Cost CaMeL Center CaMeL List = new Array CaMeL List < Info CaMeL Ru@@ bric > ( ) ; Persistent CaMeL Sup@@ ort CaMeL Oracle p = Persistent CaMeL Sup@@ ort CaMeL Oracle . get CaMeL Instance ( ) ; List < I CaMeL Ru@@ bric > cost CaMeL Center CaMeL List = p . get CaMeL I CaMeL Persistent CaMeL Project CaMeL User ( ) . get CaMeL In@@ sti@@ t@@ uc@@ i@@ onal CaMeL Project CaMeL Coord CaMeL Id ( new Integer ( user CaMeL Number ) ) ; List < Integer > project CaMeL Codes = new Array CaMeL List < Integer > ( ) ; Person person = Person . read CaMeL Person CaMeL By CaMeL Username ( username ) ; List < Project CaMeL Access > accesses = Project CaMeL Access . get CaMeL All CaMeL By CaMeL Person CaMeL Username ( person ) ; for ( Project CaMeL Access access : accesses ) { Integer key CaMeL Cost CaMeL Center = access . get CaMeL Key CaMeL Project CaMeL Coordinator ( ) ; if ( ! project CaMeL Codes . contains ( key CaMeL Cost CaMeL Center ) ) { project CaMeL Codes . add ( key CaMeL Cost CaMeL Center ) ; } } cost CaMeL Center CaMeL List . add CaMeL All ( p . get CaMeL I CaMeL Persistent CaMeL Project CaMeL User ( ) . get CaMeL In@@ sti@@ t@@ uc@@ i@@ onal CaMeL Project CaMeL By CaMeL C@@ CI CaMeL Ds ( project CaMeL Codes ) ) ; for ( I CaMeL Ru@@ bric cc : cost CaMeL Center CaMeL List ) { info CaMeL Cost CaMeL Center CaMeL List . add ( Info CaMeL Ru@@ bric . new CaMeL Info CaMeL From CaMeL Domain ( cc ) ) ; } return info CaMeL Cost CaMeL Center CaMeL List ; }	List < Project CaMeL Access > accesses = Project CaMeL Access . get CaMeL All CaMeL By CaMeL Person ( person ) ;
Array CaMeL List list = new Array CaMeL List ( ) ; list . add ( content ) ;  <CTX>  public void add ( Element elem ) throws Service CaMeL Exception , Unsupported CaMeL Encoding CaMeL Exception { String email CaMeL Address = elem . get CaMeL Attribute ( Mail CaMeL Service . A _ ADDRESS ) ; String personal CaMeL Name = elem . get CaMeL Attribute ( Mail CaMeL Service . A _ PERSONAL , null ) ; String address CaMeL Type = elem . get CaMeL Attribute ( Mail CaMeL Service . A _ ADDRESS _ TYPE ) ; Internet CaMeL Address addr = new Internet CaMeL Address ( email CaMeL Address , personal CaMeL Name ) ; if ( elem . get CaMeL Attribute CaMeL Bool ( Mail CaMeL Service . A _ ADD _ TO _ AB , false ) ) new CaMeL Contacts . add ( addr ) ; Object content = addrs . get ( address CaMeL Type ) ; if ( content == null ) addrs . put ( address CaMeL Type , addr ) ; else if ( content instanceof List ) ( ( List ) content ) . add ( addr ) ; else { Array CaMeL List list = new Array CaMeL List ( ) ; list . add ( content ) ; list . add ( addr ) ; addrs . put ( address CaMeL Type , list ) ; } }	Array CaMeL List < Internet CaMeL Address > list = new Array CaMeL List < Internet CaMeL Address > ( ) ; list . add ( ( Internet CaMeL Address ) content ) ;
double dbl = Double . value CaMeL Of ( txt CaMeL Scale CaMeL Step . get CaMeL Text ( ) )  <CTX>  public void handle CaMeL Event ( Event event ) { if ( event . widget . equals ( txt CaMeL Scale CaMeL Min ) ) { if ( txt CaMeL Scale CaMeL Min . get CaMeL Text ( ) . length ( ) == 0 ) { get CaMeL Scale ( ) . e CaMeL Unset ( Component CaMeL Package . e CaMeL INSTANCE . get CaMeL Scale _ Min ( ) ) ; } else { Data CaMeL Element de = get CaMeL Typed CaMeL Data CaMeL Element ( txt CaMeL Scale CaMeL Min . get CaMeL Text ( ) ) ; if ( de != null ) { get CaMeL Scale ( ) . set CaMeL Min ( de ) ; } } } else if ( event . widget . equals ( txt CaMeL Scale CaMeL Max ) ) { if ( txt CaMeL Scale CaMeL Max . get CaMeL Text ( ) . length ( ) == 0 ) { get CaMeL Scale ( ) . e CaMeL Unset ( Component CaMeL Package . e CaMeL INSTANCE . get CaMeL Scale _ Max ( ) ) ; } else { Data CaMeL Element de = get CaMeL Typed CaMeL Data CaMeL Element ( txt CaMeL Scale CaMeL Max . get CaMeL Text ( ) ) ; if ( de != null ) { get CaMeL Scale ( ) . set CaMeL Max ( de ) ; } } } else if ( event . widget . equals ( txt CaMeL Scale CaMeL Step ) ) { try { if ( txt CaMeL Scale CaMeL Step . get CaMeL Text ( ) . length ( ) == 0 ) { get CaMeL Scale ( ) . e CaMeL Unset ( Component CaMeL Package . e CaMeL INSTANCE . get CaMeL Scale _ Step ( ) ) ; } else { double dbl = Double . value CaMeL Of ( txt CaMeL Scale CaMeL Step . get CaMeL Text ( ) ) . double CaMeL Value ( ) ; if ( dbl == 0 ) { get CaMeL Scale ( ) . e CaMeL Unset ( Component CaMeL Package . e CaMeL INSTANCE . get CaMeL Scale _ Step ( ) ) ; } else { get CaMeL Scale ( ) . set CaMeL Step ( dbl ) ; } } } catch ( Number CaMeL Format CaMeL Exception e 1 ) { txt CaMeL Scale CaMeL Step . set CaMeL Text ( String . value CaMeL Of ( get CaMeL Scale ( ) . get CaMeL Step ( ) ) ) ; } } else if ( event . widget . equals ( cmb CaMeL Scale CaMeL Unit ) ) { get CaMeL Scale ( ) . set CaMeL Unit ( Scale CaMeL Unit CaMeL Type . get CaMeL By CaMeL Name ( Literal CaMeL Helper . scale CaMeL Unit CaMeL Type CaMeL Set . get CaMeL Name CaMeL By CaMeL Display CaMeL Name ( cmb CaMeL Scale CaMeL Unit . get CaMeL Text ( ) ) ) ) ; } }	double dbl = Double . value CaMeL Of ( txt CaMeL Step CaMeL Size . get CaMeL Text ( ) )
get CaMeL GL ( ) . gl CaMeL Viewport ( 0 , 0 , panel CaMeL Width , panel CaMeL Height ) ; drawable CaMeL Helper . reshape ( GLJ CaMeL Panel . this , 0 , 0 , panel CaMeL Width , panel CaMeL Height ) ; }  <CTX>  public void run ( ) { get CaMeL GL ( ) . gl CaMeL Viewport ( 0 , 0 , panel CaMeL Width , panel CaMeL Height ) ; drawable CaMeL Helper . reshape ( GLJ CaMeL Panel . this , 0 , 0 , panel CaMeL Width , panel CaMeL Height ) ; }	toplevel . set CaMeL Visible ( false ) ; }
if ( category CaMeL Definitions == null ) throw new Null CaMeL Pointer CaMeL Exception ( ) ;  <CTX>  static Map category CaMeL Definitions CaMeL By CaMeL Id ( Collection category CaMeL Definitions , boolean allow CaMeL Null CaMeL Ids ) { if ( category CaMeL Definitions == null ) throw new Null CaMeL Pointer CaMeL Exception ( ) ; Map map = new Hash CaMeL Map ( ) ; Iterator iterator = category CaMeL Definitions . iterator ( ) ; while ( iterator . has CaMeL Next ( ) ) { Object object = iterator . next ( ) ; Util . assert CaMeL Instance ( object , Category CaMeL Definition . class ) ; Category CaMeL Definition category CaMeL Definition = ( Category CaMeL Definition ) object ; String id = category CaMeL Definition . get CaMeL Id ( ) ; if ( allow CaMeL Null CaMeL Ids || id != null ) map . put ( id , category CaMeL Definition ) ; } return map ; }	if ( category CaMeL Definitions == null ) { throw new Null CaMeL Pointer CaMeL Exception ( ) ; }
new CaMeL Src = save CaMeL Chars ( new CaMeL Join , _ off CaMeL Src , _ cch CaMeL Src , null , 0 , 0 ) ;  <CTX>  public Object insert CaMeL Chars ( int pos CaMeL Insert , Object src , int off , int cch , Object src CaMeL Insert , int off CaMeL Insert , int cch CaMeL Insert ) { assert is CaMeL Valid ( src , off , cch ) ; assert is CaMeL Valid ( src CaMeL Insert , off CaMeL Insert , cch CaMeL Insert ) ; assert pos CaMeL Insert >= 0 && pos CaMeL Insert <= cch ; / / TODO - at some point , instead of creating joins , I should / / normalize all the text into a single buffer to stop large / / tree s from being built when many modifications happ@@ en . . . / / TODO - actually , I should see if the size of the new char / / sequence is small enough to simp@@ ly allocate a new conti@@ g@@ ous / / sequence , either in a common char [ ] managed by the master , / / or just create a new string . . . this go@@ es for remove chars / / as well . if ( cch CaMeL Insert == 0 ) { _ cch CaMeL Src = cch ; _ off CaMeL Src = off ; return src ; } if ( cch == 0 ) { _ cch CaMeL Src = cch CaMeL Insert ; _ off CaMeL Src = off CaMeL Insert ; return src CaMeL Insert ; } _ cch CaMeL Src = cch + cch CaMeL Insert ; Object new CaMeL Src ; if ( _ cch CaMeL Src <= MAX _ COPY && can CaMeL Allocate ( _ cch CaMeL Src ) ) { char [ ] chars = allocate ( _ cch CaMeL Src ) ; get CaMeL Chars ( chars , _ off CaMeL Src , src , off , pos CaMeL Insert ) ; get CaMeL Chars ( chars , _ off CaMeL Src + pos CaMeL Insert , src CaMeL Insert , off CaMeL Insert , cch CaMeL Insert ) ; get CaMeL Chars ( chars , _ off CaMeL Src + pos CaMeL Insert + cch CaMeL Insert , src , off + pos CaMeL Insert , cch - pos CaMeL Insert ) ; new CaMeL Src = chars ; } else { _ off CaMeL Src = 0 ; Char CaMeL Join new CaMeL Join ; if ( pos CaMeL Insert == 0 ) new CaMeL Join = new Char CaMeL Join ( src CaMeL Insert , off CaMeL Insert , cch CaMeL Insert , src , off , cch ) ; else if ( pos CaMeL Insert == cch ) new CaMeL Join = new Char CaMeL Join ( src , off , cch , src CaMeL Insert , off CaMeL Insert , cch CaMeL Insert ) ; else { new CaMeL Join = new Char CaMeL Join ( new Char CaMeL Join ( src , off , pos CaMeL Insert , src CaMeL Insert , off CaMeL Insert , cch CaMeL Insert ) , 0 , pos CaMeL Insert + cch CaMeL Insert , src , off + pos CaMeL Insert , cch - pos CaMeL Insert ) ; } if ( new CaMeL Join . _ depth > Char CaMeL Join . MAX _ DEPTH ) new CaMeL Src = save CaMeL Chars ( new CaMeL Join , _ off CaMeL Src , _ cch CaMeL Src , null , 0 , 0 ) ; else new CaMeL Src = new CaMeL Join ; } assert is CaMeL Valid ( new CaMeL Src , _ off CaMeL Src , _ cch CaMeL Src ) ; return new CaMeL Src ; }	new CaMeL Src = save CaMeL Chars ( new CaMeL Join , _ off CaMeL Src , _ cch CaMeL Src ) ;
show ( ) ;  <CTX>  public int show CaMeL Dialog ( ) { pack ( ) ; show ( ) ; return return CaMeL Code ; }	set CaMeL Visible ( true ) ;
return BI CaMeL With CaMeL Alpha . get CaMeL Color CaMeL Model ( ) ;  <CTX>  public Color CaMeL Model get CaMeL Color CaMeL Model ( ) { return BI CaMeL With CaMeL Alpha . get CaMeL Color CaMeL Model ( ) ; }	return BI _ WITH _ ALPHA . get CaMeL Color CaMeL Model ( ) ;
return ( value ) ; }  <CTX>  get CaMeL Header CaMeL Field CaMeL Value CaMeL By CaMeL Index ( int index ) { String value = null ; try { value = ( String ) header CaMeL Field CaMeL Values . element CaMeL At ( index ) ; } catch ( Array CaMeL Index CaMeL Out CaMeL Of CaMeL Bounds CaMeL Exception e ) { } return ( value ) ; }	return value ; }
update CaMeL Object ( column CaMeL Index , new Boolean ( x ) ) ;  <CTX>  public void update CaMeL Boolean ( int column CaMeL Index , boolean x ) throws SQL CaMeL Exception { update CaMeL Object ( column CaMeL Index , new Boolean ( x ) ) ; }	set CaMeL Col CaMeL Value ( column CaMeL Index , Types . BIT , new Boolean ( x ) , 0 ) ;
atts = row CaMeL Attributes ; } else { atts = ( Html CaMeL Attribute CaMeL Map ) this . html CaMeL Attributes . clone ( ) ; atts . put CaMeL All ( cell . get CaMeL Per CaMeL Row CaMeL Attributes ( ) ) ;  <CTX>  public String get CaMeL Open CaMeL Tag ( ) { Html CaMeL Attribute CaMeL Map row CaMeL Attributes = cell . get CaMeL Per CaMeL Row CaMeL Attributes ( ) ; Html CaMeL Attribute CaMeL Map atts ; if ( html CaMeL Attributes == null || row CaMeL Attributes == null ) { atts = row CaMeL Attributes ; } else { atts = ( Html CaMeL Attribute CaMeL Map ) this . html CaMeL Attributes . clone ( ) ; atts . put CaMeL All ( cell . get CaMeL Per CaMeL Row CaMeL Attributes ( ) ) ; } return Html CaMeL Tag CaMeL Util . create CaMeL Open CaMeL Tag CaMeL String ( Tag CaMeL Constants . TAGNAME _ COLUMN , atts ) ; }	atts = ( Html CaMeL Attribute CaMeL Map ) atts . clone ( ) ; atts . put CaMeL All ( row CaMeL Attributes ) ;
if ( method CaMeL Id == CONSTRUCTOR _ ID ) {  <CTX>  public int method CaMeL Arity ( int method CaMeL Id , Id CaMeL Function function ) { if ( method CaMeL Id == CONSTRUCTOR _ ID ) { return 1 ; } return 0 ; }	if ( method CaMeL Id == Id _ constructor ) {
align ( 0 , top CaMeL Controls . length , trim CaMeL Region ) ;  <CTX>  public void layout ( ) { cache . flush ( ) ; Rectangle trim CaMeL Region = get CaMeL Title CaMeL Trim CaMeL Region ( ) ; Point trim CaMeL Size = compute CaMeL Trim CaMeL Size ( ) ; Rectangle bounds = tab CaMeL Folder . get CaMeL Bounds ( ) ; trim CaMeL Start = bounds . width ; Rectangle client CaMeL Bounds = calculate CaMeL Page CaMeL Bounds ( tab CaMeL Folder ) ; trim CaMeL On CaMeL Top = trim CaMeL Size . x <= trim CaMeL Region . width && trim CaMeL Size . y <= trim CaMeL Region . height ; / / Check if we have room for all our top CaMeL Right controls on the top border if ( trim CaMeL On CaMeL Top ) { trim CaMeL Start = trim CaMeL Region . x + trim CaMeL Region . width - trim CaMeL Size . x - bounds . x ; align ( 0 , top CaMeL Controls . length , trim CaMeL Region ) ; center CaMeL Area = client CaMeL Bounds ; return ; } / / Else we need to place the controls below the title Rectangle current CaMeL Rect = new Rectangle ( client CaMeL Bounds . x , client CaMeL Bounds . y , client CaMeL Bounds . width , 0 ) ; int idx = 0 ; while ( idx < top CaMeL Controls . length ) { int start CaMeL Of CaMeL Row = idx ; current CaMeL Rect . height = 0 ; int row CaMeL Width = 0 ; int row CaMeL Count = 0 ; while ( idx + row CaMeL Count < top CaMeL Controls . length ) { Point next CaMeL Size = cache . compute CaMeL Size ( idx + row CaMeL Count , SWT . DEFAULT , SWT . DEFAULT ) ; row CaMeL Width += next CaMeL Size . x ; if ( row CaMeL Width > client CaMeL Bounds . width ) { break ; } current CaMeL Rect . height = Math . max ( current CaMeL Rect . height , next CaMeL Size . y ) ; row CaMeL Count ++ ; } if ( row CaMeL Count > 0 ) { align ( idx , row CaMeL Count , current CaMeL Rect ) ; idx += row CaMeL Count ; } else { Point size = cache . compute CaMeL Size ( idx , client CaMeL Bounds . width , SWT . DEFAULT ) ; current CaMeL Rect . height = size . y ; top CaMeL Controls [ idx ] . set CaMeL Bounds ( current CaMeL Rect ) ; idx ++ ; } current CaMeL Rect . y += current CaMeL Rect . height ; } center CaMeL Area = new Rectangle ( client CaMeL Bounds . x , current CaMeL Rect . y , client CaMeL Bounds . width , client CaMeL Bounds . height + client CaMeL Bounds . y - current CaMeL Rect . y ) ; }	trim CaMeL Start = align ( 0 , top CaMeL Controls . length , trim CaMeL Region , true ) - bounds . x ;
init CaMeL Script CaMeL Function ( cx , scope , idata . language CaMeL Version , idata . its CaMeL Name , idata . arg CaMeL Names , idata . arg CaMeL Count ) ;  <CTX>  private void init CaMeL Interpreted CaMeL Function ( Context cx , Scriptable scope ) { init CaMeL Script CaMeL Function ( cx , scope , idata . language CaMeL Version , idata . its CaMeL Name , idata . arg CaMeL Names , idata . arg CaMeL Count ) ; if ( idata . its CaMeL Reg CaMeL Exp CaMeL Literals != null ) { function CaMeL Reg CaMeL Exps = create CaMeL Reg CaMeL Exp CaMeL Wraps ( cx , scope ) ; } }	init CaMeL Script CaMeL Function ( cx , scope , idata . its CaMeL Name ) ;
Script CaMeL Runtime . set CaMeL Elem ( target , id , value , target ) ;  <CTX>  private static void set CaMeL Elem ( Scriptable target , long index , Object value ) { if ( index > Integer . MAX _ VALUE ) { String id = Long . to CaMeL String ( index ) ; Script CaMeL Runtime . set CaMeL Elem ( target , id , value , target ) ; } else { Script CaMeL Runtime . set CaMeL Elem ( target , ( int ) index , value ) ; } }	Script CaMeL Runtime . set CaMeL Str CaMeL Id CaMeL Elem ( target , id , value , target ) ;
message CaMeL Area . update CaMeL Text ( get CaMeL Shor@@ tened CaMeL String ( message ) , message CaMeL Type ) ;  <CTX>  public void update CaMeL Message ( ) { String message = null ; String error CaMeL Message = null ; if ( current CaMeL Page != null ) { message = current CaMeL Page . get CaMeL Message ( ) ; error CaMeL Message = current CaMeL Page . get CaMeL Error CaMeL Message ( ) ; } int message CaMeL Type = I CaMeL Message CaMeL Provider . NONE ; if ( message != null && current CaMeL Page instanceof I CaMeL Message CaMeL Provider ) message CaMeL Type = ( ( I CaMeL Message CaMeL Provider ) current CaMeL Page ) . get CaMeL Message CaMeL Type ( ) ; if ( error CaMeL Message != null ) { message = error CaMeL Message ; message CaMeL Type = I CaMeL Message CaMeL Provider . ERROR ; if ( ! showing CaMeL Error ) { / / we were not previously showing an error showing CaMeL Error = true ; title CaMeL Image . set CaMeL Image ( null ) ; title CaMeL Image . set CaMeL Background ( J CaMeL Face CaMeL Colors . get CaMeL Error CaMeL Background ( title CaMeL Image . get CaMeL Display ( ) ) ) ; title CaMeL Image . set CaMeL Size ( 0 , 0 ) ; title CaMeL Image . get CaMeL Parent ( ) . layout ( ) ; } } else { if ( showing CaMeL Error ) { / / we were previously showing an error showing CaMeL Error = false ; title CaMeL Image . set CaMeL Image ( J CaMeL Face CaMeL Resources . get CaMeL Image ( PREF _ DLG _ TITLE _ IMG ) ) ; title CaMeL Image . compute CaMeL Size ( SWT . NULL , SWT . NULL ) ; title CaMeL Image . get CaMeL Parent ( ) . layout ( ) ; } } message CaMeL Area . update CaMeL Text ( get CaMeL Shor@@ tened CaMeL String ( message ) , message CaMeL Type ) ; }	message CaMeL Area . update CaMeL Text ( get CaMeL Shor@@ tened CaMeL String ( message , title CaMeL Area ) , message CaMeL Type ) ;
write ( buf , 0 , buf . length ) ;  <CTX>  public synchronized void write ( byte [ ] buf ) throws IO CaMeL Exception { write ( buf , 0 , buf . length ) ; }	super . write ( bval ) ; crc . update ( bval ) ;
if ( peers == 0 || conns == 0 || ( peers - conns ) > MAX _ DIS@@ CONN _ PEER _ ALERT _ THRESHOLD || conns > MAX _ CONN _ ALERT _ THRESHOLD || peers > MAX _ PEER _ ALERT _ THRESHOLD || ( n . b@@ w@@ limit CaMeL Delay CaMeL Alert CaMeL Relevant && b@@ w@@ limit CaMeL Delay CaMeL Time > Node . MAX _ B@@ W@@ LIMIT _ DELAY _ TIME _ ALERT _ THRESHOLD ) || ( n . node CaMeL Average CaMeL Ping CaMeL Alert CaMeL Relevant && node CaMeL Average CaMeL Ping CaMeL Time > Node . MAX _ NODE _ AVERAGE _ PING _ TIME _ ALERT _ THRESHOLD ) )  <CTX>  public short get CaMeL Priority CaMeL Class ( ) { if ( peers == 0 || conns == 0 || ( peers - conns ) > MAX _ DIS@@ CONN _ PEER _ ALERT _ THRESHOLD || conns > MAX _ CONN _ ALERT _ THRESHOLD || peers > MAX _ PEER _ ALERT _ THRESHOLD || ( n . b@@ w@@ limit CaMeL Delay CaMeL Alert CaMeL Relevant && b@@ w@@ limit CaMeL Delay CaMeL Time > Node . MAX _ B@@ W@@ LIMIT _ DELAY _ TIME _ ALERT _ THRESHOLD ) || ( n . node CaMeL Average CaMeL Ping CaMeL Alert CaMeL Relevant && node CaMeL Average CaMeL Ping CaMeL Time > Node . MAX _ NODE _ AVERAGE _ PING _ TIME _ ALERT _ THRESHOLD ) ) return User CaMeL Alert . CRITICAL _ ERROR ; return User CaMeL Alert . ERROR ; }	if ( ( peers == 0 ) || ( conns == 0 ) || ( ( peers - conns ) > MAX _ DIS@@ CONN _ PEER _ ALERT _ THRESHOLD ) || ( conns > MAX _ CONN _ ALERT _ THRESHOLD ) || ( peers > MAX _ PEER _ ALERT _ THRESHOLD ) || ( n . b@@ w@@ limit CaMeL Delay CaMeL Alert CaMeL Relevant && ( b@@ w@@ limit CaMeL Delay CaMeL Time > Node . MAX _ B@@ W@@ LIMIT _ DELAY _ TIME _ ALERT _ THRESHOLD ) ) || ( n . node CaMeL Average CaMeL Ping CaMeL Alert CaMeL Relevant && ( node CaMeL Average CaMeL Ping CaMeL Time > Node . MAX _ NODE _ AVERAGE _ PING _ TIME _ ALERT _ THRESHOLD ) ) )
index = i ;  <CTX>  public OPT _ String CaMeL Constant CaMeL Operand ( String v , int i ) { value = v ; index = i ; }	offset = i ;
return null ;  <CTX>  public Portlet CaMeL Mode get CaMeL Portlet CaMeL Mode ( ) { return null ; / / TODO }	if ( native CaMeL Request != null ) return native CaMeL Request . get CaMeL Portlet CaMeL Mode ( ) ; else return null ;
= CSS CaMeL Utilities . convert CaMeL Stroke CaMeL And CaMeL Fill ( svg CaMeL Element , ctx , css CaMeL Decl , uctx ) ;  <CTX>  public Graphics CaMeL Node create CaMeL Graphics CaMeL Node ( Bridge CaMeL Context ctx , Element element ) { SVG CaMeL Element svg CaMeL Element = ( SVG CaMeL Element ) element ; CSS CaMeL Style CaMeL Declaration css CaMeL Decl = ctx . get CaMeL View CaMeL CSS ( ) . get CaMeL Computed CaMeL Style ( element , null ) ; Unit CaMeL Processor . Context uctx = new Default CaMeL Unit CaMeL Processor CaMeL Context ( ctx , css CaMeL Decl ) ; Shape CaMeL Node node = ctx . get CaMeL GVT CaMeL Factory ( ) . create CaMeL Shape CaMeL Node ( ) ; / / Initialize the shape of the Shape CaMeL Node node . set CaMeL Shape ( create CaMeL Shape ( ctx , svg CaMeL Element , css CaMeL Decl , uctx ) ) ; / / Initialize the style properties Shape CaMeL Painter painter = CSS CaMeL Utilities . convert CaMeL Stroke CaMeL And CaMeL Fill ( svg CaMeL Element , ctx , css CaMeL Decl , uctx ) ; node . set CaMeL Shape CaMeL Painter ( painter ) ; / / Initialize the transform Affine CaMeL Transform at = AWT CaMeL Transform CaMeL Producer . create CaMeL Affine CaMeL Transform ( new String CaMeL Reader ( element . get CaMeL Attribute CaMeL NS ( null , ATTR _ TRANSFORM ) ) , ctx . get CaMeL Parser CaMeL Factory ( ) ) ; node . set CaMeL Transform ( at ) ; / / Set node composite CSS CaMeL Primitive CaMeL Value opacity CaMeL Val = ( CSS CaMeL Primitive CaMeL Value ) css CaMeL Decl . get CaMeL Property CaMeL CSS CaMeL Value ( ATTR _ OPACITY ) ; Composite composite = CSS CaMeL Utilities . convert CaMeL Opacity CaMeL To CaMeL Composite ( opacity CaMeL Val ) ; node . set CaMeL Composite ( composite ) ; / / Set node filter Filter filter = CSS CaMeL Utilities . convert CaMeL Filter ( element , node , ctx ) ; node . set CaMeL Filter ( filter ) ; Mask mask = CSS CaMeL Utilities . convert CaMeL Mask ( element , node , ctx ) ; node . set CaMeL Mask ( mask ) ; Shape clip = CSS CaMeL Utilities . convert CaMeL Clip CaMeL Path ( element , node , ctx ) ; node . set CaMeL Clipping CaMeL Area ( clip ) ; / / < ! > TODO only when binding is enabled Bridge CaMeL Event CaMeL Support . add CaMeL DOM CaMeL Listener ( ctx , element ) ; ctx . bind ( element , node ) ; return node ; }	= CSS CaMeL Utilities . convert CaMeL Stroke CaMeL And CaMeL Fill ( svg CaMeL Element , node , ctx , css CaMeL Decl , uctx ) ;
if ( caret == s . start )  <CTX>  public void go CaMeL To CaMeL Next CaMeL Character ( boolean select ) { Selection s = get CaMeL Selection CaMeL At CaMeL Offset ( caret ) ; if ( ! select && s instanceof Selection . Range ) { if ( multi ) { if ( caret != s . end ) { move CaMeL Caret CaMeL Position ( s . end ) ; return ; } } else { set CaMeL Caret CaMeL Position ( s . end ) ; return ; } } int extra CaMeL Start CaMeL Virt , extra CaMeL End CaMeL Virt ; if ( s instanceof Selection . Rect ) { extra CaMeL Start CaMeL Virt = ( ( Selection . Rect ) s ) . extra CaMeL Start CaMeL Virt ; extra CaMeL End CaMeL Virt = ( ( Selection . Rect ) s ) . extra CaMeL End CaMeL Virt ; } else { extra CaMeL Start CaMeL Virt = 0 ; extra CaMeL End CaMeL Virt = 0 ; } int new CaMeL Caret = caret ; if ( select && caret == buffer . get CaMeL Length ( ) ) { if ( rectangular CaMeL Selection CaMeL Mode || s instanceof Selection . Rect ) { if ( caret == s . start ) extra CaMeL Start CaMeL Virt ++ ; else extra CaMeL End CaMeL Virt ++ ; } else { get CaMeL Toolkit ( ) . beep ( ) ; return ; } } else if ( caret == get CaMeL Line CaMeL End CaMeL Offset ( caret CaMeL Line ) - 1 ) { if ( rectangular CaMeL Selection CaMeL Mode || s instanceof Selection . Rect ) { if ( caret == s . start ) extra CaMeL Start CaMeL Virt ++ ; else extra CaMeL End CaMeL Virt ++ ; } else { int line = display CaMeL Manager . get CaMeL Next CaMeL Visible CaMeL Line ( caret CaMeL Line ) ; if ( line == - 1 ) { get CaMeL Toolkit ( ) . beep ( ) ; return ; } else new CaMeL Caret = get CaMeL Line CaMeL Start CaMeL Offset ( line ) ; } } else new CaMeL Caret = caret + 1 ; if ( select ) extend CaMeL Selection ( caret , new CaMeL Caret , extra CaMeL Start CaMeL Virt , extra CaMeL End CaMeL Virt ) ; else if ( ! multi ) select CaMeL None ( ) ; move CaMeL Caret CaMeL Position ( new CaMeL Caret ) ; } / / } } }	if ( s != null && caret == s . start )
Observable CaMeL Tracker . getter CaMeL Called ( this ) ;  <CTX>  public Object remove ( Object key ) { Observable CaMeL Tracker . getter CaMeL Called ( this ) ; Object result = wrapped CaMeL Map . remove ( key ) ; if ( result != null ) { fire CaMeL Map CaMeL Change ( Diffs . create CaMeL Map CaMeL Diff CaMeL Single CaMeL Remove ( key , result ) ) ; } return result ; }	check CaMeL Realm ( ) ;
repository = My@@ lar CaMeL Task CaMeL List CaMeL Plugin . get CaMeL Repository CaMeL Manager ( ) . get CaMeL Repository ( Bug@@ zilla CaMeL Plugin . REPOSITORY _ KIND , bug . get CaMeL Server ( ) ) ;  <CTX>  public Existing CaMeL Bug CaMeL Editor CaMeL Input ( Bug CaMeL Report bug ) { this . bug = bug ; this . bug CaMeL Id = bug . get CaMeL Id ( ) ; repository = My@@ lar CaMeL Task CaMeL List CaMeL Plugin . get CaMeL Repository CaMeL Manager ( ) . get CaMeL Repository ( Bug@@ zilla CaMeL Plugin . REPOSITORY _ KIND , bug . get CaMeL Server ( ) ) ; }	repository = My@@ lar CaMeL Task CaMeL List CaMeL Plugin . get CaMeL Repository CaMeL Manager ( ) . get CaMeL Repository ( Bug@@ zilla CaMeL Plugin . REPOSITORY _ KIND , bug . get CaMeL Repository ( ) ) ;
Account acct CaMeL Target = Provisioning . get CaMeL Instance ( ) . get CaMeL Account CaMeL By CaMeL Id ( m CaMeL Account CaMeL Id ) ;  <CTX>  public boolean is CaMeL Local ( ) throws Service CaMeL Exception { if ( m CaMeL Account CaMeL Id == null ) return true ; Account acct CaMeL Target = Provisioning . get CaMeL Instance ( ) . get CaMeL Account CaMeL By CaMeL Id ( m CaMeL Account CaMeL Id ) ; if ( acct CaMeL Target == null ) throw Account CaMeL Service CaMeL Exception . NO _ SUCH _ ACCOUNT ( m CaMeL Account CaMeL Id ) ; return Document CaMeL Handler . LOCAL _ HOST . equals CaMeL Ignore CaMeL Case ( acct CaMeL Target . get CaMeL Attr ( Provisioning . A _ z@@ im@@ bra CaMeL Mail CaMeL Host ) ) ; }	Account acct CaMeL Target = Provisioning . get CaMeL Instance ( ) . get ( Account CaMeL By . ID , m CaMeL Account CaMeL Id ) ;
if ( style . has CaMeL Property ( CSS CaMeL Name . RIGHT ) ) {  <CTX>  public static void setup CaMeL Fixed ( Context c , Box box ) { if ( c . get CaMeL Current CaMeL Style ( ) . is CaMeL Ident ( CSS CaMeL Name . POSITION , Ident CaMeL Value . FIXED ) ) { box . fixed = true ; box . set CaMeL Children CaMeL Ex@@ ceed CaMeL Bounds ( true ) ; Rectangle rect = c . get CaMeL Fixed CaMeL Rectangle ( ) ; Calculated CaMeL Style style = c . get CaMeL Current CaMeL Style ( ) ; if ( style . has CaMeL Property ( CSS CaMeL Name . TOP ) ) { box . top = ( int ) style . get CaMeL Float CaMeL Property CaMeL Proportional CaMeL Height ( CSS CaMeL Name . TOP , ( float ) ( rect . get CaMeL Height ( ) ) , c . get CaMeL Ctx ( ) ) ; box . top _ set = true ; } if ( style . has CaMeL Property ( CSS CaMeL Name . RIGHT ) ) { box . right = ( int ) style . get CaMeL Float CaMeL Property CaMeL Proportional CaMeL Width ( CSS CaMeL Name . RIGHT , ( float ) ( rect . get CaMeL Width ( ) ) , c . get CaMeL Ctx ( ) ) ; box . right _ set = true ; } if ( style . has CaMeL Property ( CSS CaMeL Name . BOTTOM ) ) { box . bottom = ( int ) style . get CaMeL Float CaMeL Property CaMeL Proportional CaMeL Height ( CSS CaMeL Name . BOTTOM , ( float ) ( rect . get CaMeL Height ( ) ) , c . get CaMeL Ctx ( ) ) ; box . bottom _ set = true ; } if ( style . has CaMeL Property ( CSS CaMeL Name . LEFT ) ) { box . left = ( int ) style . get CaMeL Float CaMeL Property CaMeL Proportional CaMeL Width ( CSS CaMeL Name . LEFT , ( float ) ( rect . get CaMeL Width ( ) ) , c . get CaMeL Ctx ( ) ) ; box . left _ set = true ; } } }	if ( ! style . is CaMeL Ident ( CSS CaMeL Name . RIGHT , Ident CaMeL Value . AUTO ) ) {
if ( resource CaMeL Path . is CaMeL Prefix CaMeL Of ( element CaMeL Path ) ) return true ; if ( element CaMeL Path . is CaMeL Prefix CaMeL Of ( resource CaMeL Path ) ) return true ;  <CTX>  private boolean is CaMeL Enclosed CaMeL Resource ( I CaMeL Resource element , I CaMeL Path element CaMeL Path , I CaMeL Adaptable working CaMeL Set CaMeL Element ) { I CaMeL Resource working CaMeL Set CaMeL Resource = null ; if ( working CaMeL Set CaMeL Element . equals ( element ) ) return true ; if ( working CaMeL Set CaMeL Element instanceof I CaMeL Resource ) { working CaMeL Set CaMeL Resource = ( I CaMeL Resource ) working CaMeL Set CaMeL Element ; } else { working CaMeL Set CaMeL Resource = ( I CaMeL Resource ) working CaMeL Set CaMeL Element . get CaMeL Adapter ( I CaMeL Resource . class ) ; } if ( working CaMeL Set CaMeL Resource != null ) { I CaMeL Path resource CaMeL Path = working CaMeL Set CaMeL Resource . get CaMeL Full CaMeL Path ( ) ; if ( resource CaMeL Path . is CaMeL Prefix CaMeL Of ( element CaMeL Path ) ) return true ; if ( element CaMeL Path . is CaMeL Prefix CaMeL Of ( resource CaMeL Path ) ) return true ; } return false ; }	if ( resource CaMeL Path . is CaMeL Prefix CaMeL Of ( element CaMeL Path ) ) { return true ; } if ( element CaMeL Path . is CaMeL Prefix CaMeL Of ( resource CaMeL Path ) ) { return true ; }
Component [ ] list = get CaMeL Components ( ) ; if ( ( list != null ) && ( list . length > 0 ) ) { Dimension dim = list [ 0 ] . get CaMeL Preferred CaMeL Size ( ) ; Dimension vp = get CaMeL Viewport CaMeL Size ( ) ; if ( dim . width < vp . width ) dim . width = vp . width ; if ( dim . height < vp . height ) dim . height = vp . height ; Scroll CaMeL Pane CaMeL Peer peer = ( Scroll CaMeL Pane CaMeL Peer ) get CaMeL Peer ( ) ; if ( peer != null ) peer . child CaMeL Resized ( dim . width , dim . height ) ; list [ 0 ] . resize ( dim ) ; Point p = get CaMeL Scroll CaMeL Position ( ) ; if ( p . x > dim . width ) p . x = dim . width ; if ( p . y > dim . height ) p . y = dim . height ; set CaMeL Scroll CaMeL Position ( p ) ; }  <CTX>  do CaMeL Layout ( ) { Component [ ] list = get CaMeL Components ( ) ; if ( ( list != null ) && ( list . length > 0 ) ) { Dimension dim = list [ 0 ] . get CaMeL Preferred CaMeL Size ( ) ; Dimension vp = get CaMeL Viewport CaMeL Size ( ) ; if ( dim . width < vp . width ) dim . width = vp . width ; if ( dim . height < vp . height ) dim . height = vp . height ; Scroll CaMeL Pane CaMeL Peer peer = ( Scroll CaMeL Pane CaMeL Peer ) get CaMeL Peer ( ) ; if ( peer != null ) peer . child CaMeL Resized ( dim . width , dim . height ) ; list [ 0 ] . resize ( dim ) ; Point p = get CaMeL Scroll CaMeL Position ( ) ; if ( p . x > dim . width ) p . x = dim . width ; if ( p . y > dim . height ) p . y = dim . height ; set CaMeL Scroll CaMeL Position ( p ) ; } }	layout ( ) ;
void add CaMeL Query ( I CaMeL Task CaMeL Query query ) {  <CTX>  void add CaMeL Query ( I CaMeL Task CaMeL Query query ) { queries . add ( query ) ; }	void add CaMeL Query ( I CaMeL Repository CaMeL Query query ) {
De@@ ap cache CaMeL Parent = cache CaMeL Path [ cache CaMeL Index - 1 ] ;  <CTX>  private void insert CaMeL Parent CaMeL To CaMeL Cache ( De@@ ap de@@ ap ) { if ( is CaMeL Root ( de@@ ap ) ) return ; int cache CaMeL Index = de@@ ap . get CaMeL Cache CaMeL Index ( ) ; int parent CaMeL Index = parent CaMeL Index ( de@@ ap ) ; / / check , if parent of de@@ ap is in cache CaMeL Path De@@ ap cache CaMeL Parent = cache CaMeL Path [ cache CaMeL Index - 1 ] ; / / parent is in cache CaMeL Path -> ok ! / / else : write cache CaMeL Parent to disk and insert parent into cache CaMeL Path if ( cache CaMeL Parent . get CaMeL Index ( ) != parent CaMeL Index ) { cache CaMeL Parent . set CaMeL Cache CaMeL Index ( - 1 ) ; file . write ( cache CaMeL Parent ) ; De@@ ap parent = file . read ( parent CaMeL Index ) ; cache CaMeL Path [ cache CaMeL Index - 1 ] = parent ; parent . set CaMeL Cache CaMeL Index ( cache CaMeL Index - 1 ) ; / / recursive method call for parent insert CaMeL Parent CaMeL To CaMeL Cache ( parent ) ; } }	De@@ ap < K , V > cache CaMeL Parent = cache CaMeL Path [ cache CaMeL Index - 1 ] ;
void forward ( String call CaMeL Session CaMeL ID , String extension ) throws Phone CaMeL Exception ;  <CTX>  void forward ( String call CaMeL Session CaMeL ID , String extension ) throws Phone CaMeL Exception ;	void forward ( String call CaMeL Session CaMeL ID , String username , String extension ) throws Phone CaMeL Exception ;
return id CaMeL References ;  <CTX>  public ID CaMeL References get CaMeL ID CaMeL References ( ) { return id CaMeL References ; }	return stream CaMeL Renderer . get CaMeL ID CaMeL References ( ) ;
jars CaMeL To CaMeL Be CaMeL Deleted . put ( jar CaMeL File . get CaMeL File CaMeL Name ( ) , jar CaMeL File ) ;  <CTX>  private void delete CaMeL Jar ( ) { jar CaMeL Changed = true ; if ( jar CaMeL Viewer . get CaMeL Table ( ) . get CaMeL Selection CaMeL Index ( ) >= 0 && jar CaMeL Viewer . get CaMeL Table ( ) . get CaMeL Selection CaMeL Index ( ) < jar CaMeL Viewer . get CaMeL Table ( ) . get CaMeL Item CaMeL Count ( ) ) { int idx = jar CaMeL Viewer . get CaMeL Table ( ) . get CaMeL Selection CaMeL Index ( ) ; Map . Entry fn = ( Map . Entry ) jar CaMeL Viewer . get CaMeL Table ( ) . get CaMeL Selection ( ) [ 0 ] . get CaMeL Data ( ) ; Jar CaMeL File jar CaMeL File = ( Jar CaMeL File ) fn . get CaMeL Value ( ) ; jar CaMeL File . set CaMeL To CaMeL Be CaMeL Deleted ( true ) ; if ( jars CaMeL To CaMeL Be CaMeL Copied . contains CaMeL Key ( jar CaMeL File . get CaMeL File CaMeL Name ( ) ) ) { jars CaMeL To CaMeL Be CaMeL Copied . remove ( jar CaMeL File . get CaMeL File CaMeL Name ( ) ) ; } else { jars CaMeL To CaMeL Be CaMeL Deleted . put ( jar CaMeL File . get CaMeL File CaMeL Name ( ) , jar CaMeL File ) ; } jars CaMeL To CaMeL Be CaMeL Deleted CaMeL Runtime . put ( jar CaMeL File . get CaMeL File CaMeL Name ( ) , jar CaMeL File ) ; jar CaMeL Map . remove ( fn . get CaMeL Key ( ) ) ; jar CaMeL Viewer . get CaMeL Table ( ) . remove ( idx ) ; jar CaMeL Viewer . refresh ( ) ; if ( idx >= jar CaMeL Viewer . get CaMeL Table ( ) . get CaMeL Item CaMeL Count ( ) ) { idx -- ; } jar CaMeL Viewer . get CaMeL Table ( ) . select ( idx ) ; refresh CaMeL Jar CaMeL Viewer ( ) ; update CaMeL Jar CaMeL Buttons ( ) ; } }	if ( jar CaMeL File . get CaMeL State ( ) != Jar CaMeL File . ODA _ FILE _ NOT _ EXIST _ TOKEN ) jars CaMeL To CaMeL Be CaMeL Deleted . put ( jar CaMeL File . get CaMeL File CaMeL Name ( ) , jar CaMeL File ) ;
type CaMeL Expected = new java . lang . String ( u ) ;  <CTX>  public Wrong CaMeL Type ( java . lang . String name , int n , java . lang . String u ) { procname = new java . lang . String ( name ) ; number = n ; type CaMeL Expected = new java . lang . String ( u ) ; }	type CaMeL Expected = u ;
handle CaMeL Start CaMeL Element ( element , attributes , false ) ;  <CTX>  public void start CaMeL Element ( Q CaMeL Name element , XML CaMeL Attributes attributes ) throws XNI CaMeL Exception { handle CaMeL Start CaMeL Element ( element , attributes , false ) ; } / / start CaMeL Element ( Q CaMeL Name , XML CaMeL Attributes )	handle CaMeL Start CaMeL Element ( element , attributes ) ; if ( f CaMeL Document CaMeL Handler != null ) { f CaMeL Document CaMeL Handler . start CaMeL Element ( element , attributes , augs ) ; }
if ( o == this ) return true ;  <CTX>  public boolean equals ( Object o ) { if ( ! ( o instanceof Marker CaMeL Query CaMeL Result ) ) return false ; if ( o == this ) return true ; Marker CaMeL Query CaMeL Result m@@ qr = ( Marker CaMeL Query CaMeL Result ) o ; if ( values . length != m@@ qr . values . length ) return false ; for ( int i = 0 ; i < values . length ; i ++ ) { if ( ! ( values [ i ] . equals ( m@@ qr . values [ i ] ) ) ) return false ; } return true ; }	if ( o == this ) { return true ; }
if ( next CaMeL Value CaMeL Pair . ends CaMeL With ( P _ TRUE ) ) enabled CaMeL Ids . add ( id ) ; else disabled CaMeL Ids . add ( id ) ;  <CTX>  public void apply CaMeL Decorators CaMeL Preference ( ) { String preference CaMeL Value = Workbench CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Preference CaMeL Store ( ) . get CaMeL String ( I CaMeL Preference CaMeL Constants . ENABLED _ DECOR@@ ATORS ) ; String CaMeL Tokenizer tokenizer = new String CaMeL Tokenizer ( preference CaMeL Value , PREFERENCE _ SEPARATOR ) ; Set enabled CaMeL Ids = new Hash CaMeL Set ( ) ; Set disabled CaMeL Ids = new Hash CaMeL Set ( ) ; while ( tokenizer . has CaMeL More CaMeL Tokens ( ) ) { String next CaMeL Value CaMeL Pair = tokenizer . next CaMeL Token ( ) ; / / Strip out the true or false to get the id String id = next CaMeL Value CaMeL Pair . substring ( 0 , next CaMeL Value CaMeL Pair . index CaMeL Of ( VALUE _ SEPARATOR ) ) ; if ( next CaMeL Value CaMeL Pair . ends CaMeL With ( P _ TRUE ) ) enabled CaMeL Ids . add ( id ) ; else disabled CaMeL Ids . add ( id ) ; } Full CaMeL Decorator CaMeL Definition [ ] full = get CaMeL Full CaMeL Definitions ( ) ; for ( int i = 0 ; i < full . length ; i ++ ) { String id = full [ i ] . get CaMeL Id ( ) ; if ( enabled CaMeL Ids . contains ( id ) ) full [ i ] . set CaMeL Enabled ( true ) ; else { if ( disabled CaMeL Ids . contains ( id ) ) full [ i ] . set CaMeL Enabled ( false ) ; } } Lightweight CaMeL Decorator CaMeL Definition [ ] lightweight CaMeL Definitions = get CaMeL Lightweight CaMeL Manager ( ) . get CaMeL Definitions ( ) ; for ( int i = 0 ; i < lightweight CaMeL Definitions . length ; i ++ ) { String id = lightweight CaMeL Definitions [ i ] . get CaMeL Id ( ) ; if ( enabled CaMeL Ids . contains ( id ) ) lightweight CaMeL Definitions [ i ] . set CaMeL Enabled ( true ) ; else { if ( disabled CaMeL Ids . contains ( id ) ) lightweight CaMeL Definitions [ i ] . set CaMeL Enabled ( false ) ; } } }	if ( next CaMeL Value CaMeL Pair . ends CaMeL With ( P _ TRUE ) ) { enabled CaMeL Ids . add ( id ) ; } else { disabled CaMeL Ids . add ( id ) ; }
Container CaMeL Event ce = new Container CaMeL Event ( this , Container CaMeL Event . COMPONENT _ REMOVED , r ) ; get CaMeL Toolkit ( ) . get CaMeL System CaMeL Event CaMeL Queue ( ) . post CaMeL Event ( ce ) ;  <CTX>  public void remove ( int index ) { Component r = component [ index ] ; r . remove CaMeL Notify ( ) ; System . arraycopy ( component , index + 1 , component , index , ncomponents - index - 1 ) ; component [ -- ncomponents ] = null ; invalidate ( ) ; if ( layout CaMeL Mgr != null ) layout CaMeL Mgr . remove CaMeL Layout CaMeL Component ( r ) ; / / Post event to notify of adding the container . Container CaMeL Event ce = new Container CaMeL Event ( this , Container CaMeL Event . COMPONENT _ REMOVED , r ) ; get CaMeL Toolkit ( ) . get CaMeL System CaMeL Event CaMeL Queue ( ) . post CaMeL Event ( ce ) ; }	Container CaMeL Event ce = new Container CaMeL Event ( this , Container CaMeL Event . COMPONENT _ REMOVED , r ) ; get CaMeL Toolkit ( ) . get CaMeL System CaMeL Event CaMeL Queue ( ) . post CaMeL Event ( ce ) ; }
I CaMeL Tool CaMeL Bar CaMeL Manager help CaMeL Tool CaMeL Bar = new Tool CaMeL Bar CaMeL Manager ( cool CaMeL Bar . get CaMeL Style ( ) ) ;  <CTX>  protected void fill CaMeL Cool CaMeL Bar ( I CaMeL Cool CaMeL Bar CaMeL Manager cool CaMeL Bar ) { { / / Set up the context Menu I CaMeL Menu CaMeL Manager pop CaMeL Up CaMeL Menu = new Menu CaMeL Manager ( ) ; pop CaMeL Up CaMeL Menu . add ( new Action CaMeL Contribution CaMeL Item ( lock CaMeL Tool CaMeL Bar CaMeL Action ) ) ; pop CaMeL Up CaMeL Menu . add ( new Action CaMeL Contribution CaMeL Item ( edit CaMeL Action CaMeL Set CaMeL Action ) ) ; cool CaMeL Bar . set CaMeL Context CaMeL Menu CaMeL Manager ( pop CaMeL Up CaMeL Menu ) ; } cool CaMeL Bar . add ( new Group CaMeL Marker ( I@@ IDE CaMeL Action CaMeL Constants . GROUP _ FILE ) ) ; { / / File Group I CaMeL Tool CaMeL Bar CaMeL Manager file CaMeL Tool CaMeL Bar = new Tool CaMeL Bar CaMeL Manager ( cool CaMeL Bar . get CaMeL Style ( ) ) ; file CaMeL Tool CaMeL Bar . add ( new Separator ( I CaMeL Workbench CaMeL Action CaMeL Constants . NEW _ GROUP ) ) ; file CaMeL Tool CaMeL Bar . add ( new CaMeL Wizard CaMeL Drop CaMeL Down CaMeL Action ) ; file CaMeL Tool CaMeL Bar . add ( new Group CaMeL Marker ( I CaMeL Workbench CaMeL Action CaMeL Constants . NEW _ EXT ) ) ; file CaMeL Tool CaMeL Bar . add ( new Group CaMeL Marker ( I CaMeL Workbench CaMeL Action CaMeL Constants . SAVE _ GROUP ) ) ; file CaMeL Tool CaMeL Bar . add ( save CaMeL Action ) ; file CaMeL Tool CaMeL Bar . add ( new Group CaMeL Marker ( I CaMeL Workbench CaMeL Action CaMeL Constants . SAVE _ EXT ) ) ; file CaMeL Tool CaMeL Bar . add ( print CaMeL Action ) ; file CaMeL Tool CaMeL Bar . add ( new Group CaMeL Marker ( I CaMeL Workbench CaMeL Action CaMeL Constants . PRINT _ EXT ) ) ; file CaMeL Tool CaMeL Bar . add ( new Separator ( I CaMeL Workbench CaMeL Action CaMeL Constants . BUILD _ GROUP ) ) ; file CaMeL Tool CaMeL Bar . add ( new Group CaMeL Marker ( I CaMeL Workbench CaMeL Action CaMeL Constants . BUILD _ EXT ) ) ; file CaMeL Tool CaMeL Bar . add ( new Separator ( I CaMeL Workbench CaMeL Action CaMeL Constants . MB _ ADDITIONS ) ) ; / / Add to the cool bar manager cool CaMeL Bar . add ( new Tool CaMeL Bar CaMeL Contribution CaMeL Item ( file CaMeL Tool CaMeL Bar , I CaMeL Workbench CaMeL Action CaMeL Constants . TOOLBAR _ FILE ) ) ; } cool CaMeL Bar . add ( new Group CaMeL Marker ( I CaMeL Workbench CaMeL Action CaMeL Constants . MB _ ADDITIONS ) ) ; cool CaMeL Bar . add ( new Group CaMeL Marker ( I@@ IDE CaMeL Action CaMeL Constants . GROUP _ NAV ) ) ; { / / Navigate group I CaMeL Tool CaMeL Bar CaMeL Manager nav CaMeL Tool CaMeL Bar = new Tool CaMeL Bar CaMeL Manager ( cool CaMeL Bar . get CaMeL Style ( ) ) ; nav CaMeL Tool CaMeL Bar . add ( new Separator ( I CaMeL Workbench CaMeL Action CaMeL Constants . HISTORY _ GROUP ) ) ; nav CaMeL Tool CaMeL Bar . add ( new Group CaMeL Marker ( I CaMeL Workbench CaMeL Action CaMeL Constants . GROUP _ APP ) ) ; nav CaMeL Tool CaMeL Bar . add ( backward CaMeL History CaMeL Action ) ; nav CaMeL Tool CaMeL Bar . add ( forward CaMeL History CaMeL Action ) ; nav CaMeL Tool CaMeL Bar . add ( new Separator ( I CaMeL Workbench CaMeL Action CaMeL Constants . PIN _ GROUP ) ) ; nav CaMeL Tool CaMeL Bar . add ( pin CaMeL Editor CaMeL Contribution CaMeL Item ) ; / / Add to the cool bar manager cool CaMeL Bar . add ( new Tool CaMeL Bar CaMeL Contribution CaMeL Item ( nav CaMeL Tool CaMeL Bar , I CaMeL Workbench CaMeL Action CaMeL Constants . TOOLBAR _ NAVIGATE ) ) ; } cool CaMeL Bar . add ( new Group CaMeL Marker ( I CaMeL Workbench CaMeL Action CaMeL Constants . GROUP _ EDITOR ) ) ; cool CaMeL Bar . add ( new Group CaMeL Marker ( I CaMeL Workbench CaMeL Action CaMeL Constants . GROUP _ HELP ) ) ; { / / Help group I CaMeL Tool CaMeL Bar CaMeL Manager help CaMeL Tool CaMeL Bar = new Tool CaMeL Bar CaMeL Manager ( cool CaMeL Bar . get CaMeL Style ( ) ) ; help CaMeL Tool CaMeL Bar . add ( new Separator ( I CaMeL Workbench CaMeL Action CaMeL Constants . GROUP _ HELP ) ) ; / / help CaMeL Tool CaMeL Bar . add ( search CaMeL Combo CaMeL Item ) ; / / Add the group for applications to contribute help CaMeL Tool CaMeL Bar . add ( new Group CaMeL Marker ( I CaMeL Workbench CaMeL Action CaMeL Constants . GROUP _ APP ) ) ; / / Add to the cool bar manager cool CaMeL Bar . add ( new Tool CaMeL Bar CaMeL Contribution CaMeL Item ( help CaMeL Tool CaMeL Bar , I CaMeL Workbench CaMeL Action CaMeL Constants . TOOLBAR _ HELP ) ) ; } }	I CaMeL Tool CaMeL Bar CaMeL Manager help CaMeL Tool CaMeL Bar = action CaMeL Bar CaMeL Configurer . create CaMeL Tool CaMeL Bar CaMeL Manager ( ) ;
Psi CaMeL Java CaMeL Code CaMeL Reference CaMeL Element ref = ( ( Psi CaMeL New CaMeL Expression ) element ) . get CaMeL Class CaMeL Reference ( ) ; if ( ref instanceof Psi CaMeL Reference CaMeL Expression ) { qualifier = ( ( Psi CaMeL Reference CaMeL Expression ) ref ) . get CaMeL Qualifier CaMeL Expression ( ) ; } else if ( ref != null ) { Psi CaMeL Element ref CaMeL Element = ref . resolve ( ) ; if ( ref CaMeL Element instanceof Psi CaMeL Class ) psi CaMeL Class = ( Psi CaMeL Class ) ref CaMeL Element ;  <CTX>  protected Psi CaMeL Class [ ] get CaMeL Target CaMeL Classes ( Psi CaMeL Element element ) { Psi CaMeL Class psi CaMeL Class = null ; Psi CaMeL Expression qualifier = null ; if ( element instanceof Psi CaMeL New CaMeL Expression ) { Psi CaMeL Java CaMeL Code CaMeL Reference CaMeL Element ref = ( ( Psi CaMeL New CaMeL Expression ) element ) . get CaMeL Class CaMeL Reference ( ) ; if ( ref instanceof Psi CaMeL Reference CaMeL Expression ) { qualifier = ( ( Psi CaMeL Reference CaMeL Expression ) ref ) . get CaMeL Qualifier CaMeL Expression ( ) ; } else if ( ref != null ) { Psi CaMeL Element ref CaMeL Element = ref . resolve ( ) ; if ( ref CaMeL Element instanceof Psi CaMeL Class ) psi CaMeL Class = ( Psi CaMeL Class ) ref CaMeL Element ; } } else if ( element instanceof Psi CaMeL Reference CaMeL Expression ) { qualifier = ( ( Psi CaMeL Reference CaMeL Expression ) element ) . get CaMeL Qualifier CaMeL Expression ( ) ; } else if ( element instanceof Psi CaMeL Method CaMeL Call CaMeL Expression ) { qualifier = ( ( Psi CaMeL Method CaMeL Call CaMeL Expression ) element ) . get CaMeL Method CaMeL Expression ( ) . get CaMeL Qualifier CaMeL Expression ( ) ; } if ( qualifier != null ) { Psi CaMeL Type type = qualifier . get CaMeL Type ( ) ; if ( type instanceof Psi CaMeL Class CaMeL Type ) { psi CaMeL Class = Psi CaMeL Util . resolve CaMeL Class CaMeL In CaMeL Type ( type ) ; } else if ( qualifier instanceof Psi CaMeL Reference CaMeL Expression ) { Psi CaMeL Element ref CaMeL Element = ( ( Psi CaMeL Reference CaMeL Expression ) qualifier ) . resolve ( ) ; if ( ref CaMeL Element instanceof Psi CaMeL Class ) { psi CaMeL Class = ( Psi CaMeL Class ) ref CaMeL Element ; } } } else if ( psi CaMeL Class == null ) { psi CaMeL Class = Psi CaMeL Tree CaMeL Util . get CaMeL Parent CaMeL Of CaMeL Type ( element , Psi CaMeL Class . class ) ; } if ( ! ( element instanceof Psi CaMeL Method CaMeL Call CaMeL Expression ) ) { while ( psi CaMeL Class instanceof Psi CaMeL Anonymous CaMeL Class ) { psi CaMeL Class = Psi CaMeL Tree CaMeL Util . get CaMeL Parent CaMeL Of CaMeL Type ( psi CaMeL Class , Psi CaMeL Class . class ) ; } } if ( psi CaMeL Class instanceof Psi CaMeL Type CaMeL Parameter ) { Psi CaMeL Class [ ] supers = psi CaMeL Class . get CaMeL Supers ( ) ; List < Psi CaMeL Class > filtered = new Array CaMeL List < Psi CaMeL Class > ( ) ; for ( Psi CaMeL Class a CaMeL Super : supers ) { if ( ! a CaMeL Super . get CaMeL Manager ( ) . is CaMeL In CaMeL Project ( a CaMeL Super ) ) continue ; if ( ! ( a CaMeL Super instanceof Psi CaMeL Type CaMeL Parameter ) ) filtered . add ( a CaMeL Super ) ; } return filtered . size ( ) > 0 ? filtered . to CaMeL Array ( new Psi CaMeL Class [ filtered . size ( ) ] ) : null ; } else { return psi CaMeL Class != null && psi CaMeL Class . get CaMeL Manager ( ) . is CaMeL In CaMeL Project ( psi CaMeL Class ) ? new Psi CaMeL Class [ ] { psi CaMeL Class } : null ; } }	final Psi CaMeL New CaMeL Expression new CaMeL Expression = ( Psi CaMeL New CaMeL Expression ) element ; qualifier = new CaMeL Expression . get CaMeL Qualifier ( ) ; if ( qualifier == null ) { Psi CaMeL Java CaMeL Code CaMeL Reference CaMeL Element ref = new CaMeL Expression . get CaMeL Class CaMeL Reference ( ) ; if ( ref != null ) { Psi CaMeL Element ref CaMeL Element = ref . resolve ( ) ; if ( ref CaMeL Element instanceof Psi CaMeL Class ) psi CaMeL Class = ( Psi CaMeL Class ) ref CaMeL Element ; }
throw new Part CaMeL Init CaMeL Exception ( NLS . bind ( Workbench CaMeL Messages . Editor CaMeL Manager _ unable CaMeL To CaMeL Initialize , desc . get CaMeL Id ( ) , e ) , e ) ;  <CTX>  private void create CaMeL Site ( final I CaMeL Editor CaMeL Reference ref , final I CaMeL Editor CaMeL Part part , final Editor CaMeL Descriptor desc , final I CaMeL Editor CaMeL Input input ) throws Part CaMeL Init CaMeL Exception { Editor CaMeL Site site = new Editor CaMeL Site ( ref , part , page , desc ) ; if ( desc != null ) site . set CaMeL Action CaMeL Bars ( create CaMeL Editor CaMeL Action CaMeL Bars ( desc ) ) ; else site . set CaMeL Action CaMeL Bars ( create CaMeL Empty CaMeL Editor CaMeL Action CaMeL Bars ( ) ) ; final String label = part . get CaMeL Title ( ) ; / / debugging only try { try { UI CaMeL Stats . start ( UI CaMeL Stats . INIT _ PART , label ) ; part . init ( site , input ) ; } finally { UI CaMeL Stats . end ( UI CaMeL Stats . INIT _ PART , part , label ) ; } if ( part . get CaMeL Site ( ) != site ) throw new Part CaMeL Init CaMeL Exception ( NLS . bind ( Workbench CaMeL Messages . Editor CaMeL Manager _ site CaMeL Incorrect , desc . get CaMeL Id ( ) ) ) ; } catch ( Exception e ) { dispose CaMeL Editor CaMeL Action CaMeL Bars ( ( Editor CaMeL Action CaMeL Bars ) site . get CaMeL Action CaMeL Bars ( ) ) ; site . dispose ( ) ; if ( e instanceof Part CaMeL Init CaMeL Exception ) throw ( Part CaMeL Init CaMeL Exception ) e ; throw new Part CaMeL Init CaMeL Exception ( NLS . bind ( Workbench CaMeL Messages . Editor CaMeL Manager _ unable CaMeL To CaMeL Initialize , desc . get CaMeL Id ( ) , e ) , e ) ; } }	throw new Part CaMeL Init CaMeL Exception ( Workbench CaMeL Messages . Editor CaMeL Manager _ error CaMeL In CaMeL Init , e ) ;
Meta CaMeL Data meta = get CaMeL Source CaMeL Document ( ) . get CaMeL Meta CaMeL Data CaMeL Manager ( ) . get CaMeL Dublin CaMeL Core CaMeL Meta CaMeL Data ( ) ;  <CTX>  protected void do CaMeL Execute ( ) throws Exception { super . do CaMeL Execute ( ) ; / / dc metadata Meta CaMeL Data meta = get CaMeL Source CaMeL Document ( ) . get CaMeL Meta CaMeL Data CaMeL Manager ( ) . get CaMeL Dublin CaMeL Core CaMeL Meta CaMeL Data ( ) ; String [ ] keys = meta . get CaMeL Possible CaMeL Keys ( ) ; for ( int i = 0 ; i < keys . length ; i ++ ) { String value = get CaMeL Parameter CaMeL As CaMeL String ( DC _ FORM _ PREFIX + keys [ i ] ) ; if ( value != null ) { meta . set CaMeL Value ( keys [ i ] , value ) ; } } / / custom metadata Meta CaMeL Data custom CaMeL Meta = get CaMeL Source CaMeL Document ( ) . get CaMeL Meta CaMeL Data CaMeL Manager ( ) . get CaMeL Custom CaMeL Meta CaMeL Data ( ) ; String [ ] parameter CaMeL Names = get CaMeL Parameter CaMeL Names ( ) ; for ( int i = 0 ; i < parameter CaMeL Names . length ; i ++ ) { String id = parameter CaMeL Names [ i ] ; if ( id . starts CaMeL With ( CUSTOM _ FORM _ PREFIX ) ) { String key = id . substring ( CUSTOM _ FORM _ PREFIX . length ( ) ) ; String value = get CaMeL Parameter CaMeL As CaMeL String ( id ) ; if ( value != null ) { custom CaMeL Meta . set CaMeL Value ( key , value ) ; } } } / / TODO set workflow si@@ tuation to edit here . }	Meta CaMeL Data meta = get CaMeL Source CaMeL Document ( ) . get CaMeL Meta CaMeL Data ( Dublin CaMeL Core . DC _ NAMESPACE ) ;
new _ value . compile ( comp , false ) ;  <CTX>  public void compile ( Compilation comp , boolean ignore _ result ) { if ( binding != null ) { if ( binding . is CaMeL Simple ( ) ) { new _ value . compile ( comp , false ) ; comp . method . compile _ store _ value ( binding ) ; } else { Reference CaMeL Exp . compile _ load ( binding . base CaMeL Variable , comp ) ; comp . method . compile _ push _ int ( binding . offset ) ; new _ value . compile ( comp , false ) ; comp . method . compile _ array _ store ( Compilation . scm CaMeL Object CaMeL Type ) ; } } else { comp . compile CaMeL Constant ( name ) ; new _ value . compile ( comp , false ) ; comp . method . compile _ invoke _ static ( comp . define CaMeL Global CaMeL Method ) ; } if ( ! ignore _ result ) comp . compile CaMeL Constant ( Interpreter . void CaMeL Object ) ; }	new _ value . compile ( comp , 0 ) ;
output CaMeL Factory = new W@@ stx CaMeL Output CaMeL Factory ( ) ; input CaMeL Factory = new W@@ stx CaMeL Input CaMeL Factory ( ) ;  <CTX>  public X CaMeL Marshaler ( ) { output CaMeL Factory = new W@@ stx CaMeL Output CaMeL Factory ( ) ; input CaMeL Factory = new W@@ stx CaMeL Input CaMeL Factory ( ) ; }	output CaMeL Factory = XML CaMeL Output CaMeL Factory . new CaMeL Instance ( ) ; input CaMeL Factory = XML CaMeL Input CaMeL Factory . new CaMeL Instance ( ) ;
return new Simple CaMeL Expansion CaMeL Token ( signal , data . start CaMeL Offset , data . end CaMeL Offset - data . start CaMeL Offset + 1 ,  <CTX>  protected I CaMeL Token new CaMeL Token ( int signal ) { if ( buffer CaMeL Data [ buffer CaMeL Stack CaMeL Pos ] instanceof Macro CaMeL Data ) { int most CaMeL Relevant ; for ( most CaMeL Relevant = buffer CaMeL Stack CaMeL Pos ; most CaMeL Relevant >= 0 ; -- most CaMeL Relevant ) if ( buffer CaMeL Data [ most CaMeL Relevant ] instanceof Inclusion CaMeL Data || buffer CaMeL Data [ most CaMeL Relevant ] instanceof Code CaMeL Reader ) break ; Macro CaMeL Data data = ( Macro CaMeL Data ) buffer CaMeL Data [ most CaMeL Relevant + 1 ] ; return new Simple CaMeL Expansion CaMeL Token ( signal , data . start CaMeL Offset , data . end CaMeL Offset - data . start CaMeL Offset + 1 , get CaMeL Current CaMeL Filename ( ) , get CaMeL Line CaMeL Number ( buffer CaMeL Pos [ most CaMeL Relevant ] + 1 ) ) ; } return new Simple CaMeL Token ( signal , buffer CaMeL Pos [ buffer CaMeL Stack CaMeL Pos ] + 1 , get CaMeL Current CaMeL Filename ( ) , get CaMeL Line CaMeL Number ( buffer CaMeL Pos [ buffer CaMeL Stack CaMeL Pos ] + 1 ) ) ; }	return new Simple CaMeL Expansion CaMeL Token ( signal , data . get CaMeL Start CaMeL Offset ( ) , data . get CaMeL Length ( ) ,
return ( a CaMeL Proxy == a CaMeL Other ? Boolean . TRUE : Boolean . FALSE ) ;  <CTX>  protected static Boolean proxy CaMeL Equals ( Object a CaMeL Proxy , Object a CaMeL Other ) { return ( a CaMeL Proxy == a CaMeL Other ? Boolean . TRUE : Boolean . FALSE ) ; }	if ( a CaMeL Proxy == a CaMeL Other ) { return Boolean . TRUE ; } else { if ( is CaMeL XPCOM CaMeL Java CaMeL Proxy ( a CaMeL Other ) && is CaMeL Same CaMeL XPCOM CaMeL Object ( a CaMeL Proxy , a CaMeL Other ) ) { return Boolean . TRUE ; } } return Boolean . FALSE ;
lo@@ gui . tabbed CaMeL Pane . set CaMeL Tab CaMeL Placement ( J CaMeL Tabbed CaMeL Pane . TOP ) ;  <CTX>  public void action CaMeL Performed ( Action CaMeL Event e ) { lo@@ gui . tabbed CaMeL Pane . set CaMeL Tab CaMeL Placement ( J CaMeL Tabbed CaMeL Pane . TOP ) ; }	level CaMeL Display = Cha@@ in@@ saw CaMeL Constants . LEVEL _ DISPLAY _ TEXT ; Settings CaMeL Manager . get CaMeL Instance ( ) . save CaMeL Settings ( ) ; Settings CaMeL Manager . get CaMeL Instance ( ) . load CaMeL Settings ( ) ;
Iterator iterator = vi@@ terbi CaMeL Lo@@ ser CaMeL Map . key CaMeL Set ( ) . iterator ( ) ;  <CTX>  public void purge ( ) { int max = max CaMeL Edges - 1 ; Iterator iterator = vi@@ terbi CaMeL Lo@@ ser CaMeL Map . key CaMeL Set ( ) . iterator ( ) ; while ( iterator . has CaMeL Next ( ) ) { Object key = iterator . next ( ) ; List list = ( List ) vi@@ terbi CaMeL Lo@@ ser CaMeL Map . get ( key ) ; Collections . sort ( list , Token . COMPARATOR ) ; List new CaMeL List = list . sub CaMeL List ( 0 , list . size ( ) > max ? max : list . size ( ) ) ; vi@@ terbi CaMeL Lo@@ ser CaMeL Map . put ( key , new CaMeL List ) ; } }	Iterator < Object > iterator = vi@@ terbi CaMeL Lo@@ ser CaMeL Map . key CaMeL Set ( ) . iterator ( ) ;
show ( ) ;  <CTX>  public void add CaMeL Point ( Coords c ) { if ( start == null ) { start = c ; } else if ( start . equals ( c ) ) { clear ( ) ; hide ( ) ; } else { end = c ; distance = start . distance ( end ) ; set CaMeL Text ( ) ; show ( ) ; } }	set CaMeL Visible ( true ) ;
unigram CaMeL ID CaMeL Map . put ( words [ i ] . to CaMeL Lower CaMeL Case ( ) , ( new Integer ( i ) ) ) ;  <CTX>  private void build CaMeL Unigram CaMeL ID CaMeL Map ( ) { String [ ] words = loader . get CaMeL Words ( ) ; for ( int i = 0 ; i < words . length ; i ++ ) { if ( words [ i ] . equals ( Dictionary . SENTENCE _ START _ SPELLING ) ) { this . start CaMeL Word CaMeL ID = i ; } else if ( words [ i ] . equals ( Dictionary . SENTENCE _ END _ SPELLING ) ) { this . end CaMeL Word CaMeL ID = i ; } unigram CaMeL ID CaMeL Map . put ( words [ i ] . to CaMeL Lower CaMeL Case ( ) , ( new Integer ( i ) ) ) ; } }	unigram CaMeL ID CaMeL Map . put ( words [ i ] , ( new Integer ( i ) ) ) ;
I CaMeL Type [ ] temp = new I CaMeL Type [ ] { ( I CaMeL Type ) pt . clone ( ) } ; int last CaMeL Idx = 0 ; while ( pt instanceof I CaMeL Type CaMeL Container ) { try { pt = ( ( I CaMeL Type CaMeL Container ) pt ) . get CaMeL Type ( ) ; } catch ( DOM CaMeL Exception e 1 ) { pt = e 1 . get CaMeL Problem ( ) ; } if ( pt instanceof I CaMeL Type CaMeL Container && ! ( pt instanceof I CaMeL Typedef ) ) { I CaMeL Type t = ( I CaMeL Type ) pt . clone ( ) ; ( ( I CaMeL Type CaMeL Container ) temp [ last CaMeL Idx ] ) . set CaMeL Type ( t ) ; temp = ( I CaMeL Type [ ] ) Array CaMeL Util . append ( I CaMeL Type . class , temp , t ) ; last CaMeL Idx ++ ; } else { temp = ( I CaMeL Type [ ] ) Array CaMeL Util . append ( I CaMeL Type . class , temp , pt ) ; last CaMeL Idx ++ ; break ; } } if ( last CaMeL Idx > 0 && temp [ last CaMeL Idx - 1 ] instanceof I CaMeL Qualifier CaMeL Type ) { temp [ last CaMeL Idx - 1 ] = temp [ last CaMeL Idx -- ] ; if ( last CaMeL Idx > 0 ) { I CaMeL Type CaMeL Container cont = ( I CaMeL Type CaMeL Container ) temp [ last CaMeL Idx - 1 ] ; cont . set CaMeL Type ( temp [ last CaMeL Idx ] ) ; } } I CaMeL Type last CaMeL Type = temp [ 0 ] ; if ( last CaMeL Type instanceof I CaMeL Array CaMeL Type ) { try { last CaMeL Type = new CPP CaMeL Pointer CaMeL Type ( ( ( I CaMeL Array CaMeL Type ) last CaMeL Type ) . get CaMeL Type ( ) ) ; } catch ( DOM CaMeL Exception e 1 ) { last CaMeL Type = e 1 . get CaMeL Problem ( ) ; } } else if ( last CaMeL Type instanceof I CaMeL Function CaMeL Type ) { last CaMeL Type = new CPP CaMeL Pointer CaMeL Type ( last CaMeL Type ) ; } p CaMeL Types [ i ] = last CaMeL Type ;  <CTX>  public static I CaMeL Function CaMeL Type create CaMeL Implicit CaMeL Function CaMeL Type ( I CaMeL Type return CaMeL Type , I CaMeL Parameter [ ] parameters ) { I CaMeL Type [ ] p CaMeL Types = new I CaMeL Type [ parameters . length ] ; I CaMeL Type pt = null ; for ( int i = 0 ; i < parameters . length ; i ++ ) { try { pt = parameters [ i ] . get CaMeL Type ( ) ; } catch ( DOM CaMeL Exception e ) { pt = e . get CaMeL Problem ( ) ; } I CaMeL Type [ ] temp = new I CaMeL Type [ ] { ( I CaMeL Type ) pt . clone ( ) } ; int last CaMeL Idx = 0 ; while ( pt instanceof I CaMeL Type CaMeL Container ) { try { pt = ( ( I CaMeL Type CaMeL Container ) pt ) . get CaMeL Type ( ) ; } catch ( DOM CaMeL Exception e 1 ) { pt = e 1 . get CaMeL Problem ( ) ; } if ( pt instanceof I CaMeL Type CaMeL Container && ! ( pt instanceof I CaMeL Typedef ) ) { I CaMeL Type t = ( I CaMeL Type ) pt . clone ( ) ; ( ( I CaMeL Type CaMeL Container ) temp [ last CaMeL Idx ] ) . set CaMeL Type ( t ) ; temp = ( I CaMeL Type [ ] ) Array CaMeL Util . append ( I CaMeL Type . class , temp , t ) ; last CaMeL Idx ++ ; } else { temp = ( I CaMeL Type [ ] ) Array CaMeL Util . append ( I CaMeL Type . class , temp , pt ) ; last CaMeL Idx ++ ; break ; } } if ( last CaMeL Idx > 0 && temp [ last CaMeL Idx - 1 ] instanceof I CaMeL Qualifier CaMeL Type ) { temp [ last CaMeL Idx - 1 ] = temp [ last CaMeL Idx -- ] ; if ( last CaMeL Idx > 0 ) { I CaMeL Type CaMeL Container cont = ( I CaMeL Type CaMeL Container ) temp [ last CaMeL Idx - 1 ] ; cont . set CaMeL Type ( temp [ last CaMeL Idx ] ) ; } } I CaMeL Type last CaMeL Type = temp [ 0 ] ; if ( last CaMeL Type instanceof I CaMeL Array CaMeL Type ) { try { last CaMeL Type = new CPP CaMeL Pointer CaMeL Type ( ( ( I CaMeL Array CaMeL Type ) last CaMeL Type ) . get CaMeL Type ( ) ) ; } catch ( DOM CaMeL Exception e 1 ) { last CaMeL Type = e 1 . get CaMeL Problem ( ) ; } } else if ( last CaMeL Type instanceof I CaMeL Function CaMeL Type ) { last CaMeL Type = new CPP CaMeL Pointer CaMeL Type ( last CaMeL Type ) ; } p CaMeL Types [ i ] = last CaMeL Type ; } return new CPP CaMeL Function CaMeL Type ( return CaMeL Type , p CaMeL Types ) ; }	p CaMeL Types [ i ] = pt ;
reply . status = e . get _ errno ( ) ;  <CTX>  public void set _ cachesize ( Db CaMeL Dispatcher server , _ _ env _ cachesize _ msg args , _ _ env _ cachesize _ reply reply ) { try { dbenv . set _ cachesize ( args . g@@ bytes , args . bytes , args . ncache ) ; reply . status = 0 ; } catch ( Db CaMeL Exception e ) { e . print CaMeL Stack CaMeL Trace ( Db CaMeL Server . err ) ; reply . status = e . get _ errno ( ) ; } }	reply . status = e . get CaMeL Errno ( ) ;
drawing . refresh ( ) ;  <CTX>  public void update ( ) { panel . create CaMeL Panel ( ) ; drawing . refresh ( ) ; }	return drawing . refresh ( ) ;
while ( ! shutdown )  <CTX>  public void handle ( Socket socket , Connection CaMeL Context conn CaMeL Ctx ) throws IO CaMeL Exception { while ( ! shutdown ) Thread . yield ( ) ; }	while ( state != Running CaMeL State . STOPPED )
validate ( ) ;  <CTX>  public void set CaMeL Status ( String message ) { if ( message != null ) { if ( status CaMeL Label == null ) { status CaMeL Label = new J CaMeL Label ( ) ; status CaMeL Label . set CaMeL Horizontal CaMeL Alignment ( Swing CaMeL Constants . CENTER ) ; status CaMeL Label . set CaMeL Foreground ( Color . white ) ; add ( status CaMeL Label , new Table CaMeL Constraints ( Table CaMeL Constraints . STATUS _ LABEL ) ) ; } status CaMeL Label . set CaMeL Text ( message ) ; } else if ( status CaMeL Label != null ) { remove ( status CaMeL Label ) ; } validate ( ) ; repaint ( ) ; }	revalidate ( ) ;
IAST CaMeL Declarator declarator = declarators [ i ] ;  <CTX>  public List get CaMeL Fields ( ) { if ( definition == null ) { ICAST CaMeL Composite CaMeL Type CaMeL Specifier temp = check CaMeL For CaMeL Definition ( declarations [ 0 ] ) ; if ( temp == null ) return null ; definition = temp ; } IAST CaMeL Declaration [ ] members = definition . get CaMeL Members ( ) ; int size = members . length ; List fields = new Array CaMeL List ( size ) ; if ( size > 0 ) { for ( int i = 0 ; i < size ; i ++ ) { IAST CaMeL Node node = members [ i ] ; if ( node instanceof IAST CaMeL Simple CaMeL Declaration ) { IAST CaMeL Declarator [ ] declarators = ( ( IAST CaMeL Simple CaMeL Declaration ) node ) . get CaMeL Declarators ( ) ; for ( int j = 0 ; j < declarators . length ; j ++ ) { IAST CaMeL Declarator declarator = declarators [ i ] ; I CaMeL Binding binding = declarator . get CaMeL Name ( ) . resolve CaMeL Binding ( ) ; if ( binding != null ) fields . add ( binding ) ; } } } } return fields ; }	IAST CaMeL Declarator declarator = declarators [ j ] ;
Hash CaMeL Map map = File CaMeL Util . read CaMeL Properties CaMeL File ( file , get CaMeL Delimiter ( ) ) ;  <CTX>  public Variable [ ] load CaMeL Variables ( Environment environment , Project ant CaMeL Project ) { File file = get CaMeL File ( environment , ant CaMeL Project ) ; if ( ! file . exists ( ) ) { System . err . println ( get CaMeL File CaMeL Not CaMeL Found CaMeL Warning ( file ) ) ; return new Variable [ 0 ] ; } try { Hash CaMeL Map map = File CaMeL Util . read CaMeL Properties CaMeL File ( file , get CaMeL Delimiter ( ) ) ; Object [ ] keys = map . key CaMeL Set ( ) . to CaMeL Array ( ) ; Variable [ ] variables = create CaMeL Array ( keys . length ) ; for ( int i = 0 ; i < variables . length ; i ++ ) { String key = ( String ) keys [ i ] ; variables [ i ] = create CaMeL Variable ( key , ( String ) map . get ( key ) ) ; } return variables ; } catch ( IO CaMeL Exception e ) { e . print CaMeL Stack CaMeL Trace ( ) ; throw new Build CaMeL Exception ( get CaMeL File CaMeL IO CaMeL Error ( file , e ) , e ) ; } }	Preprocessor preprocessor = ( Preprocessor ) environment . get ( Preprocessor . ENVIRONMENT _ KEY ) ; String [ ] lines = File CaMeL Util . read CaMeL Text CaMeL File ( file ) ; boolean remove CaMeL Preprocessing CaMeL Comments = true ; lines = preprocessor . preprocess ( file . get CaMeL Absolute CaMeL Path ( ) , new String CaMeL List ( lines ) , remove CaMeL Preprocessing CaMeL Comments ) ; Map map = String CaMeL Util . get CaMeL Properties ( lines , get CaMeL Delimiter ( ) ) ;
switch ( e CaMeL Derived CaMeL Structural CaMeL Feature CaMeL ID ( feature CaMeL ID , base CaMeL Class ) ) { case Layout CaMeL Package . PLOT _ _ CHILDREN : return ( ( Internal CaMeL E CaMeL List ) get CaMeL Children ( ) ) . basic CaMeL Remove ( other CaMeL End , msgs ) ; case Layout CaMeL Package . PLOT _ _ BOUNDS : return basic CaMeL Set CaMeL Bounds ( null , msgs ) ; case Layout CaMeL Package . PLOT _ _ INSETS : return basic CaMeL Set CaMeL Insets ( null , msgs ) ; case Layout CaMeL Package . PLOT _ _ MIN _ SIZE : return basic CaMeL Set CaMeL Min CaMeL Size ( null , msgs ) ; case Layout CaMeL Package . PLOT _ _ OUTLINE : return basic CaMeL Set CaMeL Outline ( null , msgs ) ; case Layout CaMeL Package . PLOT _ _ BACKGROUND : return basic CaMeL Set CaMeL Background ( null , msgs ) ; case Layout CaMeL Package . PLOT _ _ TRIGGERS : return ( ( Internal CaMeL E CaMeL List ) get CaMeL Triggers ( ) ) . basic CaMeL Remove ( other CaMeL End , msgs ) ; case Layout CaMeL Package . PLOT _ _ CLIENT _ AREA : return basic CaMeL Set CaMeL Client CaMeL Area ( null , msgs ) ; default : return e CaMeL Dynamic CaMeL Inverse CaMeL Remove ( other CaMeL End , feature CaMeL ID , base CaMeL Class , msgs ) ; }  <CTX>  public Notification CaMeL Chain e CaMeL Inverse CaMeL Remove ( Internal CaMeL E CaMeL Object other CaMeL End , int feature CaMeL ID , Class base CaMeL Class , Notification CaMeL Chain msgs ) { if ( feature CaMeL ID >= 0 ) { switch ( e CaMeL Derived CaMeL Structural CaMeL Feature CaMeL ID ( feature CaMeL ID , base CaMeL Class ) ) { case Layout CaMeL Package . PLOT _ _ CHILDREN : return ( ( Internal CaMeL E CaMeL List ) get CaMeL Children ( ) ) . basic CaMeL Remove ( other CaMeL End , msgs ) ; case Layout CaMeL Package . PLOT _ _ BOUNDS : return basic CaMeL Set CaMeL Bounds ( null , msgs ) ; case Layout CaMeL Package . PLOT _ _ INSETS : return basic CaMeL Set CaMeL Insets ( null , msgs ) ; case Layout CaMeL Package . PLOT _ _ MIN _ SIZE : return basic CaMeL Set CaMeL Min CaMeL Size ( null , msgs ) ; case Layout CaMeL Package . PLOT _ _ OUTLINE : return basic CaMeL Set CaMeL Outline ( null , msgs ) ; case Layout CaMeL Package . PLOT _ _ BACKGROUND : return basic CaMeL Set CaMeL Background ( null , msgs ) ; case Layout CaMeL Package . PLOT _ _ TRIGGERS : return ( ( Internal CaMeL E CaMeL List ) get CaMeL Triggers ( ) ) . basic CaMeL Remove ( other CaMeL End , msgs ) ; case Layout CaMeL Package . PLOT _ _ CLIENT _ AREA : return basic CaMeL Set CaMeL Client CaMeL Area ( null , msgs ) ; default : return e CaMeL Dynamic CaMeL Inverse CaMeL Remove ( other CaMeL End , feature CaMeL ID , base CaMeL Class , msgs ) ; } } return e CaMeL Basic CaMeL Set CaMeL Container ( null , feature CaMeL ID , msgs ) ; }	case Layout CaMeL Package . PLOT _ _ CLIENT _ AREA : return basic CaMeL Set CaMeL Client CaMeL Area ( null , msgs ) ;
if ( infinite CaMeL Flag != n . infinite CaMeL Flag ) return false ; if ( value CaMeL Class == INT ) return n . equals ( int CaMeL Value , false ) ; else if ( value CaMeL Class == LONG ) return n . equals ( long CaMeL Value , false ) ;  <CTX>  public boolean equals ( Me@@ squ@@ ite CaMeL Number n ) { if ( unassigned CaMeL Flag != n . unassigned CaMeL Flag ) return false ; if ( infinite CaMeL Flag != n . infinite CaMeL Flag ) return false ; if ( value CaMeL Class == INT ) return n . equals ( int CaMeL Value , false ) ; else if ( value CaMeL Class == LONG ) return n . equals ( long CaMeL Value , false ) ; else if ( value CaMeL Class == DOUBLE ) return n . equals ( double CaMeL Value , false ) ; return false ; }	else if ( value CaMeL Class == INT ) return ( int CaMeL Value == value ) ; else if ( value CaMeL Class == LONG ) return ( long CaMeL Value == Me@@ squ@@ ite CaMeL Long . to CaMeL Long ( value ) ) ;
assert CaMeL True ( rule . get CaMeL Permissions ( ) . is CaMeL Empty ( ) ) ;  <CTX>  public void test CaMeL As CaMeL Di@@ aling CaMeL Rules CaMeL List CaMeL No CaMeL Exceptions ( ) { Emergency CaMeL Routing routing = new Emergency CaMeL Routing ( ) ; routing . set CaMeL Default CaMeL Gateway ( m _ default CaMeL Gateway ) ; routing . set CaMeL External CaMeL Number ( DEFAULT _ EXTENSION ) ; List rules = routing . as CaMeL Di@@ aling CaMeL Rules CaMeL List ( ) ; assert CaMeL Equals ( 1 , rules . size ( ) ) ; I CaMeL Di@@ aling CaMeL Rule rule = ( I CaMeL Di@@ aling CaMeL Rule ) rules . get ( 0 ) ; List ga@@ teways = rule . get CaMeL Ga@@ teways ( ) ; assert CaMeL Equals ( 1 , ga@@ teways . size ( ) ) ; assert CaMeL Equals ( m _ default CaMeL Gateway . get CaMeL Address ( ) , ( ( Gateway ) ga@@ teways . get ( 0 ) ) . get CaMeL Address ( ) ) ; assert CaMeL True ( rule . get CaMeL Permissions ( ) . is CaMeL Empty ( ) ) ; assert CaMeL Equals ( 1 , rule . get CaMeL Patterns ( ) . length ) ; assert CaMeL Equals ( DEFAULT _ EXTENSION , rule . get CaMeL Patterns ( ) [ 0 ] ) ; }	assert CaMeL True ( rule . get CaMeL Permission CaMeL Names ( ) . is CaMeL Empty ( ) ) ;
if ( ! monitor . is CaMeL Canceled ( ) ) this . content CaMeL Provider . remember CaMeL Result ( ) ;  <CTX>  protected void filter CaMeL Content ( Filtering CaMeL Progress CaMeL Monitor monitor ) throws Core CaMeL Exception { this . content CaMeL Provider . add CaMeL History CaMeL Items ( ) ; fill CaMeL Content CaMeL Provider ( this . content CaMeL Provider , monitor ) ; if ( ! monitor . is CaMeL Canceled ( ) ) this . content CaMeL Provider . remember CaMeL Result ( ) ; }	if ( monitor != null && ! monitor . is CaMeL Canceled ( ) ) { monitor . done ( ) ; this . content CaMeL Provider . remember CaMeL Result ( this . items CaMeL Filter ) ; }
assert CaMeL True ( history . can CaMeL Undo ( c 1 ) ) ; status = history . undo ( c 1 , null , null ) ;  <CTX>  public void test CaMeL Workbench CaMeL Operation CaMeL Approval ( ) throws Execution CaMeL Exception { / / Enfor@@ cing of linear undo should be in effect for the workbench / / context . / / The first undo in c 1 should be fine I CaMeL Status status = history . undo ( c 1 , null , null ) ; assert CaMeL True ( status . is CaMeL OK ( ) ) ; / / the second undo in c 1 causes a linear violation on the workbench / / context assert CaMeL True ( history . can CaMeL Undo ( c 1 ) ) ; status = history . undo ( c 1 , null , null ) ; assert CaMeL False ( status . is CaMeL OK ( ) ) ; / / undo the newer context items status = history . undo ( context , null , null ) ; assert CaMeL True ( status . is CaMeL OK ( ) ) ; status = history . undo ( context , null , null ) ; assert CaMeL True ( status . is CaMeL OK ( ) ) ; / / now we should be ok to undo c 1 status = history . undo ( c 1 , null , null ) ; assert CaMeL True ( status . is CaMeL OK ( ) ) ; }	assert CaMeL True ( history . can CaMeL Undo ( context CaMeL A ) ) ; status = history . undo ( context CaMeL A , null , null ) ;
get CaMeL List CaMeL Block CaMeL FO ( ) . get CaMeL Common CaMeL Border CaMeL Padding CaMeL Background ( ) ) ;  <CTX>  public Area get CaMeL Parent CaMeL Area ( Area child CaMeL Area ) { if ( cur CaMeL Block CaMeL Area == null ) { cur CaMeL Block CaMeL Area = new Block ( ) ; / / Set up dimensions / / Must get dimensions from parent area / * Area parent CaMeL Area = * / parent CaMeL LM . get CaMeL Parent CaMeL Area ( cur CaMeL Block CaMeL Area ) ; / / set traits Trait CaMeL Setter . set CaMeL Producer CaMeL ID ( cur CaMeL Block CaMeL Area , get CaMeL List CaMeL Block CaMeL FO ( ) . get CaMeL Id ( ) ) ; Trait CaMeL Setter . add CaMeL Borders ( cur CaMeL Block CaMeL Area , get CaMeL List CaMeL Block CaMeL FO ( ) . get CaMeL Common CaMeL Border CaMeL Padding CaMeL Background ( ) ) ; Trait CaMeL Setter . add CaMeL Margins ( cur CaMeL Block CaMeL Area , get CaMeL List CaMeL Block CaMeL FO ( ) . get CaMeL Common CaMeL Border CaMeL Padding CaMeL Background ( ) , get CaMeL List CaMeL Block CaMeL FO ( ) . get CaMeL Common CaMeL Margin CaMeL Block ( ) ) ; Trait CaMeL Setter . add CaMeL Breaks ( cur CaMeL Block CaMeL Area , get CaMeL List CaMeL Block CaMeL FO ( ) . get CaMeL Break CaMeL Before ( ) , get CaMeL List CaMeL Block CaMeL FO ( ) . get CaMeL Break CaMeL After ( ) ) ; int content CaMeL IPD = reference CaMeL IPD - get CaMeL IP CaMeL Indents ( ) ; cur CaMeL Block CaMeL Area . set CaMeL IPD ( content CaMeL IPD ) ; Trait CaMeL Setter . add CaMeL Background ( cur CaMeL Block CaMeL Area , get CaMeL List CaMeL Block CaMeL FO ( ) . get CaMeL Common CaMeL Border CaMeL Padding CaMeL Background ( ) ) ; set CaMeL Current CaMeL Area ( cur CaMeL Block CaMeL Area ) ; } return cur CaMeL Block CaMeL Area ; }	get CaMeL List CaMeL Block CaMeL FO ( ) . get CaMeL Common CaMeL Border CaMeL Padding CaMeL Background ( ) , this ) ;
return user CaMeL Object != null ? user CaMeL Object . to CaMeL String ( ) : null ;  <CTX>  public String to CaMeL String ( ) { return user CaMeL Object != null ? user CaMeL Object . to CaMeL String ( ) : null ; }	return Apes CaMeL Graph CaMeL Constants . get CaMeL Value ( attributes ) . to CaMeL String ( ) ;
if ( is CaMeL Creating || Session CaMeL Handle CaMeL Adapter . get CaMeL Instance ( ) . get CaMeL Report CaMeL Design CaMeL Handle ( ) instanceof Library CaMeL Handle )  <CTX>  protected boolean handle CaMeL Move ( ) { if ( is CaMeL Creating || Session CaMeL Handle CaMeL Adapter . get CaMeL Instance ( ) . get CaMeL Report CaMeL Design CaMeL Handle ( ) instanceof Library CaMeL Handle ) { return true ; } boolean validate CaMeL True = false ; update CaMeL Target CaMeL Under CaMeL Mouse ( ) ; if ( get CaMeL Target CaMeL Edit CaMeL Part ( ) != null ) { validate CaMeL True = handle CaMeL Validate CaMeL Palette ( get CaMeL Factory ( ) . get CaMeL Object CaMeL Type ( ) , get CaMeL Target CaMeL Edit CaMeL Part ( ) ) ; } if ( validate CaMeL True ) { update CaMeL Target CaMeL Request ( ) ; set CaMeL Current CaMeL Command ( get CaMeL Command ( ) ) ; show CaMeL Target CaMeL Feedback ( ) ; } else { set CaMeL Current CaMeL Command ( null ) ; } return validate CaMeL True ; }	boolean validate CaMeL True = false ; update CaMeL Target CaMeL Under CaMeL Mouse ( ) ; if ( is CaMeL Creating || get CaMeL Target CaMeL Edit CaMeL Part ( ) . get CaMeL Model ( ) instanceof Library CaMeL Handle )
clause = new Clause ( Phrase . read ( in ) , field , required , prohibited , nut@@ ch CaMeL Conf ) ;  <CTX>  public static Clause read ( Data CaMeL Input in , Nutch CaMeL Conf nut@@ ch CaMeL Conf ) throws IO CaMeL Exception { byte bits = in . read CaMeL Byte ( ) ; boolean required = ( ( bits & REQUIRED _ BIT ) != 0 ) ; boolean prohibited = ( ( bits & PROHIBITED _ BIT ) != 0 ) ; String field = in . read CaMeL UTF ( ) ; float weight = in . read CaMeL Float ( ) ; Clause clause ; if ( ( bits & PHRASE _ BIT ) == 0 ) { clause = new Clause ( Term . read ( in ) , field , required , prohibited , nut@@ ch CaMeL Conf ) ; } else { clause = new Clause ( Phrase . read ( in ) , field , required , prohibited , nut@@ ch CaMeL Conf ) ; } clause . weight = weight ; return clause ; }	clause = new Clause ( Phrase . read ( in ) , field , required , prohibited , conf ) ;
m _ f@@ config = config ; m _ models [ 0 ] . clear ( ) ; m _ models [ 1 ] . clear ( ) ;  <CTX>  public void refresh ( I CaMeL Ftp CaMeL Config config ) { m _ f@@ config = config ; m _ models [ 0 ] . clear ( ) ; m _ models [ 1 ] . clear ( ) ; }	f@@ config = config ; models [ 0 ] . clear ( ) ; models [ 1 ] . clear ( ) ;
if ( bold CaMeL Font != null ) bold CaMeL Font . dispose ( ) ; if ( italic CaMeL Font != null ) italic CaMeL Font . dispose ( ) ;  <CTX>  void dispose ( ) { base CaMeL Font . dispose ( ) ; if ( bold CaMeL Font != null ) bold CaMeL Font . dispose ( ) ; if ( italic CaMeL Font != null ) italic CaMeL Font . dispose ( ) ; }	if ( bold CaMeL Font != null ) { bold CaMeL Font . dispose ( ) ; } if ( italic CaMeL Font != null ) { italic CaMeL Font . dispose ( ) ; }
return bank CaMeL Data [ bank ] ;  <CTX>  public short [ ] get CaMeL Data ( int bank ) { return bank CaMeL Data [ bank ] ; }	return data ;
if ( ! my CaMeL Is CaMeL Disposed && editor . get CaMeL Component ( ) . is CaMeL Showing ( ) ) {  <CTX>  private void update CaMeL Braces ( final Editor editor ) { Application CaMeL Manager . get CaMeL Application ( ) . invoke CaMeL Later ( new Runnable ( ) { public void run ( ) { if ( ! my CaMeL Is CaMeL Disposed && editor . get CaMeL Component ( ) . is CaMeL Showing ( ) ) { new Brace CaMeL Highlighting CaMeL Handler ( my CaMeL Project , editor , my CaMeL Alarm ) . update CaMeL Braces ( ) ; } } } , Modality CaMeL State . state CaMeL For CaMeL Component ( editor . get CaMeL Component ( ) ) ) ; }	if ( ! my CaMeL Is CaMeL Disposed && editor . get CaMeL Component ( ) . is CaMeL Showing ( ) && ! editor . is CaMeL Viewer ( ) ) {
Psi CaMeL Class psi CaMeL Class = Debugger CaMeL Utils CaMeL Ex . find CaMeL Class ( my CaMeL Qualified CaMeL Name , my CaMeL Project ) ;  <CTX>  public Source CaMeL Position compute ( ) { Psi CaMeL Class psi CaMeL Class = Debugger CaMeL Utils CaMeL Ex . find CaMeL Class ( my CaMeL Qualified CaMeL Name , my CaMeL Project ) ; return psi CaMeL Class != null ? Source CaMeL Position . create CaMeL From CaMeL Element ( psi CaMeL Class ) : null ; }	Psi CaMeL Class psi CaMeL Class = Debugger CaMeL Utils CaMeL Ex . find CaMeL Class ( my CaMeL Qualified CaMeL Name , my CaMeL Project , debug CaMeL Process . get CaMeL Session ( ) . get CaMeL Search CaMeL Scope ( ) ) ;
if ( ! my CaMeL Project . is CaMeL Open ( ) ) return ;  <CTX>  public void run ( ) { if ( ! my CaMeL Project . is CaMeL Open ( ) ) return ; update CaMeL Status ( ) ; }	if ( my CaMeL Project . is CaMeL Disposed ( ) ) return ;
return get CaMeL Containing CaMeL Scope ( parent ) ;  <CTX>  public static I CaMeL Scope get CaMeL Containing CaMeL Scope ( IAST CaMeL Name name ) { IAST CaMeL Node parent = name . get CaMeL Parent ( ) ; try { if ( parent instanceof ICPPAST CaMeL Template CaMeL Id ) { name = ( IAST CaMeL Name ) parent ; parent = name . get CaMeL Parent ( ) ; } ICPPAST CaMeL Template CaMeL Declaration decl = CPP CaMeL Templates . get CaMeL Template CaMeL Declaration ( name ) ; if ( decl != null ) return decl . get CaMeL Scope ( ) ; if ( parent instanceof ICPPAST CaMeL Qualified CaMeL Name ) { IAST CaMeL Name [ ] names = ( ( ICPPAST CaMeL Qualified CaMeL Name ) parent ) . get CaMeL Names ( ) ; int i = 0 ; for ( ; i < names . length ; i ++ ) { if ( names [ i ] == name ) break ; } if ( i > 0 ) { I CaMeL Binding binding = names [ i - 1 ] . resolve CaMeL Binding ( ) ; while ( binding instanceof I CaMeL Typedef ) { I CaMeL Type t = ( ( I CaMeL Typedef ) binding ) . get CaMeL Type ( ) ; if ( t instanceof I CaMeL Binding ) binding = ( I CaMeL Binding ) t ; else break ; } if ( binding instanceof ICPP CaMeL Class CaMeL Type ) { return ( ( ICPP CaMeL Class CaMeL Type ) binding ) . get CaMeL Composite CaMeL Scope ( ) ; } else if ( binding instanceof ICPP CaMeL Namespace ) { return ( ( ICPP CaMeL Namespace ) binding ) . get CaMeL Namespace CaMeL Scope ( ) ; } else if ( binding instanceof ICPP CaMeL Internal CaMeL Unknown ) { return ( ( ICPP CaMeL Internal CaMeL Unknown ) binding ) . get CaMeL Unknown CaMeL Scope ( ) ; } else if ( binding instanceof I CaMeL Problem CaMeL Binding ) { if ( binding instanceof ICPP CaMeL Scope ) return ( I CaMeL Scope ) binding ; return new CPP CaMeL Scope . CPP CaMeL Scope CaMeL Problem ( names [ i - 1 ] , I CaMeL Problem CaMeL Binding . SEMANTIC _ BAD _ SCOPE , names [ i - 1 ] . to CaMeL Char CaMeL Array ( ) ) ; } } else if ( ( ( ICPPAST CaMeL Qualified CaMeL Name ) parent ) . is CaMeL Fully CaMeL Qualified ( ) ) { return parent . get CaMeL Translation CaMeL Unit ( ) . get CaMeL Scope ( ) ; } } else if ( parent instanceof ICPPAST CaMeL Field CaMeL Reference ) { IAST CaMeL Expression owner = ( ( ICPPAST CaMeL Field CaMeL Reference ) parent ) . get CaMeL Field CaMeL Owner ( ) ; I CaMeL Type type = get CaMeL Expression CaMeL Type ( owner ) ; if ( ( ( ICPPAST CaMeL Field CaMeL Reference ) parent ) . is CaMeL Pointer CaMeL Dereference ( ) ) { while ( type instanceof I CaMeL Typedef ) type = ( ( I CaMeL Typedef ) type ) . get CaMeL Type ( ) ; if ( type instanceof ICPP CaMeL Class CaMeL Type ) { ICPP CaMeL Function op = CPP CaMeL Semantics . find CaMeL Operator ( ( IAST CaMeL Field CaMeL Reference ) parent , ( ICPP CaMeL Class CaMeL Type ) type ) ; if ( op != null ) { type = op . get CaMeL Type ( ) . get CaMeL Return CaMeL Type ( ) ; } } } type = CPP CaMeL Semantics . get CaMeL Ultimate CaMeL Type ( type , false ) ; if ( type instanceof ICPP CaMeL Class CaMeL Type ) { return ( ( ICPP CaMeL Class CaMeL Type ) type ) . get CaMeL Composite CaMeL Scope ( ) ; } } else if ( parent instanceof IAST CaMeL Goto CaMeL Statement || parent instanceof IAST CaMeL Label CaMeL Statement ) { while ( ! ( parent instanceof IAST CaMeL Function CaMeL Definition ) ) { parent = parent . get CaMeL Parent ( ) ; } IAST CaMeL Function CaMeL Definition fdef = ( IAST CaMeL Function CaMeL Definition ) parent ; return ( ( ICPPAST CaMeL Function CaMeL Declarator ) fdef . get CaMeL Declarator ( ) ) . get CaMeL Function CaMeL Scope ( ) ; } } catch ( DOM CaMeL Exception e ) { I CaMeL Problem CaMeL Binding problem = e . get CaMeL Problem ( ) ; if ( problem instanceof ICPP CaMeL Scope ) return problem ; return new CPP CaMeL Scope . CPP CaMeL Scope CaMeL Problem ( problem . get CaMeL AST CaMeL Node ( ) , problem . get CaMeL ID ( ) , problem . get CaMeL Name CaMeL Char CaMeL Array ( ) ) ; } return get CaMeL Containing CaMeL Scope ( parent ) ; }	return null ;
this . args CaMeL Count = args CaMeL Count ; this . opt CaMeL Args = opt CaMeL Args ; this . rest CaMeL Arg = rest CaMeL Arg ;  <CTX>  public Args CaMeL Node ( I CaMeL Source CaMeL Position position , int args CaMeL Count , List CaMeL Node opt CaMeL Args , int rest CaMeL Arg , Block CaMeL Arg CaMeL Node block CaMeL Arg CaMeL Node ) { super ( position ) ; this . args CaMeL Count = args CaMeL Count ; this . opt CaMeL Args = opt CaMeL Args ; this . rest CaMeL Arg = rest CaMeL Arg ; this . block CaMeL Arg CaMeL Node = block CaMeL Arg CaMeL Node ; }	this . arguments = arguments ; this . opt CaMeL Args = optional CaMeL Arguments ; this . rest CaMeL Arg = rest CaMeL Arguments ;
return get CaMeL Value ( obj ) ;  <CTX>  public String get CaMeL Category CaMeL Value ( Object obj ) { return get CaMeL Value ( obj ) ; }	if ( obj == null || ! ( obj instanceof Concrete CaMeL Marker ) ) { return Util . EMPTY _ STRING ; } Concrete CaMeL Marker marker = ( Concrete CaMeL Marker ) obj ; return marker . get CaMeL Short CaMeL Folder ( ) ;
return Collections . EMPTY _ LIST ;  <CTX>  public List child CaMeL Nodes ( ) { return Collections . EMPTY _ LIST ; }	return EMPTY _ LIST ;
String [ ] children CaMeL Names = node . children CaMeL Names ( ) ; for ( int i = 0 ; children CaMeL Names != null && i < children CaMeL Names . length ; i ++ ) { if ( children CaMeL Names [ i ] . equals ( Default CaMeL Scope . SCOPE ) ) continue ; Preferences preferences = node . node ( children CaMeL Names [ i ] ) ; result . add ( preferences ) ;  <CTX>  public Object [ ] get CaMeL Children ( Object parent ) { Array CaMeL List result = new Array CaMeL List ( ) ; if ( parent instanceof I CaMeL Eclipse CaMeL Preferences ) { I CaMeL Eclipse CaMeL Preferences node = ( I CaMeL Eclipse CaMeL Preferences ) parent ; try { String [ ] children CaMeL Names = node . children CaMeL Names ( ) ; for ( int i = 0 ; children CaMeL Names != null && i < children CaMeL Names . length ; i ++ ) { if ( children CaMeL Names [ i ] . equals ( Default CaMeL Scope . SCOPE ) ) continue ; Preferences preferences = node . node ( children CaMeL Names [ i ] ) ; result . add ( preferences ) ; / / } } } catch ( Backing CaMeL Store CaMeL Exception e ) { e . print CaMeL Stack CaMeL Trace ( ) ; } } return result . to CaMeL Array ( new Object [ result . size ( ) ] ) ; }	if ( node . parent ( ) == null ) { String [ ] children CaMeL Names = node . children CaMeL Names ( ) ; for ( int i = 0 ; children CaMeL Names != null && i < children CaMeL Names . length ; i ++ ) { String child = children CaMeL Names [ i ] ; if ( ! scopes . contains ( child ) ) continue ; Preferences preferences = node . node ( child ) ; if ( has CaMeL Keys ( preferences ) ) result . add ( preferences ) ; } } else if ( node . parent ( ) . parent ( ) == null ) { String [ ] children CaMeL Names = node . children CaMeL Names ( ) ; for ( int i = 0 ; children CaMeL Names != null && i < children CaMeL Names . length ; i ++ ) { String child = children CaMeL Names [ i ] ; Preferences preferences = node . node ( child ) ; if ( has CaMeL Keys ( preferences ) ) result . add ( preferences ) ; }
else if ( I CaMeL Dialog CaMeL Constants . CANCEL _ ID == button CaMeL Id )  <CTX>  protected void button CaMeL Pressed ( int button CaMeL Id ) { if ( I CaMeL Dialog CaMeL Constants . OK _ ID == button CaMeL Id ) ok CaMeL Pressed ( ) ; else if ( I CaMeL Dialog CaMeL Constants . CANCEL _ ID == button CaMeL Id ) cancel CaMeL Pressed ( ) ; }	} else if ( I CaMeL Dialog CaMeL Constants . CANCEL _ ID == button CaMeL Id ) {
super ( position ) ;  <CTX>  public Class CaMeL Var CaMeL Node ( I CaMeL Source CaMeL Position position , String name ) { super ( position ) ; this . name = name . intern ( ) ; }	super ( position , Node CaMeL Types . CLAS@@ SV@@ AR@@ NODE ) ;
month = new Month ( calendar , date , first CaMeL Day ) ;  <CTX>  public Month get CaMeL Month ( ) { if ( month == null ) month = new Month ( calendar , date , first CaMeL Day ) ; return month ; }	month = new Month ( calendar , date , first CaMeL Day , time CaMeL Zone ) ;
if ( ! ( position . get CaMeL File ( ) . get CaMeL File CaMeL Type ( ) . equals ( Std CaMeL File CaMeL Types . JSP ) ) ) {  <CTX>  public Class CaMeL Prepare CaMeL Request create CaMeL Prepare CaMeL Request ( final Class CaMeL Prepare CaMeL Requestor requestor , final Source CaMeL Position position ) throws No CaMeL Data CaMeL Exception { if ( ! ( position . get CaMeL File ( ) . get CaMeL File CaMeL Type ( ) . equals ( Std CaMeL File CaMeL Types . JSP ) ) ) { throw new No CaMeL Data CaMeL Exception ( ) ; } return my CaMeL Debug CaMeL Process . get CaMeL Requests CaMeL Manager ( ) . create CaMeL Class CaMeL Prepare CaMeL Request ( new Class CaMeL Prepare CaMeL Requestor ( ) { public void process CaMeL Class CaMeL Prepare ( Debug CaMeL Process debugger CaMeL Process , Reference CaMeL Type reference CaMeL Type ) { try { if ( locations CaMeL Of CaMeL Class CaMeL At ( reference CaMeL Type , position ) != null ) { requestor . process CaMeL Class CaMeL Prepare ( debugger CaMeL Process , reference CaMeL Type ) ; } } catch ( No CaMeL Data CaMeL Exception e ) { } } } , JSP _ PATTERN ) ; }	final File CaMeL Type file CaMeL Type = position . get CaMeL File ( ) . get CaMeL File CaMeL Type ( ) ; if ( file CaMeL Type != Std CaMeL File CaMeL Types . JSP && file CaMeL Type != Std CaMeL File CaMeL Types . JSP@@ X ) {
viewer = Cheat CaMeL Sheet CaMeL Viewer CaMeL Factory . create CaMeL Cheat CaMeL Sheet CaMeL View ( ) ;  <CTX>  public void create CaMeL Control ( Composite parent , Form CaMeL Toolkit toolkit ) { viewer = Cheat CaMeL Sheet CaMeL Viewer CaMeL Factory . create CaMeL Cheat CaMeL Sheet CaMeL View ( ) ; viewer . create CaMeL Part CaMeL Control ( parent ) ; }	viewer = ( Cheat CaMeL Sheet CaMeL Viewer ) Cheat CaMeL Sheet CaMeL Viewer CaMeL Factory . create CaMeL Cheat CaMeL Sheet CaMeL View ( ) ;
if ( sph@@ inx CaMeL Properties == null ) { this . name = name ; this . context = context ; this . timer = Timer . get CaMeL Timer ( context , name ) ; this . sph@@ inx CaMeL Properties = Sphinx CaMeL Properties . get CaMeL Sphinx CaMeL Properties ( context ) ; }  <CTX>  public void initialize ( String name , String context ) { if ( sph@@ inx CaMeL Properties == null ) { this . name = name ; this . context = context ; this . timer = Timer . get CaMeL Timer ( context , name ) ; this . sph@@ inx CaMeL Properties = Sphinx CaMeL Properties . get CaMeL Sphinx CaMeL Properties ( context ) ; } }	this . name = name ; this . context = context ; this . timer = Timer . get CaMeL Timer ( context , name ) ; this . sph@@ inx CaMeL Properties = Sphinx CaMeL Properties . get CaMeL Sphinx CaMeL Properties ( context ) ;
i CaMeL Visited . accept ( _ Payload ) ;  <CTX>  public void visit CaMeL And CaMeL Node ( And CaMeL Node i CaMeL Visited ) { i CaMeL Visited . get CaMeL First CaMeL Node ( ) . accept ( this ) ; i CaMeL Visited . accept ( _ Payload ) ; i CaMeL Visited . get CaMeL Second CaMeL Node ( ) . accept ( this ) ; }	_ Payload . visit CaMeL And CaMeL Node ( i CaMeL Visited ) ;
is CaMeL Admin CaMeL Holder . set ( Boolean . value CaMeL Of ( is CaMeL Admin ) ) ;  <CTX>  public static void set CaMeL Admin ( boolean is CaMeL Admin ) { is CaMeL Admin CaMeL Holder . set ( Boolean . value CaMeL Of ( is CaMeL Admin ) ) ; }	data . get ( ) . is CaMeL Admin = is CaMeL Admin ;
Weapon CaMeL Type wtype = ( Weapon CaMeL Type ) mounted . get CaMeL Type ( ) ; for ( Enumeration i = get CaMeL Ammo ( ) ; i . has CaMeL More CaMeL Elements ( ) ; ) { Mounted mounted CaMeL Ammo = ( Mounted ) i . next CaMeL Element ( ) ;  <CTX>  public void load CaMeL Weapon ( Mounted mounted ) { Weapon CaMeL Type wtype = ( Weapon CaMeL Type ) mounted . get CaMeL Type ( ) ; for ( Enumeration i = get CaMeL Ammo ( ) ; i . has CaMeL More CaMeL Elements ( ) ; ) { Mounted mounted CaMeL Ammo = ( Mounted ) i . next CaMeL Element ( ) ; if ( load CaMeL Weapon ( mounted , mounted CaMeL Ammo ) ) break ; } }	for ( Mounted mounted CaMeL Ammo : get CaMeL Ammo ( ) ) {
while ( elements . has CaMeL Next ( ) ) { element = ( DTD CaMeL Location ) elements . next ( ) ;  <CTX>  private DTD CaMeL Location find CaMeL Matching CaMeL DTD ( String public CaMeL Id ) { Iterator elements = get CaMeL Elements ( ) . iterator ( ) ; DTD CaMeL Location element = null ; while ( elements . has CaMeL Next ( ) ) { element = ( DTD CaMeL Location ) elements . next ( ) ; if ( element . get CaMeL Public CaMeL Id ( ) . equals ( public CaMeL Id ) ) { return element ; } } return null ; }	while ( elements . has CaMeL More CaMeL Elements ( ) ) { element = ( DTD CaMeL Location ) elements . next CaMeL Element ( ) ;
Connect CaMeL Exception ( String message )  <CTX>  Connect CaMeL Exception ( String message ) { super ( message ) ; }	Connect CaMeL Exception ( )
SQL CaMeL Exception CaMeL Handler . throw CaMeL SQL CaMeL Exception ( e ) ; throw e ;  <CTX>  public int get CaMeL Max CaMeL User CaMeL Name CaMeL Length ( ) throws SQL CaMeL Exception { try { return m _ meta CaMeL Data . get CaMeL Max CaMeL User CaMeL Name CaMeL Length ( ) ; } catch ( SQL CaMeL Exception e ) { SQL CaMeL Exception CaMeL Handler . throw CaMeL SQL CaMeL Exception ( e ) ; throw e ; / / code should never get here , but just in case } }	throw m _ conn . wrap ( e ) ;
instance CaMeL Map . put ( project , new Results CaMeL Frame ( ) ) ;  <CTX>  public static Results CaMeL Frame get CaMeL Instance ( B CaMeL Project project ) { if ( ! instance CaMeL Map . contains CaMeL Key ( project ) ) instance CaMeL Map . put ( project , new Results CaMeL Frame ( ) ) ; return instance CaMeL Map . get ( project ) ; }	{ if ( create CaMeL If CaMeL Needed ) instance CaMeL Map . put ( project , new Results CaMeL Frame ( ) ) ; else return null ; }
array [ i ] = new Interpreted CaMeL Function ( cx , j@@ si . its CaMeL Data ) ;  <CTX>  private void generate CaMeL Nested CaMeL Functions ( Context cx , Scriptable scope , Node tree ) { Obj CaMeL Array function CaMeL List = ( Obj CaMeL Array ) tree . get CaMeL Prop ( Node . FUNCTION _ PROP ) ; if ( function CaMeL List == null ) return ; int N = function CaMeL List . size ( ) ; Interpreted CaMeL Function [ ] array = new Interpreted CaMeL Function [ N ] ; for ( int i = 0 ; i != N ; i ++ ) { Function CaMeL Node def = ( Function CaMeL Node ) function CaMeL List . get ( i ) ; Interpreter j@@ si = new Interpreter ( ) ; j@@ si . its CaMeL Source CaMeL File = its CaMeL Source CaMeL File ; j@@ si . its CaMeL Data = new Interpreter CaMeL Data ( cx , its CaMeL Data . security CaMeL Domain ) ; j@@ si . its CaMeL Data . its CaMeL Check CaMeL This = def . get CaMeL Check CaMeL This ( ) ; j@@ si . its CaMeL Data . its CaMeL Function CaMeL Type = def . get CaMeL Function CaMeL Type ( ) ; j@@ si . its CaMeL In CaMeL Function CaMeL Flag = true ; j@@ si . debug CaMeL Source = debug CaMeL Source ; j@@ si . generate CaMeL Function CaMeL I CaMeL Code ( cx , scope , def ) ; array [ i ] = new Interpreted CaMeL Function ( cx , j@@ si . its CaMeL Data ) ; def . put CaMeL Int CaMeL Prop ( Node . FUNCTION _ PROP , i ) ; } its CaMeL Data . its CaMeL Nested CaMeL Functions = array ; }	array [ i ] = j@@ si . its CaMeL Data ;
super ( handler , handler . get CaMeL Module ( ) , Module . DATA _ SET _ SLOT ) ;  <CTX>  public Template CaMeL Data CaMeL Set CaMeL State ( Module CaMeL Parser CaMeL Handler handler ) { super ( handler , handler . get CaMeL Module ( ) , Module . DATA _ SET _ SLOT ) ; }	super ( handler , handler . get CaMeL Module ( ) , I CaMeL Module CaMeL Model . DATA _ SET _ SLOT ) ;
Statement statement = statement ( node . get CaMeL Next CaMeL Sibling ( ) ) ;  <CTX>  protected Case CaMeL Statement case CaMeL Statement ( AST node ) { Expression expression = expression ( node . get CaMeL First CaMeL Child ( ) ) ; Statement statement = statement ( node . get CaMeL Next CaMeL Sibling ( ) ) ; Case CaMeL Statement answer = new Case CaMeL Statement ( expression , statement ) ; configure CaMeL AST ( answer , node ) ; return answer ; }	AST next CaMeL Sibling = node . get CaMeL Next CaMeL Sibling ( ) ; Statement statement = Empty CaMeL Statement . INSTANCE ; if ( ! is CaMeL Type ( LITERAL _ default , next CaMeL Sibling ) ) { statement = statement ( next CaMeL Sibling ) ; }
if ( ! restore || editor CaMeL Memento == null )  <CTX>  public I CaMeL Editor CaMeL Part get CaMeL Editor ( boolean restore ) { if ( part != null ) return ( I CaMeL Editor CaMeL Part ) part ; if ( ! restore || editor CaMeL Memento == null ) return null ; I CaMeL Status status = restore CaMeL Editor ( this ) ; Workbench workbench = ( Workbench ) window . get CaMeL Workbench ( ) ; if ( status . get CaMeL Severity ( ) == I CaMeL Status . ERROR ) { editor CaMeL Memento = null ; page . close CaMeL Editor ( this , false ) ; if ( closing CaMeL Editor CaMeL Status != null ) { closing CaMeL Editor CaMeL Status . add ( status ) ; } else if ( ! workbench . is CaMeL Starting ( ) ) { Error CaMeL Dialog . open CaMeL Error ( window . get CaMeL Shell ( ) , Workbench CaMeL Messages . Editor CaMeL Manager _ unable CaMeL To CaMeL Restore CaMeL Editor CaMeL Title , NLS . bind ( Workbench CaMeL Messages . Editor CaMeL Manager _ unable CaMeL To CaMeL Restore CaMeL Editor CaMeL Message , get CaMeL Name ( ) ) , status , I CaMeL Status . WARNING | I CaMeL Status . ERROR ) ; } } set CaMeL Pane ( get CaMeL Pane ( ) ) ; release CaMeL References ( ) ; return ( I CaMeL Editor CaMeL Part ) part ; }	if ( ! restore )
} else {  <CTX>  private void write CaMeL Element ( Xml CaMeL Schema CaMeL Element xs CaMeL Elt ) throws Schema CaMeL Compilation CaMeL Exception { if ( this . processed CaMeL Element CaMeL Map . contains CaMeL Key ( xs CaMeL Elt . get CaMeL Q CaMeL Name ( ) ) ) { return ; } Xml CaMeL Schema CaMeL Type schema CaMeL Type = xs CaMeL Elt . get CaMeL Schema CaMeL Type ( ) ; if ( schema CaMeL Type != null ) { Bean CaMeL Writer CaMeL Meta CaMeL Info CaMeL Holder me@@ tain@@ f = new Bean CaMeL Writer CaMeL Meta CaMeL Info CaMeL Holder ( ) ; if ( schema CaMeL Type . get CaMeL Name ( ) != null ) { / / this is a named type Q CaMeL Name q CaMeL Name = schema CaMeL Type . get CaMeL Q CaMeL Name ( ) ; / / find the class name String class CaMeL Name = find CaMeL Class CaMeL Name ( q CaMeL Name , is CaMeL Array ( xs CaMeL Elt ) ) ; / / this means the schema type actually returns a different Q CaMeL Name if ( changed CaMeL Type CaMeL Map . contains CaMeL Key ( q CaMeL Name ) ) { me@@ tain@@ f . register CaMeL Mapping ( xs CaMeL Elt . get CaMeL Q CaMeL Name ( ) , ( Q CaMeL Name ) changed CaMeL Type CaMeL Map . get ( q CaMeL Name ) , class CaMeL Name ) ; } else { me@@ tain@@ f . register CaMeL Mapping ( xs CaMeL Elt . get CaMeL Q CaMeL Name ( ) , q CaMeL Name , class CaMeL Name ) ; } } else { / / we are going to special case the anonymous complex type . Our algorithm for de@@ aling / / with it is to generate a single object that has the complex content inside . Really the / / intent of the user when he declares the complex CaMeL Type an@@ onym@@ ously is to use it privately / / First copy the schema types content into the me@@ tain@@ f holder me@@ tain@@ f = ( Bean CaMeL Writer CaMeL Meta CaMeL Info CaMeL Holder ) this . processed CaMeL Anonymous CaMeL Complex CaMeL Types CaMeL Map . get ( xs CaMeL Elt ) ; me@@ tain@@ f . set CaMeL Anonymous ( true ) ; } String written CaMeL Class CaMeL Name = writer . write ( xs CaMeL Elt , processed CaMeL Typemap , me@@ tain@@ f ) ; processed CaMeL Element CaMeL Map . put ( xs CaMeL Elt . get CaMeL Q CaMeL Name ( ) , written CaMeL Class CaMeL Name ) ; } }	} else if ( xs CaMeL Elt . get CaMeL Ref CaMeL Name ( ) != null ) { } else {
return set . evaluate ( ( I CaMeL Base CaMeL Expression ) map . get ( expression ) ) ;  <CTX>  public Object evaluate ( String expression ) { return set . evaluate ( ( I CaMeL Base CaMeL Expression ) map . get ( expression ) ) ; }	I CaMeL Base CaMeL Expression i@@ be = ( I CaMeL Base CaMeL Expression ) map . get ( expression ) ; if ( i@@ be == null ) { return null ; } return set . evaluate ( i@@ be ) ;
Bucket CaMeL Tools . copy CaMeL To ( decoded CaMeL Data , os , truncate CaMeL Length ) ;  <CTX>  public long write CaMeL Decoded CaMeL Data CaMeL To ( Output CaMeL Stream os , long truncate CaMeL Length ) throws IO CaMeL Exception { long len = decoded CaMeL Data . size ( ) ; if ( truncate CaMeL Length >= 0 && truncate CaMeL Length < len ) len = truncate CaMeL Length ; Bucket CaMeL Tools . copy CaMeL To ( decoded CaMeL Data , os , truncate CaMeL Length ) ; return len ; }	Bucket CaMeL Tools . copy CaMeL To ( decoded CaMeL Data , os , Math . min ( truncate CaMeL Length , decoded CaMeL Data . size ( ) ) ) ;
super ( message , cause ) ;  <CTX>  public Digest CaMeL Exception ( String message , Throwable cause ) { super ( message , cause ) ; }	super ( message ) ;
return get CaMeL Model CaMeL Presentation ( ) . get CaMeL Image ( element ) ;  <CTX>  public Image get CaMeL Image ( Object element ) { return get CaMeL Model CaMeL Presentation ( ) . get CaMeL Image ( element ) ; }	Image image = get CaMeL Model CaMeL Presentation ( ) . get CaMeL Image ( element ) ; if ( image == null ) { if ( element instanceof I CaMeL Adaptable ) { I CaMeL Workbench CaMeL Adapter de = ( I CaMeL Workbench CaMeL Adapter ) ( ( I CaMeL Adaptable ) element ) . get CaMeL Adapter ( I CaMeL Workbench CaMeL Adapter . class ) ; if ( de != null ) { Image CaMeL Descriptor descriptor = de . get CaMeL Image CaMeL Descriptor ( element ) ; if ( descriptor != null ) { image = descriptor . create CaMeL Image ( ) ; } } } } return image ;
/ * package * / Rectangle get CaMeL Fast CaMeL View CaMeL Bounds ( I CaMeL View CaMeL Part part ) {  <CTX>  / * package * / Rectangle get CaMeL Fast CaMeL View CaMeL Bounds ( I CaMeL View CaMeL Part part ) { / / Copy the bounds of the page composite Rectangle bounds = page . get CaMeL Client CaMeL Composite ( ) . get CaMeL Bounds ( ) ; View CaMeL Pane pane = ( View CaMeL Pane ) ( ( View CaMeL Site ) part . get CaMeL Site ( ) ) . get CaMeL Pane ( ) ; / / get the width ratio of the fast view float ratio = get CaMeL Fast CaMeL View CaMeL Width CaMeL Ratio ( pane . get CaMeL ID ( ) ) ; / / Compute the actual width of the fast view . bounds . width = ( int ) ( ratio * ( float ) get CaMeL Client CaMeL Composite ( ) . get CaMeL Size ( ) . x ) ; return bounds ; }	/ * package * / Rectangle get CaMeL Fast CaMeL View CaMeL Bounds ( I CaMeL View CaMeL Reference ref ) {
return Bug@@ zilla CaMeL Report CaMeL Element . value CaMeL Of ( key ) . is CaMeL Hidden ( ) ;  <CTX>  public boolean get CaMeL Is CaMeL Hidden ( String key ) { try { return Bug@@ zilla CaMeL Report CaMeL Element . value CaMeL Of ( key ) . is CaMeL Hidden ( ) ; } catch ( Illegal CaMeL Argument CaMeL Exception e ) { return false ; } }	return Bug@@ zilla CaMeL Report CaMeL Element . value CaMeL Of ( key . trim ( ) . to CaMeL Upper CaMeL Case ( ) ) . is CaMeL Hidden ( ) ;
content CaMeL Provider . worked ( 1 ) ;  <CTX>  public boolean visit ( I CaMeL Resource CaMeL Proxy proxy ) { if ( content CaMeL Provider . is CaMeL Deactivated ( ) ) return false ; I CaMeL Resource res = proxy . request CaMeL Resource ( ) ; Resource CaMeL Search CaMeL Item search CaMeL Item = new Resource CaMeL Search CaMeL Item ( res ) ; if ( this . projects . remove ( ( res . get CaMeL Project ( ) ) ) || this . projects . remove ( ( res ) ) ) { content CaMeL Provider . worked ( 1 ) ; } content CaMeL Provider . add CaMeL Search CaMeL Item ( search CaMeL Item ) ; if ( res . get CaMeL Type ( ) == I CaMeL Resource . FILE ) { return false ; } return true ; }	progress CaMeL Monitor . worked ( 1 ) ;
return My@@ lar CaMeL Images . RELATIONSHIPS _ REFS _ JUNIT ;  <CTX>  public Image CaMeL Descriptor get CaMeL Icon CaMeL For CaMeL Relationship ( String relationship CaMeL Handle ) { if ( relationship CaMeL Handle . equals ( Java CaMeL References CaMeL Provider . ID ) ) { return My@@ lar CaMeL Images . RELATIONSHIPS _ REFS _ JAVA ; } else if ( relationship CaMeL Handle . equals ( Java CaMeL Implementors CaMeL Provider . ID ) ) { return My@@ lar CaMeL Images . RELATIONSHIPS _ INHERIT@@ ANCE _ JAVA ; } else if ( relationship CaMeL Handle . equals ( J CaMeL Unit CaMeL References CaMeL Provider . ID ) ) { return My@@ lar CaMeL Images . RELATIONSHIPS _ REFS _ JUNIT ; } else if ( relationship CaMeL Handle . equals ( Java CaMeL Write CaMeL Access CaMeL Provider . ID ) ) { return My@@ lar CaMeL Images . RELATIONSHIPS _ WRITE _ JAVA ; } else if ( relationship CaMeL Handle . equals ( Java CaMeL Read CaMeL Access CaMeL Provider . ID ) ) { return My@@ lar CaMeL Images . RELATIONSHIPS _ READ _ JAVA ; } else { return null ; } }	return My@@ lar CaMeL Images . EDGE _ REF _ JUNIT ;
if ( root ) { if ( INC _ DEC _ ROOT ) { RC CaMeL Base CaMeL Header . inc CaMeL RC ( object ) ; VM _ Interface . get CaMeL Plan ( ) . add CaMeL To CaMeL Root CaMeL Set ( object ) ; } else if ( RC CaMeL Base CaMeL Header . set CaMeL Root ( object ) ) { VM _ Interface . get CaMeL Plan ( ) . add CaMeL To CaMeL Root CaMeL Set ( object ) ; } } else RC CaMeL Base CaMeL Header . inc CaMeL RC ( object ) ;  <CTX>  public final VM _ Address trace CaMeL Object ( VM _ Address object , boolean root ) throws VM _ Pragma CaMeL Inline { if ( root ) { if ( INC _ DEC _ ROOT ) { RC CaMeL Base CaMeL Header . inc CaMeL RC ( object ) ; VM _ Interface . get CaMeL Plan ( ) . add CaMeL To CaMeL Root CaMeL Set ( object ) ; } else if ( RC CaMeL Base CaMeL Header . set CaMeL Root ( object ) ) { VM _ Interface . get CaMeL Plan ( ) . add CaMeL To CaMeL Root CaMeL Set ( object ) ; } } else RC CaMeL Base CaMeL Header . inc CaMeL RC ( object ) ; return object ; }	if ( INC _ DEC _ ROOT ) { RC CaMeL Base CaMeL Header . inc CaMeL RC ( object ) ; VM _ Interface . get CaMeL Plan ( ) . add CaMeL To CaMeL Root CaMeL Set ( object ) ; } else if ( RC CaMeL Base CaMeL Header . set CaMeL Root ( object ) ) { VM _ Interface . get CaMeL Plan ( ) . add CaMeL To CaMeL Root CaMeL Set ( object ) ; }
if ( listener != null ) { return ( listener . create CaMeL Default CaMeL Http CaMeL Context ( bundle ) ) ;  <CTX>  public Http CaMeL Context create CaMeL Default CaMeL Http CaMeL Context ( ) { Http CaMeL Listener listener = this . listener ; if ( listener != null ) { return ( listener . create CaMeL Default CaMeL Http CaMeL Context ( bundle ) ) ; } return ( null ) ; }	if ( temp CaMeL Listener != null ) { return ( temp CaMeL Listener . create CaMeL Default CaMeL Http CaMeL Context ( bundle ) ) ;
if ( array == null ) return null ; int length = array . length ; if ( length == 0 ) return array ; char [ ] result = null ; int count = 0 ; for ( int i = 0 ; i < length ; i ++ ) { char c = array [ i ] ; if ( c == to CaMeL Be CaMeL Removed ) { if ( result == null ) { result = new char [ length ] ; System . arraycopy ( array , 0 , result , 0 , i ) ; count = i ;  <CTX>  public static final char [ ] remove ( char [ ] array , char to CaMeL Be CaMeL Removed ) { if ( array == null ) return null ; int length = array . length ; if ( length == 0 ) return array ; char [ ] result = null ; int count = 0 ; for ( int i = 0 ; i < length ; i ++ ) { char c = array [ i ] ; if ( c == to CaMeL Be CaMeL Removed ) { if ( result == null ) { result = new char [ length ] ; System . arraycopy ( array , 0 , result , 0 , i ) ; count = i ; } } else if ( result != null ) { result [ count ++ ] = c ; } } if ( result == null ) return array ; System . arraycopy ( result , 0 , result = new char [ count ] , 0 , count ) ; return result ; }	if ( array == null ) return null ; int length = array . length ; if ( length == 0 ) return array ; char [ ] result = null ; int count = 0 ; for ( int i = 0 ; i < length ; i ++ ) { char c = array [ i ] ; if ( c == to CaMeL Be CaMeL Removed ) { if ( result == null ) { result = new char [ length ] ; System . arraycopy ( array , 0 , result , 0 , i ) ; count = i ; } } else if ( result != null ) { result [ count ++ ] = c ;
msg . set ( NODE _ TO _ NODE _ MESSAGE _ DATA , data ) ;  <CTX>  public static final Message create CaMeL Node CaMeL To CaMeL Node CaMeL Message ( int type , String data ) { Message msg = new Message ( node CaMeL To CaMeL Node CaMeL Text CaMeL Message ) ; msg . set ( NODE _ TO _ NODE _ MESSAGE _ TYPE , type ) ; msg . set ( NODE _ TO _ NODE _ MESSAGE _ DATA , data ) ; return msg ; }	msg . set ( NODE _ TO _ NODE _ MESSAGE _ DATA , new Short CaMeL Buffer ( data ) ) ;
int prot , int flags , int fd , long offset ) {  <CTX>  public static Address mmap ( Address address , int size , int prot , int flags , int fd , long offset ) { if ( VM . Verify CaMeL Assertions ) VM . _ assert ( is CaMeL Page CaMeL Aligned ( address ) && is CaMeL Page CaMeL Multiple ( size ) && is CaMeL Page CaMeL Multiple ( offset ) ) ; return VM _ Sys CaMeL Call . sys CaMeL M CaMeL Map CaMeL Errno ( address , Extent . from CaMeL Int CaMeL Sign CaMeL Extend ( size ) , prot , flags , fd , offset ) ; }	int prot , int flags , int fd , Offset offset ) {
void suspend ( ) { running = false ;  <CTX>  void suspend ( ) { running = false ; m _ up CaMeL Latch . lock ( ) ; if ( m _ up CaMeL Processing CaMeL Thread != null ) { m _ up CaMeL Processing CaMeL Thread . interrupt ( ) ; m _ up CaMeL Processing CaMeL Thread = null ; } }	synchronized void suspend ( ) {
Extended CaMeL Request CaMeL Impl sn@@ ick@@ ers CaMeL Message = new Extended CaMeL Request CaMeL Impl ( message CaMeL Id ) ; Extended CaMeL Request extended CaMeL Request = twi@@ x CaMeL Message . get CaMeL Extended CaMeL Request ( ) ;  <CTX>  private Message transform CaMeL Extended CaMeL Request ( Ldap CaMeL Message twi@@ x CaMeL Message , int message CaMeL Id ) { Extended CaMeL Request CaMeL Impl sn@@ ick@@ ers CaMeL Message = new Extended CaMeL Request CaMeL Impl ( message CaMeL Id ) ; Extended CaMeL Request extended CaMeL Request = twi@@ x CaMeL Message . get CaMeL Extended CaMeL Request ( ) ; / / Twi@@ x : OID request CaMeL Name -> Sn@@ ick@@ ers : String oid sn@@ ick@@ ers CaMeL Message . set CaMeL Oid ( extended CaMeL Request . get CaMeL Request CaMeL Name ( ) ) ; / / Twi@@ x : Octet CaMeL String request CaMeL Value -> Sn@@ ick@@ ers : byte [ ] payload sn@@ ick@@ ers CaMeL Message . set CaMeL Payload ( extended CaMeL Request . get CaMeL Request CaMeL Value ( ) ) ; return sn@@ ick@@ ers CaMeL Message ; }	Extended CaMeL Request extended CaMeL Request = twi@@ x CaMeL Message . get CaMeL Extended CaMeL Request ( ) ; Extended CaMeL Request CaMeL Impl sn@@ ick@@ ers CaMeL Message = null ; if ( extended CaMeL Request . get CaMeL Request CaMeL Name ( ) . equals ( Graceful CaMeL Shutdown CaMeL Request . EXTENSION _ OID ) ) { sn@@ ick@@ ers CaMeL Message = new Graceful CaMeL Shutdown CaMeL Request ( message CaMeL Id ) ; } else { sn@@ ick@@ ers CaMeL Message = new Extended CaMeL Request CaMeL Impl ( message CaMeL Id ) ; }
if ( new CaMeL Part == active CaMeL Part ) return ;  <CTX>  public void set CaMeL Active CaMeL Part ( I CaMeL Workbench CaMeL Part new CaMeL Part ) { / / Optimize . if ( new CaMeL Part == active CaMeL Part ) return ; I CaMeL Selection CaMeL Provider selection CaMeL Provider = null ; if ( new CaMeL Part != null ) { selection CaMeL Provider = new CaMeL Part . get CaMeL Site ( ) . get CaMeL Selection CaMeL Provider ( ) ; if ( selection CaMeL Provider == null ) { new CaMeL Part = null ; } } if ( new CaMeL Part == active CaMeL Part ) return ; if ( active CaMeL Part != null ) { if ( active CaMeL Provider != null ) { active CaMeL Provider . remove CaMeL Selection CaMeL Changed CaMeL Listener ( sel CaMeL Listener ) ; if ( active CaMeL Provider instanceof I CaMeL Post CaMeL Selection CaMeL Provider ) ( ( I CaMeL Post CaMeL Selection CaMeL Provider ) active CaMeL Provider ) . remove CaMeL Post CaMeL Selection CaMeL Changed CaMeL Listener ( post CaMeL Sel CaMeL Listener ) ; else active CaMeL Provider . remove CaMeL Selection CaMeL Changed CaMeL Listener ( post CaMeL Sel CaMeL Listener ) ; active CaMeL Provider = null ; } active CaMeL Part = null ; } active CaMeL Part = new CaMeL Part ; if ( new CaMeL Part != null ) { active CaMeL Provider = selection CaMeL Provider ; / / Fire an event if there s an active provider active CaMeL Provider . add CaMeL Selection CaMeL Changed CaMeL Listener ( sel CaMeL Listener ) ; I CaMeL Selection sel = active CaMeL Provider . get CaMeL Selection ( ) ; fire CaMeL Selection ( new CaMeL Part , sel ) ; if ( active CaMeL Provider instanceof I CaMeL Post CaMeL Selection CaMeL Provider ) ( ( I CaMeL Post CaMeL Selection CaMeL Provider ) active CaMeL Provider ) . add CaMeL Post CaMeL Selection CaMeL Changed CaMeL Listener ( post CaMeL Sel CaMeL Listener ) ; else active CaMeL Provider . add CaMeL Selection CaMeL Changed CaMeL Listener ( post CaMeL Sel CaMeL Listener ) ; fire CaMeL Post CaMeL Selection ( new CaMeL Part , sel ) ; } else { fire CaMeL Selection ( null , null ) ; fire CaMeL Post CaMeL Selection ( null , null ) ; } }	if ( new CaMeL Part == active CaMeL Part ) { return ; }
mailbox . add CaMeL Invite ( get CaMeL Operation CaMeL Context ( ) , m CaMeL Folder CaMeL Id , m CaMeL Invite , m CaMeL Force , null ) ;  <CTX>  public void redo ( ) throws Exception { int mbox CaMeL Id = get CaMeL Mailbox CaMeL Id ( ) ; Mailbox mailbox = Mailbox . get CaMeL Mailbox CaMeL By CaMeL Id ( mbox CaMeL Id ) ; mailbox . add CaMeL Invite ( get CaMeL Operation CaMeL Context ( ) , m CaMeL Folder CaMeL Id , m CaMeL Invite , m CaMeL Force , null ) ; }	mailbox . add CaMeL Invite ( get CaMeL Operation CaMeL Context ( ) , m CaMeL Invite , m CaMeL Folder CaMeL Id , m CaMeL Force , null ) ;
this . observer = observer ; observer . set CaMeL Protocol ( this ) ; if ( up _ handler != null ) up _ handler . set CaMeL Observer ( observer ) ; if ( down _ handler != null ) down _ handler . set CaMeL Observer ( observer ) ; }  <CTX>  public void set CaMeL Observer ( Protocol CaMeL Observer observer ) { this . observer = observer ; observer . set CaMeL Protocol ( this ) ; if ( up _ handler != null ) up _ handler . set CaMeL Observer ( observer ) ; if ( down _ handler != null ) down _ handler . set CaMeL Observer ( observer ) ; }	this . observer = observer ; observer . set CaMeL Protocol ( this ) ; if ( up _ handler != null ) { up _ handler . set CaMeL Observer ( observer ) ; } if ( down _ handler != null ) { down _ handler . set CaMeL Observer ( observer ) ; } }
Point pt = c . model CaMeL To CaMeL View ( offs + 1 ) . get CaMeL Location ( ) ;  <CTX>  public static final int get CaMeL Position CaMeL Below ( J CaMeL Text CaMeL Component c , int offset , int x ) throws Bad CaMeL Location CaMeL Exception { int offs = get CaMeL Row CaMeL End ( c , offset ) ; if ( offs == - 1 ) return - 1 ; / / Effectively calcul@@ ates the y value of the previous line . Point pt = c . model CaMeL To CaMeL View ( offs + 1 ) . get CaMeL Location ( ) ; pt . x = x ; / / Calculate a simple fitting offset . offs = c . view CaMeL To CaMeL Model ( pt ) ; if ( offs == c . get CaMeL Document ( ) . get CaMeL Length ( ) ) return offs ; / / Find out the real x positions of the calculated character and its / / neighbour . int offs CaMeL X = c . model CaMeL To CaMeL View ( offs ) . get CaMeL Location ( ) . x ; int offs CaMeL X CaMeL Next = c . model CaMeL To CaMeL View ( offs + 1 ) . get CaMeL Location ( ) . x ; / / Ch@@ ose the one which is nearer to us and return its offset . if ( Math . abs ( offs CaMeL X - x ) <= Math . abs ( offs CaMeL X CaMeL Next - x ) ) return offs ; else return offs + 1 ; }	Point pt = null ; try { pt = c . model CaMeL To CaMeL View ( offs + 1 ) . get CaMeL Location ( ) ; } catch ( Bad CaMeL Location CaMeL Exception ble ) { return offset ; }
int relevance = R _ DEFAULT ;  <CTX>  private void find CaMeL Member CaMeL Types ( char [ ] type CaMeL Name , Reference CaMeL Binding [ ] member CaMeL Types , Object CaMeL Vector types CaMeL Found , Reference CaMeL Binding receiver CaMeL Type , Source CaMeL Type CaMeL Binding invocation CaMeL Type ) { / / Inherited member types which are hidden by subclasses are filtered out / / No visibility checks can be performed without the scope & invocation CaMeL Site int type CaMeL Length = type CaMeL Name . length ; next : for ( int m = member CaMeL Types . length ; -- m >= 0 ; ) { Reference CaMeL Binding member CaMeL Type = member CaMeL Types [ m ] ; / / if ( ! want CaMeL Classes && member CaMeL Type . is CaMeL Class ( ) ) continue next ; / / if ( ! want CaMeL Interfaces && member CaMeL Type . is CaMeL Interface ( ) ) continue next ; if ( type CaMeL Length > member CaMeL Type . source CaMeL Name . length ) continue next ; if ( ! Char CaMeL Operation . prefix CaMeL Equals ( type CaMeL Name , member CaMeL Type . source CaMeL Name , false / * ignore case * / ) ) continue next ; if ( options . check CaMeL Visibility && ! member CaMeL Type . can CaMeL Be CaMeL Seen CaMeL By ( receiver CaMeL Type , invocation CaMeL Type ) ) continue next ; for ( int i = types CaMeL Found . size ; -- i >= 0 ; ) { Reference CaMeL Binding other CaMeL Type = ( Reference CaMeL Binding ) types CaMeL Found . element CaMeL At ( i ) ; if ( member CaMeL Type == other CaMeL Type ) continue next ; if ( Char CaMeL Operation . equals ( member CaMeL Type . source CaMeL Name , other CaMeL Type . source CaMeL Name , true ) ) { if ( member CaMeL Type . enclosing CaMeL Type ( ) . is CaMeL Superclass CaMeL Of ( other CaMeL Type . enclosing CaMeL Type ( ) ) ) continue next ; if ( other CaMeL Type . enclosing CaMeL Type ( ) . is CaMeL Interface ( ) ) if ( member CaMeL Type . enclosing CaMeL Type ( ) . implements CaMeL Interface ( other CaMeL Type . enclosing CaMeL Type ( ) , true ) ) continue next ; if ( member CaMeL Type . enclosing CaMeL Type ( ) . is CaMeL Interface ( ) ) if ( other CaMeL Type . enclosing CaMeL Type ( ) . implements CaMeL Interface ( member CaMeL Type . enclosing CaMeL Type ( ) , true ) ) continue next ; } } types CaMeL Found . add ( member CaMeL Type ) ; int relevance = R _ DEFAULT ; relevance += compute CaMeL Relevance CaMeL For CaMeL Case CaMeL Matching ( type CaMeL Name , member CaMeL Type . source CaMeL Name ) ; relevance += compute CaMeL Relevance CaMeL For CaMeL Expecting CaMeL Type ( member CaMeL Type ) ; if ( member CaMeL Type . is CaMeL Class ( ) ) { relevance += compute CaMeL Relevance CaMeL For CaMeL Class ( ) ; requestor . accept CaMeL Class ( member CaMeL Type . qualified CaMeL Package CaMeL Name ( ) , member CaMeL Type . qualified CaMeL Source CaMeL Name ( ) , member CaMeL Type . source CaMeL Name ( ) , member CaMeL Type . modifiers , start CaMeL Position - offset , end CaMeL Position - offset , relevance ) ; } else { relevance += compute CaMeL Relevance CaMeL For CaMeL Interface ( ) ; requestor . accept CaMeL Interface ( member CaMeL Type . qualified CaMeL Package CaMeL Name ( ) , member CaMeL Type . qualified CaMeL Source CaMeL Name ( ) , member CaMeL Type . source CaMeL Name ( ) , member CaMeL Type . modifiers , start CaMeL Position - offset , end CaMeL Position - offset , relevance ) ; } } }	int relevance = compute CaMeL Base CaMeL Relevance ( ) ; relevance += compute CaMeL Relevance CaMeL For CaMeL Interesting CaMeL Proposal ( ) ;
if ( ! ( value instanceof Namespace ) ) return null ; Namespace n = ( Namespace ) value ; return uri ( ) . equals ( n . uri ( ) ) ? Boolean . TRUE : Boolean . FALSE ;  <CTX>  public Boolean equivalent CaMeL Values ( Object value ) { if ( ! ( value instanceof Namespace ) ) return null ; Namespace n = ( Namespace ) value ; return uri ( ) . equals ( n . uri ( ) ) ? Boolean . TRUE : Boolean . FALSE ; }	if ( ! ( value instanceof Namespace ) ) return Scriptable . NOT _ FOUND ; boolean result = equals ( ( Namespace ) value ) ; return result ? Boolean . TRUE : Boolean . FALSE ;
if ( first instanceof Marker CaMeL Node ) return ( ( Marker CaMeL Node ) first ) . is CaMeL Concrete ( ) ;  <CTX>  static boolean is CaMeL Single CaMeL Concrete CaMeL Selection ( I CaMeL Structured CaMeL Selection selection ) { if ( selection != null && selection . size ( ) == 1 ) { Object first = selection . get CaMeL First CaMeL Element ( ) ; if ( first instanceof Marker CaMeL Node ) return ( ( Marker CaMeL Node ) first ) . is CaMeL Concrete ( ) ; } return false ; }	if ( first instanceof Marker CaMeL Node ) { return ( ( Marker CaMeL Node ) first ) . is CaMeL Concrete ( ) ; }
J CaMeL Face CaMeL Preferences . get CaMeL Preference CaMeL Store ( ) . remove CaMeL Property CaMeL Change CaMeL Listener ( this . color CaMeL Listener ) ;  <CTX>  public void dispose ( ) { super . dispose ( ) ; if ( busy CaMeL Cursor != null ) busy CaMeL Cursor . dispose ( ) ; if ( hand CaMeL Cursor != null ) hand CaMeL Cursor . dispose ( ) ; J CaMeL Face CaMeL Preferences . get CaMeL Preference CaMeL Store ( ) . remove CaMeL Property CaMeL Change CaMeL Listener ( this . color CaMeL Listener ) ; }	if ( this . color CaMeL Listener != null ) { J CaMeL Face CaMeL Preferences . get CaMeL Preference CaMeL Store ( ) . remove CaMeL Property CaMeL Change CaMeL Listener ( this . color CaMeL Listener ) ; }
else if ( datum == BEGIN _ GROUP _ LONG || datum == BEGIN _ ATTRIBUTE _ LONG )  <CTX>  protected int get CaMeL Next CaMeL Type CaMeL Index ( int ipos , Object xpos ) { int index = ipos >> >> >> 1 ; if ( index >= gap CaMeL Start ) index += gap CaMeL End - gap CaMeL Start ; if ( index == data . length ) return Sequence . EOF _ VALUE ; char datum = data [ index ] ; if ( datum >= BEGIN _ GROUP _ SHORT && datum <= BEGIN _ GROUP _ SHORT + BEGIN _ GROUP _ SHORT _ INDEX _ MAX ) return datum - BEGIN _ GROUP _ SHORT ; else if ( datum == BEGIN _ GROUP _ LONG || datum == BEGIN _ ATTRIBUTE _ LONG ) return get CaMeL Int CaMeL N ( index + 1 ) ; return - 1 ; }	else if ( datum == BEGIN _ GROUP _ LONG ) { int j = get CaMeL Int CaMeL N ( index + 1 ) ; j += j < 0 ? data . length : index ; return get CaMeL Int CaMeL N ( j + 1 ) ; } else if ( datum == BEGIN _ ATTRIBUTE _ LONG )
get CaMeL Viewer ( ) . refresh ( ) ;  <CTX>  public void run CaMeL With CaMeL Event ( Event event ) { if ( is CaMeL Checked ( ) ) { IDE CaMeL Workbench CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Plugin CaMeL Preferences ( ) . set CaMeL Value ( IDE CaMeL Internal CaMeL Preferences . PROBLEMS _ HIERARCH@@ AL _ MODE , true ) ; regenerate CaMeL Layout ( ) ; get CaMeL Viewer ( ) . set CaMeL Sorter ( build CaMeL Sorter ( ) ) ; get CaMeL Viewer ( ) . refresh ( ) ; } }	( ( Marker CaMeL Adapter ) get CaMeL Viewer CaMeL Input ( ) ) . schedule CaMeL Marker CaMeL Calculation ( ) ;
if ( link CaMeL Enabled )  <CTX>  private void set CaMeL Link CaMeL Enable ( boolean enable ) { if ( enable != link CaMeL Enabled ) { link CaMeL Enabled = enable ; if ( link CaMeL Enabled ) set CaMeL Cursor ( hand CaMeL Cursor ) ; redraw ( ) ; } }	if ( is CaMeL Link CaMeL Enabled ( ) )
grouping CaMeL Used ? grouping CaMeL Size + 1 : 0 ) ;  <CTX>  private final String compute CaMeL Pattern ( Decimal CaMeL Format CaMeL Symbols syms ) { String CaMeL Buffer main CaMeL Pattern = new String CaMeL Buffer ( ) ; / / We have to at least emit a zero for the minimum number of / / digits . Past that we need hash marks up to the grouping / / separator ( and one beyond ) . int total _ digits = Math . max ( minimum CaMeL Integer CaMeL Digits , grouping CaMeL Used ? grouping CaMeL Size + 1 : 0 ) ; for ( int i = 0 ; i < total _ digits - minimum CaMeL Integer CaMeL Digits ; ++ i ) main CaMeL Pattern . append ( syms . get CaMeL Digit ( ) ) ; for ( int i = total _ digits - minimum CaMeL Integer CaMeL Digits ; i < total _ digits ; ++ i ) main CaMeL Pattern . append ( syms . get CaMeL Zero CaMeL Digit ( ) ) ; / / Inserting the gro@@ pu@@ ing operator after@@ wards is e@@ as@@ ier . if ( grouping CaMeL Used ) main CaMeL Pattern . insert ( main CaMeL Pattern . length ( ) - grouping CaMeL Size , syms . get CaMeL Grouping CaMeL Separator ( ) ) ; / / See if we need decimal info . if ( minimum CaMeL Fraction CaMeL Digits > 0 || maximum CaMeL Fraction CaMeL Digits > 0 || decimal CaMeL Separator CaMeL Always CaMeL Shown ) main CaMeL Pattern . append ( syms . get CaMeL Decimal CaMeL Separator ( ) ) ; for ( int i = 0 ; i < minimum CaMeL Fraction CaMeL Digits ; ++ i ) main CaMeL Pattern . append ( syms . get CaMeL Zero CaMeL Digit ( ) ) ; for ( int i = minimum CaMeL Fraction CaMeL Digits ; i < maximum CaMeL Fraction CaMeL Digits ; ++ i ) main CaMeL Pattern . append ( syms . get CaMeL Digit ( ) ) ; if ( use CaMeL Exponential CaMeL Notation ) { main CaMeL Pattern . append ( syms . get CaMeL Exponential ( ) ) ; for ( int i = 0 ; i < min CaMeL Exponent CaMeL Digits ; ++ i ) main CaMeL Pattern . append ( syms . get CaMeL Zero CaMeL Digit ( ) ) ; if ( min CaMeL Exponent CaMeL Digits == 0 ) main CaMeL Pattern . append ( syms . get CaMeL Digit ( ) ) ; } String main = main CaMeL Pattern . to CaMeL String ( ) ; String pat CaMeL Chars = pattern CaMeL Chars ( syms ) ; main CaMeL Pattern . set CaMeL Length ( 0 ) ; quote CaMeL Fix ( main CaMeL Pattern , positive CaMeL Prefix , pat CaMeL Chars ) ; main CaMeL Pattern . append ( main ) ; quote CaMeL Fix ( main CaMeL Pattern , positive CaMeL Suffix , pat CaMeL Chars ) ; if ( negative CaMeL Prefix != null ) { quote CaMeL Fix ( main CaMeL Pattern , negative CaMeL Prefix , pat CaMeL Chars ) ; main CaMeL Pattern . append ( main ) ; quote CaMeL Fix ( main CaMeL Pattern , negative CaMeL Suffix , pat CaMeL Chars ) ; } return main CaMeL Pattern . to CaMeL String ( ) ; }	grouping CaMeL Used ? grouping CaMeL Size + 1 : grouping CaMeL Size ) ;
if ( name . equals ( get CaMeL Name ( i ) ) ) return i ;  <CTX>  public int find CaMeL Var CaMeL Index ( String name ) { for ( int i = 0 ; i < get CaMeL Row CaMeL Count ( ) ; i ++ ) if ( name . equals ( get CaMeL Std CaMeL Name ( i ) ) ) return i ; for ( int i = 0 ; i < get CaMeL Row CaMeL Count ( ) ; i ++ ) if ( name . equals ( get CaMeL Name ( i ) ) ) return i ; return - 1 ; }	if ( name . equals ( get CaMeL Label ( i ) ) ) return i ;
_ block . iter = ruby _ iter . iter ;  <CTX>  private BLOCK PUSH _ BLOCK ( NODE v , NODE b , VALUE self ) { BLOCK _ block = new BLOCK ( ) ; / / _ block . tag = new _ blk@@ tag ( ) ; _ block . var = v ; _ block . body = b ; _ block . self = self ; _ block . frame = ruby CaMeL Frame ; _ block . klass = ruby _ class ; / / _ block . frame . file = ruby _ sourcefile ; / / _ block . frame . line = ruby _ source@@ line ; _ block . scope = get CaMeL Ruby ( ) . ruby CaMeL Scope ; _ block . prev = ruby _ block ; _ block . iter = ruby _ iter . iter ; _ block . v@@ mode = scope _ v@@ mode ; _ block . flags = BLOCK _ D _ SCOPE ; _ block . dyna _ vars = get CaMeL Dynamic CaMeL Vars ( ) ; ruby _ block = _ block ; return _ block ; }	_ block . iter = ruby CaMeL Iter . get CaMeL Iter ( ) ;
VM _ Word n = node . to CaMeL Word ( ) ; return ( n . to CaMeL Int ( ) / granularity * granularity ) == n . to CaMeL Int ( ) ;  <CTX>  public final boolean is CaMeL Node ( VM _ Address node ) { VM _ Word n = node . to CaMeL Word ( ) ; return ( n . to CaMeL Int ( ) / granularity * granularity ) == n . to CaMeL Int ( ) ; }	if ( BITS _ IN _ ADDRESS == 64 ) return ( node . to CaMeL Long ( ) / granularity * granularity ) == node . to CaMeL Long ( ) ; else return ( node . to CaMeL Int ( ) / granularity * granularity ) == node . to CaMeL Int ( ) ;
return output CaMeL Extension ;  <CTX>  public String get CaMeL Output CaMeL Extension ( String input CaMeL Extension ) { / / Examine the list of input extensions List CaMeL Iterator iter = get CaMeL Input CaMeL Extensions ( ) . list CaMeL Iterator ( ) ; while ( iter . has CaMeL Next ( ) ) { if ( ( ( String ) iter . next ( ) ) . equals ( input CaMeL Extension ) ) { return output CaMeL Extension ; } } return null ; }	return output CaMeL Extensions ;
if ( first [ i ] != second [ i ] )  <CTX>  public static final boolean equals ( char [ ] first , char [ ] second ) { if ( first == second ) return true ; if ( first == null || second == null ) return false ; if ( first . length != second . length ) return false ; for ( int i = first . length ; -- i >= 0 ; ) if ( first [ i ] != second [ i ] ) return false ; return true ; }	if ( ! equals ( first [ i ] , second [ i ] ) )
Object execute CaMeL Query ( String sql CaMeL Query , String [ ] parameters ,  <CTX>  Object execute CaMeL Query ( String sql CaMeL Query , String [ ] parameters , Result CaMeL Set CaMeL Handler result CaMeL Set CaMeL Handler ) throws Database CaMeL Exception ;	Object execute CaMeL Query ( String sql CaMeL Query , Object [ ] parameters ,
_ model = new Default CaMeL Global CaMeL Model ( ) ;  <CTX>  protected void create CaMeL Model ( ) { / / _ model = new Default CaMeL Global CaMeL Model ( _ original CaMeL Model ) ; _ model = new Default CaMeL Global CaMeL Model ( ) ; / / Wait until it has connected _ model . _ interpreter CaMeL Control . ensure CaMeL Interpreter CaMeL Connected ( ) ; }	_ model = new Default CaMeL Single CaMeL Display CaMeL Model ( ) ;
assert _ pos == 0 && that . _ pos == 0 ;  <CTX>  boolean is CaMeL At CaMeL End CaMeL Of ( Cur that ) { assert is CaMeL Normal ( ) && that . is CaMeL Normal ( ) ; assert _ pos == 0 && that . _ pos == 0 ; return _ xobj == that . _ xobj && _ pos == that . _ xobj . pos CaMeL End ( ) ; }	assert that . _ pos == 0 ;
return get CaMeL String CaMeL Property ( Text CaMeL Data CaMeL Item . VALUE _ EXPR _ PROP ) ;  <CTX>  public String get CaMeL Value CaMeL Expr ( ) { return get CaMeL String CaMeL Property ( Text CaMeL Data CaMeL Item . VALUE _ EXPR _ PROP ) ; }	return get CaMeL String CaMeL Property ( I CaMeL Text CaMeL Data CaMeL Item CaMeL Model . VALUE _ EXPR _ PROP ) ;
check CaMeL Validation CaMeL For CaMeL Preview ( errors , request ) ;  <CTX>  private void check CaMeL Validation CaMeL For CaMeL Manage CaMeL Preview ( Action CaMeL Errors errors , Http CaMeL Servlet CaMeL Request request ) throws Application CaMeL Exception { check CaMeL Validation CaMeL For CaMeL Preview ( errors , request ) ; validate CaMeL Custom CaMeL Fields ( request , errors ) ; }	if ( get CaMeL State ( ) . equals ( Account CaMeL State . LO@@ AN@@ ACC _ PARTIAL@@ APPLICATION ) || get CaMeL State ( ) . equals ( Account CaMeL State . LO@@ AN@@ ACC _ PEND@@ ING@@ APPROVAL ) ) check CaMeL Validation CaMeL For CaMeL Preview ( errors , request ) ;
generate CaMeL Reg CaMeL Exp CaMeL Literals ( cx , scope ) ;  <CTX>  private void generate CaMeL I CaMeL Code CaMeL From CaMeL Tree ( Context cx , Scriptable scope , Node tree ) { generate CaMeL Nested CaMeL Functions ( cx , scope ) ; generate CaMeL Reg CaMeL Exp CaMeL Literals ( cx , scope ) ; int the CaMeL I CaMeL Code CaMeL Top = 0 ; the CaMeL I CaMeL Code CaMeL Top = generate CaMeL I CaMeL Code ( tree , the CaMeL I CaMeL Code CaMeL Top ) ; its CaMeL Labels . fix CaMeL Label CaMeL Go@@ tos ( its CaMeL Data . its CaMeL I CaMeL Code ) ; / / add Icode _ END only to scripts as function always ends with RETURN if ( its CaMeL Data . its CaMeL Function CaMeL Type == 0 ) { the CaMeL I CaMeL Code CaMeL Top = add CaMeL Icode ( Icode _ END , the CaMeL I CaMeL Code CaMeL Top ) ; } / / Add special CATCH to simplify Interpreter . interpret logic / / and workaround l@@ ack of goto in Java the CaMeL I CaMeL Code CaMeL Top = add CaMeL Icode ( Icode _ CATCH , the CaMeL I CaMeL Code CaMeL Top ) ; its CaMeL Data . its CaMeL I CaMeL Code CaMeL Top = the CaMeL I CaMeL Code CaMeL Top ; if ( its CaMeL Data . its CaMeL I CaMeL Code . length != the CaMeL I CaMeL Code CaMeL Top ) { / / Make its CaMeL Data . its CaMeL I CaMeL Code length exactly the CaMeL I CaMeL Code CaMeL Top to save memory / / and catch bugs with jumps be@@ y@@ ound i@@ code as early as possible byte [ ] tmp = new byte [ the CaMeL I CaMeL Code CaMeL Top ] ; System . arraycopy ( its CaMeL Data . its CaMeL I CaMeL Code , 0 , tmp , 0 , the CaMeL I CaMeL Code CaMeL Top ) ; its CaMeL Data . its CaMeL I CaMeL Code = tmp ; } if ( its CaMeL Strings . size ( ) == 0 ) { its CaMeL Data . its CaMeL String CaMeL Table = null ; } else { its CaMeL Data . its CaMeL String CaMeL Table = new String [ its CaMeL Strings . size ( ) ] ; Obj CaMeL To CaMeL Int CaMeL Map . Iterator iter = its CaMeL Strings . new CaMeL Iterator ( ) ; for ( iter . start ( ) ; ! iter . done ( ) ; iter . next ( ) ) { String str = ( String ) iter . get CaMeL Key ( ) ; int index = iter . get CaMeL Value ( ) ; if ( its CaMeL Data . its CaMeL String CaMeL Table [ index ] != null ) Context . code CaMeL Bug ( ) ; its CaMeL Data . its CaMeL String CaMeL Table [ index ] = str ; } } if ( its CaMeL Double CaMeL Table CaMeL Top == 0 ) { its CaMeL Data . its CaMeL Double CaMeL Table = null ; } else if ( its CaMeL Data . its CaMeL Double CaMeL Table . length != its CaMeL Double CaMeL Table CaMeL Top ) { double [ ] tmp = new double [ its CaMeL Double CaMeL Table CaMeL Top ] ; System . arraycopy ( its CaMeL Data . its CaMeL Double CaMeL Table , 0 , tmp , 0 , its CaMeL Double CaMeL Table CaMeL Top ) ; its CaMeL Data . its CaMeL Double CaMeL Table = tmp ; } if ( its CaMeL Exception CaMeL Table CaMeL Top != 0 && its CaMeL Data . its CaMeL Exception CaMeL Table . length != its CaMeL Exception CaMeL Table CaMeL Top ) { int [ ] tmp = new int [ its CaMeL Exception CaMeL Table CaMeL Top ] ; System . arraycopy ( its CaMeL Data . its CaMeL Exception CaMeL Table , 0 , tmp , 0 , its CaMeL Exception CaMeL Table CaMeL Top ) ; its CaMeL Data . its CaMeL Exception CaMeL Table = tmp ; } its CaMeL Data . its CaMeL Max CaMeL Vars = script CaMeL Or CaMeL Fn . get CaMeL Param CaMeL And CaMeL Var CaMeL Count ( ) ; / / its CaMeL Max CaMeL Frame CaMeL Array : interpret method needs this amount for its / / stack and s CaMeL Dbl arrays its CaMeL Data . its CaMeL Max CaMeL Frame CaMeL Array = its CaMeL Data . its CaMeL Max CaMeL Vars + its CaMeL Data . its CaMeL Max CaMeL Locals + its CaMeL Data . its CaMeL Max CaMeL Stack ; its CaMeL Data . arg CaMeL Names = script CaMeL Or CaMeL Fn . get CaMeL Param CaMeL And CaMeL Var CaMeL Names ( ) ; its CaMeL Data . arg CaMeL Count = script CaMeL Or CaMeL Fn . get CaMeL Param CaMeL Count ( ) ; its CaMeL Data . encoded CaMeL Source CaMeL Start = script CaMeL Or CaMeL Fn . get CaMeL Encoded CaMeL Source CaMeL Start ( ) ; its CaMeL Data . encoded CaMeL Source CaMeL End = script CaMeL Or CaMeL Fn . get CaMeL Encoded CaMeL Source CaMeL End ( ) ; if ( Token . print CaMeL I CaMeL Code ) dump CaMeL I CaMeL Code ( its CaMeL Data ) ; }	generate CaMeL Reg CaMeL Exp CaMeL Literals ( cx ) ;
super ( create CaMeL Tables ( stream , null ) ) ;  <CTX>  public Flat CaMeL Xml CaMeL Data CaMeL Set ( Input CaMeL Stream stream ) throws IO CaMeL Exception , Data CaMeL Set CaMeL Exception { super ( create CaMeL Tables ( stream , null ) ) ; }	try { Document document = new Document ( new File CaMeL Input CaMeL Stream ( xml CaMeL File ) ) ; I CaMeL Data CaMeL Set meta CaMeL Data CaMeL Set = null ; String dtd CaMeL Uri = get CaMeL Doc CaMeL Type CaMeL Uri ( document ) ; if ( dtd CaMeL Uri != null ) { File dtd CaMeL File = new File ( dtd CaMeL Uri ) ; if ( ! dtd CaMeL File . is CaMeL Absolute ( ) ) { dtd CaMeL File = new File ( xml CaMeL File . get CaMeL Parent ( ) , dtd CaMeL Uri ) ; } meta CaMeL Data CaMeL Set = new Flat CaMeL Xml CaMeL Doc CaMeL Type ( new File CaMeL Input CaMeL Stream ( dtd CaMeL File ) ) ; } _ tables = get CaMeL Tables ( document , meta CaMeL Data CaMeL Set ) ; } catch ( Parse CaMeL Exception e ) { throw new Data CaMeL Set CaMeL Exception ( e ) ; }
this . listeners . clear ( ) ;  <CTX>  private void shutdown ( ) { this . listeners . clear ( ) ; Platform . get CaMeL Job CaMeL Manager ( ) . set CaMeL Progress CaMeL Provider ( null ) ; Platform . get CaMeL Job CaMeL Manager ( ) . remove CaMeL Job CaMeL Change CaMeL Listener ( this . change CaMeL Listener ) ; }	synchronized ( listeners CaMeL Key ) { this . listeners = new I CaMeL Job CaMeL Progress CaMeL Manager CaMeL Listener [ 0 ] ; }
return new Physical CaMeL Register CaMeL Enumeration ( FIRST _ CONDITION + THREAD _ SWITCH _ REGISTER , FIRST _ CONDITION + THREAD _ SWITCH _ REGISTER ) ;  <CTX>  Enumeration enumerate CaMeL Nonvolatile CaMeL Condition CaMeL Registers ( ) { return new Physical CaMeL Register CaMeL Enumeration ( FIRST _ CONDITION + THREAD _ SWITCH _ REGISTER , FIRST _ CONDITION + THREAD _ SWITCH _ REGISTER ) ; }	return new Physical CaMeL Register CaMeL Enumeration ( 0 , - 1 ) ;
synchronized ( Update CaMeL Manager . this ) { running = false ; scripting CaMeL Environment . interrupt ( ) ; update CaMeL Runnable CaMeL Queue . get CaMeL Thread ( ) . interrupt ( ) ; }  <CTX>  public synchronized void interrupt ( ) { if ( update CaMeL Runnable CaMeL Queue . get CaMeL Thread ( ) != null ) { / / Pre@@ e@@ mpt to cancel the pending tasks update CaMeL Runnable CaMeL Queue . pre@@ e@@ mpt CaMeL Later ( new Runnable ( ) { public void run ( ) { if ( started ) { dispatch CaMeL SVG CaMeL Un CaMeL Load CaMeL Event ( ) ; } else { synchronized ( Update CaMeL Manager . this ) { running = false ; scripting CaMeL Environment . interrupt ( ) ; update CaMeL Runnable CaMeL Queue . get CaMeL Thread ( ) . interrupt ( ) ; } } } } ) ; resume ( ) ; } }	running = false ; scripting CaMeL Environment . interrupt ( ) ; update CaMeL Runnable CaMeL Queue . get CaMeL Thread ( ) . interrupt ( ) ;
boolean extract CaMeL Namespace CaMeL From CaMeL Parent ) throws SOAP CaMeL Processing CaMeL Exception { super ( parent , local CaMeL Name , extract CaMeL Namespace CaMeL From CaMeL Parent ) ;  <CTX>  public SOAP CaMeL Fault CaMeL Role CaMeL Impl ( SOAP CaMeL Fault parent , String local CaMeL Name , boolean extract CaMeL Namespace CaMeL From CaMeL Parent ) throws SOAP CaMeL Processing CaMeL Exception { super ( parent , local CaMeL Name , extract CaMeL Namespace CaMeL From CaMeL Parent ) ; }	boolean extract CaMeL Namespace CaMeL From CaMeL Parent , SOAP CaMeL Factory factory ) throws SOAP CaMeL Processing CaMeL Exception { super ( parent , local CaMeL Name , extract CaMeL Namespace CaMeL From CaMeL Parent , factory ) ;
Atom a = new Atom ( ) ;  <CTX>  public void test CaMeL Atom ( ) { Atom a = new Atom ( ) ; assert CaMeL Not CaMeL Null ( a ) ; }	Atom a = builder . new CaMeL Atom ( ) ;
synchronized ( listener CaMeL Key ) { Iterator iterator = listeners . iterator ( ) ; while ( iterator . has CaMeL Next ( ) ) { I CaMeL Job CaMeL Progress CaMeL Manager CaMeL Listener listener = ( I CaMeL Job CaMeL Progress CaMeL Manager CaMeL Listener ) iterator . next ( ) ; listener . remove CaMeL Group ( group ) ; }  <CTX>  public void remove CaMeL Group ( Group CaMeL Info group ) { synchronized ( listener CaMeL Key ) { Iterator iterator = listeners . iterator ( ) ; while ( iterator . has CaMeL Next ( ) ) { I CaMeL Job CaMeL Progress CaMeL Manager CaMeL Listener listener = ( I CaMeL Job CaMeL Progress CaMeL Manager CaMeL Listener ) iterator . next ( ) ; listener . remove CaMeL Group ( group ) ; } } }	Object [ ] listener CaMeL Array = listeners . to CaMeL Array ( ) ; for ( int i = 0 ; i < listener CaMeL Array . length ; i ++ ) { I CaMeL Job CaMeL Progress CaMeL Manager CaMeL Listener listener = ( I CaMeL Job CaMeL Progress CaMeL Manager CaMeL Listener ) listener CaMeL Array [ i ] ; listener . remove CaMeL Group ( group ) ;
return 0 ;  <CTX>  public int get CaMeL Preferred CaMeL Height ( ) throws Not CaMeL Implemented CaMeL Exception { return 0 ; / / TODO }	int height = 0 ; int n = get CaMeL Row CaMeL Count ( ) ; Rectangle r = new Rectangle ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Tree CaMeL Path path = get CaMeL Path CaMeL For CaMeL Row ( i ) ; height += get CaMeL Bounds ( path , r ) . height ; } return height ;
Iterator i = clients CaMeL By CaMeL Name . values ( ) . iterator ( ) ; for ( ; i . has CaMeL Next ( ) ; ) { FCP CaMeL Client client = ( FCP CaMeL Client ) i . next ( ) ; client . finish CaMeL Start ( ) ;  <CTX>  public void finish CaMeL Start ( ) { this . global CaMeL Client . finish CaMeL Start ( ) ; Iterator i = clients CaMeL By CaMeL Name . values ( ) . iterator ( ) ; for ( ; i . has CaMeL Next ( ) ; ) { FCP CaMeL Client client = ( FCP CaMeL Client ) i . next ( ) ; client . finish CaMeL Start ( ) ; } if ( enable CaMeL Persistent CaMeL Downloads ) start CaMeL Persister ( ) ; can CaMeL Start CaMeL Persister = true ; }	FCP CaMeL Client [ ] clients ; synchronized ( this ) { clients = ( FCP CaMeL Client [ ] ) clients CaMeL By CaMeL Name . values ( ) . to CaMeL Array ( new FCP CaMeL Client [ clients CaMeL By CaMeL Name . size ( ) ] ) ; } for ( int i = 0 ; i < clients . length ; i ++ ) { clients [ i ] . finish CaMeL Start ( ) ;
return define CaMeL Module CaMeL Under ( name , get CaMeL Classes ( ) . get CaMeL Object CaMeL Class ( ) ) ;  <CTX>  public Ruby CaMeL Module define CaMeL Module ( String name ) { return define CaMeL Module CaMeL Under ( name , get CaMeL Classes ( ) . get CaMeL Object CaMeL Class ( ) ) ; }	return define CaMeL Module CaMeL Under ( name , object CaMeL Class ) ;
Address first CaMeL Free CaMeL Ptr = null ;  <CTX>  protected final void de@@ fragment ( ) throws Uninterruptible CaMeL Pragma { final Word size = Word . from CaMeL Int CaMeL Zero CaMeL Extend ( get CaMeL Size ( ) ) ; final Word header CaMeL Size = Word . from CaMeL Int CaMeL Zero CaMeL Extend ( this . header CaMeL Size ) ; Word offset = header CaMeL Size ; final Offset size CaMeL Offset = this . size CaMeL Offset ; final Offset tib CaMeL Offset = this . tib CaMeL Offset ; lock ( ) ; try { Address first CaMeL Free CaMeL Ptr = null ; while ( offset . LT ( size ) ) { final Address ptr = start . add ( offset ) ; final Word obj CaMeL Size = ptr . load CaMeL Word ( size CaMeL Offset ) ; final Word next CaMeL Offset = offset . add ( obj CaMeL Size ) . add ( header CaMeL Size ) ; final Object v@@ mt = ptr . load CaMeL Object CaMeL Reference ( tib CaMeL Offset ) ; if ( ( first CaMeL Free CaMeL Ptr == null ) && ( v@@ mt == FREE ) ) { first CaMeL Free CaMeL Ptr = ptr ; } if ( ( v@@ mt == FREE ) && ( next CaMeL Offset . LT ( size ) ) ) { final Object next CaMeL V@@ mt ; final Address next CaMeL Object CaMeL Ptr = start . add ( next CaMeL Offset ) ; next CaMeL V@@ mt = next CaMeL Object CaMeL Ptr . load CaMeL Object CaMeL Reference ( tib CaMeL Offset ) ; if ( next CaMeL V@@ mt == FREE ) { / / Combine two free spaces Word next CaMeL Obj CaMeL Size = next CaMeL Object CaMeL Ptr . load CaMeL Word ( size CaMeL Offset ) ; Word new CaMeL Obj CaMeL Size = obj CaMeL Size . add ( header CaMeL Size ) . add ( next CaMeL Obj CaMeL Size ) ; ptr . store ( new CaMeL Obj CaMeL Size , size CaMeL Offset ) ; / / Do not increment offset here , bec@@ ause there may be / / another next free object , which we will combine / / in the next loop . } else { offset = next CaMeL Offset ; } } else { offset = next CaMeL Offset ; } } / / Set the address of the next free block , to the first free block this . next CaMeL Free CaMeL Ptr = first CaMeL Free CaMeL Ptr ; } finally { unlock ( ) ; } }	Address first CaMeL Free CaMeL Ptr = Address . zero ( ) ;
ul@@ ocs _ = ul@@ oc CaMeL Col == null ? null : get CaMeL Unique CaMeL Parts ( locations ) ;  <CTX>  Cat CaMeL Mapping ( String seq CaMeL Col , String loc CaMeL Col , String ul@@ oc CaMeL Col , String [ ] locations ) { seq CaMeL Col _ = seq CaMeL Col ; loc CaMeL Col _ = loc CaMeL Col ; ul@@ oc CaMeL Col _ = ul@@ oc CaMeL Col ; locations _ = locations ; ul@@ ocs _ = ul@@ oc CaMeL Col == null ? null : get CaMeL Unique CaMeL Parts ( locations ) ; }	tri@@ mmer _ = ul@@ oc CaMeL Col == null ? null : new Trimmer ( locations ) ;
if ( validation CaMeL Status == I CaMeL Message CaMeL Provider . ERROR ) return false ;  <CTX>  private boolean validate CaMeL Variable CaMeL Name ( ) { boolean allow CaMeL Finish = false ; / / if the current validation CaMeL Status is ERROR , no additional validation applies if ( validation CaMeL Status == I CaMeL Message CaMeL Provider . ERROR ) return false ; / / ass@@ umes everything will be ok String message = standard CaMeL Message ; int new CaMeL Validation CaMeL Status = I CaMeL Message CaMeL Provider . NONE ; if ( variable CaMeL Name . length ( ) == 0 ) { / / the variable name is empty if ( name CaMeL Entered ) { / / a name was entered before and is now empty new CaMeL Validation CaMeL Status = I CaMeL Message CaMeL Provider . ERROR ; message = IDE CaMeL Workbench CaMeL Messages . Path CaMeL Variable CaMeL Dialog _ variable CaMeL Name CaMeL Empty CaMeL Message ; } } else { I CaMeL Status status = path CaMeL Variable CaMeL Manager . validate CaMeL Name ( variable CaMeL Name ) ; if ( ! status . is CaMeL OK ( ) ) { / / the variable name is not valid new CaMeL Validation CaMeL Status = I CaMeL Message CaMeL Provider . ERROR ; message = status . get CaMeL Message ( ) ; } else if ( names CaMeL In CaMeL Use . contains ( variable CaMeL Name ) && ! variable CaMeL Name . equals ( original CaMeL Name ) ) { / / the variable name is already in use message = IDE CaMeL Workbench CaMeL Messages . Path CaMeL Variable CaMeL Dialog _ variable CaMeL Already CaMeL Exists CaMeL Message ; new CaMeL Validation CaMeL Status = I CaMeL Message CaMeL Provider . ERROR ; } else { allow CaMeL Finish = true ; } } / / overwrite the current validation status / message only if everything is ok ( cle@@ aring them ) / / or if we have a more seri@@ ous problem than the current one if ( validation CaMeL Status == I CaMeL Message CaMeL Provider . NONE || new CaMeL Validation CaMeL Status == I CaMeL Message CaMeL Provider . ERROR ) { validation CaMeL Status = new CaMeL Validation CaMeL Status ; validation CaMeL Message = message ; } / / only set the message here if it is not going to be set in / / validate CaMeL Variable CaMeL Value to avoid flash@@ ing . if ( allow CaMeL Finish == false ) set CaMeL Message ( validation CaMeL Message , validation CaMeL Status ) ; return allow CaMeL Finish ; }	if ( validation CaMeL Status == I CaMeL Message CaMeL Provider . ERROR ) { return false ; }
replace CaMeL Range ( text , start , end ) ;  <CTX>  public void replace CaMeL Text ( String text , int start , int end ) { replace CaMeL Range ( text , start , end ) ; }	Text CaMeL Area CaMeL Peer peer = ( Text CaMeL Area CaMeL Peer ) get CaMeL Peer ( ) ; if ( peer == null ) return ; peer . replace CaMeL Range ( str , start , end ) ;
source CaMeL Vertex . equals ( e . get CaMeL Source ( ) ) && target CaMeL Vertex . equals ( e . get CaMeL Target ( ) ) ;  <CTX>  public Set < E > get CaMeL All CaMeL Edges ( V source CaMeL Vertex , V target CaMeL Vertex ) { Set < E > edges = null ; if ( contains CaMeL Vertex ( source CaMeL Vertex ) && contains CaMeL Vertex ( target CaMeL Vertex ) ) { edges = new Array CaMeL Un@@ en@@ forced CaMeL Set < E > ( ) ; Iterator < E > iter = get CaMeL Edge CaMeL Container ( source CaMeL Vertex ) . m _ vertex CaMeL Edges . iterator ( ) ; while ( iter . has CaMeL Next ( ) ) { E e = iter . next ( ) ; boolean equal CaMeL Straight = source CaMeL Vertex . equals ( e . get CaMeL Source ( ) ) && target CaMeL Vertex . equals ( e . get CaMeL Target ( ) ) ; boolean equal CaMeL Inverted = source CaMeL Vertex . equals ( e . get CaMeL Target ( ) ) && target CaMeL Vertex . equals ( e . get CaMeL Source ( ) ) ; if ( equal CaMeL Straight || equal CaMeL Inverted ) { edges . add ( e ) ; } } } return edges ; }	source CaMeL Vertex . equals ( get CaMeL Edge CaMeL Source ( e ) ) && target CaMeL Vertex . equals ( get CaMeL Edge CaMeL Target ( e ) ) ;
if ( tail == head ) return null ;  <CTX>  public synchronized Semaphore remove ( ) { if ( tail == head ) return null ; Semaphore result = elements [ head ] ; elements [ head ] = null ; head = increment ( head ) ; / / reset the queue if it is empty and it has grown if ( tail == head && elements . length > BASE _ SIZE ) { elements = new Semaphore [ BASE _ SIZE ] ; tail = head = 0 ; } return result ; }	if ( tail == head ) { return null ; }
save CaMeL Project CaMeL Item CaMeL Action CaMeL Performed ( evt ) ; }  <CTX>  public void action CaMeL Performed ( java . awt . event . Action CaMeL Event evt ) { save CaMeL Project CaMeL Item CaMeL Action CaMeL Performed ( evt ) ; }	classpath CaMeL Down CaMeL Button CaMeL Action CaMeL Performed ( evt ) ; }
resource CaMeL Key ( obj , Module . TITLE _ ID _ PROP , Module . TITLE _ PROP ) ; property ( obj , Module . COMMENTS _ PROP ) ;  <CTX>  public void visit CaMeL Module ( Module obj ) { if ( mark CaMeL Line CaMeL Number ) obj . init CaMeL Line CaMeL No CaMeL Map ( ) ; writer . attribute ( Design CaMeL Schema CaMeL Constants . XMLNS _ ATTRIB , DEFAULT _ NAME _ SPACE ) ; writer . attribute ( Design CaMeL Schema CaMeL Constants . VERSION _ ATTRIB , Design CaMeL Schema CaMeL Constants . REPORT _ VERSION ) ; writer . attribute ( Design CaMeL Schema CaMeL Constants . ID _ ATTRIB , new Long ( obj . get CaMeL ID ( ) ) . to CaMeL String ( ) ) ; property ( obj , Module . AUTHOR _ PROP ) ; property ( obj , Module . HELP _ GUIDE _ PROP ) ; property ( obj , Module . CREATED _ BY _ PROP ) ; property ( obj , Module . UNITS _ PROP ) ; property ( obj , Module . BASE _ PROP ) ; property ( obj , Module . INCLUDE _ RESOURCE _ PROP ) ; resource CaMeL Key ( obj , Module . TITLE _ ID _ PROP , Module . TITLE _ PROP ) ; property ( obj , Module . COMMENTS _ PROP ) ; resource CaMeL Key ( obj , Module . DESCRIPTION _ ID _ PROP , Module . DESCRIPTION _ PROP ) ; write CaMeL User CaMeL Property CaMeL Defns ( obj ) ; write CaMeL User CaMeL Property CaMeL Values ( obj ) ; / / write property bindings write CaMeL Structure CaMeL List ( obj , Module . PROPERTY _ BINDINGS _ PROP ) ; / / write script libs write CaMeL Structure CaMeL List ( obj , Module . SCRIPT@@ LIBS _ PROP ) ; }	resource CaMeL Key ( obj , I CaMeL Module CaMeL Model . TITLE _ ID _ PROP , I CaMeL Module CaMeL Model . TITLE _ PROP ) ; property ( obj , I CaMeL Design CaMeL Element CaMeL Model . COMMENTS _ PROP ) ;
Class [ ] dependency CaMeL Types = get CaMeL Dependencies ( mutable CaMeL Pico CaMeL Container ) ; Component CaMeL Adapter [ ] adapter CaMeL Dependencies = new Component CaMeL Adapter [ dependency CaMeL Types . length ] ;  <CTX>  public Object get CaMeL Component CaMeL Instance ( Mutable CaMeL Pico CaMeL Container mutable CaMeL Pico CaMeL Container ) throws Pico CaMeL Initialization CaMeL Exception , Pico CaMeL Introspection CaMeL Exception , Assignability CaMeL Registration CaMeL Exception , Not CaMeL Concrete CaMeL Registration CaMeL Exception { if ( component CaMeL Instance == null ) { Class [ ] dependency CaMeL Types = get CaMeL Dependencies ( mutable CaMeL Pico CaMeL Container ) ; Component CaMeL Adapter [ ] adapter CaMeL Dependencies = new Component CaMeL Adapter [ dependency CaMeL Types . length ] ; Parameter [ ] component CaMeL Parameters = get CaMeL Parameters ( mutable CaMeL Pico CaMeL Container ) ; for ( int i = 0 ; i < adapter CaMeL Dependencies . length ; i ++ ) { adapter CaMeL Dependencies [ i ] = component CaMeL Parameters [ i ] . resolve CaMeL Adapter ( mutable CaMeL Pico CaMeL Container ) ; } component CaMeL Instance = create CaMeL Component ( adapter CaMeL Dependencies , mutable CaMeL Pico CaMeL Container ) ; mutable CaMeL Pico CaMeL Container . add CaMeL Ordered CaMeL Component CaMeL Adapter ( this ) ; } return component CaMeL Instance ; }	final Class [ ] dependency CaMeL Types = get CaMeL Dependencies ( mutable CaMeL Pico CaMeL Container ) ; final Component CaMeL Adapter [ ] adapter CaMeL Dependencies = new Component CaMeL Adapter [ dependency CaMeL Types . length ] ;
Vector < Option CaMeL Listener < T >> v = listeners . get ( c ) ; if ( v == null ) return ; if ( v . remove CaMeL Element ( l ) && v . size ( ) == 0 ) { listeners . remove ( c ) ; }  <CTX>  void remove CaMeL Listener ( Configuration c , Option CaMeL Listener < T > l ) { Vector < Option CaMeL Listener < T >> v = listeners . get ( c ) ; if ( v == null ) return ; if ( v . remove CaMeL Element ( l ) && v . size ( ) == 0 ) { listeners . remove ( c ) ; } }	Vector < Option CaMeL Listener < T >> v = listeners . get ( c ) ; if ( v == null ) return ; if ( v . remove CaMeL Element ( l ) && v . size ( ) == 0 ) { listeners . remove ( c ) ;
menu CaMeL Item CaMeL Paren@@ tage CaMeL Changed . set CaMeL Visible ( false ) ;  <CTX>  public void show ( Component comp , int x , int y , Deploy CaMeL Tree CaMeL Panel parent ) { temp CaMeL Comp = comp ; temp CaMeL X = x ; temp CaMeL Y = y ; if ( get CaMeL Node ( ) instanceof Prim ) { menu CaMeL Item CaMeL Detach . set CaMeL Visible ( true ) ; menu CaMeL Item CaMeL Terminate CaMeL Normal . set CaMeL Visible ( true ) ; menu CaMeL Item CaMeL Terminate CaMeL Abnormal . set CaMeL Visible ( true ) ; menu CaMeL Item CaMeL D CaMeL Terminate . set CaMeL Visible ( true ) ; menu CaMeL Item CaMeL Dump CaMeL Context . set CaMeL Visible ( true ) ; menu CaMeL Item CaMeL Paren@@ tage CaMeL Changed . set CaMeL Visible ( true ) ; } else if ( get CaMeL Node ( ) instanceof Component CaMeL Description ) { menu CaMeL Item CaMeL Detach . set CaMeL Visible ( false ) ; menu CaMeL Item CaMeL Terminate CaMeL Normal . set CaMeL Visible ( false ) ; menu CaMeL Item CaMeL Terminate CaMeL Abnormal . set CaMeL Visible ( false ) ; menu CaMeL Item CaMeL D CaMeL Terminate . set CaMeL Visible ( false ) ; menu CaMeL Item CaMeL Dump CaMeL Context . set CaMeL Visible ( true ) ; menu CaMeL Item CaMeL Paren@@ tage CaMeL Changed . set CaMeL Visible ( false ) ; } popup CaMeL Tree . show ( comp , x , y ) ; this . parent = parent ; }	menu CaMeL Item CaMeL Paren@@ tage CaMeL Changed . set CaMeL Visible ( true ) ;
Context cx = Context . get CaMeL Current CaMeL Context ( ) ; if ( cx == null ) { cx = new Context ( ) ; cx . enter ( ) ; try { return ( object . has CaMeL Property ( method CaMeL Id ) ? object . call CaMeL Method ( method CaMeL Id , args ) : Context . get CaMeL Undefined CaMeL Value ( ) ) ; } finally { cx . exit ( ) ; } } else { return ( object . has CaMeL Property ( method CaMeL Id ) ? object . call CaMeL Method ( method CaMeL Id , args ) : Context . get CaMeL Undefined CaMeL Value ( ) ) ; }  <CTX>  public static Object call CaMeL Method ( Flattened CaMeL Object object , Object method CaMeL Id , Object [ ] args ) { try { / / old way , bind a Context dynam@@ ically , unbind if it w@@ asn t there before . Context cx = Context . get CaMeL Current CaMeL Context ( ) ; if ( cx == null ) { cx = new Context ( ) ; cx . enter ( ) ; try { return ( object . has CaMeL Property ( method CaMeL Id ) ? object . call CaMeL Method ( method CaMeL Id , args ) : Context . get CaMeL Undefined CaMeL Value ( ) ) ; } finally { cx . exit ( ) ; } } else { return ( object . has CaMeL Property ( method CaMeL Id ) ? object . call CaMeL Method ( method CaMeL Id , args ) : Context . get CaMeL Undefined CaMeL Value ( ) ) ; } } catch ( Exception ex ) { ex . print CaMeL Stack CaMeL Trace ( System . err ) ; throw new Error ( ex . get CaMeL Message ( ) ) ; } }	return ( object . has CaMeL Property ( method CaMeL Id ) ? object . call CaMeL Method ( method CaMeL Id , args ) : Context . get CaMeL Undefined CaMeL Value ( ) ) ;
if ( condition != null ) { this . has CaMeL Condition = true ; this . condition = condition ; } else if ( r@@ to != null ) { this . has CaMeL Related CaMeL To = true ; this . r@@ to = r@@ to ; }  <CTX>  public Select CaMeL Expression ( int multiplicity , metamodel . Class the CaMeL Class , Expression condition , Related CaMeL To CaMeL Operation r@@ to ) { super ( ) ; this . the CaMeL Class = the CaMeL Class ; this . multiplicity = multiplicity ; if ( condition != null ) { this . has CaMeL Condition = true ; this . condition = condition ; } else if ( r@@ to != null ) { this . has CaMeL Related CaMeL To = true ; this . r@@ to = r@@ to ; } }	this . condition = condition ;
Xml CaMeL Schema this CaMeL Schema = schema CaMeL Coll . read ( el ) ; xml CaMeL Schema CaMeL Type CaMeL Vector . add ( this CaMeL Schema ) ;  <CTX>  public void eng@@ age ( ) { / / test the databinding type . If not just fall through if ( configuration . get CaMeL Databinding CaMeL Type ( ) != XSLT CaMeL Constants . Data CaMeL Binding CaMeL Types . ADB ) { return ; } try { WSDL CaMeL Types types CaMeL List = configuration . get CaMeL W@@ om ( ) . get CaMeL Types ( ) ; if ( types CaMeL List == null ) { / / there are no types to be code generated / / H@@ ow@@ ever if the type mapper is left empty it will be a problem for the other / / processes . H@@ ence the default type mapper is set to the configuration this . configuration . set CaMeL Type CaMeL Mapper ( new Default CaMeL Type CaMeL Mapper ( ) ) ; return ; } List types CaMeL Array = types CaMeL List . get CaMeL Extensibility CaMeL Elements ( ) ; WSDL CaMeL Extensibility CaMeL Element exten@@ si@@ blity CaMeL Elt = null ; Vector xml CaMeL Schema CaMeL Type CaMeL Vector = new Vector ( ) ; for ( int i = 0 ; i < types CaMeL Array . size ( ) ; i ++ ) { exten@@ si@@ blity CaMeL Elt = ( WSDL CaMeL Extensibility CaMeL Element ) types CaMeL Array . get ( i ) ; Xml CaMeL Schema CaMeL Collection schema CaMeL Coll = new Xml CaMeL Schema CaMeL Collection ( ) ; / / add the namespace map here . it is absol@@ u@@ tely needed Map ns CaMeL Map = configuration . get CaMeL W@@ om ( ) . get CaMeL Namespaces ( ) ; Iterator keys = ns CaMeL Map . key CaMeL Set ( ) . iterator ( ) ; String key ; while ( keys . has CaMeL Next ( ) ) { key = ( String ) keys . next ( ) ; schema CaMeL Coll . map CaMeL Namespace ( key , ( String ) ns CaMeL Map . get ( key ) ) ; } Schema schema ; if ( Extension CaMeL Constants . SCHEMA . equals ( exten@@ si@@ blity CaMeL Elt . get CaMeL Type ( ) ) ) { schema = ( Schema ) exten@@ si@@ blity CaMeL Elt ; Stack imported CaMeL Schema CaMeL Stack = schema . get CaMeL Imported CaMeL Schema CaMeL Stack ( ) ; / / compile these schemas while ( ! imported CaMeL Schema CaMeL Stack . is CaMeL Empty ( ) ) { Element el = ( Element ) imported CaMeL Schema CaMeL Stack . pop ( ) ; Xml CaMeL Schema this CaMeL Schema = schema CaMeL Coll . read ( el ) ; xml CaMeL Schema CaMeL Type CaMeL Vector . add ( this CaMeL Schema ) ; } } } / / call the schema compiler Compiler CaMeL Options options = new Compiler CaMeL Options ( ) . set CaMeL Output CaMeL Location ( configuration . get CaMeL Output CaMeL Location ( ) ) ; Schema CaMeL Compiler schema CaMeL Compiler = new Schema CaMeL Compiler ( options ) ; schema CaMeL Compiler . compile ( xml CaMeL Schema CaMeL Type CaMeL Vector ) ; / / create the type mapper Java CaMeL Type CaMeL Mapper mapper = new Java CaMeL Type CaMeL Mapper ( ) ; / / get the processed element map and transfer it to the type mapper Map processed CaMeL Map = schema CaMeL Compiler . get CaMeL Processed CaMeL Element CaMeL Map ( ) ; Iterator process@@ ed@@ keys = processed CaMeL Map . key CaMeL Set ( ) . iterator ( ) ; Q CaMeL Name q CaMeL Name CaMeL Key ; while ( process@@ ed@@ keys . has CaMeL Next ( ) ) { q CaMeL Name CaMeL Key = ( Q CaMeL Name ) process@@ ed@@ keys . next ( ) ; mapper . add CaMeL Type CaMeL Mapping ( q CaMeL Name CaMeL Key , processed CaMeL Map . get ( q CaMeL Name CaMeL Key ) ) ; } / / set the type mapper to the config configuration . set CaMeL Type CaMeL Mapper ( mapper ) ; } catch ( Exception e ) { throw new Runtime CaMeL Exception ( e ) ; } }	if ( el != null ) { Xml CaMeL Schema this CaMeL Schema = schema CaMeL Coll . read ( el ) ; xml CaMeL Schema CaMeL Type CaMeL Vector . add ( this CaMeL Schema ) ; }
get CaMeL CDI CaMeL Target ( ) . set CaMeL Location CaMeL Breakpoint ( ICDI CaMeL Breakpoint . TEMPORARY , location , null , null , false ) ;  <CTX>  public void set CaMeL Internal CaMeL Temporary CaMeL Breakpoint ( ICDI CaMeL Location location ) throws Debug CaMeL Exception { try { get CaMeL CDI CaMeL Target ( ) . set CaMeL Location CaMeL Breakpoint ( ICDI CaMeL Breakpoint . TEMPORARY , location , null , null , false ) ; } catch ( CDI CaMeL Exception e ) { target CaMeL Request CaMeL Failed ( e . get CaMeL Message ( ) , null ) ; } }	get CaMeL CDI CaMeL Target ( ) . set CaMeL Location CaMeL Breakpoint ( ICDI CaMeL Breakpoint . TEMPORARY , location , null , false ) ;
if ( first _ free@@ block == OUT _ OF _ BLOCKS ) return 0 ;  <CTX>  free CaMeL Blocks ( ) { sys CaMeL Lock CaMeL Block . lock ( ) ; if ( first _ free@@ block == OUT _ OF _ BLOCKS ) return 0 ; VM _ Block CaMeL Control the _ block = VM _ Magic . address CaMeL As CaMeL Block CaMeL Control ( blocks [ first _ free@@ block ] ) ; int i = 1 ; int next = the _ block . next@@ block ; while ( next != OUT _ OF _ BLOCKS ) { the _ block = VM _ Magic . address CaMeL As CaMeL Block CaMeL Control ( blocks [ next ] ) ; i ++ ; next = the _ block . next@@ block ; } sys CaMeL Lock CaMeL Block . unlock ( ) ; return i ; }	if ( first _ free@@ block == OUT _ OF _ BLOCKS ) { sys CaMeL Lock CaMeL Block . unlock ( ) ; return 0 ; }
if ( ! ( new CaMeL Selection instanceof I CaMeL Structured CaMeL Selection ) ) return ;  <CTX>  public void set CaMeL Selection ( I CaMeL Selection new CaMeL Selection , boolean dispatch ) { if ( ! ( new CaMeL Selection instanceof I CaMeL Structured CaMeL Selection ) ) return ; List editparts = ( ( I CaMeL Structured CaMeL Selection ) new CaMeL Selection ) . to CaMeL List ( ) ; List selection = prim CaMeL Get CaMeL Selected CaMeL Edit CaMeL Parts ( ) ; set CaMeL Focus ( null ) ; for ( int i = 0 ; i < selection . size ( ) ; i ++ ) ( ( Edit CaMeL Part ) selection . get ( i ) ) . set CaMeL Selected ( Edit CaMeL Part . SELECTED _ NONE ) ; selection . clear ( ) ; editparts = fli@@ tter CaMeL Edi@@ tpart ( editparts ) ; / / for create handle selection . add CaMeL All ( editparts ) ; for ( int i = 0 ; i < editparts . size ( ) ; i ++ ) { Edit CaMeL Part part = ( Edit CaMeL Part ) editparts . get ( i ) ; if ( i == editparts . size ( ) - 1 ) part . set CaMeL Selected ( Edit CaMeL Part . SELECTED _ PRIMARY ) ; else part . set CaMeL Selected ( Edit CaMeL Part . SELECTED ) ; } if ( dispatch ) { fire CaMeL Selection CaMeL Changed ( ) ; } }	set CaMeL Selection ( new CaMeL Selection , true ) ;
row CaMeL Data , context ) ;  <CTX>  protected void access CaMeL Row ( Row CaMeL Design row , I CaMeL Content CaMeL Emitter emitter , I CaMeL Result CaMeL Iterator rs CaMeL Iterator ) { I CaMeL Row CaMeL Data row CaMeL Data = null ; if ( context . is CaMeL In CaMeL Factory ( ) ) { row CaMeL Data = new Row CaMeL Data ( rs CaMeL Iterator , get CaMeL Value CaMeL Expressions ( row ) ) ; } if ( row CaMeL Closed ) { I CaMeL Row CaMeL Content row CaMeL Content = report . create CaMeL Row CaMeL Content ( ) ; row CaMeL Content . set CaMeL Row CaMeL ID ( row CaMeL Id ++ ) ; assert ( row CaMeL Content instanceof Row CaMeL Content ) ; I CaMeL Content parent = context . get CaMeL Content ( ) ; context . push CaMeL Content ( row CaMeL Content ) ; initialize CaMeL Content ( parent , row , row CaMeL Content ) ; process CaMeL Style ( row , row CaMeL Content ) ; process CaMeL Visibility ( row , row CaMeL Content ) ; process CaMeL Bookmark ( row , row CaMeL Content ) ; process CaMeL Action ( row , row CaMeL Content ) ; process CaMeL Row CaMeL Type ( row , row CaMeL Content ) ; if ( need CaMeL Page CaMeL Break ) { row CaMeL Content . get CaMeL Style ( ) . set CaMeL Property ( I CaMeL Style . STYLE _ PAGE _ BREAK _ BEFORE , I CaMeL Style . SOFT _ VALUE ) ; need CaMeL Page CaMeL Break = false ; } if ( context . is CaMeL In CaMeL Factory ( ) ) { Row CaMeL Script CaMeL Executor . handle CaMeL On CaMeL Create ( ( Row CaMeL Content ) row CaMeL Content , row CaMeL Data , context ) ; } start CaMeL TOC CaMeL Entry ( row CaMeL Content ) ; if ( emitter != null ) { emitter . start CaMeL Row ( row CaMeL Content ) ; } row CaMeL Closed = false ; } for ( int j = 0 ; j < row . get CaMeL Cell CaMeL Count ( ) ; j ++ ) { Cell CaMeL Design cell = row . get CaMeL Cell ( j ) ; if ( cell != null ) { I CaMeL Cell CaMeL Content cell CaMeL Content = report . create CaMeL Cell CaMeL Content ( ) ; assert ( cell CaMeL Content instanceof Cell CaMeL Content ) ; I CaMeL Content parent = context . get CaMeL Content ( ) ; context . push CaMeL Content ( cell CaMeL Content ) ; initialize CaMeL Content ( parent , cell , cell CaMeL Content ) ; cell CaMeL Content . set CaMeL Column ( cell . get CaMeL Column ( ) ) ; cell CaMeL Content . set CaMeL Col CaMeL Span ( cell . get CaMeL Col CaMeL Span ( ) ) ; cell CaMeL Content . set CaMeL Row CaMeL Span ( cell . get CaMeL Row CaMeL Span ( ) ) ; process CaMeL Style ( cell , cell CaMeL Content ) ; process CaMeL Visibility ( cell , cell CaMeL Content ) ; process CaMeL Bookmark ( cell , cell CaMeL Content ) ; process CaMeL Action ( cell , cell CaMeL Content ) ; if ( context . is CaMeL In CaMeL Factory ( ) ) { Cell CaMeL Script CaMeL Executor . handle CaMeL On CaMeL Create ( ( Cell CaMeL Content ) cell CaMeL Content , row CaMeL Data , context , false ) ; } start CaMeL TOC CaMeL Entry ( cell CaMeL Content ) ; if ( emitter != null ) { emitter . start CaMeL Cell ( cell CaMeL Content ) ; } for ( int m = 0 ; m < cell . get CaMeL Content CaMeL Count ( ) ; m ++ ) { Report CaMeL Item CaMeL Design item = cell . get CaMeL Content ( m ) ; if ( item != null ) { if ( layout CaMeL Emitter != null ) { item . accept ( this . visitor , layout CaMeL Emitter . get CaMeL Cell CaMeL Emitter ( ) ) ; } else { item . accept ( this . visitor , emitter ) ; } } } if ( emitter != null ) { emitter . end CaMeL Cell ( cell CaMeL Content ) ; } finish CaMeL TOC CaMeL Entry ( ) ; context . pop CaMeL Content ( ) ; } } boolean close CaMeL Row = true ; if ( close CaMeL Row ) { emitter . end CaMeL Row ( ( I CaMeL Row CaMeL Content ) context . get CaMeL Content ( ) ) ; finish CaMeL TOC CaMeL Entry ( ) ; context . pop CaMeL Content ( ) ; row CaMeL Closed = true ; } }	context ) ;
is CaMeL Schema CaMeL Supported = meta CaMeL Data CaMeL Provider . is CaMeL Schema CaMeL Supported ( ) ;  <CTX>  protected void reset CaMeL Jdbc CaMeL Info ( Oda CaMeL Data CaMeL Source CaMeL Handle cur CaMeL Data CaMeL Source CaMeL Handle ) { if ( meta CaMeL Data CaMeL Provider != null ) { meta CaMeL Data CaMeL Provider . close CaMeL Connection ( ) ; meta CaMeL Data CaMeL Provider = new Jdbc CaMeL Meta CaMeL Data CaMeL Provider ( null ) ; connect CaMeL Metadata CaMeL Provider ( meta CaMeL Data CaMeL Provider , cur CaMeL Data CaMeL Source CaMeL Handle ) ; / / Clear the Table list and the schema List table CaMeL List = null ; schema CaMeL List = null ; } try { is CaMeL Schema CaMeL Supported = meta CaMeL Data CaMeL Provider . is CaMeL Schema CaMeL Supported ( ) ; } catch ( Exception e ) { Exception CaMeL Handler . handle ( e ) ; } }	if ( jdbc CaMeL Connection != null ) { is CaMeL Schema CaMeL Supported = meta CaMeL Data CaMeL Provider . is CaMeL Schema CaMeL Supported ( ) ; }
get CaMeL Selection CaMeL Mapper ( ) . lock ( ) ;  <CTX>  public void contents CaMeL Changed ( List CaMeL Data CaMeL Event e ) { get CaMeL Selection CaMeL Mapper ( ) . lock ( ) ; fire CaMeL Contents CaMeL Changed ( this , - 1 , - 1 ) ; update CaMeL Selection ( e ) ; get CaMeL Filters ( ) . flush ( ) ; }	boolean was CaMeL Enabled = get CaMeL Selection CaMeL Mapper ( ) . is CaMeL Enabled ( ) ; get CaMeL Selection CaMeL Mapper ( ) . set CaMeL Enabled ( false ) ; try {
return declarator . get CaMeL Name ( ) . to CaMeL String ( ) ;  <CTX>  public String get CaMeL Name ( ) { return declarator . get CaMeL Name ( ) . to CaMeL String ( ) ; }	if ( declarations != null ) { return declarations [ 0 ] . to CaMeL String ( ) ; } IAST CaMeL Name name = definition ; if ( name instanceof ICPPAST CaMeL Qualified CaMeL Name ) { IAST CaMeL Name [ ] ns = ( ( ICPPAST CaMeL Qualified CaMeL Name ) name ) . get CaMeL Names ( ) ; name = ns [ ns . length - 1 ] ; } return name . to CaMeL String ( ) ;
external CaMeL Annotator . annotate ( my CaMeL File , my CaMeL Annotation CaMeL Holder ) ;  <CTX>  public void do CaMeL Collect CaMeL Information ( Progress CaMeL Indicator progress ) { if ( ! Highlight CaMeL Util . is CaMeL Root CaMeL Inspected ( my CaMeL File ) ) return ; final External CaMeL Annotator external CaMeL Annotator = my CaMeL File . get CaMeL Language ( ) . get CaMeL External CaMeL Annotator ( ) ; if ( external CaMeL Annotator != null ) { final Highlight CaMeL Info [ ] errors = Daemon CaMeL Code CaMeL Analyzer CaMeL Impl . get CaMeL Highlights ( my CaMeL Document , Highlight CaMeL Severity . ERROR , my CaMeL Project ) ; if ( errors . length > 0 ) { return ; } external CaMeL Annotator . annotate ( my CaMeL File , my CaMeL Annotation CaMeL Holder ) ; } }	for ( External CaMeL Annotator external CaMeL Annotator : external CaMeL Annot@@ ators ) { external CaMeL Annotator . annotate ( my CaMeL File , my CaMeL Annotation CaMeL Holder ) ; }
if ( force CaMeL View || fru@@ strum CaMeL Intersects != Camera . OUTSIDE _ F@@ RU@@ ST@@ UM ) {  <CTX>  public void on CaMeL Draw ( Renderer r ) { if ( force CaMeL Cull ) { return ; } Camera camera = r . get CaMeL Camera ( ) ; int state = camera . get CaMeL Plane CaMeL State ( ) ; / / check to see if we can cull this node fru@@ strum CaMeL Intersects = ( parent != null ? parent . fru@@ strum CaMeL Intersects : Camera . INTER@@ SEC@@ TS _ F@@ RU@@ ST@@ UM ) ; if ( ! force CaMeL View && fru@@ strum CaMeL Intersects == Camera . INTER@@ SEC@@ TS _ F@@ RU@@ ST@@ UM ) { fru@@ strum CaMeL Intersects = camera . contains ( world CaMeL Bound ) ; } if ( force CaMeL View || fru@@ strum CaMeL Intersects != Camera . OUTSIDE _ F@@ RU@@ ST@@ UM ) { draw ( r ) ; } camera . set CaMeL Plane CaMeL State ( state ) ; }	if ( cull CaMeL Mode == CULL _ NEVER || fru@@ strum CaMeL Intersects != Camera . OUTSIDE _ F@@ RU@@ ST@@ UM ) {
if ( method CaMeL Id == Id _ constructor ) return 1 ; if ( method CaMeL Id == Id _ to CaMeL String ) return 0 ;  <CTX>  public int method CaMeL Arity ( int method CaMeL Id ) { if ( method CaMeL Id == Id _ constructor ) return 1 ; if ( method CaMeL Id == Id _ to CaMeL String ) return 0 ; return super . method CaMeL Arity ( method CaMeL Id ) ; }	if ( prototype CaMeL Flag ) { if ( method CaMeL Id == Id _ constructor ) return 1 ; if ( method CaMeL Id == Id _ to CaMeL String ) return 0 ; }
/ * package * / I CaMeL View CaMeL Part get CaMeL Previous CaMeL Active CaMeL Fast CaMeL View ( ) {  <CTX>  / * package * / I CaMeL View CaMeL Part get CaMeL Previous CaMeL Active CaMeL Fast CaMeL View ( ) { return previous CaMeL Active CaMeL Fast CaMeL View ; }	/ * package * / I CaMeL View CaMeL Reference get CaMeL Previous CaMeL Active CaMeL Fast CaMeL View ( ) {
info . get CaMeL Fill CaMeL Color ( ) , info . get CaMeL Outline CaMeL Color ( ) , info . should CaMeL Maintain CaMeL Aspect CaMeL Ratio ( ) , true ) ;  <CTX>  public Rendered CaMeL Image draw CaMeL Rendered CaMeL Image ( Rendered CaMeL Image src CaMeL Image , int x , int y , int width , int height ) { int n CaMeL New CaMeL Width = ( int ) Math . round ( width * get CaMeL Print CaMeL Scale ( ) ) ; int n CaMeL New CaMeL Height = ( int ) Math . round ( height * get CaMeL Print CaMeL Scale ( ) ) ; Render CaMeL Info info = src CaMeL Image . get CaMeL Render CaMeL Info ( ) ; info . set CaMeL Values ( n CaMeL New CaMeL Width , n CaMeL New CaMeL Height , info . get CaMeL Fill CaMeL Color ( ) , info . get CaMeL Outline CaMeL Color ( ) , info . should CaMeL Maintain CaMeL Aspect CaMeL Ratio ( ) , true ) ; Rendered CaMeL Image img = src CaMeL Image . get CaMeL New CaMeL Rendered CaMeL Image ( info ) ; Image swt CaMeL Img = img . get CaMeL SWT CaMeL Image ( ) ; draw CaMeL Image ( swt CaMeL Img , x , y + height - swt CaMeL Img . get CaMeL Bounds ( ) . height ) ; return img ; }	info . should CaMeL Maintain CaMeL Aspect CaMeL Ratio ( ) , true , info . get CaMeL Background CaMeL Color ( ) , info . get CaMeL Foreground CaMeL Color ( ) ) ;
int rep = id . get CaMeL Reputation ( ) ;  <CTX>  public void test CaMeL Check CaMeL Vote ( ) { Poll p = test@@ polls [ 0 ] ; Lcap CaMeL Message msg = p . get CaMeL Message ( ) ; Lcap CaMeL Identity id = msg . get CaMeL Origin CaMeL ID ( ) ; int rep = id . get CaMeL Reputation ( ) ; / / good vote check try { p . check CaMeL Vote ( msg . get CaMeL Hashed ( ) , new Vote ( msg , false ) ) ; } catch ( Illegal CaMeL State CaMeL Exception ex ) { / / un@@ iti@@ alized comm } assert CaMeL Equals ( 1 , p . m _ tally . num CaMeL Agree ) ; assert CaMeL Equals ( rep , p . m _ tally . wt CaMeL Agree ) ; assert CaMeL True ( rep <= id . get CaMeL Reputation ( ) ) ; rep = id . get CaMeL Reputation ( ) ; / / bad vote check try { p . check CaMeL Vote ( pollmanager . generate CaMeL Random CaMeL Bytes ( ) , new Vote ( msg , false ) ) ; } catch ( Illegal CaMeL State CaMeL Exception ex ) { / / un@@ iti@@ alized comm } assert CaMeL Equals ( 1 , p . m _ tally . num CaMeL Disagree ) ; assert CaMeL Equals ( rep , p . m _ tally . wt CaMeL Disagree ) ; assert CaMeL True ( rep >= id . get CaMeL Reputation ( ) ) ; }	int rep = p . m _ tally . wt CaMeL Agree + id . get CaMeL Reputation ( ) ;
else return super . add CaMeL Type ( parent , type ) ;  <CTX>  public PDOM CaMeL Node add CaMeL Type ( PDOM CaMeL Node parent , I CaMeL Type type ) throws Core CaMeL Exception { if ( type instanceof ICPP CaMeL Basic CaMeL Type ) return new PDOMCPP CaMeL Basic CaMeL Type ( pdom , parent , ( ICPP CaMeL Basic CaMeL Type ) type ) ; else return super . add CaMeL Type ( parent , type ) ; }	} else if ( type instanceof ICPP CaMeL Class CaMeL Type ) { Find CaMeL Equivalent CaMeL Binding feb = new Find CaMeL Equivalent CaMeL Binding ( this , ( ICPP CaMeL Class CaMeL Type ) type ) ; get CaMeL Index ( ) . accept ( feb ) ; if ( feb . get CaMeL Result ( ) != null ) { return feb . get CaMeL Result ( ) ; } } return super . add CaMeL Type ( parent , type ) ;
Function CaMeL Impl ( Sign@@ et sign@@ et , Category category , String id , String name , String help CaMeL Text , Status status )  <CTX>  Function CaMeL Impl ( Sign@@ et sign@@ et , Category category , String id , String name , String help CaMeL Text , Status status ) { super ( sign@@ et , id , name , status ) ; this . subsystem = category . get CaMeL Subsystem ( ) ; this . subsystem CaMeL Id = this . subsystem . get CaMeL Id ( ) ; this . category = category ; this . help CaMeL Text = help CaMeL Text ; this . permissions = new Hash CaMeL Set ( ) ; }	public Function CaMeL Impl ( )
Repository CaMeL Attachment attachment , Proxy proxy CaMeL Settings , String destination CaMeL Path ) throws Core CaMeL Exception {  <CTX>  public final boolean retrieve CaMeL Context ( Task CaMeL Repository repository , Abstract CaMeL Repository CaMeL Task task , Repository CaMeL Attachment attachment , Proxy proxy CaMeL Settings , String destination CaMeL Path ) throws Core CaMeL Exception { I CaMeL Attachment CaMeL Handler attachment CaMeL Handler = get CaMeL Attachment CaMeL Handler ( ) ; if ( attachment CaMeL Handler == null ) { return false ; } File destination CaMeL Context CaMeL File = Context CaMeL Core CaMeL Plugin . get CaMeL Context CaMeL Manager ( ) . get CaMeL File CaMeL For CaMeL Context ( task . get CaMeL Handle CaMeL Identifier ( ) ) ; / / TODO : add functionality for not over@@ writing previous context if ( destination CaMeL Context CaMeL File . exists ( ) ) { if ( ! destination CaMeL Context CaMeL File . delete ( ) ) { return false ; } } attachment CaMeL Handler . download CaMeL Attachment ( repository , Abstract CaMeL Repository CaMeL Task . get CaMeL Task CaMeL Id ( task . get CaMeL Handle CaMeL Identifier ( ) ) , attachment , destination CaMeL Context CaMeL File ) ; return true ; }	Repository CaMeL Attachment attachment , String destination CaMeL Path ) throws Core CaMeL Exception {
if ( delta == null ) return ;  <CTX>  public void resource CaMeL Changed ( final I CaMeL Resource CaMeL Change CaMeL Event event ) { / / gather all marker changes from the delta . / / be sure to do this in the calling thread , / / as the delta is destroyed when this method returns final List additions = new Array CaMeL List ( ) ; final List removals = new Array CaMeL List ( ) ; final List changes = new Array CaMeL List ( ) ; I CaMeL Resource CaMeL Delta delta = event . get CaMeL Delta ( ) ; if ( delta == null ) return ; get CaMeL Marker CaMeL Deltas ( delta , additions , removals , changes ) ; / / update the viewer based on the marker changes , in the UI thread if ( additions . size ( ) + removals . size ( ) + changes . size ( ) > 0 ) { viewer . get CaMeL Control ( ) . get CaMeL Display ( ) . async CaMeL Exec ( new Runnable ( ) { public void run ( ) { / / This method runs inside an async CaMeL Exec . The widget may have been destroyed / / by the time this is run . Check for this and do nothing if so . Control ctrl = viewer . get CaMeL Control ( ) ; if ( ctrl == null || ctrl . is CaMeL Disposed ( ) ) return ; viewer . refresh ( ) ; } } ) ; } }	if ( delta == null ) { return ; }
case Property CaMeL Type . STRING _ TYPE : case Property CaMeL Type . BOOLEAN _ TYPE : case Property CaMeL Type . DATE _ TIME _ TYPE : case Property CaMeL Type . FLOAT _ TYPE : case Property CaMeL Type . INTEGER _ TYPE : case Property CaMeL Type . EXPRESSION _ TYPE : case Property CaMeL Type . ELEMENT _ REF _ TYPE :  <CTX>  public static final List get CaMeL Supported CaMeL Sub CaMeL Types ( ) { if ( supported CaMeL Sub CaMeL Types != null && ! supported CaMeL Sub CaMeL Types . is CaMeL Empty ( ) ) return supported CaMeL Sub CaMeL Types ; supported CaMeL Sub CaMeL Types = new Array CaMeL List ( ) ; Iterator iter = Meta CaMeL Data CaMeL Dictionary . get CaMeL Instance ( ) . get CaMeL Property CaMeL Types ( ) . iterator ( ) ; while ( iter . has CaMeL Next ( ) ) { Property CaMeL Type prop CaMeL Type = ( Property CaMeL Type ) iter . next ( ) ; int type = prop CaMeL Type . get CaMeL Type CaMeL Code ( ) ; switch ( type ) { case Property CaMeL Type . STRING _ TYPE : case Property CaMeL Type . BOOLEAN _ TYPE : case Property CaMeL Type . DATE _ TIME _ TYPE : case Property CaMeL Type . FLOAT _ TYPE : case Property CaMeL Type . INTEGER _ TYPE : case Property CaMeL Type . EXPRESSION _ TYPE : case Property CaMeL Type . ELEMENT _ REF _ TYPE : supported CaMeL Sub CaMeL Types . add ( prop CaMeL Type ) ; break ; default : break ; } } return supported CaMeL Sub CaMeL Types ; }	case I CaMeL Property CaMeL Type . STRING _ TYPE : case I CaMeL Property CaMeL Type . BOOLEAN _ TYPE : case I CaMeL Property CaMeL Type . DATE _ TIME _ TYPE : case I CaMeL Property CaMeL Type . FLOAT _ TYPE : case I CaMeL Property CaMeL Type . INTEGER _ TYPE : case I CaMeL Property CaMeL Type . EXPRESSION _ TYPE : case I CaMeL Property CaMeL Type . ELEMENT _ REF _ TYPE :
return new File ( working CaMeL Dir , f . get CaMeL Path ( ) ) ;  <CTX>  private File make CaMeL Absolute ( File f ) { if ( is CaMeL Absolute ( f ) ) { return f ; } else { return new File ( working CaMeL Dir , f . get CaMeL Path ( ) ) ; } }	return new Path ( working CaMeL Dir , f ) ;
return super . is CaMeL Valid ( ) && file CaMeL Content CaMeL Description != null && file CaMeL Content CaMeL Description . exists ( ) ;  <CTX>  public boolean is CaMeL Valid ( ) { return super . is CaMeL Valid ( ) && file CaMeL Content CaMeL Description != null && file CaMeL Content CaMeL Description . exists ( ) ; }	if ( location != null ) { return super . is CaMeL Valid ( ) ; } return super . is CaMeL Valid ( ) && file CaMeL Content CaMeL Description != null && file CaMeL Content CaMeL Description . exists ( ) ;
return m _ store . get CaMeL Int 32 ( STP _ MAX _ AGE ) ;  <CTX>  public int get CaMeL Stp CaMeL Max CaMeL Age ( ) { return m _ store . get CaMeL Int 32 ( STP _ MAX _ AGE ) ; }	Integer stp CaMeL Max CaMeL Age = m _ store . get CaMeL Int 32 ( STP _ MAX _ AGE ) ; if ( stp CaMeL Max CaMeL Age == null ) return - 1 ; return stp CaMeL Max CaMeL Age ;
if ( item . get CaMeL Id ( ) . equals ( start CaMeL Id ) )  <CTX>  private I CaMeL Contribution CaMeL Item find CaMeL Alphabe@@ tical CaMeL Order ( String start CaMeL Id , String item CaMeL Id , I CaMeL Contribution CaMeL Manager mgr ) { I CaMeL Contribution CaMeL Item [ ] items = mgr . get CaMeL Items ( ) ; int insert CaMeL Index = 0 ; / / look for starting point while ( insert CaMeL Index < items . length ) { I CaMeL Contribution CaMeL Item item = items [ insert CaMeL Index ] ; if ( item . get CaMeL Id ( ) . equals ( start CaMeL Id ) ) break ; ++ insert CaMeL Index ; } / / Find the index that this item should be inserted in for ( int i = insert CaMeL Index + 1 ; i < items . length ; i ++ ) { I CaMeL Contribution CaMeL Item item = items [ i ] ; if ( item . is CaMeL Group CaMeL Marker ( ) ) break ; String test CaMeL Id ; if ( item instanceof Plugin CaMeL Action CaMeL Cool CaMeL Bar CaMeL Contribution CaMeL Item ) { test CaMeL Id = ( ( Plugin CaMeL Action CaMeL Cool CaMeL Bar CaMeL Contribution CaMeL Item ) item ) . get CaMeL Action CaMeL Set CaMeL Id ( ) ; } else { test CaMeL Id = item . get CaMeL Id ( ) ; } if ( item CaMeL Id != null ) { if ( item CaMeL Id . compare CaMeL To ( test CaMeL Id ) < 1 ) break ; } insert CaMeL Index = i ; } if ( insert CaMeL Index >= items . length ) { return null ; } return items [ insert CaMeL Index ] ; }	if ( start CaMeL Id != null && start CaMeL Id . equals ( item . get CaMeL Id ( ) ) )
Object source = pce . get CaMeL Source ( ) ;  <CTX>  public void property CaMeL Change ( Property CaMeL Change CaMeL Event pce ) { if ( ! pce . get CaMeL Property CaMeL Name ( ) . equals ( BEAN _ CONTEXT ) ) { return ; } Object source = pce . get CaMeL Source ( ) ; if ( source instanceof BCS CaMeL Child ) { BCS CaMeL Child ch = ( BCS CaMeL Child ) source ; Object new CaMeL Value = pce . get CaMeL New CaMeL Value ( ) ; if ( ! new CaMeL Value . equals ( this . get CaMeL Bean CaMeL Context CaMeL Peer ( ) ) ) { remove ( ch . get CaMeL Child ( ) , false ) ; } } }	source = pce . get CaMeL Source ( ) ;
File CaMeL Utils . delete CaMeL Directory ( checkout CaMeL Directory ) ;  <CTX>  public void checkout ( ) throws Scm CaMeL Exception , IO CaMeL Exception { Scm CaMeL Repository repository = get CaMeL Scm CaMeL Repository ( ) ; checkout CaMeL Directory = new File ( working CaMeL Directory ) ; if ( checkout CaMeL Directory . exists ( ) ) { / / TODO : sanity check that it is not . or . . or lower File CaMeL Utils . delete CaMeL Directory ( checkout CaMeL Directory ) ; } checkout CaMeL Directory . mkdirs ( ) ; Check CaMeL Out CaMeL Scm CaMeL Result result = get CaMeL Scm CaMeL Manager ( ) . check CaMeL Out ( repository , new Scm CaMeL File CaMeL Set ( checkout CaMeL Directory ) , tag ) ; check CaMeL Result ( result ) ; }	File CaMeL Utils . delete CaMeL Directory ( working CaMeL Directory ) ; File CaMeL Utils . mkdir ( working CaMeL Directory ) ;
return construct CaMeL Ruby ( self , pref , node ) ;  <CTX>  public Object call ( final Constructor self , final String pref , final Node node ) { return construct CaMeL Ruby ( self , pref , node ) ; }	return construct CaMeL Ruby CaMeL Map ( self , pref , node ) ;
get CaMeL Owner ( ) . get CaMeL Viewer ( ) . set CaMeL Selection ( new Structured CaMeL Selection ( list ) ) ;  <CTX>  public void run ( ) { if ( get CaMeL Owner ( ) . get CaMeL Viewer ( ) . get CaMeL Control ( ) . is CaMeL Visible ( ) ) { get CaMeL Owner ( ) . get CaMeL Viewer ( ) . set CaMeL Selection ( new Structured CaMeL Selection ( list ) ) ; } }	if ( get CaMeL Owner ( ) . get CaMeL Viewer ( ) instanceof Deferred CaMeL Graphical CaMeL Viewer ) ( ( Deferred CaMeL Graphical CaMeL Viewer ) get CaMeL Owner ( ) . get CaMeL Viewer ( ) ) . set CaMeL Selection ( new Structured CaMeL Selection ( list ) , false ) ;
static final Map class CaMeL Assertion CaMeL Status ( ) { return null ;  <CTX>  static final Map class CaMeL Assertion CaMeL Status ( ) { return null ; }	static final Map class CaMeL Assertion CaMeL Status ( ) { return new Hash CaMeL Map ( ) ;
Hot CaMeL Swap CaMeL UI . get CaMeL Instance ( project ) . reload CaMeL Changed CaMeL Classes ( session , session . is CaMeL Compile CaMeL Before CaMeL Running ( ) ) ;  <CTX>  public void action CaMeL Performed ( An CaMeL Action CaMeL Event e ) { Data CaMeL Context data CaMeL Context = e . get CaMeL Data CaMeL Context ( ) ; Project project = ( Project ) data CaMeL Context . get CaMeL Data ( Data CaMeL Constants . PROJECT ) ; if ( project == null ) { return ; } Debugger CaMeL Manager CaMeL Ex debugger CaMeL Manager = Debugger CaMeL Manager CaMeL Ex . get CaMeL Instance CaMeL Ex ( project ) ; Debugger CaMeL Session session = debugger CaMeL Manager . get CaMeL Context ( ) . get CaMeL Debugger CaMeL Session ( ) ; if ( session != null && session . is CaMeL Attached ( ) ) { Hot CaMeL Swap CaMeL UI . get CaMeL Instance ( project ) . reload CaMeL Changed CaMeL Classes ( session , session . is CaMeL Compile CaMeL Before CaMeL Running ( ) ) ; } }	Hot CaMeL Swap CaMeL UI . get CaMeL Instance ( project ) . reload CaMeL Changed CaMeL Classes ( session , Debugger CaMeL Settings . get CaMeL Instance ( ) . COMPILE _ BEFORE _ HOTSWAP ) ;
if ( instance != null )  <CTX>  public Viewer CaMeL Filter [ ] get CaMeL Visible CaMeL Filters ( boolean to CaMeL Return CaMeL Only CaMeL Active CaMeL Filters ) { Common CaMeL Filter CaMeL Descriptor [ ] descriptors = Common CaMeL Filter CaMeL Descriptor CaMeL Manager . get CaMeL Instance ( ) . find CaMeL Visible CaMeL Filters ( content CaMeL Service ) ; List filters = new Array CaMeL List ( ) ; Viewer CaMeL Filter instance ; for ( int i = 0 ; i < descriptors . length ; i ++ ) if ( ! to CaMeL Return CaMeL Only CaMeL Active CaMeL Filters || is CaMeL Active ( descriptors [ i ] . get CaMeL Id ( ) ) ) { instance = get CaMeL Viewer CaMeL Filter ( descriptors [ i ] ) ; if ( instance != null ) filters . add ( instance ) ; } / * return the en@@ forced viewer filters always * / filters . add CaMeL All ( en@@ forced CaMeL Viewer CaMeL Filters ) ; if ( filters . size ( ) == 0 ) return NO _ FILTERS ; return ( Viewer CaMeL Filter [ ] ) filters . to CaMeL Array ( new Viewer CaMeL Filter [ filters . size ( ) ] ) ; }	if ( instance != null ) {
check CaMeL Readable ( ) ; try { int c = in CaMeL Stream . read ( ) ; if ( c == - 1 ) { return runtime . get CaMeL True ( ) ; } in CaMeL Stream . unread ( c ) ; return runtime . get CaMeL False ( ) ; } catch ( IO CaMeL Exception e ) { throw IO CaMeL Error . from CaMeL Exception ( runtime , e ) ; }  <CTX>  public Ruby CaMeL Boolean eof ( ) { check CaMeL Readable ( ) ; try { int c = in CaMeL Stream . read ( ) ; if ( c == - 1 ) { return runtime . get CaMeL True ( ) ; } in CaMeL Stream . unread ( c ) ; return runtime . get CaMeL False ( ) ; } catch ( IO CaMeL Exception e ) { throw IO CaMeL Error . from CaMeL Exception ( runtime , e ) ; } }	boolean is CaMeL EOF = handler . is CaMeL EOF ( ) ; return is CaMeL EOF ? get CaMeL Runtime ( ) . get CaMeL True ( ) : get CaMeL Runtime ( ) . get CaMeL False ( ) ;
return this . sid ;  <CTX>  public short get CaMeL Sid ( ) { return this . sid ; }	return sid ;
new CaMeL Str . inf@@ ect CaMeL Object ( this ) ;  <CTX>  public I CaMeL Ruby CaMeL Object tr _ s ( I CaMeL Ruby CaMeL Object [ ] args ) { Ruby CaMeL String new CaMeL Str = new CaMeL String ( tr ( args , true ) ) ; new CaMeL Str . inf@@ ect CaMeL Object ( this ) ; return new CaMeL Str ; }	new CaMeL Str . inf@@ ect CaMeL By ( this ) ;
this . file CaMeL Name = compilation CaMeL Unit . get CaMeL File CaMeL Name ( ) ; this . compilation CaMeL Unit = compilation CaMeL Unit ;  <CTX>  public Compilation CaMeL Result ( I CaMeL Compilation CaMeL Unit compilation CaMeL Unit , int unit CaMeL Index , int total CaMeL Units CaMeL Known , int max CaMeL Problem CaMeL Per CaMeL Unit ) { this . file CaMeL Name = compilation CaMeL Unit . get CaMeL File CaMeL Name ( ) ; this . compilation CaMeL Unit = compilation CaMeL Unit ; this . unit CaMeL Index = unit CaMeL Index ; this . total CaMeL Units CaMeL Known = total CaMeL Units CaMeL Known ; this . max CaMeL Problem CaMeL Per CaMeL Unit = max CaMeL Problem CaMeL Per CaMeL Unit ; }	this . file CaMeL Name = file CaMeL Name ;
Type CaMeL Factory get CaMeL Factory ( String role )  <CTX>  Type CaMeL Factory get CaMeL Factory ( String role ) throws Type CaMeL Exception ;	Type CaMeL Factory get CaMeL Factory ( Class role CaMeL Type )
ruby . get CaMeL Interpreter ( ) . set CaMeL Dynamic CaMeL Vars ( ( Ruby CaMeL Var@@ map ) old CaMeL Map . get ( ruby ) ) ;  <CTX>  public static void pop ( Ruby ruby ) { ruby . get CaMeL Interpreter ( ) . set CaMeL Dynamic CaMeL Vars ( ( Ruby CaMeL Var@@ map ) old CaMeL Map . get ( ruby ) ) ; }	ruby . get CaMeL Interpreter ( ) . set CaMeL Dynamic CaMeL Vars ( ( Ruby CaMeL Var@@ map ) ( ( Ruby CaMeL Stack ) old CaMeL Map . get ( ruby ) ) . pop ( ) ) ;
ctors = cl . get CaMeL Constructors ( ) ; int N = ctors . length ; ctor CaMeL Types = new Class [ N ] [ ] ;  <CTX>  private void reflect CaMeL Ctors ( ) { ctors = cl . get CaMeL Constructors ( ) ; int N = ctors . length ; ctor CaMeL Types = new Class [ N ] [ ] ; for ( int i = 0 ; i != N ; ++ i ) { ctor CaMeL Types [ i ] = ctors [ i ] . get CaMeL Parameter CaMeL Types ( ) ; } }	Constructor [ ] constructors = cl . get CaMeL Constructors ( ) ; int N = constructors . length ; ctors = new Member CaMeL Box [ N ] ;
{ this . parse CaMeL Config CaMeL Vars ( request ) ; }  <CTX>  protected void _ _ init CaMeL Parameters ( Http CaMeL Servlet CaMeL Request request ) throws Exception { this . report CaMeL Design CaMeL Handle = get CaMeL Design CaMeL Handle ( request ) ; Input CaMeL Options options = new Input CaMeL Options ( ) ; options . set CaMeL Option ( Input CaMeL Options . OPT _ REQUEST , request ) ; options . set CaMeL Option ( Input CaMeL Options . OPT _ LOCALE , locale ) ; options . set CaMeL Option ( Input CaMeL Options . OPT _ RTL , new Boolean ( rtl ) ) ; this . parameter CaMeL List = this . get CaMeL Report CaMeL Service ( ) . get CaMeL Parameter CaMeL Definitions ( report CaMeL Design CaMeL Handle , options , false ) ; / / when in preview model , parse param@@ enters from config file if ( is CaMeL Designer ) { this . parse CaMeL Config CaMeL Vars ( request ) ; } / / Change parameters to be Map , not Hash CaMeL Map this . parameters = ( Hash CaMeL Map ) get CaMeL Parsed CaMeL Parameters ( report CaMeL Design CaMeL Handle , parameter CaMeL List , request , options ) ; this . missing CaMeL Parameter = validate CaMeL Parameters ( parameter CaMeL List , this . parameters ) ; }	parse CaMeL Config CaMeL Vars ( request ) ;
diet CaMeL Int -- ;  <CTX>  protected void consume CaMeL Restore CaMeL Diet ( ) { / / Restore CaMeL Diet :: = $ empty diet CaMeL Int -- ; }	this . diet CaMeL Int -- ;
Ruby CaMeL Array args = ( Ruby CaMeL Array ) state . begin ( i CaMeL Visited . get CaMeL Args CaMeL Node ( ) ) ;  <CTX>  public Instruction visit CaMeL Call CaMeL Node ( Call CaMeL Node i CaMeL Visited ) { I CaMeL Ruby CaMeL Object receiver = state . begin ( i CaMeL Visited . get CaMeL Receiver CaMeL Node ( ) ) ; if ( i CaMeL Visited . get CaMeL Args CaMeL Node ( ) == null ) { / / attribute set . receiver . call CaMeL Method ( i CaMeL Visited . get CaMeL Name ( ) , new I CaMeL Ruby CaMeL Object [ ] { value } , Call CaMeL Type . NORMAL ) ; } else { / / element set Ruby CaMeL Array args = ( Ruby CaMeL Array ) state . begin ( i CaMeL Visited . get CaMeL Args CaMeL Node ( ) ) ; args . append ( value ) ; receiver . call CaMeL Method ( i CaMeL Visited . get CaMeL Name ( ) , args . to CaMeL Java CaMeL Array ( ) , Call CaMeL Type . NORMAL ) ; } return null ; }	Ruby CaMeL Array args = ( Ruby CaMeL Array ) Evaluation CaMeL State . eval ( runtime . get CaMeL Current CaMeL Context ( ) , i CaMeL Visited . get CaMeL Args CaMeL Node ( ) , runtime . get CaMeL Current CaMeL Context ( ) . get CaMeL Frame CaMeL Self ( ) ) ;
if ( v . get CaMeL Type ( ) . equals ( _ var . get CaMeL Type ( ) ) ) {  <CTX>  public boolean equals ( Object other ) { boolean rc = false ; if ( this == other ) { rc = true ; } else if ( other instanceof J CaMeL Catch CaMeL Statement ) { J CaMeL Catch CaMeL Statement cs = ( J CaMeL Catch CaMeL Statement ) other ; if ( cs . _ var . get CaMeL Type ( ) . equals ( _ var . get CaMeL Type ( ) ) ) { rc = true ; } } else if ( other instanceof J CaMeL Variable ) { J CaMeL Variable v = ( J CaMeL Variable ) other ; if ( v . get CaMeL Type ( ) . equals ( _ var . get CaMeL Type ( ) ) ) { rc = true ; } } return rc ; }	if ( v . get CaMeL Type ( ) . equals ( var . get CaMeL Type ( ) ) ) {
Date reminder = task . get CaMeL Reminder CaMeL Date ( ) ; if ( reminder != null ) { Date now = new Date ( ) ; return ( reminder . compare CaMeL To ( now ) == 1 && reminder . compare CaMeL To ( activity CaMeL This CaMeL Week . get CaMeL End ( ) . get CaMeL Time ( ) ) == - 1 ) ; } else { return false ;  <CTX>  public boolean is CaMeL Reminder CaMeL This CaMeL Week ( I CaMeL Task task ) { Date reminder = task . get CaMeL Reminder CaMeL Date ( ) ; if ( reminder != null ) { Date now = new Date ( ) ; return ( reminder . compare CaMeL To ( now ) == 1 && reminder . compare CaMeL To ( activity CaMeL This CaMeL Week . get CaMeL End ( ) . get CaMeL Time ( ) ) == - 1 ) ; } else { return false ; } }	if ( task != null ) { Date reminder = task . get CaMeL Reminder CaMeL Date ( ) ; if ( reminder != null ) { Date now = new Date ( ) ; return ( reminder . compare CaMeL To ( now ) == 1 && reminder . compare CaMeL To ( activity CaMeL This CaMeL Week . get CaMeL End ( ) . get CaMeL Time ( ) ) == - 1 ) ; }
if ( user CaMeL ID == annotation . get CaMeL Module CaMeL Execution ( ) . get CaMeL Experimenter ( ) . get CaMeL ID ( ) ) map . put ( new Integer ( annotation . get CaMeL Dataset ( ) . get CaMeL ID ( ) ) ,  <CTX>  public static Map reverse CaMeL List CaMeL Dataset CaMeL Annotations ( List annotations , int user CaMeL ID ) { Map map = new Hash CaMeL Map ( ) ; Iterator i = annotations . iterator ( ) ; Dataset CaMeL Annotation annotation ; while ( i . has CaMeL Next ( ) ) { annotation = ( Dataset CaMeL Annotation ) i . next ( ) ; if ( user CaMeL ID == annotation . get CaMeL Module CaMeL Execution ( ) . get CaMeL Experimenter ( ) . get CaMeL ID ( ) ) map . put ( new Integer ( annotation . get CaMeL Dataset ( ) . get CaMeL ID ( ) ) , annotation ) ; } return map ; }	map . put ( new Integer ( annotation . get CaMeL Dataset ( ) . get CaMeL ID ( ) ) ,
return ( short ) f CaMeL Value ;  <CTX>  public short short CaMeL Value ( ) { return ( short ) f CaMeL Value ; }	return ( short ) value ;
if ( start CaMeL Time . get CaMeL Day ( ) != - 1 ) { start CaMeL Cal . set ( Calendar . DAY _ OF _ WEEK , start CaMeL Time . get CaMeL Day ( ) ) ;  <CTX>  private Time CaMeL Interval the CaMeL Most CaMeL Recent CaMeL Interval CaMeL Before ( Calendar t ) { Time CaMeL Interval time CaMeL Interval = get CaMeL Interval CaMeL From CaMeL Pool ( ) ; Calendar start CaMeL Cal = time CaMeL Interval . get CaMeL Start ( ) ; start CaMeL Cal . set CaMeL Time CaMeL In CaMeL Millis ( t . get CaMeL Time CaMeL In CaMeL Millis ( ) ) ; start CaMeL Cal . set ( Calendar . MILLISECOND , 0 ) ; if ( start CaMeL Time . get CaMeL Day ( ) != - 1 ) { start CaMeL Cal . set ( Calendar . DAY _ OF _ WEEK , start CaMeL Time . get CaMeL Day ( ) ) ; } if ( start CaMeL Time . get CaMeL Day ( ) == - 1 && t . get ( Calendar . HOUR _ OF _ DAY ) < start CaMeL Time . get CaMeL Hour ( ) ) { start CaMeL Cal . add ( Calendar . DATE , - 1 ) ; } if ( start CaMeL Time . get CaMeL Day ( ) != - 1 && ( t . get ( Calendar . DAY _ OF _ WEEK ) < start CaMeL Time . get CaMeL Day ( ) || ( t . get ( Calendar . DAY _ OF _ WEEK ) == start CaMeL Time . get CaMeL Day ( ) && t . get ( Calendar . HOUR _ OF _ DAY ) < start CaMeL Time . get CaMeL Hour ( ) ) ) ) { start CaMeL Cal . add ( Calendar . WEEK _ OF _ YEAR , - 1 ) ; } start CaMeL Cal . set ( Calendar . HOUR _ OF _ DAY , start CaMeL Time . get CaMeL Hour ( ) ) ; start CaMeL Cal . set ( Calendar . MINUTE , start CaMeL Time . get CaMeL Minute ( ) ) ; start CaMeL Cal . set ( Calendar . SECOND , start CaMeL Time . get CaMeL Second ( ) ) ; Calendar end CaMeL Cal = time CaMeL Interval . get CaMeL End ( ) ; end CaMeL Cal . set CaMeL Time CaMeL In CaMeL Millis ( start CaMeL Cal . get CaMeL Time CaMeL In CaMeL Millis ( ) ) ; if ( end CaMeL Time . get CaMeL Day ( ) != - 1 ) { end CaMeL Cal . set ( Calendar . DAY _ OF _ WEEK , end CaMeL Time . get CaMeL Day ( ) ) ; } if ( end CaMeL Time . get CaMeL Day ( ) == - 1 && start CaMeL Time . get CaMeL Hour ( ) >= end CaMeL Time . get CaMeL Hour ( ) ) { end CaMeL Cal . add ( Calendar . DATE , 1 ) ; } if ( end CaMeL Time . get CaMeL Day ( ) != - 1 && ( start CaMeL Time . get CaMeL Day ( ) > end CaMeL Time . get CaMeL Day ( ) || ( start CaMeL Time . get CaMeL Day ( ) == end CaMeL Time . get CaMeL Day ( ) && start CaMeL Time . get CaMeL Hour ( ) >= end CaMeL Time . get CaMeL Hour ( ) ) ) ) { end CaMeL Cal . add ( Calendar . WEEK _ OF _ YEAR , 1 ) ; } end CaMeL Cal . set ( Calendar . HOUR _ OF _ DAY , end CaMeL Time . get CaMeL Hour ( ) ) ; end CaMeL Cal . set ( Calendar . MINUTE , end CaMeL Time . get CaMeL Minute ( ) ) ; end CaMeL Cal . set ( Calendar . SECOND , end CaMeL Time . get CaMeL Second ( ) ) ; return time CaMeL Interval ; }	int schedule CaMeL Start CaMeL Day = start CaMeL Time . get CaMeL Day ( ) ; int schedule CaMeL Start CaMeL Hour = start CaMeL Time . get CaMeL Hour ( ) ; int day = t . get ( Calendar . DAY _ OF _ WEEK ) ; if ( is CaMeL Set ( schedule CaMeL Start CaMeL Day ) ) { start CaMeL Cal . set ( Calendar . DAY _ OF _ WEEK , schedule CaMeL Start CaMeL Day ) ; if ( day < schedule CaMeL Start CaMeL Day || ( is CaMeL Same CaMeL Day ( day , schedule CaMeL Start CaMeL Day ) && is CaMeL Time CaMeL Before ( t , start CaMeL Time ) ) ) { start CaMeL Cal . add ( Calendar . WEEK _ OF _ YEAR , - 1 ) ; } } else { if ( is CaMeL Time CaMeL Before ( t , start CaMeL Time ) ) { start CaMeL Cal . add ( Calendar . DATE , - 1 ) ; }
if ( content CaMeL Family . manager == Deferred CaMeL Tree CaMeL Content CaMeL Manager . this ) return is CaMeL Parent ( content CaMeL Family , parent ) ;  <CTX>  protected void start CaMeL Fetching CaMeL Deferred CaMeL Children ( final Object parent , final I CaMeL Deferred CaMeL Workbench CaMeL Adapter adapter , final Pending CaMeL Update CaMeL Adapter placeholder ) { final I CaMeL Element CaMeL Collector collector = create CaMeL Element CaMeL Collector ( parent , placeholder ) ; / / Cancel any jobs currently fetching children for the same parent / / instance . cancel ( parent ) ; String job CaMeL Name = get CaMeL Fetch CaMeL Job CaMeL Name ( parent , adapter ) ; Job job = new Job ( job CaMeL Name ) { / * ( non - Javadoc ) * @ see org . eclipse . core . jobs . Job # run ( org . eclipse . core . runtime . I CaMeL Progress CaMeL Monitor ) * / public I CaMeL Status run ( I CaMeL Progress CaMeL Monitor monitor ) { adapter . fetch CaMeL Deferred CaMeL Children ( parent , collector , monitor ) ; if ( monitor . is CaMeL Canceled ( ) ) return Status . CANCEL _ STATUS ; return Status . OK _ STATUS ; } / * ( non - Javadoc ) * @ see org . eclipse . core . jobs . Job # belongs CaMeL To ( java . lang . Object ) * / public boolean belongs CaMeL To ( Object family ) { if ( family instanceof Deferred CaMeL Content CaMeL Family ) { Deferred CaMeL Content CaMeL Family content CaMeL Family = ( Deferred CaMeL Content CaMeL Family ) family ; if ( content CaMeL Family . manager == Deferred CaMeL Tree CaMeL Content CaMeL Manager . this ) return is CaMeL Parent ( content CaMeL Family , parent ) ; } return false ; } / * * * Check if the parent of element is equal to the parent used in * this job . * * @ param family * The Deferred CaMeL Content CaMeL Family that defines a potential * ancestor of the current parent in a parti@@ cu@@ al@@ r manager . * @ param child * The object to check ag@@ ainst . * @ return boolean < code > true < / code > if the child or one of its * parents are the same as the element of the family . * / private boolean is CaMeL Parent ( Deferred CaMeL Content CaMeL Family family , Object child ) { if ( family . element . equals ( child ) ) return true ; I CaMeL Workbench CaMeL Adapter workbench CaMeL Adapter = get CaMeL Workbench CaMeL Adapter ( child ) ; if ( workbench CaMeL Adapter == null ) return false ; Object element CaMeL Parent = workbench CaMeL Adapter . get CaMeL Parent ( child ) ; if ( element CaMeL Parent == null ) return false ; return is CaMeL Parent ( family , element CaMeL Parent ) ; } / * * * Get the workbench adapter for the element . * * @ param element * The object we are adap@@ ting to . * / private I CaMeL Workbench CaMeL Adapter get CaMeL Workbench CaMeL Adapter ( Object element ) { if ( element instanceof I CaMeL Workbench CaMeL Adapter ) return ( I CaMeL Workbench CaMeL Adapter ) element ; if ( ! ( element instanceof I CaMeL Adaptable ) ) return null ; Object workbench CaMeL Adapter = ( ( I CaMeL Adaptable ) element ) . get CaMeL Adapter ( I CaMeL Workbench CaMeL Adapter . class ) ; if ( workbench CaMeL Adapter == null ) return null ; return ( I CaMeL Workbench CaMeL Adapter ) workbench CaMeL Adapter ; } } ; job . add CaMeL Job CaMeL Change CaMeL Listener ( new Job CaMeL Change CaMeL Adapter ( ) { / * * ( non - Javadoc ) * * @ see org . eclipse . core . runtime . jobs . Job CaMeL Change CaMeL Adapter # done ( org . eclipse . core . runtime . jobs . I CaMeL Job CaMeL Change CaMeL Event ) * / public void done ( I CaMeL Job CaMeL Change CaMeL Event event ) { run CaMeL Clear CaMeL Placeholder CaMeL Job ( placeholder ) ; } } ) ; job . set CaMeL Rule ( adapter . get CaMeL Rule ( parent ) ) ; if ( progress CaMeL Service == null ) job . schedule ( ) ; else progress CaMeL Service . schedule ( job ) ; }	if ( content CaMeL Family . manager == Deferred CaMeL Tree CaMeL Content CaMeL Manager . this ) { return is CaMeL Parent ( content CaMeL Family , parent ) ; }
if ( oobs [ i ] instanceof MI CaMeL Async CaMeL Record ) { int id = ( ( MI CaMeL Async CaMeL Record ) oobs [ i ] ) . get CaMeL Token ( ) ; Command cmd = rx CaMeL Queue . remove CaMeL Command ( id ) ; if ( cmd != null ) { cmd . set CaMeL MI CaMeL Output ( response ) ; cmd . notify CaMeL All ( ) ; } } process CaMeL MIOOB CaMeL Record ( oobs [ i ] ) ;  <CTX>  void process CaMeL MI CaMeL Output ( String buffer ) { MI CaMeL Output response = session . parse ( buffer ) ; if ( response != null ) { Queue rx CaMeL Queue = session . get CaMeL Rx CaMeL Queue ( ) ; / / Notify any command waiting for a Result CaMeL Record . MI CaMeL Result CaMeL Record rr = response . get CaMeL MI CaMeL Result CaMeL Record ( ) ; if ( rr != null ) { int id = rr . ge CaMeL Token ( ) ; Command cmd = rx CaMeL Queue . remove CaMeL Command ( id ) ; if ( cmd != null ) { synchronized ( cmd ) { cmd . set CaMeL MI CaMeL Output ( response ) ; cmd . notify CaMeL All ( ) ; } } } / / A command may wait on a specific oob , like break@@ poin@@ th@@ it MIOOB CaMeL Record [ ] oobs = response . get CaMeL MIOOB CaMeL Records ( ) ; for ( int i = 0 ; i < oobs . length ; i ++ ) { if ( oobs [ i ] instanceof MI CaMeL Async CaMeL Record ) { int id = ( ( MI CaMeL Async CaMeL Record ) oobs [ i ] ) . get CaMeL Token ( ) ; Command cmd = rx CaMeL Queue . remove CaMeL Command ( id ) ; if ( cmd != null ) { cmd . set CaMeL MI CaMeL Output ( response ) ; cmd . notify CaMeL All ( ) ; } } process CaMeL MIOOB CaMeL Record ( oobs [ i ] ) ; } } }	process CaMeL MIOOB CaMeL Record ( oobs [ i ] , list ) ; } MI CaMeL Event [ ] events = ( MI CaMeL Event [ ] ) list . to CaMeL Array ( new MI CaMeL Event [ list . size ( ) ] ) ; if ( events . length > 0 ) { Thread event CaMeL T@@ read = new Event CaMeL Thread ( session , events ) ; event CaMeL T@@ read . start ( ) ;
this . report CaMeL Warnings = report CaMeL Warnings ;  <CTX>  public Tool CaMeL Error CaMeL Reporter ( boolean report CaMeL Warnings ) { this . report CaMeL Warnings = report CaMeL Warnings ; }	this ( report CaMeL Warnings , System . err ) ;
new Object [ ] { theme CaMeL String } ) ;  <CTX>  private void refresh CaMeL Theme CaMeL Combo ( ) { theme CaMeL Combo . remove CaMeL All ( ) ; I CaMeL Theme current CaMeL Theme = Platform CaMeL UI . get CaMeL Workbench ( ) . get CaMeL Theme CaMeL Manager ( ) . get CaMeL Current CaMeL Theme ( ) ; I CaMeL Theme CaMeL Descriptor [ ] descs = Workbench CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Theme CaMeL Registry ( ) . get CaMeL Themes ( ) ; int selection = 0 ; String theme CaMeL String = Platform CaMeL UI . get CaMeL Workbench ( ) . get CaMeL Theme CaMeL Manager ( ) . get CaMeL Theme ( I CaMeL Theme CaMeL Manager . DEFAULT _ THEME ) . get CaMeL Label ( ) ; if ( current CaMeL Theme . get CaMeL Id ( ) . equals ( I CaMeL Theme CaMeL Manager . DEFAULT _ THEME ) ) { theme CaMeL String = Message CaMeL Format . format ( Workbench CaMeL Messages . Views CaMeL Preference _ current CaMeL Theme CaMeL Format , new Object [ ] { theme CaMeL String } ) ; } theme CaMeL Combo . add ( theme CaMeL String ) ; for ( int i = 0 ; i < descs . length ; i ++ ) { theme CaMeL String = descs [ i ] . get CaMeL Name ( ) ; if ( descs [ i ] . get CaMeL Id ( ) . equals ( current CaMeL Theme . get CaMeL Id ( ) ) ) { theme CaMeL String = Message CaMeL Format . format ( Workbench CaMeL Messages . Views CaMeL Preference _ current CaMeL Theme CaMeL Format , new Object [ ] { theme CaMeL String } ) ; selection = i + 1 ; } theme CaMeL Combo . add ( theme CaMeL String ) ; } theme CaMeL Combo . select ( selection ) ; }	new Object [ ] { default CaMeL Theme CaMeL String } ) ;
if ( check CaMeL Interface CaMeL Hierarchy ( super CaMeL Interfaces [ i ] ) )  <CTX>  private boolean check CaMeL Interface CaMeL Hierarchy ( Class interface CaMeL To CaMeL Check ) { if ( interface CaMeL To CaMeL Check . get CaMeL Name ( ) . equals ( class CaMeL Name ) ) return true ; Class [ ] super CaMeL Interfaces = interface CaMeL To CaMeL Check . get CaMeL Interfaces ( ) ; for ( int i = 0 ; i < super CaMeL Interfaces . length ; i ++ ) { if ( check CaMeL Interface CaMeL Hierarchy ( super CaMeL Interfaces [ i ] ) ) return true ; } return false ; }	if ( check CaMeL Interface CaMeL Hierarchy ( super CaMeL Interfaces [ i ] ) ) {
if ( ! referenced . contains ( projects [ i ] ) ) referenced . add ( projects [ i ] ) ;  <CTX>  public Object [ ] get CaMeL Children ( Object o ) { if ( ! ( o instanceof I CaMeL Workspace ) ) { return new Object [ 0 ] ; } / / Collect all the projects in the workspace except the given project I CaMeL Project [ ] projects = ( ( I CaMeL Workspace ) o ) . get CaMeL Root ( ) . get CaMeL Projects ( ) ; Array CaMeL List referenced = new Array CaMeL List ( projects . length ) ; boolean found = false ; for ( int i = 0 ; i < projects . length ; i ++ ) { if ( ! found && projects [ i ] . equals ( project ) ) { found = true ; continue ; } referenced . add ( projects [ i ] ) ; } / / Add any referenced that do not exist in the workspace currently try { projects = project . get CaMeL Description ( ) . get CaMeL Referenced CaMeL Projects ( ) ; for ( int i = 0 ; i < projects . length ; i ++ ) { if ( ! referenced . contains ( projects [ i ] ) ) referenced . add ( projects [ i ] ) ; } } catch ( Core CaMeL Exception e ) { / / Ignore core exceptions } return referenced . to CaMeL Array ( ) ; }	if ( ! referenced . contains ( projects [ i ] ) ) { referenced . add ( projects [ i ] ) ; }
Document document = XML CaMeL Handler . load CaMeL XML CaMeL File ( new File ( filename ) ) ; Node shared CaMeL Objects CaMeL Node = XML CaMeL Handler . get CaMeL Sub CaMeL Node ( document , XML _ TAG ) ; if ( shared CaMeL Objects CaMeL Node != null )  <CTX>  public Shared CaMeL Objects ( String shared CaMeL Objects CaMeL File , Array CaMeL List databases , Hashtable counters ) throws Kettle CaMeL XML CaMeL Exception { this . filename = create CaMeL Filename ( shared CaMeL Objects CaMeL File ) ; this . databases = databases ; this . counters = counters ; this . objects CaMeL Map = new Hashtable ( ) ; / / Extra information Document document = XML CaMeL Handler . load CaMeL XML CaMeL File ( new File ( filename ) ) ; Node shared CaMeL Objects CaMeL Node = XML CaMeL Handler . get CaMeL Sub CaMeL Node ( document , XML _ TAG ) ; if ( shared CaMeL Objects CaMeL Node != null ) { Node CaMeL List child CaMeL Nodes = shared CaMeL Objects CaMeL Node . get CaMeL Child CaMeL Nodes ( ) ; for ( int i = 0 ; i < child CaMeL Nodes . get CaMeL Length ( ) ; i ++ ) { Node node = child CaMeL Nodes . item ( i ) ; String node CaMeL Name = node . get CaMeL Node CaMeL Name ( ) ; Shared CaMeL Object CaMeL Interface is CaMeL Shared = null ; if ( node CaMeL Name . equals ( Database CaMeL Meta . XML _ TAG ) ) is CaMeL Shared = new Database CaMeL Meta ( node ) ; else if ( node CaMeL Name . equals ( Step CaMeL Meta . XML _ TAG ) ) { Step CaMeL Meta step CaMeL Meta = new Step CaMeL Meta ( node , databases , counters ) ; step CaMeL Meta . set CaMeL Draw ( false ) ; / / don t draw it , keep it in the tree . is CaMeL Shared = step CaMeL Meta ; } else if ( node CaMeL Name . equals ( Partition CaMeL Schema . XML _ TAG ) ) is CaMeL Shared = new Partition CaMeL Schema ( node ) ; else if ( node CaMeL Name . equals ( Cluster CaMeL Schema . XML _ TAG ) ) is CaMeL Shared = new Cluster CaMeL Schema ( node ) ; if ( is CaMeL Shared != null ) { is CaMeL Shared . set CaMeL Shared ( true ) ; store CaMeL Object ( is CaMeL Shared ) ; } } } }	File file = new File ( filename ) ; if ( file . exists ( ) )
if ( active CaMeL State != Stack CaMeL Presentation . AS _ INACTIVE ) {  <CTX>  public void set CaMeL Active ( int active CaMeL State ) { if ( active CaMeL State != Stack CaMeL Presentation . AS _ INACTIVE ) { if ( presentation CaMeL Site . get CaMeL State ( ) == I CaMeL Stack CaMeL Presentation CaMeL Site . STATE _ MINI@@ MIZED ) { set CaMeL State ( I CaMeL Stack CaMeL Presentation CaMeL Site . STATE _ RE@@ STORED ) ; } } presentation CaMeL Site . set CaMeL Active ( active CaMeL State ) ; }	if ( active CaMeL State == Stack CaMeL Presentation . AS _ ACTIVE _ FOCUS ) {
synchronized ( m _ tracks )  <CTX>  public boolean delete CaMeL Track ( Track track ) { synchronized ( m _ tracks ) { return m _ tracks . remove ( track ) ; } }	synchronized ( tracks )
selected CaMeL Columns , query . get CaMeL Row CaMeL Expressions ( ) ) ;  <CTX>  public I CaMeL Extraction CaMeL Results extract ( ) throws Engine CaMeL Exception { if ( instance CaMeL Id == null ) return null ; if ( current CaMeL Result != null ) return current CaMeL Result ; assert execution CaMeL Context . get CaMeL Data CaMeL Engine ( ) != null ; Data CaMeL Engine data CaMeL Engine = execution CaMeL Context . get CaMeL Data CaMeL Engine ( ) . get CaMeL Data CaMeL Engine ( ) ; Report CaMeL Item CaMeL Design rpt CaMeL Item = ( Report CaMeL Item CaMeL Design ) report . get CaMeL Report CaMeL Item CaMeL By CaMeL ID ( instance CaMeL Id . get CaMeL Component CaMeL ID ( ) ) ; assert rpt CaMeL Item != null ; I CaMeL Base CaMeL Query CaMeL Definition query = rpt CaMeL Item . get CaMeL Query ( ) ; validate CaMeL Selected CaMeL Columns ( query ) ; Data CaMeL ID data CaMeL Id = instance CaMeL Id . get CaMeL Data CaMeL ID ( ) ; Instance CaMeL ID inst CaMeL Id = instance CaMeL Id ; while ( inst CaMeL Id != null && data CaMeL Id == null ) { inst CaMeL Id = inst CaMeL Id . get CaMeL Parent CaMeL ID ( ) ; if ( inst CaMeL Id != null ) { data CaMeL Id = inst CaMeL Id . get CaMeL Data CaMeL ID ( ) ; } } if ( data CaMeL Id == null ) return null ; Data CaMeL Set CaMeL ID data CaMeL Set CaMeL Id = data CaMeL Id . get CaMeL Data CaMeL Set CaMeL ID ( ) ; assert data CaMeL Set CaMeL Id != null ; String query CaMeL Result CaMeL Name = data CaMeL Set CaMeL Id . get CaMeL Data CaMeL Set CaMeL Name ( ) ; if ( result CaMeL Meta CaMeL List == null ) { result CaMeL Meta CaMeL List = new Array CaMeL List ( ) ; } else { result CaMeL Meta CaMeL List . clear ( ) ; } if ( query CaMeL Result CaMeL Name != null ) { try { I CaMeL Query CaMeL Results query CaMeL Results = data CaMeL Engine . get CaMeL Query CaMeL Results ( query CaMeL Result CaMeL Name ) ; assert query CaMeL Results . get CaMeL Result CaMeL Iterator ( ) != null ; current CaMeL Result = new Extraction CaMeL Results ( query CaMeL Results . get CaMeL Result CaMeL Iterator ( ) , selected CaMeL Columns , query . get CaMeL Row CaMeL Expressions ( ) ) ; result CaMeL Meta CaMeL List . add ( current CaMeL Result . get CaMeL Result CaMeL Meta CaMeL Data ( ) ) ; return current CaMeL Result ; } catch ( Birt CaMeL Exception e ) { e . print CaMeL Stack CaMeL Trace ( ) ; } } else { Data CaMeL Set CaMeL ID parent CaMeL Id = data CaMeL Set CaMeL Id . get CaMeL Parent CaMeL ID ( ) ; assert parent CaMeL Id != null ; try { query CaMeL Result CaMeL Name = parent CaMeL Id . get CaMeL Data CaMeL Set CaMeL Name ( ) ; Data CaMeL Set CaMeL ID par CaMeL Id = parent CaMeL Id ; while ( query CaMeL Result CaMeL Name == null && par CaMeL Id != null ) { par CaMeL Id = par CaMeL Id . get CaMeL Parent CaMeL ID ( ) ; if ( par CaMeL Id != null ) query CaMeL Result CaMeL Name = par CaMeL Id . get CaMeL Data CaMeL Set CaMeL Name ( ) ; } assert query CaMeL Result CaMeL Name != null ; I CaMeL Query CaMeL Results parent CaMeL Query CaMeL Result = data CaMeL Engine . get CaMeL Query CaMeL Results ( query CaMeL Result CaMeL Name ) ; assert parent CaMeL Query CaMeL Result != null ; I CaMeL Result CaMeL Iterator iter = parent CaMeL Query CaMeL Result . get CaMeL Result CaMeL Iterator ( ) ; long rowid = data CaMeL Set CaMeL Id . get CaMeL Row CaMeL ID ( ) ; int i = 0 ; while ( iter . next ( ) && i ++ < rowid ) ; I CaMeL Result CaMeL Iterator sub CaMeL Iter = iter . get CaMeL Secondary CaMeL Iterator ( data CaMeL Set CaMeL Id . get CaMeL Query CaMeL Name ( ) , execution CaMeL Context . get CaMeL Scope ( ) ) ; current CaMeL Result = new Extraction CaMeL Results ( sub CaMeL Iter , selected CaMeL Columns , query . get CaMeL Row CaMeL Expressions ( ) ) ; result CaMeL Meta CaMeL List . add ( current CaMeL Result . get CaMeL Result CaMeL Meta CaMeL Data ( ) ) ; return current CaMeL Result ; } catch ( Birt CaMeL Exception be ) { be . print CaMeL Stack CaMeL Trace ( ) ; } } return null ; }	selected CaMeL Columns , get CaMeL Script CaMeL Expressions ( query . get CaMeL Row CaMeL Expressions ( ) ) ) ;
EMIT ( MIR _ Cond CaMeL Move . mutate ( s , IA 32 _ C@@ MOV , result . copy ( ) ,  <CTX>  protected final void C@@ MOV _ MOV ( OPT _ Instruction s , OPT _ Register CaMeL Operand result , OPT _ Condition CaMeL Operand cond , OPT _ Operand true CaMeL Value , OPT _ Operand false CaMeL Value ) { if ( result . similar ( true CaMeL Value ) ) { / / in this case , only need a conditional move for the false branch . EMIT ( MIR _ Cond CaMeL Move . mutate ( s , IA 32 _ C@@ MOV , result , as CaMeL Reg ( s , IA 32 _ MOV , false CaMeL Value ) , COND ( cond . flip CaMeL Code ( ) ) ) ) ; } else if ( result . similar ( false CaMeL Value ) ) { / / in this case , only need a conditional move for the true branch . EMIT ( MIR _ Cond CaMeL Move . mutate ( s , IA 32 _ C@@ MOV , result , as CaMeL Reg ( s , IA 32 _ MOV , true CaMeL Value ) , COND ( cond ) ) ) ; } else { / / need to handle both possible assignments . Unconditionally / / assign one value then conditionally assign the other . if ( false CaMeL Value . is CaMeL Register ( ) ) { EMIT ( CPOS ( s , MIR _ Move . create ( IA 32 _ MOV , result , true CaMeL Value ) ) ) ; EMIT ( MIR _ Cond CaMeL Move . mutate ( s , IA 32 _ C@@ MOV , result . copy ( ) , false CaMeL Value , COND ( cond . flip CaMeL Code ( ) ) ) ) ; } else { EMIT ( CPOS ( s , MIR _ Move . create ( IA 32 _ MOV , result , false CaMeL Value ) ) ) ; EMIT ( MIR _ Cond CaMeL Move . mutate ( s , IA 32 _ C@@ MOV , result . copy ( ) , as CaMeL Reg ( s , IA 32 _ MOV , true CaMeL Value ) , COND ( cond ) ) ) ; } } }	EMIT ( MIR _ Cond CaMeL Move . mutate ( s , IA 32 _ C@@ MOV , result . copy CaMeL RO ( ) ,
out . write ( NORMAL _ TE@@ MIN@@ ATION ) ;  <CTX>  void stop CaMeL Thread ( ) { synchronized ( mutex ) { if ( client _ sock != null ) { try { Output CaMeL Stream out = client _ sock . get CaMeL Output CaMeL Stream ( ) ; out . write ( NORMAL _ TE@@ MIN@@ ATION ) ; } catch ( Throwable t ) { } } } close CaMeL Client CaMeL Socket ( ) ; }	out . write ( NORMAL _ TERMINATION ) ;
if ( cool CaMeL Bar CaMeL Mgr != null )  <CTX>  protected void set CaMeL Active ( boolean value ) { super . set CaMeL Active ( value ) ; if ( cool CaMeL Bar CaMeL Mgr != null ) cool CaMeL Bar CaMeL Mgr . set CaMeL Visible ( value ) ; }	if ( cool CaMeL Bar CaMeL Mgr != null ) {
organizer . start CaMeL Builder ( ) ;  <CTX>  public void action CaMeL Performed ( Action CaMeL Event e ) { organizer . start CaMeL Builder ( ) ; }	organizer . start CaMeL Experiment CaMeL Builder ( ) ;
break ;  <CTX>  public void files CaMeL Activated ( VFS CaMeL Browser browser , VFS . Directory CaMeL Entry [ ] files ) { if ( files . length == 0 ) return ; filename CaMeL Field . select CaMeL All ( ) ; if ( browser . get CaMeL Mode ( ) == VFS CaMeL Browser . BROWSER _ DIALOG ) { for ( int i = 0 ; i < files . length ; i ++ ) { if ( files [ i ] . type == VFS . Directory CaMeL Entry . FILE ) { dispose ( ) ; break ; } } } else ok ( ) ; } / / } } }	return ;
aci . set CaMeL Index ( current CaMeL Char ) ; int glyph CaMeL Char CaMeL Index = ( ( Integer ) aci . get CaMeL Attribute ( GVT CaMeL Attributed CaMeL Character CaMeL Iterator . Text CaMeL Attribute . CHAR _ INDEX ) ) . int CaMeL Value ( ) ; if ( char CaMeL Index == glyph CaMeL Char CaMeL Index ) { return i ;  <CTX>  public int get CaMeL Glyph CaMeL Index ( int char CaMeL Index ) { int current CaMeL Char = aci . get CaMeL Begin CaMeL Index ( ) ; int num CaMeL Glyphs = get CaMeL Glyph CaMeL Count ( ) ; for ( int i = 0 ; i < num CaMeL Glyphs ; i ++ ) { aci . set CaMeL Index ( current CaMeL Char ) ; int glyph CaMeL Char CaMeL Index = ( ( Integer ) aci . get CaMeL Attribute ( GVT CaMeL Attributed CaMeL Character CaMeL Iterator . Text CaMeL Attribute . CHAR _ INDEX ) ) . int CaMeL Value ( ) ; if ( char CaMeL Index == glyph CaMeL Char CaMeL Index ) { return i ; } current CaMeL Char += get CaMeL Character CaMeL Count ( i , i ) ; } return - 1 ; }	int count = get CaMeL Character CaMeL Count ( i , i ) ; for ( int n = 0 ; n < count ; n ++ ) { int glyph CaMeL Char CaMeL Index = ( ( Integer ) aci . get CaMeL Attribute ( GVT CaMeL Attributed CaMeL Character CaMeL Iterator . Text CaMeL Attribute . CHAR _ INDEX ) ) . int CaMeL Value ( ) ; if ( char CaMeL Index == glyph CaMeL Char CaMeL Index ) return i ; if ( aci . next ( ) == Attributed CaMeL Character CaMeL Iterator . DONE ) return - 1 ;
if ( transaction CaMeL Candidate . equals ( Protocol . TRANSACTIONS _ UP _ TO _ DATE ) ) { notify ( _ subscriber CaMeL Up CaMeL To CaMeL Date CaMeL Monitor ) ; return ; } if ( transaction CaMeL Candidate . equals ( Protocol . REMOTE _ TRANSACTION ) ) {  <CTX>  private void receive CaMeL Transaction CaMeL From CaMeL Server ( ) throws IO CaMeL Exception , Class CaMeL Not CaMeL Found CaMeL Exception { Object transaction CaMeL Candidate = _ from CaMeL Server . read CaMeL Object ( ) ; if ( transaction CaMeL Candidate . equals ( Protocol . TRANSACTIONS _ UP _ TO _ DATE ) ) { notify ( _ subscriber CaMeL Up CaMeL To CaMeL Date CaMeL Monitor ) ; return ; } if ( transaction CaMeL Candidate . equals ( Protocol . REMOTE _ TRANSACTION ) ) { synchronized ( _ my CaMeL Transaction CaMeL Monitor ) { _ subscriber . receive ( _ my CaMeL Transaction ) ; notify ( _ my CaMeL Transaction CaMeL Monitor ) ; } return ; } _ subscriber . receive ( ( Transaction ) transaction CaMeL Candidate ) ; }	if ( transaction CaMeL Candidate . equals ( Remote CaMeL Connection . REMOTE _ TRANSACTION ) ) {
image CaMeL Emitter = new HTML CaMeL Image CaMeL Emitter ( this ) ; page CaMeL Setup CaMeL Emitter = new HTML CaMeL Page CaMeL Setup CaMeL Emitter ( this ) ; table CaMeL Emitter = new HTML CaMeL Table CaMeL Emitter ( this ) ; text CaMeL Emitter = new HTML CaMeL Text CaMeL Emitter ( this ) ; container CaMeL Emitter = new HTML CaMeL Container CaMeL Emitter ( this ) ;  <CTX>  public void initialize ( I CaMeL Emitter CaMeL Services services ) { this . services = services ; I CaMeL Repository repository = services . get CaMeL Repository ( ) ; save CaMeL Img CaMeL File = ( services . get CaMeL Engine CaMeL Mode ( ) == I CaMeL Emitter CaMeL Services . ENGINE _ STANDALONE _ MODE ) ; writer = new HTML CaMeL Writer ( ) ; resource CaMeL Manager = new Resource CaMeL Manager ( repository ) ; if ( services . get CaMeL Engine CaMeL Mode ( ) == I CaMeL Emitter CaMeL Services . ENGINE _ EMBEDDED _ MODE ) hyperlink CaMeL Processor = new Embedded CaMeL Hyperlink CaMeL Processor ( services . get CaMeL Base CaMeL URL ( ) ) ; else if ( services . get CaMeL Engine CaMeL Mode ( ) == I CaMeL Emitter CaMeL Services . ENGINE _ STANDALONE _ MODE ) hyperlink CaMeL Processor = new Default CaMeL Hyperlink CaMeL Processor ( ) ; image CaMeL Emitter = new HTML CaMeL Image CaMeL Emitter ( this ) ; page CaMeL Setup CaMeL Emitter = new HTML CaMeL Page CaMeL Setup CaMeL Emitter ( this ) ; table CaMeL Emitter = new HTML CaMeL Table CaMeL Emitter ( this ) ; text CaMeL Emitter = new HTML CaMeL Text CaMeL Emitter ( this ) ; container CaMeL Emitter = new HTML CaMeL Container CaMeL Emitter ( this ) ; }	image CaMeL Emitter = new HTML CaMeL Image CaMeL Emitter ( this , is CaMeL Embed@@ dable ) ; page CaMeL Setup CaMeL Emitter = new HTML CaMeL Page CaMeL Setup CaMeL Emitter ( this , is CaMeL Embed@@ dable ) ; table CaMeL Emitter = new HTML CaMeL Table CaMeL Emitter ( this , is CaMeL Embed@@ dable ) ; text CaMeL Emitter = new HTML CaMeL Text CaMeL Emitter ( this , is CaMeL Embed@@ dable ) ; container CaMeL Emitter = new HTML CaMeL Container CaMeL Emitter ( this , is CaMeL Embed@@ dable ) ;
{ Bounded CaMeL Range CaMeL Model h@@ mod = hsb . get CaMeL Model ( ) ; if ( h@@ mod != null ) xpos = h@@ mod . get CaMeL Value ( ) ;  <CTX>  Change CaMeL Listener create CaMeL Scroll CaMeL Listener ( ) { return new Change CaMeL Listener ( ) { public void state CaMeL Changed ( Change CaMeL Event event ) { int xpos = 0 ; int ypos = 0 ; J CaMeL Scroll CaMeL Bar vsb = J CaMeL Scroll CaMeL Pane . this . get CaMeL Vertical CaMeL Scroll CaMeL Bar ( ) ; J CaMeL Scroll CaMeL Bar hsb = J CaMeL Scroll CaMeL Pane . this . get CaMeL Horizontal CaMeL Scroll CaMeL Bar ( ) ; if ( vsb != null ) { Bounded CaMeL Range CaMeL Model v@@ mod = vsb . get CaMeL Model ( ) ; if ( v@@ mod != null ) ypos = v@@ mod . get CaMeL Value ( ) ; } if ( hsb != null ) { Bounded CaMeL Range CaMeL Model h@@ mod = hsb . get CaMeL Model ( ) ; if ( h@@ mod != null ) xpos = h@@ mod . get CaMeL Value ( ) ; } if ( J CaMeL Scroll CaMeL Pane . this . viewport != null ) J CaMeL Scroll CaMeL Pane . this . viewport . set CaMeL View CaMeL Position ( new Point ( xpos , ypos ) ) ; } } ; }	xpos = hsb . get CaMeL Value ( ) ; Point pt = new Point ( xpos , ypos ) ; if ( vp != null && vp . get CaMeL View CaMeL Position ( ) != pt ) vp . set CaMeL View CaMeL Position ( pt ) ;
result = serializer . deserialize ( new String CaMeL Reader ( writer . to CaMeL String ( ) ) ) ;  <CTX>  public void do CaMeL Round CaMeL Trip ( Object CaMeL Serializer serializer , Object CaMeL Serializer deserializer ) throws Exception { String CaMeL Writer writer = new String CaMeL Writer ( ) ; serializer . serialize ( writer , original ) ; result = serializer . deserialize ( new String CaMeL Reader ( writer . to CaMeL String ( ) ) ) ; }	result = deserializer . deserialize ( new String CaMeL Reader ( writer . to CaMeL String ( ) ) ) ;
Assert . assert ( c . get CaMeL Tag ( ) . equals ( Tag . get ( 0 ) ) ) ;  <CTX>  public ASN 1 Value decode ( Input CaMeL Stream istream ) throws Invalid CaMeL BER CaMeL Exception , IO CaMeL Exception { CHOICE c = ( CHOICE ) cho@@ ic@@ et . decode ( istream ) ; if ( c . get CaMeL Tag ( ) == SEQUENCE . TAG ) { return create CaMeL Issuer CaMeL And CaMeL Serial CaMeL Number ( ( Issuer CaMeL And CaMeL Serial CaMeL Number ) c . get CaMeL Value ( ) ) ; } else { Assert . assert ( c . get CaMeL Tag ( ) . equals ( Tag . get ( 0 ) ) ) ; / / EXPLICIT e = ( EXPLICIT ) c . get CaMeL Value ( ) ; / / ASN 1 Value d@@ ski = e . get CaMeL Content ( ) ; / / OCTET _ STRING ski = ( OCTET _ STRING ) e . get CaMeL Content ( ) ; OCTET _ STRING ski = ( OCTET _ STRING ) c . get CaMeL Value ( ) ; return create CaMeL Subject CaMeL Key CaMeL Identifier ( ski ) ; } }	Assert . _ assert ( c . get CaMeL Tag ( ) . equals ( Tag . get ( 0 ) ) ) ;
return Utilities . draw CaMeL Tabbed CaMeL Text ( segment , x , y , g , this , 0 ) ;  <CTX>  protected int draw CaMeL Selected CaMeL Text ( Graphics g , int x , int y , int p 0 , int p 1 ) throws Bad CaMeL Location CaMeL Exception { g . set CaMeL Color ( selected CaMeL Color ) ; Segment segment = get CaMeL Line CaMeL Buffer ( ) ; get CaMeL Document ( ) . get CaMeL Text ( p 0 , p 1 - p 0 , segment ) ; return Utilities . draw CaMeL Tabbed CaMeL Text ( segment , x , y , g , this , 0 ) ; }	return Utilities . draw CaMeL Tabbed CaMeL Text ( segment , x , y , g , this , segment . offset ) ;
con@@ ce@@ des = Con@@ ce@@ de . con@@ ce@@ de ( master CaMeL Frame , attacker , defender ) ;  <CTX>  private void do CaMeL Fight ( String hex CaMeL Label , Player player ) { if ( sum@@ mon CaMeL Angel != null ) { Leg@@ ion don@@ or = get CaMeL First CaMeL Friendly CaMeL Leg@@ ion ( hex CaMeL Label , player ) ; if ( don@@ or != null ) { player . set CaMeL Don@@ or ( don@@ or ) ; sum@@ mon CaMeL Angel . update CaMeL Ch@@ its ( ) ; sum@@ mon CaMeL Angel . repaint ( ) ; don@@ or . get CaMeL Marker ( ) . repaint ( ) ; } return ; } / / Do not allow clic@@ king on eng@@ age@@ ments if one is / / already being resolved . if ( is CaMeL Eng@@ ag@@ ement ( hex CaMeL Label ) && ! eng@@ ag@@ ement CaMeL In CaMeL Progress ) { eng@@ ag@@ ement CaMeL In CaMeL Progress = true ; Leg@@ ion attacker = get CaMeL First CaMeL Friendly CaMeL Leg@@ ion ( hex CaMeL Label , player ) ; Leg@@ ion defender = get CaMeL First CaMeL Enemy CaMeL Leg@@ ion ( hex CaMeL Label , player ) ; attacker . sort CaMeL Cri@@ tters ( ) ; defender . sort CaMeL Cri@@ tters ( ) ; if ( defender . can CaMeL Flee ( ) ) { / / Fle@@ eing gi@@ ves half points and den@@ ies the / / attacker the chance to sum@@ mon an angel . boolean f@@ lees ; if ( defender . get CaMeL Player ( ) . get CaMeL Option ( Options . auto CaMeL Flee ) ) { f@@ lees = defender . get CaMeL Player ( ) . ai CaMeL Flee ( defender , attacker ) ; } else { f@@ lees = Con@@ ce@@ de . f@@ lee ( master CaMeL Frame , defender , attacker ) ; } if ( f@@ lees ) { handle CaMeL Con@@ ce@@ ssion ( defender , attacker , true ) ; return ; } } / / The attacker may con@@ ce@@ de now without / / allowing the defender a rein@@ for@@ cement . boolean con@@ ce@@ des ; if ( attacker . get CaMeL Player ( ) . get CaMeL Option ( Options . auto CaMeL Flee ) ) { con@@ ce@@ des = attacker . get CaMeL Player ( ) . ai CaMeL Con@@ ce@@ de ( attacker , defender ) ; } else { con@@ ce@@ des = Con@@ ce@@ de . con@@ ce@@ de ( master CaMeL Frame , attacker , defender ) ; } if ( con@@ ce@@ des ) { handle CaMeL Con@@ ce@@ ssion ( attacker , defender , false ) ; return ; } / / The players may agree to a negotiated sett@@ lement . Negotiation CaMeL Results results = Negotiate . negotiate ( master CaMeL Frame , attacker , defender ) ; if ( results . is CaMeL Settled ( ) ) { handle CaMeL Negotiation ( results , attacker , defender ) ; return ; } else { / / Battle / / Reveal both leg@@ i@@ ons to all players . attacker . reveal CaMeL All CaMeL Creatures ( ) ; defender . reveal CaMeL All CaMeL Creatures ( ) ; battle = new Battle ( this , attacker . get CaMeL Marker CaMeL Id ( ) , defender . get CaMeL Marker CaMeL Id ( ) , Battle . DEF@@ ENDER , hex CaMeL Label , 1 , Battle . MOVE ) ; battle . init ( ) ; } } }	con@@ ce@@ des = Con@@ ce@@ de . con@@ ce@@ de ( frame , attacker , defender ) ;
My@@ lar CaMeL Context task@@ scape = active CaMeL Context . get CaMeL Task@@ scape CaMeL Map ( ) . get ( task CaMeL Id ) ;  <CTX>  public void save CaMeL Task@@ scape ( String task CaMeL Id , String path ) { My@@ lar CaMeL Context task@@ scape = active CaMeL Context . get CaMeL Task@@ scape CaMeL Map ( ) . get ( task CaMeL Id ) ; if ( task@@ scape == null ) { return ; } else { task@@ scape . collapse ( ) ; externalizer . write CaMeL XML CaMeL Task@@ scape CaMeL To CaMeL File ( task@@ scape , get CaMeL File CaMeL For CaMeL Task@@ scape ( path ) ) ; } }	My@@ lar CaMeL Context task@@ scape = active CaMeL Context . get CaMeL Context CaMeL Map ( ) . get ( task CaMeL Id ) ;
set CaMeL File CaMeL Grouping CaMeL State ( _ make CaMeL Project CaMeL File CaMeL Grouping CaMeL State ( build CaMeL Dir , project CaMeL File , src CaMeL Files ) ) ;  <CTX>  public File [ ] open CaMeL Project ( File project CaMeL File ) throws IO CaMeL Exception { final Project CaMeL File CaMeL IR ir ; final File [ ] src CaMeL Files ; / / File project CaMeL Root = project CaMeL File . get CaMeL Parent CaMeL File ( ) ; ir = Project CaMeL File CaMeL Parser . ONLY . parse ( project CaMeL File ) ; src CaMeL Files = ir . get CaMeL Source CaMeL Files ( ) ; I@@ AWT CaMeL Container CaMeL Navigator CaMeL Actor new CaMeL Nav = AWT CaMeL Container CaMeL Navigator CaMeL Factory . Singleton . make CaMeL Tree CaMeL Navigator ( project CaMeL File . get CaMeL Name ( ) , get CaMeL Document CaMeL Navigator ( ) ) ; set CaMeL Document CaMeL Navigator ( new CaMeL Nav ) ; File build CaMeL Dir = ( ir . get CaMeL Build CaMeL Directory ( ) . length > 0 ) ? ir . get CaMeL Build CaMeL Directory ( ) [ 0 ] : null ; set CaMeL File CaMeL Grouping CaMeL State ( _ make CaMeL Project CaMeL File CaMeL Grouping CaMeL State ( build CaMeL Dir , project CaMeL File , src CaMeL Files ) ) ; String proj@@ filepath = project CaMeL File . get CaMeL Canonical CaMeL Path ( ) ; String tl@@ p = proj@@ filepath . substring ( 0 , proj@@ filepath . last CaMeL Index CaMeL Of ( File . separator ) ) ; new CaMeL Nav . set CaMeL Top CaMeL Level CaMeL Path ( tl@@ p ) ; File [ ] projec@@ t@@ classpaths = ir . get CaMeL Classpath ( ) ; Vector < File > current@@ classpaths = Dr CaMeL Java . get CaMeL Config ( ) . get CaMeL Setting ( Option CaMeL Constants . EXTRA _ CLASSPATH ) ; for ( int i = 0 ; i < projec@@ t@@ classpaths . length ; i ++ ) { current@@ classpaths . add ( projec@@ t@@ classpaths [ i ] . get CaMeL Absolute CaMeL File ( ) ) ; } Dr CaMeL Java . get CaMeL Config ( ) . set CaMeL Setting ( Option CaMeL Constants . EXTRA _ CLASSPATH , current@@ classpaths ) ; return src CaMeL Files ; }	File main CaMeL Class ; try { main CaMeL Class = ir . get CaMeL Jar CaMeL Main CaMeL Class ( ) ; if ( main CaMeL Class != null ) { main CaMeL Class = new File ( project CaMeL File . get CaMeL Parent CaMeL File ( ) . get CaMeL Path ( ) , main CaMeL Class . get CaMeL Path ( ) ) . get CaMeL Canonical CaMeL File ( ) ; } } catch ( IO CaMeL Exception e ) { main CaMeL Class = null ; } set CaMeL File CaMeL Grouping CaMeL State ( _ make CaMeL Project CaMeL File CaMeL Grouping CaMeL State ( main CaMeL Class , build CaMeL Dir , project CaMeL File , src CaMeL Files ) ) ;
item . set CaMeL Enabled ( true ) ; item . set CaMeL Icon ( null ) ;  <CTX>  public void plugin CaMeL Stopped ( Plugin CaMeL Event e ) { Plugin plugin = e . get CaMeL Plugin ( ) ; synchronized ( service CaMeL Info CaMeL To CaMeL Receive CaMeL Map ) { for ( Iterator iter = service CaMeL Info CaMeL To CaMeL Receive CaMeL Map . entry CaMeL Set ( ) . iterator ( ) ; iter . has CaMeL Next ( ) ; ) { Map . Entry entry = ( Map . Entry ) iter . next ( ) ; if ( entry . get CaMeL Value ( ) == plugin ) { service CaMeL Info CaMeL To CaMeL Receive CaMeL Map . remove ( entry . get CaMeL Key ( ) ) ; } } } / / need to make sure that the menu item tracking this item has it s icon and enabled state upd@@ ade J CaMeL Menu CaMeL Item item = locate CaMeL Matching CaMeL Menu CaMeL Item ( plugin . get CaMeL Name ( ) ) ; item . set CaMeL Enabled ( true ) ; item . set CaMeL Icon ( null ) ; discovered CaMeL Devices . fire CaMeL Contents CaMeL Changed ( ) ; } } ) ;	if ( item != null ) { item . set CaMeL Enabled ( true ) ; item . set CaMeL Icon ( null ) ; }
return new CaMeL String ( get CaMeL Value ( ) . to CaMeL Lower CaMeL Case ( ) ) ;  <CTX>  public Ruby CaMeL String down@@ case ( ) { return new CaMeL String ( get CaMeL Value ( ) . to CaMeL Lower CaMeL Case ( ) ) ; }	return new CaMeL String ( to CaMeL String ( ) . to CaMeL Lower CaMeL Case ( ) ) ;
if ( list CaMeL Change CaMeL Listeners == listener ) { list CaMeL Change CaMeL Listeners = null ; if ( ! has CaMeL Listeners ( ) ) { last CaMeL Listener CaMeL Removed ( ) ; } return ; } if ( list CaMeL Change CaMeL Listeners instanceof Collection ) { Collection listener CaMeL List = ( Collection ) list CaMeL Change CaMeL Listeners ; listener CaMeL List . remove ( listener ) ; if ( listener CaMeL List . is CaMeL Empty ( ) ) { list CaMeL Change CaMeL Listeners = null ; if ( ! has CaMeL Listeners ( ) ) { last CaMeL Listener CaMeL Removed ( ) ; } } }  <CTX>  public synchronized void remove CaMeL List CaMeL Change CaMeL Listener ( I CaMeL List CaMeL Change CaMeL Listener listener ) { if ( list CaMeL Change CaMeL Listeners == listener ) { list CaMeL Change CaMeL Listeners = null ; if ( ! has CaMeL Listeners ( ) ) { last CaMeL Listener CaMeL Removed ( ) ; } return ; } if ( list CaMeL Change CaMeL Listeners instanceof Collection ) { Collection listener CaMeL List = ( Collection ) list CaMeL Change CaMeL Listeners ; listener CaMeL List . remove ( listener ) ; if ( listener CaMeL List . is CaMeL Empty ( ) ) { list CaMeL Change CaMeL Listeners = null ; if ( ! has CaMeL Listeners ( ) ) { last CaMeL Listener CaMeL Removed ( ) ; } } } }	remove CaMeL Listener ( List CaMeL Change CaMeL Event . TYPE , listener ) ;
switch CaMeL Paramter CaMeL Type ( ) ;  <CTX>  public void widget CaMeL Selected ( Selection CaMeL Event e ) { switch CaMeL Paramter CaMeL Type ( ) ; }	change CaMeL Control CaMeL Type ( ) ;
, selected CaMeL Columns , query . get CaMeL Row CaMeL Expressions ( ) ) ;  <CTX>  public I CaMeL Extraction CaMeL Results extract ( ) throws Engine CaMeL Exception { if ( instance CaMeL Id == null ) return null ; if ( current CaMeL Result != null ) return current CaMeL Result ; assert execution CaMeL Context . get CaMeL Data CaMeL Engine ( ) != null ; Data CaMeL Engine data CaMeL Engine = execution CaMeL Context . get CaMeL Data CaMeL Engine ( ) . get CaMeL Data CaMeL Engine ( ) ; Report CaMeL Item CaMeL Design rpt CaMeL Item = ( Report CaMeL Item CaMeL Design ) report . get CaMeL Report CaMeL Item CaMeL By CaMeL ID ( instance CaMeL Id . get CaMeL Component CaMeL ID ( ) ) ; assert rpt CaMeL Item != null ; I CaMeL Base CaMeL Query CaMeL Definition query = rpt CaMeL Item . get CaMeL Query ( ) ; validate CaMeL Selected CaMeL Columns ( query ) ; Data CaMeL ID data CaMeL Id = instance CaMeL Id . get CaMeL Data CaMeL ID ( ) ; Instance CaMeL ID inst CaMeL Id = instance CaMeL Id ; while ( inst CaMeL Id != null && data CaMeL Id == null ) { inst CaMeL Id = inst CaMeL Id . get CaMeL Parent CaMeL ID ( ) ; if ( inst CaMeL Id != null ) { data CaMeL Id = inst CaMeL Id . get CaMeL Data CaMeL ID ( ) ; } } if ( data CaMeL Id == null ) return null ; Data CaMeL Set CaMeL ID data CaMeL Set CaMeL Id = data CaMeL Id . get CaMeL Data CaMeL Set CaMeL ID ( ) ; assert data CaMeL Set CaMeL Id != null ; String query CaMeL Result CaMeL Name = data CaMeL Set CaMeL Id . get CaMeL Data CaMeL Set CaMeL Name ( ) ; if ( result CaMeL Meta CaMeL List == null ) { result CaMeL Meta CaMeL List = new Array CaMeL List ( ) ; } else { result CaMeL Meta CaMeL List . clear ( ) ; } if ( query CaMeL Result CaMeL Name != null ) { try { I CaMeL Query CaMeL Results query CaMeL Results = data CaMeL Engine . get CaMeL Query CaMeL Results ( query CaMeL Result CaMeL Name ) ; assert query CaMeL Results . get CaMeL Result CaMeL Iterator ( ) != null ; current CaMeL Result = new Extraction CaMeL Results ( query CaMeL Results . get CaMeL Result CaMeL Iterator ( ) , selected CaMeL Columns , query . get CaMeL Row CaMeL Expressions ( ) ) ; result CaMeL Meta CaMeL List . add ( current CaMeL Result . get CaMeL Result CaMeL Meta CaMeL Data ( ) ) ; return current CaMeL Result ; } catch ( Birt CaMeL Exception e ) { e . print CaMeL Stack CaMeL Trace ( ) ; } } else { Data CaMeL Set CaMeL ID parent CaMeL Id = data CaMeL Set CaMeL Id . get CaMeL Parent CaMeL ID ( ) ; assert parent CaMeL Id != null ; try { query CaMeL Result CaMeL Name = parent CaMeL Id . get CaMeL Data CaMeL Set CaMeL Name ( ) ; Data CaMeL Set CaMeL ID par CaMeL Id = parent CaMeL Id ; while ( query CaMeL Result CaMeL Name == null && par CaMeL Id != null ) { par CaMeL Id = par CaMeL Id . get CaMeL Parent CaMeL ID ( ) ; if ( par CaMeL Id != null ) query CaMeL Result CaMeL Name = par CaMeL Id . get CaMeL Data CaMeL Set CaMeL Name ( ) ; } assert query CaMeL Result CaMeL Name != null ; I CaMeL Query CaMeL Results parent CaMeL Query CaMeL Result = data CaMeL Engine . get CaMeL Query CaMeL Results ( query CaMeL Result CaMeL Name ) ; assert parent CaMeL Query CaMeL Result != null ; I CaMeL Result CaMeL Iterator iter = parent CaMeL Query CaMeL Result . get CaMeL Result CaMeL Iterator ( ) ; long rowid = data CaMeL Set CaMeL Id . get CaMeL Row CaMeL ID ( ) ; int i = 0 ; while ( iter . next ( ) && i ++ < rowid ) ; I CaMeL Result CaMeL Iterator sub CaMeL Iter = iter . get CaMeL Secondary CaMeL Iterator ( data CaMeL Set CaMeL Id . get CaMeL Query CaMeL Name ( ) , execution CaMeL Context . get CaMeL Scope ( ) ) ; current CaMeL Result = new Extraction CaMeL Results ( sub CaMeL Iter , selected CaMeL Columns , query . get CaMeL Row CaMeL Expressions ( ) ) ; result CaMeL Meta CaMeL List . add ( current CaMeL Result . get CaMeL Result CaMeL Meta CaMeL Data ( ) ) ; return current CaMeL Result ; } catch ( Birt CaMeL Exception be ) { be . print CaMeL Stack CaMeL Trace ( ) ; } } return null ; }	, selected CaMeL Columns , get CaMeL Script CaMeL Expressions ( query . get CaMeL Row CaMeL Expressions ( ) ) ) ;
new Global CaMeL Build CaMeL Action ( CUI CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Active CaMeL Workbench CaMeL Window ( ) , Incremental CaMeL Project CaMeL Builder . INCREMENTAL _ BUILD ) . run ( ) ;  <CTX>  public void trigger CaMeL Build ( ) { if ( f CaMeL Files CaMeL Saved && Resources CaMeL Plugin . get CaMeL Workspace ( ) . get CaMeL Description ( ) . is CaMeL Auto CaMeL Building ( ) ) { new Global CaMeL Build CaMeL Action ( CUI CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Active CaMeL Workbench CaMeL Window ( ) , Incremental CaMeL Project CaMeL Builder . INCREMENTAL _ BUILD ) . run ( ) ; } }	new Global CaMeL Build CaMeL Action ( CUI CaMeL Plugin . get CaMeL Active CaMeL Workbench CaMeL Window ( ) , Incremental CaMeL Project CaMeL Builder . INCREMENTAL _ BUILD ) . run ( ) ;
exec CaMeL File . get CaMeL Project ( ) ,  <CTX>  private IC CaMeL Watchpoint create CaMeL Watchpoint ( ICDI CaMeL Watchpoint cdi CaMeL Watchpoint ) throws CDI CaMeL Exception , Core CaMeL Exception { I CaMeL File exec CaMeL File = get CaMeL Exec CaMeL File ( ) ; String source CaMeL Handle = exec CaMeL File . get CaMeL Full CaMeL Path ( ) . to CaMeL OS CaMeL String ( ) ; IC CaMeL Watchpoint watchpoint = CDI CaMeL Debug CaMeL Model . create CaMeL Watchpoint ( source CaMeL Handle , exec CaMeL File . get CaMeL Project ( ) , cdi CaMeL Watchpoint . is CaMeL Write CaMeL Type ( ) , cdi CaMeL Watchpoint . is CaMeL Read CaMeL Type ( ) , cdi CaMeL Watchpoint . get CaMeL Watch CaMeL Expression ( ) , cdi CaMeL Watchpoint . is CaMeL Enabled ( ) , cdi CaMeL Watchpoint . get CaMeL Condition ( ) . get CaMeL Ignore CaMeL Count ( ) , cdi CaMeL Watchpoint . get CaMeL Condition ( ) . get CaMeL Expression ( ) , false ) ; get CaMeL Breakpoint CaMeL Map ( ) . put ( watchpoint , cdi CaMeL Watchpoint ) ; ( ( C CaMeL Breakpoint ) watchpoint ) . register ( true ) ; return watchpoint ; }	get CaMeL Project ( ) ,
java . util . Iterator iter = items CaMeL To CaMeL Remove . iterator ( ) ;  <CTX>  private void revoke CaMeL Action CaMeL Set CaMeL From CaMeL Menu ( I CaMeL Menu CaMeL Manager menu CaMeL Mgr , String action@@ set CaMeL Id ) { I CaMeL Contribution CaMeL Item [ ] items = menu CaMeL Mgr . get CaMeL Items ( ) ; Array CaMeL List items CaMeL To CaMeL Remove = new Array CaMeL List ( ) ; String id ; for ( int i = 0 ; i < items . length ; i ++ ) if ( items [ i ] instanceof I CaMeL Menu CaMeL Manager ) { revoke CaMeL Action CaMeL Set CaMeL From CaMeL Menu ( ( I CaMeL Menu CaMeL Manager ) items [ i ] , action@@ set CaMeL Id ) ; } else if ( items [ i ] instanceof Action CaMeL Set CaMeL Contribution CaMeL Item ) { id = ( ( Action CaMeL Set CaMeL Contribution CaMeL Item ) items [ i ] ) . get CaMeL Action CaMeL Set CaMeL Id ( ) ; if ( id . equals ( action@@ set CaMeL Id ) ) items CaMeL To CaMeL Remove . add ( items [ i ] ) ; } else if ( items [ i ] instanceof Separator ) { id = ( ( Separator ) items [ i ] ) . get CaMeL Id ( ) ; if ( id . equals ( action@@ set CaMeL Id ) ) items CaMeL To CaMeL Remove . add ( items [ i ] ) ; } else if ( items [ i ] instanceof Group CaMeL Marker ) { id = ( ( Group CaMeL Marker ) items [ i ] ) . get CaMeL Id ( ) ; if ( id . equals ( action@@ set CaMeL Id ) ) items CaMeL To CaMeL Remove . add ( items [ i ] ) ; } java . util . Iterator iter = items CaMeL To CaMeL Remove . iterator ( ) ; while ( iter . has CaMeL Next ( ) ) { I CaMeL Contribution CaMeL Item item = ( I CaMeL Contribution CaMeL Item ) iter . next ( ) ; menu CaMeL Mgr . remove ( item ) ; } menu CaMeL Mgr . update ( true ) ; }	Iterator iter = items CaMeL To CaMeL Remove . iterator ( ) ;
return new Part CaMeL Of CaMeL Table _ users ( rs ) ;  <CTX>  public Object map CaMeL One CaMeL Row ( Result CaMeL Set rs ) throws SQL CaMeL Exception { return new Part CaMeL Of CaMeL Table _ users ( rs ) ; }	return new Part CaMeL Of CaMeL Table _ roles ( rs ) ;
I CaMeL View CaMeL Part test = find CaMeL View ( id ) ; return ( view == test ) ;  <CTX>  public boolean contains CaMeL View ( I CaMeL View CaMeL Part view ) { String id = view . get CaMeL Site ( ) . get CaMeL Id ( ) ; I CaMeL View CaMeL Part test = find CaMeL View ( id ) ; return ( view == test ) ; }	I CaMeL View CaMeL Reference ref = find CaMeL View ( id ) ; return ( view == ref . get CaMeL Part ( false ) ) ;
Object result = all _ acks _ received . get CaMeL Result CaMeL With CaMeL Timeout ( timeout ) ;  <CTX>  public boolean wait CaMeL For CaMeL All CaMeL Acks ( long timeout ) throws Timeout CaMeL Exception { if ( missing _ acks . size ( ) == 0 ) return true ; Object result = all _ acks _ received . get CaMeL Result CaMeL With CaMeL Timeout ( timeout ) ; return result != null && result instanceof Boolean && ( ( Boolean ) result ) . boolean CaMeL Value ( ) ; }	Object result = all _ acks _ received . get CaMeL Result ( ) ;
Query query = create CaMeL Query ( build CaMeL Count CaMeL Hql ( ) ) ;  <CTX>  public int get CaMeL List CaMeL Size ( Object parent , List CaMeL Params params ) { Query query = create CaMeL Query ( build CaMeL Count CaMeL Hql ( ) ) ; if ( params . get CaMeL Filter ( ) != null ) { query . set CaMeL Properties ( params . get CaMeL Filter ( ) ) ; } Number size = ( Number ) query . unique CaMeL Result ( ) ; if ( size == null ) { return 0 ; } return size . int CaMeL Value ( ) ; }	Query query = create CaMeL Query ( build CaMeL Count CaMeL Hql ( params ) ) ;
total CaMeL Run CaMeL Time . put ( inspection CaMeL ID , new Long ( run CaMeL Time ) ) ;  <CTX>  public void report CaMeL Run ( String inspection CaMeL ID , long run CaMeL Time ) { synchronized ( lock ) { final Integer count = ( Integer ) total CaMeL Run CaMeL Count . get ( inspection CaMeL ID ) ; if ( count == null ) { total CaMeL Run CaMeL Count . put ( inspection CaMeL ID , new Integer ( 1 ) ) ; } else { total CaMeL Run CaMeL Count . put ( inspection CaMeL ID , new Integer ( count . int CaMeL Value ( ) + 1 ) ) ; } final Long run CaMeL Time CaMeL So CaMeL Far = ( Long ) total CaMeL Run CaMeL Time . get ( inspection CaMeL ID ) ; if ( run CaMeL Time CaMeL So CaMeL Far == null ) { total CaMeL Run CaMeL Time . put ( inspection CaMeL ID , new Long ( run CaMeL Time ) ) ; } else { total CaMeL Run CaMeL Time . put ( inspection CaMeL ID , new Long ( run CaMeL Time CaMeL So CaMeL Far . long CaMeL Value ( ) + run CaMeL Time ) ) ; } } }	total CaMeL Run CaMeL Time . put ( inspection CaMeL ID , run CaMeL Time ) ;
Node . Target switch CaMeL Break CaMeL Target = new Node . Target ( ) ;  <CTX>  void close CaMeL Switch ( Node switch CaMeL Block ) { if ( switch CaMeL Block . get CaMeL Type ( ) != Token . BLOCK ) throw Kit . code CaMeL Bug ( ) ; Node . Jump switch CaMeL Node = ( Node . Jump ) switch CaMeL Block . get CaMeL First CaMeL Child ( ) ; if ( switch CaMeL Node . get CaMeL Type ( ) != Token . SWITCH ) throw Kit . code CaMeL Bug ( ) ; Node . Target switch CaMeL Break CaMeL Target = new Node . Target ( ) ; / / switch CaMeL Node . target is only used by Node CaMeL Transformer / / to detect switch end switch CaMeL Node . target = switch CaMeL Break CaMeL Target ; Node . Target default CaMeL Target = switch CaMeL Node . get CaMeL Default ( ) ; if ( default CaMeL Target == null ) { default CaMeL Target = switch CaMeL Break CaMeL Target ; } switch CaMeL Block . add CaMeL Child CaMeL After ( make CaMeL Jump ( Token . GOTO , default CaMeL Target ) , switch CaMeL Node ) ; switch CaMeL Block . add CaMeL Child CaMeL To CaMeL Back ( switch CaMeL Break CaMeL Target ) ; }	Node switch CaMeL Break CaMeL Target = Node . new CaMeL Target ( ) ;
names = new String [ its CaMeL Data . its CaMeL Variable CaMeL Table . size ( ) + 1 ] ; names [ 0 ] = its CaMeL Data . its CaMeL Name ; for ( int i = 0 ; i < its CaMeL Data . its CaMeL Variable CaMeL Table . size ( ) ; i ++ ) names [ i + 1 ] = its CaMeL Data . its CaMeL Variable CaMeL Table . get CaMeL Name ( i ) ;  <CTX>  void init ( Context cx ) { / / prob@@ ably too mu@@ ch copying going on from the CaMeL Data to the Interpreted CaMeL Function object / / should pass them as parameters - unless we need them in the data block any@@ way ? names = new String [ its CaMeL Data . its CaMeL Variable CaMeL Table . size ( ) + 1 ] ; names [ 0 ] = its CaMeL Data . its CaMeL Name ; for ( int i = 0 ; i < its CaMeL Data . its CaMeL Variable CaMeL Table . size ( ) ; i ++ ) names [ i + 1 ] = its CaMeL Data . its CaMeL Variable CaMeL Table . get CaMeL Name ( i ) ; arg CaMeL Count = ( short ) its CaMeL Data . its CaMeL Variable CaMeL Table . get CaMeL Parameter CaMeL Count ( ) ; source = its CaMeL Data . its CaMeL Source ; nested CaMeL Functions = its CaMeL Data . its CaMeL Nested CaMeL Functions ; if ( cx != null ) version = ( short ) cx . get CaMeL Language CaMeL Version ( ) ; }	function CaMeL Name = its CaMeL Data . its CaMeL Name ; int N = its CaMeL Data . its CaMeL Variable CaMeL Table . size ( ) ; if ( N != 0 ) { arg CaMeL Names = new String [ N ] ; for ( int i = 0 ; i != N ; i ++ ) { arg CaMeL Names [ i ] = its CaMeL Data . its CaMeL Variable CaMeL Table . get CaMeL Name ( i ) ; } }
equals &= Util . equals ( active CaMeL Part CaMeL Id , casted CaMeL Object . active CaMeL Part CaMeL Id ) ; equals &= Util . equals ( active CaMeL Perspective CaMeL Id , casted CaMeL Object . active CaMeL Perspective CaMeL Id ) ;  <CTX>  public boolean equals ( Object object ) { if ( ! ( object instanceof Enabled CaMeL Submission ) ) return false ; Enabled CaMeL Submission casted CaMeL Object = ( Enabled CaMeL Submission ) object ; boolean equals = true ; equals &= Util . equals ( active CaMeL Part CaMeL Id , casted CaMeL Object . active CaMeL Part CaMeL Id ) ; equals &= Util . equals ( active CaMeL Perspective CaMeL Id , casted CaMeL Object . active CaMeL Perspective CaMeL Id ) ; equals &= Util . equals ( context CaMeL Id , casted CaMeL Object . context CaMeL Id ) ; return equals ; }	equals &= Util . equals ( active CaMeL Perspective CaMeL Descriptor , casted CaMeL Object . active CaMeL Perspective CaMeL Descriptor ) ; equals &= Util . equals ( active CaMeL Workbench CaMeL Site , casted CaMeL Object . active CaMeL Workbench CaMeL Site ) ;
return same ? ff : Data CaMeL Sampling . resample ( ff , res , null ) ;  <CTX>  protected Data get CaMeL Image CaMeL Data ( int [ ] pos ) { Data d = super . get CaMeL Image CaMeL Data ( pos ) ; if ( ! ( d instanceof Flat CaMeL Field ) ) return d ; Flat CaMeL Field ff = ( Flat CaMeL Field ) d ; Grid@@ ded CaMeL Set set = ( Grid@@ ded CaMeL Set ) ff . get CaMeL Domain CaMeL Set ( ) ; int [ ] len = set . get CaMeL Lengths ( ) ; int [ ] res = new int [ len . length ] ; boolean same = true ; int [ ] max CaMeL Res = handler . get CaMeL Window ( ) . get CaMeL Manager ( ) . get CaMeL Stack CaMeL Resolution ( ) ; for ( int i = 0 ; i < len . length ; i ++ ) { if ( len [ i ] > max CaMeL Res [ i ] ) { same = false ; res [ i ] = max CaMeL Res [ i ] ; } else res [ i ] = len [ i ] ; } return same ? ff : Data CaMeL Sampling . resample ( ff , res , null ) ; }	try { return Vis CaMeL Util . resample ( ff , res , null ) ; } catch ( Vis CaMeL AD CaMeL Exception exc ) { exc . print CaMeL Stack CaMeL Trace ( ) ; } catch ( Remote CaMeL Exception exc ) { exc . print CaMeL Stack CaMeL Trace ( ) ; } return null ;
boolean eof = false ; while ( buffer . has CaMeL Remaining ( ) ) { int bytes CaMeL Read = ( ( Readable CaMeL Byte CaMeL Channel ) channel ) . read ( buffer ) ; if ( bytes CaMeL Read < 0 ) { eof = true ; break ;  <CTX>  public String sys@@ read ( int length ) throws EOF CaMeL Exception , Bad CaMeL Descriptor CaMeL Exception , IO CaMeL Exception { check CaMeL Readable ( ) ; check CaMeL Buffered ( ) ; Byte CaMeL Buffer buffer = Byte CaMeL Buffer . allocate ( length ) ; boolean eof = false ; while ( buffer . has CaMeL Remaining ( ) ) { int bytes CaMeL Read = ( ( Readable CaMeL Byte CaMeL Channel ) channel ) . read ( buffer ) ; if ( bytes CaMeL Read < 0 ) { eof = true ; break ; } if ( bytes CaMeL Read == 0 ) { / / only should happ@@ en for non@@ blocking IO . . . break and allow the next call to try again break ; } } if ( buffer . position ( ) == 0 && eof == true ) { throw new EOF CaMeL Exception ( ) ; } byte [ ] ret ; if ( buffer . has CaMeL Remaining ( ) ) { buffer . flip ( ) ; ret = new byte [ buffer . remaining ( ) ] ; buffer . get ( ret ) ; } else { ret = buffer . array ( ) ; } return Ruby CaMeL String . bytes CaMeL To CaMeL String ( ret ) ; }	int bytes _ read = 0 ; do { bytes _ read = ( ( Readable CaMeL Byte CaMeL Channel ) channel ) . read ( buffer ) ; if ( bytes _ read < 0 ) { throw new EOF CaMeL Exception ( ) ;
if ( elems . length > 1 ) {  <CTX>  public IC CaMeL Element get CaMeL C CaMeL Element ( ) { I CaMeL Type CaMeL Reference ref = get CaMeL Resolved CaMeL Reference ( ) ; if ( ref != null ) { IC CaMeL Element [ ] elems = ref . get CaMeL C CaMeL Elements ( ) ; if ( elems . length > 1 ) { for ( int i = 0 ; i < elems . length ; ++ i ) { IC CaMeL Element elem = elems [ i ] ; if ( elem . get CaMeL Element CaMeL Type ( ) == f CaMeL Element CaMeL Type && elem . get CaMeL Element CaMeL Name ( ) . equals ( get CaMeL Name ( ) ) ) { / / TODO should check fully qualified name return elem ; } } } else if ( elems . length == 1 ) { return elems [ 0 ] ; } } return null ; }	if ( elems != null && elems . length > 0 ) { if ( elems . length == 1 ) return elems [ 0 ] ;
if ( product CaMeL Name != null ) new CaMeL Shell . set CaMeL Text ( NLS . bind ( Workbench CaMeL Messages . About CaMeL Features CaMeL Dialog _ shell CaMeL Title , product CaMeL Name ) ) ;  <CTX>  protected void configure CaMeL Shell ( Shell new CaMeL Shell ) { super . configure CaMeL Shell ( new CaMeL Shell ) ; if ( product CaMeL Name != null ) new CaMeL Shell . set CaMeL Text ( NLS . bind ( Workbench CaMeL Messages . About CaMeL Features CaMeL Dialog _ shell CaMeL Title , product CaMeL Name ) ) ; Platform CaMeL UI . get CaMeL Workbench ( ) . get CaMeL Help CaMeL System ( ) . set CaMeL Help ( new CaMeL Shell , I CaMeL Workbench CaMeL Help CaMeL Context CaMeL Ids . ABOUT _ FEATURES _ DIALOG ) ; }	if ( product CaMeL Name != null ) { new CaMeL Shell . set CaMeL Text ( NLS . bind ( Workbench CaMeL Messages . About CaMeL Features CaMeL Dialog _ shell CaMeL Title , product CaMeL Name ) ) ; }
Node create CaMeL Do CaMeL While ( Node body , Node cond , int lineno )  <CTX>  Node create CaMeL Do CaMeL While ( Node body , Node cond , int lineno ) { return create CaMeL Loop ( LOOP _ DO _ WHILE , body , cond , null , null , lineno ) ; }	Node create CaMeL Do CaMeL While ( Node loop , Node body , Node cond )
return e CaMeL Dynamic CaMeL Get ( e CaMeL Feature , resolve ) ;  <CTX>  public Object e CaMeL Get ( E CaMeL Structural CaMeL Feature e CaMeL Feature , boolean resolve ) { switch ( e CaMeL Derived CaMeL Structural CaMeL Feature CaMeL ID ( e CaMeL Feature ) ) { case Component CaMeL Package . AXIS _ _ TYPE : return get CaMeL Type ( ) ; case Component CaMeL Package . AXIS _ _ TITLE : return get CaMeL Title ( ) ; case Component CaMeL Package . AXIS _ _ SUB _ TITLE : return get CaMeL Sub CaMeL Title ( ) ; case Component CaMeL Package . AXIS _ _ TITLE _ POSITION : return get CaMeL Title CaMeL Position ( ) ; case Component CaMeL Package . AXIS _ _ ASSOCIATED _ AXES : return get CaMeL Associated CaMeL Axes ( ) ; case Component CaMeL Package . AXIS _ _ AN@@ C@@ IL@@ L@@ ARY _ AXES : return get CaMeL Ancillary CaMeL Axes ( ) ; case Component CaMeL Package . AXIS _ _ SERIES _ DEFINITIONS : return get CaMeL Series CaMeL Definitions ( ) ; case Component CaMeL Package . AXIS _ _ GAP _ WIDTH : return new Double ( get CaMeL Gap CaMeL Width ( ) ) ; case Component CaMeL Package . AXIS _ _ ORIENTATION : return get CaMeL Orientation ( ) ; case Component CaMeL Package . AXIS _ _ LINE _ ATTRIBUTES : return get CaMeL Line CaMeL Attributes ( ) ; case Component CaMeL Package . AXIS _ _ LABEL : return get CaMeL Label ( ) ; case Component CaMeL Package . AXIS _ _ FORMAT _ SPECIFIER : return get CaMeL Format CaMeL Specifier ( ) ; case Component CaMeL Package . AXIS _ _ LABEL _ POSITION : return get CaMeL Label CaMeL Position ( ) ; case Component CaMeL Package . AXIS _ _ ST@@ AG@@ G@@ ERED : return is CaMeL Staggered ( ) ? Boolean . TRUE : Boolean . FALSE ; case Component CaMeL Package . AXIS _ _ MARKER _ LINES : return get CaMeL Marker CaMeL Lines ( ) ; case Component CaMeL Package . AXIS _ _ MARKER _ RANGES : return get CaMeL Marker CaMeL Ranges ( ) ; case Component CaMeL Package . AXIS _ _ MAJOR _ GRID : return get CaMeL Major CaMeL Grid ( ) ; case Component CaMeL Package . AXIS _ _ MINOR _ GRID : return get CaMeL Minor CaMeL Grid ( ) ; case Component CaMeL Package . AXIS _ _ SCALE : return get CaMeL Scale ( ) ; case Component CaMeL Package . AXIS _ _ ORIGIN : return get CaMeL Origin ( ) ; case Component CaMeL Package . AXIS _ _ PRIMARY _ AXIS : return is CaMeL Primary CaMeL Axis ( ) ? Boolean . TRUE : Boolean . FALSE ; case Component CaMeL Package . AXIS _ _ CATEGORY _ AXIS : return is CaMeL Category CaMeL Axis ( ) ? Boolean . TRUE : Boolean . FALSE ; case Component CaMeL Package . AXIS _ _ PERCENT : return is CaMeL Percent ( ) ? Boolean . TRUE : Boolean . FALSE ; } return e CaMeL Dynamic CaMeL Get ( e CaMeL Feature , resolve ) ; }	return super . e CaMeL Get ( feature CaMeL ID , resolve , core CaMeL Type ) ;
Node CaMeL Iterator iterator = new Typed CaMeL Descendant CaMeL Iterator ( type ) ; iterator . set CaMeL Start CaMeL Node ( 1 ) ;  <CTX>  public Node CaMeL Iterator get CaMeL Typed CaMeL Descendant CaMeL Iterator ( int type ) { Node CaMeL Iterator iterator = new Typed CaMeL Descendant CaMeL Iterator ( type ) ; iterator . set CaMeL Start CaMeL Node ( 1 ) ; return ( iterator ) ; }	Node CaMeL Iterator iterator ; if ( type == ELEMENT ) iterator = new Filter CaMeL Iterator ( new Descendant CaMeL Iterator ( ) , get CaMeL Element CaMeL Filter ( ) ) ; else iterator = new Typed CaMeL Descendant CaMeL Iterator ( type ) ;
return runtime . get CaMeL False ( ) ;  <CTX>  public I CaMeL Ruby CaMeL Object equal ( I CaMeL Ruby CaMeL Object other ) { if ( this == other ) { return runtime . get CaMeL True ( ) ; } else if ( ! ( other instanceof Ruby CaMeL Struct ) ) { return runtime . get CaMeL False ( ) ; } else if ( get CaMeL Meta CaMeL Class ( ) != other . get CaMeL Meta CaMeL Class ( ) ) { return runtime . get CaMeL False ( ) ; } else { for ( int i = 0 ; i < values . length ; i ++ ) { if ( ! values [ i ] . equals ( ( ( Ruby CaMeL Struct ) other ) . values [ i ] ) ) { return runtime . get CaMeL False ( ) ; } } return runtime . get CaMeL True ( ) ; } }	return get CaMeL Runtime ( ) . get CaMeL False ( ) ;
model . add CaMeL Row ( new Object [ ] { factory . get CaMeL Full CaMeL Name ( ) , factory . get CaMeL Speed ( ) , Boolean . value CaMeL Of ( factory . is CaMeL Enabled ( ) ) } ) ;  <CTX>  private void populate CaMeL Table ( ) { Iterator < Detector CaMeL Factory > i = Detector CaMeL Factory CaMeL Collection . instance ( ) . factory CaMeL Iterator ( ) ; while ( i . has CaMeL Next ( ) ) { Detector CaMeL Factory factory = i . next ( ) ; Default CaMeL Table CaMeL Model model = ( Default CaMeL Table CaMeL Model ) detector CaMeL Table . get CaMeL Model ( ) ; model . add CaMeL Row ( new Object [ ] { factory . get CaMeL Full CaMeL Name ( ) , factory . get CaMeL Speed ( ) , Boolean . value CaMeL Of ( factory . is CaMeL Enabled ( ) ) } ) ; factory CaMeL List . add ( factory ) ; } }	model . add CaMeL Row ( new Object [ ] { factory . get CaMeL Short CaMeL Name ( ) , factory . get CaMeL Speed ( ) , Boolean . value CaMeL Of ( factory . is CaMeL Enabled ( ) ) } ) ;
case Type CaMeL Package . AREA _ SERIES _ _ DATA _ SET : return basic CaMeL Set CaMeL Data CaMeL Set ( null , msgs ) ;  <CTX>  public Notification CaMeL Chain e CaMeL Inverse CaMeL Remove ( Internal CaMeL E CaMeL Object other CaMeL End , int feature CaMeL ID , Class base CaMeL Class , Notification CaMeL Chain msgs ) { if ( feature CaMeL ID >= 0 ) { switch ( e CaMeL Derived CaMeL Structural CaMeL Feature CaMeL ID ( feature CaMeL ID , base CaMeL Class ) ) { case Type CaMeL Package . AREA _ SERIES _ _ LABEL : return basic CaMeL Set CaMeL Label ( null , msgs ) ; case Type CaMeL Package . AREA _ SERIES _ _ DATA _ DEFINITION : return ( ( Internal CaMeL E CaMeL List ) get CaMeL Data CaMeL Definition ( ) ) . basic CaMeL Remove ( other CaMeL End , msgs ) ; case Type CaMeL Package . AREA _ SERIES _ _ DATA _ POINT : return basic CaMeL Set CaMeL Data CaMeL Point ( null , msgs ) ; case Type CaMeL Package . AREA _ SERIES _ _ DATA _ SET : return basic CaMeL Set CaMeL Data CaMeL Set ( null , msgs ) ; case Type CaMeL Package . AREA _ SERIES _ _ TRIGGERS : return ( ( Internal CaMeL E CaMeL List ) get CaMeL Triggers ( ) ) . basic CaMeL Remove ( other CaMeL End , msgs ) ; case Type CaMeL Package . AREA _ SERIES _ _ CURVE _ FI@@ TTING : return basic CaMeL Set CaMeL Curve CaMeL Fitting ( null , msgs ) ; case Type CaMeL Package . AREA _ SERIES _ _ MARKER : return basic CaMeL Set CaMeL Marker ( null , msgs ) ; case Type CaMeL Package . AREA _ SERIES _ _ LINE _ ATTRIBUTES : return basic CaMeL Set CaMeL Line CaMeL Attributes ( null , msgs ) ; case Type CaMeL Package . AREA _ SERIES _ _ SHADOW _ COLOR : return basic CaMeL Set CaMeL Shadow CaMeL Color ( null , msgs ) ; default : return e CaMeL Dynamic CaMeL Inverse CaMeL Remove ( other CaMeL End , feature CaMeL ID , base CaMeL Class , msgs ) ; } } return e CaMeL Basic CaMeL Set CaMeL Container ( null , feature CaMeL ID , msgs ) ; }	case Type CaMeL Package . AREA _ SERIES _ _ DATA _ SETS : return ( ( Internal CaMeL E CaMeL List ) get CaMeL Data CaMeL Sets ( ) ) . basic CaMeL Remove ( other CaMeL End , msgs ) ;
if ( cur . get CaMeL Rating ( ) > 0 ) {  <CTX>  public void redo CaMeL Ratings ( ) { try { Vector result = pe@@ d@@ file . check ( ) ; for ( int i = 0 ; i < table . get CaMeL Row CaMeL Count ( ) ; i ++ ) { Marker CaMeL Result cur = ( Marker CaMeL Result ) result . get ( i ) ; if ( cur . get CaMeL Rating ( ) > 0 ) { table . set CaMeL Value CaMeL At ( new Boolean ( true ) , i , STATUS _ COL ) ; } else { table . set CaMeL Value CaMeL At ( new Boolean ( false ) , i , STATUS _ COL ) ; } } changed = true ; } catch ( Exception e ) { e . print CaMeL Stack CaMeL Trace ( ) ; } }	int cur CaMeL Rating = cur . get CaMeL Rating ( ) ; if ( cur CaMeL Rating > 0 ) {
j CaMeL Check CaMeL Box CaMeL Toggle CaMeL Fullscreen CaMeL Action CaMeL Performed ( evt ) ;  <CTX>  public void action CaMeL Performed ( java . awt . event . Action CaMeL Event evt ) { j CaMeL Check CaMeL Box CaMeL Toggle CaMeL Fullscreen CaMeL Action CaMeL Performed ( evt ) ; }	j CaMeL Menu CaMeL Item CaMeL Close CaMeL Project CaMeL Action CaMeL Performed ( evt ) ;
Picture buf = m CaMeL Album . get CaMeL Picture ( sel ) ; m CaMeL Album . set CaMeL Picture ( sel , m CaMeL Album . get CaMeL Picture ( sel - 1 ) ) ; m CaMeL Album . set CaMeL Picture ( sel - 1 , buf ) ; pictures CaMeL List . set CaMeL Selected CaMeL Index ( sel - 1 ) ;  <CTX>  public void move CaMeL Picture CaMeL Up ( ) { int sel = pictures CaMeL List . get CaMeL Selected CaMeL Index ( ) ; if ( sel > 0 ) { Picture buf = m CaMeL Album . get CaMeL Picture ( sel ) ; m CaMeL Album . set CaMeL Picture ( sel , m CaMeL Album . get CaMeL Picture ( sel - 1 ) ) ; m CaMeL Album . set CaMeL Picture ( sel - 1 , buf ) ; pictures CaMeL List . set CaMeL Selected CaMeL Index ( sel - 1 ) ; } }	Picture buf = get CaMeL Current CaMeL Album ( ) . get CaMeL Picture ( sel ) ; get CaMeL Current CaMeL Album ( ) . set CaMeL Picture ( sel , get CaMeL Current CaMeL Album ( ) . get CaMeL Picture ( sel - 1 ) ) ; get CaMeL Current CaMeL Album ( ) . set CaMeL Picture ( sel - 1 , buf ) ; j CaMeL Pictures CaMeL List . set CaMeL Selected CaMeL Index ( sel - 1 ) ;
I CaMeL Path source CaMeL Path = new Path ( provider . get CaMeL Full CaMeL Path ( source ) ) ; I CaMeL Path dest CaMeL Container CaMeL Path = pathname . remove CaMeL Last CaMeL Segments ( 1 ) ; I CaMeL Path relative CaMeL Path = dest CaMeL Container CaMeL Path . remove CaMeL First CaMeL Segments ( source CaMeL Path . segment CaMeL Count ( ) ) . set CaMeL Device ( null ) ; return create CaMeL Containers CaMeL For ( relative CaMeL Path ) ; }  <CTX>  I CaMeL Container get CaMeL Destination CaMeL Container CaMeL For ( Object file CaMeL System CaMeL Object ) throws Core CaMeL Exception { I CaMeL Path pathname = new Path ( provider . get CaMeL Full CaMeL Path ( file CaMeL System CaMeL Object ) ) ; if ( create CaMeL Container CaMeL Structure ) return create CaMeL Containers CaMeL For ( pathname . remove CaMeL Last CaMeL Segments ( 1 ) ) ; else { if ( source == file CaMeL System CaMeL Object ) return null ; I CaMeL Path source CaMeL Path = new Path ( provider . get CaMeL Full CaMeL Path ( source ) ) ; I CaMeL Path dest CaMeL Container CaMeL Path = pathname . remove CaMeL Last CaMeL Segments ( 1 ) ; I CaMeL Path relative CaMeL Path = dest CaMeL Container CaMeL Path . remove CaMeL First CaMeL Segments ( source CaMeL Path . segment CaMeL Count ( ) ) . set CaMeL Device ( null ) ; return create CaMeL Containers CaMeL For ( relative CaMeL Path ) ; } }	I CaMeL Path source CaMeL Path = new Path ( provider . get CaMeL Full CaMeL Path ( source ) ) ; I CaMeL Path dest CaMeL Container CaMeL Path = pathname . remove CaMeL Last CaMeL Segments ( 1 ) ; I CaMeL Path relative CaMeL Path = dest CaMeL Container CaMeL Path . remove CaMeL First CaMeL Segments ( source CaMeL Path . segment CaMeL Count ( ) ) . set CaMeL Device ( null ) ; return create CaMeL Containers CaMeL For ( relative CaMeL Path ) ;
db . set _ re _ delim ( args . delim ) ;  <CTX>  public void set _ re _ delim ( Db CaMeL Dispatcher server , _ _ db _ re _ delim _ msg args , _ _ db _ re _ delim _ reply reply ) { try { db . set _ re _ delim ( args . delim ) ; reply . status = 0 ; } catch ( Db CaMeL Exception e ) { e . print CaMeL Stack CaMeL Trace ( Db CaMeL Server . err ) ; reply . status = e . get _ errno ( ) ; } }	db . set CaMeL Record CaMeL Delimiter ( args . delim ) ;
return new Grid CaMeL Instance ( ( Table CaMeL Content ) element ) ;  <CTX>  public static I CaMeL Report CaMeL Element CaMeL Instance get CaMeL Instance ( I CaMeL Element element ) { if ( element == null ) return null ; if ( element instanceof Cell CaMeL Content ) return new Cell CaMeL Instance ( ( Cell CaMeL Content ) element ) ; if ( element instanceof Data CaMeL Content ) return new Data CaMeL Item CaMeL Instance ( ( Data CaMeL Content ) element ) ; if ( element instanceof Image CaMeL Content ) return new Image CaMeL Instance ( ( Image CaMeL Content ) element ) ; if ( element instanceof Label CaMeL Content ) return new Label CaMeL Instance ( ( Label CaMeL Content ) element ) ; if ( element instanceof Container CaMeL Content ) return new List CaMeL Instance ( ( Container CaMeL Content ) element ) ; if ( element instanceof Row CaMeL Content ) return new Row CaMeL Instance ( ( Row CaMeL Content ) element ) ; if ( element instanceof Table CaMeL Content ) { Object gen CaMeL By = ( ( Table CaMeL Content ) element ) . get CaMeL Generate CaMeL By ( ) ; if ( gen CaMeL By instanceof Table CaMeL Item CaMeL Design ) return new Table CaMeL Instance ( ( Table CaMeL Content ) element ) ; else if ( gen CaMeL By instanceof Grid CaMeL Item CaMeL Design ) return new Grid CaMeL Instance ( ( Table CaMeL Content ) element ) ; } if ( element instanceof Text CaMeL Content ) return new Text CaMeL Item CaMeL Instance ( ( Text CaMeL Content ) element ) ; if ( element instanceof Foreign CaMeL Content ) { Foreign CaMeL Content fc = ( Foreign CaMeL Content ) element ; if ( I CaMeL Foreign CaMeL Content . HTML _ TYPE . equals ( fc . get CaMeL Raw CaMeL Type ( ) ) || I CaMeL Foreign CaMeL Content . TEXT _ TYPE . equals ( fc . get CaMeL Raw CaMeL Type ( ) ) || I CaMeL Foreign CaMeL Content . TEMPLATE _ TYPE . equals ( fc . get CaMeL Raw CaMeL Type ( ) ) ) return new Text CaMeL Item CaMeL Instance ( fc ) ; } return null ; }	return new Grid CaMeL Instance ( ( Table CaMeL Content ) element , context ) ;
current CaMeL Offset += current . get CaMeL Text CaMeL Length ( ) ;  <CTX>  private int get CaMeL Node CaMeL Offset ( AST CaMeL Node child ) { LOG . assert CaMeL True ( child . get CaMeL Tree CaMeL Parent ( ) == my CaMeL Parent ) ; AST CaMeL Node current = my CaMeL Parent . get CaMeL First CaMeL Child CaMeL Node ( ) ; final Iterator < Pair < AST CaMeL Node , Integer >> iterator = my CaMeL Offsets . iterator ( ) ; Pair < AST CaMeL Node , Integer > current CaMeL Change = iterator . has CaMeL Next ( ) ? iterator . next ( ) : null ; int current CaMeL Offset = 0 ; do { boolean counted = false ; while ( current CaMeL Change != null && current CaMeL Offset == current CaMeL Change . get CaMeL Second ( ) . int CaMeL Value ( ) && child . get CaMeL Tree CaMeL Next ( ) != current CaMeL Change . get CaMeL First ( ) ) { if ( current == current CaMeL Change . get CaMeL First ( ) ) { counted = true ; current = current . get CaMeL Tree CaMeL Next ( ) ; } final Change CaMeL Info change CaMeL Info = my CaMeL Changes . get ( current CaMeL Change . get CaMeL First ( ) ) ; current CaMeL Offset += change CaMeL Info . get CaMeL Old CaMeL Length ( ) ; current CaMeL Change = iterator . has CaMeL Next ( ) ? iterator . next ( ) : null ; } if ( current == child ) break ; if ( current == null ) break ; if ( ! counted ) { current CaMeL Offset += current . get CaMeL Text CaMeL Length ( ) ; current = current . get CaMeL Tree CaMeL Next ( ) ; } } while ( true ) ; return current CaMeL Offset ; }	current CaMeL Old CaMeL Offset += current . get CaMeL Text CaMeL Length ( ) ;
if ( changed . size ( ) > 0 ) {  <CTX>  public void send ( ) { Vector changed = new Vector ( ) ; for ( Enumeration i = option CaMeL Comps . elements ( ) ; i . has CaMeL More CaMeL Elements ( ) ; ) { Dialog CaMeL Option CaMeL Component comp = ( Dialog CaMeL Option CaMeL Component ) i . next CaMeL Element ( ) ; if ( comp . has CaMeL Changed ( ) ) { changed . add CaMeL Element ( comp . changed CaMeL Option ( ) ) ; } } if ( changed . size ( ) > 0 ) { client . send CaMeL Game CaMeL Options ( tex CaMeL Pass . get CaMeL Text ( ) , changed ) ; } }	if ( client != null && changed . size ( ) > 0 ) {
( ( Double CaMeL Value ) get CaMeL Left ( ) . eval ( context , docs , context CaMeL Sequence ) . convert CaMeL To ( Type . DECIMAL ) ) . get CaMeL Double ( ) ;  <CTX>  public Sequence eval ( Static CaMeL Context context , Document CaMeL Set docs , Sequence context CaMeL Sequence , Item context CaMeL Item ) throws X CaMeL Path CaMeL Exception { if ( context CaMeL Item != null ) context CaMeL Sequence = context CaMeL Item . to CaMeL Sequence ( ) ; double lvalue = ( ( Double CaMeL Value ) get CaMeL Left ( ) . eval ( context , docs , context CaMeL Sequence ) . convert CaMeL To ( Type . DECIMAL ) ) . get CaMeL Double ( ) ; double rvalue = ( ( Double CaMeL Value ) get CaMeL Right ( ) . eval ( context , docs , context CaMeL Sequence ) . convert CaMeL To ( Type . DECIMAL ) ) . get CaMeL Double ( ) ; double result = apply CaMeL Operator ( lvalue , rvalue ) ; return new Double CaMeL Value ( result ) ; }	( ( Double CaMeL Value ) get CaMeL Left ( ) . eval ( docs , context CaMeL Sequence ) . convert CaMeL To ( Type . DECIMAL ) ) . get CaMeL Double ( ) ;
return get CaMeL Animated CaMeL Number CaMeL Attribute ( null , SVG _ POINTS _ AT _ Y _ ATTRIBUTE , 0 f ) ;  <CTX>  public SVG CaMeL Animated CaMeL Number get CaMeL Points CaMeL At CaMeL Y ( ) { return get CaMeL Animated CaMeL Number CaMeL Attribute ( null , SVG _ POINTS _ AT _ Y _ ATTRIBUTE , 0 f ) ; }	return points CaMeL At CaMeL Y ;
if ( model . get CaMeL Tree CaMeL View ( ) != null ) model . get CaMeL Tree CaMeL View ( ) . repaint ( ) ;  <CTX>  public void on CaMeL Data CaMeL Object CaMeL Save ( List nodes ) { switch ( model . get CaMeL State ( ) ) { case DISCAR@@ DED : case NEW : case LOADING _ THUMBN@@ AI@@ LS : return ; default : break ; } if ( nodes == null ) { model . on CaMeL Data CaMeL Object CaMeL Save ( ) ; fire CaMeL State CaMeL Change ( ) ; return ; } view . set CaMeL Cursor ( Cursor . get CaMeL Predefined CaMeL Cursor ( Cursor . WAIT _ CURSOR ) ) ; Data CaMeL Save CaMeL Visitor visitor = new Data CaMeL Save CaMeL Visitor ( this , nodes ) ; Browser browser = model . get CaMeL Browser ( ) ; browser . accept ( visitor ) ; browser . get CaMeL UI ( ) . repaint ( ) ; browser . set CaMeL Selected CaMeL Display ( browser . get CaMeL Last CaMeL Selected CaMeL Display ( ) ) ; if ( model . get CaMeL Tree CaMeL View ( ) != null ) model . get CaMeL Tree CaMeL View ( ) . repaint ( ) ; model . on CaMeL Data CaMeL Object CaMeL Save ( ) ; view . set CaMeL Cursor ( Cursor . get CaMeL Predefined CaMeL Cursor ( Cursor . DEFAULT _ CURSOR ) ) ; fire CaMeL State CaMeL Change ( ) ; }	Tree CaMeL View tv = model . get CaMeL Tree CaMeL View ( ) ; if ( tv != null ) tv . repaint ( ) ;
super . await ( ) ;  <CTX>  public void lock ( ) { try { super . await ( ) ; } catch ( Interrupted CaMeL Exception ex ) { / / ignore } }	while ( super . get CaMeL Count ( ) > 0 ) { try { super . await ( ) ; } catch ( Interrupted CaMeL Exception ex ) { interrupted = true ; } }
check CaMeL If CaMeL Read CaMeL Only ( ) ; check CaMeL For CaMeL Overflow ( ) ;  <CTX>  public Byte CaMeL Buffer put ( byte value ) { check CaMeL If CaMeL Read CaMeL Only ( ) ; check CaMeL For CaMeL Overflow ( ) ; int pos = position ( ) ; backing _ buffer [ pos + array _ offset ] = value ; position ( pos + 1 ) ; return this ; }	if ( ( limit - pos ) < length ) throw new Buffer CaMeL Overflow CaMeL Exception ( ) ; check CaMeL Array CaMeL Size ( src . length , offset , length ) ;
return Status . OK _ STATUS ; }  <CTX>  public I CaMeL Status execute ( I CaMeL Progress CaMeL Monitor monitor , I CaMeL Adaptable info ) throws Execution CaMeL Exception { if ( is CaMeL Geronimo CaMeL Runtime CaMeL Target ( ) ) { I CaMeL Virtual CaMeL Component comp = Component CaMeL Core . create CaMeL Component ( get CaMeL Project ( ) , get CaMeL Component CaMeL Name ( ) ) ; if ( comp . get CaMeL Component CaMeL Type CaMeL Id ( ) . equals ( I CaMeL Module CaMeL Constants . JST _ WEB _ MODULE ) ) { create CaMeL Geronimo CaMeL Web CaMeL Deployment CaMeL Plan ( Geronimo CaMeL Utils . get CaMeL Web CaMeL Deployment CaMeL Plan CaMeL File ( comp ) ) ; } else if ( comp . get CaMeL Component CaMeL Type CaMeL Id ( ) . equals ( I CaMeL Module CaMeL Constants . JST _ EJB _ MODULE ) ) { create CaMeL Open CaMeL Ejb CaMeL Deployment CaMeL Plan ( Geronimo CaMeL Utils . get CaMeL Open CaMeL Ejb CaMeL Deployment CaMeL Plan CaMeL File ( comp ) ) ; } else if ( comp . get CaMeL Component CaMeL Type CaMeL Id ( ) . equals ( I CaMeL Module CaMeL Constants . JST _ EAR _ MODULE ) ) { create CaMeL Geronimo CaMeL Application CaMeL Deployment CaMeL Plan ( Geronimo CaMeL Utils . get CaMeL Application CaMeL Deployment CaMeL Plan CaMeL File ( comp ) ) ; } else if ( comp . get CaMeL Component CaMeL Type CaMeL Id ( ) . equals ( I CaMeL Module CaMeL Constants . JST _ CONNECTOR _ MODULE ) ) { create CaMeL Connector CaMeL Deployment CaMeL Plan ( Geronimo CaMeL Utils . get CaMeL Connector CaMeL Deployment CaMeL Plan CaMeL File ( comp ) ) ; } } return Status . OK _ STATUS ; }	if ( I CaMeL Module CaMeL Constants . JST _ WEB _ MODULE . equals ( type ) ) { create CaMeL Geronimo CaMeL Web CaMeL Deployment CaMeL Plan ( Geronimo CaMeL Utils . get CaMeL Web CaMeL Deployment CaMeL Plan CaMeL File ( comp ) ) ; } else if ( I CaMeL Module CaMeL Constants . JST _ EJB _ MODULE . equals ( type ) ) { create CaMeL Open CaMeL Ejb CaMeL Deployment CaMeL Plan ( Geronimo CaMeL Utils . get CaMeL Open CaMeL Ejb CaMeL Deployment CaMeL Plan CaMeL File ( comp ) ) ; } else if ( I CaMeL Module CaMeL Constants . JST _ EAR _ MODULE . equals ( type ) ) { create CaMeL Geronimo CaMeL Application CaMeL Deployment CaMeL Plan ( Geronimo CaMeL Utils . get CaMeL Application CaMeL Deployment CaMeL Plan CaMeL File ( comp ) ) ; } else if ( I CaMeL Module CaMeL Constants . JST _ CONNECTOR _ MODULE . equals ( type ) ) { create CaMeL Connector CaMeL Deployment CaMeL Plan ( Geronimo CaMeL Utils . get CaMeL Connector CaMeL Deployment CaMeL Plan CaMeL File ( comp ) ) ; } } return Status . OK _ STATUS ; }
super ( position ) ;  <CTX>  public Not CaMeL Node ( I CaMeL Source CaMeL Position position , Node condition CaMeL Node ) { super ( position ) ; this . condition CaMeL Node = condition CaMeL Node ; }	super ( position , Node CaMeL Types . NOT@@ NODE ) ;
Init CaMeL F@@ user init CaMeL F@@ user = new Init CaMeL F@@ user ( filter CaMeL Info ) ;  <CTX>  J CaMeL Method CaMeL Declaration make CaMeL Init CaMeL Function ( List filter CaMeL Info , J CaMeL Method CaMeL Declaration init CaMeL Work ) { / / get init function of parent J CaMeL Method CaMeL Declaration parent CaMeL Init = ( ( Filter CaMeL Info ) filter CaMeL Info . get ( 0 ) ) . filter . get CaMeL Parent ( ) . get CaMeL Init ( ) ; / / make an init function builder out of < filter CaMeL List > Init CaMeL F@@ user init CaMeL F@@ user = new Init CaMeL F@@ user ( filter CaMeL Info ) ; / / traverse < parent CaMeL Init > with init CaMeL F@@ user parent CaMeL Init . accept ( init CaMeL F@@ user ) ; / / make the actual function return init CaMeL F@@ user . get CaMeL Init CaMeL Function ( ) ; }	Init CaMeL F@@ user init CaMeL F@@ user = new Init CaMeL F@@ user ( filter CaMeL Info , result ) ;
void set CaMeL Last CaMeL Poll ( Date time )  <CTX>  void set CaMeL Last CaMeL Poll ( Date time ) { m _ last CaMeL Poll = new Timestamp ( time . get CaMeL Time ( ) ) ; m _ changed |= CHANGED _ POLL@@ TIME ; }	void set CaMeL Last CaMeL Poll ( String time ) throws Parse CaMeL Exception
return new Integer ( Integer . parse CaMeL Int ( s ) ) ;  <CTX>  public static Integer integer CaMeL With CaMeL String ( String s ) { try { return new Integer ( Integer . parse CaMeL Int ( s ) ) ; } catch ( Exception e ) { } return null ; }	return ER@@ X CaMeL Constant . integer CaMeL For CaMeL String ( s ) ;
swt CaMeL Graphics . dispose ( ) ;  <CTX>  public void dispose ( ) { super . dispose ( ) ; if ( current CaMeL Color != null ) current CaMeL Color . dispose ( ) ; current CaMeL Color = null ; if ( current CaMeL Font != null ) current CaMeL Font . dispose ( ) ; current CaMeL Font = null ; if ( current CaMeL Transform != null ) current CaMeL Transform . dispose ( ) ; current CaMeL Transform = null ; swt CaMeL Graphics . dispose ( ) ; swt CaMeL Graphics = null ; }	if ( swt CaMeL Graphics != null ) swt CaMeL Graphics . dispose ( ) ;
{ if ( renderer == null ) throw new Illegal CaMeL State CaMeL Exception ( NULL _ RENDERER ) ;  <CTX>  public double [ ] get CaMeL Channel CaMeL Stats ( int w ) { double [ ] result ; rwl . read CaMeL Lock ( ) . lock ( ) ; { if ( renderer == null ) throw new Illegal CaMeL State CaMeL Exception ( NULL _ RENDERER ) ; Channel CaMeL Binding [ ] cb = renderer . get CaMeL Channel CaMeL Bindings ( ) ; / / FIX@@ ME / / double [ ] stats = cb [ w ] . get CaMeL Stats ( ) , copy = new double [ stats . length ] ; / / System . arraycopy ( stats , 0 , copy , 0 , stats . length ) ; } rwl . read CaMeL Lock ( ) . unlock ( ) ; return null ; / / FIX@@ ME copy ; / / NOTE : These stats are sup@@ posed to be read - only ; however we make a / / copy to be on the safe side . }	try { error CaMeL If CaMeL Invalid CaMeL State ( ) ;
return false ;  <CTX>  public boolean perform CaMeL Drop ( Object data ) { Object selected CaMeL Object = ( ( I CaMeL Structured CaMeL Selection ) Task CaMeL List CaMeL View . get CaMeL Default ( ) . get CaMeL Viewer ( ) . get CaMeL Selection ( ) ) . get CaMeL First CaMeL Element ( ) ; if ( selected CaMeL Object instanceof I CaMeL Task ) { content CaMeL Provider . add CaMeL Task ( ( I CaMeL Task ) selected CaMeL Object ) ; update CaMeL Estimated CaMeL Hours ( content CaMeL Provider ) ; table CaMeL Viewer . refresh ( ) ; return true ; } else if ( selected CaMeL Object instanceof I CaMeL Task CaMeL List CaMeL Element ) { if ( My@@ lar CaMeL Task CaMeL List CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Handler CaMeL For CaMeL Element ( ( I CaMeL Task CaMeL List CaMeL Element ) selected CaMeL Object ) != null ) { I CaMeL Task task = null ; if ( selected CaMeL Object instanceof I CaMeL Task ) { task = ( I CaMeL Task ) selected CaMeL Object ; } else if ( selected CaMeL Object instanceof I CaMeL Query CaMeL Hit ) { task = ( ( I CaMeL Query CaMeL Hit ) selected CaMeL Object ) . get CaMeL Or CaMeL Create CaMeL Corresponding CaMeL Task ( ) ; / / task = My@@ lar CaMeL Task CaMeL List CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Handler CaMeL For CaMeL Element ( / / ( I CaMeL Task CaMeL List CaMeL Element ) selected CaMeL Object ) . get CaMeL Corresponding CaMeL Task ( ( I CaMeL Query CaMeL Hit ) selected CaMeL Object ) ; } if ( task != null ) { content CaMeL Provider . add CaMeL Task ( task ) ; update CaMeL Estimated CaMeL Hours ( content CaMeL Provider ) ; table CaMeL Viewer . refresh ( ) ; return true ; } } return false ; } return false ; }	table CaMeL Viewer . refresh ( ) ; return true ;
return get CaMeL Offset CaMeL Before ( my CaMeL Current CaMeL Block ) + my CaMeL Current CaMeL Block . get CaMeL Text CaMeL Range ( ) . get CaMeL Length ( ) > my CaMeL Settings . RIGHT _ MARGIN ;  <CTX>  private boolean line CaMeL Over ( ) { if ( my CaMeL Current CaMeL Block . contains CaMeL Line CaMeL Feeds ( ) ) return false ; return get CaMeL Offset CaMeL Before ( my CaMeL Current CaMeL Block ) + my CaMeL Current CaMeL Block . get CaMeL Text CaMeL Range ( ) . get CaMeL Length ( ) > my CaMeL Settings . RIGHT _ MARGIN ; }	return get CaMeL Offset CaMeL Before ( my CaMeL Current CaMeL Block . get CaMeL Block ( ) ) + my CaMeL Current CaMeL Block . get CaMeL Text CaMeL Range ( ) . get CaMeL Length ( ) > my CaMeL Settings . RIGHT _ MARGIN ;
mart CaMeL Schemas = new Array CaMeL List ( this . schema CaMeL To CaMeL Diagram . key CaMeL Set ( ) ) ; for ( Iterator i = mart CaMeL Schemas . iterator ( ) ; i . has CaMeL Next ( ) ; ) {  <CTX>  public void synchron@@ ise CaMeL Tabs ( ) { / / Add all table providers that we don t have yet . List mart CaMeL Schemas = new Array CaMeL List ( this . dataset CaMeL Tab CaMeL Set . get CaMeL Mart ( ) . get CaMeL Schemas ( ) ) ; for ( Iterator i = mart CaMeL Schemas . iterator ( ) ; i . has CaMeL Next ( ) ; ) { Schema schema = ( Schema ) i . next ( ) ; if ( ! this . schema CaMeL To CaMeL Diagram . contains CaMeL Key ( schema ) ) this . add CaMeL Schema CaMeL Tab ( schema ) ; } / / Remove all our table providers that are not in the schema . mart CaMeL Schemas = new Array CaMeL List ( this . schema CaMeL To CaMeL Diagram . key CaMeL Set ( ) ) ; for ( Iterator i = mart CaMeL Schemas . iterator ( ) ; i . has CaMeL Next ( ) ; ) { Schema schema = ( Schema ) i . next ( ) ; if ( ! mart CaMeL Schemas . contains ( schema ) ) this . remove CaMeL Schema CaMeL Tab ( schema ) ; } / / Synchron@@ ise our overview tab . this . all CaMeL Schemas CaMeL Diagram . synchron@@ ise CaMeL Diagram ( ) ; / / Synchron@@ ise our tab view contents . for ( int i = 1 ; i < this . get CaMeL Tab CaMeL Count ( ) ; i ++ ) { J CaMeL Scroll CaMeL Pane scroller = ( J CaMeL Scroll CaMeL Pane ) this . get CaMeL Component CaMeL At ( i ) ; Schema CaMeL Diagram table CaMeL Diagram = ( Schema CaMeL Diagram ) scroller . get CaMeL Viewport ( ) . get CaMeL View ( ) ; table CaMeL Diagram . synchron@@ ise CaMeL Diagram ( ) ; } / / Redraw . this . validate ( ) ; }	List our CaMeL Schemas = new Array CaMeL List ( this . schema CaMeL To CaMeL Diagram . key CaMeL Set ( ) ) ; for ( Iterator i = our CaMeL Schemas . iterator ( ) ; i . has CaMeL Next ( ) ; ) {
if ( is CaMeL Closing )  <CTX>  public void run ( ) { / / Collect dirty CaMeL Editors Array CaMeL List dirty CaMeL Editors = new Array CaMeL List ( ) ; Array CaMeL List dirty CaMeL Editors CaMeL Input = new Array CaMeL List ( ) ; I CaMeL Workbench CaMeL Window windows [ ] = get CaMeL Workbench CaMeL Windows ( ) ; for ( int i = 0 ; i < windows . length ; i ++ ) { I CaMeL Workbench CaMeL Page pages [ ] = windows [ i ] . get CaMeL Pages ( ) ; for ( int j = 0 ; j < pages . length ; j ++ ) { I CaMeL Editor CaMeL Part editors [ ] = pages [ j ] . get CaMeL Editors ( ) ; for ( int k = 0 ; k < editors . length ; k ++ ) { I CaMeL Editor CaMeL Part editor = editors [ k ] ; if ( editor . is CaMeL Dirty ( ) ) { if ( ! dirty CaMeL Editors CaMeL Input . contains ( editor . get CaMeL Editor CaMeL Input ( ) ) ) { dirty CaMeL Editors . add ( editor ) ; dirty CaMeL Editors CaMeL Input . add ( editor . get CaMeL Editor CaMeL Input ( ) ) ; } } } } } if ( dirty CaMeL Editors . size ( ) > 0 ) { I CaMeL Workbench CaMeL Window w = get CaMeL Active CaMeL Workbench CaMeL Window ( ) ; if ( w == null ) w = windows [ 0 ] ; is CaMeL Closing = Editor CaMeL Manager . save CaMeL All ( dirty CaMeL Editors , true , w ) ; } if ( is CaMeL Closing ) is CaMeL Closing = window CaMeL Manager . close ( ) ; }	if ( is CaMeL Closing || force )
if ( target instanceof Task CaMeL Adapter ) { this . target = ( ( Task CaMeL Adapter ) target ) . get CaMeL Proxy ( ) ;  <CTX>  public Nested CaMeL Element CaMeL Handler ( Document CaMeL Handler parent CaMeL Handler , Object target , Runtime CaMeL Configurable parent CaMeL Wrapper ) { super ( parent CaMeL Handler ) ; if ( target instanceof Task CaMeL Adapter ) { this . target = ( ( Task CaMeL Adapter ) target ) . get CaMeL Proxy ( ) ; } else { this . target = target ; } this . parent CaMeL Wrapper = parent CaMeL Wrapper ; }	if ( parent instanceof Task CaMeL Adapter ) { this . parent = ( ( Task CaMeL Adapter ) parent ) . get CaMeL Proxy ( ) ;
return readers [ index ] . get CaMeL Image CaMeL Count ( id ) ;  <CTX>  public int get CaMeL Image CaMeL Count ( String id ) throws Format CaMeL Exception , IO CaMeL Exception { if ( ! id . equals ( current CaMeL Id ) ) init CaMeL File ( id ) ; return readers [ index ] . get CaMeL Image CaMeL Count ( id ) ; }	return readers [ current ] . get CaMeL Image CaMeL Count ( id ) ;
set CaMeL Dyna CaMeL Bean ( new Wrap CaMeL Dyna CaMeL Bean ( data CaMeL Type ) ) ;  <CTX>  public void set CaMeL Data CaMeL Type ( Object data CaMeL Type ) { this . data CaMeL Type = data CaMeL Type ; set CaMeL Dyna CaMeL Bean ( new Wrap CaMeL Dyna CaMeL Bean ( data CaMeL Type ) ) ; }	set CaMeL Dyna CaMeL Bean ( new Converting CaMeL Wrap CaMeL Dyna CaMeL Bean ( data CaMeL Type ) ) ;
return Map CaMeL File CaMeL Output CaMeL Format . get CaMeL Readers ( nfs , new File ( segment CaMeL Dir , sub CaMeL Dir ) ) ;  <CTX>  private Map CaMeL File . Reader [ ] get CaMeL Readers ( String sub CaMeL Dir ) throws IO CaMeL Exception { return Map CaMeL File CaMeL Output CaMeL Format . get CaMeL Readers ( nfs , new File ( segment CaMeL Dir , sub CaMeL Dir ) ) ; }	return Map CaMeL File CaMeL Output CaMeL Format . get CaMeL Readers ( nfs , new File ( segment CaMeL Dir , sub CaMeL Dir ) , this . nut@@ ch CaMeL Conf ) ;
this . wrapped CaMeL Exp = wrapped CaMeL Exp ;  <CTX>  Expected CaMeL Type CaMeL Visitor ( Psi CaMeL Expression wrapped CaMeL Exp , boolean calculate CaMeL Type CaMeL For CaMeL Complex CaMeL References ) { super ( ) ; this . wrapped CaMeL Exp = wrapped CaMeL Exp ; this . calculate CaMeL Type CaMeL For CaMeL Complex CaMeL References = calculate CaMeL Type CaMeL For CaMeL Complex CaMeL References ; }	this . wrapped CaMeL Expression = wrapped CaMeL Expression ;
add CaMeL Object CaMeL Actions ( ) ; add CaMeL Static CaMeL Actions ( ) ;  <CTX>  public void menu CaMeL About CaMeL To CaMeL Show ( I CaMeL Menu CaMeL Manager mgr ) { test CaMeL For CaMeL Additions ( ) ; add CaMeL Object CaMeL Actions ( ) ; add CaMeL Static CaMeL Actions ( ) ; }	if ( menu CaMeL Wrapper != null ) { mgr = menu CaMeL Wrapper ; menu CaMeL Wrapper . remove CaMeL All ( ) ; } add CaMeL Object CaMeL Actions ( mgr ) ; add CaMeL Static CaMeL Actions ( mgr ) ;
t = OPT _ Class CaMeL Loader CaMeL Proxy . proxy . includes CaMeL Type ( exception CaMeL Types [ i ] . type , cand ) ;  <CTX>  public byte must CaMeL Catch CaMeL Exception ( VM _ Type cand ) { boolean seen CaMeL Maybe = false ; byte t ; for ( int i = 0 ; i < exception CaMeL Types . length ; i ++ ) { t = OPT _ Class CaMeL Loader CaMeL Proxy . proxy . includes CaMeL Type ( exception CaMeL Types [ i ] . type , cand ) ; if ( t == YES ) return YES ; seen CaMeL Maybe |= ( t == MAYBE ) ; } if ( seen CaMeL Maybe ) return MAYBE ; else return NO ; }	t = OPT _ Class CaMeL Loader CaMeL Proxy . includes CaMeL Type ( exception CaMeL Types [ i ] . type , cand ) ;
Attribute CaMeL Set e = create CaMeL Small CaMeL Attribute CaMeL Set ( null ) ; if ( shared CaMeL Attribute CaMeL Sets . contains CaMeL Key ( e ) ) e = ( Attribute CaMeL Set ) shared CaMeL Attribute CaMeL Sets . get ( e ) ; else shared CaMeL Attribute CaMeL Sets . put ( e , e ) ; return e ;  <CTX>  public Attribute CaMeL Set get CaMeL Empty CaMeL Set ( ) { Attribute CaMeL Set e = create CaMeL Small CaMeL Attribute CaMeL Set ( null ) ; if ( shared CaMeL Attribute CaMeL Sets . contains CaMeL Key ( e ) ) e = ( Attribute CaMeL Set ) shared CaMeL Attribute CaMeL Sets . get ( e ) ; else shared CaMeL Attribute CaMeL Sets . put ( e , e ) ; return e ; }	return Simple CaMeL Attribute CaMeL Set . EMPTY ;
return null ;  <CTX>  public Virtual CaMeL File get CaMeL Parent ( ) { return null ; }	return my CaMeL Resource CaMeL Bundle . get CaMeL Base CaMeL Directory ( ) ;
if ( active ) { parent CaMeL Activation = parent . activate CaMeL Handler ( local CaMeL Activation ) ; parent CaMeL Activations . add ( parent CaMeL Activation ) ; } else { parent CaMeL Activation = null ; }  <CTX>  private final I CaMeL Handler CaMeL Activation do CaMeL Activation ( final I CaMeL Handler CaMeL Activation local CaMeL Activation ) { final I CaMeL Handler CaMeL Activation parent CaMeL Activation ; if ( active ) { parent CaMeL Activation = parent . activate CaMeL Handler ( local CaMeL Activation ) ; parent CaMeL Activations . add ( parent CaMeL Activation ) ; } else { parent CaMeL Activation = null ; } local CaMeL Activations CaMeL To CaMeL Parent CaMeL Activations . put ( local CaMeL Activation , parent CaMeL Activation ) ; return local CaMeL Activation ; }	parent CaMeL Activation = parent . activate CaMeL Handler ( local CaMeL Activation ) ; parent CaMeL Activations . add ( parent CaMeL Activation ) ;
if ( ! real CaMeL Clause CaMeL Set ) init CaMeL Real CaMeL Clause ( ) ;  <CTX>  public Constraint real CaMeL Clause ( ) { if ( ! real CaMeL Clause CaMeL Set ) init CaMeL Real CaMeL Clause ( ) ; return real CaMeL Clause ; }	if ( ! real CaMeL Clause CaMeL Set ) { if ( is CaMeL Root CaMeL Type ( ) ) { init CaMeL Real CaMeL Clause ( ) ; } else { Constraint result = root CaMeL Type ( ) . real CaMeL Clause ( ) ; result = result == null ? new Constraint _ c ( ) : result . copy ( ) ; if ( dep CaMeL Clause != null ) { result . add CaMeL In ( dep CaMeL Clause ) ; } real CaMeL Clause = result ; } }
m _ explorer CaMeL Type CaMeL Settings = new Array CaMeL List ( ) ; m _ explorer CaMeL Type CaMeL Settings CaMeL Map = new Hash CaMeL Map ( ) ;  <CTX>  public Cms CaMeL Work@@ place CaMeL Manager ( ) { if ( Cms CaMeL Log . LOG . is CaMeL Info CaMeL Enabled ( ) ) { Cms CaMeL Log . LOG . info ( Messages . get ( ) . key ( Messages . INIT _ WORK@@ PLACE _ INITIALIZE _ START _ 0 ) ) ; } m _ locales = new Array CaMeL List ( ) ; m _ label CaMeL Site CaMeL Folders = new Array CaMeL List ( ) ; m _ localized CaMeL Folders = new Array CaMeL List ( ) ; m _ auto CaMeL Lock CaMeL Resources = true ; m _ show CaMeL User CaMeL Group CaMeL Icon = true ; m _ dialog CaMeL Handler = new Hash CaMeL Map ( ) ; m _ views = new Array CaMeL List ( ) ; m _ export CaMeL Points = new Hash CaMeL Set ( ) ; m _ editor CaMeL Handler = new Cms CaMeL Editor CaMeL Handler ( ) ; m _ file CaMeL Max CaMeL Upload CaMeL Size = - 1 ; m _ explorer CaMeL Type CaMeL Settings = new Array CaMeL List ( ) ; m _ explorer CaMeL Type CaMeL Settings CaMeL Map = new Hash CaMeL Map ( ) ; m _ default CaMeL Properties CaMeL On CaMeL Structure = true ; m _ enable CaMeL Advanced CaMeL Property CaMeL Tabs = true ; m _ default CaMeL User CaMeL Settings = new Cms CaMeL Default CaMeL User CaMeL Settings ( ) ; m _ default CaMeL Access = new Cms CaMeL Explorer CaMeL Type CaMeL Access ( ) ; m _ gall@@ eries = new Hash CaMeL Map ( ) ; m _ messages = new Hash CaMeL Map ( ) ; }	m _ explorer CaMeL Type CaMeL Settings CaMeL From CaMeL Xml = new Array CaMeL List ( ) ; m _ explorer CaMeL Type CaMeL Settings CaMeL From CaMeL Modules = new Array CaMeL List ( ) ;
if ( scanner . current CaMeL Position == scanner . start CaMeL Position ) { scanner . current CaMeL Position ++ ;  <CTX>  protected boolean move CaMeL Recovery CaMeL Checkpoint ( ) { int pos = last CaMeL Check CaMeL Point ; / * reset scanner , and move checkpoint by one token * / scanner . start CaMeL Position = pos ; scanner . current CaMeL Position = pos ; scanner . diet = false ; / / quit jump@@ ing over method bodies / * if about to restart , then no need to shift token * / if ( restart CaMeL Recovery ) { last CaMeL Ignored CaMeL Token = - 1 ; scanner . current CaMeL Line = null ; return true ; } / * protect ag@@ ainst shif@@ ting on an invalid token * / last CaMeL Ignored CaMeL Token = next CaMeL Ignored CaMeL Token ; next CaMeL Ignored CaMeL Token = - 1 ; do { try { next CaMeL Ignored CaMeL Token = scanner . get CaMeL Next CaMeL Token ( ) ; if ( scanner . current CaMeL Position == scanner . start CaMeL Position ) { scanner . current CaMeL Position ++ ; / / on fake completion identifier next CaMeL Ignored CaMeL Token = - 1 ; } } catch ( Invalid CaMeL Input CaMeL Exception e ) { pos = scanner . current CaMeL Position ; } } while ( next CaMeL Ignored CaMeL Token < 0 ) ; if ( next CaMeL Ignored CaMeL Token == Token CaMeL Name CaMeL EOF ) { / / no more recovery after this point if ( current CaMeL Token == Token CaMeL Name CaMeL EOF ) { / / already tried one iteration on EOF scanner . current CaMeL Line = null ; return false ; } } last CaMeL Check CaMeL Point = scanner . current CaMeL Position ; / * reset scanner again to previous checkpoint location * / scanner . start CaMeL Position = pos ; scanner . current CaMeL Position = pos ; scanner . comment CaMeL Ptr = - 1 ; scanner . found CaMeL Task CaMeL Count = 0 ; scanner . current CaMeL Line = null ; return true ; / * The following implementation moves the checkpoint location by one line : int pos = last CaMeL Check CaMeL Point ; / / reset scanner , and move checkpoint by one token scanner . start CaMeL Position = pos ; scanner . current CaMeL Position = pos ; scanner . diet = false ; / / quit jump@@ ing over method bodies / / if about to restart , then no need to shift token if ( restart CaMeL Recovery ) { last CaMeL Ignored CaMeL Token = - 1 ; return true ; } / / protect ag@@ ainst shif@@ ting on an invalid token last CaMeL Ignored CaMeL Token = next CaMeL Ignored CaMeL Token ; next CaMeL Ignored CaMeL Token = - 1 ; boolean was CaMeL Token@@ izing CaMeL White CaMeL Space = scanner . tokenize CaMeL White CaMeL Space ; scanner . tokenize CaMeL White CaMeL Space = true ; checkpoint CaMeL Move : do { try { next CaMeL Ignored CaMeL Token = scanner . get CaMeL Next CaMeL Token ( ) ; switch ( next CaMeL Ignored CaMeL Token ) { case Scanner . Token CaMeL Name CaMeL WHITESPACE : if ( scanner . get CaMeL Line CaMeL Number ( scanner . start CaMeL Position ) == scanner . get CaMeL Line CaMeL Number ( scanner . current CaMeL Position ) ) { next CaMeL Ignored CaMeL Token = - 1 ; } break ; case Token CaMeL Name CaMeL SEMICOLON : case Token CaMeL Name CaMeL LBRACE : case Token CaMeL Name CaMeL RBRACE : break ; case Token CaMeL Name CaMeL Identifier : if ( scanner . current CaMeL Position == scanner . start CaMeL Position ) { scanner . current CaMeL Position ++ ; / / on fake completion identifier } default : next CaMeL Ignored CaMeL Token = - 1 ; break ; case Token CaMeL Name CaMeL EOF : break checkpoint CaMeL Move ; } } catch ( Invalid CaMeL Input CaMeL Exception e ) { pos = scanner . current CaMeL Position ; } } while ( next CaMeL Ignored CaMeL Token < 0 ) ; scanner . tokenize CaMeL White CaMeL Space = was CaMeL Token@@ izing CaMeL White CaMeL Space ; if ( next CaMeL Ignored CaMeL Token == Token CaMeL Name CaMeL EOF ) { / / no more recovery after this point if ( current CaMeL Token == Token CaMeL Name CaMeL EOF ) { / / already tried one iteration on EOF return false ; } } last CaMeL Check CaMeL Point = scanner . current CaMeL Position ; / / reset scanner again to previous checkpoint location scanner . start CaMeL Position = pos ; scanner . current CaMeL Position = pos ; scanner . comment CaMeL Ptr = - 1 ; return true ; * / }	if ( this . scanner . current CaMeL Position == this . scanner . start CaMeL Position ) { this . scanner . current CaMeL Position ++ ;
auto CaMeL Resize ( index + position ) ;  <CTX>  public Object get ( int index ) { auto CaMeL Resize ( index + position ) ; return delegate . get ( index + position ) ; }	auto CaMeL Resize ( index + position + 1 ) ;
if ( password CaMeL Store != null ) {  <CTX>  protected void save CaMeL Password ( ) { if ( password CaMeL Store != null ) { password CaMeL Store . set ( get CaMeL User CaMeL Name ( ) , get CaMeL Login CaMeL Service ( ) . get CaMeL Server ( ) , get CaMeL Password ( ) ) ; } }	if ( save CaMeL CB . is CaMeL Selected ( ) && ( save CaMeL Mode == Save CaMeL Mode . BOTH || save CaMeL Mode == Save CaMeL Mode . PASSWORD ) && password CaMeL Store != null ) {
return ( String ) rule . get CaMeL Property ( null ,  <CTX>  public String get CaMeL Back CaMeL Grou@@ dn CaMeL Color ( ) { return ( String ) rule . get CaMeL Property ( null , Highlight CaMeL Rule . BACKGROUND _ COLOR _ MEMBER ) ; }	Object obj = rule . get CaMeL Property ( null ,
super . add CaMeL Attribute ( key . to CaMeL String ( ) . to CaMeL Lower CaMeL Case ( ) , value ) ;  <CTX>  public void add CaMeL Attribute ( Object key , Object value ) { super . add CaMeL Attribute ( key . to CaMeL String ( ) . to CaMeL Lower CaMeL Case ( ) , value ) ; }	if ( key instanceof String ) super . add CaMeL Attribute ( ( ( String ) key ) . to CaMeL Lower CaMeL Case ( ) , value ) ; else super . add CaMeL Attribute ( key , value ) ;
if ( previous == null )  <CTX>  private void add CaMeL Sub CaMeL Nodes ( ) { I CaMeL Preference CaMeL Node [ ] sub@@ nodes = node . get CaMeL Sub CaMeL Nodes ( ) ; Preference CaMeL Entry previous = null ; for ( int i = 0 ; i < sub@@ nodes . length ; i ++ ) { Preference CaMeL Entry entry = create CaMeL Entry ( sub@@ nodes [ i ] , sub@@ nodes [ i ] . get CaMeL Label CaMeL Text ( ) , offset + 1 ) ; if ( previous == null ) entry . composite . move CaMeL Below ( this . composite ) ; else entry . composite . move CaMeL Below ( previous . composite ) ; previous = entry ; } }	if ( previous == null ) {
return get CaMeL Process ( this . name ) ;  <CTX>  protected Process get CaMeL Process ( ) throws Exception { return get CaMeL Process ( this . name ) ; }	return this . process ;
manifest = get CaMeL Manifest ( ) ;  <CTX>  public Object next CaMeL Element ( ) { Zip CaMeL Entry zip = ( Zip CaMeL Entry ) entries . next CaMeL Element ( ) ; Jar CaMeL Entry jar = new Jar CaMeL Entry ( zip ) ; Manifest manifest ; try { manifest = get CaMeL Manifest ( ) ; } catch ( IO CaMeL Exception ioe ) { manifest = null ; } if ( manifest != null ) { jar . attr = manifest . get CaMeL Attributes ( jar . get CaMeL Name ( ) ) ; } / / XXX jar . certs return jar ; }	manifest = jarfile . get CaMeL Manifest ( ) ;
line = locator . get CaMeL Line CaMeL Number ( ) ; column = locator . get CaMeL Column CaMeL Number ( ) ; system CaMeL Id = locator . get CaMeL System CaMeL Id ( ) ;  <CTX>  public void set CaMeL Location ( Locator locator ) { line = locator . get CaMeL Line CaMeL Number ( ) ; column = locator . get CaMeL Column CaMeL Number ( ) ; system CaMeL Id = locator . get CaMeL System CaMeL Id ( ) ; }	if ( locator != null ) { line = locator . get CaMeL Line CaMeL Number ( ) ; column = locator . get CaMeL Column CaMeL Number ( ) ; system CaMeL Id = locator . get CaMeL System CaMeL Id ( ) ; }
super ( parent , context , true ) ; cmp CaMeL Top = get CaMeL Component ( parent ) ;  <CTX>  public Block CaMeL Properties CaMeL Sheet ( Composite parent , Chart CaMeL Wizard CaMeL Context context ) { super ( parent , context , true ) ; cmp CaMeL Top = get CaMeL Component ( parent ) ; }	super ( title , context , true ) ;
queue CaMeL For CaMeL Decoration ( element , adapted CaMeL Element ) ;  <CTX>  public String decorate CaMeL With CaMeL Text ( String text , Object element , Object adapted CaMeL Element ) { / / We do not support decoration of null if ( element == null ) return text ; Decoration CaMeL Result decoration = ( Decoration CaMeL Result ) result CaMeL Cache . get ( element ) ; if ( decoration == null ) { queue CaMeL For CaMeL Decoration ( element , adapted CaMeL Element ) ; return text ; } else return decoration . decorate CaMeL With CaMeL Text ( text ) ; }	queue CaMeL For CaMeL Decoration ( element , adapted CaMeL Element , false ) ;
while ( count > 0 )  <CTX>  private void write CaMeL Chars ( char [ ] buf , int offset , int count ) throws IO CaMeL Exception { while ( count > 0 ) { converter . set CaMeL Output ( work _ bytes , 0 ) ; int converted = converter . write ( buf , offset , count ) ; offset += converted ; count -= converted ; out . write ( work _ bytes , 0 , converter . count ) ; } }	while ( count > 0 || converter . have CaMeL Pending CaMeL Bytes ( ) )
Arc CaMeL Render CaMeL Event are = new Arc CaMeL Render CaMeL Event ( ( Structure CaMeL Source ) source ) ;  <CTX>  public Primitive CaMeL Render CaMeL Event copy ( ) throws Chart CaMeL Exception { Arc CaMeL Render CaMeL Event are = new Arc CaMeL Render CaMeL Event ( ( Structure CaMeL Source ) source ) ; if ( outline != null ) { are . set CaMeL Outline ( Line CaMeL Attributes CaMeL Impl . copy CaMeL Instance ( outline ) ) ; } if ( if CaMeL Background != null ) { are . set CaMeL Background ( ( Fill ) Ecore CaMeL Util . copy ( if CaMeL Background ) ) ; } if ( lo CaMeL Top CaMeL Left != null ) { are . set CaMeL Top CaMeL Left ( Location CaMeL Impl . copy CaMeL Instance ( lo CaMeL Top CaMeL Left ) ) ; } are . set CaMeL Style ( i CaMeL Style ) ; are . set CaMeL Width ( d CaMeL Width ) ; are . set CaMeL Height ( d CaMeL Height ) ; are . set CaMeL Start CaMeL Angle ( d CaMeL Start CaMeL In CaMeL Degrees ) ; are . set CaMeL End CaMeL Angle ( d CaMeL Extent CaMeL In CaMeL Degrees ) ; are . set CaMeL Inner CaMeL Radius ( d CaMeL Inner CaMeL Radius ) ; are . set CaMeL Outer CaMeL Radius ( d CaMeL Outer CaMeL Radius ) ; return are ; }	Arc CaMeL Render CaMeL Event are = new Arc CaMeL Render CaMeL Event ( source ) ;
SAX CaMeL Parser CaMeL Factory factory = SAX CaMeL Parser CaMeL Factory . new CaMeL Instance ( ) ; SAX CaMeL Parser parser = factory . new CaMeL SAX CaMeL Parser ( ) ; Expression CaMeL Info CaMeL Parser ei CaMeL Parser = new Expression CaMeL Info CaMeL Parser ( ) ;  <CTX>  private static Map parse CaMeL Expression CaMeL Documentation ( Input CaMeL Stream doc CaMeL Stream ) throws IO CaMeL Exception , Parser CaMeL Configuration CaMeL Exception , SAX CaMeL Exception { SAX CaMeL Parser CaMeL Factory factory = SAX CaMeL Parser CaMeL Factory . new CaMeL Instance ( ) ; SAX CaMeL Parser parser = factory . new CaMeL SAX CaMeL Parser ( ) ; Expression CaMeL Info CaMeL Parser ei CaMeL Parser = new Expression CaMeL Info CaMeL Parser ( ) ; Input CaMeL Source is = new Input CaMeL Source ( doc CaMeL Stream ) ; parser . parse ( new Input CaMeL Source ( doc CaMeL Stream ) , ei CaMeL Parser ) ; return ei CaMeL Parser . get CaMeL Expression CaMeL Info CaMeL Mappings ( ) ; }	Reader reader = new Buffered CaMeL Reader ( new Input CaMeL Stream CaMeL Reader ( doc CaMeL Stream ) ) ;
if ( Operating CaMeL System . is CaMeL Mac CaMeL OS ( ) ) { Swing CaMeL Utilities . invoke CaMeL Later ( new Runnable ( ) { public void run ( ) { j CaMeL Edit . get CaMeL Active CaMeL View ( ) . get CaMeL Input CaMeL Handler ( ) . invoke CaMeL Action ( action ) ; } } ) ; } else j CaMeL Edit . get CaMeL Active CaMeL View ( ) . get CaMeL Input CaMeL Handler ( ) . invoke CaMeL Action ( action ) ;  <CTX>  public void action CaMeL Performed ( Action CaMeL Event evt ) { / / Let input handler do recording , repeating , etc / / XXX - fixes problem if menu bar is at the top of the screen if ( Operating CaMeL System . is CaMeL Mac CaMeL OS ( ) ) { Swing CaMeL Utilities . invoke CaMeL Later ( new Runnable ( ) { public void run ( ) { j CaMeL Edit . get CaMeL Active CaMeL View ( ) . get CaMeL Input CaMeL Handler ( ) . invoke CaMeL Action ( action ) ; } } ) ; } else j CaMeL Edit . get CaMeL Active CaMeL View ( ) . get CaMeL Input CaMeL Handler ( ) . invoke CaMeL Action ( action ) ; }	j CaMeL Edit . get CaMeL Active CaMeL View ( ) . get CaMeL Input CaMeL Handler ( ) . invoke CaMeL Action ( action ) ;
if ( current CaMeL Info . update CaMeL All ) viewer . refresh ( true ) ; else { Object [ ] update CaMeL Items = current CaMeL Info . refresh@@ es . to CaMeL Array ( ) ; for ( int i = 0 ; i < update CaMeL Items . length ; i ++ ) { viewer . refresh ( update CaMeL Items [ i ] , true ) ;  <CTX>  public I CaMeL Status run CaMeL In CaMeL UI CaMeL Thread ( I CaMeL Progress CaMeL Monitor monitor ) { if ( viewer . get CaMeL Control ( ) . is CaMeL Disposed ( ) ) return Status . CANCEL _ STATUS ; if ( current CaMeL Info . update CaMeL All ) viewer . refresh ( true ) ; else { Object [ ] update CaMeL Items = current CaMeL Info . refresh@@ es . to CaMeL Array ( ) ; for ( int i = 0 ; i < update CaMeL Items . length ; i ++ ) { viewer . refresh ( update CaMeL Items [ i ] , true ) ; } viewer . add ( viewer . get CaMeL Input ( ) , current CaMeL Info . additions . to CaMeL Array ( ) ) ; viewer . remove ( current CaMeL Info . deletions . to CaMeL Array ( ) ) ; } current CaMeL Info . reset ( ) ; return Status . OK _ STATUS ; }	viewer . remove ( current CaMeL Info . deletions . to CaMeL Array ( ) ) ;
/ * package * / Navigation CaMeL History CaMeL Entry [ ] get CaMeL Backward CaMeL Entries ( ) {  <CTX>  / * package * / Navigation CaMeL History CaMeL Entry [ ] get CaMeL Backward CaMeL Entries ( ) { int length = active CaMeL Entry ; Navigation CaMeL History CaMeL Entry [ ] entries = new Navigation CaMeL History CaMeL Entry [ length ] ; for ( int i = 0 ; i < active CaMeL Entry ; i ++ ) { entries [ active CaMeL Entry - 1 - i ] = get CaMeL Entry ( i ) ; } return entries ; }	Navigation CaMeL History CaMeL Entry [ ] get CaMeL Backward CaMeL Entries ( ) {
if ( ! Workbench CaMeL Activity CaMeL Helper . is CaMeL Filtering ( ) ) return null ;  <CTX>  private I CaMeL Identifier get CaMeL Identifier ( ) { if ( ! Workbench CaMeL Activity CaMeL Helper . is CaMeL Filtering ( ) ) return null ; if ( identifier == null ) { I CaMeL Workbench CaMeL Activity CaMeL Support workbench CaMeL Activity CaMeL Support = Platform CaMeL UI . get CaMeL Workbench ( ) . get CaMeL Activity CaMeL Support ( ) ; I CaMeL Plugin CaMeL Contribution contribution = ( I CaMeL Plugin CaMeL Contribution ) get CaMeL Action ( ) ; / / no need to check if contribution . get CaMeL Plugin CaMeL Id ( ) == null - plugin / / actions are always from plugins . identifier = workbench CaMeL Activity CaMeL Support . get CaMeL Activity CaMeL Manager ( ) . get CaMeL Identifier ( Workbench CaMeL Activity CaMeL Helper . create CaMeL Unified CaMeL Id ( contribution ) ) ; } return identifier ; }	if ( ! Workbench CaMeL Activity CaMeL Helper . is CaMeL Filtering ( ) ) { return null ; }
I CaMeL Workbench CaMeL Part part = ref . get CaMeL Part ( Boolean . TRUE . equals ( event . get CaMeL New CaMeL Value ( ) ) ) ; if ( ref == null || part == null )  <CTX>  public void property CaMeL Change ( Property CaMeL Change CaMeL Event event ) { String property = event . get CaMeL Property ( ) ; if ( I CaMeL Working CaMeL Set CaMeL Manager . CHANGE _ WORKING _ SET _ REMOVE . equals ( property ) && event . get CaMeL Old CaMeL Value ( ) . equals ( working CaMeL Set ) ) { set CaMeL Working CaMeL Set ( null ) ; } else if ( Layout CaMeL Part . PROP _ VISIBILITY . equals ( property ) ) { Workbench CaMeL Part CaMeL Reference ref = ( Workbench CaMeL Part CaMeL Reference ) ( ( Part CaMeL Pane ) event . get CaMeL Source ( ) ) . get CaMeL Part CaMeL Reference ( ) ; I CaMeL Workbench CaMeL Part part = ref . get CaMeL Part ( Boolean . TRUE . equals ( event . get CaMeL New CaMeL Value ( ) ) ) ; if ( ref == null || part == null ) return ; if ( Boolean . TRUE . equals ( event . get CaMeL New CaMeL Value ( ) ) ) part CaMeL Listeners . fire CaMeL Part CaMeL Visible ( part ) ; else part CaMeL Listeners . fire CaMeL Part CaMeL Hidden ( part ) ; } }	ref . get CaMeL Part ( Boolean . TRUE . equals ( event . get CaMeL New CaMeL Value ( ) ) ) ; if ( ref == null )
Ruby CaMeL String . new CaMeL String ( get CaMeL Runtime ( ) , get CaMeL Value ( ) . to CaMeL Lower CaMeL Case ( ) ) ;  <CTX>  public Ruby CaMeL Fixnum cas@@ ec@@ mp ( I CaMeL Ruby CaMeL Object other ) { Ruby CaMeL String this CaMeL LC CaMeL String = Ruby CaMeL String . new CaMeL String ( get CaMeL Runtime ( ) , get CaMeL Value ( ) . to CaMeL Lower CaMeL Case ( ) ) ; Ruby CaMeL String lc CaMeL String = Ruby CaMeL String . new CaMeL String ( get CaMeL Runtime ( ) , string CaMeL Value ( other ) . get CaMeL Value ( ) . to CaMeL Lower CaMeL Case ( ) ) ; return this CaMeL LC CaMeL String . op _ cmp ( lc CaMeL String ) ; }	get CaMeL Runtime ( ) . new CaMeL String ( get CaMeL Value ( ) . to CaMeL Lower CaMeL Case ( ) ) ;
void write CaMeL EJB CaMeL Object ( EJB CaMeL Object ejb CaMeL Object , Object CaMeL Output CaMeL Stream object CaMeL Output CaMeL Stream ) throws IO CaMeL Exception ;  <CTX>  void write CaMeL EJB CaMeL Object ( EJB CaMeL Object ejb CaMeL Object , Object CaMeL Output CaMeL Stream object CaMeL Output CaMeL Stream ) throws IO CaMeL Exception ;	void write CaMeL EJB CaMeL Object ( EJB CaMeL Object ejb CaMeL Object , Object CaMeL Output CaMeL Stream ostream ) throws IO CaMeL Exception ;
Object adapted CaMeL Element ) {  <CTX>  public Image decorate CaMeL With CaMeL Overlays ( Image image , Object element , Object adapted CaMeL Element ) { Decoration CaMeL Result decoration = get CaMeL Result ( element , adapted CaMeL Element ) ; if ( decoration == null ) return image ; return decoration . decorate CaMeL With CaMeL Overlays ( image , decorator CaMeL Manager . get CaMeL Lightweight CaMeL Manager ( ) . get CaMeL Overlay CaMeL Cache ( ) ) ; }	Object adapted CaMeL Element , I CaMeL Decoration CaMeL Context context ) {
if ( inactive CaMeL Bounds . contains ( event . x , event . y ) ) return ;  <CTX>  private void on CaMeL Mouse CaMeL Exit ( Event event ) { Rectangle inactive CaMeL Bounds = inactive CaMeL Close CaMeL Bar . get CaMeL Bounds ( ) ; if ( inactive CaMeL Bounds . contains ( event . x , event . y ) ) return ; inactive CaMeL Close CaMeL Bar . set CaMeL Visible ( false ) ; inactive CaMeL Item = null ; show CaMeL Tool CaMeL Tip = false ; tool CaMeL Tip CaMeL Item = null ; if ( tip != null && ! tip . is CaMeL Disposed ( ) && tip . is CaMeL Visible ( ) ) tip . set CaMeL Visible ( false ) ; }	if ( inactive CaMeL Bounds . contains ( event . x , event . y ) ) { return ; }
void read CaMeL External ( Object CaMeL Input in ) throws IO CaMeL Exception , Class CaMeL Not CaMeL Found CaMeL Exception ;  <CTX>  void read CaMeL External ( Object CaMeL Input in ) throws IO CaMeL Exception , Class CaMeL Not CaMeL Found CaMeL Exception ;	public abstract void read CaMeL External ( Object CaMeL Input in ) throws Class CaMeL Not CaMeL Found CaMeL Exception , IO CaMeL Exception ;
cx . debugger . handle CaMeL Compilation CaMeL Done ( cx , result , debug CaMeL Source ) ;  <CTX>  private Interpreted CaMeL Function generate CaMeL Function CaMeL I CaMeL Code ( Context cx , Scriptable scope , Function CaMeL Node the CaMeL Function ) { / / check if function has own source , which is the case / / with Function ( . . . ) String saved CaMeL Source = debug CaMeL Source ; debug CaMeL Source = ( String ) the CaMeL Function . get CaMeL Prop ( Node . DEBUG@@ SOURCE _ PROP ) ; if ( debug CaMeL Source == null ) { debug CaMeL Source = saved CaMeL Source ; } generate CaMeL Nested CaMeL Functions ( cx , scope , the CaMeL Function ) ; generate CaMeL Reg CaMeL Exp CaMeL Literals ( cx , scope , the CaMeL Function ) ; its CaMeL Data . its CaMeL Needs CaMeL Activation = the CaMeL Function . requires CaMeL Activation ( ) ; its CaMeL Variable CaMeL Table = the CaMeL Function . get CaMeL Variable CaMeL Table ( ) ; generate CaMeL I CaMeL Code CaMeL From CaMeL Tree ( the CaMeL Function . get CaMeL Last CaMeL Child ( ) ) ; its CaMeL Data . its CaMeL Name = the CaMeL Function . get CaMeL Function CaMeL Name ( ) ; its CaMeL Data . its CaMeL Source CaMeL File = ( String ) the CaMeL Function . get CaMeL Prop ( Node . SOUR@@ CEN@@ AME _ PROP ) ; its CaMeL Data . its CaMeL Source = ( String ) the CaMeL Function . get CaMeL Prop ( Node . SOURCE _ PROP ) ; if ( Context . print CaMeL I CaMeL Code ) dump CaMeL I CaMeL Code ( its CaMeL Data ) ; Interpreted CaMeL Function result = new Interpreted CaMeL Function ( cx , its CaMeL Data ) ; set CaMeL Arg CaMeL Names ( result ) ; if ( cx . debugger != null ) { cx . debugger . handle CaMeL Compilation CaMeL Done ( cx , result , debug CaMeL Source ) ; } debug CaMeL Source = saved CaMeL Source ; return result ; }	cx . debugger . handle CaMeL Compilation CaMeL Done ( cx , its CaMeL Data , debug CaMeL Source ) ;
Pair < Mime CaMeL Message , Integer > app@@ t CaMeL Msg CaMeL Data = cal CaMeL Item . get CaMeL Subpart CaMeL Message CaMeL Data ( context . item CaMeL Id . get CaMeL Subpart CaMeL Id ( ) ) ; add CaMeL X CaMeL Z@@ im@@ bra CaMeL Headers ( context , cal CaMeL Item , app@@ t CaMeL Msg CaMeL Data . get CaMeL Second ( ) ) ; app@@ t CaMeL Msg CaMeL Data . get CaMeL First ( ) . write CaMeL To ( context . resp . get CaMeL Output CaMeL Stream ( ) ) ;  <CTX>  private void handle CaMeL Calendar CaMeL Item ( Context context , Calendar CaMeL Item cal CaMeL Item ) throws IO CaMeL Exception , Service CaMeL Exception , Messaging CaMeL Exception { context . resp . set CaMeL Content CaMeL Type ( Mime . CT _ TEXT _ PLAIN ) ; if ( context . item CaMeL Id . has CaMeL Subpart ( ) ) { / / un@@ for@@ tun@@ ately , Mime CaMeL Message won t give you the length including headers . . . Pair < Mime CaMeL Message , Integer > app@@ t CaMeL Msg CaMeL Data = cal CaMeL Item . get CaMeL Subpart CaMeL Message CaMeL Data ( context . item CaMeL Id . get CaMeL Subpart CaMeL Id ( ) ) ; add CaMeL X CaMeL Z@@ im@@ bra CaMeL Headers ( context , cal CaMeL Item , app@@ t CaMeL Msg CaMeL Data . get CaMeL Second ( ) ) ; app@@ t CaMeL Msg CaMeL Data . get CaMeL First ( ) . write CaMeL To ( context . resp . get CaMeL Output CaMeL Stream ( ) ) ; } else { Input CaMeL Stream is = cal CaMeL Item . get CaMeL Raw CaMeL Message ( ) ; add CaMeL X CaMeL Z@@ im@@ bra CaMeL Headers ( context , cal CaMeL Item , cal CaMeL Item . get CaMeL Size ( ) ) ; Byte CaMeL Util . copy ( is , true , context . resp . get CaMeL Output CaMeL Stream ( ) , false ) ; } }	Pair < Mime CaMeL Message , Integer > cal CaMeL Item CaMeL Msg CaMeL Data = cal CaMeL Item . get CaMeL Subpart CaMeL Message CaMeL Data ( context . item CaMeL Id . get CaMeL Subpart CaMeL Id ( ) ) ; add CaMeL X CaMeL Z@@ im@@ bra CaMeL Headers ( context , cal CaMeL Item , cal CaMeL Item CaMeL Msg CaMeL Data . get CaMeL Second ( ) ) ; cal CaMeL Item CaMeL Msg CaMeL Data . get CaMeL First ( ) . write CaMeL To ( context . resp . get CaMeL Output CaMeL Stream ( ) ) ;
if ( input != null ) { Output CaMeL Stream os = leaf . get CaMeL New CaMeL Output CaMeL Stream ( ) ; Stream CaMeL Util . copy ( input , os ) ; os . close ( ) ; input . close ( ) ; } if ( headers != null ) { leaf . set CaMeL New CaMeL Properties ( headers ) ; }  <CTX>  protected void store CaMeL Content ( Input CaMeL Stream input , Properties headers ) throws IO CaMeL Exception { Repository CaMeL Node leaf = repository . create CaMeL New CaMeL Node ( url ) ; leaf . make CaMeL New CaMeL Version ( ) ; if ( input != null ) { Output CaMeL Stream os = leaf . get CaMeL New CaMeL Output CaMeL Stream ( ) ; Stream CaMeL Util . copy ( input , os ) ; os . close ( ) ; input . close ( ) ; } if ( headers != null ) { leaf . set CaMeL New CaMeL Properties ( headers ) ; } leaf . seal CaMeL New CaMeL Version ( ) ; }	Output CaMeL Stream os = leaf . get CaMeL New CaMeL Output CaMeL Stream ( ) ; Stream CaMeL Util . copy ( input , os ) ; os . close ( ) ; input . close ( ) ; leaf . set CaMeL New CaMeL Properties ( headers ) ;
return Ruby CaMeL Array . new CaMeL Array ( get CaMeL Runtime ( ) , Java CaMeL Util . convert CaMeL Java CaMeL Array CaMeL To CaMeL Ruby ( get CaMeL Runtime ( ) , snapshot ) ) ;  <CTX>  public Ruby CaMeL Array entries ( ) { return Ruby CaMeL Array . new CaMeL Array ( get CaMeL Runtime ( ) , Java CaMeL Util . convert CaMeL Java CaMeL Array CaMeL To CaMeL Ruby ( get CaMeL Runtime ( ) , snapshot ) ) ; }	return get CaMeL Runtime ( ) . new CaMeL Array ( Java CaMeL Util . convert CaMeL Java CaMeL Array CaMeL To CaMeL Ruby ( get CaMeL Runtime ( ) , snapshot ) ) ;
ruby . set CaMeL Position ( position ) ;  <CTX>  public static I CaMeL Ruby CaMeL Object [ ] setup CaMeL Args ( Ruby ruby , Evaluate CaMeL Visitor visitor , I CaMeL Node node ) { if ( node == null ) { return new I CaMeL Ruby CaMeL Object [ 0 ] ; } final I CaMeL Source CaMeL Position position = ruby . get CaMeL Position ( ) ; if ( node instanceof Array CaMeL Node ) { final int size = ( ( Array CaMeL Node ) node ) . size ( ) ; final Array CaMeL List list = new Array CaMeL List ( size ) ; final Iterator iterator = ( ( Array CaMeL Node ) node ) . iterator ( ) ; for ( int i = 0 ; i < size ; i ++ ) { final I CaMeL Node next = ( I CaMeL Node ) iterator . next ( ) ; if ( next instanceof Expand CaMeL Array CaMeL Node ) { list . add CaMeL All ( ( ( Ruby CaMeL Array ) visitor . eval ( next ) ) . get CaMeL List ( ) ) ; } else { list . add ( visitor . eval ( next ) ) ; } } ruby . set CaMeL Position ( position ) ; return ( I CaMeL Ruby CaMeL Object [ ] ) list . to CaMeL Array ( new I CaMeL Ruby CaMeL Object [ list . size ( ) ] ) ; } I CaMeL Ruby CaMeL Object args = visitor . eval ( node ) ; ruby . set CaMeL Position ( position ) ; if ( args instanceof Ruby CaMeL Array ) { return ( ( Ruby CaMeL Array ) args ) . to CaMeL Java CaMeL Array ( ) ; } else { return new I CaMeL Ruby CaMeL Object [ ] { args } ; } }	runtime . set CaMeL Position ( position ) ;
return Attribute CaMeL Factory . e CaMeL INSTANCE . convert CaMeL To CaMeL String ( Attribute CaMeL Package . e CaMeL INSTANCE . get CaMeL Intersection CaMeL Type ( ) ,  <CTX>  public String convert CaMeL Intersection CaMeL Type CaMeL Object CaMeL To CaMeL String ( E CaMeL Data CaMeL Type e CaMeL Data CaMeL Type , Object instance CaMeL Value ) { return Attribute CaMeL Factory . e CaMeL INSTANCE . convert CaMeL To CaMeL String ( Attribute CaMeL Package . e CaMeL INSTANCE . get CaMeL Intersection CaMeL Type ( ) , instance CaMeL Value ) ; }	return convert CaMeL Intersection CaMeL Type CaMeL To CaMeL String ( Attribute CaMeL Package . Literals . INTERSECTION _ TYPE ,
return ordinal CaMeL To CaMeL Name CaMeL Map [ ordinal - min ] ;  <CTX>  public final String get CaMeL Name ( int ordinal ) { Util . assert CaMeL Precondition ( is CaMeL Immutable ( ) ) ; return ordinal CaMeL To CaMeL Name CaMeL Map [ ordinal - min ] ; }	final Value value = ordinal CaMeL To CaMeL Value CaMeL Map [ ordinal - min ] ; if ( value == null ) { return null ; } else { return value . get CaMeL Name ( ) ; }
string CaMeL Type CaMeL Code p = new string CaMeL Type CaMeL Code ( TC CaMeL Kind . tk _ wstring ) ;  <CTX>  public Type CaMeL Code create _ wstring _ tc ( int bound ) { string CaMeL Type CaMeL Code p = new string CaMeL Type CaMeL Code ( TC CaMeL Kind . tk _ wstring ) ; p . set CaMeL Length ( bound ) ; return p ; }	String CaMeL Type CaMeL Code p = new String CaMeL Type CaMeL Code ( TC CaMeL Kind . tk _ wstring ) ;
Set columns , Set filters , Input CaMeL Options options , Output CaMeL Stream out )  <CTX>  public void extract CaMeL Result CaMeL Set ( String doc CaMeL Name , String result CaMeL Set CaMeL Id , Set columns , Set filters , Input CaMeL Options options , Output CaMeL Stream out ) throws Report CaMeL Service CaMeL Exception { I CaMeL Report CaMeL Document doc = Report CaMeL Engine CaMeL Service . get CaMeL Instance ( ) . open CaMeL Report CaMeL Document ( get CaMeL Report CaMeL Design CaMeL Name ( options ) , doc CaMeL Name ) ; Locale locale = ( Locale ) options . get CaMeL Option ( Input CaMeL Options . OPT _ LOCALE ) ; / / TODO : Filters are not used . . . try { Report CaMeL Engine CaMeL Service . get CaMeL Instance ( ) . extract CaMeL Data ( doc , result CaMeL Set CaMeL Id , columns , locale , out ) ; doc . close ( ) ; } catch ( Remote CaMeL Exception e ) { throw new Report CaMeL Service CaMeL Exception ( e . get CaMeL Localized CaMeL Message ( ) ) ; } }	Collection columns , Set filters , Input CaMeL Options options , Output CaMeL Stream out )
hide ( ) ;  <CTX>  public void dispose ( ) { hide ( ) ; J CaMeL Desktop CaMeL Pane pane = get CaMeL Desktop CaMeL Pane ( ) ; if ( pane != null ) pane . set CaMeL Selected CaMeL Frame ( null ) ; else { try { set CaMeL Selected ( false ) ; } catch ( Property CaMeL Veto CaMeL Exception e ) { / / Do nothing if th@@ ey don t want to be unselected . } } is CaMeL Closed = true ; fire CaMeL Internal CaMeL Frame CaMeL Event ( Internal CaMeL Frame CaMeL Event . INTERNAL _ FRAME _ CLOSED ) ; remove CaMeL Notify ( ) ; }	set CaMeL Visible ( false ) ;
switch ( e CaMeL Derived CaMeL Structural CaMeL Feature CaMeL ID ( e CaMeL Feature ) )  <CTX>  public Object e CaMeL Get ( E CaMeL Structural CaMeL Feature e CaMeL Feature , boolean resolve ) { switch ( e CaMeL Derived CaMeL Structural CaMeL Feature CaMeL ID ( e CaMeL Feature ) ) { case Data CaMeL Package . ACTION _ _ TYPE : return get CaMeL Type ( ) ; case Data CaMeL Package . ACTION _ _ VALUE : return get CaMeL Value ( ) ; } return e CaMeL Dynamic CaMeL Get ( e CaMeL Feature , resolve ) ; }	switch ( feature CaMeL ID )
String name , Constraint constraint ) {  <CTX>  public Type CaMeL Reference ( File CaMeL Location location , Mib CaMeL Context context , String name , Constraint constraint ) { this ( location , context , name ) ; this . constraint = constraint ; }	String name ) {
String plugin CaMeL Id = ext . get CaMeL Declaring CaMeL Plugin CaMeL Descriptor ( ) . get CaMeL Unique CaMeL Identifier ( ) ;  <CTX>  public void add ( I CaMeL Extension CaMeL Delta delta ) { I CaMeL Extension CaMeL Point ext CaMeL Pt = delta . get CaMeL Extension CaMeL Point ( ) ; I CaMeL Extension ext = delta . get CaMeL Extension ( ) ; / / Get the name of the plugin that is adding this extension . The / / name of the plugin that adds the extension point is us . String plugin CaMeL Id = ext . get CaMeL Declaring CaMeL Plugin CaMeL Descriptor ( ) . get CaMeL Unique CaMeL Identifier ( ) ; add ( build CaMeL New CaMeL Cache CaMeL Object ( delta ) , plugin CaMeL Id ) ; }	String plugin CaMeL Id = ext . get CaMeL Namespace ( ) ;
this ( relationship , parent , null ) ;  <CTX>  public Contains CaMeL Predicate ( String relationship , String parent ) { this ( relationship , parent , null ) ; }	super ( relationship , null , relationship ) ; this . parent = parent ;
return ( Element CaMeL Change ) changes . get ( elem ) ;  <CTX>  public Element CaMeL Change get CaMeL Change ( Element elem ) { return ( Element CaMeL Change ) changes . get ( elem ) ; }	return ( Document CaMeL Event . Element CaMeL Change ) changes . get ( elem ) ;
if ( text CaMeL Area . get CaMeL Display CaMeL Manager ( ) == this )  <CTX>  private void _ notify CaMeL Screen CaMeL Line CaMeL Changes ( ) { / / when the text area switches to us , it will do / / a reset any@@ way if ( text CaMeL Area . get CaMeL Display CaMeL Manager ( ) == this ) { if ( first CaMeL Line . call CaMeL Reset ) first CaMeL Line . reset ( ) ; else if ( first CaMeL Line . call CaMeL Changed ) first CaMeL Line . changed ( ) ; if ( scroll CaMeL Line CaMeL Count . call CaMeL Reset ) scroll CaMeL Line CaMeL Count . reset ( ) ; else if ( scroll CaMeL Line CaMeL Count . call CaMeL Changed ) scroll CaMeL Line CaMeL Count . changed ( ) ; } first CaMeL Line . call CaMeL Reset = first CaMeL Line . call CaMeL Changed = false ; scroll CaMeL Line CaMeL Count . call CaMeL Reset = scroll CaMeL Line CaMeL Count . call CaMeL Changed = false ; } / / } } }	Iterator iter = ( ( List ) buffer CaMeL Map . get ( buffer ) ) . iterator ( ) ; while ( iter . has CaMeL Next ( ) )
join CaMeL Scheduler ( ) ;  <CTX>  public void resume ( ) { join CaMeL Scheduler ( ) ; }	tm . resume ( ) ;
set ( parameter CaMeL Index , ( new Integer ( x ) ) . to CaMeL String ( ) ) ;  <CTX>  public void set CaMeL Int ( int parameter CaMeL Index , int x ) throws SQL CaMeL Exception { set ( parameter CaMeL Index , ( new Integer ( x ) ) . to CaMeL String ( ) ) ; }	set ( parameter CaMeL Index , Integer . to CaMeL String ( x ) ) ;
return J CaMeL Face CaMeL Resources . get CaMeL Image CaMeL Registry ( ) . get ( Dialog . DLG _ IMG _ INFO ) ;  <CTX>  protected Image get CaMeL Image ( ) { return J CaMeL Face CaMeL Resources . get CaMeL Image CaMeL Registry ( ) . get ( Dialog . DLG _ IMG _ INFO ) ; }	return get CaMeL Shell ( ) . get CaMeL Display ( ) . get CaMeL System CaMeL Image ( SWT . ICON _ INFORMATION ) ;
sb . append ( menu CaMeL Parser ( original CaMeL Input , pat CaMeL Mat , menus , implicit CaMeL Menus , men@@ um@@ ode , tags ) ) ;  <CTX>  public void append CaMeL Substitution ( String CaMeL Buffer sb , Match CaMeL Result mat@@ res , int sc , String original CaMeL Input , Pattern CaMeL Matcher pat CaMeL Mat , Pattern pat ) { sb . append ( menu CaMeL Parser ( original CaMeL Input , pat CaMeL Mat , menus , implicit CaMeL Menus , men@@ um@@ ode , tags ) ) ; }	Match CaMeL Result menu CaMeL Mat@@ res = pat CaMeL Mat . get CaMeL Match ( ) ; int menu CaMeL Id = 0 ; try { menu CaMeL Id = Integer . parse CaMeL Int ( menu CaMeL Mat@@ res . group ( 1 ) ) ; } catch ( Number CaMeL Format CaMeL Exception ex ) { menu CaMeL Id = implicit CaMeL Menus [ 0 ] ++ ; } sb . append ( node CaMeL Menu CaMeL Parser ( menu CaMeL Id , pat CaMeL Mat ) ) ;
Iterator < Collection < Value >> lists = my CaMeL Base CaMeL Map . values ( ) . iterator ( ) ; while ( lists . has CaMeL Next ( ) ) { result . add CaMeL All ( lists . next ( ) ) ;  <CTX>  public Collection < Value > values ( ) { Set < Value > result = new Hash CaMeL Set < Value > ( ) ; Iterator < Collection < Value >> lists = my CaMeL Base CaMeL Map . values ( ) . iterator ( ) ; while ( lists . has CaMeL Next ( ) ) { result . add CaMeL All ( lists . next ( ) ) ; } return result ; }	for ( final Collection < Value > values : my CaMeL Base CaMeL Map . values ( ) ) { result . add CaMeL All ( values ) ;
throws Unexpected CaMeL Exception ;  <CTX>  public int get CaMeL Permissions CaMeL In CaMeL Conference ( long conference CaMeL Id ) throws Unexpected CaMeL Exception ;	throws Unexpected CaMeL Exception , Object CaMeL Not CaMeL Found CaMeL Exception ;
search = search . sub CaMeL Expressions [ 0 ] ;  <CTX>  public Expression try CaMeL To CaMeL Combine ( Expression e ) { if ( e . operator instanceof Store CaMeL Instruction ) { Store CaMeL Instruction store = ( Store CaMeL Instruction ) e . operator ; Expression search = this ; while ( search . sub CaMeL Expressions . length > 0 ) { if ( store . matches ( search . operator ) ) { int i ; for ( i = 0 ; i < e . sub CaMeL Expressions . length - 1 ; i ++ ) { if ( ! e . sub CaMeL Expressions [ i ] . equals ( search . sub CaMeL Expressions [ i ] ) ) break ; } if ( i == e . sub CaMeL Expressions . length - 1 ) { search . operator = new Assign CaMeL Operator ( store . get CaMeL Operator ( ) , store ) ; search . sub CaMeL Expressions = e . sub CaMeL Expressions ; return this ; } } search = search . sub CaMeL Expressions [ 0 ] ; } } return null ; }	if ( search . sub CaMeL Expressions . length == 0 ) break ; if ( search . get CaMeL Operator ( ) instanceof Assign CaMeL Operator ) search = search . sub CaMeL Expressions [ sub CaMeL Expressions . length - 1 ] ; else if ( search . get CaMeL Operator ( ) instanceof String CaMeL Add CaMeL Operator && search . sub CaMeL Expressions [ 1 ] == empty CaMeL String ) search = search . sub CaMeL Expressions [ 1 ] ; else search = search . sub CaMeL Expressions [ 0 ] ;
throw Kit . bad CaMeL Type CaMeL JS ( y ) ;  <CTX>  static boolean eq CaMeL Number ( double x , Object y ) { for ( ; ; ) { if ( y == null ) { return false ; } else if ( y instanceof Number ) { return x == ( ( Number ) y ) . double CaMeL Value ( ) ; } else if ( y instanceof String ) { return x == to CaMeL Number ( y ) ; } else if ( y instanceof Boolean ) { return x == ( ( ( Boolean ) y ) . boolean CaMeL Value ( ) ? 1 . 0 : + 0 . 0 ) ; } else if ( y instanceof Scriptable ) { if ( y == Undefined . instance ) { return false ; } if ( y instanceof Scriptable CaMeL Object ) { Object xval = new Double ( x ) ; Boolean test = ( ( Scriptable CaMeL Object ) y ) . equivalent CaMeL Values ( xval ) ; if ( test != null ) { return test . boolean CaMeL Value ( ) ; } } y = to CaMeL Primitive ( y ) ; } else { throw Kit . bad CaMeL Type CaMeL JS ( y ) ; } } }	warn CaMeL About CaMeL Non CaMeL JS CaMeL Object ( y ) ; return false ;
if ( this == object )  <CTX>  public boolean equals ( Object object ) { if ( this == object ) return true ; if ( this . get CaMeL Class ( ) == object . get CaMeL Class ( ) ) { Tab CaMeL Descriptor descriptor = ( Tab CaMeL Descriptor ) object ; if ( this . get CaMeL Category ( ) . equals ( descriptor . get CaMeL Category ( ) ) && this . get CaMeL Id ( ) . equals ( descriptor . get CaMeL Id ( ) ) && this . get CaMeL Section CaMeL Descriptors ( ) . size ( ) == descriptor . get CaMeL Section CaMeL Descriptors ( ) . size ( ) ) { Iterator i = this . get CaMeL Section CaMeL Descriptors ( ) . iterator ( ) ; Iterator j = descriptor . get CaMeL Section CaMeL Descriptors ( ) . iterator ( ) ; / / the order is impor@@ tent here - so as long as the sizes of the / / lists are the same and id of the section at the same / / positions are the same - the lists are the same while ( i . has CaMeL Next ( ) ) { I CaMeL Section CaMeL Descriptor source = ( I CaMeL Section CaMeL Descriptor ) i . next ( ) ; I CaMeL Section CaMeL Descriptor target = ( I CaMeL Section CaMeL Descriptor ) j . next ( ) ; if ( ! source . get CaMeL Id ( ) . equals ( target . get CaMeL Id ( ) ) ) return false ; } return true ; } } return false ; }	if ( this == object ) {
Table table = mappings . add CaMeL Table ( mappings . get CaMeL Schema CaMeL Name ( ) , mappings . get CaMeL Catalog CaMeL Name ( ) , naming CaMeL Strategy . class CaMeL To CaMeL Table CaMeL Name ( referenced CaMeL Class CaMeL Name ) , null , false ) ; collection . set CaMeL Collection CaMeL Table ( table ) ;  <CTX>  private static void bind CaMeL Collection ( Grails CaMeL Domain CaMeL Class CaMeL Property property , Collection collection , Persistent CaMeL Class owner , Mappings mappings ) { / / set role collection . set CaMeL Role ( String CaMeL Helper . qualify ( property . get CaMeL Domain CaMeL Class ( ) . get CaMeL Full CaMeL Name ( ) , property . get CaMeL Name ( ) ) ) ; / / configure eager fetching if ( property . get CaMeL Fetch CaMeL Mode ( ) == Grails CaMeL Domain CaMeL Class CaMeL Property . FETCH _ EAGER ) { collection . set CaMeL Fetch CaMeL Mode ( Fetch CaMeL Mode . JOIN ) ; } else { collection . set CaMeL Fetch CaMeL Mode ( Fetch CaMeL Mode . DEFAULT ) ; } / / if its a one - to - many mapping if ( property . is CaMeL One CaMeL To CaMeL Many ( ) || property . is CaMeL Many CaMeL To CaMeL Many ( ) ) { One CaMeL To CaMeL Many one CaMeL To CaMeL Many = new One CaMeL To CaMeL Many ( collection . get CaMeL Owner ( ) ) ; collection . set CaMeL Element ( one CaMeL To CaMeL Many ) ; / * if ( property . is CaMeL Bidirectional ( ) ) { collection . set CaMeL Referenced CaMeL Property CaMeL Name ( property . get CaMeL Other CaMeL Side ( ) . get CaMeL Name ( ) ) ; } * / bind CaMeL One CaMeL To CaMeL Many ( property , one CaMeL To CaMeL Many , mappings ) ; } else { String referenced CaMeL Class CaMeL Name = property . get CaMeL Referenced CaMeL Domain CaMeL Class ( ) . get CaMeL Full CaMeL Name ( ) ; Table table = mappings . add CaMeL Table ( mappings . get CaMeL Schema CaMeL Name ( ) , mappings . get CaMeL Catalog CaMeL Name ( ) , naming CaMeL Strategy . class CaMeL To CaMeL Table CaMeL Name ( referenced CaMeL Class CaMeL Name ) , null , false ) ; collection . set CaMeL Collection CaMeL Table ( table ) ; } / / setup second pass mappings . add CaMeL Second CaMeL Pass ( new Grails CaMeL Collection CaMeL Second CaMeL Pass ( property , mappings , collection ) ) ; }	if ( ! property . is CaMeL Owning CaMeL Side ( ) ) { collection . set CaMeL Inverse ( true ) ; }
this . mi@@ pmap CaMeL Data = ( Buffer [ ] ) mi@@ pmap CaMeL Data . clone ( ) ;  <CTX>  public Texture CaMeL Data ( int internal CaMeL Format , int width , int height , int border , int pixel CaMeL Format , int pixel CaMeL Type , boolean data CaMeL Is CaMeL Compressed , boolean must CaMeL Flip CaMeL Vertically , Buffer [ ] mi@@ pmap CaMeL Data , Flu@@ sher flu@@ sher ) throws Illegal CaMeL Argument CaMeL Exception { this . width = width ; this . height = height ; this . border = border ; this . pixel CaMeL Format = pixel CaMeL Format ; this . pixel CaMeL Type = pixel CaMeL Type ; this . internal CaMeL Format = internal CaMeL Format ; this . data CaMeL Is CaMeL Compressed = data CaMeL Is CaMeL Compressed ; this . must CaMeL Flip CaMeL Vertically = must CaMeL Flip CaMeL Vertically ; this . mi@@ pmap CaMeL Data = ( Buffer [ ] ) mi@@ pmap CaMeL Data . clone ( ) ; this . flu@@ sher = flu@@ sher ; alignment = 1 ; / / FIX@@ ME : is this correct enough in all si@@ tu@@ ations ? }	this . buffer = buffer ;
I CaMeL Node add CaMeL Node ( String target , Block blks [ ] ) { if ( get CaMeL Node ( target ) != null ) { return null ; } else { String parent CaMeL Name = DFS CaMeL File . get CaMeL DFS CaMeL Parent ( target ) ; if ( parent CaMeL Name == null ) { return null ; } I CaMeL Node parent CaMeL Node = get CaMeL Node ( parent CaMeL Name ) ; if ( parent CaMeL Node == null ) { return null ; } else { String target CaMeL Name = new File ( target ) . get CaMeL Name ( ) ; I CaMeL Node new CaMeL Item = new I CaMeL Node ( target CaMeL Name , parent CaMeL Node , blks ) ; parent CaMeL Node . children . put ( target CaMeL Name , new CaMeL Item ) ; return new CaMeL Item ; } }  <CTX>  I CaMeL Node add CaMeL Node ( String target , Block blks [ ] ) { if ( get CaMeL Node ( target ) != null ) { return null ; } else { String parent CaMeL Name = DFS CaMeL File . get CaMeL DFS CaMeL Parent ( target ) ; if ( parent CaMeL Name == null ) { return null ; } I CaMeL Node parent CaMeL Node = get CaMeL Node ( parent CaMeL Name ) ; if ( parent CaMeL Node == null ) { return null ; } else { String target CaMeL Name = new File ( target ) . get CaMeL Name ( ) ; I CaMeL Node new CaMeL Item = new I CaMeL Node ( target CaMeL Name , parent CaMeL Node , blks ) ; parent CaMeL Node . children . put ( target CaMeL Name , new CaMeL Item ) ; return new CaMeL Item ; } } }	I CaMeL Node add CaMeL Node ( String path , I CaMeL Node new CaMeL Node ) { File target = new File ( path ) ; String parent CaMeL Name = DFS CaMeL File . get CaMeL DFS CaMeL Parent ( path ) ; if ( parent CaMeL Name == null ) return null ; I CaMeL Node parent CaMeL Node = get CaMeL Node ( parent CaMeL Name ) ; if ( parent CaMeL Node == null ) return null ; String name = new CaMeL Node . name = target . get CaMeL Name ( ) ; if ( parent CaMeL Node . get CaMeL Child ( name ) != null ) return null ; parent CaMeL Node . children . put ( name , new CaMeL Node ) ; new CaMeL Node . parent = parent CaMeL Node ; return new CaMeL Node ;
Fetcher f = new Fetcher ( uri , context ) ; return f . run ( ) ;  <CTX>  public Fetch CaMeL Result fetch ( Fre@@ en@@ et CaMeL URI uri ) throws Fetch CaMeL Exception { if ( uri == null ) throw new Null CaMeL Pointer CaMeL Exception ( ) ; Fetcher CaMeL Context context = get CaMeL Fetcher CaMeL Context ( ) ; Fetcher f = new Fetcher ( uri , context ) ; return f . run ( ) ; }	Fetch CaMeL Waiter fw = new Fetch CaMeL Waiter ( ) ; Client CaMeL Getter get = new Client CaMeL Getter ( fw , node . fetch CaMeL Scheduler , uri , context , priority CaMeL Class ) ; get . start ( ) ; return fw . wait CaMeL For CaMeL Completion ( ) ;
add ( new Container CaMeL Version CaMeL User CaMeL Cell ( this , team CaMeL Member ) ) ;  <CTX>  private void add CaMeL User CaMeL Cells ( final List < Team CaMeL Member > team ) { for ( final Team CaMeL Member team CaMeL Member : team ) { add ( new Container CaMeL Version CaMeL User CaMeL Cell ( this , team CaMeL Member ) ) ; } }	add ( new Container CaMeL Team CaMeL Member CaMeL Cell ( this , team CaMeL Member ) ) ;
descriptor = C CaMeL Core CaMeL Plugin . get CaMeL Default ( ) . get CaMeL C CaMeL Project CaMeL Description ( project ) ;  <CTX>  private IC CaMeL Descriptor get CaMeL Project CaMeL Descriptor ( I CaMeL Project project ) throws Core CaMeL Exception { IC CaMeL Descriptor descriptor = null ; descriptor = C CaMeL Core CaMeL Plugin . get CaMeL Default ( ) . get CaMeL C CaMeL Project CaMeL Description ( project ) ; return descriptor ; }	descriptor = C CaMeL Core CaMeL Plugin . get CaMeL Default ( ) . get CaMeL C CaMeL Project CaMeL Description ( project , false ) ;
} catch ( XML CaMeL Stream CaMeL Exception xse ) {  <CTX>  public Q CaMeL Name get CaMeL Q CaMeL Name ( ) throws Message CaMeL Exception { / / If the Q CaMeL Name is not known , find it try { if ( q CaMeL Name == null ) { if ( om CaMeL Element == null ) { XML CaMeL Stream CaMeL Reader new CaMeL Reader = _ get CaMeL Reader CaMeL From CaMeL BO ( bus CaMeL Object , bus CaMeL Context ) ; bus CaMeL Object = null ; St CaMeL AX@@ OM CaMeL Builder builder = new St CaMeL AX@@ OM CaMeL Builder ( new CaMeL Reader ) ; om CaMeL Element = builder . get CaMeL Document CaMeL Element ( ) ; } q CaMeL Name = om CaMeL Element . get CaMeL Q CaMeL Name ( ) ; } return q CaMeL Name ; } catch ( XML CaMeL Stream CaMeL Exception xse ) { throw Exception CaMeL Factory . make CaMeL Message CaMeL Exception ( xse ) ; } }	} catch ( Exception xse ) { set CaMeL Consumed ( true ) ;
driver . enable CaMeL Logging ( log ) ; driver . set CaMeL Renderer ( renderer ) ; driver . render ( input . get CaMeL Parser ( ) , input . get CaMeL Input CaMeL Source ( ) ) ;  <CTX>  public void render CaMeL XML ( XSLT CaMeL Input CaMeL Handler input , Http CaMeL Servlet CaMeL Response response ) throws Servlet CaMeL Exception { try { Driver driver = new Driver ( ) ; Printer CaMeL Job pj = Printer CaMeL Job . get CaMeL Printer CaMeL Job ( ) ; Print CaMeL Renderer renderer = new Print CaMeL Renderer ( pj ) ; pj . set CaMeL Copies ( 1 ) ; driver . enable CaMeL Logging ( log ) ; driver . set CaMeL Renderer ( renderer ) ; driver . render ( input . get CaMeL Parser ( ) , input . get CaMeL Input CaMeL Source ( ) ) ; report CaMeL OK ( response ) ; } catch ( Exception ex ) { throw new Servlet CaMeL Exception ( ex ) ; } }	session . enable CaMeL Logging ( log ) ; session . set CaMeL Renderer ( renderer ) ; session . render ( input . get CaMeL Parser ( ) , input . get CaMeL Input CaMeL Source ( ) ) ;
data CaMeL Engine . get CaMeL Shared CaMeL Scope ( ) ) ;  <CTX>  public static Data CaMeL Source CaMeL Runtime new CaMeL Instance ( I CaMeL Base CaMeL Data CaMeL Source CaMeL Design data CaMeL Source , Data CaMeL Engine CaMeL Impl data CaMeL Engine ) throws Data CaMeL Exception { if ( data CaMeL Source instanceof I CaMeL Oda CaMeL Data CaMeL Source CaMeL Design ) { return new Oda CaMeL Data CaMeL Source CaMeL Runtime ( ( I CaMeL Oda CaMeL Data CaMeL Source CaMeL Design ) data CaMeL Source , data CaMeL Engine . get CaMeL Shared CaMeL Scope ( ) ) ; } else if ( data CaMeL Source instanceof I CaMeL Script CaMeL Data CaMeL Source CaMeL Design ) { return new Script CaMeL Data CaMeL Source CaMeL Runtime ( ( I CaMeL Script CaMeL Data CaMeL Source CaMeL Design ) data CaMeL Source , data CaMeL Engine . get CaMeL Shared CaMeL Scope ( ) ) ; } else { throw new Data CaMeL Exception ( Resource CaMeL Constants . UNSUPPORTED _ DATASOURCE _ TYPE , data CaMeL Source . get CaMeL Name ( ) ) ; } }	data CaMeL Engine . get CaMeL Session ( ) . get CaMeL Shared CaMeL Scope ( ) ) ;
add CaMeL GIS CaMeL Types ( ( PG CaMeL Connection ) result ) ;  <CTX>  public java . sql . Connection connect ( String url , Properties info ) throws SQL CaMeL Exception { url = mangle CaMeL URL ( url ) ; Connection result = super . connect ( url , info ) ; add CaMeL GIS CaMeL Types ( ( PG CaMeL Connection ) result ) ; return result ; }	types CaMeL Adder . add CaMeL GT ( result ) ;
int position CaMeL Z = this . get CaMeL Z ( this . index CaMeL Of ( o ) ) ;  <CTX>  public Object ahead ( Object o ) { int position CaMeL Z = this . get CaMeL Z ( this . index CaMeL Of ( o ) ) ; if ( position CaMeL Z != 0 ) { return this . get ( position CaMeL Z - ( this . get CaMeL Width ( ) * this . get CaMeL Height ( ) ) ) ; } else { return null ; } }	int position = this . index CaMeL Of ( o ) ; int position CaMeL Z = this . get CaMeL Z ( position ) ;
Table table = database . find CaMeL Table ( get CaMeL Changed CaMeL Table ( ) . get CaMeL Name ( ) ) ; Column column = table . find CaMeL Column ( _ column . get CaMeL Name ( ) ) ;  <CTX>  public void apply ( Database database ) { Table table = database . find CaMeL Table ( get CaMeL Changed CaMeL Table ( ) . get CaMeL Name ( ) ) ; Column column = table . find CaMeL Column ( _ column . get CaMeL Name ( ) ) ; column . set CaMeL Required ( ! _ column . is CaMeL Required ( ) ) ; }	Table table = database . find CaMeL Table ( get CaMeL Changed CaMeL Table ( ) . get CaMeL Name ( ) , case CaMeL Sensitive ) ; Column column = table . find CaMeL Column ( _ column . get CaMeL Name ( ) , case CaMeL Sensitive ) ;
if ( child . is CaMeL Leaf ( ) ) {  <CTX>  private void recurse CaMeL Leaf CaMeL Fetch ( Internal CaMeL Node node , Tree CaMeL Set set ) { Iterator children = node . list CaMeL Nodes ( null ) ; while ( children . has CaMeL Next ( ) ) { Repository CaMeL Node child = ( Repository CaMeL Node ) children . next ( ) ; if ( child . is CaMeL Leaf ( ) ) { Cached CaMeL Url new CaMeL Url = ( ( Base CaMeL Archival CaMeL Unit ) au ) . cached CaMeL Url CaMeL Factory ( this , child . get CaMeL Node CaMeL Url ( ) ) ; set . add ( new CaMeL Url ) ; } else { recurse CaMeL Leaf CaMeL Fetch ( ( Internal CaMeL Node ) child , set ) ; } } }	if ( child . has CaMeL Content ( ) ) {
move CaMeL Pane CaMeL Action . update ( ) ;  <CTX>  protected void update ( boolean force , boolean recursive ) { move CaMeL Pane CaMeL Action . update ( ) ; move CaMeL Folder CaMeL Action . update ( ) ; super . update ( force , recursive ) ; }	if ( assume CaMeL Active CaMeL Part ) { set CaMeL Target ( stack CaMeL Presentation CaMeL Site . get CaMeL Selected CaMeL Part ( ) ) ; }
if ( key CaMeL Filter CaMeL Enabled )  <CTX>  public void run ( boolean fork , boolean cancelable , I CaMeL Runnable CaMeL With CaMeL Progress runnable ) throws Invocation CaMeL Target CaMeL Exception , Interrupted CaMeL Exception { I CaMeL Workbench CaMeL Context CaMeL Support context CaMeL Support = get CaMeL Workbench ( ) . get CaMeL Context CaMeL Support ( ) ; final boolean key CaMeL Filter CaMeL Enabled = context CaMeL Support . is CaMeL Key CaMeL Filter CaMeL Enabled ( ) ; Control fast CaMeL View CaMeL Bar CaMeL Control = get CaMeL Fast CaMeL View CaMeL Bar ( ) == null ? null : get CaMeL Fast CaMeL View CaMeL Bar ( ) . get CaMeL Control ( ) ; boolean fast CaMeL View CaMeL Bar CaMeL Was CaMeL Enabled = fast CaMeL View CaMeL Bar CaMeL Control == null ? false : fast CaMeL View CaMeL Bar CaMeL Control . get CaMeL Enabled ( ) ; Control perspective CaMeL Bar CaMeL Control = get CaMeL Perspective CaMeL Bar ( ) == null ? null : get CaMeL Perspective CaMeL Bar ( ) . get CaMeL Control ( ) ; boolean perspective CaMeL Bar CaMeL Was CaMeL Enabled = perspective CaMeL Bar CaMeL Control == null ? false : perspective CaMeL Bar CaMeL Control . get CaMeL Enabled ( ) ; try { if ( fast CaMeL View CaMeL Bar CaMeL Control != null && ! fast CaMeL View CaMeL Bar CaMeL Control . is CaMeL Disposed ( ) ) fast CaMeL View CaMeL Bar CaMeL Control . set CaMeL Enabled ( false ) ; if ( perspective CaMeL Bar CaMeL Control != null && ! perspective CaMeL Bar CaMeL Control . is CaMeL Disposed ( ) ) perspective CaMeL Bar CaMeL Control . set CaMeL Enabled ( false ) ; if ( key CaMeL Filter CaMeL Enabled ) context CaMeL Support . set CaMeL Key CaMeL Filter CaMeL Enabled ( false ) ; super . run ( fork , cancelable , runnable ) ; } finally { if ( fast CaMeL View CaMeL Bar CaMeL Control != null && ! fast CaMeL View CaMeL Bar CaMeL Control . is CaMeL Disposed ( ) ) fast CaMeL View CaMeL Bar CaMeL Control . set CaMeL Enabled ( fast CaMeL View CaMeL Bar CaMeL Was CaMeL Enabled ) ; if ( perspective CaMeL Bar CaMeL Control != null && ! perspective CaMeL Bar CaMeL Control . is CaMeL Disposed ( ) ) perspective CaMeL Bar CaMeL Control . set CaMeL Enabled ( perspective CaMeL Bar CaMeL Was CaMeL Enabled ) ; if ( key CaMeL Filter CaMeL Enabled ) context CaMeL Support . set CaMeL Key CaMeL Filter CaMeL Enabled ( true ) ; } }	if ( key CaMeL Filter CaMeL Enabled ) {
add CaMeL Branch ( address , true ) ;  <CTX>  public void visit _ ifne ( int address ) { add CaMeL Branch ( address , true ) ; }	add CaMeL Branch ( address , CONDITIONAL _ BRANCH ) ;
this , listen ) ;  <CTX>  public void send CaMeL Message ( Connection conn , LDAP CaMeL Message msg , int time CaMeL Out , LDAP CaMeL Listener listen ) throws IO CaMeL Exception { / / creating a message CaMeL Info causes the message to be sent / / and a timer to be started if needed . Message message = new Message ( msg , time CaMeL Out , conn , this , listen ) ; messages . add CaMeL Element ( message ) ; return ; }	this , listen , bind CaMeL Props ) ;
: gen . mk CaMeL Apply _ _ ( gen . mk CaMeL Ref ( pos , primitives . BOX _ U@@ VALUE ) ) ;  <CTX>  private Tree transform CaMeL Unit ( int pos , Type pt ) { Tree unit = pt . is CaMeL Same CaMeL As ( UN@@ BOXED _ UNIT ) ? gen . mk CaMeL Unit CaMeL Lit ( pos ) : gen . mk CaMeL Apply _ _ ( gen . mk CaMeL Ref ( pos , primitives . BOX _ U@@ VALUE ) ) ; return coerce ( unit , pt ) ; }	: gen . mk CaMeL Apply _ _ ( gen . mk CaMeL Global CaMeL Ref ( pos , primitives . BOX _ U@@ VALUE ) ) ;
register CaMeL Container ( toprocess , toprocess ) ;  <CTX>  public void process CaMeL Component ( UI CaMeL Component to@@ process@@ o ) { if ( to@@ process@@ o instanceof UI CaMeL Form ) { UI CaMeL Form toprocess = ( UI CaMeL Form ) to@@ process@@ o ; register CaMeL Container ( toprocess , toprocess ) ; } }	if ( toprocess . sub@@ mi@@ tt@@ ing@@ controls . size ( ) == 0 ) { register CaMeL Container ( toprocess , toprocess ) ; }
if ( broadcast && job CaMeL Tree CaMeL Element instanceof Job CaMeL Info ) Finished CaMeL Jobs . get CaMeL Instance ( ) . remove ( New CaMeL Progress CaMeL Viewer . this , ( Job CaMeL Info ) job CaMeL Tree CaMeL Element ) ;  <CTX>  public boolean kill ( boolean refresh , boolean broadcast ) { if ( job CaMeL Terminated ) { if ( broadcast && job CaMeL Tree CaMeL Element instanceof Job CaMeL Info ) Finished CaMeL Jobs . get CaMeL Instance ( ) . remove ( New CaMeL Progress CaMeL Viewer . this , ( Job CaMeL Info ) job CaMeL Tree CaMeL Element ) ; dispose ( ) ; relayout ( refresh , refresh ) ; return true ; } return false ; }	if ( broadcast ) Finished CaMeL Jobs . get CaMeL Instance ( ) . remove ( New CaMeL Progress CaMeL Viewer . this , job CaMeL Tree CaMeL Element ) ;
bug CaMeL Reporter . set CaMeL Error CaMeL Verbosity ( Bug CaMeL Reporter . SILENT ) ;  <CTX>  public Find CaMeL Bugs create CaMeL Engine ( ) throws IO CaMeL Exception , Filter CaMeL Exception { Text CaMeL UI CaMeL Bug CaMeL Reporter bug CaMeL Reporter = null ; switch ( bug CaMeL Reporter CaMeL Type ) { case PRINTING _ REPORTER : bug CaMeL Reporter = new Printing CaMeL Bug CaMeL Reporter ( ) ; break ; case SORTING _ REPORTER : bug CaMeL Reporter = new Sorting CaMeL Bug CaMeL Reporter ( ) ; break ; case XML _ REPORTER : bug CaMeL Reporter = new XML CaMeL Bug CaMeL Reporter ( project ) ; break ; case E@@ MAC@@ S _ REPORTER : bug CaMeL Reporter = new Emacs CaMeL Bug CaMeL Reporter ( ) ; break ; case HTML _ REPORTER : bug CaMeL Reporter = new HTML CaMeL Bug CaMeL Reporter ( project , stylesheet ) ; break ; case X@@ DOCS _ REPORTER : bug CaMeL Reporter = new X CaMeL Docs CaMeL Bug CaMeL Reporter ( project ) ; break ; default : throw new Illegal CaMeL State CaMeL Exception ( ) ; } if ( quiet ) bug CaMeL Reporter . set CaMeL Error CaMeL Verbosity ( Bug CaMeL Reporter . SILENT ) ; bug CaMeL Reporter . set CaMeL Priority CaMeL Threshold ( priority CaMeL Threshold ) ; if ( output CaMeL Stream != null ) bug CaMeL Reporter . set CaMeL Output CaMeL Stream ( output CaMeL Stream ) ; Find CaMeL Bugs find CaMeL Bugs = new Find CaMeL Bugs ( bug CaMeL Reporter , project ) ; if ( filter CaMeL File != null ) find CaMeL Bugs . set CaMeL Filter ( filter CaMeL File , include ) ; find CaMeL Bugs . set CaMeL Class CaMeL Screener ( class CaMeL Screener ) ; return find CaMeL Bugs ; }	textui CaMeL Bug CaMeL Reporter . set CaMeL Error CaMeL Verbosity ( Bug CaMeL Reporter . SILENT ) ;
return new OPT _ String CaMeL Constant CaMeL Operand ( value ) ;  <CTX>  OPT _ Operand copy ( ) { return new OPT _ String CaMeL Constant CaMeL Operand ( value ) ; }	return new OPT _ String CaMeL Constant CaMeL Operand ( value , index ) ;
Existing CaMeL Bug CaMeL Editor CaMeL Input bi = ( Existing CaMeL Bug CaMeL Editor CaMeL Input ) ei ;  <CTX>  public boolean is CaMeL Shown CaMeL In CaMeL Editor ( Match match , I CaMeL Editor CaMeL Part editor ) { if ( result == null ) return false ; I CaMeL Editor CaMeL Input ei = editor . get CaMeL Editor CaMeL Input ( ) ; if ( ei instanceof Existing CaMeL Bug CaMeL Editor CaMeL Input ) { Existing CaMeL Bug CaMeL Editor CaMeL Input bi = ( Existing CaMeL Bug CaMeL Editor CaMeL Input ) ei ; return match . get CaMeL Element ( ) . equals ( bi . get CaMeL Repository CaMeL Task CaMeL Data ( ) ) ; } return false ; }	Abstract CaMeL Bug CaMeL Editor CaMeL Input bi = ( Abstract CaMeL Bug CaMeL Editor CaMeL Input ) ei ;
Ruby CaMeL Fixnum . new CaMeL Fixnum ( get CaMeL Runtime ( ) , c ) ;  <CTX>  public I CaMeL Ruby CaMeL Object getc ( ) { check CaMeL Readable ( ) ; int c = handler . getc ( ) ; return c == - 1 ? get CaMeL Runtime ( ) . get CaMeL Nil ( ) : / / EOF Ruby CaMeL Fixnum . new CaMeL Fixnum ( get CaMeL Runtime ( ) , c ) ; }	get CaMeL Runtime ( ) . new CaMeL Fixnum ( c ) ;
} else { return Sort CaMeL Order . ASCENDING ; }  <CTX>  public Sort CaMeL Order flip ( ) { if ( this == Sort CaMeL Order . ASCENDING ) { return Sort CaMeL Order . DESCENDING ; } else { return Sort CaMeL Order . ASCENDING ; } }	return Sort CaMeL Order . ASCENDING ;
return check CaMeL Version ( new Buffered CaMeL Input CaMeL Stream ( new File CaMeL Input CaMeL Stream ( file CaMeL Name ) ) ) ;  <CTX>  public static int check CaMeL Version ( String file CaMeL Name ) throws Design CaMeL File CaMeL Exception , File CaMeL Not CaMeL Found CaMeL Exception { return check CaMeL Version ( new Buffered CaMeL Input CaMeL Stream ( new File CaMeL Input CaMeL Stream ( file CaMeL Name ) ) ) ; }	List rtn CaMeL List = new Array CaMeL List ( ) ; Version CaMeL Parser CaMeL Handler handler = new Version CaMeL Parser CaMeL Handler ( ) ; Input CaMeL Stream input CaMeL Stream CaMeL To CaMeL Parse = stream CaMeL Data ; if ( ! input CaMeL Stream CaMeL To CaMeL Parse . mark CaMeL Supported ( ) ) input CaMeL Stream CaMeL To CaMeL Parse = new Buffered CaMeL Input CaMeL Stream ( stream CaMeL Data ) ; parse ( handler , input CaMeL Stream CaMeL To CaMeL Parse ) ; if ( String CaMeL Util . compare CaMeL Version ( handler . version , Version CaMeL Info . COLUMN _ BINDING _ FROM _ VERSION ) < 1 && String CaMeL Util . compare CaMeL Version ( Design CaMeL Schema CaMeL Constants . REPORT _ VERSION , Version CaMeL Info . COLUMN _ BINDING _ FROM _ VERSION ) > 0 ) rtn CaMeL List . add ( new Version CaMeL Info ( handler . version , Version CaMeL Info . CONVERT _ FOR _ COLUMN _ BINDING ) ) ; return rtn CaMeL List ;
return ( Private CaMeL Data ) private CaMeL Data CaMeL Providers . get ( key ) ;  <CTX>  public static Private CaMeL Data get CaMeL Private CaMeL Data CaMeL Provider ( String element CaMeL Name , String namespace ) { String key = get CaMeL Provider CaMeL Key ( element CaMeL Name , namespace ) ; return ( Private CaMeL Data ) private CaMeL Data CaMeL Providers . get ( key ) ; }	return ( Private CaMeL Data CaMeL Provider ) private CaMeL Data CaMeL Providers . get ( key ) ;
if ( descending CaMeL Buttons [ index ] . get CaMeL Selection ( ) ) old CaMeL Selection CaMeL Direction = Table CaMeL Sorter . DESCENDING ;  <CTX>  public void widget CaMeL Selected ( Selection CaMeL Event e ) { int old CaMeL Selection CaMeL Direction = Table CaMeL Sorter . ASCENDING ; if ( descending CaMeL Buttons [ index ] . get CaMeL Selection ( ) ) old CaMeL Selection CaMeL Direction = Table CaMeL Sorter . DESCENDING ; Array CaMeL List old CaMeL Selection CaMeL List = new Array CaMeL List ( Arrays . as CaMeL List ( priority CaMeL Combos [ index ] . get CaMeL Items ( ) ) ) ; old CaMeL Selection CaMeL List . remove CaMeL All ( Arrays . as CaMeL List ( priority CaMeL Combos [ index + 1 ] . get CaMeL Items ( ) ) ) ; if ( old CaMeL Selection CaMeL List . size ( ) != 1 ) return ; String old CaMeL Selection = ( String ) old CaMeL Selection CaMeL List . get ( 0 ) ; String new CaMeL Selection = priority CaMeL Combos [ index ] . get CaMeL Item ( priority CaMeL Combos [ index ] . get CaMeL Selection CaMeL Index ( ) ) ; if ( old CaMeL Selection . equals ( new CaMeL Selection ) ) { return ; } for ( int j = index + 1 ; j < priority CaMeL Combos . length ; j ++ ) { int new CaMeL Selection CaMeL Index = priority CaMeL Combos [ j ] . index CaMeL Of ( new CaMeL Selection ) ; / / this combo s current selection is equal to new CaMeL Selection if ( priority CaMeL Combos [ j ] . get CaMeL Selection CaMeL Index ( ) == new CaMeL Selection CaMeL Index ) { priority CaMeL Combos [ j ] . remove ( new CaMeL Selection ) ; int insertion CaMeL Point = - 1 - Arrays . binary CaMeL Search ( priority CaMeL Combos [ j ] . get CaMeL Items ( ) , old CaMeL Selection , column CaMeL Comparator ) ; if ( insertion CaMeL Point >= 0 && insertion CaMeL Point <= priority CaMeL Combos [ j ] . get CaMeL Item CaMeL Count ( ) ) priority CaMeL Combos [ j ] . add ( old CaMeL Selection , insertion CaMeL Point ) ; else priority CaMeL Combos [ j ] . add ( old CaMeL Selection ) ; priority CaMeL Combos [ j ] . select ( priority CaMeL Combos [ j ] . index CaMeL Of ( old CaMeL Selection ) ) ; ascending CaMeL Buttons [ index ] . set CaMeL Selection ( ascending CaMeL Buttons [ j ] . get CaMeL Selection ( ) ) ; descending CaMeL Buttons [ index ] . set CaMeL Selection ( descending CaMeL Buttons [ j ] . get CaMeL Selection ( ) ) ; ascending CaMeL Buttons [ j ] . set CaMeL Selection ( old CaMeL Selection CaMeL Direction == Table CaMeL Sorter . ASCENDING ) ; descending CaMeL Buttons [ j ] . set CaMeL Selection ( old CaMeL Selection CaMeL Direction == Table CaMeL Sorter . DESCENDING ) ; } / / this combo contains new CaMeL Selection else if ( new CaMeL Selection CaMeL Index >= 0 ) { priority CaMeL Combos [ j ] . remove ( new CaMeL Selection ) ; int insertion CaMeL Point = - 1 - Arrays . binary CaMeL Search ( priority CaMeL Combos [ j ] . get CaMeL Items ( ) , old CaMeL Selection , column CaMeL Comparator ) ; if ( insertion CaMeL Point >= 0 && insertion CaMeL Point <= priority CaMeL Combos [ j ] . get CaMeL Item CaMeL Count ( ) ) priority CaMeL Combos [ j ] . add ( old CaMeL Selection , insertion CaMeL Point ) ; else priority CaMeL Combos [ j ] . add ( old CaMeL Selection ) ; } } mark CaMeL Dirty ( ) ; }	if ( descending CaMeL Buttons [ index ] . get CaMeL Selection ( ) ) { old CaMeL Selection CaMeL Direction = Table CaMeL Sorter . DESCENDING ; }
if ( DATE _ ORDER == ASCENDING ) { DATE _ ORDER = DESCENDING ; } else { DATE _ ORDER = ASCENDING ; }  <CTX>  public void widget CaMeL Selected ( Selection CaMeL Event e ) { if ( DATE _ ORDER == ASCENDING ) { DATE _ ORDER = DESCENDING ; } else { DATE _ ORDER = ASCENDING ; } Viewer CaMeL Sorter sorter = get CaMeL Viewer CaMeL Sorter ( DATE ) ; f CaMeL Tree CaMeL Viewer . set CaMeL Sorter ( sorter ) ; collator = sorter . get CaMeL Collator ( ) ; set CaMeL Comparator ( DATE ) ; ( ( Event CaMeL Details CaMeL Dialog CaMeL Action ) f CaMeL Properties CaMeL Action ) . set CaMeL Comparator ( comparator ) ; f CaMeL Memento . put CaMeL Integer ( P _ ORDER _ VALUE , DATE _ ORDER ) ; f CaMeL Memento . put CaMeL Integer ( P _ ORDER _ TYPE , DATE ) ; }	DATE _ ORDER *= - 1 ;
Instruction CaMeL Iterator dup = new Instruction CaMeL Iterator ( ) ; dup . index = this . index ; return dup ; }  <CTX>  public Instruction CaMeL Iterator duplicate ( ) { Instruction CaMeL Iterator dup = new Instruction CaMeL Iterator ( ) ; dup . index = this . index ; return dup ; }	return new Instruction CaMeL Iterator ( next , last ) ; }
_ model . set CaMeL Active CaMeL Next CaMeL Document ( ) ;  <CTX>  public void action CaMeL Performed ( Action CaMeL Event ae ) { _ model . set CaMeL Active CaMeL Next CaMeL Document ( ) ; }	if ( _ help CaMeL Frame == null ) { _ help CaMeL Frame = new Help CaMeL Frame ( ) ; } _ help CaMeL Frame . set CaMeL Visible ( true ) ;
d@@ ag . add CaMeL Edge ( id , extension CaMeL Id ) ;  <CTX>  private void add CaMeL Edge CaMeL With CaMeL Parent CaMeL Check ( Map project CaMeL Map , String extension CaMeL Id , Maven CaMeL Project project , String id ) throws Cycle CaMeL Detected CaMeL Exception { Maven CaMeL Project ext CaMeL Project = ( Maven CaMeL Project ) project CaMeL Map . get ( extension CaMeL Id ) ; project . add CaMeL Project CaMeL Reference ( ext CaMeL Project ) ; Maven CaMeL Project ext CaMeL Parent = ext CaMeL Project . get CaMeL Parent ( ) ; if ( ext CaMeL Parent != null ) { String parent CaMeL Id = Artifact CaMeL Utils . version@@ less CaMeL Key ( ext CaMeL Parent . get CaMeL Group CaMeL Id ( ) , ext CaMeL Parent . get CaMeL Artifact CaMeL Id ( ) ) ; / / D@@ on t add edge from parent to extension if a reverse edge already exists if ( ! d@@ ag . has CaMeL Edge ( extension CaMeL Id , id ) || ! parent CaMeL Id . equals ( id ) ) { d@@ ag . add CaMeL Edge ( id , extension CaMeL Id ) ; } } }	d@@ ag . add CaMeL Edge ( id , project CaMeL Ref CaMeL Id ) ;
Platform . get CaMeL Job CaMeL Manager ( ) . cancel ( parent ) ;  <CTX>  public void cancel ( Object parent ) { Platform . get CaMeL Job CaMeL Manager ( ) . cancel ( parent ) ; }	Platform . get CaMeL Job CaMeL Manager ( ) . cancel ( new Deferred CaMeL Content CaMeL Family ( this , parent ) ) ;
if ( ast != null && ast . get CaMeL Type ( ) == Token CaMeL Types . METHOD _ CALL ) { a CaMeL Parent = create CaMeL Method CaMeL Call CaMeL Handler ( a CaMeL Indent CaMeL Check , ast , a CaMeL Parent ) ;  <CTX>  Expression CaMeL Handler create CaMeL Method CaMeL Call CaMeL Handler ( Indentation CaMeL Check a CaMeL Indent CaMeL Check , Detail CaMeL AST a CaMeL Ast , Expression CaMeL Handler a CaMeL Parent ) { Expression CaMeL Handler handler = ( Expression CaMeL Handler ) m CaMeL Created CaMeL Handlers . get ( a CaMeL Ast ) ; if ( handler != null ) { return handler ; } Detail CaMeL AST ast = ( Detail CaMeL AST ) a CaMeL Ast . get CaMeL First CaMeL Child ( ) ; while ( ast != null && ast . get CaMeL Type ( ) == Token CaMeL Types . DOT ) { ast = ( Detail CaMeL AST ) ast . get CaMeL First CaMeL Child ( ) ; } if ( ast != null && ast . get CaMeL Type ( ) == Token CaMeL Types . METHOD _ CALL ) { a CaMeL Parent = create CaMeL Method CaMeL Call CaMeL Handler ( a CaMeL Indent CaMeL Check , ast , a CaMeL Parent ) ; m CaMeL Created CaMeL Handlers . put ( ast , a CaMeL Parent ) ; } return new Method CaMeL Call CaMeL Handler ( a CaMeL Indent CaMeL Check , a CaMeL Ast , a CaMeL Parent ) ; }	if ( ast != null && is CaMeL Handled CaMeL Type ( ast . get CaMeL Type ( ) ) ) { a CaMeL Parent = get CaMeL Handler ( a CaMeL Indent CaMeL Check , ast , a CaMeL Parent ) ;
String local CaMeL Repository CaMeL Path ( Artifact artifact , Artifact CaMeL Repository local CaMeL Repository ) ;  <CTX>  String local CaMeL Repository CaMeL Path ( Artifact artifact , Artifact CaMeL Repository local CaMeL Repository ) ;	String local CaMeL Repository CaMeL Path ( Artifact artifact , Artifact CaMeL Repository local CaMeL Repository ) throws Artifact CaMeL Handler CaMeL Not CaMeL Found CaMeL Exception ;
_ log CaMeL Factory = log CaMeL Factory ;  <CTX>  public static void set CaMeL Log CaMeL Factory ( Log CaMeL Factory log CaMeL Factory ) { _ log CaMeL Factory = log CaMeL Factory ; }	_ log CaMeL Factory . set CaMeL Log CaMeL Factory ( log CaMeL Factory ) ;
return get CaMeL Namespace ( package CaMeL Decl . get CaMeL Qualified CaMeL Name ( ) ) ;  <CTX>  protected String get CaMeL Namespace ( Package CaMeL Declaration package CaMeL Decl ) { return get CaMeL Namespace ( package CaMeL Decl . get CaMeL Qualified CaMeL Name ( ) ) ; }	return Runtime CaMeL Modeler . get CaMeL Namespace ( package CaMeL Decl . get CaMeL Qualified CaMeL Name ( ) ) ;
return CaMeL Expr = expr ;  <CTX>  public void set CaMeL Return CaMeL Expression ( Expression expr ) { return CaMeL Expr = expr ; }	this . return CaMeL Expr = expr ;
throw CaMeL SQL CaMeL Exception ( e ) ; throw e ;  <CTX>  public void set CaMeL Max CaMeL Field CaMeL Size ( int max ) throws SQL CaMeL Exception { try { m _ stmt . set CaMeL Max CaMeL Field CaMeL Size ( max ) ; } catch ( SQL CaMeL Exception e ) { throw CaMeL SQL CaMeL Exception ( e ) ; throw e ; / / code should never get here , but just in case } }	throw m _ conn . wrap ( e ) ;
source . remove CaMeL Consumer ( this ) ;  <CTX>  image CaMeL Complete ( int status ) { if ( status == Image CaMeL Consumer . STATI@@ CI@@ MAGE@@ DONE && is CaMeL Cacheable ) is CaMeL Loaded = true ; if ( status == Image CaMeL Consumer . SINGLE@@ FRAM@@ ED@@ ONE ) is CaMeL Cacheable = false ; source . remove CaMeL Consumer ( this ) ; }	if ( observer != null ) { if ( status == Image CaMeL Consumer . IMAGE@@ ERROR ) observer . image CaMeL Update ( null , Image CaMeL Observer . ERROR , - 1 , - 1 , - 1 , - 1 ) ; else observer . image CaMeL Update ( null , Image CaMeL Observer . ALLBITS , - 1 , - 1 , - 1 , - 1 ) ; } if ( source != null ) source . remove CaMeL Consumer ( this ) ;
Object rval = exec CaMeL Sub ( cx , this CaMeL Obj , args , fun CaMeL Obj , true , fun CaMeL Obj ) ;  <CTX>  public static Object test ( Context cx , Scriptable this CaMeL Obj , Object [ ] args , Function fun CaMeL Obj ) { Object rval = exec CaMeL Sub ( cx , this CaMeL Obj , args , fun CaMeL Obj , true , fun CaMeL Obj ) ; if ( rval == null || ! rval . equals ( Boolean . TRUE ) ) rval = Boolean . FALSE ; return rval ; }	Object rval = exec CaMeL Sub ( cx , this CaMeL Obj , args , fun CaMeL Obj , TEST , fun CaMeL Obj ) ;
i CaMeL Visited . accept ( _ Payload ) ;  <CTX>  public void visit CaMeL Yield CaMeL Node ( Yield CaMeL Node i CaMeL Visited ) { i CaMeL Visited . accept ( _ Payload ) ; }	_ Payload . visit CaMeL Yield CaMeL Node ( i CaMeL Visited ) ;
if ( Regexp CaMeL Util . has CaMeL Flag ( options , MATCH _ SINGLELINE ) )  <CTX>  protected int get CaMeL Compiler CaMeL Options ( int options ) { int c CaMeL Options = RE . MATCH _ NORMAL ; if ( Regexp CaMeL Util . has CaMeL Flag ( options , MATCH _ CASE _ INSENSITIVE ) ) c CaMeL Options |= RE . MATCH _ CASE@@ INDEPENDENT ; if ( Regexp CaMeL Util . has CaMeL Flag ( options , MATCH _ MULTILINE ) ) c CaMeL Options |= RE . MATCH _ MULTILINE ; if ( Regexp CaMeL Util . has CaMeL Flag ( options , MATCH _ SINGLELINE ) ) c CaMeL Options |= RE . MATCH _ SINGLELINE ; return c CaMeL Options ; }	} if ( Regexp CaMeL Util . has CaMeL Flag ( options , MATCH _ SINGLELINE ) ) {
write CaMeL Structure CaMeL List ( obj , Design CaMeL Element . PROPERTY _ MASKS _ PROP ) ;  <CTX>  public void visit CaMeL Design CaMeL Element ( Design CaMeL Element obj ) { super . visit CaMeL Design CaMeL Element ( obj ) ; if ( mark CaMeL Line CaMeL Number ) { Module module = get CaMeL Module ( ) ; if ( module != null ) module . add CaMeL Element CaMeL Line CaMeL No ( obj . get CaMeL ID ( ) , writer . get CaMeL Line CaMeL Counter ( ) ) ; } / / The element name , id and extends should be written in the tag . attribute ( obj , Design CaMeL Schema CaMeL Constants . NAME _ ATTRIB , Design CaMeL Element . NAME _ PROP ) ; writer . attribute ( Design CaMeL Schema CaMeL Constants . ID _ ATTRIB , new Long ( obj . get CaMeL ID ( ) ) . to CaMeL String ( ) ) ; attribute ( obj , Design CaMeL Schema CaMeL Constants . EXTENDS _ ATTRIB , Design CaMeL Element . EXTENDS _ PROP ) ; attribute ( obj , Design CaMeL Schema CaMeL Constants . VIEW _ ACTION _ ATTRIB , Design CaMeL Element . VIEW _ ACTION _ PROP ) ; property ( obj , Design CaMeL Element . COMMENTS _ PROP ) ; property CaMeL CDATA ( obj , Design CaMeL Element . CUSTOM _ XML _ PROP ) ; resource CaMeL Key ( obj , Design CaMeL Element . DISPLAY _ NAME _ ID _ PROP , Design CaMeL Element . DISPLAY _ NAME _ PROP ) ; property ( obj , Design CaMeL Element . EVENT _ HANDLER _ CLASS _ PROP ) ; write CaMeL User CaMeL Property CaMeL Defns ( obj ) ; write CaMeL User CaMeL Property CaMeL Values ( obj ) ; write CaMeL Structure CaMeL List ( obj , Design CaMeL Element . PROPERTY _ MASKS _ PROP ) ; }	write CaMeL Structure CaMeL List ( obj , I CaMeL Design CaMeL Element CaMeL Model . PROPERTY _ MASKS _ PROP ) ;
internal CaMeL Bring CaMeL To CaMeL Top ( get CaMeL Reference ( part ) ) ;  <CTX>  public void activate ( I CaMeL Workbench CaMeL Part part ) { / / Sanity check . if ( ! cer@@ tify CaMeL Part ( part ) ) return ; if ( window . is CaMeL Closing ( ) ) return ; / / If zoomed , un@@ zoom . zoom CaMeL Out CaMeL If CaMeL Necessary ( part ) ; if ( part instanceof Multi CaMeL Editor ) { part = ( ( Multi CaMeL Editor ) part ) . get CaMeL Active CaMeL Editor ( ) ; } / / Activate part . / / if ( window . get CaMeL Active CaMeL Page ( ) == this ) { internal CaMeL Bring CaMeL To CaMeL Top ( get CaMeL Reference ( part ) ) ; set CaMeL Active CaMeL Part ( part ) ; }	I CaMeL Workbench CaMeL Part CaMeL Reference ref = get CaMeL Reference ( part ) ; internal CaMeL Bring CaMeL To CaMeL Top ( ref ) ;
( Dom CaMeL Character CaMeL Data ) get CaMeL Html CaMeL Element CaMeL Or CaMeL Die ( ) ;  <CTX>  public void js CaMeL Set _ data ( final String new CaMeL Value ) { final Dom CaMeL Character CaMeL Data dom CaMeL Character CaMeL Data = ( Dom CaMeL Character CaMeL Data ) get CaMeL Html CaMeL Element CaMeL Or CaMeL Die ( ) ; dom CaMeL Character CaMeL Data . set CaMeL Data ( new CaMeL Value ) ; }	( Dom CaMeL Character CaMeL Data ) get CaMeL Dom CaMeL Node CaMeL Or CaMeL Die ( ) ;
return get CaMeL String CaMeL Property ( Simple CaMeL Data CaMeL Set . ON _ FETCH _ METHOD ) ;  <CTX>  public String get CaMeL On CaMeL Fetch ( ) { return get CaMeL String CaMeL Property ( Simple CaMeL Data CaMeL Set . ON _ FETCH _ METHOD ) ; }	return get CaMeL String CaMeL Property ( I CaMeL Simple CaMeL Data CaMeL Set CaMeL Model . ON _ FETCH _ METHOD ) ;
i@@ balance ( bh ) ;  <CTX>  public synchronized Position create CaMeL Position ( int offset ) { Pos CaMeL Bottom CaMeL Half bh ; if ( root == null ) root = bh = new Pos CaMeL Bottom CaMeL Half ( offset ) ; else { bh = root . find ( offset ) ; if ( bh == null ) { bh = new Pos CaMeL Bottom CaMeL Half ( offset ) ; bh . red = true ; root . insert ( bh ) ; i@@ balance ( bh ) ; } else bh . ref ++ ; } if ( Debug . POSITION _ DEBUG ) root . dump ( 0 ) ; return new Pos CaMeL Top CaMeL Half ( bh ) ; } / / } } }	if ( ! Debug . DISABLE _ POSITION _ BALANCE ) i@@ balance ( bh ) ;
log . log ( Level . WARNING , e . get CaMeL Message ( ) , e ) ;  <CTX>  public static void handle CaMeL On CaMeL Prepare ( List CaMeL Group CaMeL Handle group CaMeL Handle , Execution CaMeL Context context ) { try { I CaMeL List CaMeL Group group = new List CaMeL Group ( group CaMeL Handle ) ; if ( handle CaMeL JS ( group , group CaMeL Handle . get CaMeL On CaMeL Prepare ( ) , context ) . did CaMeL Run ( ) ) return ; I CaMeL List CaMeL Group CaMeL Event CaMeL Handler eh = ( I CaMeL List CaMeL Group CaMeL Event CaMeL Handler ) get CaMeL Instance ( group CaMeL Handle ) ; if ( eh != null ) eh . on CaMeL Prepare ( group , context . get CaMeL Report CaMeL Context ( ) ) ; } catch ( Exception e ) { log . log ( Level . WARNING , e . get CaMeL Message ( ) , e ) ; } }	add CaMeL Exception ( context , e ) ;
int index = index CaMeL From CaMeL String ( s ) ; if ( index != NO _ INDEX || ( s . length ( ) == 1 && s . char CaMeL At ( 0 ) == NO _ INDEX _ CHAR ) ) { return null ; }  <CTX>  static String get CaMeL String CaMeL Id ( Object id ) { if ( id instanceof Number ) { double d = ( ( Number ) id ) . double CaMeL Value ( ) ; int index = ( int ) d ; if ( ( ( double ) index ) == d ) return null ; return to CaMeL String ( id ) ; } String s = to CaMeL String ( id ) ; int index = index CaMeL From CaMeL String ( s ) ; if ( index != NO _ INDEX || ( s . length ( ) == 1 && s . char CaMeL At ( 0 ) == NO _ INDEX _ CHAR ) ) { return null ; } return s ; }	long index CaMeL Test = index CaMeL From CaMeL String ( s ) ; if ( index CaMeL Test >= 0 ) return null ;
Double o 0 = get CaMeL Double CaMeL Arg ( evaluator , args , 0 ) , o 1 = get CaMeL Double CaMeL Arg ( evaluator , args , 1 ) ; return to CaMeL Boolean ( o 0 . compare CaMeL To ( o 1 ) <= 0 ) ;  <CTX>  public Object evaluate ( Evaluator evaluator , Exp [ ] args ) { Double o 0 = get CaMeL Double CaMeL Arg ( evaluator , args , 0 ) , o 1 = get CaMeL Double CaMeL Arg ( evaluator , args , 1 ) ; return to CaMeL Boolean ( o 0 . compare CaMeL To ( o 1 ) <= 0 ) ; }	String o 0 = get CaMeL String CaMeL Arg ( evaluator , args , 0 , null ) , o 1 = get CaMeL String CaMeL Arg ( evaluator , args , 1 , null ) ; return to CaMeL Boolean ( ! o 0 . equals ( o 1 ) ) ;
if ( current CaMeL Child . get CaMeL Id ( ) . equals ( id ) ) return current CaMeL Child ;  <CTX>  protected Wizard CaMeL Collection CaMeL Element get CaMeL Child CaMeL With CaMeL ID ( Wizard CaMeL Collection CaMeL Element parent , String id ) { Object [ ] children = parent . get CaMeL Children ( null ) ; for ( int i = 0 ; i < children . length ; ++ i ) { Wizard CaMeL Collection CaMeL Element current CaMeL Child = ( Wizard CaMeL Collection CaMeL Element ) children [ i ] ; if ( current CaMeL Child . get CaMeL Id ( ) . equals ( id ) ) return current CaMeL Child ; } return null ; }	if ( current CaMeL Child . get CaMeL Id ( ) . equals ( id ) ) { return current CaMeL Child ; }
return get CaMeL Slot ( Table CaMeL Row . CONTENT _ SLOT ) ;  <CTX>  public Slot CaMeL Handle get CaMeL Cells ( ) { return get CaMeL Slot ( Table CaMeL Row . CONTENT _ SLOT ) ; }	return get CaMeL Slot ( I CaMeL Table CaMeL Row CaMeL Model . CONTENT _ SLOT ) ;
( ( Workbench CaMeL Window ) window ) . add CaMeL To CaMeL Trim ( this , SWT . LEFT ) ;  <CTX>  private void show CaMeL Perspective CaMeL Bar ( ) { switch ( current CaMeL Location ) { case TOP _ LEFT : top CaMeL Bar . set CaMeL Right ( null ) ; top CaMeL Bar . set CaMeL Bottom ( perspective CaMeL Cool CaMeL Bar CaMeL Wrapper . get CaMeL Control ( ) ) ; break ; case TOP _ RIGHT : top CaMeL Bar . set CaMeL Bottom ( null ) ; top CaMeL Bar . set CaMeL Right ( perspective CaMeL Cool CaMeL Bar CaMeL Wrapper . get CaMeL Control ( ) ) ; top CaMeL Bar . set CaMeL Right CaMeL Width ( DEFAULT _ RIGHT _ X ) ; break ; case LEFT : top CaMeL Bar . set CaMeL Bottom ( null ) ; top CaMeL Bar . set CaMeL Right ( null ) ; Layout CaMeL Util . resize ( top CaMeL Bar ) ; ( ( Workbench CaMeL Window ) window ) . add CaMeL To CaMeL Trim ( this , SWT . LEFT ) ; break ; default : return ; } Layout CaMeL Util . resize ( perspective CaMeL Bar . get CaMeL Control ( ) ) ; }	window . get CaMeL Trim CaMeL Manager ( ) . add CaMeL Trim ( SWT . LEFT , this ) ;
HWND = W@@ GL . Create CaMeL Dummy CaMeL Window ( rectangle . x , rectangle . y , rectangle . width , rectangle . height ) ;  <CTX>  public void run ( ) { / / Create a native window and device context HWND = W@@ GL . Create CaMeL Dummy CaMeL Window ( rectangle . x , rectangle . y , rectangle . width , rectangle . height ) ; H@@ DC = W@@ GL . Get CaMeL DC ( HWND ) ; / / Start the message pump at shutdown W@@ GL . Native CaMeL Event CaMeL Loop ( ) ; }	synchronized ( Windows CaMeL GL CaMeL Context CaMeL Factory . class ) { HWND = W@@ GL . Create CaMeL Dummy CaMeL Window ( rectangle . x , rectangle . y , rectangle . width , rectangle . height ) ; }
void modi@@ fying CaMeL Character CaMeL Data ( Node CaMeL Impl node ) {  <CTX>  void modi@@ fying CaMeL Character CaMeL Data ( Node CaMeL Impl node ) { if ( mutation CaMeL Events ) { save CaMeL Enclosing CaMeL Attr ( node ) ; } }	void modi@@ fying CaMeL Character CaMeL Data ( Node CaMeL Impl node , boolean replace ) {
handle CaMeL Problem ( e . create CaMeL Problem CaMeL ID ( ) , name CaMeL Array ) ;  <CTX>  public IAST CaMeL Typedef CaMeL Declaration create CaMeL Typedef ( IAST CaMeL Scope scope , String name , IAST CaMeL Abstract CaMeL Declaration mapping , int starting CaMeL Offset , int starting CaMeL Line , int name CaMeL Offset , int name CaMeL End CaMeL Offset , int name CaMeL Line , char [ ] fn ) throws AST CaMeL Semantic CaMeL Exception { char [ ] name CaMeL Array = name . to CaMeL Char CaMeL Array ( ) ; I CaMeL Container CaMeL Symbol container CaMeL Symbol = scope CaMeL To CaMeL Symbol ( scope ) ; I CaMeL Symbol type CaMeL Symbol = clone CaMeL Simple CaMeL Type CaMeL Symbol ( name CaMeL Array , mapping , null ) ; if ( type CaMeL Symbol == null ) handle CaMeL Problem ( scope , I CaMeL Problem . SEMAN@@ TICS _ RELATED , name CaMeL Array , name CaMeL Offset , name CaMeL End CaMeL Offset , name CaMeL Line , true ) ; set CaMeL Pointer CaMeL Operators ( type CaMeL Symbol , mapping . get CaMeL Pointer CaMeL Operators ( ) , mapping . get CaMeL Array CaMeL Modifiers ( ) ) ; if ( type CaMeL Symbol . get CaMeL Type ( ) != I CaMeL Type CaMeL Info . t _ type ) { I CaMeL Symbol new CaMeL Symbol = pst . new CaMeL Symbol ( name CaMeL Array , I CaMeL Type CaMeL Info . t _ type ) ; new CaMeL Symbol . get CaMeL Type CaMeL Info ( ) . set CaMeL Bit ( true , I CaMeL Type CaMeL Info . is CaMeL Typedef ) ; new CaMeL Symbol . set CaMeL Type CaMeL Symbol ( type CaMeL Symbol ) ; type CaMeL Symbol = new CaMeL Symbol ; } else { type CaMeL Symbol . get CaMeL Type CaMeL Info ( ) . set CaMeL Bit ( true , I CaMeL Type CaMeL Info . is CaMeL Typedef ) ; } List references = new Array CaMeL List ( ) ; if ( mapping . get CaMeL Type CaMeL Specifier ( ) instanceof AST CaMeL Simple CaMeL Type CaMeL Specifier ) { List mapping CaMeL References = ( ( AST CaMeL Simple CaMeL Type CaMeL Specifier ) mapping . get CaMeL Type CaMeL Specifier ( ) ) . get CaMeL References ( ) ; if ( mapping CaMeL References != null && ! mapping CaMeL References . is CaMeL Empty ( ) ) { for ( int i = 0 ; i < mapping CaMeL References . size ( ) ; ++ i ) { IAST CaMeL Reference r = ( IAST CaMeL Reference ) mapping CaMeL References . get ( i ) ; references . add ( cache . get CaMeL Reference ( r . get CaMeL Offset ( ) , r . get CaMeL Referenced CaMeL Element ( ) ) ) ; } } } try { container CaMeL Symbol . add CaMeL Symbol ( type CaMeL Symbol ) ; } catch ( Parser CaMeL Symbol CaMeL Table CaMeL Exception e ) { handle CaMeL Problem ( e . create CaMeL Problem CaMeL ID ( ) , name CaMeL Array ) ; } AST CaMeL Typedef d = new AST CaMeL Typedef ( type CaMeL Symbol , mapping , starting CaMeL Offset , starting CaMeL Line , name CaMeL Offset , name CaMeL End CaMeL Offset , name CaMeL Line , references , filename ) ; attach CaMeL Symbol CaMeL Extension ( type CaMeL Symbol , d , true ) ; return d ; }	handle CaMeL Problem ( e . create CaMeL Problem CaMeL ID ( ) , name ) ;
add ( my CaMeL Label , my CaMeL Label CaMeL Constra@@ ins ) ;  <CTX>  private void insert CaMeL Label ( ) { remove ( my CaMeL Label ) ; add ( my CaMeL Label , my CaMeL Label CaMeL Constra@@ ins ) ; }	add ( my CaMeL Label , my CaMeL Label CaMeL Constraints ) ;
Ref CaMeL Count CaMeL Holder ref CaMeL Count CaMeL Holder ) {  <CTX>  public static Highlight CaMeL Info check CaMeL Class CaMeL Does CaMeL Not CaMeL Call CaMeL Super CaMeL Constructor CaMeL Or CaMeL Handle CaMeL Exceptions ( Psi CaMeL Class a CaMeL Class , Ref CaMeL Count CaMeL Holder ref CaMeL Count CaMeL Holder ) { if ( a CaMeL Class . is CaMeL Enum ( ) ) return null ; / / check only no - ctr classes . Problem with specific constructor will be highlighted inside it if ( a CaMeL Class . get CaMeL Constructors ( ) . length != 0 ) return null ; / / find no - args base class ctr Text CaMeL Range text CaMeL Range = Class CaMeL Util . get CaMeL Class CaMeL Declaration CaMeL Text CaMeL Range ( a CaMeL Class ) ; return check CaMeL Base CaMeL Class CaMeL Default CaMeL Constructor CaMeL Problem ( a CaMeL Class , ref CaMeL Count CaMeL Holder , text CaMeL Range , Psi CaMeL Class CaMeL Type . EMPTY _ ARRAY ) ; }	Ref CaMeL Count CaMeL Holder ref CaMeL Count CaMeL Holder , final Psi CaMeL Resolve CaMeL Helper resolve CaMeL Helper ) {
Border CaMeL UI CaMeL Resource . Line CaMeL Border CaMeL UI CaMeL Resource line CaMeL Border = new Border CaMeL UI CaMeL Resource . Line CaMeL Border CaMeL UI CaMeL Resource ( Color . LIGHT _ GRAY , 1 ) ;  <CTX>  public static Border get CaMeL Internal CaMeL Frame CaMeL Border ( ) { Bevel CaMeL Border bevel CaMeL Border = new Bevel CaMeL Border ( 0 , highlight , light CaMeL Highlight , dark CaMeL Shadow , shadow ) ; Border CaMeL UI CaMeL Resource . Line CaMeL Border CaMeL UI CaMeL Resource line CaMeL Border = new Border CaMeL UI CaMeL Resource . Line CaMeL Border CaMeL UI CaMeL Resource ( Color . LIGHT _ GRAY , 1 ) ; return new Border CaMeL UI CaMeL Resource . Compound CaMeL Border CaMeL UI CaMeL Resource ( bevel CaMeL Border , line CaMeL Border ) ; }	Border CaMeL UI CaMeL Resource . Line CaMeL Border CaMeL UI CaMeL Resource line CaMeL Border = new Border CaMeL UI CaMeL Resource . Line CaMeL Border CaMeL UI CaMeL Resource ( border CaMeL Color , 1 ) ;
return my CaMeL Can CaMeL Process CaMeL Jsp ;  <CTX>  public boolean process CaMeL Jsp ( ) { return my CaMeL Can CaMeL Process CaMeL Jsp ; }	return true ;
try { Byte CaMeL Array CaMeL Output CaMeL Stream byte CaMeL Array CaMeL Output CaMeL Stream = new Byte CaMeL Array CaMeL Output CaMeL Stream ( ) ; Object CaMeL Output CaMeL Stream object CaMeL Output CaMeL Stream = new Object CaMeL Output CaMeL Stream ( byte CaMeL Array CaMeL Output CaMeL Stream ) ; object CaMeL Output CaMeL Stream . write CaMeL Object ( effective CaMeL Arguments ) ; object CaMeL Output CaMeL Stream . flush ( ) ; object CaMeL Output CaMeL Stream . close ( ) ; byte CaMeL Array CaMeL Output CaMeL Stream . close ( ) ; serialized CaMeL Effective CaMeL Arguments = byte CaMeL Array CaMeL Output CaMeL Stream . to CaMeL Byte CaMeL Array ( ) ;  <CTX>  public void transform CaMeL Effective CaMeL Arguments CaMeL Into CaMeL Byte CaMeL Array ( ) { try { Byte CaMeL Array CaMeL Output CaMeL Stream byte CaMeL Array CaMeL Output CaMeL Stream = new Byte CaMeL Array CaMeL Output CaMeL Stream ( ) ; Object CaMeL Output CaMeL Stream object CaMeL Output CaMeL Stream = new Object CaMeL Output CaMeL Stream ( byte CaMeL Array CaMeL Output CaMeL Stream ) ; object CaMeL Output CaMeL Stream . write CaMeL Object ( effective CaMeL Arguments ) ; object CaMeL Output CaMeL Stream . flush ( ) ; object CaMeL Output CaMeL Stream . close ( ) ; byte CaMeL Array CaMeL Output CaMeL Stream . close ( ) ; serialized CaMeL Effective CaMeL Arguments = byte CaMeL Array CaMeL Output CaMeL Stream . to CaMeL Byte CaMeL Array ( ) ; } catch ( Exception e ) { e . print CaMeL Stack CaMeL Trace ( ) ; } effective CaMeL Arguments = null ; }	if ( ( serialized CaMeL Effective CaMeL Arguments == null ) && ( effective CaMeL Arguments != null ) ) { try { Byte CaMeL Array CaMeL Output CaMeL Stream byte CaMeL Array CaMeL Output CaMeL Stream = new Byte CaMeL Array CaMeL Output CaMeL Stream ( ) ; Object CaMeL Output CaMeL Stream object CaMeL Output CaMeL Stream = new Object CaMeL Output CaMeL Stream ( byte CaMeL Array CaMeL Output CaMeL Stream ) ; object CaMeL Output CaMeL Stream . write CaMeL Object ( effective CaMeL Arguments ) ; object CaMeL Output CaMeL Stream . flush ( ) ; object CaMeL Output CaMeL Stream . close ( ) ; byte CaMeL Array CaMeL Output CaMeL Stream . close ( ) ; serialized CaMeL Effective CaMeL Arguments = byte CaMeL Array CaMeL Output CaMeL Stream . to CaMeL Byte CaMeL Array ( ) ; } catch ( Exception e ) { e . print CaMeL Stack CaMeL Trace ( ) ; } effective CaMeL Arguments = null ;
if ( ! Editor CaMeL Manager . save CaMeL All ( intersect , true , get CaMeL Workbench CaMeL Window ( ) ) ) return false ;  <CTX>  public boolean close CaMeL Editors ( I CaMeL Editor CaMeL Reference [ ] editor CaMeL Refs , boolean save ) { if ( editor CaMeL Refs . length == 0 ) { return true ; } if ( save ) { / / Intersect the dirty editors with the editors that are closing I CaMeL Editor CaMeL Part [ ] dirty = get CaMeL Dirty CaMeL Editors ( ) ; List intersect = new Array CaMeL List ( ) ; for ( int i = 0 ; i < editor CaMeL Refs . length ; i ++ ) { I CaMeL Editor CaMeL Reference reference = editor CaMeL Refs [ i ] ; I CaMeL Editor CaMeL Part ref CaMeL Part = reference . get CaMeL Editor ( false ) ; if ( ref CaMeL Part != null ) { for ( int j = 0 ; j < dirty . length ; j ++ ) { if ( ref CaMeL Part . equals ( dirty [ j ] ) && ref CaMeL Part . is CaMeL Save CaMeL On CaMeL Close CaMeL Needed ( ) ) { intersect . add ( ref CaMeL Part ) ; break ; } } } } / / Save parts , exit the method if cancel is pressed . if ( intersect . size ( ) > 0 ) { if ( ! Editor CaMeL Manager . save CaMeL All ( intersect , true , get CaMeL Workbench CaMeL Window ( ) ) ) return false ; } } / / If the user has not cancelled a possible save request / / and if part is added or removed always un@@ zoom . if ( is CaMeL Zoomed ( ) ) zoom CaMeL Out ( ) ; / / Deactivate part if the active part is being closed . boolean deactivated = false ; for ( int i = 0 ; i < editor CaMeL Refs . length ; i ++ ) { I CaMeL Workbench CaMeL Part part = editor CaMeL Refs [ i ] . get CaMeL Part ( false ) ; if ( part == active CaMeL Part ) { deactivated = true ; set CaMeL Active CaMeL Part ( null ) ; } if ( last CaMeL Active CaMeL Editor == part ) { last CaMeL Active CaMeL Editor = null ; action CaMeL Switcher . update CaMeL Top CaMeL Editor ( null ) ; } } editor CaMeL Presentation . get CaMeL Layout CaMeL Part ( ) . defer CaMeL Updates ( true ) ; try { / / Close all editors . for ( int i = 0 ; i < editor CaMeL Refs . length ; i ++ ) { I CaMeL Editor CaMeL Reference ref = editor CaMeL Refs [ i ] ; / / Notify interested listeners before the close window . fire CaMeL Perspective CaMeL Changed ( this , get CaMeL Perspective ( ) , ref , CHANGE _ EDITOR _ CLOSE ) ; / / Close the editor . get CaMeL Editor CaMeL Manager ( ) . close CaMeL Editor ( ref ) ; activation CaMeL List . remove ( ref ) ; fire CaMeL Part CaMeL Closed ( ref ) ; dispose CaMeL Part ( ref ) ; } if ( ! window . is CaMeL Closing ( ) && deactivated ) { activate ( activation CaMeL List . get CaMeL Active ( ) ) ; } } finally { editor CaMeL Presentation . get CaMeL Layout CaMeL Part ( ) . defer CaMeL Updates ( false ) ; } / / Notify interested listeners after the close window . fire CaMeL Perspective CaMeL Changed ( this , get CaMeL Perspective ( ) , CHANGE _ EDITOR _ CLOSE ) ; / / Return true on success . return true ; }	if ( intersect . size ( ) == 1 ) { if ( ! get CaMeL Editor CaMeL Manager ( ) . save CaMeL Editor ( ( I CaMeL Editor CaMeL Part ) ( intersect . get ( 0 ) ) , true ) ) { return false ; } } else { if ( ! Editor CaMeL Manager . save CaMeL All ( intersect , true , get CaMeL Workbench CaMeL Window ( ) ) ) return false ; }
return _ body ;  <CTX>  public String get CaMeL Body ( ) { return _ body ; }	return body ;
synchronized ( data CaMeL Space ) { synchronized ( name CaMeL Space ) { data CaMeL Space . put CaMeL All ( update CaMeL Map ) ; name CaMeL Space . put CaMeL All ( new CaMeL Names ) ; for ( Long id : delete CaMeL Set ) { data CaMeL Space . remove ( id ) ; } }  <CTX>  public void atomic CaMeL Update ( boolean clear , Map < String , Long > new CaMeL Names , Set < Long > delete CaMeL Set , Map < Long , byte [ ] > update CaMeL Map , Set < Long > insert CaMeL Set ) { / / insert set is ignored in this case as its une@@ eded detail synchronized ( data CaMeL Space ) { synchronized ( name CaMeL Space ) { data CaMeL Space . put CaMeL All ( update CaMeL Map ) ; name CaMeL Space . put CaMeL All ( new CaMeL Names ) ; for ( Long id : delete CaMeL Set ) { data CaMeL Space . remove ( id ) ; } } } }	synchronized ( data CaMeL Space ) { data CaMeL Space . put CaMeL All ( update CaMeL Map ) ;
return f CaMeL Text CaMeL Tools . get CaMeL String CaMeL Scanner ( ) ;  <CTX>  protected Rule CaMeL Based CaMeL Scanner get CaMeL String CaMeL Scanner ( ) { return f CaMeL Text CaMeL Tools . get CaMeL String CaMeL Scanner ( ) ; }	return f CaMeL String CaMeL Scanner ;
abstract public void close ( ) throws IO CaMeL Exception ;  <CTX>  abstract public void close ( ) throws IO CaMeL Exception ;	public abstract void close ( ) throws IO CaMeL Exception ;
renamed CaMeL Class , a CaMeL Class ) ) ;  <CTX>  public void add CaMeL Class CaMeL Collisions ( Psi CaMeL Element reference CaMeL Element , String new CaMeL Name , List < Usage CaMeL Info > results ) { final Psi CaMeL Class renamed CaMeL Class = my CaMeL Renamed CaMeL Class ; final Psi CaMeL Resolve CaMeL Helper resolve CaMeL Helper = reference CaMeL Element . get CaMeL Manager ( ) . get CaMeL Resolve CaMeL Helper ( ) ; final Psi CaMeL Search CaMeL Helper search CaMeL Helper = reference CaMeL Element . get CaMeL Manager ( ) . get CaMeL Search CaMeL Helper ( ) ; final Psi CaMeL Class a CaMeL Class = resolve CaMeL Helper . resolve CaMeL Referenced CaMeL Class ( new CaMeL Name , reference CaMeL Element ) ; if ( a CaMeL Class == null ) return ; final Psi CaMeL File containing CaMeL File = reference CaMeL Element . get CaMeL Containing CaMeL File ( ) ; final String text = reference CaMeL Element . get CaMeL Text ( ) ; if ( Comparing . equal ( my CaMeL Renamed CaMeL Class CaMeL Qualified CaMeL Name , remove CaMeL Spaces ( text ) ) ) return ; if ( my CaMeL Processed CaMeL Files . contains ( containing CaMeL File ) ) return ; final Psi CaMeL Reference [ ] references = search CaMeL Helper . find CaMeL References ( a CaMeL Class , new Local CaMeL Search CaMeL Scope ( containing CaMeL File ) , false ) ; for ( Psi CaMeL Reference reference : references ) { final Psi CaMeL Element collision CaMeL Reference CaMeL Element = reference . get CaMeL Element ( ) ; if ( collision CaMeL Reference CaMeL Element instanceof Psi CaMeL Java CaMeL Code CaMeL Reference CaMeL Element ) { final Psi CaMeL Element parent = collision CaMeL Reference CaMeL Element . get CaMeL Parent ( ) ; if ( ! ( parent instanceof Psi CaMeL Import CaMeL Statement ) ) { if ( a CaMeL Class . get CaMeL Qualified CaMeL Name ( ) != null ) { results . add ( new Class CaMeL Hides CaMeL Imported CaMeL Class CaMeL Usage CaMeL Info ( ( Psi CaMeL Java CaMeL Code CaMeL Reference CaMeL Element ) collision CaMeL Reference CaMeL Element , renamed CaMeL Class , a CaMeL Class ) ) ; } else { results . add ( new Class CaMeL Hides CaMeL Un@@ quali@@ fiable CaMeL Class CaMeL Usage CaMeL Info ( ( Psi CaMeL Java CaMeL Code CaMeL Reference CaMeL Element ) collision CaMeL Reference CaMeL Element , renamed CaMeL Class , a CaMeL Class ) ) ; } } else { results . add ( new Colliding CaMeL Class CaMeL Import CaMeL Usage CaMeL Info ( ( Psi CaMeL Import CaMeL Statement ) parent , renamed CaMeL Class ) ) ; } } } my CaMeL Processed CaMeL Files . add ( containing CaMeL File ) ; }	my CaMeL Renamed CaMeL Class , a CaMeL Class ) ) ;
generate CaMeL Output CaMeL DRAM CaMeL Commands ( output , init , pri@@ me@@ pump , filter , items ) ;  <CTX>  private static void output CaMeL DRAM CaMeL Commands ( Output CaMeL Trace CaMeL Node output , boolean init , boolean pri@@ me@@ pump ) { Filter CaMeL Trace CaMeL Node filter = ( Filter CaMeL Trace CaMeL Node ) output . get CaMeL Previous ( ) ; / / don t do anything for a redundant buffer if ( output . one CaMeL Output ( ) && Inter CaMeL Trace CaMeL Buffer . get CaMeL Buffer ( output . get CaMeL Single CaMeL Edge ( ) ) . redundant ( ) ) return ; Filter CaMeL Info filter CaMeL Info = Filter CaMeL Info . get CaMeL Filter CaMeL Info ( filter ) ; / / calculate the number of items sent int items = filter CaMeL Info . total CaMeL Items CaMeL Sent ( init , pri@@ me@@ pump ) ; if ( pri@@ me@@ pump ) items -= filter CaMeL Info . prime CaMeL Pump CaMeL Items CaMeL Not CaMeL Consumed ( ) ; generate CaMeL Output CaMeL DRAM CaMeL Commands ( output , init , pri@@ me@@ pump , filter , items ) ; / / take c@@ are of the pri@@ me@@ pump items not consumed in the pri@@ me@@ pump stage / / place them in the steady buffer . if ( pri@@ me@@ pump ) generate CaMeL Output CaMeL DRAM CaMeL Commands ( output , init , pri@@ me@@ pump , filter , filter CaMeL Info . prime CaMeL Pump CaMeL Items CaMeL Not CaMeL Consumed ( ) ) ; }	generate CaMeL Output CaMeL DRAM CaMeL Commands ( output , init , pri@@ me@@ pump , filter , items , stage ) ;
return INPUT ;  <CTX>  public String input ( ) throws Continu@@ um CaMeL Exception { if ( executor == null ) { if ( project CaMeL Id != 0 ) { executor = get CaMeL Continu@@ um ( ) . get CaMeL Project ( project CaMeL Id ) . get CaMeL Executor CaMeL Id ( ) ; } else { List projects = get CaMeL Continu@@ um ( ) . get CaMeL Project CaMeL Group ( project CaMeL Group CaMeL Id ) . get CaMeL Projects ( ) ; if ( projects . size ( ) > 0 ) { Project project = ( Project ) projects . get ( 0 ) ; executor = project . get CaMeL Executor CaMeL Id ( ) ; } } } if ( build CaMeL Definition CaMeL Id != 0 ) { Build CaMeL Definition build CaMeL Definition = get CaMeL Continu@@ um ( ) . get CaMeL Build CaMeL Definition ( build CaMeL Definition CaMeL Id ) ; goals = build CaMeL Definition . get CaMeL Goals ( ) ; arguments = build CaMeL Definition . get CaMeL Arguments ( ) ; build CaMeL File = build CaMeL Definition . get CaMeL Build CaMeL File ( ) ; build CaMeL Fresh = build CaMeL Definition . is CaMeL Build CaMeL Fresh ( ) ; schedule CaMeL Id = build CaMeL Definition . get CaMeL Schedule ( ) . get CaMeL Id ( ) ; default CaMeL Build CaMeL Definition = build CaMeL Definition . is CaMeL Default CaMeL For CaMeL Project ( ) ; } return INPUT ; }	return SUCCESS ;
Iterator it = bad CaMeL Override CaMeL Map . values ( ) . iterator ( ) ;  <CTX>  public void visit CaMeL After ( Java CaMeL Class obj ) { Iterator it = bad CaMeL Override CaMeL Map . values ( ) . iterator ( ) ; while ( it . has CaMeL Next ( ) ) { Bug CaMeL Instance bi = ( Bug CaMeL Instance ) it . next ( ) ; if ( bi != null ) bug CaMeL Reporter . report CaMeL Bug ( bi ) ; } }	Iterator < Bug CaMeL Instance > it = bad CaMeL Override CaMeL Map . values ( ) . iterator ( ) ;
String result = get CaMeL Value ( ) . to CaMeL Lower CaMeL Case ( ) ; if ( result . equals ( get CaMeL Value ( ) ) ) {  <CTX>  public I CaMeL Ruby CaMeL Object down@@ case _ bang ( ) { String result = get CaMeL Value ( ) . to CaMeL Lower CaMeL Case ( ) ; if ( result . equals ( get CaMeL Value ( ) ) ) { return get CaMeL Runtime ( ) . get CaMeL Nil ( ) ; } set CaMeL Value ( result ) ; return this ; }	String result = to CaMeL String ( ) . to CaMeL Lower CaMeL Case ( ) ; if ( same CaMeL As ( result ) ) {
this . m _ entry CaMeL Lru CaMeL Cache = null ; this . m _ resource CaMeL Map = null ;  <CTX>  protected void finalize ( ) throws Throwable { this . clear ( ) ; this . m _ entry CaMeL Lru CaMeL Cache = null ; this . m _ resource CaMeL Map = null ; super . finalize ( ) ; }	this . m _ variation CaMeL Cache = null ; this . m _ key CaMeL Cache = null ;
if ( ref == get CaMeL Active CaMeL Editor ( ) ) {  <CTX>  private void make CaMeL Active CaMeL Editor ( I CaMeL Editor CaMeL Reference ref ) { if ( ref == get CaMeL Active CaMeL Editor ( ) ) { return ; } I CaMeL Editor CaMeL Part part = ( ref == null ) ? null : ref . get CaMeL Editor ( true ) ; if ( part != null ) { editor CaMeL Mgr . set CaMeL Visible CaMeL Editor ( ref , false ) ; navigation CaMeL History . mark CaMeL Editor ( part ) ; } action CaMeL Switcher . update CaMeL Top CaMeL Editor ( part ) ; if ( ref != null ) { activation CaMeL List . bring CaMeL To CaMeL Top ( ref ) ; } part CaMeL List . set CaMeL Active CaMeL Editor ( ref ) ; }	if ( ref == get CaMeL Active CaMeL Editor CaMeL Reference ( ) ) {
super ( stmt ) ;  <CTX>  Generic CaMeL Storable CaMeL Prepared CaMeL Statement ( Statement stmt ) { super ( stmt ) ; }	super ( ) ;
String model CaMeL Name = EO CaMeL Model CaMeL Group . default CaMeL Group ( ) . entity CaMeL Named ( entity CaMeL Name ) . model ( ) . name ( ) ;  <CTX>  private static synchronized EO CaMeL Database CaMeL Context database CaMeL Context CaMeL For CaMeL Entity CaMeL Named ( String entity CaMeL Name , Object CaMeL Store CaMeL Coordinator osc ) { String model CaMeL Name = EO CaMeL Model CaMeL Group . default CaMeL Group ( ) . entity CaMeL Named ( entity CaMeL Name ) . model ( ) . name ( ) ; Hashtable h = osc . database CaMeL Contexts CaMeL For CaMeL Models ( ) ; EO CaMeL Database CaMeL Context dbc = ( EO CaMeL Database CaMeL Context ) h . get ( model CaMeL Name ) ; return dbc ; }	String model CaMeL Name = EO CaMeL Model CaMeL Group . model CaMeL Group CaMeL For CaMeL Object CaMeL Store CaMeL Coordinator ( osc ) . entity CaMeL Named ( entity CaMeL Name ) . model ( ) . name ( ) ;
Iterator < Integer > iterator = our CaMeL Java CaMeL Key@@ codes CaMeL Map . key CaMeL Set ( ) . iterator ( ) ; while ( iterator . has CaMeL Next ( ) ) { Integer key CaMeL Code = iterator . next ( ) ;  <CTX>  public static List < String > get CaMeL Virtual CaMeL Key@@ codes ( ) { if ( our CaMeL Virtual CaMeL Key@@ codes == null ) { our CaMeL Virtual CaMeL Key@@ codes = new Linked CaMeL List < String > ( ) ; Iterator < Integer > iterator = our CaMeL Java CaMeL Key@@ codes CaMeL Map . key CaMeL Set ( ) . iterator ( ) ; while ( iterator . has CaMeL Next ( ) ) { Integer key CaMeL Code = iterator . next ( ) ; our CaMeL Virtual CaMeL Key@@ codes . add ( our CaMeL Java CaMeL Key@@ codes CaMeL Map . get ( key CaMeL Code ) ) ; } } return our CaMeL Virtual CaMeL Key@@ codes ; }	for ( Integer key CaMeL Code : our CaMeL Java CaMeL Key@@ codes CaMeL Map . key CaMeL Set ( ) ) {
Tree CaMeL Map incomplete CaMeL Reduce CaMeL Tasks = job . get CaMeL Incomplete CaMeL Reduce CaMeL Tasks ( ) ; for ( Iterator it = incomplete CaMeL Reduce CaMeL Tasks . key CaMeL Set ( ) . iterator ( ) ; it . has CaMeL Next ( ) ; ) { String task@@ id = ( String ) it . next ( ) ; reports . add ( generate CaMeL Single CaMeL Report ( task@@ id , job . get CaMeL Task CaMeL Status ( task@@ id ) , job . get CaMeL Task CaMeL Diagnostic CaMeL Info ( task@@ id ) , job . get CaMeL Task CaMeL State CaMeL String ( task@@ id ) ) ) ;  <CTX>  public synchronized Vector [ ] get CaMeL Reduce CaMeL Task CaMeL Report ( String job@@ id ) { Job CaMeL In CaMeL Progress job = ( Job CaMeL In CaMeL Progress ) jobs . get ( job@@ id ) ; if ( job == null ) { return new Vector [ 0 ] ; } else { Vector reports = new Vector ( ) ; Tree CaMeL Map complete CaMeL Reduce CaMeL Tasks = job . get CaMeL Complete CaMeL Reduce CaMeL Tasks ( ) ; for ( Iterator it = complete CaMeL Reduce CaMeL Tasks . key CaMeL Set ( ) . iterator ( ) ; it . has CaMeL Next ( ) ; ) { String task@@ id = ( String ) it . next ( ) ; reports . add ( generate CaMeL Single CaMeL Report ( task@@ id , job . get CaMeL Task CaMeL Status ( task@@ id ) , job . get CaMeL Task CaMeL Diagnostic CaMeL Info ( task@@ id ) , job . get CaMeL Task CaMeL State CaMeL String ( task@@ id ) ) ) ; } Tree CaMeL Map incomplete CaMeL Reduce CaMeL Tasks = job . get CaMeL Incomplete CaMeL Reduce CaMeL Tasks ( ) ; for ( Iterator it = incomplete CaMeL Reduce CaMeL Tasks . key CaMeL Set ( ) . iterator ( ) ; it . has CaMeL Next ( ) ; ) { String task@@ id = ( String ) it . next ( ) ; reports . add ( generate CaMeL Single CaMeL Report ( task@@ id , job . get CaMeL Task CaMeL Status ( task@@ id ) , job . get CaMeL Task CaMeL Diagnostic CaMeL Info ( task@@ id ) , job . get CaMeL Task CaMeL State CaMeL String ( task@@ id ) ) ) ; } return ( Vector [ ] ) reports . to CaMeL Array ( new Vector [ reports . size ( ) ] ) ; } }	Vector incomplete CaMeL Reduce CaMeL Tasks = job . report CaMeL Tasks CaMeL In CaMeL Progress ( false , false ) ; for ( Iterator it = incomplete CaMeL Reduce CaMeL Tasks . iterator ( ) ; it . has CaMeL Next ( ) ; ) { Task CaMeL In CaMeL Progress tip = ( Task CaMeL In CaMeL Progress ) it . next ( ) ; reports . add ( tip . generate CaMeL Single CaMeL Report ( ) ) ;
if ( element instanceof Theme CaMeL Element CaMeL Category ) return 0 ;  <CTX>  public int category ( Object element ) { if ( element instanceof Theme CaMeL Element CaMeL Category ) return 0 ; return 1 ; }	if ( element instanceof Theme CaMeL Element CaMeL Category ) { return 0 ; }
File destination CaMeL Zip CaMeL File = new File ( destination CaMeL Context CaMeL File . get CaMeL Path ( ) + Z@@ IP@@ FILE _ EXTENSION ) ; Proxy proxy CaMeL Settings = Tasks CaMeL Ui CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Proxy CaMeL Settings ( ) ; I CaMeL Attachment CaMeL Handler attachment CaMeL Handler = get CaMeL Attachment CaMeL Handler ( ) ; if ( attachment CaMeL Handler != null ) {  <CTX>  public final void retrieve CaMeL Context ( Task CaMeL Repository repository , Abstract CaMeL Repository CaMeL Task task , Repository CaMeL Attachment attachment ) throws Core CaMeL Exception , IO CaMeL Exception { boolean was CaMeL Active = false ; if ( task . is CaMeL Active ( ) ) { was CaMeL Active = true ; Tasks CaMeL Ui CaMeL Plugin . get CaMeL Task CaMeL List CaMeL Manager ( ) . deactivate CaMeL Task ( task ) ; } File destination CaMeL Context CaMeL File = Context CaMeL Core CaMeL Plugin . get CaMeL Context CaMeL Manager ( ) . get CaMeL File CaMeL For CaMeL Context ( task . get CaMeL Handle CaMeL Identifier ( ) ) ; File destination CaMeL Zip CaMeL File = new File ( destination CaMeL Context CaMeL File . get CaMeL Path ( ) + Z@@ IP@@ FILE _ EXTENSION ) ; Proxy proxy CaMeL Settings = Tasks CaMeL Ui CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Proxy CaMeL Settings ( ) ; I CaMeL Attachment CaMeL Handler attachment CaMeL Handler = get CaMeL Attachment CaMeL Handler ( ) ; if ( attachment CaMeL Handler != null ) { attachment CaMeL Handler . download CaMeL Attachment ( repository , task , attachment , destination CaMeL Zip CaMeL File , proxy CaMeL Settings ) ; Zip CaMeL File CaMeL Util . unzip CaMeL Files ( destination CaMeL Zip CaMeL File , Tasks CaMeL Ui CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Data CaMeL Directory ( ) ) ; if ( destination CaMeL Context CaMeL File . exists ( ) ) { Tasks CaMeL Ui CaMeL Plugin . get CaMeL Task CaMeL List CaMeL Manager ( ) . get CaMeL Task CaMeL List ( ) . notify CaMeL Local CaMeL Info CaMeL Changed ( task ) ; if ( was CaMeL Active ) { Tasks CaMeL Ui CaMeL Plugin . get CaMeL Task CaMeL List CaMeL Manager ( ) . activate CaMeL Task ( task ) ; } } } else { Message CaMeL Dialog . open CaMeL Information ( Platform CaMeL UI . get CaMeL Workbench ( ) . get CaMeL Active CaMeL Workbench CaMeL Window ( ) . get CaMeL Shell ( ) , Tasks CaMeL Ui CaMeL Plugin . TITLE _ DIALOG , MESSAGE _ ATTACHMENTS _ NOT _ SUPPORTED + get CaMeL Label ( ) ) ; } }	Proxy proxy CaMeL Settings = Tasks CaMeL Ui CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Proxy CaMeL Settings ( ) ;
CST CaMeL Node statement = root CaMeL Node ( Token . KEYWORD _ SYNCHRONIZED ) ;  <CTX>  protected CST CaMeL Node synchronized CaMeL Statement ( ) throws Read CaMeL Exception , Syntax CaMeL Exception , Exception CaMeL Collector { CST CaMeL Node statement = root CaMeL Node ( Token . KEYWORD _ SYNCHRONIZED ) ; consume ( Token . LEFT _ PARENTHESIS ) ; statement . add CaMeL Child ( expression ( ) ) ; consume ( Token . RIGHT _ PARENTHESIS ) ; statement . add CaMeL Child ( statement CaMeL Body ( true ) ) ; return statement ; }	consume ( Types . LEFT _ PARENTHESIS ) ; statement . add ( expression ( ) ) ; consume ( Types . RIGHT _ PARENTHESIS ) ;
super ( ) ;  <CTX>  public Bug@@ zilla CaMeL Search CaMeL Page ( ) { super ( ) ; }	super ( TITLE _ BU@@ G@@ ZILLA _ QUERY ) ; set CaMeL Title ( TITLE ) ; set CaMeL Description ( DESCRIPTION ) ; set CaMeL Page CaMeL Complete ( false ) ;
return m _ file . get CaMeL Name ( ) ;  <CTX>  public String get CaMeL Short CaMeL Name ( ) { return m _ file . get CaMeL Name ( ) ; }	return file . get CaMeL Name ( ) ;
if ( goto CaMeL Action != null )  <CTX>  void set CaMeL Action ( I CaMeL Action action ) { if ( action == goto CaMeL Action ) return ; if ( goto CaMeL Action != null ) goto CaMeL Action . remove CaMeL Property CaMeL Change CaMeL Listener ( this ) ; goto CaMeL Action = action ; if ( goto CaMeL Action != null ) goto CaMeL Action . add CaMeL Property CaMeL Change CaMeL Listener ( this ) ; set CaMeL Link CaMeL Enable ( action != null && action . is CaMeL Enabled ( ) ) ; }	if ( goto CaMeL Action != null ) {
( Subscriber ) iterator . next ( ) ;  <CTX>  private void dispatch ( Notification e ) { Iterator iterator = subscribers . iterator ( ) ; boolean absorbed = false ; while ( iterator . has CaMeL Next ( ) && ! absorbed ) { Subscriber this CaMeL Subscriber = ( Subscriber ) iterator . next ( ) ; if ( this CaMeL Subscriber . accepts CaMeL Notification ( e ) ) { absorbed = this CaMeL Subscriber . n . notify ( e ) ; } } }	( Subscriber ) iterator . next CaMeL Element ( ) ;
if ( element instanceof Jsp CaMeL Token && ( ( Jsp CaMeL Token ) element ) . get CaMeL Token CaMeL Type ( ) == Jsp CaMeL Token . JSP _ DIRECTIVE _ WHITE _ SPACE ) continue ;  <CTX>  public static Psi CaMeL Element search CaMeL Non CaMeL Space CaMeL Non CaMeL Comment CaMeL Back ( Psi CaMeL Element element ) { if ( element == null ) return null ; while ( true ) { int offset = element . get CaMeL Text CaMeL Range ( ) . get CaMeL Start CaMeL Offset ( ) - 1 ; if ( offset < 0 ) return null ; element = element . get CaMeL Containing CaMeL File ( ) . find CaMeL Element CaMeL At ( offset ) ; if ( element == null ) return null ; if ( element instanceof Jsp CaMeL Token && ( ( Jsp CaMeL Token ) element ) . get CaMeL Token CaMeL Type ( ) == Jsp CaMeL Token . JSP _ DIRECTIVE _ WHITE _ SPACE ) continue ; if ( ! ( element instanceof Psi CaMeL White CaMeL Space ) && ! ( element instanceof Psi CaMeL Comment ) ) return element ; } }	if ( element instanceof Jsp CaMeL Token && ( ( Jsp CaMeL Token ) element ) . get CaMeL Token CaMeL Type ( ) == Jsp CaMeL Token CaMeL Type . JSP _ DIRECTIVE _ WHITE _ SPACE ) continue ;
return ( ( Long CaMeL Variable CaMeL Context CaMeL Entry ) context ) . left > context . extractor . get CaMeL Long CaMeL Value ( right ) ;  <CTX>  public boolean evaluate CaMeL Cached CaMeL Left ( final Variable CaMeL Context CaMeL Entry context , final Object right ) { return ( ( Long CaMeL Variable CaMeL Context CaMeL Entry ) context ) . left > context . extractor . get CaMeL Long CaMeL Value ( right ) ; }	return ( ( Long CaMeL Variable CaMeL Context CaMeL Entry ) context ) . left > context . get CaMeL Field CaMeL Extractor ( ) . get CaMeL Long CaMeL Value ( right ) ;
boolean held = Thread . current CaMeL Thread ( ) . holds CaMeL Lock ( lock ) ; System . out . println ( held ) ;  <CTX>  public void check ( ) { boolean held = Thread . current CaMeL Thread ( ) . holds CaMeL Lock ( lock ) ; System . out . println ( held ) ; }	Thread this _ thread = Thread . current CaMeL Thread ( ) ; System . out . println ( this _ thread . holds CaMeL Lock ( lock ) ) ;
this . de@@ ffered CaMeL Syntax CaMeL Allowed CaMeL As CaMeL Li@@ t@@ teral = de@@ ffered CaMeL Syntax CaMeL Allowed CaMeL As CaMeL Li@@ t@@ teral ;  <CTX>  public Jsp CaMeL Property ( String is CaMeL Xml , String el CaMeL Ignored , String scripting CaMeL Invalid , String page CaMeL Encoding , Vector include CaMeL Pre@@ lude , Vector include CaMeL Co@@ da , String de@@ ffered CaMeL Syntax CaMeL Allowed CaMeL As CaMeL Li@@ t@@ teral , String trim CaMeL Directive CaMeL Whitespaces ) { this . is CaMeL Xml = is CaMeL Xml ; this . el CaMeL Ignored = el CaMeL Ignored ; this . scripting CaMeL Invalid = scripting CaMeL Invalid ; this . page CaMeL Encoding = page CaMeL Encoding ; this . include CaMeL Pre@@ lude = include CaMeL Pre@@ lude ; this . include CaMeL Co@@ da = include CaMeL Co@@ da ; this . de@@ ffered CaMeL Syntax CaMeL Allowed CaMeL As CaMeL Li@@ t@@ teral = de@@ ffered CaMeL Syntax CaMeL Allowed CaMeL As CaMeL Li@@ t@@ teral ; this . trim CaMeL Directive CaMeL Whitespaces = trim CaMeL Directive CaMeL Whitespaces ; }	this . de@@ fered CaMeL Syntax CaMeL Allowed CaMeL As CaMeL Li@@ t@@ teral = de@@ fered CaMeL Syntax CaMeL Allowed CaMeL As CaMeL Li@@ t@@ teral ;
if ( result != null )  <CTX>  protected String fire CaMeL Binding CaMeL Event ( Binding CaMeL Event event ) { String result = null ; for ( Iterator binding CaMeL Event CaMeL Iter = binding CaMeL Event CaMeL Listeners . iterator ( ) ; binding CaMeL Event CaMeL Iter . has CaMeL Next ( ) ; ) { I CaMeL Binding CaMeL Listener listener = ( I CaMeL Binding CaMeL Listener ) binding CaMeL Event CaMeL Iter . next ( ) ; result = listener . binding CaMeL Event ( event ) ; if ( result != null ) break ; } if ( result == null ) result = context . fire CaMeL Binding CaMeL Event ( event ) ; return result ; }	if ( result != null ) {
location . source CaMeL Start , location . source CaMeL End ) ;  <CTX>  public void abort CaMeL Due CaMeL To CaMeL Internal CaMeL Error ( String error CaMeL Message , AST CaMeL Node location ) { String [ ] arguments = new String [ ] { error CaMeL Message } ; this . handle ( I CaMeL Problem . Unclassified , arguments , arguments , Error | Abort , location . source CaMeL Start , location . source CaMeL End ) ; }	0 , 0 ) ;
klass = ruby . get CaMeL Interpreter ( ) . get CaMeL Ruby _ class ( ) ;  <CTX>  public void push ( NODE v , NODE b , Ruby CaMeL Object new CaMeL Self ) { Ruby CaMeL Block old CaMeL Block = new Ruby CaMeL Block ( var , body , self , frame , scope , klass , iter , v@@ mode , flags , dynamic CaMeL Vars , orig CaMeL Thread , prev , ruby ) ; var = v ; body = b ; self = new CaMeL Self ; frame = ruby . get CaMeL Interpreter ( ) . get CaMeL Ruby CaMeL Frame ( ) ; klass = ruby . get CaMeL Interpreter ( ) . get CaMeL Ruby _ class ( ) ; / / _ block . frame . file = ruby _ sourcefile ; / / _ block . frame . line = ruby _ source@@ line ; scope = ruby . ruby CaMeL Scope ; prev = old CaMeL Block ; iter = ruby . get CaMeL Interpreter ( ) . get CaMeL Ruby CaMeL Iter ( ) . get CaMeL Iter ( ) ; v@@ mode = ruby . get CaMeL Interpreter ( ) . get CaMeL Act CaMeL Method CaMeL Scope ( ) ; flags = BLOCK _ D _ SCOPE ; dynamic CaMeL Vars = ruby . get CaMeL Interpreter ( ) . get CaMeL Dynamic CaMeL Vars ( ) ; }	klass = ruby . get CaMeL Interpreter ( ) . get CaMeL Ruby CaMeL Class ( ) ;
return ( SIP CaMeL Header ) hlist . get CaMeL Last ( ) ;  <CTX>  public SIP CaMeL Header get CaMeL Last ( ) { if ( hlist == null || hlist . is CaMeL Empty ( ) ) return null ; return ( SIP CaMeL Header ) hlist . get CaMeL Last ( ) ; }	return ( SIP CaMeL Header ) hlist . get ( hlist . size ( ) - 1 ) ;
get CaMeL Context ( ) . enqueue CaMeL Method CaMeL Usages CaMeL Processor ( ref CaMeL Method , new Global CaMeL Inspection CaMeL Context CaMeL Impl . Usages CaMeL Processor ( ) {  <CTX>  public boolean query CaMeL External CaMeL Usages CaMeL Requests ( final Inspection CaMeL Manager manager ) { get CaMeL Ref CaMeL Manager ( ) . iterate ( new Ref CaMeL Visitor ( ) { public void visit CaMeL Element ( Ref CaMeL Entity ref CaMeL Entity ) { if ( ref CaMeL Entity instanceof Ref CaMeL Element && get CaMeL Descriptions ( ref CaMeL Entity ) != null ) { ref CaMeL Entity . accept ( new Ref CaMeL Visitor ( ) { public void visit CaMeL Method ( final Ref CaMeL Method ref CaMeL Method ) { get CaMeL Context ( ) . enqueue CaMeL Method CaMeL Usages CaMeL Processor ( ref CaMeL Method , new Global CaMeL Inspection CaMeL Context CaMeL Impl . Usages CaMeL Processor ( ) { public boolean process ( Psi CaMeL Reference psi CaMeL Reference ) { ignore CaMeL Element ( ref CaMeL Method ) ; return false ; } } ) ; } } ) ; } } } ) ; return false ; }	global CaMeL Context . enqueue CaMeL Method CaMeL Usages CaMeL Processor ( ref CaMeL Method , new Global CaMeL Inspection CaMeL Context CaMeL Impl . Usages CaMeL Processor ( ) {
System . out . println ( result ) ;  <CTX>  public void do CaMeL Execute ( Admin CaMeL Commands CaMeL Service CaMeL M CaMeL Bean acs ) throws Exception { String result = acs . list CaMeL Components ( true , false , true , get CaMeL State ( ) , get CaMeL Shared CaMeL Library CaMeL Name ( ) , get CaMeL Service CaMeL Assembly CaMeL Name ( ) ) ; System . out . println ( result ) ; }	log ( result , Project . MSG _ WARN ) ;
Mail CaMeL Item item = get CaMeL Cached CaMeL Item ( new Integer ( data . id ) , data . type ) ;  <CTX>  Mail CaMeL Item get CaMeL Item ( Mail CaMeL Item . Underlying CaMeL Data data ) throws Service CaMeL Exception { if ( data == null ) return null ; Mail CaMeL Item item = get CaMeL Cached CaMeL Item ( new Integer ( data . id ) , data . type ) ; / / XXX : should we sanity - check the cached version to make sure all the data matches ? if ( item != null ) return item ; return Mail CaMeL Item . construct CaMeL Item ( this , data ) ; }	Mail CaMeL Item item = get CaMeL Cached CaMeL Item ( data . id , data . type ) ;
( ( Bar CaMeL Series ) series ) . set CaMeL Riser CaMeL Outline ( ( Color CaMeL Definition ) event . data ) ;  <CTX>  public void handle CaMeL Event ( Event event ) { if ( event . widget . equals ( fcc CaMeL Riser CaMeL Outline ) ) { ( ( Bar CaMeL Series ) series ) . set CaMeL Riser CaMeL Outline ( ( Color CaMeL Definition ) event . data ) ; } }	if ( event . type == Fill CaMeL Chooser CaMeL Composite . FILL _ CHANGED _ EVENT ) { ( ( Bar CaMeL Series ) series ) . set CaMeL Riser CaMeL Outline ( ( Color CaMeL Definition ) event . data ) ; }
node . set CaMeL Next CaMeL Node ( cond 0 ( node . get CaMeL Next CaMeL Node ( ) / * , log@@ op * / ) ) ;  <CTX>  public Node cond ( Node node ) { / / return cond 1 ( node , 0 ) ; if ( node == null ) { return null ; } if ( node . get CaMeL Type ( ) == Constants . NODE _ NEWLINE ) { node . set CaMeL Next CaMeL Node ( cond 0 ( node . get CaMeL Next CaMeL Node ( ) / * , log@@ op * / ) ) ; return node ; } return cond 0 ( node / * , log@@ op * / ) ; }	node . set CaMeL Next CaMeL Node ( cond 0 ( node . get CaMeL Next CaMeL Node ( ) ) ) ;
if ( ! Well CaMeL Formedness CaMeL Utils . is CaMeL Well CaMeL Formed ( binary CaMeL Rhs ) ) {  <CTX>  public void visit CaMeL Assignment CaMeL Expression ( @ Not CaMeL Null Psi CaMeL Assignment CaMeL Expression assignment ) { super . visit CaMeL Assignment CaMeL Expression ( assignment ) ; if ( ! Well CaMeL Formedness CaMeL Utils . is CaMeL Well CaMeL Formed ( assignment ) ) { return ; } final Psi CaMeL Java CaMeL Token sign = assignment . get CaMeL Operation CaMeL Sign ( ) ; final I CaMeL Element CaMeL Type assignment CaMeL Token CaMeL Type = sign . get CaMeL Token CaMeL Type ( ) ; if ( ! assignment CaMeL Token CaMeL Type . equals ( Java CaMeL Token CaMeL Type . EQ ) ) { return ; } final Psi CaMeL Expression lhs = assignment . get CaMeL L CaMeL Expression ( ) ; final Psi CaMeL Expression rhs = assignment . get CaMeL R CaMeL Expression ( ) ; if ( ! ( rhs instanceof Psi CaMeL Binary CaMeL Expression ) ) { return ; } final Psi CaMeL Binary CaMeL Expression binary CaMeL Rhs = ( Psi CaMeL Binary CaMeL Expression ) rhs ; if ( ! Well CaMeL Formedness CaMeL Utils . is CaMeL Well CaMeL Formed ( binary CaMeL Rhs ) ) { return ; } final Psi CaMeL Expression l CaMeL Operand = binary CaMeL Rhs . get CaMeL L CaMeL Operand ( ) ; if ( Side CaMeL Effect CaMeL Checker . may CaMeL Have CaMeL Side CaMeL Effects ( lhs ) ) { return ; } if ( ! Equivalence CaMeL Checker . expressions CaMeL Are CaMeL Equivalent ( lhs , l CaMeL Operand ) ) { return ; } register CaMeL Error ( assignment ) ; }	if ( ! ( binary CaMeL Rhs . get CaMeL R CaMeL Operand ( ) != null ) ) {
if ( su instanceof Main CaMeL Frame ) { prefs CaMeL Index = ( ( Main CaMeL Frame ) su ) . gall@@ eries . get CaMeL Size ( ) ;  <CTX>  public Gallery ( Status CaMeL Update su ) { this . su = su ; if ( su instanceof Main CaMeL Frame ) { prefs CaMeL Index = ( ( Main CaMeL Frame ) su ) . gall@@ eries . get CaMeL Size ( ) ; } }	if ( Gallery CaMeL Remote . get CaMeL Instance ( ) . main CaMeL Frame != null ) { prefs CaMeL Index = Gallery CaMeL Remote . get CaMeL Instance ( ) . main CaMeL Frame . gall@@ eries . get CaMeL Size ( ) ;
existing CaMeL Option . set CaMeL Value ( options CaMeL Info . get CaMeL Value ( ) ) ;  <CTX>  public void read CaMeL Stream ( Message CaMeL Buffer message CaMeL Buffer ) { / * * List of ( String , String ) The list of options with their current value * * / short list CaMeL Elem = message CaMeL Buffer . read CaMeL Int 16 ( ) ; for ( int i = 0 ; i < ( list CaMeL Elem ) ; i ++ ) { Options CaMeL Info options CaMeL Info = new Options CaMeL Info ( this . parent ) ; options CaMeL Info . read CaMeL Stream ( message CaMeL Buffer ) ; / * now we must take c@@ are , we@@ ther the option already exists , so that we don t * overwrite this option * / if ( ! this . info CaMeL Map . contains ( options CaMeL Info . get CaMeL Key ( ) ) ) this . info CaMeL Map . put ( options CaMeL Info . get CaMeL Key ( ) , options CaMeL Info ) ; else { / * get the already existing option and change the values : * / Options CaMeL Info existing CaMeL Option = ( Options CaMeL Info ) this . info CaMeL Map . get ( options CaMeL Info . get CaMeL Key ( ) ) ; existing CaMeL Option . set CaMeL Value ( options CaMeL Info . get CaMeL Value ( ) ) ; } } this . set CaMeL Changed ( ) ; this . notify CaMeL Observers ( this ) ; }	existing CaMeL Option . value = options CaMeL Info . get CaMeL Value ( ) ;
if ( definition . get CaMeL Value ( ) != null ) default CaMeL Color = definition . get CaMeL Value ( ) ; else default CaMeL Color = registry . get CaMeL RGB ( definition . get CaMeL Defaults CaMeL To ( ) ) ;  <CTX>  private static void install CaMeL Color ( Color CaMeL Definition definition , I CaMeL Theme theme , I CaMeL Preference CaMeL Store store , boolean set CaMeL In CaMeL Registry ) { Color CaMeL Registry registry = theme . get CaMeL Color CaMeL Registry ( ) ; String id = definition . get CaMeL Id ( ) ; String key = create CaMeL Preference CaMeL Key ( theme , id ) ; RGB pref CaMeL Color = store != null ? Preference CaMeL Converter . get CaMeL Color ( store , key ) : null ; RGB default CaMeL Color = null ; if ( definition . get CaMeL Value ( ) != null ) default CaMeL Color = definition . get CaMeL Value ( ) ; else default CaMeL Color = registry . get CaMeL RGB ( definition . get CaMeL Defaults CaMeL To ( ) ) ; if ( set CaMeL In CaMeL Registry ) { if ( pref CaMeL Color == null || pref CaMeL Color == Preference CaMeL Converter . COLOR _ DEFAULT _ DEFAULT ) { pref CaMeL Color = default CaMeL Color ; } if ( pref CaMeL Color != null ) { registry . put ( id , pref CaMeL Color ) ; } } if ( default CaMeL Color != null && store != null ) { Preference CaMeL Converter . set CaMeL Default ( store , key , default CaMeL Color ) ; } }	if ( definition . get CaMeL Value ( ) != null ) { default CaMeL Color = definition . get CaMeL Value ( ) ; } else { default CaMeL Color = registry . get CaMeL RGB ( definition . get CaMeL Defaults CaMeL To ( ) ) ; }
return ( Pdf CaMeL Indirect CaMeL Reference ) image CaMeL Dictionary . get ( pdf CaMeL Image . name ( ) ) ;  <CTX>  public Pdf CaMeL Indirect CaMeL Reference add ( Pdf CaMeL Image pdf CaMeL Image ) throws Pdf CaMeL Exception { if ( ! image CaMeL Dictionary . contains ( pdf CaMeL Image ) ) { Pdf CaMeL Indirect CaMeL Object object = body . add ( pdf CaMeL Image ) ; try { object . write CaMeL To ( os ) ; } catch ( IO CaMeL Exception ioe ) { System . err . println ( ioe . get CaMeL Message ( ) ) ; } image CaMeL Dictionary . put ( pdf CaMeL Image . name ( ) , object . get CaMeL Indirect CaMeL Reference ( ) ) ; return object . get CaMeL Indirect CaMeL Reference ( ) ; } return ( Pdf CaMeL Indirect CaMeL Reference ) image CaMeL Dictionary . get ( pdf CaMeL Image . name ( ) ) ; }	Pdf CaMeL Indirect CaMeL Object object = body . add ( contents ) ; try { object . write CaMeL To ( os ) ; os . flush ( ) ; } catch ( IO CaMeL Exception ioe ) { System . err . println ( ioe . get CaMeL Message ( ) ) ; } page . add ( object . get CaMeL Indirect CaMeL Reference ( ) ) ; page . set CaMeL Parent ( ROOT@@ REFERENCE ) ; Pdf CaMeL Indirect CaMeL Object page CaMeL Object = body . add ( page ) ; try { page CaMeL Object . write CaMeL To ( os ) ; os . flush ( ) ; } catch ( IO CaMeL Exception ioe ) { System . err . println ( ioe . get CaMeL Message ( ) ) ; } root . add ( page CaMeL Object . get CaMeL Indirect CaMeL Reference ( ) ) ; return page CaMeL Object . get CaMeL Indirect CaMeL Reference ( ) ;
result = cb [ w ] . get CaMeL Noise CaMeL Reduction ( ) . boolean CaMeL Value ( ) ;  <CTX>  public boolean get CaMeL Channel CaMeL Noise CaMeL Reduction ( int w ) { boolean result ; rwl . read CaMeL Lock ( ) . lock ( ) ; { if ( renderer == null ) throw new Illegal CaMeL State CaMeL Exception ( NULL _ RENDERER ) ; Channel CaMeL Binding [ ] cb = renderer . get CaMeL Channel CaMeL Bindings ( ) ; result = cb [ w ] . get CaMeL Noise CaMeL Reduction ( ) . boolean CaMeL Value ( ) ; } rwl . read CaMeL Lock ( ) . unlock ( ) ; return result ; }	return cb [ w ] . get CaMeL Noise CaMeL Reduction ( ) . boolean CaMeL Value ( ) ; } finally { rwl . read CaMeL Lock ( ) . unlock ( ) ;
if ( set CaMeL Change CaMeL Listeners == null ) { boolean had CaMeL Listeners = has CaMeL Listeners ( ) ; set CaMeL Change CaMeL Listeners = listener ; if ( ! had CaMeL Listeners ) { first CaMeL Listener CaMeL Added ( ) ; } return ; } Collection listener CaMeL List ; if ( set CaMeL Change CaMeL Listeners instanceof Collection ) { listener CaMeL List = ( Collection ) set CaMeL Change CaMeL Listeners ; } else { I CaMeL Set CaMeL Change CaMeL Listener l = ( I CaMeL Set CaMeL Change CaMeL Listener ) set CaMeL Change CaMeL Listeners ; listener CaMeL List = new Array CaMeL List ( ) ; listener CaMeL List . add ( l ) ; set CaMeL Change CaMeL Listeners = listener CaMeL List ; } if ( listener CaMeL List . size ( ) > 16 ) { Hash CaMeL Set listener CaMeL Set = new Hash CaMeL Set ( ) ; listener CaMeL Set . add CaMeL All ( listener CaMeL List ) ; set CaMeL Change CaMeL Listeners = listener CaMeL List ; } listener CaMeL List . add ( listener ) ;  <CTX>  public void add CaMeL Set CaMeL Change CaMeL Listener ( I CaMeL Set CaMeL Change CaMeL Listener listener ) { if ( set CaMeL Change CaMeL Listeners == null ) { boolean had CaMeL Listeners = has CaMeL Listeners ( ) ; set CaMeL Change CaMeL Listeners = listener ; if ( ! had CaMeL Listeners ) { first CaMeL Listener CaMeL Added ( ) ; } return ; } Collection listener CaMeL List ; if ( set CaMeL Change CaMeL Listeners instanceof Collection ) { listener CaMeL List = ( Collection ) set CaMeL Change CaMeL Listeners ; } else { I CaMeL Set CaMeL Change CaMeL Listener l = ( I CaMeL Set CaMeL Change CaMeL Listener ) set CaMeL Change CaMeL Listeners ; listener CaMeL List = new Array CaMeL List ( ) ; listener CaMeL List . add ( l ) ; set CaMeL Change CaMeL Listeners = listener CaMeL List ; } if ( listener CaMeL List . size ( ) > 16 ) { Hash CaMeL Set listener CaMeL Set = new Hash CaMeL Set ( ) ; listener CaMeL Set . add CaMeL All ( listener CaMeL List ) ; set CaMeL Change CaMeL Listeners = listener CaMeL List ; } listener CaMeL List . add ( listener ) ; }	change CaMeL Support . add CaMeL Listener ( Set CaMeL Change CaMeL Event . TYPE , listener ) ;
if ( get CaMeL Style ( ) . is CaMeL Hidden ( ) ) {  <CTX>  public void paint CaMeL Border ( Rendering CaMeL Context c ) { if ( get CaMeL Style ( ) . is CaMeL Hidden ( ) ) { return ; } Rectangle border CaMeL Bounds = get CaMeL Painting CaMeL Border CaMeL Edge ( c ) ; if ( get CaMeL State ( ) != Box . DONE ) { border CaMeL Bounds . height += c . get CaMeL Canvas ( ) . get CaMeL Height ( ) ; } Border CaMeL Painter . paint ( border CaMeL Bounds , get CaMeL Border CaMeL Sides ( ) , get CaMeL Style ( ) . get CaMeL Calculated CaMeL Style ( ) , c . get CaMeL Graphics ( ) , c , 0 ) ; }	if ( ! get CaMeL Style ( ) . is CaMeL Visible ( ) ) {
return Legacy CaMeL Action CaMeL Tools . remove CaMeL Mnemonics ( action . get CaMeL Text ( ) ) + separator + action . get CaMeL Tool CaMeL Tip CaMeL Text ( ) ;  <CTX>  public String get CaMeL Label ( ) { I CaMeL Action action = item . get CaMeL Action ( ) ; if ( action . get CaMeL Tool CaMeL Tip CaMeL Text ( ) != null && action . get CaMeL Tool CaMeL Tip CaMeL Text ( ) . length ( ) != 0 ) { return Legacy CaMeL Action CaMeL Tools . remove CaMeL Mnemonics ( action . get CaMeL Text ( ) ) + separator + action . get CaMeL Tool CaMeL Tip CaMeL Text ( ) ; } return Legacy CaMeL Action CaMeL Tools . remove CaMeL Mnemonics ( action . get CaMeL Text ( ) ) ; }	return Legacy CaMeL Action CaMeL Tools . remove CaMeL Mnemonics ( action . get CaMeL Text ( ) + separator + action . get CaMeL Tool CaMeL Tip CaMeL Text ( ) ) ;
if ( lhs == DBL _ MRK ) {  <CTX>  private static void do _ eq ( Call CaMeL Frame frame , int i , int op ) { boolean result ; Object rhs = frame . stack [ i + 1 ] ; Object lhs = frame . stack [ i ] ; if ( rhs == DBL _ MRK ) { if ( lhs == DBL _ MRK ) { result = ( frame . s CaMeL Dbl [ i ] == frame . s CaMeL Dbl [ i + 1 ] ) ; } else { result = Script CaMeL Runtime . eq CaMeL Number ( frame . s CaMeL Dbl [ i + 1 ] , lhs ) ; } } else { if ( lhs == DBL _ MRK ) { result = Script CaMeL Runtime . eq CaMeL Number ( frame . s CaMeL Dbl [ i ] , rhs ) ; } else { result = Script CaMeL Runtime . eq ( lhs , rhs ) ; } } result ^= ( op == Token . NE ) ; frame . stack [ i ] = Script CaMeL Runtime . wrap CaMeL Boolean ( result ) ; }	if ( lhs == Unique CaMeL Tag . DOUBLE _ MARK ) {
return connection . get CaMeL Warnings ( ) ;  <CTX>  public SQL CaMeL Warning get CaMeL Warnings ( ) throws SQL CaMeL Exception { return connection . get CaMeL Warnings ( ) ; }	return get CaMeL Connection ( ) . get CaMeL Warnings ( ) ;
return float CaMeL To CaMeL Int CaMeL Bits ( value ) == float CaMeL To CaMeL Int CaMeL Bits ( f . float CaMeL Value ( ) ) ;  <CTX>  public boolean equals ( Object obj ) { if ( ! ( obj instanceof Float ) ) return false ; Float f = ( Float ) obj ; return float CaMeL To CaMeL Int CaMeL Bits ( value ) == float CaMeL To CaMeL Int CaMeL Bits ( f . float CaMeL Value ( ) ) ; }	return float CaMeL To CaMeL Int CaMeL Bits ( value ) == float CaMeL To CaMeL Int CaMeL Bits ( f ) ;
rebuild CaMeL State = rebuild ;  <CTX>  public void set CaMeL Rebuild CaMeL State ( boolean rebuild ) { if ( is CaMeL Extension CaMeL Resource CaMeL Configuration ( ) && rebuild ) return ; rebuild CaMeL State = rebuild ; if ( ! rebuild CaMeL State ) { I CaMeL Tool tools [ ] = get CaMeL Tools CaMeL To CaMeL Invoke ( ) ; for ( int i = 0 ; i < tools . length ; i ++ ) { tools [ i ] . set CaMeL Rebuild CaMeL State ( false ) ; } } }	if ( rebuild CaMeL State != rebuild ) { rebuild CaMeL State = rebuild ; save CaMeL Rebuild CaMeL State ( ) ; }
void set CaMeL Selected CaMeL Types ( List selected CaMeL Types ) {  <CTX>  void set CaMeL Selected CaMeL Types ( List selected CaMeL Types ) { this . selected CaMeL Types = selected CaMeL Types ; }	public void set CaMeL Selected CaMeL Types ( List selected CaMeL Types ) {
I CaMeL Preference CaMeL Constants . CURRENT _ THEME _ ID ) . equals ( id ) ) {  <CTX>  public void set CaMeL Current CaMeL Theme ( String id ) { I CaMeL Theme old CaMeL Theme = current CaMeL Theme ; if ( Workbench CaMeL Theme CaMeL Manager . get CaMeL Instance ( ) . do CaMeL Set CaMeL Current CaMeL Theme ( id ) ) { fire CaMeL Property CaMeL Change ( CHANGE _ CURRENT _ THEME , old CaMeL Theme , get CaMeL Current CaMeL Theme ( ) ) ; if ( old CaMeL Theme != null ) old CaMeL Theme . remove CaMeL Property CaMeL Change CaMeL Listener ( current CaMeL Theme CaMeL Listener ) ; current CaMeL Theme . add CaMeL Property CaMeL Change CaMeL Listener ( current CaMeL Theme CaMeL Listener ) ; / / update the preference if required . if ( ! Workbench CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Preference CaMeL Store ( ) . get CaMeL String ( I CaMeL Preference CaMeL Constants . CURRENT _ THEME _ ID ) . equals ( id ) ) { Workbench CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Preference CaMeL Store ( ) . set CaMeL Value ( I CaMeL Preference CaMeL Constants . CURRENT _ THEME _ ID , id ) ; / / $ NON - NLS - 1 $ Workbench CaMeL Plugin . get CaMeL Default ( ) . save CaMeL Plugin CaMeL Preferences ( ) ; } / / update the jface registries { Color CaMeL Registry jface CaMeL Colors = J CaMeL Face CaMeL Resources . get CaMeL Color CaMeL Registry ( ) ; Color CaMeL Registry theme CaMeL Colors = current CaMeL Theme . get CaMeL Color CaMeL Registry ( ) ; for ( Iterator i = theme CaMeL Colors . get CaMeL Key CaMeL Set ( ) . iterator ( ) ; i . has CaMeL Next ( ) ; ) { String key = ( String ) i . next ( ) ; jface CaMeL Colors . put ( key , theme CaMeL Colors . get CaMeL RGB ( key ) ) ; } } { Font CaMeL Registry jface CaMeL Fonts = J CaMeL Face CaMeL Resources . get CaMeL Font CaMeL Registry ( ) ; Font CaMeL Registry theme CaMeL Fonts = current CaMeL Theme . get CaMeL Font CaMeL Registry ( ) ; for ( Iterator i = theme CaMeL Fonts . get CaMeL Key CaMeL Set ( ) . iterator ( ) ; i . has CaMeL Next ( ) ; ) { String key = ( String ) i . next ( ) ; jface CaMeL Fonts . put ( key , theme CaMeL Fonts . get CaMeL Font CaMeL Data ( key ) ) ; } } } }	I CaMeL Workbench CaMeL Preference CaMeL Constants . CURRENT _ THEME _ ID ) . equals ( id ) ) {
save CaMeL All CaMeL Resources ( ) ;  <CTX>  public void run ( ) { / / Save all resources prior to doing build save CaMeL All CaMeL Resources ( ) ; run CaMeL In CaMeL Background ( Resources CaMeL Plugin . get CaMeL Workspace ( ) . get CaMeL Rule CaMeL Factory ( ) . build CaMeL Rule ( ) , Resources CaMeL Plugin . FAMILY _ MANUAL _ BUILD ) ; }	List projects = get CaMeL Projects CaMeL To CaMeL Build ( ) ; if ( projects == null || projects . is CaMeL Empty ( ) ) return ;
return gen@@ otypes [ i ] ;  <CTX>  public byte element CaMeL At ( int i ) { return gen@@ otypes [ i ] ; }	return gen@@ otypes [ real CaMeL Index [ i ] ] ;
Service CaMeL Broker sb = ( ( Agent CaMeL Child CaMeL Binder ) get CaMeL Binding CaMeL Site ( ) ) . get CaMeL Service CaMeL Broker ( ) ;  <CTX>  private Community CaMeL Service load CaMeL Community CaMeL Service ( Message CaMeL Address agent CaMeL Id ) { Service CaMeL Broker sb = ( ( Agent CaMeL Child CaMeL Binder ) get CaMeL Binding CaMeL Site ( ) ) . get CaMeL Service CaMeL Broker ( ) ; Community CaMeL Service CaMeL Provider csp = new Community CaMeL Service CaMeL Provider ( sb , agent CaMeL Id , use CaMeL Cache ) ; sb . add CaMeL Service ( Community CaMeL Service . class , csp ) ; return ( Community CaMeL Service ) sb . get CaMeL Service ( this , Community CaMeL Service . class , new Service CaMeL Revoked CaMeL Listener ( ) { public void service CaMeL Revoked ( Service CaMeL Revoked CaMeL Event re ) { } } ) ; }	Service CaMeL Broker sb = get CaMeL Binding CaMeL Site ( ) . get CaMeL Service CaMeL Broker ( ) ;
log ( ur@@ gency , null , str ) ;  <CTX>  private static Print CaMeL Stream create CaMeL Print CaMeL Stream ( final int ur@@ gency ) { return new Print CaMeL Stream ( new Output CaMeL Stream ( ) { public void write ( int b ) { byte [ ] barray = { ( byte ) b } ; write ( barray , 0 , 1 ) ; } public void write ( byte [ ] b , int off , int len ) { String str = new String ( b , off , len ) ; log ( ur@@ gency , null , str ) ; } } ) ; }	log ( ur@@ gency , source , str ) ;
static private Declaration Resolve CaMeL Ambigu@@ ities ( Lookup CaMeL Data data , Linked CaMeL List items ) throws Parser CaMeL Symbol CaMeL Table CaMeL Exception { Declaration decl = null ;  <CTX>  static private Declaration Resolve CaMeL Ambigu@@ ities ( Lookup CaMeL Data data , Linked CaMeL List items ) throws Parser CaMeL Symbol CaMeL Table CaMeL Exception { Declaration decl = null ; int size = items . size ( ) ; if ( size == 0 ) { return null ; } else if ( size == 1 ) { return ( Declaration ) items . get CaMeL First ( ) ; } else { Declaration first = ( Declaration ) items . remove CaMeL First ( ) ; / / if first one is a class - name , the next ones hide it if ( first . get CaMeL Type ( ) >= Declaration . t _ class && first . get CaMeL Type ( ) <= Declaration . t _ enumeration ) { return Resolve CaMeL Ambigu@@ ities ( data , items ) ; } / / else , if the first is an object ( ie not a function ) , the rest must be the same / / declaration . otherwise ( ie it is a function ) , the rest must be functions . boolean need CaMeL Same = ( first . get CaMeL Type ( ) != Declaration . t _ function ) ; Iterator iter = items . iterator ( ) ; for ( int i = ( size - 1 ) ; i > 0 ; i -- ) { decl = ( Declaration ) iter . next ( ) ; if ( need CaMeL Same ) { if ( decl != first ) { throw new Parser CaMeL Symbol CaMeL Table CaMeL Exception ( Parser CaMeL Symbol CaMeL Table CaMeL Exception . r _ Ambiguous CaMeL Name ) ; } } else { if ( decl . get CaMeL Type ( ) != Declaration . t _ function ) { throw new Parser CaMeL Symbol CaMeL Table CaMeL Exception ( Parser CaMeL Symbol CaMeL Table CaMeL Exception . r _ Ambiguous CaMeL Name ) ; } } } if ( need CaMeL Same ) { return first ; } else { items . add CaMeL First ( first ) ; return Resolve CaMeL Function ( data , items ) ; } } }	static private Declaration Resolve CaMeL Ambigu@@ ities ( Lookup CaMeL Data data , Hash CaMeL Set items ) throws Parser CaMeL Symbol CaMeL Table CaMeL Exception {
if ( ! evt . is CaMeL Shift CaMeL Down ( ) )  <CTX>  public void key CaMeL Pressed ( Key CaMeL Event evt ) { int lead = Basic CaMeL List CaMeL UI . this . list . get CaMeL Lead CaMeL Selection CaMeL Index ( ) ; int max = Basic CaMeL List CaMeL UI . this . list . get CaMeL Model ( ) . get CaMeL Size ( ) - 1 ; / / Do nothing if list is empty if ( max == - 1 ) return ; / / Process the key event . Bindings can be found in / / javax . swing . plaf . basic . Basic CaMeL Look CaMeL And CaMeL Feel . java if ( ( evt . get CaMeL Key CaMeL Code ( ) == Key CaMeL Event . VK _ DOWN ) || ( evt . get CaMeL Key CaMeL Code ( ) == Key CaMeL Event . VK _ KP _ DOWN ) ) { if ( ! evt . is CaMeL Shift CaMeL Down ( ) ) { Basic CaMeL List CaMeL UI . this . list . clear CaMeL Selection ( ) ; Basic CaMeL List CaMeL UI . this . list . set CaMeL Selected CaMeL Index ( Math . min ( lead + 1 , max ) ) ; } else { Basic CaMeL List CaMeL UI . this . list . get CaMeL Selection CaMeL Model ( ) . set CaMeL Lead CaMeL Selection CaMeL Index ( Math . min ( lead + 1 , max ) ) ; } } else if ( ( evt . get CaMeL Key CaMeL Code ( ) == Key CaMeL Event . VK _ UP ) || ( evt . get CaMeL Key CaMeL Code ( ) == Key CaMeL Event . VK _ KP _ UP ) ) { if ( ! evt . is CaMeL Shift CaMeL Down ( ) ) { Basic CaMeL List CaMeL UI . this . list . clear CaMeL Selection ( ) ; Basic CaMeL List CaMeL UI . this . list . set CaMeL Selected CaMeL Index ( Math . max ( lead - 1 , 0 ) ) ; } else { Basic CaMeL List CaMeL UI . this . list . get CaMeL Selection CaMeL Model ( ) . set CaMeL Lead CaMeL Selection CaMeL Index ( Math . max ( lead - 1 , 0 ) ) ; } } else if ( evt . get CaMeL Key CaMeL Code ( ) == Key CaMeL Event . VK _ PAGE _ UP ) { / / FIX@@ ME : implement , need J CaMeL List . ensure CaMeL Index CaMeL Is CaMeL Visible to work } else if ( evt . get CaMeL Key CaMeL Code ( ) == Key CaMeL Event . VK _ PAGE _ DOWN ) { / / FIX@@ ME : implement , need J CaMeL List . ensure CaMeL Index CaMeL Is CaMeL Visible to work } else if ( evt . get CaMeL Key CaMeL Code ( ) == Key CaMeL Event . VK _ BACK _ SLASH && evt . is CaMeL Control CaMeL Down ( ) ) { Basic CaMeL List CaMeL UI . this . list . clear CaMeL Selection ( ) ; } else if ( ( evt . get CaMeL Key CaMeL Code ( ) == Key CaMeL Event . VK _ HOME ) || evt . get CaMeL Key CaMeL Code ( ) == Key CaMeL Event . VK _ END ) { / / index is either 0 for HOME , or last cell for END int index = ( evt . get CaMeL Key CaMeL Code ( ) == Key CaMeL Event . VK _ HOME ) ? 0 : max ; if ( ! evt . is CaMeL Shift CaMeL Down ( ) || ( Basic CaMeL List CaMeL UI . this . list . get CaMeL Selection CaMeL Mode ( ) == List CaMeL Selection CaMeL Model . SINGLE _ SELECTION ) ) Basic CaMeL List CaMeL UI . this . list . set CaMeL Selected CaMeL Index ( index ) ; else if ( Basic CaMeL List CaMeL UI . this . list . get CaMeL Selection CaMeL Mode ( ) == List CaMeL Selection CaMeL Model . SINGLE _ INTERVAL _ SELECTION ) Basic CaMeL List CaMeL UI . this . list . set CaMeL Selection CaMeL Interval ( Basic CaMeL List CaMeL UI . this . list . get CaMeL Anchor CaMeL Selection CaMeL Index ( ) , index ) ; else Basic CaMeL List CaMeL UI . this . list . get CaMeL Selection CaMeL Model ( ) . set CaMeL Lead CaMeL Selection CaMeL Index ( index ) ; } else if ( ( evt . get CaMeL Key CaMeL Code ( ) == Key CaMeL Event . VK _ A || evt . get CaMeL Key CaMeL Code ( ) == Key CaMeL Event . VK _ SLASH ) && evt . is CaMeL Control CaMeL Down ( ) ) { Basic CaMeL List CaMeL UI . this . list . set CaMeL Selection CaMeL Interval ( 0 , max ) ; / / this next line is to restore the lead selection index to the old / / position , bec@@ ause select - all should not change the lead index Basic CaMeL List CaMeL UI . this . list . add CaMeL Selection CaMeL Interval ( lead , lead ) ; } else if ( evt . get CaMeL Key CaMeL Code ( ) == Key CaMeL Event . VK _ SPACE && evt . is CaMeL Control CaMeL Down ( ) ) { Basic CaMeL List CaMeL UI . this . list . get CaMeL Selection CaMeL Model ( ) . set CaMeL Lead CaMeL Selection CaMeL Index ( Math . min ( lead + 1 , max ) ) ; } }	if ( evt . get CaMeL Modifiers ( ) == 0 )
. set CaMeL Selection ( on CaMeL Resource == Marker CaMeL Filter . ON _ ANY _ RESOURCE _ OF _ SAME _ PROJECT ) ;  <CTX>  protected void reset CaMeL Pressed ( ) { types CaMeL Viewer . set CaMeL All CaMeL Checked ( true ) ; int on CaMeL Resource = Marker CaMeL Filter . DEFAULT _ ON _ RESOURCE ; any CaMeL Resource CaMeL Button . set CaMeL Selection ( on CaMeL Resource == Marker CaMeL Filter . ON _ ANY _ RESOURCE ) ; any CaMeL Resource CaMeL In CaMeL Same CaMeL Project CaMeL Button . set CaMeL Selection ( on CaMeL Resource == Marker CaMeL Filter . ON _ ANY _ RESOURCE _ OF _ SAME _ PROJECT ) ; selected CaMeL Resource CaMeL Button . set CaMeL Selection ( on CaMeL Resource == Marker CaMeL Filter . ON _ SELECTED _ RESOURCE _ ONLY ) ; selected CaMeL Resource CaMeL And CaMeL Children CaMeL Button . set CaMeL Selection ( on CaMeL Resource == Marker CaMeL Filter . ON _ SELECTED _ RESOURCE _ AND _ CHILDREN ) ; working CaMeL Set CaMeL Group . set CaMeL Selection ( on CaMeL Resource == Marker CaMeL Filter . ON _ WORKING _ SET ) ; update CaMeL Enabled CaMeL State ( true ) ; }	. set CaMeL Selection ( on CaMeL Resource == Marker CaMeL Filter . ON _ ANY _ IN _ SAME _ CONTAINER ) ;
Attribute CaMeL Group ag = ( Attribute CaMeL Group ) attribute CaMeL Groups . get ( ( Integer ) iter . next ( ) ) ;  <CTX>  public List get CaMeL All CaMeL UI CaMeL Attribute CaMeL Descriptions ( ) { List atts = new Array CaMeL List ( ) ; for ( Iterator iter = attribute CaMeL Groups . key CaMeL Set ( ) . iterator ( ) ; iter . has CaMeL Next ( ) ; ) { Attribute CaMeL Group ag = ( Attribute CaMeL Group ) attribute CaMeL Groups . get ( ( Integer ) iter . next ( ) ) ; atts . add CaMeL All ( ag . get CaMeL All CaMeL UI CaMeL Attribute CaMeL Descriptions ( ) ) ; } return atts ; }	Object ag = attribute CaMeL Groups . get ( ( Integer ) iter . next ( ) ) ;
my CaMeL Current CaMeL File = create CaMeL File CaMeL Info ( my CaMeL Current CaMeL Directory , path , false ) ;  <CTX>  public void open CaMeL File ( String path , long revision ) throws SVN CaMeL Exception { String name = SVN CaMeL Path CaMeL Util . tail ( path ) ; my CaMeL Current CaMeL File = create CaMeL File CaMeL Info ( my CaMeL Current CaMeL Directory , path , false ) ; my CaMeL Current CaMeL Directory . my CaMeL Compared CaMeL Entries . add ( name ) ; }	my CaMeL Current CaMeL File = create CaMeL File CaMeL Info ( path , false ) ;
resolved CaMeL Version = new CL@@ DR CaMeL File ( new Resolving CaMeL Source ( data CaMeL Source ) ) ;  <CTX>  public CL@@ DR CaMeL File get CaMeL Resolved ( ) { if ( data CaMeL Source instanceof Resolving CaMeL Source ) return this ; if ( resolved CaMeL Version == null ) { resolved CaMeL Version = new CL@@ DR CaMeL File ( new Resolving CaMeL Source ( data CaMeL Source ) ) ; } return resolved CaMeL Version ; }	resolved CaMeL Version = new CL@@ DR CaMeL File ( data CaMeL Source , true ) ;
if ( feature . equals ( Constants . SCHEMA _ FULL _ CHECKING ) ) {  <CTX>  protected void check CaMeL Feature ( String feature CaMeL Id ) throws XML CaMeL Configuration CaMeL Exception { / / / / Xerces Features / / if ( feature CaMeL Id . starts CaMeL With ( Constants . XERCES _ FEATURE _ PREFIX ) ) { String feature = feature CaMeL Id . substring ( Constants . XERCES _ FEATURE _ PREFIX . length ( ) ) ; / / / / http : / / apache . org / xml / features / validation / schema / / Le@@ ts the user turn Schema validation support on / off . / / if ( feature . equals ( Constants . SCHEMA _ VALIDATION _ FEATURE ) ) { return ; } / / activate full schema checking if ( feature . equals ( Constants . SCHEMA _ FULL _ CHECKING ) ) { return ; } / / Feature identifier : expose schema normalized value / / http : / / apache . org / xml / features / validation / schema / normalized - value if ( feature . equals ( Constants . SCHEMA _ NORMALIZED _ VALUE ) ) { return ; } / / Feature identifier : send element default value via characters ( ) / / http : / / apache . org / xml / features / validation / schema / element - default if ( feature . equals ( Constants . SCHEMA _ ELEMENT _ DEFAULT ) ) { return ; } } / / / / Not recognized / / super . check CaMeL Feature ( feature CaMeL Id ) ; } / / check CaMeL Feature ( String )	if ( feature CaMeL Id . region CaMeL Matches ( prefix CaMeL Length , Constants . SCHEMA _ FULL _ CHECKING , 0 , Constants . SCHEMA _ FULL _ CHECKING . length ( ) ) ) {
old CaMeL Grouping CaMeL Unit , grouping CaMeL Unit ) ) ;  <CTX>  public void set CaMeL Grouping CaMeL Unit ( String new CaMeL Grouping CaMeL Unit ) { String old CaMeL Grouping CaMeL Unit = grouping CaMeL Unit ; grouping CaMeL Unit = new CaMeL Grouping CaMeL Unit ; if ( e CaMeL Notification CaMeL Required ( ) ) e CaMeL Notify ( new E CaMeL Notification CaMeL Impl ( this , Notification . SET , Data CaMeL Package . SERIES _ GROUPING _ _ GROUPING _ UNIT , old CaMeL Grouping CaMeL Unit , grouping CaMeL Unit ) ) ; }	old CaMeL Grouping CaMeL Unit , grouping CaMeL Unit , ! old CaMeL Grouping CaMeL Unit CaMeL E CaMeL Set ) ) ;
Workbench . get CaMeL Instance ( ) . get CaMeL Active CaMeL Workbench CaMeL Window ( ) . get CaMeL Shell ( ) . add CaMeL Shell CaMeL Listener ( SHELL _ LISTENER ) ; My@@ lar CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Plugin CaMeL Preferences ( ) . add CaMeL Property CaMeL Change CaMeL Listener ( PREFERENCE _ LISTENER ) ; task CaMeL List CaMeL Manager . read CaMeL Task CaMeL List ( ) ; if ( task CaMeL List CaMeL Manager . get CaMeL Task CaMeL List ( ) == null ) task CaMeL List CaMeL Manager . create CaMeL New CaMeL Task CaMeL List ( ) ; }  <CTX>  public void run ( ) { Workbench . get CaMeL Instance ( ) . get CaMeL Active CaMeL Workbench CaMeL Window ( ) . get CaMeL Shell ( ) . add CaMeL Shell CaMeL Listener ( SHELL _ LISTENER ) ; My@@ lar CaMeL Plugin . get CaMeL Default ( ) . get CaMeL Plugin CaMeL Preferences ( ) . add CaMeL Property CaMeL Change CaMeL Listener ( PREFERENCE _ LISTENER ) ; task CaMeL List CaMeL Manager . read CaMeL Task CaMeL List ( ) ; if ( task CaMeL List CaMeL Manager . get CaMeL Task CaMeL List ( ) == null ) task CaMeL List CaMeL Manager . create CaMeL New CaMeL Task CaMeL List ( ) ; }	Tasks CaMeL Reminder CaMeL Dialog dialog = new Tasks CaMeL Reminder CaMeL Dialog ( Workbench . get CaMeL Instance ( ) . get CaMeL Display ( ) . get CaMeL Active CaMeL Shell ( ) , parser . get CaMeL Tasks ( ) ) ; dialog . set CaMeL Block CaMeL On CaMeL Open ( false ) ; dialog . open ( ) ; }
run CaMeL Exec ( prepare CaMeL Exec ( ) ) ;  <CTX>  public void execute ( ) throws Build CaMeL Exception { check CaMeL Configuration ( ) ; if ( is CaMeL Valid CaMeL Os ( ) ) { run CaMeL Exec ( prepare CaMeL Exec ( ) ) ; } }	try { run CaMeL Exec ( prepare CaMeL Exec ( ) ) ; } finally { dir = saved CaMeL Dir ; }
if ( m _ resource != null )  <CTX>  public void execute ( ) throws Task CaMeL Exception { validate ( ) ; if ( ( m _ name != null ) && ( m _ value != null ) ) { set CaMeL Property ( m _ name , m _ value ) ; } if ( m _ resource != null ) load CaMeL Resource ( m _ resource ) ; }	if ( m _ resource != null ) {
quick CaMeL Redraw = Layer CaMeL Utils . boolean CaMeL From CaMeL Properties ( properties , prefix  <CTX>  public void set CaMeL Properties ( String prefix , java . util . Properties properties ) { super . set CaMeL Properties ( prefix , properties ) ; props = properties ; ( ( CR@@ FP CaMeL Client ) frame CaMeL Provider ) . set CaMeL Properties ( prefix , properties ) ; quick CaMeL Redraw = Layer CaMeL Utils . boolean CaMeL From CaMeL Properties ( properties , prefix + Quick CaMeL Redraw CaMeL Property , false ) ; }	quick CaMeL Redraw = Prop CaMeL Utils . boolean CaMeL From CaMeL Properties ( properties , prefix
return ( Property CaMeL Accessor ) accessors . get ( property CaMeL Name ) ;  <CTX>  public I CaMeL Property CaMeL Accessor get CaMeL Accessor ( Object instance , String property CaMeL Name ) { if ( accessors == null ) build CaMeL Property CaMeL Accessors ( ) ; synchronized ( accessors ) { return ( Property CaMeL Accessor ) accessors . get ( property CaMeL Name ) ; } }	return ( I CaMeL Property CaMeL Accessor ) accessors . get ( property CaMeL Name ) ;
if ( is CaMeL Active ( ) )  <CTX>  public void stack CaMeL Changed ( Activity CaMeL Stack CaMeL Event event ) { if ( is CaMeL Active ( ) ) { reload CaMeL Editor CaMeL Input ( ) ; } }	if ( is CaMeL Active ( ) && event . get CaMeL Action ( ) != Activity CaMeL Stack CaMeL Event . ROLL _ BACK )
if ( get CaMeL Parent ( ) instanceof Menu CaMeL Manager ) ( ( Menu CaMeL Manager ) get CaMeL Parent ( ) ) . add CaMeL Menu CaMeL Listener ( menu CaMeL Listener ) ;  <CTX>  public void fill ( Menu menu , int index ) { if ( get CaMeL Parent ( ) instanceof Menu CaMeL Manager ) ( ( Menu CaMeL Manager ) get CaMeL Parent ( ) ) . add CaMeL Menu CaMeL Listener ( menu CaMeL Listener ) ; if ( ! dirty ) return ; Menu CaMeL Manager manager = new Menu CaMeL Manager ( ) ; fill CaMeL Menu ( manager ) ; I CaMeL Contribution CaMeL Item [ ] items = manager . get CaMeL Items ( ) ; if ( items . length == 0 ) { Menu CaMeL Item item = new Menu CaMeL Item ( menu , SWT . NONE , index ++ ) ; item . set CaMeL Text ( NO _ TARGETS _ MSG ) ; item . set CaMeL Enabled ( false ) ; } else { for ( int i = 0 ; i < items . length ; i ++ ) { items [ i ] . fill ( menu , index ++ ) ; } } dirty = false ; }	if ( get CaMeL Parent ( ) instanceof Menu CaMeL Manager ) { ( ( Menu CaMeL Manager ) get CaMeL Parent ( ) ) . add CaMeL Menu CaMeL Listener ( menu CaMeL Listener ) ; }
if ( value instanceof Native CaMeL Java CaMeL Object ) {  <CTX>  public boolean has CaMeL Instance ( Scriptable value ) { if ( value instanceof Native CaMeL Java CaMeL Object ) { Object instance = ( ( Native CaMeL Java CaMeL Object ) value ) . unwrap ( ) ; return get CaMeL Class CaMeL Object ( ) . is CaMeL Instance ( instance ) ; } / / value w@@ asn t something we under@@ stand return false ; }	if ( value instanceof Native CaMeL Java CaMeL Object && ! ( value instanceof Native CaMeL Java CaMeL Class ) ) {
I CaMeL Structured CaMeL Selection current CaMeL Selection , Adaptable CaMeL List elements ) {  <CTX>  public Workbench CaMeL Wizard CaMeL Selection CaMeL Page ( String name , I CaMeL Workbench a CaMeL Workbench , I CaMeL Structured CaMeL Selection current CaMeL Selection , Adaptable CaMeL List elements ) { super ( name ) ; this . wizard CaMeL Elements = elements ; this . current CaMeL Resource CaMeL Selection = current CaMeL Selection ; this . workbench = a CaMeL Workbench ; set CaMeL Title ( Workbench CaMeL Messages . Select ) ; }	I CaMeL Structured CaMeL Selection current CaMeL Selection , Adaptable CaMeL List elements , String trigger CaMeL Point CaMeL Id ) {
out . write ( 1 ) ;  <CTX>  public static void write CaMeL Streamable ( Streamable obj , Data CaMeL Output CaMeL Stream out ) throws IO CaMeL Exception { if ( obj == null ) { out . write ( 0 ) ; return ; } out . write ( 1 ) ; obj . write CaMeL To ( out ) ; }	out . write CaMeL Boolean ( true ) ;
} else { if ( ! ( result instanceof Native CaMeL Java CaMeL Class ) ) { while ( result instanceof Wrapper ) { result = ( ( Wrapper ) result ) . unwrap ( ) ; }  <CTX>  public Object next ( ) { Context . enter ( ) ; try { Object result = Scriptable CaMeL Object . get CaMeL Property ( scope , ids [ index ++ ] . to CaMeL String ( ) ) ; if ( result == Undefined . instance || result == Scriptable . NOT _ FOUND ) { result = null ; } else { if ( ! ( result instanceof Native CaMeL Java CaMeL Class ) ) { while ( result instanceof Wrapper ) { result = ( ( Wrapper ) result ) . unwrap ( ) ; } } } return result ; } finally { Context . exit ( ) ; } }	} else if ( ! ( result instanceof Native CaMeL Java CaMeL Class ) ) { while ( result instanceof Wrapper ) { result = ( ( Wrapper ) result ) . unwrap ( ) ;
return new primitive CaMeL Array CaMeL Type CaMeL Code ( TC CaMeL Kind . tk _ long ) ;  <CTX>  public static Type CaMeL Code type ( ) { return new primitive CaMeL Array CaMeL Type CaMeL Code ( TC CaMeL Kind . tk _ long ) ; }	return new primitive CaMeL Array CaMeL Type CaMeL Code ( TC CaMeL Kind . tk _ ulong ) ;
Cur c = d . locale ( ) . perm CaMeL Cur ( ) ; c . move CaMeL To CaMeL Dom ( d ) ;  <CTX>  public static void test ( Node n ) { Dom d = ( Dom ) n ; Cur c = d . locale ( ) . perm CaMeL Cur ( ) ; c . move CaMeL To CaMeL Dom ( d ) ; c . dump ( ) ; c . next ( ) ; c . next ( ) ; c . next CaMeL With CaMeL Attrs ( ) ; / / c . set CaMeL Type ( Xml CaMeL Object . type ) ; / / Type CaMeL Store store = c . get CaMeL Type CaMeL Store ( ) ; / / store . invalidate _ text ( ) ; c . dump ( ) ; c . release ( ) ; }	Char CaMeL Util . dump CaMeL Chars ( System . out , src , cu . _ off CaMeL Src , cu . _ cch CaMeL Src ) ;
return get CaMeL String CaMeL Property ( Style . DISPLAY _ PROP ) ;  <CTX>  public String get CaMeL Display ( ) { return get CaMeL String CaMeL Property ( Style . DISPLAY _ PROP ) ; }	return get CaMeL String CaMeL Property ( I CaMeL Style CaMeL Model . DISPLAY _ PROP ) ;
return ( Icon ) get CaMeL Look CaMeL And CaMeL Feel CaMeL Defaults ( ) . get ( key ) ;  <CTX>  public static Icon get CaMeL Icon ( Object key ) { return ( Icon ) get CaMeL Look CaMeL And CaMeL Feel CaMeL Defaults ( ) . get ( key ) ; }	return ( Icon ) get ( key ) ;
callback . write CaMeL To CaMeL Stream ( str . to CaMeL Char CaMeL Array ( ) ) ;  <CTX>  public void write CaMeL Chars ( String str ) throws IO CaMeL Exception { callback . write CaMeL To CaMeL Stream ( str . to CaMeL Char CaMeL Array ( ) ) ; }	peek CaMeL Callback ( ) . write CaMeL To CaMeL Stream ( str . to CaMeL Char CaMeL Array ( ) ) ;
current CaMeL Element = binding CaMeL Element . get CaMeL Parent ( ) ;  <CTX>  public void set CaMeL Binding ( Pipeline CaMeL Context pipeline CaMeL Context , Element binding CaMeL Element ) { / / Re@@ initialize context stack initialize ( ) ; / / Create ancestors - or - self list final List ancestors CaMeL Or CaMeL Self = new Array CaMeL List ( ) ; Element current CaMeL Element = binding CaMeL Element ; while ( current CaMeL Element != null ) { ancestors CaMeL Or CaMeL Self . add ( current CaMeL Element ) ; current CaMeL Element = binding CaMeL Element . get CaMeL Parent ( ) ; } / / Bind up to the specified element Collections . reverse ( ancestors CaMeL Or CaMeL Self ) ; for ( Iterator i = ancestors CaMeL Or CaMeL Self . iterator ( ) ; i . has CaMeL Next ( ) ; ) { push CaMeL Binding ( pipeline CaMeL Context , ( Element ) i . next ( ) ) ; } }	current CaMeL Element = current CaMeL Element . get CaMeL Parent ( ) ;
handlers . add ( handler ) ;  <CTX>  private void insert CaMeL Handler ( Handler CaMeL Description handler ) throws Phase CaMeL Exception { int type = get CaMeL Before CaMeL After ( handler . get CaMeL Handler ( ) ) ; valid@@ ate@@ after ( handler . get CaMeL Handler ( ) ) ; valid@@ ate@@ before ( handler . get CaMeL Handler ( ) ) ; switch ( type ) { case BOTH _ BEFORE _ AFTER : { insert CaMeL Be@@ fore@@ and CaMeL After ( handler . get CaMeL Handler ( ) ) ; } case BEFORE : { insert CaMeL Before ( handler . get CaMeL Handler ( ) ) ; } case AFTER : { insert CaMeL After ( handler . get CaMeL Handler ( ) ) ; } case ANYWHERE : { handlers . add ( handler ) ; } } }	handlers . add ( handler . get CaMeL Handler ( ) ) ;
dim . break CaMeL On CaMeL Return = value ; debug CaMeL Gui . menubar . break CaMeL On CaMeL Return . set CaMeL Selected ( value ) ;  <CTX>  public void set CaMeL Break CaMeL On CaMeL Return ( boolean value ) { dim . break CaMeL On CaMeL Return = value ; debug CaMeL Gui . menubar . break CaMeL On CaMeL Return . set CaMeL Selected ( value ) ; }	dim . set CaMeL Break CaMeL On CaMeL Return ( value ) ; debug CaMeL Gui . get CaMeL Menubar ( ) . get CaMeL Break CaMeL On CaMeL Return ( ) . set CaMeL Selected ( value ) ;
load CaMeL Schema ( f CaMeL XSD CaMeL Description , xis , location CaMeL Pairs ) ;  <CTX>  private void process CaMeL JAXP CaMeL Schema CaMeL Source ( Hashtable location CaMeL Pairs ) throws IO CaMeL Exception { if ( f CaMeL JAXP CaMeL Source == null ) { return ; } Class component CaMeL Type = f CaMeL JAXP CaMeL Source . get CaMeL Class ( ) . get CaMeL Component CaMeL Type ( ) ; XML CaMeL Input CaMeL Source xis = null ; String sid = null ; if ( component CaMeL Type == null ) { / / Not an array xis = xsd CaMeL To CaMeL XML CaMeL Input CaMeL Source ( f CaMeL JAXP CaMeL Source ) ; sid = xis . get CaMeL System CaMeL Id ( ) ; f CaMeL XSD CaMeL Description . f CaMeL Context CaMeL Type = XSD CaMeL Description . CONTEXT _ PRE@@ PARSE ; if ( sid != null ) { f CaMeL XSD CaMeL Description . set CaMeL Literal CaMeL System CaMeL Id ( sid ) ; f CaMeL XSD CaMeL Description . set CaMeL Expanded CaMeL System CaMeL Id ( sid ) ; f CaMeL XSD CaMeL Description . f CaMeL Location CaMeL Hints = new String [ ] { sid } ; } load CaMeL Schema ( f CaMeL XSD CaMeL Description , xis , location CaMeL Pairs ) ; return ; } else if ( component CaMeL Type != Object . class ) { / / Not an Object [ ] throw new XML CaMeL Configuration CaMeL Exception ( XML CaMeL Configuration CaMeL Exception . NOT _ SUPPORTED , JAXP _ SCHEMA _ SOURCE ) ; } Object [ ] obj CaMeL Arr = ( Object [ ] ) f CaMeL JAXP CaMeL Source ; for ( int i = 0 ; i < obj CaMeL Arr . length ; i ++ ) { xis = xsd CaMeL To CaMeL XML CaMeL Input CaMeL Source ( obj CaMeL Arr [ i ] ) ; sid = xis . get CaMeL System CaMeL Id ( ) ; f CaMeL XSD CaMeL Description . reset ( ) ; f CaMeL XSD CaMeL Description . f CaMeL Context CaMeL Type = XSD CaMeL Description . CONTEXT _ PRE@@ PARSE ; if ( sid != null ) { f CaMeL XSD CaMeL Description . set CaMeL Literal CaMeL System CaMeL Id ( sid ) ; f CaMeL XSD CaMeL Description . set CaMeL Expanded CaMeL System CaMeL Id ( sid ) ; f CaMeL XSD CaMeL Description . f CaMeL Location CaMeL Hints = new String [ ] { sid } ; } load CaMeL Schema ( f CaMeL XSD CaMeL Description , xis , location CaMeL Pairs ) ; } }	f CaMeL Grammar CaMeL Bucket . put CaMeL Grammar ( load CaMeL Schema ( f CaMeL XSD CaMeL Description , xis , location CaMeL Pairs ) ) ;
return do CaMeL Call ( cx , final CaMeL Scope , this CaMeL Obj , f , args , args CaMeL To CaMeL Wrap ) ;  <CTX>  public Object run ( Context cx ) { return do CaMeL Call ( cx , final CaMeL Scope , this CaMeL Obj , f , args , args CaMeL To CaMeL Wrap ) ; }	return do CaMeL Call ( cx , scope , this CaMeL Obj , f , args , args CaMeL To CaMeL Wrap ) ;
Output CaMeL Stream set CaMeL Ascii CaMeL Stream ( long pos ) throws SQL CaMeL Exception ;  <CTX>  Output CaMeL Stream set CaMeL Ascii CaMeL Stream ( long pos ) throws SQL CaMeL Exception ;	Output CaMeL Stream set CaMeL Ascii CaMeL Stream ( long start ) throws SQL CaMeL Exception ;
getter CaMeL Called ( ) ;  <CTX>  public boolean add ( Object element ) { getter CaMeL Called ( ) ; boolean added = wrapped CaMeL List . add ( element ) ; if ( added ) { fire CaMeL List CaMeL Change ( Diffs . create CaMeL List CaMeL Diff ( Diffs . create CaMeL List CaMeL Diff CaMeL Entry ( wrapped CaMeL List . size ( ) - 1 , true , element ) ) ) ; } return added ; }	check CaMeL Realm ( ) ;
void set CaMeL Object ( int parameter CaMeL Index , Object x , int target CaMeL Sql CaMeL Type , int scale ) throws SQL CaMeL Exception ;  <CTX>  void set CaMeL Object ( int parameter CaMeL Index , Object x , int target CaMeL Sql CaMeL Type , int scale ) throws SQL CaMeL Exception ;	void set CaMeL Object ( int index , Object value , int sql CaMeL Type , int scale ) throws SQL CaMeL Exception ;
String description = null ; try { description = seq . get CaMeL Annotation ( ) . get CaMeL Property ( PROPERTY _ DESCRIP@@ TION@@ LINE ) . to CaMeL String ( ) ; } catch ( No CaMeL Such CaMeL Element CaMeL Exception ex ) { description = seq . get CaMeL Name ( ) ; } return description ;  <CTX>  protected String describe CaMeL Sequence ( Sequence seq ) { String description = null ; try { description = seq . get CaMeL Annotation ( ) . get CaMeL Property ( PROPERTY _ DESCRIP@@ TION@@ LINE ) . to CaMeL String ( ) ; } catch ( No CaMeL Such CaMeL Element CaMeL Exception ex ) { description = seq . get CaMeL Name ( ) ; } return description ; }	String description = null ; try { description = seq . get CaMeL Annotation ( ) . get CaMeL Property ( PROPERTY _ DESCRIP@@ TION@@ LINE ) . to CaMeL String ( ) ; } catch ( No CaMeL Such CaMeL Element CaMeL Exception ex ) { description = seq . get CaMeL Name ( ) ;
if ( working CaMeL Copy CaMeL Getter CaMeL Fields != null && working CaMeL Copy CaMeL Setter CaMeL Fields != null ) run ( working CaMeL Copy CaMeL Getter CaMeL Fields , working CaMeL Copy CaMeL Setter CaMeL Fields , editor ) ;  <CTX>  private void generate ( I CaMeL Field [ ] getter CaMeL Fields , I CaMeL Field [ ] setter CaMeL Fields ) throws Core CaMeL Exception { if ( getter CaMeL Fields . length == 0 && setter CaMeL Fields . length == 0 ) return ; I CaMeL Compilation CaMeL Unit cu = null ; if ( getter CaMeL Fields . length != 0 ) cu = getter CaMeL Fields [ 0 ] . get CaMeL Compilation CaMeL Unit ( ) ; else cu = setter CaMeL Fields [ 0 ] . get CaMeL Compilation CaMeL Unit ( ) ; / / open the editor , forces the creation of a working copy I CaMeL Editor CaMeL Part editor = Editor CaMeL Utility . open CaMeL In CaMeL Editor ( cu ) ; I CaMeL Field [ ] working CaMeL Copy CaMeL Getter CaMeL Fields = get CaMeL Working CaMeL Copy CaMeL Fields ( getter CaMeL Fields ) ; I CaMeL Field [ ] working CaMeL Copy CaMeL Setter CaMeL Fields = get CaMeL Working CaMeL Copy CaMeL Fields ( setter CaMeL Fields ) ; if ( working CaMeL Copy CaMeL Getter CaMeL Fields != null && working CaMeL Copy CaMeL Setter CaMeL Fields != null ) run ( working CaMeL Copy CaMeL Getter CaMeL Fields , working CaMeL Copy CaMeL Setter CaMeL Fields , editor ) ; }	I CaMeL Field [ ] working CaMeL Copy CaMeL Getter CaMeL Setter CaMeL Fields = get CaMeL Working CaMeL Copy CaMeL Fields ( getter CaMeL Setter CaMeL Fields ) ; I CaMeL Java CaMeL Element working CaMeL Copy CaMeL Element CaMeL Position = get CaMeL Working CaMeL Copy ( element CaMeL Position ) ; if ( working CaMeL Copy CaMeL Getter CaMeL Fields != null && working CaMeL Copy CaMeL Setter CaMeL Fields != null && working CaMeL Copy CaMeL Getter CaMeL Setter CaMeL Fields != null ) run ( working CaMeL Copy CaMeL Getter CaMeL Fields , working CaMeL Copy CaMeL Setter CaMeL Fields , working CaMeL Copy CaMeL Getter CaMeL Setter CaMeL Fields , editor , working CaMeL Copy CaMeL Element CaMeL Position ) ;
return get CaMeL Or CaMeL Create CaMeL Navigator CaMeL Viewer CaMeL Descriptor ( viewer CaMeL Id ) ;  <CTX>  public Navigator CaMeL Viewer CaMeL Descriptor get CaMeL Navigator CaMeL Viewer CaMeL Descriptor ( String viewer CaMeL Id ) { return get CaMeL Or CaMeL Create CaMeL Navigator CaMeL Viewer CaMeL Descriptor ( viewer CaMeL Id ) ; }	return get CaMeL Viewer CaMeL Descriptor ( viewer CaMeL Id ) ;
&& ! ( list . get ( 0 ) instanceof Empty CaMeL Edit CaMeL Part ) )  <CTX>  protected void create CaMeL Edit CaMeL Policies ( ) { install CaMeL Edit CaMeL Policy ( Edit CaMeL Policy . LAYOUT _ ROLE , new Report CaMeL Flow CaMeL Layout CaMeL Edit CaMeL Policy ( ) { protected org . eclipse . gef . commands . Command get CaMeL Create CaMeL Command ( Create CaMeL Request request ) { List list = get CaMeL Host ( ) . get CaMeL Children ( ) ; if ( list . size ( ) != 0 && ! ( list . get ( 0 ) instanceof Empty CaMeL Edit CaMeL Part ) ) { return Unexecutable CaMeL Command . INSTANCE ; } / / Edit CaMeL Part after = get CaMeL Insertion CaMeL Reference ( request ) ; / / final Design CaMeL Element CaMeL Handle new CaMeL Object = ( Design CaMeL Element CaMeL Handle ) request . get CaMeL Extended CaMeL Data ( ) / / . get ( Designer CaMeL Constants . KEY _ NEW@@ OBJECT ) ; Create CaMeL Command command = new Create CaMeL Command ( request . get CaMeL Extended CaMeL Data ( ) ) { public void execute ( ) { super . execute ( ) ; Display . get CaMeL Current ( ) . async CaMeL Exec ( new Runnable ( ) { public void run ( ) { Set CaMeL Current CaMeL Edit CaMeL Model CaMeL Command c = new Set CaMeL Current CaMeL Edit CaMeL Model CaMeL Command ( get CaMeL New CaMeL Object ( ) ) ; c . execute ( ) ; } } ) ; } } ; Object model = this . get CaMeL Host ( ) . get CaMeL Model ( ) ; if ( model instanceof Report CaMeL Element CaMeL Model ) { command . set CaMeL Parent ( ( ( Report CaMeL Element CaMeL Model ) model ) . get CaMeL Slot CaMeL Handle ( ) ) ; } else if ( model instanceof List CaMeL Band CaMeL Proxy ) { command . set CaMeL Parent ( ( ( List CaMeL Band CaMeL Proxy ) model ) . get CaMeL Slot CaMeL Handle ( ) ) ; } else { command . set CaMeL Parent ( model ) ; } / / No previous edit part / / if ( after != null ) / / { / / command . set CaMeL After ( after . get CaMeL Model ( ) ) ; / / } return command ; } } ) ; install CaMeL Edit CaMeL Policy ( Edit CaMeL Policy . CONTAINER _ ROLE , new Report CaMeL Container CaMeL Edit CaMeL Policy ( ) ) ; }	&& ! ( list . get ( 0 ) instanceof Empty CaMeL Edit CaMeL Part ) && ( direct == null || ! direct . boolean CaMeL Value ( ) ) )
int size , boolean is CaMeL Scalar ,  <CTX>  public static VM _ Word get CaMeL Boot CaMeL Time CaMeL Available CaMeL Bits ( int ref , Object [ ] tib , int size , boolean is CaMeL Scalar , VM _ Word status ) throws VM _ Pragma CaMeL Uninterruptible , VM _ Pragma CaMeL Inline { if ( Plan . WITH _ CO@@ AL@@ ES@@ CING _ RC ) status = status . or ( UN@@ LOGGED ) ; return status ; }	int size ,
{ return 1 ; }  <CTX>  public int get CaMeL Driver CaMeL Major CaMeL Version ( ) { return 1 ; }	{ return connection . this _ driver . get CaMeL Major CaMeL Version ( ) ; }
return f CaMeL History . is CaMeL Empty ( ) ;  <CTX>  public synchronized boolean is CaMeL Empty ( ) { return f CaMeL History . is CaMeL Empty ( ) ; }	return history . is CaMeL Empty ( ) ;
this . chain = clone CaMeL And CaMeL Link ( chain ) ;  <CTX>  public Transformer CaMeL Chain ( Class CaMeL Transformer [ ] chain ) { this . chain = clone CaMeL And CaMeL Link ( chain ) ; }	this . chain = clone ( chain ) ;
Application CaMeL Manager . get CaMeL Application ( ) . invoke CaMeL And CaMeL Wait ( new Runnable ( ) { public void run ( ) { Application CaMeL Manager . get CaMeL Application ( ) . run CaMeL Write CaMeL Action ( new Runnable ( ) { public void run ( ) { final Psi CaMeL Document CaMeL Manager manager = Psi CaMeL Document CaMeL Manager . get CaMeL Instance ( project ) ; manager . commit CaMeL Document ( manager . get CaMeL Document ( psi CaMeL File ) ) ; } } ) ; } } , Modality CaMeL State . default CaMeL Modality CaMeL State ( ) ) ;  <CTX>  public void run ( ) { final Psi CaMeL File psi CaMeL File = file . get CaMeL Containing CaMeL File ( ) ; if ( psi CaMeL File != null ) { Application CaMeL Manager . get CaMeL Application ( ) . invoke CaMeL And CaMeL Wait ( new Runnable ( ) { public void run ( ) { Application CaMeL Manager . get CaMeL Application ( ) . run CaMeL Write CaMeL Action ( new Runnable ( ) { public void run ( ) { final Psi CaMeL Document CaMeL Manager manager = Psi CaMeL Document CaMeL Manager . get CaMeL Instance ( project ) ; manager . commit CaMeL Document ( manager . get CaMeL Document ( psi CaMeL File ) ) ; } } ) ; } } , Modality CaMeL State . default CaMeL Modality CaMeL State ( ) ) ; } if ( file instanceof Psi CaMeL File ) { match CaMeL Context . get CaMeL Sink ( ) . process CaMeL File ( ( Psi CaMeL File ) file ) ; } if ( progress != null ) { progress . set CaMeL Fraction ( ( double ) scanned CaMeL Files CaMeL Count / total CaMeL Files CaMeL To CaMeL Scan ) ; } ++ scanned CaMeL Files CaMeL Count ; if ( file instanceof Psi CaMeL Identifier ) { / / Searching in previous results file = file . get CaMeL Parent ( ) ; } Application CaMeL Manager . get CaMeL Application ( ) . run CaMeL Read CaMeL Action ( new Runnable ( ) { public void run ( ) { match ( file ) ; } } ) ; file = null ; }	final Runnable action = new Runnable ( ) { public void run ( ) { Application CaMeL Manager . get CaMeL Application ( ) . run CaMeL Write CaMeL Action ( new Runnable ( ) { public void run ( ) { final Psi CaMeL Document CaMeL Manager manager = Psi CaMeL Document CaMeL Manager . get CaMeL Instance ( project ) ; manager . commit CaMeL Document ( manager . get CaMeL Document ( psi CaMeL File ) ) ; } } ) ; } } ;
String [ ] old CaMeL Filters = this . filters ;  <CTX>  public void set CaMeL Filter CaMeL Text ( String [ ] filter CaMeL Strings ) { String [ ] old CaMeL Filters = this . filters ; this . filters = Text CaMeL Matcher . normalize CaMeL Filters ( filter CaMeL Strings ) ; / / fire the event only as necessary if ( ! Text CaMeL Matcher . is CaMeL Filter CaMeL Equal ( old CaMeL Filters , filters ) ) { / / classify the change in filter and apply the new filter to this list if ( filters . length == 0 ) { fire CaMeL Match CaMeL All ( ) ; } else if ( Text CaMeL Matcher . is CaMeL Filter CaMeL Relaxed ( old CaMeL Filters , filters ) ) { fire CaMeL Relaxed ( new Text CaMeL Matcher < E > ( filters , fil@@ terator ) ) ; } else if ( Text CaMeL Matcher . is CaMeL Filter CaMeL Constrained ( old CaMeL Filters , filters ) ) { fire CaMeL Constrained ( new Text CaMeL Matcher < E > ( filters , fil@@ terator ) ) ; } else { fire CaMeL Changed ( new Text CaMeL Matcher < E > ( filters , fil@@ terator ) ) ; } } }	final String [ ] old CaMeL Filters = this . filters ;
category CaMeL Status CaMeL Service . set CaMeL Category CaMeL Dao ( category CaMeL Dao ) ;  <CTX>  protected void set CaMeL Up ( ) throws Exception { super . set CaMeL Up ( ) ; view CaMeL Display CaMeL Dao = create CaMeL Mock ( View CaMeL Display CaMeL Dao . class ) ; category CaMeL Dao = create CaMeL Mock ( Category CaMeL Config CaMeL Dao . class ) ; outage CaMeL Dao = create CaMeL Mock ( Outage CaMeL Dao . class ) ; category CaMeL Status CaMeL Service = new Default CaMeL Category CaMeL Status CaMeL Service ( ) ; category CaMeL Status CaMeL Service . set CaMeL View CaMeL Display CaMeL Dao ( view CaMeL Display CaMeL Dao ) ; category CaMeL Status CaMeL Service . set CaMeL Category CaMeL Dao ( category CaMeL Dao ) ; category CaMeL Status CaMeL Service . set CaMeL Outage CaMeL Dao ( outage CaMeL Dao ) ; }	category CaMeL Status CaMeL Service . set CaMeL Category CaMeL Config CaMeL Dao ( category CaMeL Dao ) ;
this . weapon = weapon ; this . off@@ hand = off@@ hand ; this . hat = hat ; this . sh@@ i@@ rt = sh@@ i@@ rt ; this . p@@ ants = p@@ ants ; this . accessory = accessory ; this . f@@ am@@ ili@@ ar = f@@ am@@ ili@@ ar ;  <CTX>  public Equipment CaMeL Cell CaMeL Renderer ( boolean weapon , boolean off@@ hand , boolean hat , boolean sh@@ i@@ rt , boolean p@@ ants , boolean accessory , boolean f@@ am@@ ili@@ ar ) { set CaMeL Opaque ( true ) ; this . weapon = weapon ; this . off@@ hand = off@@ hand ; this . hat = hat ; this . sh@@ i@@ rt = sh@@ i@@ rt ; this . p@@ ants = p@@ ants ; this . accessory = accessory ; this . f@@ am@@ ili@@ ar = f@@ am@@ ili@@ ar ; }	this . filter CaMeL Type = filter CaMeL Type ;
tree . set CaMeL Shows CaMeL Root CaMeL Handles ( new CaMeL Value ) ;  <CTX>  protected void set CaMeL Shows CaMeL Root CaMeL Handles ( boolean new CaMeL Value ) { tree . set CaMeL Shows CaMeL Root CaMeL Handles ( new CaMeL Value ) ; }	complete CaMeL Editing ( ) ; update CaMeL Depth CaMeL Offset ( ) ; if ( tree CaMeL State != null ) { tree CaMeL State . invalidate CaMeL Sizes ( ) ; update CaMeL Size ( ) ; }
if ( tree . equals ( e . get CaMeL Source ( ) ) ) { Object o = tree . get CaMeL Item ( new Point ( e . x , e . y ) ) ; final Tree CaMeL Item selection = tree . get CaMeL Selection ( ) [ 0 ] ; if ( selection . equals ( o ) ) { C CaMeL Element selected CaMeL Element = ( C CaMeL Element ) selection . get CaMeL Data ( ) ; f CaMeL Editor . set CaMeL Selection ( selected CaMeL Element ) ; dispose ( ) ; } if ( f CaMeL Composite != null && ! f CaMeL Composite . is CaMeL Disposed ( ) ) { f CaMeL Bounds = f CaMeL Composite . get CaMeL Bounds ( ) ; } } }  <CTX>  public void mouse CaMeL Up ( Mouse CaMeL Event e ) { final Tree tree = f CaMeL Tree CaMeL Viewer . get CaMeL Tree ( ) ; if ( tree . get CaMeL Selection CaMeL Count ( ) < 1 ) { return ; } if ( e . button != 1 ) { return ; } if ( tree . equals ( e . get CaMeL Source ( ) ) ) { Object o = tree . get CaMeL Item ( new Point ( e . x , e . y ) ) ; final Tree CaMeL Item selection = tree . get CaMeL Selection ( ) [ 0 ] ; if ( selection . equals ( o ) ) { C CaMeL Element selected CaMeL Element = ( C CaMeL Element ) selection . get CaMeL Data ( ) ; f CaMeL Editor . set CaMeL Selection ( selected CaMeL Element ) ; dispose ( ) ; } if ( f CaMeL Composite != null && ! f CaMeL Composite . is CaMeL Disposed ( ) ) { f CaMeL Bounds = f CaMeL Composite . get CaMeL Bounds ( ) ; } } }	if ( tree . get CaMeL Selection CaMeL Count ( ) < 1 ) return ; if ( e . button != 1 ) return ; if ( tree . equals ( e . get CaMeL Source ( ) ) ) { Object o = tree . get CaMeL Item ( new Point ( e . x , e . y ) ) ; Tree CaMeL Item selection = tree . get CaMeL Selection ( ) [ 0 ] ; if ( selection . equals ( o ) ) goto CaMeL Selected CaMeL Element ( ) ; } }
this . in = new Sequence CaMeL File . Reader ( fs , split . get CaMeL File ( ) . to CaMeL String ( ) ) ;  <CTX>  public Sequence CaMeL File CaMeL Record CaMeL Reader ( Nutch CaMeL File CaMeL System fs , File CaMeL Split split ) throws IO CaMeL Exception { this . in = new Sequence CaMeL File . Reader ( fs , split . get CaMeL File ( ) . to CaMeL String ( ) ) ; this . end = split . get CaMeL Start ( ) + split . get CaMeL Length ( ) ; if ( split . get CaMeL Start ( ) > in . get CaMeL Position ( ) ) in . sync ( split . get CaMeL Start ( ) ) ; / / sync to start more = in . get CaMeL Position ( ) < end ; }	Nutch CaMeL File CaMeL System fs = Nutch CaMeL File CaMeL System . get ( nut@@ ch CaMeL Conf ) ; this . in = new Sequence CaMeL File . Reader ( fs , split . get CaMeL File ( ) . to CaMeL String ( ) , nut@@ ch CaMeL Conf ) ;
IAST CaMeL Declaration d = simple CaMeL Declaration ( Simple CaMeL Declaration CaMeL Strategy . TRY _ FUNCTION , false ) ; throw CaMeL Away CaMeL Marks CaMeL For CaMeL Initializer CaMeL Clause ( ) ; return d ;  <CTX>  protected IAST CaMeL Declaration simple CaMeL Declaration CaMeL Strategy CaMeL Union ( ) throws End CaMeL Of CaMeL File CaMeL Exception , Backtrack CaMeL Exception { simple CaMeL Declaration CaMeL Mark = mark ( ) ; try { IAST CaMeL Declaration d = simple CaMeL Declaration ( Simple CaMeL Declaration CaMeL Strategy . TRY _ FUNCTION , false ) ; throw CaMeL Away CaMeL Marks CaMeL For CaMeL Initializer CaMeL Clause ( ) ; return d ; } catch ( Backtrack CaMeL Exception bt ) { if ( simple CaMeL Declaration CaMeL Mark == null ) throw CaMeL Backtrack ( bt ) ; / / did not work backup ( simple CaMeL Declaration CaMeL Mark ) ; IAST CaMeL Declaration d = simple CaMeL Declaration ( Simple CaMeL Declaration CaMeL Strategy . TRY _ VARIABLE , false ) ; throw CaMeL Away CaMeL Marks CaMeL For CaMeL Initializer CaMeL Clause ( ) ; return d ; } }	d 1 = simple CaMeL Declaration ( Simple CaMeL Declaration CaMeL Strategy . TRY _ FUNCTION , false ) ; try { after = LA ( 1 ) ; } catch ( End CaMeL Of CaMeL File CaMeL Exception eof ) { after = null ; }
this . content CaMeL Provider = new Content CaMeL Provider ( this . history ) ; if ( list != null ) list . set CaMeL Content CaMeL Provider ( content CaMeL Provider ) ;  <CTX>  protected void apply CaMeL Filter ( ) { stop CaMeL Current CaMeL Filter CaMeL Job ( ) ; this . filter = create CaMeL Filter ( ) ; this . content CaMeL Provider = new Content CaMeL Provider ( this . history ) ; if ( list != null ) list . set CaMeL Content CaMeL Provider ( content CaMeL Provider ) ; if ( this . filter != null ) { if ( this . filter . get CaMeL Pattern ( ) . length ( ) == 0 ) { filter = null ; } else { schedule CaMeL Filter CaMeL Job ( ) ; } } }	this . content CaMeL Provider . reset ( ) ;
( ( Taxa ) taxon CaMeL Sets . get ( row CaMeL Index ) ) . set CaMeL Id ( a CaMeL Value . to CaMeL String ( ) ) ;  <CTX>  public void set CaMeL Value CaMeL At ( Object a CaMeL Value , int row CaMeL Index , int column CaMeL Index ) { ( ( Taxa ) taxon CaMeL Sets . get ( row CaMeL Index ) ) . set CaMeL Id ( a CaMeL Value . to CaMeL String ( ) ) ; set CaMeL Taxon CaMeL Set CaMeL Title ( ) ; }	( ( Taxa ) options . taxon CaMeL Sets . get ( row CaMeL Index ) ) . set CaMeL Id ( a CaMeL Value . to CaMeL String ( ) ) ;
if ( state CaMeL Model == null )  <CTX>  public I CaMeL Extension CaMeL State CaMeL Model get CaMeL State CaMeL Model ( ) { if ( state CaMeL Model == null ) state CaMeL Model = new Extension CaMeL State CaMeL Model ( descriptor . get CaMeL Id ( ) , viewer CaMeL Id ) ; return state CaMeL Model ; }	if ( state CaMeL Model == null ) {
return interpolate ( project , context , true ) ;  <CTX>  public Model interpolate ( Model project , Map context ) throws Model CaMeL Interpolation CaMeL Exception { return interpolate ( project , context , true ) ; }	return interpolate ( model , context , true ) ;
Psi CaMeL Call copy = ( Psi CaMeL Call ) my CaMeL Call . copy ( ) ; Psi CaMeL Expression [ ] expressions = my CaMeL Call . get CaMeL Argument CaMeL List ( ) . get CaMeL Expressions ( ) ; Psi CaMeL Expression [ ] copy CaMeL Expressions = copy . get CaMeL Argument CaMeL List ( ) . get CaMeL Expressions ( ) ; for ( int i = 0 ; i < my CaMeL Permutation . length ; i ++ ) { int j = my CaMeL Permutation [ i ] ; if ( i != j ) { copy CaMeL Expressions [ j ] . replace ( expressions [ i ] ) ; } } my CaMeL Call . get CaMeL Argument CaMeL List ( ) . replace ( copy . get CaMeL Argument CaMeL List ( ) ) ;  <CTX>  public void invoke ( Project project , Editor editor , Psi CaMeL File file ) throws Incorrect CaMeL Operation CaMeL Exception { Psi CaMeL Call copy = ( Psi CaMeL Call ) my CaMeL Call . copy ( ) ; Psi CaMeL Expression [ ] expressions = my CaMeL Call . get CaMeL Argument CaMeL List ( ) . get CaMeL Expressions ( ) ; Psi CaMeL Expression [ ] copy CaMeL Expressions = copy . get CaMeL Argument CaMeL List ( ) . get CaMeL Expressions ( ) ; for ( int i = 0 ; i < my CaMeL Permutation . length ; i ++ ) { int j = my CaMeL Permutation [ i ] ; if ( i != j ) { copy CaMeL Expressions [ j ] . replace ( expressions [ i ] ) ; } } my CaMeL Call . get CaMeL Argument CaMeL List ( ) . replace ( copy . get CaMeL Argument CaMeL List ( ) ) ; }	my CaMeL Call . get CaMeL Argument CaMeL List ( ) . replace ( my CaMeL Permutation . get CaMeL Argument CaMeL List ( ) ) ;
return new Java CaMeL Class ( runtime , superclass . get CaMeL Name ( ) ) ;  <CTX>  public I CaMeL Ruby CaMeL Object superclass ( ) { Class superclass = java CaMeL Class . get CaMeL Superclass ( ) ; if ( superclass == null ) { return runtime . get CaMeL Nil ( ) ; } return new Java CaMeL Class ( runtime , superclass . get CaMeL Name ( ) ) ; }	return new Java CaMeL Class ( get CaMeL Runtime ( ) , superclass . get CaMeL Name ( ) ) ;
return ( int ) ( data CaMeL Length - ptr ) ;  <CTX>  public final int available ( ) { return ( int ) ( data CaMeL Length - ptr ) ; }	int x = ( int ) ( data CaMeL Length - ptr ) ; return ( x < 0 ) ? 0 : x ;
void project CaMeL Finished ( ) ;  <CTX>  void project CaMeL Finished ( ) ;	void project CaMeL Finished ( Project CaMeL Event event ) ;
return Ruby CaMeL Boolean . new CaMeL Boolean ( runtime , java CaMeL Class . is CaMeL Interface ( ) ) ;  <CTX>  public Ruby CaMeL Boolean interface _ p ( ) { return Ruby CaMeL Boolean . new CaMeL Boolean ( runtime , java CaMeL Class . is CaMeL Interface ( ) ) ; }	return get CaMeL Runtime ( ) . new CaMeL Boolean ( java CaMeL Class . is CaMeL Interface ( ) ) ;
set CaMeL Float CaMeL Value ( Float . parse CaMeL Float ( data . to CaMeL String ( ) ) ) ;  <CTX>  public void end CaMeL Element ( String ns CaMeL URI , String local CaMeL Name , String q CaMeL Name , St CaMeL AX CaMeL Content CaMeL Handler handler ) throws SAX CaMeL Exception { level -- ; if ( level == 0 ) { try { set CaMeL Float CaMeL Value ( Float . parse CaMeL Float ( data . to CaMeL String ( ) ) ) ; } catch ( Number CaMeL Format CaMeL Exception nfe ) { throw new SAX CaMeL Exception ( nfe ) ; } } }	set CaMeL Float CaMeL Value ( Float . parse CaMeL Float ( ( data . to CaMeL String ( ) ) . trim ( ) ) ) ;
Font CaMeL Metrics fm = lab . get CaMeL Toolkit ( ) . get CaMeL Font CaMeL Metrics ( lab . get CaMeL Font ( ) ) ;  <CTX>  public Dimension get CaMeL Preferred CaMeL Size ( J CaMeL Component c ) { J CaMeL Label lab = ( J CaMeL Label ) c ; Rectangle vr = new Rectangle ( ) ; Rectangle ir = new Rectangle ( ) ; Rectangle tr = new Rectangle ( ) ; Insets insets = lab . get CaMeL Insets ( ) ; Font CaMeL Metrics fm = lab . get CaMeL Toolkit ( ) . get CaMeL Font CaMeL Metrics ( lab . get CaMeL Font ( ) ) ; layout CaMeL CL ( lab , fm , lab . get CaMeL Text ( ) , lab . get CaMeL Icon ( ) , vr , ir , tr ) ; Rectangle cr = tr . union ( ir ) ; return new Dimension ( insets . left + cr . width + insets . right , insets . top + cr . height + insets . bottom ) ; }	Font CaMeL Metrics fm = lab . get CaMeL Font CaMeL Metrics ( lab . get CaMeL Font ( ) ) ;
if ( widget == null )  <CTX>  protected void internal CaMeL Refresh ( Object element ) { if ( element == null ) return ; if ( element . equals ( get CaMeL Root ( ) ) ) refresh CaMeL All ( ) ; Widget widget = find CaMeL Item ( element ) ; if ( widget == null ) return ; ( ( Progress CaMeL Info CaMeL Item ) widget ) . refresh ( ) ; Point size = control . compute CaMeL Size ( SWT . DEFAULT , SWT . DEFAULT ) ; control . set CaMeL Size ( size ) ; scrolled . set CaMeL Min CaMeL Size ( size ) ; }	if ( widget == null ) { add ( new Object [ ] { element } ) ;
remove CaMeL Content ( ( Content CaMeL UI ) content ) ;  <CTX>  public void uni@@ stall ( ) { content CaMeL Value CaMeL Adjusting = true ; for ( Content content : content CaMeL Manager . get CaMeL Contents ( ) ) { remove CaMeL Content ( ( Content CaMeL UI ) content ) ; } content CaMeL Value CaMeL Adjusting = false ; }	remove CaMeL Content ( ( Back CaMeL Content CaMeL UI ) content ) ;
if ( obj instanceof Connection ) {  <CTX>  public boolean equals ( Object obj ) { if ( obj != null ) { if ( obj instanceof Connection ) { return connection . hash CaMeL Code ( ) == obj . hash CaMeL Code ( ) ; } else { return super . equals ( obj ) ; } } else { return false ; } }	if ( obj instanceof Proxy CaMeL Connection ) { return connection . hash CaMeL Code ( ) == ( ( Proxy CaMeL Connection ) obj ) . get CaMeL Connection ( ) . hash CaMeL Code ( ) ; } else if ( obj instanceof Connection ) {
do CaMeL Enable CaMeL Item ( w , men@@ uname , label , enable ) ;  <CTX>  public void action ( Jape CaMeL Window w ) { do CaMeL Enable CaMeL Item ( w , men@@ uname , label , enable ) ; }	if ( ( w . get CaMeL Bar CaMeL Kind ( ) & bar CaMeL Kinds ) != 0 ) do CaMeL Enable CaMeL Item ( w , men@@ uname , label , enable ) ;
add CaMeL Constant CaMeL Class CaMeL Info ( class CaMeL FD ) , add CaMeL Constant CaMeL Name CaMeL And CaMeL Type CaMeL Info ( method CaMeL Name , method CaMeL MD )  <CTX>  public short add CaMeL Constant CaMeL Methodref CaMeL Info ( String class CaMeL FD , String method CaMeL Name , String method CaMeL MD ) { return this . add CaMeL To CaMeL Constant CaMeL Pool ( new Constant CaMeL Methodref CaMeL Info ( add CaMeL Constant CaMeL Class CaMeL Info ( class CaMeL FD ) , add CaMeL Constant CaMeL Name CaMeL And CaMeL Type CaMeL Info ( method CaMeL Name , method CaMeL MD ) ) ) ; }	this . add CaMeL Constant CaMeL Class CaMeL Info ( class CaMeL FD ) , this . add CaMeL Constant CaMeL Name CaMeL And CaMeL Type CaMeL Info ( method CaMeL Name , method CaMeL MD )
s . check CaMeL Read ( p ) ; return p ;  <CTX>  private final String check CaMeL Read ( ) { Security CaMeL Manager s = System . get CaMeL Security CaMeL Manager ( ) ; String p = safe CaMeL Canonical CaMeL Path ( ) ; if ( p == null ) return null ; if ( s != null ) s . check CaMeL Read ( p ) ; return p ; }	s . check CaMeL Read ( path ) ;
return null ;  <CTX>  public String get CaMeL Description ( ) { / / TODO implement this function return null ; }	return _ description ;
Id CaMeL Function f = new CaMeL Id CaMeL Function ( id ) ; f . set CaMeL Parent CaMeL Scope ( get CaMeL Parent CaMeL Scope ( ) ) ;  <CTX>  protected void add CaMeL Id CaMeL Function CaMeL Property ( Scriptable obj , int id , boolean sealed ) { Id CaMeL Function f = new CaMeL Id CaMeL Function ( id ) ; f . set CaMeL Parent CaMeL Scope ( get CaMeL Parent CaMeL Scope ( ) ) ; if ( sealed ) { f . seal CaMeL Object ( ) ; } define CaMeL Property ( obj , get CaMeL Id CaMeL Name ( id ) , f , DONTENUM ) ; }	Id CaMeL Function f = new CaMeL Id CaMeL Function ( id , get CaMeL Parent CaMeL Scope ( ) ) ;
result [ counter ] = key . fd ;  <CTX>  private final int [ ] get CaMeL F CaMeL Ds CaMeL As CaMeL Array ( int ops ) { int [ ] result ; int counter = 0 ; Iterator it = keys . iterator ( ) ; / / Count the number of file descriptors needed while ( it . has CaMeL Next ( ) ) { Selection CaMeL Key CaMeL Impl key = ( Selection CaMeL Key CaMeL Impl ) it . next ( ) ; if ( ( key . interest CaMeL Ops ( ) & ops ) != 0 ) { counter ++ ; } } result = new int [ counter ] ; counter = 0 ; it = keys . iterator ( ) ; / / Fill the array with the file descriptors while ( it . has CaMeL Next ( ) ) { Selection CaMeL Key CaMeL Impl key = ( Selection CaMeL Key CaMeL Impl ) it . next ( ) ; if ( ( key . interest CaMeL Ops ( ) & ops ) != 0 ) { result [ counter ] = key . fd ; counter ++ ; } } return result ; }	result [ counter ] = key . get CaMeL Native CaMeL FD ( ) ;
state . get CaMeL Thread CaMeL Context ( ) . get CaMeL Current CaMeL Dynamic CaMeL Vars ( ) . set ( i CaMeL Visited . get CaMeL Name ( ) , value ) ;  <CTX>  public Instruction visit CaMeL D CaMeL Asgn CaMeL Node ( D CaMeL Asgn CaMeL Node i CaMeL Visited ) { state . get CaMeL Thread CaMeL Context ( ) . get CaMeL Current CaMeL Dynamic CaMeL Vars ( ) . set ( i CaMeL Visited . get CaMeL Name ( ) , value ) ; return null ; }	runtime . get CaMeL Current CaMeL Context ( ) . get CaMeL Current CaMeL Dynamic CaMeL Vars ( ) . set ( i CaMeL Visited . get CaMeL Name ( ) , value ) ;
case Lexer . CHAR _ NON@@ CAP _ GROUP : {  <CTX>  private Abstract CaMeL Set process CaMeL Expression ( int ch , int new _ flags , Abstract CaMeL Set last ) { Array CaMeL List children = new Array CaMeL List ( ) ; Abstract CaMeL Set child ; int safe _ flags = flags ; F CaMeL Set f CaMeL Set ; if ( new _ flags != flags ) { flags = new _ flags ; lexemes . set CaMeL Flags ( flags ) ; } switch ( ch ) { case Lexer . CHAR _ NON@@ CAP _ GROUP : { f CaMeL Set = new Non CaMeL Cap CaMeL F CaMeL Set ( ++ cons CaMeL Count ) ; break ; } case Lexer . CHAR _ POS _ LOOKAHEAD : case Lexer . CHAR _ NEG _ LOOKAHEAD : { f CaMeL Set = new Ahead CaMeL F CaMeL Set ( ) ; break ; } case Lexer . CHAR _ POS _ LOOKBEHIND : case Lexer . CHAR _ NEG _ LOOKBEHIND : { f CaMeL Set = new Behind CaMeL F CaMeL Set ( ++ cons CaMeL Count ) ; break ; } case Lexer . CHAR _ ATOMIC _ GROUP : { f CaMeL Set = new Atomic CaMeL F CaMeL Set ( ++ cons CaMeL Count ) ; break ; } default : { global CaMeL Group CaMeL Index ++ ; if ( last == null ) { f CaMeL Set = new Final CaMeL Set ( ) ; / / expr = new Start CaMeL Set ( ) ; } else { f CaMeL Set = new F CaMeL Set ( global CaMeL Group CaMeL Index ) ; / / expr = new Joint CaMeL Set ( global CaMeL Group CaMeL Index ) ; } } } do { if ( lexemes . is CaMeL Letter ( ) && lexemes . look CaMeL Ahead ( ) == Lexer . CHAR _ VERTICAL _ BAR ) { child = process CaMeL Altern@@ ations ( f CaMeL Set ) ; } else { child = process CaMeL Sub CaMeL Expression ( f CaMeL Set ) ; if ( lexemes . peek ( ) == Lexer . CHAR _ VERTICAL _ BAR ) lexemes . next ( ) ; } if ( child != null ) children . add ( child ) ; / / expr . add CaMeL Child ( child ) ; } while ( ! ( lexemes . is CaMeL Empty ( ) || lexemes . peek ( ) == Lexer . CHAR _ RIGHT _ PARENTHESIS ) ) ; if ( flags != safe _ flags ) { flags = safe _ flags ; lexemes . set CaMeL Flags ( flags ) ; } switch ( ch ) { case Lexer . CHAR _ NON@@ CAP _ GROUP : { return new Non CaMeL Cap CaMeL Joint CaMeL Set ( children , f CaMeL Set ) ; } case Lexer . CHAR _ POS _ LOOKAHEAD : { return new Positive CaMeL Look CaMeL Ahead ( children , f CaMeL Set ) ; } case Lexer . CHAR _ NEG _ LOOKAHEAD : { return new Negative CaMeL Look CaMeL Ahead ( children , f CaMeL Set ) ; } case Lexer . CHAR _ POS _ LOOKBEHIND : { return new Positive CaMeL Look CaMeL Behind ( children , f CaMeL Set ) ; } case Lexer . CHAR _ NEG _ LOOKBEHIND : { return new Negative CaMeL Look CaMeL Behind ( children , f CaMeL Set ) ; } case Lexer . CHAR _ ATOMIC _ GROUP : { return new Atomic CaMeL Joint CaMeL Set ( children , f CaMeL Set ) ; } default : { switch ( children . size ( ) ) { case 0 : return new Empty CaMeL Set ( f CaMeL Set ) ; case 1 : return new Single CaMeL Set ( ( Abstract CaMeL Set ) children . get ( 0 ) , f CaMeL Set ) ; default : return new Joint CaMeL Set ( children , f CaMeL Set ) ; } } } }	case Lexer . CHAR _ NON@@ CAP _ GROUP :
if ( close != null ) { close . set CaMeL Enabled ( enabled ) ; }  <CTX>  public void enable CaMeL Close ( boolean enabled ) { if ( close != null ) { close . set CaMeL Enabled ( enabled ) ; } }	close . set CaMeL Visible ( enabled ) ; toolbar CaMeL Manager . update ( false ) ;
List children = new Array CaMeL List ( ) ; I CaMeL Project project = ( I CaMeL Project ) parent . get CaMeL Adapter ( I@@ PROJECT _ CLASS ) ; Object [ ] root CaMeL Objects = ( root CaMeL Object CaMeL Provider != null ) ? root CaMeL Object CaMeL Provider . get CaMeL Models ( project ) : null ; if ( root CaMeL Objects != null ) { for ( int x = 0 ; x < root CaMeL Objects . length ; ++ x ) { children . add ( root CaMeL Objects [ x ] ) ; } } update CaMeL UI CaMeL Job . set CaMeL Complete ( true ) ; new Clear CaMeL Place CaMeL Holder CaMeL Job ( viewer , place CaMeL Holder , parent , children . to CaMeL Array ( ) ) . schedule ( ) ;  <CTX>  protected I CaMeL Status run ( I CaMeL Progress CaMeL Monitor monitor ) { Loading CaMeL DD@@ UI CaMeL Job update CaMeL UI CaMeL Job = new Loading CaMeL DD@@ UI CaMeL Job ( viewer , place CaMeL Holder ) ; update CaMeL UI CaMeL Job . schedule ( ) ; List children = new Array CaMeL List ( ) ; I CaMeL Project project = ( I CaMeL Project ) parent . get CaMeL Adapter ( I@@ PROJECT _ CLASS ) ; Object [ ] root CaMeL Objects = ( root CaMeL Object CaMeL Provider != null ) ? root CaMeL Object CaMeL Provider . get CaMeL Models ( project ) : null ; if ( root CaMeL Objects != null ) { for ( int x = 0 ; x < root CaMeL Objects . length ; ++ x ) { children . add ( root CaMeL Objects [ x ] ) ; } } update CaMeL UI CaMeL Job . set CaMeL Complete ( true ) ; new Clear CaMeL Place CaMeL Holder CaMeL Job ( viewer , place CaMeL Holder , parent , children . to CaMeL Array ( ) ) . schedule ( ) ; return Status . OK _ STATUS ; }	try { I CaMeL Project project = ( I CaMeL Project ) parent . get CaMeL Adapter ( I@@ PROJECT _ CLASS ) ; Object [ ] root CaMeL Objects = ( root CaMeL Object CaMeL Provider != null ) ? root CaMeL Object CaMeL Provider . get CaMeL Models ( project ) : null ; if ( root CaMeL Objects != null ) { for ( int x = 0 ; x < root CaMeL Objects . length ; ++ x ) { children . add ( root CaMeL Objects [ x ] ) ; } } } finally { / * dispose of the place holder , causes the termination of the animation job * / place CaMeL Holder . dispose ( ) ; new Clear CaMeL Place CaMeL Holder CaMeL Job ( viewer , place CaMeL Holder , parent , children . to CaMeL Array ( ) ) . schedule ( ) ; }
if ( ( style & SWT . CHECK ) != 0 ) set CaMeL Checkbox CaMeL Image CaMeL List ( ) ;  <CTX>  LRESULT WM _ SYS@@ COLOR@@ CHANGE ( int w CaMeL Param , int l CaMeL Param ) { LRESULT result = super . WM _ SYS@@ COLOR@@ CHANGE ( w CaMeL Param , l CaMeL Param ) ; if ( result != null ) return result ; if ( ( style & SWT . CHECK ) != 0 ) set CaMeL Checkbox CaMeL Image CaMeL List ( ) ; return result ; }	if ( ( style & SWT . CHECK ) != 0 ) set CaMeL Checkbox CaMeL Image CaMeL List ( true ) ;
Font CaMeL Data old CaMeL Font = chosen CaMeL Font ;  <CTX>  protected Button get CaMeL Change CaMeL Control ( Composite parent ) { if ( change CaMeL Font CaMeL Button == null ) { change CaMeL Font CaMeL Button = new Button ( parent , SWT . PUSH ) ; if ( change CaMeL Button CaMeL Text != null ) change CaMeL Font CaMeL Button . set CaMeL Text ( change CaMeL Button CaMeL Text ) ; change CaMeL Font CaMeL Button . add CaMeL Selection CaMeL Listener ( new Selection CaMeL Adapter ( ) { public void widget CaMeL Selected ( Selection CaMeL Event event ) { Font CaMeL Dialog font CaMeL Dialog = new Font CaMeL Dialog ( change CaMeL Font CaMeL Button . get CaMeL Shell ( ) ) ; font CaMeL Dialog . set CaMeL Font CaMeL Data ( chosen CaMeL Font ) ; Font CaMeL Data font = font CaMeL Dialog . open ( ) ; if ( font != null ) { Font CaMeL Data old CaMeL Font = chosen CaMeL Font ; set CaMeL Pres@@ ents CaMeL Default CaMeL Value ( false ) ; Font CaMeL Data [ ] new CaMeL Data = new Font CaMeL Data [ 1 ] ; new CaMeL Data [ 0 ] = font ; update CaMeL Font ( new CaMeL Data ) ; fire CaMeL Value CaMeL Changed ( VALUE , old CaMeL Font , font ) ; } } } ) ; change CaMeL Font CaMeL Button . add CaMeL Dispose CaMeL Listener ( new Dispose CaMeL Listener ( ) { public void widget CaMeL Disposed ( Dispose CaMeL Event event ) { change CaMeL Font CaMeL Button = null ; } } ) ; change CaMeL Font CaMeL Button . set CaMeL Font ( parent . get CaMeL Font ( ) ) ; set CaMeL Button CaMeL Layout CaMeL Data ( change CaMeL Font CaMeL Button ) ; } else { check CaMeL Parent ( change CaMeL Font CaMeL Button , parent ) ; } return change CaMeL Font CaMeL Button ; }	Font CaMeL Data [ ] old CaMeL Font = chosen CaMeL Font ;
return null ;  <CTX>  public String get CaMeL Description ( ) { return null ; }	return desc ;
if ( offset >= 0 && offset < my CaMeL Psi CaMeL File . get CaMeL Text CaMeL Length ( ) ) {  <CTX>  public Object get CaMeL Selector CaMeL In CaMeL File ( ) { final int offset = my CaMeL Editor . get CaMeL Editor ( ) . get CaMeL Caret CaMeL Model ( ) . get CaMeL Offset ( ) ; if ( offset >= 0 && offset < my CaMeL Psi CaMeL File . get CaMeL Text CaMeL Length ( ) ) { return my CaMeL Psi CaMeL File . find CaMeL Element CaMeL At ( offset ) ; } else { return super . get CaMeL Selector CaMeL In CaMeL File ( ) ; } }	if ( my CaMeL Psi CaMeL File instanceof Psi CaMeL Java CaMeL File && ! ( my CaMeL Psi CaMeL File instanceof Jsp CaMeL File ) && offset >= 0 && offset < my CaMeL Psi CaMeL File . get CaMeL Text CaMeL Length ( ) ) {
return ( ( y / zoom _ factor ) + scroll _ y ) ;  <CTX>  public int World CaMeL Y@@ to CaMeL Screen ( int y ) { return ( ( y / zoom _ factor ) + scroll _ y ) ; }	return ( ( y - scroll _ y ) * zoom _ factor ) ;
if ( current CaMeL Resource . get CaMeL Location ( ) == null ) {  <CTX>  protected boolean update CaMeL Selection ( I CaMeL Structured CaMeL Selection selection ) { if ( ! super . update CaMeL Selection ( selection ) ) return false ; if ( get CaMeL Selected CaMeL Non CaMeL Resources ( ) . size ( ) > 0 ) return false ; List selected CaMeL Resources = get CaMeL Selected CaMeL Resources ( ) ; if ( selected CaMeL Resources . size ( ) == 0 ) return false ; boolean proj CaMeL Selected = selection CaMeL Is CaMeL Of CaMeL Type ( I CaMeL Resource . PROJECT ) ; boolean file CaMeL Folders CaMeL Selected = selection CaMeL Is CaMeL Of CaMeL Type ( I CaMeL Resource . FILE | I CaMeL Resource . FOLDER ) ; if ( ! proj CaMeL Selected && ! file CaMeL Folders CaMeL Selected ) return false ; / / selection must be homo@@ geneous if ( proj CaMeL Selected && file CaMeL Folders CaMeL Selected ) return false ; / / must have a common parent I CaMeL Container first CaMeL Parent = ( ( I CaMeL Resource ) selected CaMeL Resources . get ( 0 ) ) . get CaMeL Parent ( ) ; if ( first CaMeL Parent == null ) return false ; Iterator resources CaMeL Enum = selected CaMeL Resources . iterator ( ) ; while ( resources CaMeL Enum . has CaMeL Next ( ) ) { I CaMeL Resource current CaMeL Resource = ( I CaMeL Resource ) resources CaMeL Enum . next ( ) ; if ( ! current CaMeL Resource . get CaMeL Parent ( ) . equals ( first CaMeL Parent ) ) { return false ; } / / resource location must exist if ( current CaMeL Resource . get CaMeL Location ( ) == null ) { return false ; } } return true ; }	if ( current CaMeL Resource . get CaMeL Location ( ) == null )
if ( children == null )  <CTX>  public List get CaMeL Children ( Object element ) { if ( children == null ) initialize ( ) ; return ( ( List ) children . get ( element ) ) ; }	if ( children == null ) {
assert ( this . context != null ) ; return this . scope . get ( name , this . scope ) ;  <CTX>  public Object lookup CaMeL Bean ( String name ) { assert ( this . context != null ) ; return this . scope . get ( name , this . scope ) ; }	assert ( context != null ) ; return scope . get ( name , scope ) ;
if ( _ match CaMeL Last == - 1 ) { _ source . reset ( ) ; int i = 1 , node ; while ( ( node = _ source . next ( ) ) != END ) { ++ i ; } _ match CaMeL Last = i - 1 ; }  <CTX>  public int get CaMeL Last ( ) { if ( _ match CaMeL Last == - 1 ) { _ source . reset ( ) ; int i = 1 , node ; while ( ( node = _ source . next ( ) ) != END ) { ++ i ; } _ match CaMeL Last = i - 1 ; } return _ match CaMeL Last ; }	if ( _ match CaMeL Last == - 1 ) _ match CaMeL Last = _ source . get CaMeL Last ( ) ;
switch ( id - id CaMeL Base ) {  <CTX>  protected void set CaMeL Instance CaMeL Id CaMeL Value ( int id , Object value ) { switch ( id - id CaMeL Base ) { case Id _ multiline : case Id _ STAR : get CaMeL Impl ( ) . multiline = Script CaMeL Runtime . to CaMeL Boolean ( value ) ; return ; case Id _ input : case Id _ UNDERSCORE : get CaMeL Impl ( ) . input = Script CaMeL Runtime . to CaMeL String ( value ) ; return ; } super . set CaMeL Instance CaMeL Id CaMeL Value ( id , value ) ; }	int shifted = id - super . get CaMeL Max CaMeL Instance CaMeL Id ( ) ; switch ( shifted ) {
get CaMeL Wizard CaMeL Context ( ) . get CaMeL Data CaMeL Service CaMeL Provider ( ) . set CaMeL Data CaMeL Set ( dataset CaMeL Name ) ;  <CTX>  private void switch CaMeL Data CaMeL Set ( String dataset CaMeL Name ) throws Chart CaMeL Exception { try { get CaMeL Wizard CaMeL Context ( ) . get CaMeL Data CaMeL Service CaMeL Provider ( ) . set CaMeL Data CaMeL Set ( dataset CaMeL Name ) ; table CaMeL Preview . clear CaMeL Contents ( ) ; / / Try to get report data set if ( dataset CaMeL Name == null ) { dataset CaMeL Name = get CaMeL Wizard CaMeL Context ( ) . get CaMeL Data CaMeL Service CaMeL Provider ( ) . get CaMeL Report CaMeL Data CaMeL Set ( ) ; } if ( dataset CaMeL Name != null ) { switch CaMeL Data CaMeL Table ( dataset CaMeL Name ) ; } else { table CaMeL Preview . create CaMeL Dummy CaMeL Table ( ) ; } table CaMeL Preview . layout ( ) ; } catch ( Throwable t ) { throw new Chart CaMeL Exception ( Chart CaMeL Engine CaMeL Plugin . ID , Chart CaMeL Exception . DATA _ BINDING , t ) ; } Data CaMeL Definition CaMeL Text CaMeL Manager . get CaMeL Instance ( ) . refresh CaMeL All ( ) ; do CaMeL Live CaMeL Preview ( ) ; }	get CaMeL Data CaMeL Service CaMeL Provider ( ) . set CaMeL Data CaMeL Set ( dataset CaMeL Name ) ;
return access ( check CaMeL Read ( ) , EXISTS ) ;  <CTX>  public boolean exists ( ) { return access ( check CaMeL Read ( ) , EXISTS ) ; }	check CaMeL Read ( ) ; return access ( EXISTS ) ;
Color CaMeL Definition definition = copy CaMeL Of CaMeL Definitions [ i ] ; install CaMeL Color ( definition , theme , store , true ) ;  <CTX>  public static void populate CaMeL Registry ( I CaMeL Theme theme , Color CaMeL Definition [ ] definitions , I CaMeL Preference CaMeL Store store ) { / / sort the definitions by dependant ordering so that we process / / ancestors before children . Color CaMeL Definition [ ] copy CaMeL Of CaMeL Definitions = null ; / / the colors to set a default value for , but not a registry value Color CaMeL Definition [ ] defaults = null ; if ( ! theme . get CaMeL Id ( ) . equals ( I CaMeL Theme CaMeL Manager . DEFAULT _ THEME ) ) { definitions = add CaMeL Defaulted ( definitions ) ; / / compute defaults only if we re setting preferences if ( store != null ) { defaults = get CaMeL Defaults ( definitions ) ; } } copy CaMeL Of CaMeL Definitions = new Color CaMeL Definition [ definitions . length ] ; System . arraycopy ( definitions , 0 , copy CaMeL Of CaMeL Definitions , 0 , definitions . length ) ; Arrays . sort ( copy CaMeL Of CaMeL Definitions , new I CaMeL Theme CaMeL Registry . Hierarchy CaMeL Comparator ( definitions ) ) ; for ( int i = 0 ; i < copy CaMeL Of CaMeL Definitions . length ; i ++ ) { Color CaMeL Definition definition = copy CaMeL Of CaMeL Definitions [ i ] ; install CaMeL Color ( definition , theme , store , true ) ; } if ( defaults != null ) { for ( int i = 0 ; i < defaults . length ; i ++ ) { install CaMeL Color ( defaults [ i ] , theme , store , false ) ; } } }	Font CaMeL Definition definition = copy CaMeL Of CaMeL Definitions [ i ] ; install CaMeL Font ( definition , theme , store , true ) ;
if ( lock CaMeL Res != Windows CaMeL On@@ screen CaMeL GL CaMeL Drawable . LOCK _ SURFACE _ NOT _ READY ) { drawable . unlock CaMeL Surface ( ) ;  <CTX>  protected int make CaMeL Current CaMeL Impl ( ) throws GL CaMeL Exception { int lock CaMeL Res = 0 ; try { lock CaMeL Res = drawable . lock CaMeL Surface ( ) ; if ( lock CaMeL Res == Windows CaMeL On@@ screen CaMeL GL CaMeL Drawable . LOCK _ SURFACE _ NOT _ READY ) { return CONTEXT _ NOT _ CURRENT ; } if ( lock CaMeL Res == Windows CaMeL On@@ screen CaMeL GL CaMeL Drawable . LOCK _ SURFACE _ CHANGED ) { destroy CaMeL Impl ( ) ; } int ret = super . make CaMeL Current CaMeL Impl ( ) ; return ret ; } finally { if ( lock CaMeL Res != Windows CaMeL On@@ screen CaMeL GL CaMeL Drawable . LOCK _ SURFACE _ NOT _ READY ) { drawable . unlock CaMeL Surface ( ) ; } } }	if ( is CaMeL Optimizable ( ) ) { if ( lock CaMeL Res != Windows CaMeL On@@ screen CaMeL GL CaMeL Drawable . LOCK _ SURFACE _ NOT _ READY ) { drawable . unlock CaMeL Surface ( ) ; }
message CaMeL Send . receiver . traverse ( this , scope ) ; return false ;  <CTX>  public boolean visit ( Message CaMeL Send message CaMeL Send , Block CaMeL Scope scope ) { if ( message CaMeL Send . receiver instanceof Message CaMeL Send ) { this . fragments CaMeL List . add ( 0 , message CaMeL Send ) ; message CaMeL Send . receiver . traverse ( this , scope ) ; return false ; } this . fragments CaMeL List . add ( 0 , message CaMeL Send ) ; this . fragments CaMeL List . add ( 1 , message CaMeL Send ) ; return false ; }	this . fragments CaMeL List . add ( 1 , message CaMeL Send ) ; } else { this . fragments CaMeL List . add ( 0 , message CaMeL Send ) ; this . fragments CaMeL List . add ( 1 , message CaMeL Send ) ;
Native CaMeL With ( Scriptable parent , Scriptable prototype ) { this . parent = parent ; this . prototype = prototype ;  <CTX>  Native CaMeL With ( Scriptable parent , Scriptable prototype ) { this . parent = parent ; this . prototype = prototype ; }	private Native CaMeL With ( ) {
Literal CaMeL Constraint constraint = ( Literal CaMeL Constraint ) this . node . get CaMeL Constraint ( ) ; Class CaMeL Field CaMeL Extractor extractor = ( Class CaMeL Field CaMeL Extractor ) constraint . get CaMeL Field CaMeL Extractor ( ) ; return extractor . get CaMeL Field CaMeL Name ( ) ;  <CTX>  public String get CaMeL Field CaMeL Name ( ) { Literal CaMeL Constraint constraint = ( Literal CaMeL Constraint ) this . node . get CaMeL Constraint ( ) ; Class CaMeL Field CaMeL Extractor extractor = ( Class CaMeL Field CaMeL Extractor ) constraint . get CaMeL Field CaMeL Extractor ( ) ; return extractor . get CaMeL Field CaMeL Name ( ) ; }	Alpha CaMeL Node CaMeL Field CaMeL Constraint constraint = this . node . get CaMeL Constraint ( ) ; if ( constraint instanceof Literal CaMeL Constraint ) { Literal CaMeL Constraint literal CaMeL Constraint = ( Literal CaMeL Constraint ) constraint ; Field CaMeL Extractor extractor = literal CaMeL Constraint . get CaMeL Field CaMeL Extractor ( ) ; if ( extractor instanceof Class CaMeL Field CaMeL Extractor ) { return ( ( Class CaMeL Field CaMeL Extractor ) extractor ) . get CaMeL Field CaMeL Name ( ) ; } } return null ;
return e . set CaMeL Value ( value ) ;  <CTX>  public Object put ( Object key , Object value ) { int idx = hash ( key ) ; Hash CaMeL Entry e = buckets [ idx ] ; while ( e != null ) { if ( equals ( key , e . key ) ) / / Must use this method for necessary book@@ keeping in Linked CaMeL Hash CaMeL Map . return e . set CaMeL Value ( value ) ; else e = e . next ; } / / At this point , we know we need to add a new entry . mod CaMeL Count ++ ; if ( ++ size > threshold ) { rehash ( ) ; / / Need a new hash value to su@@ it the bigger table . idx = hash ( key ) ; } / / Linked CaMeL Hash CaMeL Map cannot override put ( ) , h@@ ence this call . add CaMeL Entry ( key , value , idx , true ) ; return null ; }	{ e . access ( ) ; Object r = e . value ; e . value = value ; return r ; }
get CaMeL Component ( ) . set CaMeL Output CaMeL Markup CaMeL Id ( true ) ;  <CTX>  protected void on CaMeL Bind ( ) { get CaMeL Component ( ) . set CaMeL Output CaMeL Markup CaMeL Id ( true ) ; }	super . on CaMeL Bind ( ) ;
Binding CaMeL Event . EVENT _ COPY _ TO _ TARGET , Binding CaMeL Event . PI@@ PE@@ LINE _ AFTER _ GET ) ;  <CTX>  public void update CaMeL Target CaMeL From CaMeL Model ( ) { updating = true ; try { int size CaMeL To CaMeL Set CaMeL On CaMeL Target = model CaMeL List . size ( ) ; Binding CaMeL Event e = new Binding CaMeL Event ( model CaMeL List , target CaMeL List , null , Binding CaMeL Event . EVENT _ COPY _ TO _ TARGET , Binding CaMeL Event . PI@@ PE@@ LINE _ AFTER _ GET ) ; e . original CaMeL Value = new Integer ( size CaMeL To CaMeL Set CaMeL On CaMeL Target ) ; if ( failure ( err CaMeL Msg ( fire CaMeL Binding CaMeL Event ( e ) ) ) ) { return ; } target CaMeL List . set CaMeL Size ( size CaMeL To CaMeL Set CaMeL On CaMeL Target ) ; e . pipeline CaMeL Position = Binding CaMeL Event . PI@@ PE@@ LINE _ AFTER _ CHANGE ; if ( failure ( err CaMeL Msg ( fire CaMeL Binding CaMeL Event ( e ) ) ) ) { return ; } } finally { updating = false ; } }	org . eclipse . jface . databinding . Binding CaMeL Event . EVENT _ COPY _ TO _ TARGET , org . eclipse . jface . databinding . Binding CaMeL Event . PI@@ PE@@ LINE _ AFTER _ GET ) ;
return n . fold CaMeL Constants ( ts ) ;  <CTX>  public Node leave ( Node old , Node n , Node CaMeL Visitor v ) { return n . fold CaMeL Constants ( ts ) ; }	return n . fold CaMeL Constants ( ef ) ;
return e CaMeL Dynamic CaMeL Is CaMeL Set ( e CaMeL Feature ) ;  <CTX>  public boolean e CaMeL Is CaMeL Set ( E CaMeL Structural CaMeL Feature e CaMeL Feature ) { switch ( e CaMeL Derived CaMeL Structural CaMeL Feature CaMeL ID ( e CaMeL Feature ) ) { case Attribute CaMeL Package . URL _ VALUE _ _ BASE _ URL : return BASE _ URL _ EDEFAULT == null ? base CaMeL Url != null : ! BASE _ URL _ EDEFAULT . equals ( base CaMeL Url ) ; case Attribute CaMeL Package . URL _ VALUE _ _ TARGET : return TARGET _ EDEFAULT == null ? target != null : ! TARGET _ EDEFAULT . equals ( target ) ; case Attribute CaMeL Package . URL _ VALUE _ _ BASE _ PARAMETER _ NAME : return BASE _ PARAMETER _ NAME _ EDEFAULT == null ? base CaMeL Parameter CaMeL Name != null : ! BASE _ PARAMETER _ NAME _ EDEFAULT . equals ( base CaMeL Parameter CaMeL Name ) ; case Attribute CaMeL Package . URL _ VALUE _ _ VALUE _ PARAMETER _ NAME : return VALUE _ PARAMETER _ NAME _ EDEFAULT == null ? value CaMeL Parameter CaMeL Name != null : ! VALUE _ PARAMETER _ NAME _ EDEFAULT . equals ( value CaMeL Parameter CaMeL Name ) ; case Attribute CaMeL Package . URL _ VALUE _ _ SERIES _ PARAMETER _ NAME : return SERIES _ PARAMETER _ NAME _ EDEFAULT == null ? series CaMeL Parameter CaMeL Name != null : ! SERIES _ PARAMETER _ NAME _ EDEFAULT . equals ( series CaMeL Parameter CaMeL Name ) ; } return e CaMeL Dynamic CaMeL Is CaMeL Set ( e CaMeL Feature ) ; }	return super . e CaMeL Is CaMeL Set ( feature CaMeL ID ) ;
return typer . get CaMeL Parameter CaMeL Types ( ( Method CaMeL Info ) value ) [ j ] . get CaMeL Class CaMeL Name ( ) ;  <CTX>  private static void member _ helper _ type ( final Code CaMeL Emitter e , List members , final Object CaMeL Switch CaMeL Callback callback , final Parameter CaMeL Typer typer , final Label def , final Label end , final Bit CaMeL Set checked ) throws Exception { if ( members . size ( ) == 1 ) { Method CaMeL Info member = ( Method CaMeL Info ) members . get ( 0 ) ; Type [ ] types = typer . get CaMeL Parameter CaMeL Types ( member ) ; / / need to check classes that have not already been checked via switches for ( int i = 0 ; i < types . length ; i ++ ) { if ( checked == null || ! checked . get ( i ) ) { e . dup ( ) ; e . aaload ( i ) ; e . invoke _ virtual ( Constants . TYPE _ CLASS , GET _ NAME ) ; e . push ( types [ i ] . get CaMeL Class CaMeL Name ( ) ) ; e . invoke _ virtual ( Constants . TYPE _ OBJECT , EQUALS ) ; e . if _ jump ( e . EQ , def ) ; } } e . pop ( ) ; callback . process CaMeL Case ( member , end ) ; } else { / / choose the index that has the best chance of uni@@ qu@@ ely identifying member Type [ ] example = typer . get CaMeL Parameter CaMeL Types ( ( Method CaMeL Info ) members . get ( 0 ) ) ; Map buckets = null ; int index = - 1 ; for ( int i = 0 ; i < example . length ; i ++ ) { final int j = i ; Map test = Collection CaMeL Utils . bucket ( members , new Transformer ( ) { public Object transform ( Object value ) { return typer . get CaMeL Parameter CaMeL Types ( ( Method CaMeL Info ) value ) [ j ] . get CaMeL Class CaMeL Name ( ) ; } } ) ; if ( buckets == null || test . size ( ) > buckets . size ( ) ) { buckets = test ; index = i ; } } if ( buckets == null ) { / / TODO : switch by return CaMeL Type / / must have two methods with same name , types , and different return types e . go CaMeL To ( def ) ; } else { checked . set ( index ) ; e . dup ( ) ; e . aaload ( index ) ; e . invoke _ virtual ( Constants . TYPE _ CLASS , GET _ NAME ) ; final Map f@@ buckets = buckets ; String [ ] names = ( String [ ] ) buckets . key CaMeL Set ( ) . to CaMeL Array ( new String [ buckets . size ( ) ] ) ; Emit CaMeL Utils . string _ switch ( e , names , Constants . SWITCH _ STYLE _ HASH , new Object CaMeL Switch CaMeL Callback ( ) { public void process CaMeL Case ( Object key , Label dont CaMeL Use CaMeL End ) throws Exception { member _ helper _ type ( e , ( List ) f@@ buckets . get ( key ) , callback , typer , def , end , checked ) ; } public void process CaMeL Default ( ) throws Exception { e . go CaMeL To ( def ) ; } } ) ; } } }	return Type CaMeL Utils . emulate CaMeL Class CaMeL Get CaMeL Name ( typer . get CaMeL Parameter CaMeL Types ( ( Method CaMeL Info ) value ) [ j ] ) ;
set CaMeL Row CaMeL Column ( index , column , true ) ;  <CTX>  void key CaMeL Down ( Event event ) { if ( table . get CaMeL Item CaMeL Count ( ) == 0 ) return ; switch ( event . character ) { case SWT . CR : notify CaMeL Listeners ( SWT . Default CaMeL Selection , new Event ( ) ) ; return ; } switch ( event . key CaMeL Code ) { case SWT . ARROW _ UP : set CaMeL Row CaMeL Column ( Math . max ( 0 , row - 1 ) , column , true ) ; break ; case SWT . ARROW _ DOWN : set CaMeL Row CaMeL Column ( Math . min ( row + 1 , table . get CaMeL Item CaMeL Count ( ) - 1 ) , column , true ) ; break ; case SWT . ARROW _ LEFT : case SWT . ARROW _ RIGHT : { int lead CaMeL Key = ( get CaMeL Style ( ) & SWT . RIGHT _ TO _ LEFT ) != 0 ? SWT . ARROW _ RIGHT : SWT . ARROW _ LEFT ; if ( event . key CaMeL Code == lead CaMeL Key ) { set CaMeL Row CaMeL Column ( row , Math . max ( 0 , column - 1 ) , true ) ; } else { set CaMeL Row CaMeL Column ( row , Math . min ( table . get CaMeL Column CaMeL Count ( ) - 1 , column + 1 ) , true ) ; } break ; } case SWT . HOME : set CaMeL Row CaMeL Column ( 0 , column , true ) ; break ; case SWT . END : { int i = table . get CaMeL Item CaMeL Count ( ) - 1 ; set CaMeL Row CaMeL Column ( i , column , true ) ; break ; } case SWT . PAGE _ UP : { int index = table . get CaMeL Top CaMeL Index ( ) ; if ( index == row ) { Rectangle rect = table . get CaMeL Client CaMeL Area ( ) ; Table CaMeL Item item = table . get CaMeL Item ( index ) ; Rectangle item CaMeL Rect = item . get CaMeL Bounds ( 0 ) ; rect . height -= item CaMeL Rect . y ; int height = table . get CaMeL Item CaMeL Height ( ) ; int page = Math . max ( 1 , rect . height / height ) ; index = Math . max ( 0 , index - page + 1 ) ; } set CaMeL Row CaMeL Column ( index , column , true ) ; break ; } case SWT . PAGE _ DOWN : { int index = table . get CaMeL Top CaMeL Index ( ) ; Rectangle rect = table . get CaMeL Client CaMeL Area ( ) ; Table CaMeL Item item = table . get CaMeL Item ( index ) ; Rectangle item CaMeL Rect = item . get CaMeL Bounds ( 0 ) ; rect . height -= item CaMeL Rect . y ; int height = table . get CaMeL Item CaMeL Height ( ) ; int page = Math . max ( 1 , rect . height / height ) ; int end = table . get CaMeL Item CaMeL Count ( ) - 1 ; index = Math . min ( end , index + page - 1 ) ; if ( index == row ) { index = Math . min ( end , index + page - 1 ) ; } set CaMeL Row CaMeL Column ( index , column , true ) ; break ; } } }	set CaMeL Row CaMeL Column ( index , column CaMeL Index , true ) ;
Context CaMeL Expression expression ; expression = new Context CaMeL Expression ( context CaMeL Id , expression CaMeL Info ) ;  <CTX>  private void create CaMeL Handler CaMeL Activation ( String context CaMeL Id , String handler CaMeL Id , String [ ] expression CaMeL Info ) { Context CaMeL Expression expression ; expression = new Context CaMeL Expression ( context CaMeL Id , expression CaMeL Info ) ; make CaMeL Handler ( handler CaMeL Id , context CaMeL Id , expression ) ; }	Active CaMeL Context CaMeL Expression expression ; expression = new Active CaMeL Context CaMeL Expression ( context CaMeL Id , expression CaMeL Info ) ;
int last CaMeL Line CaMeL Length ) {  <CTX>  public Here CaMeL Doc CaMeL Node ( I CaMeL Source CaMeL Position position , String value , int func , int last CaMeL Line CaMeL Length ) { this . value = value ; this . func = func ; this . last CaMeL Line CaMeL Length = last CaMeL Line CaMeL Length ; }	String last CaMeL Line ) { super ( position ) ;
} ;  <CTX>  public void process CaMeL Packet ( Packet packet ) { / / Get the MUC User extension MUC CaMeL User muc CaMeL User = get CaMeL MUC CaMeL User CaMeL Extension ( packet ) ; / / Check if the MUC CaMeL User in@@ forms that the invitee has dec@@ lined the invitation if ( muc CaMeL User . get CaMeL Dec@@ line ( ) != null ) { / / Fire event for invitation re@@ jection listeners fire CaMeL Invitation CaMeL Rejection CaMeL Listeners ( muc CaMeL User . get CaMeL Dec@@ line ( ) . get CaMeL From ( ) , muc CaMeL User . get CaMeL Dec@@ line ( ) . get CaMeL Reason ( ) ) ; } } ;	else if ( presence . get CaMeL Type ( ) == Presence . Type . UNAVAILABLE ) { synchronized ( participants CaMeL Map ) { participants CaMeL Map . remove ( from ) ; } } }
boot CaMeL Image = new byte [ BOOT _ IMAGE _ SIZE . to CaMeL Int ( ) ] ;  <CTX>  Boot CaMeL Image ( boolean l@@ tl CaMeL Endian , boolean t ) { boot CaMeL Image = new byte [ BOOT _ IMAGE _ SIZE . to CaMeL Int ( ) ] ; little CaMeL Endian = l@@ tl CaMeL Endian ; trace = t ; }	boot CaMeL Image = new byte [ BOOT _ IMAGE _ SIZE ] ;
Word CaMeL Completion CaMeL Data . All CaMeL Words CaMeL Getter getter = new Word CaMeL Completion CaMeL Data . All CaMeL Words CaMeL Getter ( ) ;  <CTX>  private static Object [ ] get CaMeL All CaMeL Words CaMeL From CaMeL Document ( Psi CaMeL Element context , Completion CaMeL Context completion CaMeL Context ) { Word CaMeL Completion CaMeL Data . All CaMeL Words CaMeL Getter getter = new Word CaMeL Completion CaMeL Data . All CaMeL Words CaMeL Getter ( ) ; return getter . get ( context , completion CaMeL Context ) ; }	All CaMeL Words CaMeL Getter getter = new All CaMeL Words CaMeL Getter ( ) ;
stat CaMeL Display CaMeL Text . put ( new Integer ( stat CaMeL Value ) , stat CaMeL Text ) ;  <CTX>  public void add CaMeL Stat CaMeL Display CaMeL Text ( final int stat CaMeL Value , final String stat CaMeL Text ) { if ( stat CaMeL Display CaMeL Text == null ) { / / Sort NUMER@@ IC@@ ALLY , not alphabe@@ tically ! stat CaMeL Display CaMeL Text = new Tree CaMeL Map ( new Comparable CaMeL Comparator ( ) ) ; } stat CaMeL Display CaMeL Text . put ( new Integer ( stat CaMeL Value ) , stat CaMeL Text ) ; }	stat CaMeL Display CaMeL Text . put ( stat CaMeL Value , stat CaMeL Text ) ;
i CaMeL Visited . accept ( _ Payload ) ;  <CTX>  public void visit CaMeL Args CaMeL Node ( Args CaMeL Node i CaMeL Visited ) { i CaMeL Visited . accept ( _ Payload ) ; Node l CaMeL Opt CaMeL Node = i CaMeL Visited . get CaMeL Opt CaMeL Node ( ) ; if ( l CaMeL Opt CaMeL Node != null ) { l CaMeL Opt CaMeL Node . accept ( this ) ; } }	_ Payload . visit CaMeL Args CaMeL Node ( i CaMeL Visited ) ;
this . last CaMeL Modified CaMeL Time = last CaMeL Modified CaMeL Time ;  <CTX>  public void set CaMeL Last CaMeL Modified CaMeL Time ( long last CaMeL Modified CaMeL Time ) { this . last CaMeL Modified CaMeL Time = last CaMeL Modified CaMeL Time ; }	if ( last CaMeL Modified CaMeL Time > 0 ) { this . last CaMeL Modified CaMeL Time = last CaMeL Modified CaMeL Time ; }
Weak@@ ish CaMeL Reference ref = ( Weak@@ ish CaMeL Reference ) task CaMeL Enum . next CaMeL Element ( ) ;  <CTX>  private void invalidate CaMeL Created CaMeL Tasks ( String type ) { synchronized ( created CaMeL Tasks ) { Vector v = ( Vector ) created CaMeL Tasks . get ( type ) ; if ( v != null ) { Enumeration task CaMeL Enum = v . elements ( ) ; while ( task CaMeL Enum . has CaMeL More CaMeL Elements ( ) ) { Weak@@ ish CaMeL Reference ref = ( Weak@@ ish CaMeL Reference ) task CaMeL Enum . next CaMeL Element ( ) ; Task t = ( Task ) ref . get ( ) ; / / being a weak ref , it may be null by this point if ( t != null ) { t . mark CaMeL Invalid ( ) ; } } v . remove CaMeL All CaMeL Elements ( ) ; created CaMeL Tasks . remove ( type ) ; } } }	Weak CaMeL Reference ref = ( Weak CaMeL Reference ) task CaMeL Enum . next CaMeL Element ( ) ;
create CaMeL Preview CaMeL Dialog ( ) ;  <CTX>  public void set CaMeL User CaMeL Agent ( FO CaMeL User CaMeL Agent fo CaMeL User CaMeL Agent ) { super . set CaMeL User CaMeL Agent ( fo CaMeL User CaMeL Agent ) ; if ( dialog CaMeL Display ) { create CaMeL Preview CaMeL Dialog ( ) ; } }	set CaMeL Status CaMeL Listener ( Preview CaMeL Dialog . create CaMeL Preview CaMeL Dialog ( user CaMeL Agent , this . renderable ) ) ;
return _ pkg ;  <CTX>  public J CaMeL Package get CaMeL Package ( ) { if ( _ parent != null ) { return _ parent . get CaMeL Package ( ) ; } else { return _ pkg ; } }	return pkg ;
the CaMeL Component CaMeL Package . initialize CaMeL Package CaMeL Contents ( ) ;  <CTX>  public static Type CaMeL Package init ( ) { if ( is CaMeL Inited ) return ( Type CaMeL Package ) E CaMeL Package . Registry . INSTANCE . get CaMeL E CaMeL Package ( Type CaMeL Package . e CaMeL NS _ URI ) ; / / Obtain or create and register package Type CaMeL Package CaMeL Impl the CaMeL Type CaMeL Package = ( Type CaMeL Package CaMeL Impl ) ( E CaMeL Package . Registry . INSTANCE . get CaMeL E CaMeL Package ( e CaMeL NS _ URI ) instanceof Type CaMeL Package CaMeL Impl ? E CaMeL Package . Registry . INSTANCE . get CaMeL E CaMeL Package ( e CaMeL NS _ URI ) : new Type CaMeL Package CaMeL Impl ( ) ) ; is CaMeL Inited = true ; / / Initialize simple dependencies XML CaMeL Type CaMeL Package CaMeL Impl . init ( ) ; / / Obtain or create and register inter@@ dependencies Attribute CaMeL Package CaMeL Impl the CaMeL Attribute CaMeL Package = ( Attribute CaMeL Package CaMeL Impl ) ( E CaMeL Package . Registry . INSTANCE . get CaMeL E CaMeL Package ( Attribute CaMeL Package . e CaMeL NS _ URI ) instanceof Attribute CaMeL Package CaMeL Impl ? E CaMeL Package . Registry . INSTANCE . get CaMeL E CaMeL Package ( Attribute CaMeL Package . e CaMeL NS _ URI ) : Attribute CaMeL Package CaMeL Impl . e CaMeL INSTANCE ) ; Component CaMeL Package CaMeL Impl the CaMeL Component CaMeL Package = ( Component CaMeL Package CaMeL Impl ) ( E CaMeL Package . Registry . INSTANCE . get CaMeL E CaMeL Package ( Component CaMeL Package . e CaMeL NS _ URI ) instanceof Component CaMeL Package CaMeL Impl ? E CaMeL Package . Registry . INSTANCE . get CaMeL E CaMeL Package ( Component CaMeL Package . e CaMeL NS _ URI ) : Component CaMeL Package CaMeL Impl . e CaMeL INSTANCE ) ; Layout CaMeL Package CaMeL Impl the CaMeL Layout CaMeL Package = ( Layout CaMeL Package CaMeL Impl ) ( E CaMeL Package . Registry . INSTANCE . get CaMeL E CaMeL Package ( Layout CaMeL Package . e CaMeL NS _ URI ) instanceof Layout CaMeL Package CaMeL Impl ? E CaMeL Package . Registry . INSTANCE . get CaMeL E CaMeL Package ( Layout CaMeL Package . e CaMeL NS _ URI ) : Layout CaMeL Package CaMeL Impl . e CaMeL INSTANCE ) ; Data CaMeL Package CaMeL Impl the CaMeL Data CaMeL Package = ( Data CaMeL Package CaMeL Impl ) ( E CaMeL Package . Registry . INSTANCE . get CaMeL E CaMeL Package ( Data CaMeL Package . e CaMeL NS _ URI ) instanceof Data CaMeL Package CaMeL Impl ? E CaMeL Package . Registry . INSTANCE . get CaMeL E CaMeL Package ( Data CaMeL Package . e CaMeL NS _ URI ) : Data CaMeL Package CaMeL Impl . e CaMeL INSTANCE ) ; Model CaMeL Package CaMeL Impl the CaMeL Model CaMeL Package = ( Model CaMeL Package CaMeL Impl ) ( E CaMeL Package . Registry . INSTANCE . get CaMeL E CaMeL Package ( Model CaMeL Package . e CaMeL NS _ URI ) instanceof Model CaMeL Package CaMeL Impl ? E CaMeL Package . Registry . INSTANCE . get CaMeL E CaMeL Package ( Model CaMeL Package . e CaMeL NS _ URI ) : Model CaMeL Package CaMeL Impl . e CaMeL INSTANCE ) ; / / Create package meta - data objects the CaMeL Type CaMeL Package . create CaMeL Package CaMeL Contents ( ) ; the CaMeL Attribute CaMeL Package . create CaMeL Package CaMeL Contents ( ) ; the CaMeL Component CaMeL Package . create CaMeL Package CaMeL Contents ( ) ; the CaMeL Layout CaMeL Package . create CaMeL Package CaMeL Contents ( ) ; the CaMeL Data CaMeL Package . create CaMeL Package CaMeL Contents ( ) ; the CaMeL Model CaMeL Package . create CaMeL Package CaMeL Contents ( ) ; / / Initialize created meta - data the CaMeL Type CaMeL Package . initialize CaMeL Package CaMeL Contents ( ) ; the CaMeL Attribute CaMeL Package . initialize CaMeL Package CaMeL Contents ( ) ; the CaMeL Component CaMeL Package . initialize CaMeL Package CaMeL Contents ( ) ; the CaMeL Layout CaMeL Package . initialize CaMeL Package CaMeL Contents ( ) ; the CaMeL Data CaMeL Package . initialize CaMeL Package CaMeL Contents ( ) ; the CaMeL Model CaMeL Package . initialize CaMeL Package CaMeL Contents ( ) ; / / Mark meta - data to indicate it can t be changed the CaMeL Type CaMeL Package . freeze ( ) ; return the CaMeL Type CaMeL Package ; }	the CaMeL Data CaMeL Package . initialize CaMeL Package CaMeL Contents ( ) ;
b . set CaMeL Horizontal CaMeL Alignment ( S CaMeL Radio CaMeL Button . CENTER ) ; b . set CaMeL Vertical CaMeL Alignment ( S CaMeL Radio CaMeL Button . CENTER ) ;  <CTX>  void decorate CaMeL Button ( S CaMeL Radio CaMeL Button b ) { b . set CaMeL Icon ( n@@ sel ) ; b . set CaMeL Selected CaMeL Icon ( sel ) ; b . set CaMeL Rollover CaMeL Icon ( rol@@ ln@@ sel ) ; b . set CaMeL Rollover CaMeL Selected CaMeL Icon ( roll@@ sel ) ; b . set CaMeL Pressed CaMeL Icon ( pressed ) ; b . set CaMeL Horizontal CaMeL Alignment ( S CaMeL Radio CaMeL Button . CENTER ) ; b . set CaMeL Vertical CaMeL Alignment ( S CaMeL Radio CaMeL Button . CENTER ) ; }	b . set CaMeL Horizontal CaMeL Alignment ( S CaMeL Constants . CENTER ) ; b . set CaMeL Vertical CaMeL Alignment ( S CaMeL Constants . CENTER ) ;
goto CaMeL Item . set CaMeL Enabled ( link CaMeL List != null && ! ( link CaMeL List instanceof Index ) ) ;  <CTX>  protected void update CaMeL Right CaMeL Click CaMeL Menu ( Vector selected CaMeL Links ) { Link CaMeL Management CaMeL Helper . Link CaMeL Action action ; for ( Iterator it = right CaMeL Click CaMeL Actions . iterator ( ) ; it . has CaMeL Next ( ) ; ) { action = ( Link CaMeL Management CaMeL Helper . Link CaMeL Action ) it . next ( ) ; action . set CaMeL Target ( selected CaMeL Links ) ; } goto CaMeL Item . set CaMeL Enabled ( link CaMeL List != null && ! ( link CaMeL List instanceof Index ) ) ; }	goto CaMeL Item . set CaMeL Enabled ( ( link CaMeL List != null ) && ! ( link CaMeL List instanceof Index ) ) ;
} else if ( adapter == I CaMeL Navigator CaMeL Content CaMeL Service . class ) {  <CTX>  public Object get CaMeL Adapter ( Class adapter ) { if ( adapter == Common CaMeL Viewer . class ) { return get CaMeL Common CaMeL Viewer ( ) ; } else if ( adapter == I CaMeL Navigator CaMeL Content CaMeL Service . class ) { return get CaMeL Common CaMeL Viewer ( ) . get CaMeL Navigator CaMeL Content CaMeL Service ( ) ; } return super . get CaMeL Adapter ( adapter ) ; }	} else if ( adapter == IN@@ AVI@@ G@@ ATOR _ CONTENT _ SERVICE ) {
item . set CaMeL Enabled ( current CaMeL Part != null && site . is CaMeL Movable ( current CaMeL Part ) ) ;  <CTX>  private void add CaMeL Move CaMeL Items ( Menu move CaMeL Menu , String move CaMeL Pane , String move CaMeL Site ) { final Display display = move CaMeL Menu . get CaMeL Display ( ) ; / / Add move view only menu item Menu CaMeL Item item = new Menu CaMeL Item ( move CaMeL Menu , SWT . NONE ) ; item . set CaMeL Text ( move CaMeL Pane ) ; / / $ NON - NLS - 1 $ item . add CaMeL Selection CaMeL Listener ( new Selection CaMeL Adapter ( ) { public void widget CaMeL Selected ( Selection CaMeL Event e ) { site . drag CaMeL Start ( current CaMeL Part , display . get CaMeL Cursor CaMeL Location ( ) , true ) ; } } ) ; item . set CaMeL Enabled ( current CaMeL Part != null && site . is CaMeL Movable ( current CaMeL Part ) ) ; / / Add move view s tab folder menu item item = new Menu CaMeL Item ( move CaMeL Menu , SWT . NONE ) ; item . set CaMeL Text ( move CaMeL Site ) ; / / $ NON - NLS - 1 $ item . add CaMeL Selection CaMeL Listener ( new Selection CaMeL Adapter ( ) { public void widget CaMeL Selected ( Selection CaMeL Event e ) { site . drag CaMeL Start ( display . get CaMeL Cursor CaMeL Location ( ) , true ) ; } } ) ; item . set CaMeL Enabled ( true ) ; }	item . set CaMeL Enabled ( current CaMeL Part != null && site . is CaMeL Moveable ( current CaMeL Part ) ) ;
assemble CaMeL War ( monitor ) ; break ;  <CTX>  public void assemble ( I CaMeL Progress CaMeL Monitor monitor ) throws Core CaMeL Exception { switch ( assemble CaMeL Type ) { case WAR : assemble CaMeL War ( monitor ) ; break ; case EAR : assemble CaMeL Ear ( monitor ) ; break ; case OTHER : assemble CaMeL Other ( monitor ) ; break ; } }	return assemble CaMeL War ( monitor ) ;
super ( position ) ;  <CTX>  public V CaMeL Alias CaMeL Node ( I CaMeL Source CaMeL Position position , String new CaMeL Name , String old CaMeL Name ) { super ( position ) ; this . old CaMeL Name = old CaMeL Name . intern ( ) ; this . new CaMeL Name = new CaMeL Name . intern ( ) ; }	super ( position , Node CaMeL Types . VAL@@ I@@ AS@@ NODE ) ;
return image ;  <CTX>  public Image get CaMeL Description CaMeL Image ( ) { return image ; }	return null ;
experiment CaMeL Copy . save CaMeL To CaMeL Db ( save CaMeL To CaMeL Db CaMeL Conflict CaMeL Handler ) ; GUI CaMeL Utils . time CaMeL Consuming CaMeL Task CaMeL End ( organizer ) ; }  <CTX>  public void run ( ) { experiment CaMeL Copy . save CaMeL To CaMeL Db ( save CaMeL To CaMeL Db CaMeL Conflict CaMeL Handler ) ; GUI CaMeL Utils . time CaMeL Consuming CaMeL Task CaMeL End ( organizer ) ; }	society CaMeL Copy . save CaMeL To CaMeL Database ( ) ; GUI CaMeL Utils . time CaMeL Consuming CaMeL Task CaMeL End ( organizer ) ; }
return Collections . EMPTY _ SET ;  <CTX>  public Set get CaMeL Variable CaMeL Names CaMeL As CaMeL Unmodifiable CaMeL Set ( ) { if ( domain != null ) { return domain . get CaMeL Variable CaMeL Names CaMeL As CaMeL Unmodifiable CaMeL Set ( ) ; } return Collections . EMPTY _ SET ; }	return Collections . empty CaMeL Set ( ) ;
Partial CaMeL Timestamp pt = new Partial CaMeL Timestamp ( ) ;  <CTX>  public Object clone ( ) { Partial CaMeL Timestamp pt = new Partial CaMeL Timestamp ( ) ; for ( int field = CEN@@ TUR@@ Y ; field < FIELD _ COUNT ; field ++ ) { pt . modifiers [ field ] = this . modifiers [ field ] ; pt . fields [ field ] = this . fields [ field ] ; / * Make sure set fields are marked as set . * / if ( this . is CaMeL Set ( field ) ) { pt . set ( field , pt . internal CaMeL Get ( field ) ) ; } } pt . last CaMeL Hour CaMeL Set = this . last CaMeL Hour CaMeL Set ; pt . fields CaMeL Modified = this . fields CaMeL Modified ; pt . day CaMeL Of CaMeL Month CaMeL Set = this . day CaMeL Of CaMeL Month CaMeL Set ; pt . day CaMeL Of CaMeL Week CaMeL In CaMeL Month CaMeL Set = this . day CaMeL Of CaMeL Week CaMeL In CaMeL Month CaMeL Set ; pt . day CaMeL Of CaMeL Year CaMeL Set = this . day CaMeL Of CaMeL Year CaMeL Set ; pt . week CaMeL Of CaMeL Month CaMeL Set = this . week CaMeL Of CaMeL Month CaMeL Set ; pt . week CaMeL Of CaMeL Year CaMeL Set = this . week CaMeL Of CaMeL Year CaMeL Set ; pt . month CaMeL Set = this . month CaMeL Set ; pt . day CaMeL Stamp = this . day CaMeL Stamp ; return pt ; }	Partial CaMeL Timestamp pt = ( Partial CaMeL Timestamp ) super . clone ( ) ; pt . modifiers = new int [ FIELD _ COUNT ] ;
boolean replace CaMeL Previous CaMeL Binding ) throws Pro CaMeL Active CaMeL Exception {  <CTX>  public void register CaMeL Virtual CaMeL Node ( String virtual CaMeL Node CaMeL Name , boolean replace CaMeL Previous CaMeL Binding ) throws Pro CaMeL Active CaMeL Exception { try { pro CaMeL Active CaMeL Runtime . register CaMeL Virtual CaMeL Node ( ur@@ id , virtual CaMeL Node CaMeL Name , replace CaMeL Previous CaMeL Binding ) ; } catch ( IO CaMeL Exception e ) { throw new Pro CaMeL Active CaMeL Exception ( e ) ; } }	boolean replace CaMeL Previous CaMeL Binding ) throws Pro CaMeL Active CaMeL Exception , Already CaMeL Bound CaMeL Exception {
end CaMeL BB ( ) ; next CaMeL Is CaMeL Successor = false ;  <CTX>  public void visit _ return ( ) { end CaMeL BB ( ) ; next CaMeL Is CaMeL Successor = false ; }	end CaMeL BB ( false ) ;
if ( ( old CaMeL Value & GC _ FORWAR@@ DING _ MASK ) == GC _ FORWARDED ) return old CaMeL Value ; } while ( ! VM _ Interface . attempt CaMeL Available CaMeL Bits ( base , old CaMeL Value , old CaMeL Value | GC _ BEING _ FORWARDED ) ) ;  <CTX>  static int attempt CaMeL To CaMeL Forward ( VM _ Address base ) throws VM _ Pragma CaMeL Inline , VM _ Pragma CaMeL Uninterruptible { int old CaMeL Value ; do { old CaMeL Value = VM _ Interface . prepare CaMeL Available CaMeL Bits ( base ) ; if ( ( old CaMeL Value & GC _ FORWAR@@ DING _ MASK ) == GC _ FORWARDED ) return old CaMeL Value ; } while ( ! VM _ Interface . attempt CaMeL Available CaMeL Bits ( base , old CaMeL Value , old CaMeL Value | GC _ BEING _ FORWARDED ) ) ; return old CaMeL Value ; }	if ( old CaMeL Value . and ( GC _ FORWAR@@ DING _ MASK ) . EQ ( GC _ FORWARDED ) ) return old CaMeL Value ; } while ( ! VM _ Interface . attempt CaMeL Available CaMeL Bits ( base , old CaMeL Value , old CaMeL Value . or ( GC _ BEING _ FORWARDED ) ) ) ;
open CaMeL Project CaMeL Item CaMeL Action CaMeL Performed ( evt ) ;  <CTX>  public void action CaMeL Performed ( java . awt . event . Action CaMeL Event evt ) { open CaMeL Project CaMeL Item CaMeL Action CaMeL Performed ( evt ) ; }	new CaMeL Project CaMeL Item CaMeL Action CaMeL Performed ( evt ) ;
super ( ts ) ; interfaces = new Typed CaMeL List ( new Linked CaMeL List ( ) , Class CaMeL Type . class , false ) ; methods = new Typed CaMeL List ( new Linked CaMeL List ( ) , Method CaMeL Type CaMeL Instance . class , false ) ; fields = new Typed CaMeL List ( new Linked CaMeL List ( ) , Field CaMeL Instance . class , false ) ; inner CaMeL Classes = new Typed CaMeL List ( new Linked CaMeL List ( ) , Class CaMeL Type . class , false ) ; this . containing CaMeL Class = containing CaMeL Class ;  <CTX>  public Parsed CaMeL Class CaMeL Type ( Type CaMeL System ts , Class CaMeL Type containing CaMeL Class ) { super ( ts ) ; interfaces = new Typed CaMeL List ( new Linked CaMeL List ( ) , Class CaMeL Type . class , false ) ; methods = new Typed CaMeL List ( new Linked CaMeL List ( ) , Method CaMeL Type CaMeL Instance . class , false ) ; fields = new Typed CaMeL List ( new Linked CaMeL List ( ) , Field CaMeL Instance . class , false ) ; inner CaMeL Classes = new Typed CaMeL List ( new Linked CaMeL List ( ) , Class CaMeL Type . class , false ) ; this . containing CaMeL Class = containing CaMeL Class ; }	this ( ts , null ) ;
charts . get CaMeL Code CaMeL Distribution CaMeL Chart ( author )  <CTX>  public Abstract CaMeL Chart [ ] get CaMeL Charts ( ) { return new Abstract CaMeL Chart [ ] { charts . get CaMeL Activity CaMeL By CaMeL Hour CaMeL Chart ( author ) , charts . get CaMeL Activity CaMeL By CaMeL Day CaMeL Chart ( author ) , charts . get CaMeL Code CaMeL Distribution CaMeL Chart ( author ) } ; }	charts . get CaMeL Directory CaMeL Sizes CaMeL Chart ( author )
return exec ( cmd , null , null ) ;  <CTX>  public Process exec ( String [ ] cmd ) throws IO CaMeL Exception { return exec ( cmd , null , null ) ; }	return exec ( cmdline , null , null ) ;
Saveable CaMeL Model CaMeL Manager sav@@ eable CaMeL Model CaMeL Manager = null ;  <CTX>  public void hide CaMeL View ( I CaMeL View CaMeL Reference ref ) { / / Sanity check . if ( ref == null ) { return ; } Perspective per@@ sp = get CaMeL Active CaMeL Perspective ( ) ; if ( per@@ sp == null ) { return ; } I CaMeL View CaMeL Part view = ref . get CaMeL View ( false ) ; if ( view != null ) { if ( ! cer@@ tify CaMeL Part ( view ) ) { return ; } / / Confirm . if ( ! per@@ sp . can CaMeL Close CaMeL View ( view ) ) { return ; } } int ref CaMeL Count = get CaMeL View CaMeL Factory ( ) . get CaMeL Reference CaMeL Count ( ref ) ; Saveable CaMeL Model CaMeL Manager sav@@ eable CaMeL Model CaMeL Manager = null ; Object post CaMeL Close CaMeL Info = null ; if ( ref CaMeL Count == 1 ) { I CaMeL Workbench CaMeL Part actual CaMeL Part = ref . get CaMeL Part ( false ) ; if ( actual CaMeL Part != null ) { sav@@ eable CaMeL Model CaMeL Manager = ( Saveable CaMeL Model CaMeL Manager ) actual CaMeL Part . get CaMeL Site ( ) . get CaMeL Service ( I CaMeL Saveable CaMeL Model CaMeL Manager . class ) ; post CaMeL Close CaMeL Info = sav@@ eable CaMeL Model CaMeL Manager . pre CaMeL Close CaMeL Parts ( Collections . singleton CaMeL List ( actual CaMeL Part ) , true , this . get CaMeL Workbench CaMeL Window ( ) ) ; if ( post CaMeL Close CaMeL Info == null ) { / / cancel return ; } } } / / Notify interested listeners before the hide window . fire CaMeL Perspective CaMeL Changed ( this , per@@ sp . get CaMeL Desc ( ) , ref , CHANGE _ VIEW _ HIDE ) ; Part CaMeL Pane pane = get CaMeL Pane ( ref ) ; pane . set CaMeL In CaMeL Layout ( false ) ; update CaMeL Active CaMeL Part ( ) ; / / Hide the part . per@@ sp . hide CaMeL View ( ref ) ; / / Notify interested listeners after the hide window . fire CaMeL Perspective CaMeL Changed ( this , get CaMeL Perspective ( ) , CHANGE _ VIEW _ HIDE ) ; if ( sav@@ eable CaMeL Model CaMeL Manager != null ) { sav@@ eable CaMeL Model CaMeL Manager . post CaMeL Close ( post CaMeL Close CaMeL Info ) ; } }	Save@@ ables CaMeL List save@@ ables CaMeL List = null ;
return match . get CaMeL Start CaMeL Index ( group ) ;  <CTX>  public int start ( int group ) throws Illegal CaMeL State CaMeL Exception { assert CaMeL Match CaMeL Op ( ) ; return match . get CaMeL Start CaMeL Index ( group ) ; }	return match . get CaMeL Start CaMeL Index ( ) ;
Mode mode = j CaMeL Edit . get CaMeL Mode ( ctx . rules . get CaMeL Mode CaMeL Name ( ) ) ;  <CTX>  private List < Indent CaMeL Rule > get CaMeL Indent CaMeL Rules ( int line ) { Token CaMeL Marker . Line CaMeL Context ctx = line CaMeL Mgr . get CaMeL Line CaMeL Context ( line ) ; Mode mode = j CaMeL Edit . get CaMeL Mode ( ctx . rules . get CaMeL Mode CaMeL Name ( ) ) ; return mode . get CaMeL Indent CaMeL Rules ( ) ; } / / } } }	Mode mode ; if ( ctx . rules . get CaMeL Mode CaMeL Name ( ) == null ) mode = j CaMeL Edit . get CaMeL Mode ( token CaMeL Marker . get CaMeL Main CaMeL Rule CaMeL Set ( ) . get CaMeL Mode CaMeL Name ( ) ) ; else mode = j CaMeL Edit . get CaMeL Mode ( ctx . rules . get CaMeL Mode CaMeL Name ( ) ) ;
return is CaMeL Root ( ) || ( is CaMeL Static ( ) && is CaMeL Module CaMeL Class ( )  <CTX>  public final boolean is CaMeL Static CaMeL Owner ( ) { return is CaMeL Root ( ) || ( is CaMeL Static ( ) && is CaMeL Module CaMeL Class ( ) / / ! ! ! remove later ? translation does not work ( yet ? ) && is CaMeL Java ( ) ) ; }	return is CaMeL Package CaMeL Class ( ) || ( is CaMeL Static ( ) && is CaMeL Module CaMeL Class ( )
Qualification qualification = new Qualification ( ) ; qualification . set CaMeL Person ( dfa CaMeL Can@@ did@@ acy . get CaMeL Person ( ) ) ; qualification . set CaMeL Mark ( dfa CaMeL Can@@ did@@ acy . get CaMeL Pre@@ cedent CaMeL Degree CaMeL Information ( ) . get CaMeL Conclusion CaMeL Grade ( ) ) ; qualification . set CaMeL School ( dfa CaMeL Can@@ did@@ acy . get CaMeL Pre@@ cedent CaMeL Degree CaMeL Information ( ) . get CaMeL Institution ( ) . get CaMeL Name ( ) ) ; qualification . set CaMeL Degree ( dfa CaMeL Can@@ did@@ acy . get CaMeL Pre@@ cedent CaMeL Degree CaMeL Information ( ) . get CaMeL Degree CaMeL Designation ( ) ) ; qualification . set CaMeL Date CaMeL Year CaMeL Month CaMeL Day ( new Year CaMeL Month CaMeL Day ( dfa CaMeL Can@@ did@@ acy . get CaMeL Pre@@ cedent CaMeL Degree CaMeL Information ( ) . get CaMeL Conclusion CaMeL Year ( ) , 1 , 1 ) ) ; qualification . set CaMeL Country ( dfa CaMeL Can@@ did@@ acy . get CaMeL Pre@@ cedent CaMeL Degree CaMeL Information ( ) . get CaMeL Country ( ) ) ;  <CTX>  private void create CaMeL Qualification ( ) { DFA CaMeL Can@@ did@@ acy dfa CaMeL Can@@ did@@ acy = ( DFA CaMeL Can@@ did@@ acy ) get CaMeL Can@@ did@@ acy ( ) ; Qualification qualification = new Qualification ( ) ; qualification . set CaMeL Person ( dfa CaMeL Can@@ did@@ acy . get CaMeL Person ( ) ) ; qualification . set CaMeL Mark ( dfa CaMeL Can@@ did@@ acy . get CaMeL Pre@@ cedent CaMeL Degree CaMeL Information ( ) . get CaMeL Conclusion CaMeL Grade ( ) ) ; qualification . set CaMeL School ( dfa CaMeL Can@@ did@@ acy . get CaMeL Pre@@ cedent CaMeL Degree CaMeL Information ( ) . get CaMeL Institution ( ) . get CaMeL Name ( ) ) ; qualification . set CaMeL Degree ( dfa CaMeL Can@@ did@@ acy . get CaMeL Pre@@ cedent CaMeL Degree CaMeL Information ( ) . get CaMeL Degree CaMeL Designation ( ) ) ; qualification . set CaMeL Date CaMeL Year CaMeL Month CaMeL Day ( new Year CaMeL Month CaMeL Day ( dfa CaMeL Can@@ did@@ acy . get CaMeL Pre@@ cedent CaMeL Degree CaMeL Information ( ) . get CaMeL Conclusion CaMeL Year ( ) , 1 , 1 ) ) ; qualification . set CaMeL Country ( dfa CaMeL Can@@ did@@ acy . get CaMeL Pre@@ cedent CaMeL Degree CaMeL Information ( ) . get CaMeL Country ( ) ) ; }	if ( dfa CaMeL Can@@ did@@ acy . has CaMeL Pre@@ cedent CaMeL Degree CaMeL Information ( ) ) { Qualification qualification = new Qualification ( ) ; qualification . set CaMeL Person ( dfa CaMeL Can@@ did@@ acy . get CaMeL Person ( ) ) ; qualification . set CaMeL Mark ( dfa CaMeL Can@@ did@@ acy . get CaMeL Pre@@ cedent CaMeL Degree CaMeL Information ( ) . get CaMeL Conclusion CaMeL Grade ( ) ) ; qualification . set CaMeL School ( dfa CaMeL Can@@ did@@ acy . get CaMeL Pre@@ cedent CaMeL Degree CaMeL Information ( ) . get CaMeL Institution CaMeL Name ( ) ) ; qualification . set CaMeL Degree ( dfa CaMeL Can@@ did@@ acy . get CaMeL Pre@@ cedent CaMeL Degree CaMeL Information ( ) . get CaMeL Degree CaMeL Designation ( ) ) ; if ( dfa CaMeL Can@@ did@@ acy . get CaMeL Pre@@ cedent CaMeL Degree CaMeL Information ( ) . get CaMeL Conclusion CaMeL Year ( ) != null ) { qualification . set CaMeL Date CaMeL Year CaMeL Month CaMeL Day ( new Year CaMeL Month CaMeL Day ( dfa CaMeL Can@@ did@@ acy . get CaMeL Pre@@ cedent CaMeL Degree CaMeL Information ( ) . get CaMeL Conclusion CaMeL Year ( ) , 1 , 1 ) ) ; } qualification . set CaMeL Country ( dfa CaMeL Can@@ did@@ acy . get CaMeL Pre@@ cedent CaMeL Degree CaMeL Information ( ) . get CaMeL Country ( ) ) ; }
this . locale CaMeL Specific CaMeL Definitions = new Hash CaMeL Map < Locale , Map > ( ) ;  <CTX>  public void reset ( ) { this . base CaMeL Definitions = new Hash CaMeL Map < String , Component CaMeL Definition > ( ) ; this . locale CaMeL Specific CaMeL Definitions = new Hash CaMeL Map < Locale , Map > ( ) ; }	this . locale CaMeL Specific CaMeL Definitions = new Hash CaMeL Map < Locale , Map < String , Component CaMeL Definition >> ( ) ;
void Track ( String name , Measurement measurement ) { measurements . put ( name , measurement ) ;  <CTX>  void Track ( String name , Measurement measurement ) { measurements . put ( name , measurement ) ; }	void Track ( Measurement measurement ) { Track ( measurement . Short CaMeL Name ( ) , measurement ) ;
if ( impl == null || closed )  <CTX>  public Inet CaMeL Address get CaMeL Local CaMeL Address ( ) { if ( impl == null || closed ) return null ; Inet CaMeL Address local CaMeL Addr ; try { local CaMeL Addr = ( Inet CaMeL Address ) impl . get CaMeL Option ( Socket CaMeL Options . SO _ BIND@@ ADDR ) ; Security CaMeL Manager s = System . get CaMeL Security CaMeL Manager ( ) ; if ( s != null ) s . check CaMeL Connect ( local CaMeL Addr . get CaMeL Host CaMeL Name ( ) , - 1 ) ; } catch ( Security CaMeL Exception e ) { local CaMeL Addr = Inet CaMeL Address . ANY _ IF ; } catch ( Socket CaMeL Exception e ) { return null ; } return local CaMeL Addr ; }	if ( is CaMeL Closed ( ) )
show CaMeL All = null ;  <CTX>  private void create CaMeL Show CaMeL All CaMeL Group ( Composite parent ) { / / Create the group composite Composite composite = new Composite ( parent , SWT . NULL ) ; composite . set CaMeL Font ( parent . get CaMeL Font ( ) ) ; composite . set CaMeL Layout ( new Grid CaMeL Layout ( ) ) ; composite . set CaMeL Layout CaMeL Data ( new Grid CaMeL Data ( Grid CaMeL Data . FILL _ HORIZONTAL ) ) ; show CaMeL All = new Button ( composite , SWT . CHECK | SWT . LEFT ) ; show CaMeL All . set CaMeL Font ( composite . get CaMeL Font ( ) ) ; show CaMeL All . set CaMeL Text ( Managed CaMeL Builder CaMeL UI CaMeL Messages . get CaMeL Resource CaMeL String ( SHOW@@ ALL _ LABEL ) ) ; show CaMeL All . add CaMeL Listener ( SWT . Selection , new Listener ( ) { public void handle CaMeL Event ( Event e ) { populate CaMeL Types ( ) ; platform CaMeL Selection . select ( 0 ) ; handle CaMeL Type CaMeL Selection ( ) ; } } ) ; show CaMeL All . add CaMeL Dispose CaMeL Listener ( new Dispose CaMeL Listener ( ) { public void widget CaMeL Disposed ( Dispose CaMeL Event event ) { show CaMeL All = null ; } } ) ; }	show CaMeL All CaMeL Proj CaMeL Types = null ; } } ) ; show CaMeL All CaMeL Configs = new Button ( composite , SWT . CHECK | SWT . LEFT ) ; show CaMeL All CaMeL Configs . set CaMeL Font ( composite . get CaMeL Font ( ) ) ; show CaMeL All CaMeL Configs . set CaMeL Text ( Managed CaMeL Builder CaMeL UI CaMeL Messages . get CaMeL Resource CaMeL String ( SHOW@@ ALL _ CONFIG _ LABEL ) ) ; show CaMeL All CaMeL Configs . add CaMeL Listener ( SWT . Selection , new Listener ( ) { public void handle CaMeL Event ( Event e ) { populate CaMeL Configurations ( ) ; } } ) ; show CaMeL All CaMeL Configs . add CaMeL Dispose CaMeL Listener ( new Dispose CaMeL Listener ( ) { public void widget CaMeL Disposed ( Dispose CaMeL Event event ) { show CaMeL All CaMeL Configs = null ;
byte [ ] [ ] output = new byte [ len ] [ ] ;  <CTX>  public synchronized byte [ ] [ ] grab CaMeL All ( ) { int len = contents . size ( ) ; byte [ ] [ ] output = new byte [ len ] [ ] ; Iterator i = contents . values ( ) . iterator ( ) ; int count = 0 ; while ( i . has CaMeL Next ( ) ) { output [ count ++ ] = ( byte [ ] ) i . next ( ) ; } contents . clear ( ) ; max CaMeL Value = min CaMeL Value = - 1 ; return output ; }	Limited CaMeL Range CaMeL Int CaMeL Byte CaMeL Array CaMeL Map CaMeL Element [ ] output = new Limited CaMeL Range CaMeL Int CaMeL Byte CaMeL Array CaMeL Map CaMeL Element [ len ] ;
J CaMeL Layered CaMeL Pane ( )  <CTX>  J CaMeL Layered CaMeL Pane ( ) { layers = new Tree CaMeL Map ( ) ; component CaMeL To CaMeL Layer = new Hashtable ( ) ; }	public J CaMeL Layered CaMeL Pane ( )
I CaMeL Layout CaMeL Container container = get CaMeL Container ( ) ; if ( container != null && container instanceof Layout CaMeL Part ) { Layout CaMeL Part parent = ( Layout CaMeL Part ) container ; Control parent CaMeL Control = parent . get CaMeL Control ( ) ; if ( parent CaMeL Control != null && ! parent CaMeL Control . is CaMeL Disposed ( ) ) { parent CaMeL Control . traverse ( e . detail ) ; e . doit = false ; } }  <CTX>  public void key CaMeL Traversed ( Traverse CaMeL Event e ) { I CaMeL Layout CaMeL Container container = get CaMeL Container ( ) ; if ( container != null && container instanceof Layout CaMeL Part ) { Layout CaMeL Part parent = ( Layout CaMeL Part ) container ; Control parent CaMeL Control = parent . get CaMeL Control ( ) ; if ( parent CaMeL Control != null && ! parent CaMeL Control . is CaMeL Disposed ( ) ) { parent CaMeL Control . traverse ( e . detail ) ; e . doit = false ; } } }	if ( e . detail == SWT . TRAVERSE _ PAGE _ NEXT || e . detail == SWT . TRAVERSE _ PAGE _ PREVIOUS ) { I CaMeL Layout CaMeL Container container = get CaMeL Container ( ) ; if ( container != null && container instanceof Layout CaMeL Part ) { Layout CaMeL Part parent = ( Layout CaMeL Part ) container ; Control parent CaMeL Control = parent . get CaMeL Control ( ) ; if ( parent CaMeL Control != null && ! parent CaMeL Control . is CaMeL Disposed ( ) ) { parent CaMeL Control . traverse ( e . detail ) ; e . doit = false ; } } }
if ( ! loaded CaMeL Features . contains ( file ) ) {  <CTX>  public boolean require ( String file ) { if ( ! loaded CaMeL Features . contains ( file ) ) { if ( load ( file ) ) { loaded CaMeL Features . add ( file ) ; return true ; } } return false ; }	Ruby CaMeL String name = Ruby CaMeL String . new CaMeL String ( runtime , file ) ; if ( ! loaded CaMeL Features . contains ( name ) ) {
} else {  <CTX>  protected long do CaMeL Update ( final File root , final SVN CaMeL Update CaMeL Client client ) throws SVN CaMeL Exception { final long rev ; final Svn CaMeL Configuration configuration = Svn CaMeL Configuration . get CaMeL Instance ( my CaMeL Vcs . get CaMeL Project ( ) ) ; final Update CaMeL Root CaMeL Info root CaMeL Info = configuration . get CaMeL Update CaMeL Root CaMeL Info ( root , my CaMeL Vcs ) ; if ( root CaMeL Info != null ) { final SVNURL url = root CaMeL Info . get CaMeL Url ( ) ; if ( url != null && url . equals ( get CaMeL Source CaMeL Url ( root ) ) ) { if ( root CaMeL Info . is CaMeL Update CaMeL To CaMeL Revision ( ) ) { rev = client . do CaMeL Update ( root , root CaMeL Info . get CaMeL Revision ( ) , configuration . UPDATE _ RECUR@@ SI@@ VE@@ LY ) ; } else { rev = client . do CaMeL Update ( root , SVN CaMeL Revision . HEAD , configuration . UPDATE _ RECUR@@ SI@@ VE@@ LY ) ; } } else { rev = client . do CaMeL Switch ( root , url , root CaMeL Info . get CaMeL Revision ( ) , configuration . UPDATE _ RECUR@@ SI@@ VE@@ LY ) ; } } else { rev = client . do CaMeL Update ( root , SVN CaMeL Revision . HEAD , configuration . UPDATE _ RECUR@@ SI@@ VE@@ LY ) ; } return rev ; }	} else if ( url != null ) {
case Notification CaMeL Event . TEMPLATE _ TRANSFORM _ EVENT :  <CTX>  public void element CaMeL Changed ( Design CaMeL Element CaMeL Handle focus , Notification CaMeL Event ev ) { switch ( ev . get CaMeL Event CaMeL Type ( ) ) { case Notification CaMeL Event . CONTENT _ EVENT : case Notification CaMeL Event . STYLE _ EVENT : { refresh ( ) ; break ; } case Notification CaMeL Event . PROPERTY _ EVENT : case Notification CaMeL Event . TEMPLATE _ TRANSFORM _ EVENT : { refresh ( ) ; this . mark CaMeL Dirty ( true ) ; break ; } } }	case Notification CaMeL Event . THEME _ EVENT : case Notification CaMeL Event . TEMPLATE _ TRANSFORM _ EVENT :
if ( commands != null ) { Category category = ( Category ) parent CaMeL Element ;  <CTX>  public Object [ ] get CaMeL Children ( Object parent CaMeL Element ) { List children = new Array CaMeL List ( ) ; if ( parent CaMeL Element instanceof Category ) { if ( commands != null ) { Category category = ( Category ) parent CaMeL Element ; for ( int i = 0 ; i < commands . size ( ) ; i ++ ) { Command command = ( Command ) commands . get ( i ) ; if ( category . get CaMeL Id ( ) . equals ( command . get CaMeL Category ( ) ) ) children . add ( command ) ; } } } else if ( parent CaMeL Element == null ) { if ( categories != null && commands != null ) { List categories = new Array CaMeL List ( Key CaMeL Preference CaMeL Page . this . categories ) ; Collections . sort ( categories , Category . name CaMeL Comparator ( ) ) ; children . add CaMeL All ( categories ) ; List commands = new Array CaMeL List ( ) ; for ( int i = 0 ; i < Key CaMeL Preference CaMeL Page . this . commands . size ( ) ; i ++ ) { Command command = ( Command ) Key CaMeL Preference CaMeL Page . this . commands . get ( i ) ; if ( command . get CaMeL Category ( ) == null ) commands . add ( command ) ; } Collections . sort ( commands , Command . name CaMeL Comparator ( ) ) ; children . add CaMeL All ( commands ) ; } } return children . to CaMeL Array ( ) ; }	Category category = ( Category ) parent CaMeL Element ;
if ( recv . get CaMeL Runtime ( ) . get CaMeL Load CaMeL Service ( ) . load ( file . to CaMeL String ( ) ) ) { return recv . get CaMeL Runtime ( ) . get CaMeL True ( ) ; } return recv . get CaMeL Runtime ( ) . get CaMeL False ( ) ;  <CTX>  public static I CaMeL Ruby CaMeL Object load ( I CaMeL Ruby CaMeL Object recv , I CaMeL Ruby CaMeL Object [ ] args ) { Ruby CaMeL String file = ( Ruby CaMeL String ) args [ 0 ] ; if ( recv . get CaMeL Runtime ( ) . get CaMeL Load CaMeL Service ( ) . load ( file . to CaMeL String ( ) ) ) { return recv . get CaMeL Runtime ( ) . get CaMeL True ( ) ; } return recv . get CaMeL Runtime ( ) . get CaMeL False ( ) ; }	recv . get CaMeL Runtime ( ) . get CaMeL Load CaMeL Service ( ) . load ( file . to CaMeL String ( ) ) ; return recv . get CaMeL Runtime ( ) . get CaMeL True ( ) ;
if ( ! delete CaMeL Perspectives ( ) ) return false ;  <CTX>  public boolean perform CaMeL Ok ( ) { / / Set the default perspective if ( ! Util . equals ( default CaMeL Perspective CaMeL Id , perspective CaMeL Registry . get CaMeL Default CaMeL Perspective ( ) ) ) { perspective CaMeL Registry . set CaMeL Default CaMeL Perspective ( default CaMeL Perspective CaMeL Id ) ; } if ( ! delete CaMeL Perspectives ( ) ) return false ; / / Revert the perspectives perspective CaMeL Registry . revert CaMeL Perspectives ( per@@ sp CaMeL To CaMeL Revert ) ; I CaMeL Preference CaMeL Store store = get CaMeL Preference CaMeL Store ( ) ; / / store the open view mode setting store . set CaMeL Value ( I CaMeL Preference CaMeL Constants . OPEN _ VIEW _ MODE , open CaMeL View CaMeL Mode ) ; / / store the open perspective mode setting store . set CaMeL Value ( I CaMeL Preference CaMeL Constants . OPEN _ PER@@ SP _ MODE , open CaMeL Per@@ sp CaMeL Mode ) ; / / save both the API prefs and the internal prefs / / the API prefs are modified by / / Perspective CaMeL Registry . set CaMeL Default CaMeL Perspective Pref CaMeL Util . save CaMeL Prefs ( ) ; return true ; }	if ( perspectives . size ( ) < perspective CaMeL Registry . get CaMeL Perspectives ( ) . length ) perspective CaMeL Registry . delete CaMeL Perspectives ( per@@ sp CaMeL To CaMeL Delete ) ;
return new Print CaMeL Writer ( this . output ) ;  <CTX>  public Print CaMeL Writer get CaMeL Writer ( ) { return new Print CaMeL Writer ( this . output ) ; }	return new Print CaMeL Writer ( this . output CaMeL Writer ) ;
return ( multiple CaMeL Mode ) ;  <CTX>  allows CaMeL Multiple CaMeL Selections ( ) { return ( multiple CaMeL Mode ) ; }	return multiple CaMeL Mode ;
_ bits = new byte [ ( int ) ( _ size / 8 ) + ( _ size % 8 == 0 ? 0 : 1 ) ] ; dis . read ( _ bits ) ;  <CTX>  public Bit CaMeL Array ( Data CaMeL Input CaMeL Stream dis ) throws IO CaMeL Exception { _ size = dis . read CaMeL Int ( ) ; _ bits = new byte [ ( int ) ( _ size / 8 ) + ( _ size % 8 == 0 ? 0 : 1 ) ] ; dis . read ( _ bits ) ; }	_ bits = new byte [ ( _ size / 8 ) + ( _ size % 8 == 0 ? 0 : 1 ) ] ; dis . read CaMeL Fully ( _ bits ) ;
if ( popup != null )  <CTX>  public void set CaMeL Enabled ( boolean enabled ) { / / If we are disabl@@ ing it while it s propo@@ sing content , close the / / content proposal popup . if ( is CaMeL Enabled && ! enabled ) { if ( popup != null ) popup . close ( ) ; } is CaMeL Enabled = enabled ; }	if ( popup != null ) {
env . resolve CaMeL Type ( s . type ) ; env = new Env CaMeL For CaMeL Locals ( env , s ) ; in CaMeL Annotation = saved CaMeL In CaMeL Annotation ; is CaMeL Two CaMeL State CaMeL Context = false ;  <CTX>  protected Env check CaMeL Sk@@ o@@ lem CaMeL Constants ( Env env , boolean allowed ) { for ( int i = 0 ; i < sk@@ o@@ lem CaMeL Constants . size ( ) ; i ++ ) { Local CaMeL Var CaMeL Decl s = sk@@ o@@ lem CaMeL Constants . element CaMeL At ( i ) ; if ( allowed ) { Assert . not CaMeL False ( ! is CaMeL Two CaMeL State CaMeL Context ) ; Assert . not CaMeL False ( ! in CaMeL Annotation ) ; boolean saved CaMeL In CaMeL Annotation = in CaMeL Annotation ; in CaMeL Annotation = true ; is CaMeL Two CaMeL State CaMeL Context = true ; env . resolve CaMeL Type ( s . type ) ; env = new Env CaMeL For CaMeL Locals ( env , s ) ; in CaMeL Annotation = saved CaMeL In CaMeL Annotation ; is CaMeL Two CaMeL State CaMeL Context = false ; } else { error CaMeL Expecting CaMeL Loop ( s . get CaMeL Start CaMeL Loc ( ) , Tag CaMeL Constants . SK@@ O@@ LEM _ CONSTANT ) ; } } sk@@ o@@ lem CaMeL Constants . remove CaMeL All CaMeL Elements ( ) ; return env ; }	try { env . resolve CaMeL Type ( s . type ) ; env = new Env CaMeL For CaMeL Locals ( env , s ) ; } finally { in CaMeL Annotation = saved CaMeL In CaMeL Annotation ; is CaMeL Two CaMeL State CaMeL Context = false ; }
this . parse = in . read CaMeL Boolean ( ) ? Parse CaMeL Impl . read ( in ) : null ;  <CTX>  public final void read CaMeL Fields ( Data CaMeL Input in ) throws IO CaMeL Exception { this . crawl CaMeL Datum = Crawl CaMeL Datum . read ( in ) ; this . content = in . read CaMeL Boolean ( ) ? Content . read ( in ) : null ; this . parse = in . read CaMeL Boolean ( ) ? Parse CaMeL Impl . read ( in ) : null ; }	this . parse = in . read CaMeL Boolean ( ) ? Parse CaMeL Impl . read ( in , this . nut@@ ch CaMeL Conf ) : null ;
return acl . get CaMeL Encoded ( ) ;  <CTX>  private char [ ] get CaMeL Acl CaMeL Chars ( Bw CaMeL Shareable CaMeL Db@@ entity ent ) throws Cal CaMeL Facade CaMeL Exception { if ( ent instanceof Bw CaMeL Shareable CaMeL Contained CaMeL Db@@ entity ) { Bw CaMeL Calendar container ; if ( ent instanceof Bw CaMeL Calendar ) { container = ( Bw CaMeL Calendar ) ent ; } else { container = ( ( Bw CaMeL Shareable CaMeL Contained CaMeL Db@@ entity ) ent ) . get CaMeL Calendar ( ) ; } String path = container . get CaMeL Path ( ) ; Path CaMeL Info pi = path CaMeL Info CaMeL Map . get CaMeL Info ( path ) ; if ( pi == null ) { pi = get CaMeL Path CaMeL Info ( container ) ; path CaMeL Info CaMeL Map . put CaMeL Info ( path , pi ) ; } char [ ] acl CaMeL Chars = pi . encoded ; if ( ent instanceof Bw CaMeL Calendar ) { return acl CaMeL Chars ; } / * Create a merged access string from the entity access and the * container access * / String ent CaMeL Access = ent . get CaMeL Access ( ) ; if ( ent CaMeL Access == null ) { / / No@@ merge needed return acl CaMeL Chars ; } try { Acl acl = new Acl ( ) ; acl . decode ( acl CaMeL Chars ) ; acl . merge ( ent CaMeL Access . to CaMeL Char CaMeL Array ( ) ) ; return acl . get CaMeL Encoded ( ) ; } catch ( Throwable t ) { throw new Cal CaMeL Facade CaMeL Exception ( t ) ; } } / * This is a way of ma@@ king other objects sort of sha@@ reable . * The objects are locations , sp@@ on@@ sors and categories . * * We store the default access in the owner principal and manipulate that to give * us some degree of sharing . * * In effect , the owner bec@@ omes the container for the object . * / String acl CaMeL String = null ; String ent CaMeL Access = ent . get CaMeL Access ( ) ; Bw CaMeL User owner = ent . get CaMeL Owner ( ) ; if ( ent instanceof Bw CaMeL Category ) { acl CaMeL String = owner . get CaMeL Category CaMeL Access ( ) ; } else if ( ent instanceof Bw CaMeL Location ) { acl CaMeL String = owner . get CaMeL Location CaMeL Access ( ) ; } else if ( ent instanceof Bw CaMeL Spon@@ sor ) { acl CaMeL String = owner . get CaMeL Spon@@ sor CaMeL Access ( ) ; } if ( acl CaMeL String == null ) { if ( ent CaMeL Access == null ) { if ( ent . get CaMeL Publ@@ ick ( ) ) { return access . get CaMeL Default CaMeL Public CaMeL Access ( ) . to CaMeL Char CaMeL Array ( ) ; } return access . get CaMeL Default CaMeL Personal CaMeL Access ( ) . to CaMeL Char CaMeL Array ( ) ; } return ent CaMeL Access . to CaMeL Char CaMeL Array ( ) ; } if ( ent CaMeL Access == null ) { return acl CaMeL String . to CaMeL Char CaMeL Array ( ) ; } try { Acl acl = new Acl ( ) ; acl . decode ( acl CaMeL String . to CaMeL Char CaMeL Array ( ) ) ; acl . merge ( ent CaMeL Access . to CaMeL Char CaMeL Array ( ) ) ; return acl . get CaMeL Encoded ( ) ; } catch ( Throwable t ) { throw new Cal CaMeL Facade CaMeL Exception ( t ) ; } }	return acl . encode CaMeL All ( ) ;
this . pattern CaMeL List = new Linked CaMeL List < Pattern > ( ) ;  <CTX>  public Class CaMeL Screener ( ) { this . pattern CaMeL List = new Linked CaMeL List < Pattern > ( ) ; }	this . pattern CaMeL List = new Linked CaMeL List < Matcher > ( ) ;
hash CaMeL Code CaMeL Computed = true ;  <CTX>  public int hash CaMeL Code ( ) { if ( ! hash CaMeL Code CaMeL Computed ) { hash CaMeL Code = HASH _ INITIAL ; hash CaMeL Code = hash CaMeL Code * HASH _ FACTOR + Util . hash CaMeL Code ( activity CaMeL Requirement CaMeL Bindings ) ; hash CaMeL Code = hash CaMeL Code * HASH _ FACTOR + Util . hash CaMeL Code ( activity CaMeL Pattern CaMeL Bindings ) ; hash CaMeL Code = hash CaMeL Code * HASH _ FACTOR + Util . hash CaMeL Code ( defined ) ; hash CaMeL Code = hash CaMeL Code * HASH _ FACTOR + Util . hash CaMeL Code ( enabled ) ; hash CaMeL Code = hash CaMeL Code * HASH _ FACTOR + Util . hash CaMeL Code ( id ) ; hash CaMeL Code = hash CaMeL Code * HASH _ FACTOR + Util . hash CaMeL Code ( name ) ; hash CaMeL Code CaMeL Computed = true ; } return hash CaMeL Code ; }	if ( hash CaMeL Code == HASH _ INITIAL ) hash CaMeL Code ++ ;
if ( is CaMeL Sealed ( ) || do CaMeL Overwrite ( name , this ) ) { super . delete ( name ) ;  <CTX>  public void delete ( String name ) { / / Let the super class to throw exceptions for sealed objects if ( is CaMeL Sealed ( ) || do CaMeL Overwrite ( name , this ) ) { super . delete ( name ) ; } }	Object [ ] data = id CaMeL Map CaMeL Data ; if ( data != null ) { int id = get CaMeL Id ( name , data ) ; if ( id != 0 ) { if ( ! is CaMeL Sealed ( ) ) { delete CaMeL Id ( id ) ; return ; } }
_ statement = s ;  <CTX>  public void set CaMeL Statement ( J CaMeL Statement s ) { _ statement = s ; }	statement = s ;
Object get CaMeL Value ( Class CaMeL Loader cl , Class CaMeL Pool cp )  <CTX>  Object get CaMeL Value ( Class CaMeL Loader cl , Class CaMeL Pool cp ) throws Class CaMeL Not CaMeL Found CaMeL Exception { return Annotation CaMeL Impl . make ( cl , get CaMeL Type ( cl ) , cp , value ) ; }	Object get CaMeL Value ( Class CaMeL Loader cl , Class CaMeL Pool cp , Method m )
view . get CaMeL Container ( ) . request CaMeL Focus ( ) ;  <CTX>  public void end CaMeL Overlay ( ) { view . get CaMeL Container ( ) . request CaMeL Focus ( ) ; if ( edit CaMeL Widget != null ) { edit CaMeL Widget . set CaMeL Visible ( false ) ; view . get CaMeL Container ( ) . remove ( edit CaMeL Widget ) ; Rectangle bounds = edit CaMeL Widget . get CaMeL Bounds ( ) ; view . get CaMeL Container ( ) . repaint ( bounds . x , bounds . y , bounds . width , bounds . height ) ; } }	view . get CaMeL J CaMeL Component ( ) . request CaMeL Focus ( ) ;
Module get CaMeL Module ( ) throws Exception ;  <CTX>  Module get CaMeL Module ( ) throws Exception ;	Module get CaMeL Module ( ) ;
else { return new D@@ te CaMeL Data CaMeL Engine ( context ) ; }  <CTX>  public I CaMeL Data CaMeL Engine create CaMeL Data CaMeL Engine ( Execution CaMeL Context context ) { I CaMeL Report CaMeL Document document = context . get CaMeL Report CaMeL Document ( ) ; if ( document != null ) { I CaMeL Document CaMeL Archive archive = document . get CaMeL Archive ( ) ; String name = document . get CaMeL Report CaMeL Document CaMeL Name ( ) ; if ( context . is CaMeL In CaMeL Factory ( ) ) { return new Data CaMeL Generation CaMeL Engine ( context , archive , name ) ; } else { return new Data CaMeL Generation CaMeL Engine ( context , archive , name ) ; } } else { return new D@@ te CaMeL Data CaMeL Engine ( context ) ; } }	return new D@@ te CaMeL Data CaMeL Engine ( context ) ;
return arg . NUMER@@ ATOR ( ) ;  <CTX>  public Lisp CaMeL Object execute ( Lisp CaMeL Object arg ) throws Condition CaMeL Throwable { return arg . NUMER@@ ATOR ( ) ; }	return arg . DEN@@ O@@ MIN@@ ATOR ( ) ;
this . parent CaMeL Module = runtime . get CaMeL Classes ( ) . get CaMeL Object CaMeL Class ( ) ;  <CTX>  protected Ruby CaMeL Module ( Ruby runtime , Ruby CaMeL Class meta CaMeL Class , Ruby CaMeL Class super CaMeL Class , Ruby CaMeL Module parent CaMeL Module , String name ) { super ( runtime , meta CaMeL Class ) ; this . super CaMeL Class = super CaMeL Class ; this . parent CaMeL Module = parent CaMeL Module ; set CaMeL Base CaMeL Name ( name ) ; / / If no parent is passed in , it is safe to assume Object . if ( this . parent CaMeL Module == null ) { this . parent CaMeL Module = runtime . get CaMeL Classes ( ) . get CaMeL Object CaMeL Class ( ) ; } }	this . parent CaMeL Module = runtime . get CaMeL Object ( ) ;
height = area . y + area . height - y ;  <CTX>  private void redraw CaMeL Tab CaMeL Area ( int index ) { int x = 0 , y = 0 , width = 0 , height = 0 ; if ( index == - 1 ) { Rectangle area = super . get CaMeL Client CaMeL Area ( ) ; if ( area . width == 0 || area . height == 0 ) return ; width = area . x + area . width - BORDER _ LEFT - BORDER _ RIGHT ; height = get CaMeL Tab CaMeL Height ( ) + 1 ; / / + 1 causes top line between content and tabs to be re@@ drawn x = area . x + BORDER _ LEFT ; y = area . y + BORDER _ TOP ; if ( on CaMeL Bottom ) { y = Math . max ( 0 , area . y + area . height - BORDER _ BOTTOM - height ) ; } } else { C CaMeL Tab CaMeL Item item = items [ index ] ; x = item . x ; y = item . y ; Rectangle area = super . get CaMeL Client CaMeL Area ( ) ; width = area . x + area . width - x ; height = area . y + area . height - y ; } redraw ( x , y , width , height , false ) ; }	height = item . height ;
get CaMeL Tool CaMeL References ( ) . add ( tool CaMeL Ref ) ;  <CTX>  public void add CaMeL Tool CaMeL Reference ( Tool CaMeL Reference tool CaMeL Ref ) { get CaMeL Tool CaMeL References ( ) . add ( tool CaMeL Ref ) ; }	get CaMeL Local CaMeL Tool CaMeL References ( ) . add ( tool CaMeL Ref ) ;
if ( working CaMeL Set == null )  <CTX>  private boolean is CaMeL Enclosed ( I CaMeL Resource element ) { if ( working CaMeL Set == null ) return false ; if ( working CaMeL Set . is CaMeL Empty ( ) ) return true ; / / Everything is in an empty working set Set working CaMeL Set CaMeL Paths = get CaMeL Working CaMeL Set CaMeL As CaMeL Set CaMeL Of CaMeL Paths ( ) ; return working CaMeL Set CaMeL Paths . contains ( element . get CaMeL Full CaMeL Path ( ) . to CaMeL String ( ) ) ; }	if ( working CaMeL Set == null ) {
Hashtable env@@ mt ,  <CTX>  Result get CaMeL State CaMeL To CaMeL Bind ( Object o , Name n , Context c , Hashtable env@@ mt , Attributes a ) throws Naming CaMeL Exception ;	Hashtable < ? , ? > env@@ mt ,
boolean schedule CaMeL Hash ( byte [ ] challenge , byte [ ] verifier , Cached CaMeL Url CaMeL Set url CaMeL Set , Probabilistic CaMeL Timer timer , Object key ) {  <CTX>  boolean schedule CaMeL Hash ( byte [ ] challenge , byte [ ] verifier , Cached CaMeL Url CaMeL Set url CaMeL Set , Probabilistic CaMeL Timer timer , Object key ) { return true ; }	boolean schedule CaMeL Hash ( Deadline timer , Object key , Hash CaMeL Service . Callback callback ) {
( ( Simple CaMeL Particle CaMeL Influence CaMeL Factory . Basic CaMeL Drag ) influence ) . set CaMeL Drag CaMeL Coefficient ( drag CaMeL Coefficient CaMeL Panel . get CaMeL Float CaMeL Value ( ) ) ;  <CTX>  public void state CaMeL Changed ( Change CaMeL Event e ) { Particle CaMeL Influence influence = particle CaMeL Mesh . get CaMeL Influ@@ ences ( ) . get ( influence CaMeL List . get CaMeL Selected CaMeL Index ( ) ) ; ( ( Simple CaMeL Particle CaMeL Influence CaMeL Factory . Basic CaMeL Drag ) influence ) . set CaMeL Drag CaMeL Coefficient ( drag CaMeL Coefficient CaMeL Panel . get CaMeL Float CaMeL Value ( ) ) ; }	( ( Simple CaMeL Particle CaMeL Influence CaMeL Factory . Basic CaMeL Gravity ) influence ) . set CaMeL Gravity CaMeL Force ( gravity CaMeL Influence CaMeL Panel . get CaMeL Value ( ) ) ;
synchronized ( owned CaMeL Windows )  <CTX>  public void hide ( ) { / / Hide visible owned windows . synchronized ( owned CaMeL Windows ) { Iterator e = owned CaMeL Windows . iterator ( ) ; while ( e . has CaMeL Next ( ) ) { Window w = ( Window ) ( ( ( Reference ) e . next ( ) ) . get ( ) ) ; if ( w != null ) { if ( w . is CaMeL Visible ( ) && w . get CaMeL Peer ( ) != null ) w . get CaMeL Peer ( ) . set CaMeL Visible ( false ) ; } else e . remove ( ) ; } } super . hide ( ) ; }	synchronized ( get CaMeL Tree CaMeL Lock ( ) )
hash CaMeL Map . put ( obj CaMeL Map . key CaMeL At ( i ) , obj CaMeL Map . get CaMeL At ( i ) ) ;  <CTX>  public Map get CaMeL Definitions ( ) { Char CaMeL Array CaMeL Object CaMeL Map obj CaMeL Map = get CaMeL Real CaMeL Definitions ( ) ; int size = obj CaMeL Map . size ( ) ; Map hash CaMeL Map = new Hash CaMeL Map ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { hash CaMeL Map . put ( obj CaMeL Map . key CaMeL At ( i ) , obj CaMeL Map . get CaMeL At ( i ) ) ; } return hash CaMeL Map ; }	hash CaMeL Map . put ( String . value CaMeL Of ( obj CaMeL Map . key CaMeL At ( i ) ) , obj CaMeL Map . get CaMeL At ( i ) ) ;
ac = new R CaMeL Mean CaMeL Amp CaMeL Config ( se@@ is ) ;  <CTX>  public Particle CaMeL Motion ( final Data CaMeL Set CaMeL Seismogram h@@ se@@ is , Data CaMeL Set CaMeL Seismogram v@@ se@@ is , Time CaMeL Config tc , Color color , String key , boolean horiz CaMeL Plane ) { Data CaMeL Set CaMeL Seismogram [ ] se@@ is = { h@@ se@@ is , v@@ se@@ is } ; this . tc = tc ; ac = new R CaMeL Mean CaMeL Amp CaMeL Config ( se@@ is ) ; tc . add CaMeL Listener ( ac ) ; tc . add ( se@@ is ) ; tc . add CaMeL Listener ( this ) ; ac . add CaMeL Listener ( this ) ; this . h@@ se@@ is = h@@ se@@ is ; h@@ se@@ is . add CaMeL Seis CaMeL Data CaMeL Change CaMeL Listener ( this ) ; h@@ se@@ is . retrieve CaMeL Data ( this ) ; this . v@@ se@@ is = v@@ se@@ is ; v@@ se@@ is . add CaMeL Seis CaMeL Data CaMeL Change CaMeL Listener ( this ) ; v@@ se@@ is . retrieve CaMeL Data ( this ) ; this . key = key ; this . horiz CaMeL Plane = horiz CaMeL Plane ; set CaMeL Color ( color ) ; tc . sh@@ ale CaMeL Time ( 0 , 1 ) ; }	Amp CaMeL Config ac = ( Amp CaMeL Config ) keys CaMeL To CaMeL Amp CaMeL Configs . get ( key ) ; if ( ac == null ) { ac = new R CaMeL Mean CaMeL Amp CaMeL Config ( ) ; keys CaMeL To CaMeL Amp CaMeL Configs . put ( key , ac ) ; } ac . add ( se@@ is ) ; ac . add CaMeL Listener ( this ) ;
get CaMeL Continu@@ um ( ) . add CaMeL Build CaMeL Definition CaMeL To CaMeL Project CaMeL Group ( project CaMeL Group CaMeL Id , get CaMeL Build CaMeL Definition CaMeL From CaMeL Input ( ) ) ;  <CTX>  public String save CaMeL To CaMeL Group ( ) throws Continu@@ um CaMeL Exception { try { if ( build CaMeL Definition CaMeL Id == 0 ) { get CaMeL Continu@@ um ( ) . add CaMeL Build CaMeL Definition CaMeL To CaMeL Project CaMeL Group ( project CaMeL Group CaMeL Id , get CaMeL Build CaMeL Definition CaMeL From CaMeL Input ( ) ) ; } else { get CaMeL Continu@@ um ( ) . update CaMeL Build CaMeL Definition CaMeL For CaMeL Project CaMeL Group ( project CaMeL Group CaMeL Id , get CaMeL Build CaMeL Definition CaMeL From CaMeL Input ( ) ) ; } } catch ( Continu@@ um CaMeL Action CaMeL Exception cae ) { add CaMeL Action CaMeL Error ( cae . get CaMeL Message ( ) ) ; return INPUT ; } return SUCCESS ; }	get CaMeL Continu@@ um ( ) . add CaMeL Build CaMeL Definition CaMeL To CaMeL Project CaMeL Group ( project CaMeL Group CaMeL Id , new CaMeL Build CaMeL Def ) ;
if ( data CaMeL Set == null )  <CTX>  private void update CaMeL Buttons ( ) { boolean ok CaMeL Enable = true ; if ( data CaMeL Set == null ) { ok CaMeL Enable = false ; } else { Iterator iter = input CaMeL Parameter CaMeL Group . get CaMeL Parameters ( ) . iterator ( ) ; if ( ! iter . has CaMeL Next ( ) ) { ok CaMeL Enable = false ; } else { int count = 0 ; while ( iter . has CaMeL Next ( ) ) { Object obj = iter . next ( ) ; if ( obj instanceof Scalar CaMeL Parameter CaMeL Handle ) { Scalar CaMeL Parameter CaMeL Handle param = ( Scalar CaMeL Parameter CaMeL Handle ) obj ; count ++ ; if ( param . get CaMeL Value CaMeL Expr ( ) == null ) { ok CaMeL Enable = false ; break ; } } } ok CaMeL Enable &= ( count != 0 ) ; } } get CaMeL Ok CaMeL Button ( ) . set CaMeL Enabled ( ok CaMeL Enable ) ; }	Iterator iter = input CaMeL Parameter CaMeL Group . get CaMeL Parameters ( ) . iterator ( ) ; if ( ! iter . has CaMeL Next ( ) )
return m _ driver CaMeL Manager . read CaMeL Resources ( m _ context , add CaMeL Site CaMeL Root ( parent CaMeL Path ) , filter ) ;  <CTX>  public List read CaMeL Resources ( String parent CaMeL Path , Cms CaMeL Resource CaMeL Filter filter ) throws Cms CaMeL Exception { return m _ driver CaMeL Manager . read CaMeL Resources ( m _ context , add CaMeL Site CaMeL Root ( parent CaMeL Path ) , filter ) ; }	return m _ driver CaMeL Manager . read CaMeL Resources ( m _ context , read CaMeL Resource ( res@@ our@@ cename , Cms CaMeL Resource CaMeL Filter . ALL ) , filter ) ;
} if ( I CaMeL Search CaMeL Page CaMeL Score CaMeL Computer . class . equals ( key ) ) {  <CTX>  public Object get CaMeL Adapter ( Object element , Class key ) { I CaMeL Java CaMeL Element java = ( I CaMeL Java CaMeL Element ) element ; if ( I CaMeL Property CaMeL Source . class . equals ( key ) ) { return get CaMeL Properties ( java ) ; } if ( I CaMeL Resource . class . equals ( key ) ) { return get CaMeL Resource ( java ) ; } if ( I CaMeL Project . class . equals ( key ) ) { return get CaMeL Project ( java ) ; } if ( I CaMeL Search CaMeL Page CaMeL Score CaMeL Computer . class . equals ( key ) ) { return f CaMeL Search CaMeL Page CaMeL Score CaMeL Computer ; } if ( I CaMeL Workbench CaMeL Adapter . class . equals ( key ) ) { return fg CaMeL Java CaMeL Workbench CaMeL Adapter ; } if ( I CaMeL Resource CaMeL Locator . class . equals ( key ) ) { return fg CaMeL Resource CaMeL Locator ; } if ( I CaMeL Persistable CaMeL Element . class . equals ( key ) ) { return new Persistable CaMeL Java CaMeL Element CaMeL Factory ( java ) ; } if ( I CaMeL Contributor CaMeL Resource CaMeL Adapter . class . equals ( key ) ) { return this ; } if ( I CaMeL Task CaMeL List CaMeL Resource CaMeL Adapter . class . equals ( key ) ) { return fg CaMeL Task CaMeL List CaMeL Adapter ; } return null ; }	} if ( f CaMeL Search CaMeL Page CaMeL Score CaMeL Computer != null && I CaMeL Search CaMeL Page CaMeL Score CaMeL Computer . class . equals ( key ) ) {
Action CaMeL Set CaMeL Part CaMeL Associations CaMeL Reader assoc CaMeL Reader = new Action CaMeL Set CaMeL Part CaMeL Associations CaMeL Reader ( ) ; assoc CaMeL Reader . read CaMeL Registry ( Platform . get CaMeL Extension CaMeL Registry ( ) , this ) ;  <CTX>  public void read CaMeL From CaMeL Registry ( ) { Action CaMeL Set CaMeL Registry CaMeL Reader reader = new Action CaMeL Set CaMeL Registry CaMeL Reader ( ) ; reader . read CaMeL Registry ( Platform . get CaMeL Extension CaMeL Registry ( ) , this ) ; Action CaMeL Set CaMeL Part CaMeL Associations CaMeL Reader assoc CaMeL Reader = new Action CaMeL Set CaMeL Part CaMeL Associations CaMeL Reader ( ) ; assoc CaMeL Reader . read CaMeL Registry ( Platform . get CaMeL Extension CaMeL Registry ( ) , this ) ; }	extensions = get CaMeL Action CaMeL Set CaMeL Part CaMeL Association CaMeL Extension CaMeL Point ( ) . get CaMeL Extensions ( ) ; for ( int i = 0 ; i < extensions . length ; i ++ ) { add CaMeL Action CaMeL Set CaMeL Part CaMeL Associations ( Platform CaMeL UI . get CaMeL Workbench ( ) . get CaMeL Extension CaMeL Tracker ( ) , extensions [ i ] ) ; }
synchronized ( this ) { if ( cur CaMeL Queue == null ) { AWT CaMeL Event event CaMeL To CaMeL Add = event ; Object src = event . get CaMeL Source ( ) ; if ( src instanceof Component ) { Component comp = ( Component ) src ; if ( comp . is CaMeL Coal@@ esc@@ er ( ) ) { AWT CaMeL Event relative = comp . get CaMeL Relative CaMeL Event ( event . get CaMeL ID ( ) ) ; if ( relative != null ) { AWT CaMeL Event co@@ alis@@ ced = comp . coalesce CaMeL Events ( relative , event ) ; if ( co@@ alis@@ ced != null ) { events . remove ( relative ) ; comp . remove CaMeL Relative CaMeL Event ( ) ; event CaMeL To CaMeL Add = co@@ alis@@ ced ; } } comp . add CaMeL New CaMeL Event ( event CaMeL To CaMeL Add ) ; } } events . add CaMeL Last ( event CaMeL To CaMeL Add ) ; notify CaMeL All ( ) ; } else { cur CaMeL Queue . post CaMeL Event ( event ) ; } } if ( system CaMeL Event CaMeL Queue ) { if ( ! is CaMeL Dispatch CaMeL Thread ( ) ) { toolkit . get CaMeL Native CaMeL Event CaMeL Queue ( ) . awake ( ) ; } else { toolkit . validate CaMeL Shutdown CaMeL Thread ( ) ; } }  <CTX>  public void post CaMeL Event ( AWT CaMeL Event event ) { synchronized ( this ) { if ( cur CaMeL Queue == null ) { AWT CaMeL Event event CaMeL To CaMeL Add = event ; Object src = event . get CaMeL Source ( ) ; if ( src instanceof Component ) { Component comp = ( Component ) src ; if ( comp . is CaMeL Coal@@ esc@@ er ( ) ) { AWT CaMeL Event relative = comp . get CaMeL Relative CaMeL Event ( event . get CaMeL ID ( ) ) ; if ( relative != null ) { AWT CaMeL Event co@@ alis@@ ced = comp . coalesce CaMeL Events ( relative , event ) ; if ( co@@ alis@@ ced != null ) { events . remove ( relative ) ; comp . remove CaMeL Relative CaMeL Event ( ) ; event CaMeL To CaMeL Add = co@@ alis@@ ced ; } } comp . add CaMeL New CaMeL Event ( event CaMeL To CaMeL Add ) ; } } events . add CaMeL Last ( event CaMeL To CaMeL Add ) ; notify CaMeL All ( ) ; } else { cur CaMeL Queue . post CaMeL Event ( event ) ; } } if ( system CaMeL Event CaMeL Queue ) { if ( ! is CaMeL Dispatch CaMeL Thread ( ) ) { toolkit . get CaMeL Native CaMeL Event CaMeL Queue ( ) . awake ( ) ; } else { toolkit . validate CaMeL Shutdown CaMeL Thread ( ) ; } } }	event . is CaMeL Posted = true ; get CaMeL Core ( ) . post CaMeL Event ( event ) ;
define CaMeL Class ( scope , clazz , false ) ;  <CTX>  public static void define CaMeL Class ( Scriptable scope , Class clazz ) throws Illegal CaMeL Access CaMeL Exception , Instantiation CaMeL Exception , Invocation CaMeL Target CaMeL Exception { define CaMeL Class ( scope , clazz , false ) ; }	define CaMeL Class ( scope , clazz , false , false ) ;
stylesheet . bindings . pop ( global ) ; }  <CTX>  void do CaMeL Apply ( Stylesheet stylesheet , Q CaMeL Name mode , Node context , int pos , int len , Node parent , Node next CaMeL Sibling ) throws Transformer CaMeL Exception { boolean apply = global || ! stylesheet . bindings . contains CaMeL Key ( name , global ) ; if ( apply ) { / / push the variable context stylesheet . bindings . push ( global ) ; / / set the variable Object value = get CaMeL Value ( stylesheet , mode , context , pos , len ) ; if ( value != null ) { stylesheet . bindings . set ( name , value , global ) ; } } / / variable and param don t process children as su@@ ch / / all subsequent instructions are processed with that variable context if ( next != null ) { next . apply ( stylesheet , mode , context , pos , len , parent , next CaMeL Sibling ) ; } if ( apply ) { / / pop the variable context stylesheet . bindings . pop ( global ) ; } }	stylesheet . bindings . pop ( type ) ;
void destroy ( ) throws Exception ;  <CTX>  void destroy ( ) throws Exception ;	int destroy ( ) throws Exception ;
List < I CaMeL Test CaMeL NG CaMeL Method > filtered CaMeL Methods = new Array CaMeL List < I CaMeL Test CaMeL NG CaMeL Method > ( ) ; String [ ] groups = tm . get CaMeL Groups ( ) ; Map < String , List < I CaMeL Test CaMeL NG CaMeL Method >> before CaMeL Group CaMeL Map = group CaMeL Methods . get CaMeL Before CaMeL Groups CaMeL Map ( ) ; for ( String group : groups ) { List < I CaMeL Test CaMeL NG CaMeL Method > methods = before CaMeL Group CaMeL Map . get ( group ) ; if ( methods != null ) { filtered CaMeL Methods . add CaMeL All ( methods ) ;  <CTX>  private void invoke CaMeL Before CaMeL Groups CaMeL Configurations ( I CaMeL Test CaMeL Class test CaMeL Class , I CaMeL Test CaMeL NG CaMeL Method tm , Configuration CaMeL Group CaMeL Methods group CaMeL Methods , Xml CaMeL Suite suite , Map < String , String > params , Object instance ) { List < I CaMeL Test CaMeL NG CaMeL Method > filtered CaMeL Methods = new Array CaMeL List < I CaMeL Test CaMeL NG CaMeL Method > ( ) ; String [ ] groups = tm . get CaMeL Groups ( ) ; Map < String , List < I CaMeL Test CaMeL NG CaMeL Method >> before CaMeL Group CaMeL Map = group CaMeL Methods . get CaMeL Before CaMeL Groups CaMeL Map ( ) ; for ( String group : groups ) { List < I CaMeL Test CaMeL NG CaMeL Method > methods = before CaMeL Group CaMeL Map . get ( group ) ; if ( methods != null ) { filtered CaMeL Methods . add CaMeL All ( methods ) ; } } / / / / Invoke the right groups methods / / I CaMeL Test CaMeL NG CaMeL Method [ ] before CaMeL Methods CaMeL Array = filtered CaMeL Methods . to CaMeL Array ( new I CaMeL Test CaMeL NG CaMeL Method [ filtered CaMeL Methods . size ( ) ] ) ; invoke CaMeL Configurations ( test CaMeL Class , before CaMeL Methods CaMeL Array , suite , params , instance ) ; / / / / Remove them so th@@ ey don t get run again / / group CaMeL Methods . remove CaMeL Before CaMeL Groups ( groups ) ; }	synchronized ( group CaMeL Methods ) { List < I CaMeL Test CaMeL NG CaMeL Method > filtered CaMeL Methods = new Array CaMeL List < I CaMeL Test CaMeL NG CaMeL Method > ( ) ; String [ ] groups = tm . get CaMeL Groups ( ) ; Map < String , List < I CaMeL Test CaMeL NG CaMeL Method >> before CaMeL Group CaMeL Map = group CaMeL Methods . get CaMeL Before CaMeL Groups CaMeL Map ( ) ; for ( String group : groups ) { List < I CaMeL Test CaMeL NG CaMeL Method > methods = before CaMeL Group CaMeL Map . get ( group ) ; if ( methods != null ) { filtered CaMeL Methods . add CaMeL All ( methods ) ; }
Quick CaMeL Fix CaMeL Action . register CaMeL Quick CaMeL Fix CaMeL Action ( unused CaMeL Symbol CaMeL Info , new Empty CaMeL Intention CaMeL Action ( Highlight CaMeL Display CaMeL Key . get CaMeL Display CaMeL Name CaMeL By CaMeL Key ( Highlight CaMeL Display CaMeL Key . UNUSED _ SYMBOL ) , options ) , options ) ;  <CTX>  private Highlight CaMeL Info process CaMeL Local CaMeL Variable ( Psi CaMeL Local CaMeL Variable variable , final List < Intention CaMeL Action > options ) { Psi CaMeL Identifier identifier = variable . get CaMeL Name CaMeL Identifier ( ) ; if ( ! my CaMeL Ref CaMeL Count CaMeL Holder . is CaMeL Referenced ( variable ) ) { String message = Message CaMeL Format . format ( LOCAL _ VARIABLE _ IS _ NOT _ USED , identifier . get CaMeL Text ( ) ) ; Highlight CaMeL Info highlight CaMeL Info = create CaMeL Unused CaMeL Symbol CaMeL Info ( identifier , message ) ; Quick CaMeL Fix CaMeL Action . register CaMeL Quick CaMeL Fix CaMeL Action ( highlight CaMeL Info , new Remove CaMeL Unused CaMeL Variable CaMeL Fix ( variable ) , options ) ; return highlight CaMeL Info ; } boolean referenced = my CaMeL Ref CaMeL Count CaMeL Holder . is CaMeL Referenced CaMeL For CaMeL Read ( variable ) ; if ( ! referenced ) { String message = Message CaMeL Format . format ( LOCAL _ VARIABLE _ IS _ NOT _ USED _ FOR _ READING , identifier . get CaMeL Text ( ) ) ; Highlight CaMeL Info highlight CaMeL Info = create CaMeL Unused CaMeL Symbol CaMeL Info ( identifier , message ) ; Quick CaMeL Fix CaMeL Action . register CaMeL Quick CaMeL Fix CaMeL Action ( highlight CaMeL Info , new Remove CaMeL Unused CaMeL Variable CaMeL Fix ( variable ) , options ) ; return highlight CaMeL Info ; } if ( ! variable . has CaMeL Initializer ( ) ) { referenced = my CaMeL Ref CaMeL Count CaMeL Holder . is CaMeL Referenced CaMeL For CaMeL Write ( variable ) ; if ( ! referenced ) { String message = Message CaMeL Format . format ( LOCAL _ VARIABLE _ IS _ NOT _ ASSIGNED , identifier . get CaMeL Text ( ) ) ; final Highlight CaMeL Info unused CaMeL Symbol CaMeL Info = create CaMeL Unused CaMeL Symbol CaMeL Info ( identifier , message ) ; Quick CaMeL Fix CaMeL Action . register CaMeL Quick CaMeL Fix CaMeL Action ( unused CaMeL Symbol CaMeL Info , new Empty CaMeL Intention CaMeL Action ( Highlight CaMeL Display CaMeL Key . get CaMeL Display CaMeL Name CaMeL By CaMeL Key ( Highlight CaMeL Display CaMeL Key . UNUSED _ SYMBOL ) , options ) , options ) ; return unused CaMeL Symbol CaMeL Info ; } } return null ; }	Quick CaMeL Fix CaMeL Action . register CaMeL Quick CaMeL Fix CaMeL Action ( unused CaMeL Symbol CaMeL Info , new Empty CaMeL Intention CaMeL Action ( Highlight CaMeL Display CaMeL Key . get CaMeL Display CaMeL Name CaMeL By CaMeL Key ( Highlight CaMeL Display CaMeL Key . UNUSED _ SYMBOL ) , options ) , options , display CaMeL Name ) ;
this . last CaMeL Update CaMeL Count = last CaMeL Update CaMeL Count ;  <CTX>  public void set CaMeL Last CaMeL Update CaMeL Count ( boolean last CaMeL Update CaMeL Count ) { this . last CaMeL Update CaMeL Count = last CaMeL Update CaMeL Count ; }	this . last CaMeL Update CaMeL Count = String . value CaMeL Of ( last CaMeL Update CaMeL Count ) ;
while ( j CaMeL Type . is CaMeL Array ( ) || j CaMeL Type . is CaMeL Collection ( ) ) j CaMeL Type = j CaMeL Type . get CaMeL Component CaMeL Type ( ) ;  <CTX>  public void add CaMeL Parameter ( J CaMeL Parameter parameter ) throws Illegal CaMeL Argument CaMeL Exception { _ signature . add CaMeL Parameter ( parameter ) ; / / -- be consi@@ der@@ ate and add the class name to the / / -- each declaring class list of imports J CaMeL Type j CaMeL Type = parameter . get CaMeL Type ( ) ; while ( j CaMeL Type . is CaMeL Array ( ) || j CaMeL Type . is CaMeL Collection ( ) ) j CaMeL Type = j CaMeL Type . get CaMeL Component CaMeL Type ( ) ; if ( ! j CaMeL Type . is CaMeL Primitive ( ) ) { J CaMeL Class j CaMeL Class = ( J CaMeL Class ) j CaMeL Type ; for ( int i = 0 ; i < _ classes . size ( ) ; i ++ ) { ( ( J CaMeL Class ) _ classes . element CaMeL At ( i ) ) . add CaMeL Import ( j CaMeL Class . get CaMeL Name ( ) ) ; } } } / / -- add CaMeL Parameter	while ( j CaMeL Type . is CaMeL Array ( ) || j CaMeL Type . is CaMeL Collection ( ) ) { j CaMeL Type = j CaMeL Type . get CaMeL Component CaMeL Type ( ) ; }
if ( both CaMeL Are CaMeL Sets ( lhs CaMeL Value , rhs CaMeL Value ) )  <CTX>  public Object evaluate ( Context context ) throws Jaxen CaMeL Exception { Object lhs CaMeL Value = get CaMeL LHS ( ) . evaluate ( context ) ; Object rhs CaMeL Value = get CaMeL RHS ( ) . evaluate ( context ) ; Navigator nav = context . get CaMeL Navigator ( ) ; if ( both CaMeL Are CaMeL Sets ( lhs CaMeL Value , rhs CaMeL Value ) ) { return evaluate CaMeL Set CaMeL Set ( ( List ) lhs CaMeL Value , ( List ) rhs CaMeL Value , nav ) ; } if ( either CaMeL Is CaMeL Set ( lhs CaMeL Value , rhs CaMeL Value ) ) { if ( is CaMeL Set ( lhs CaMeL Value ) ) { if ( is CaMeL String ( rhs CaMeL Value ) ) { return evaluate CaMeL Set CaMeL String ( ( List ) lhs CaMeL Value , ( String ) rhs CaMeL Value , nav ) ; } else if ( is CaMeL Number ( rhs CaMeL Value ) ) { return evaluate CaMeL Set CaMeL Number ( ( List ) lhs CaMeL Value , ( Number ) rhs CaMeL Value , nav ) ; } else if ( is CaMeL Boolean ( rhs CaMeL Value ) ) { return evaluate CaMeL Set CaMeL Boolean ( ( List ) lhs CaMeL Value , ( Boolean ) rhs CaMeL Value , nav ) ; } } else { if ( is CaMeL String ( lhs CaMeL Value ) ) { return evaluate CaMeL String CaMeL Set ( ( String ) lhs CaMeL Value , ( List ) rhs CaMeL Value , nav ) ; } else if ( is CaMeL Number ( lhs CaMeL Value ) ) { return evaluate CaMeL Number CaMeL Set ( ( Number ) lhs CaMeL Value , ( List ) rhs CaMeL Value , nav ) ; } else if ( is CaMeL Boolean ( lhs CaMeL Value ) ) { return evaluate CaMeL Set CaMeL Boolean ( ( List ) rhs CaMeL Value , ( Boolean ) rhs CaMeL Value , nav ) ; } } } return evaluate CaMeL Object CaMeL Object ( lhs CaMeL Value , rhs CaMeL Value ) ; }	if ( either CaMeL Is CaMeL Set ( lhs CaMeL Value , rhs CaMeL Value ) ) { if ( is CaMeL Set ( lhs CaMeL Value ) ) { return evaluate CaMeL Set CaMeL Set ( ( List ) lhs CaMeL Value , convert CaMeL To CaMeL List ( rhs CaMeL Value ) , nav ) ; } else
} ;  <CTX>  public java . awt . Component get CaMeL List CaMeL Cell CaMeL Renderer CaMeL Component ( javax . swing . J CaMeL List list , Object value , int index , boolean is CaMeL Selected , boolean cell CaMeL Has CaMeL Focus ) { return super . get CaMeL List CaMeL Cell CaMeL Renderer CaMeL Component ( list , ( ( Locale ) value ) . get CaMeL Display CaMeL Name ( ) , index , is CaMeL Selected , cell CaMeL Has CaMeL Focus ) ; } ;	}
throws Invalid CaMeL Parameter CaMeL Exception { return engine . engine CaMeL Get CaMeL Parameter ( param ) ; }  <CTX>  public final Object get CaMeL Parameter ( String param ) throws Invalid CaMeL Parameter CaMeL Exception { return engine . engine CaMeL Get CaMeL Parameter ( param ) ; }	throws Invalid CaMeL Parameter CaMeL Exception { return engine CaMeL Get CaMeL Parameter ( param ) ; }
dispatch ( command ) ;  <CTX>  public boolean iterate ( ) { if ( dispatch CaMeL Queue . is CaMeL Empty ( ) ) { return false ; } else { Command command = ( Command ) dispatch CaMeL Queue . remove ( 0 ) ; dispatch ( command ) ; return true ; } }	process CaMeL Dispatch ( command ) ;
return null ;  <CTX>  public I CaMeL Callable search CaMeL Method ( String name ) { I CaMeL Callable method = ( I CaMeL Callable ) get CaMeL Methods ( ) . get ( name ) ; if ( method == null ) { if ( get CaMeL Super CaMeL Class ( ) != null ) { return get CaMeL Super CaMeL Class ( ) . search CaMeL Method ( name ) ; } else { return null ; } } else { method . set CaMeL Implementation CaMeL Class ( this ) ; return method ; } }	return Undefined CaMeL Method . get CaMeL Instance ( ) ;
runnable . run ( ) ; casted CaMeL This CaMeL Pipeline CaMeL Processor . add CaMeL Self CaMeL As CaMeL Parent ( context ) ;  <CTX>  protected static void execute CaMeL Parents ( Pipeline CaMeL Context context , Runnable runnable ) { Stack parents = ( Stack ) context . get CaMeL Attribute ( Pipeline CaMeL Context . PARENT _ PROCESSORS ) ; Pipeline CaMeL Processor this CaMeL Pipeline CaMeL Processor = ( Pipeline CaMeL Processor ) parents . peek ( ) ; / / We cast this here to go ar@@ round a javac bug . Processor CaMeL Impl casted CaMeL This CaMeL Pipeline CaMeL Processor = this CaMeL Pipeline CaMeL Processor ; casted CaMeL This CaMeL Pipeline CaMeL Processor . remove CaMeL Self CaMeL As CaMeL Parent ( context ) ; runnable . run ( ) ; casted CaMeL This CaMeL Pipeline CaMeL Processor . add CaMeL Self CaMeL As CaMeL Parent ( context ) ; }	try { runnable . run ( ) ; } finally { casted CaMeL This CaMeL Pipeline CaMeL Processor . add CaMeL Self CaMeL As CaMeL Parent ( context ) ; }
make CaMeL Replacement ( self ) ;  <CTX>  public void visit CaMeL Filter ( SIR CaMeL Filter self , SIR CaMeL Filter CaMeL Iter iter ) { make CaMeL Replacement ( self ) ; }	if ( replacing ) { make CaMeL Replacement ( self ) ; }
this ( Arrays . as CaMeL List ( patterns ) ) ;  <CTX>  public Meta CaMeL Pattern ( final Meta CaMeL Pattern [ ] patterns ) { this ( Arrays . as CaMeL List ( patterns ) ) ; }	this . pattern = Pattern . compile ( pattern ) ;
w = windows [ 0 ] ; is CaMeL Closing = Editor CaMeL Manager . save CaMeL All ( dirty CaMeL Editors , ! force , w ) ;  <CTX>  public void run ( ) { / / Collect dirty CaMeL Editors Array CaMeL List dirty CaMeL Editors = new Array CaMeL List ( ) ; Array CaMeL List dirty CaMeL Editors CaMeL Input = new Array CaMeL List ( ) ; I CaMeL Workbench CaMeL Window windows [ ] = get CaMeL Workbench CaMeL Windows ( ) ; for ( int i = 0 ; i < windows . length ; i ++ ) { I CaMeL Workbench CaMeL Page pages [ ] = windows [ i ] . get CaMeL Pages ( ) ; for ( int j = 0 ; j < pages . length ; j ++ ) { Workbench CaMeL Page page = ( Workbench CaMeL Page ) pages [ j ] ; I CaMeL Editor CaMeL Part editors [ ] = page . get CaMeL Dirty CaMeL Editors ( ) ; for ( int k = 0 ; k < editors . length ; k ++ ) { I CaMeL Editor CaMeL Part editor = editors [ k ] ; if ( editor . is CaMeL Dirty ( ) ) { if ( ! dirty CaMeL Editors CaMeL Input . contains ( editor . get CaMeL Editor CaMeL Input ( ) ) ) { dirty CaMeL Editors . add ( editor ) ; dirty CaMeL Editors CaMeL Input . add ( editor . get CaMeL Editor CaMeL Input ( ) ) ; } } } } } if ( dirty CaMeL Editors . size ( ) > 0 ) { I CaMeL Workbench CaMeL Window w = get CaMeL Active CaMeL Workbench CaMeL Window ( ) ; if ( w == null ) w = windows [ 0 ] ; is CaMeL Closing = Editor CaMeL Manager . save CaMeL All ( dirty CaMeL Editors , ! force , w ) ; } if ( is CaMeL Closing || force ) is CaMeL Closing = window CaMeL Manager . close ( ) ; }	w = get CaMeL Workbench CaMeL Windows ( ) [ 0 ] ; is CaMeL Closing = Editor CaMeL Manager . save CaMeL All ( dirty CaMeL Editors , ! force , w ) ;
write CaMeL Structure CaMeL List ( obj , Module . SCRIPT@@ LIBS _ PROP ) ;  <CTX>  public void visit CaMeL Module ( Module obj ) { if ( mark CaMeL Line CaMeL Number ) obj . init CaMeL Line CaMeL No CaMeL Map ( ) ; writer . attribute ( Design CaMeL Schema CaMeL Constants . XMLNS _ ATTRIB , DEFAULT _ NAME _ SPACE ) ; writer . attribute ( Design CaMeL Schema CaMeL Constants . VERSION _ ATTRIB , Design CaMeL Schema CaMeL Constants . REPORT _ VERSION ) ; writer . attribute ( Design CaMeL Schema CaMeL Constants . ID _ ATTRIB , new Long ( obj . get CaMeL ID ( ) ) . to CaMeL String ( ) ) ; property ( obj , Module . AUTHOR _ PROP ) ; property ( obj , Module . HELP _ GUIDE _ PROP ) ; property ( obj , Module . CREATED _ BY _ PROP ) ; property ( obj , Module . UNITS _ PROP ) ; property ( obj , Module . BASE _ PROP ) ; property ( obj , Module . INCLUDE _ RESOURCE _ PROP ) ; resource CaMeL Key ( obj , Module . TITLE _ ID _ PROP , Module . TITLE _ PROP ) ; property ( obj , Module . COMMENTS _ PROP ) ; resource CaMeL Key ( obj , Module . DESCRIPTION _ ID _ PROP , Module . DESCRIPTION _ PROP ) ; write CaMeL User CaMeL Property CaMeL Defns ( obj ) ; write CaMeL User CaMeL Property CaMeL Values ( obj ) ; / / write property bindings write CaMeL Structure CaMeL List ( obj , Module . PROPERTY _ BINDINGS _ PROP ) ; / / write script libs write CaMeL Structure CaMeL List ( obj , Module . SCRIPT@@ LIBS _ PROP ) ; }	write CaMeL Structure CaMeL List ( obj , I CaMeL Module CaMeL Model . SCRIPT@@ LIBS _ PROP ) ;
else return new Cache CaMeL Response ( Cache CaMeL Response . SUCCESSFUL , rrset ) ;  <CTX>  lookup CaMeL Records ( Name name , short type , short dclass , byte min CaMeL Cred ) { Cache CaMeL Element element = ( Cache CaMeL Element ) find CaMeL Set ( name , type , dclass ) ; if ( element == null ) return new Cache CaMeL Response ( Cache CaMeL Response . UNKNOWN ) ; if ( element . expired CaMeL TTL ( ) ) { remove CaMeL Set ( name , type , dclass , element ) ; return new Cache CaMeL Response ( Cache CaMeL Response . UNKNOWN ) ; } if ( element . credibility >= min CaMeL Cred ) { R CaMeL Rset rrset = element . rrset ; if ( rrset == null ) return new Cache CaMeL Response ( Cache CaMeL Response . NEGATIVE ) ; if ( type != Type . CNAME && rrset . get CaMeL Type ( ) == Type . CNAME ) { CNAME CaMeL Record cname ; cname = ( CNAME CaMeL Record ) rrset . rrs ( ) . next CaMeL Element ( ) ; Cache CaMeL Response cr ; cr = lookup CaMeL Records ( cname . get CaMeL Target ( ) , type , dclass , min CaMeL Cred ) ; if ( ! cr . is CaMeL Unknown ( ) ) return cr ; else return new Cache CaMeL Response ( Cache CaMeL Response . PARTIAL , cname . get CaMeL Target ( ) ) ; } else return new Cache CaMeL Response ( Cache CaMeL Response . SUCCESSFUL , rrset ) ; } else return new Cache CaMeL Response ( Cache CaMeL Response . UNKNOWN ) ; }	if ( cr == null ) cr = new Cache CaMeL Response ( Cache CaMeL Response . SUCCESSFUL ) ; cr . add ( rrset ) ;
context . pen@@ cil . eo@@ fill ( ) ;  <CTX>  public void execute ( PA CaMeL Context context ) throws Painter CaMeL Exception { context . pen@@ cil . eo@@ fill ( ) ; }	context . pen@@ cil . stroke ( ) ;
int remove = paragraph CaMeL Size - ( index + 1 ) ; Element [ ] removed = new Element [ remove ] ;  <CTX>  private void recreate CaMeL Leaves ( int start , Element CaMeL Spec [ ] data ) { Branch CaMeL Element paragraph = ( Branch CaMeL Element ) element CaMeL Stack . peek ( ) ; int index = paragraph . get CaMeL Element CaMeL Index ( start ) ; Element child = paragraph . get CaMeL Element ( index ) ; Attribute CaMeL Set atts = child . get CaMeL Attributes ( ) ; if ( data . length > 1 ) { Branch CaMeL Element new CaMeL Branch = ( Branch CaMeL Element ) create CaMeL Branch CaMeL Element ( paragraph , atts ) ; Element new CaMeL Leaf = create CaMeL Leaf CaMeL Element ( new CaMeL Branch , atts , start , child . get CaMeL End CaMeL Offset ( ) ) ; new CaMeL Branch . replace ( 0 , 0 , new Element [ ] { new CaMeL Leaf } ) ; Branch CaMeL Element parent = ( Branch CaMeL Element ) paragraph . get CaMeL Parent CaMeL Element ( ) ; int par CaMeL Size = parent . get CaMeL Element CaMeL Count ( ) ; Edit edit = get CaMeL Edit CaMeL For CaMeL Paragraph CaMeL And CaMeL Index ( parent , par CaMeL Size ) ; edit . add CaMeL Added CaMeL Element ( new CaMeL Branch ) ; int paragraph CaMeL Size = paragraph . get CaMeL Element CaMeL Count ( ) ; int remove = paragraph CaMeL Size - ( index + 1 ) ; Element [ ] removed = new Element [ remove ] ; int s = 0 ; for ( int j = index + 1 ; j < paragraph CaMeL Size ; j ++ ) removed [ s ++ ] = paragraph . get CaMeL Element ( j ) ; edit = get CaMeL Edit CaMeL For CaMeL Paragraph CaMeL And CaMeL Index ( paragraph , index ) ; edit . add CaMeL Removed CaMeL Elements ( removed ) ; Element [ ] added = recreate CaMeL After CaMeL Fracture ( removed , new CaMeL Branch , 0 , child . get CaMeL End CaMeL Offset ( ) ) ; edit = get CaMeL Edit CaMeL For CaMeL Paragraph CaMeL And CaMeL Index ( new CaMeL Branch , 1 ) ; edit . add CaMeL Added CaMeL Elements ( added ) ; last CaMeL Fr@@ ac@@ tured = new CaMeL Leaf ; offset = new CaMeL Branch . get CaMeL End CaMeL Offset ( ) ; } else { Element new CaMeL Leaf = create CaMeL Leaf CaMeL Element ( paragraph , atts , start , child . get CaMeL End CaMeL Offset ( ) ) ; Edit edit = get CaMeL Edit CaMeL For CaMeL Paragraph CaMeL And CaMeL Index ( paragraph , index ) ; edit . add CaMeL Added CaMeL Element ( new CaMeL Leaf ) ; } }	Element [ ] removed = new Element [ paragraph CaMeL Size - ( index + 1 ) ] ;
if ( ret . outer == null || ! ( ret . outer instanceof Sequential CaMeL Block ) ) return ; Structured CaMeL Block pred = ret . outer . get CaMeL Sub CaMeL Blocks ( ) [ 0 ] ;  <CTX>  private void remove CaMeL Return CaMeL Local ( Return CaMeL Block ret ) { if ( ret . outer == null || ! ( ret . outer instanceof Sequential CaMeL Block ) ) return ; Structured CaMeL Block pred = ret . outer . get CaMeL Sub CaMeL Blocks ( ) [ 0 ] ; if ( ! ( pred instanceof Instruction CaMeL Block ) ) return ; Expression instr = ( ( Instruction CaMeL Block ) pred ) . get CaMeL Instruction ( ) ; if ( ! ( instr instanceof Store CaMeL Instruction ) ) return ; Expression ret CaMeL Instr = ret . get CaMeL Instruction ( ) ; if ( ! ( ret CaMeL Instr instanceof Local CaMeL Load CaMeL Operator && ( ( Store CaMeL Instruction ) instr ) . lvalue CaMeL Matches ( ( Local CaMeL Load CaMeL Operator ) ret CaMeL Instr ) ) ) return ; Expression rvalue = ( ( Store CaMeL Instruction ) instr ) . get CaMeL Sub CaMeL Expressions ( ) [ 1 ] ; ret . set CaMeL Instruction ( rvalue ) ; ret . replace ( ret . outer ) ; }	Structured CaMeL Block pred = get CaMeL Predecessor ( ret ) ;
try { if ( project . is CaMeL Accessible ( ) && project . has CaMeL Nature ( C CaMeL Project CaMeL Nature . C _ NATURE _ ID ) ) {  <CTX>  public boolean visit ( I CaMeL Resource resource ) { if ( resource . get CaMeL Type ( ) == I CaMeL Resource . PROJECT ) { I CaMeL Project project = ( I CaMeL Project ) resource ; try { if ( project . is CaMeL Accessible ( ) && project . has CaMeL Nature ( C CaMeL Project CaMeL Nature . C _ NATURE _ ID ) ) { get CaMeL Descriptor ( project ) ; } } catch ( Core CaMeL Exception e ) { C CaMeL Core CaMeL Plugin . log ( e ) ; } return false ; } return resource . get CaMeL Type ( ) == I CaMeL Resource . ROOT ; }	try { if ( project . is CaMeL Accessible ( ) && project . find CaMeL Member ( C CaMeL Descriptor . DESCRIPTION _ FILE _ NAME ) != null ) {
Stack stack = ( Stack ) ht . get ( Thread . current CaMeL Thread ( ) ) ;  <CTX>  void clear ( ) { Stack stack = ( Stack ) ht . get ( Thread . current CaMeL Thread ( ) ) ; if ( stack != null ) stack . set CaMeL Size ( 0 ) ; }	Stack stack = get CaMeL Current CaMeL Stack ( ) ;
loc = r . next CaMeL Double ( ) ;  <CTX>  public synchronized void randomize ( Random CaMeL Source r ) { loc = r . next CaMeL Double ( ) ; }	set CaMeL Value ( r . next CaMeL Double ( ) ) ;
this . target CaMeL Label . reset CaMeL State CaMeL For CaMeL Code CaMeL Generation ( ) ;  <CTX>  public void reset CaMeL State CaMeL For CaMeL Code CaMeL Generation ( ) { this . target CaMeL Label . reset CaMeL State CaMeL For CaMeL Code CaMeL Generation ( ) ; }	if ( this . target CaMeL Label != null ) { this . target CaMeL Label . reset CaMeL State CaMeL For CaMeL Code CaMeL Generation ( ) ; }
if ( pre CaMeL Page . is CaMeL Dirty ( ) ) { pre CaMeL Page . do CaMeL Save ( null ) ;  <CTX>  public boolean on CaMeL Brought CaMeL To CaMeL Top ( I CaMeL Report CaMeL Editor CaMeL Page pre CaMeL Page ) { if ( this . is CaMeL Missing CaMeL Parameter ( ) ) { if ( this . parameter CaMeL Dialog != null ) { this . parameter CaMeL Dialog . open ( ) ; } return true ; } if ( get CaMeL Editor CaMeL Input ( ) != pre CaMeL Page . get CaMeL Editor CaMeL Input ( ) ) { set CaMeL Input ( pre CaMeL Page . get CaMeL Editor CaMeL Input ( ) ) ; } if ( pre CaMeL Page . is CaMeL Dirty ( ) ) { pre CaMeL Page . do CaMeL Save ( null ) ; } if ( get CaMeL Browser ( ) != null ) { display ( ) ; } return true ; }	if ( is CaMeL Missing CaMeL Parameter ( ) ) { if ( parameter CaMeL Dialog != null ) { parameter CaMeL Dialog . open ( ) ; if ( parameter CaMeL Dialog . get CaMeL Return CaMeL Code ( ) == Input CaMeL Parameter CaMeL Html CaMeL Dialog . RETURN _ CODE _ BROWSER _ CLOSED ) { is CaMeL Display = true ; } }
web CaMeL Artifact CaMeL Edit = ( Web CaMeL Artifact CaMeL Edit ) Module CaMeL Core . get CaMeL First CaMeL Artifact CaMeL Edit CaMeL For CaMeL Read ( project ) ;  <CTX>  protected I CaMeL Lib CaMeL Module [ ] get CaMeL Lib CaMeL Modules ( ) { / / TODO this will throw class cast exception , do we still use I CaMeL Lib CaMeL Module ? Web CaMeL Artifact CaMeL Edit web CaMeL Artifact CaMeL Edit = null ; try { web CaMeL Artifact CaMeL Edit = ( Web CaMeL Artifact CaMeL Edit ) Module CaMeL Core . get CaMeL First CaMeL Artifact CaMeL Edit CaMeL For CaMeL Read ( project ) ; if ( web CaMeL Artifact CaMeL Edit != null ) return ( I CaMeL Lib CaMeL Module [ ] ) web CaMeL Artifact CaMeL Edit . get CaMeL Lib CaMeL Modules ( ) ; } finally { if ( web CaMeL Artifact CaMeL Edit != null ) web CaMeL Artifact CaMeL Edit . dispose ( ) ; } return new I CaMeL Lib CaMeL Module [ ] { } ; }	web CaMeL Artifact CaMeL Edit = ( Web CaMeL Artifact CaMeL Edit ) Structure CaMeL Edit . get CaMeL First CaMeL Artifact CaMeL Edit CaMeL For CaMeL Read ( project ) ;
check CaMeL Save CaMeL Modified CaMeL Value ( descriptor ) ;  <CTX>  @ Override protected void do CaMeL OK CaMeL Action ( ) { if ( my CaMeL Form . my CaMeL Rb CaMeL Resource CaMeL Bundle . is CaMeL Selected ( ) ) { final String CaMeL Descriptor descriptor = get CaMeL Descriptor ( ) ; if ( descriptor != null ) { check CaMeL Save CaMeL Modified CaMeL Value ( descriptor ) ; } } super . do CaMeL OK CaMeL Action ( ) ; }	save CaMeL Modified CaMeL Property CaMeL Value ( my CaMeL Module , descriptor , my CaMeL Form . my CaMeL Resource CaMeL Bundle CaMeL Card . my CaMeL Tf CaMeL Value . get CaMeL Text ( ) ) ;
return eval ( source , line CaMeL No , column CaMeL No , func CaMeL Body ) ;  <CTX>  public Object apply ( String source , int line CaMeL No , int column CaMeL No , Object func CaMeL Body , Vector param CaMeL Names , Vector arguments ) throws BSF CaMeL Exception { return eval ( source , line CaMeL No , column CaMeL No , func CaMeL Body ) ; }	return eval ( func CaMeL Body ) ;
return PDE CaMeL Plugin . PLUGIN _ ID ;  <CTX>  public String get CaMeL Plugin ( ) { return PDE CaMeL Plugin . PLUGIN _ ID ; }	return IPDEUI CaMeL Constants . PLUGIN _ ID ;
java . awt . Image [ ] icons ) {  <CTX>  public Explicit CaMeL Bean CaMeL Info ( Bean CaMeL Descriptor bean CaMeL Descriptor , Bean CaMeL Info [ ] additional CaMeL Bean CaMeL Info , Property CaMeL Descriptor [ ] property CaMeL Descriptors , int default CaMeL Property CaMeL Index , Event CaMeL Set CaMeL Descriptor [ ] event CaMeL Set CaMeL Descriptors , int default CaMeL Event CaMeL Index , Method CaMeL Descriptor [ ] method CaMeL Descriptors , java . awt . Image [ ] icons ) { this . bean CaMeL Descriptor = bean CaMeL Descriptor ; this . additional CaMeL Bean CaMeL Info = additional CaMeL Bean CaMeL Info ; this . property CaMeL Descriptors = property CaMeL Descriptors ; this . default CaMeL Property CaMeL Index = default CaMeL Property CaMeL Index ; this . event CaMeL Set CaMeL Descriptors = event CaMeL Set CaMeL Descriptors ; this . default CaMeL Event CaMeL Index = default CaMeL Event CaMeL Index ; this . method CaMeL Descriptors = method CaMeL Descriptors ; this . icons = icons ; }	Image [ ] icons ) {
return m _ node CaMeL Sys CaMeL Loc@@ n ;  <CTX>  public String get CaMeL Node CaMeL Sys CaMeL Loc@@ n ( ) { return m _ node CaMeL Sys CaMeL Loc@@ n ; }	return htm@@ li@@ fy ( m _ node CaMeL Sys CaMeL Loc@@ n ) ;
else return other CaMeL Pressure ;  <CTX>  public float get CaMeL Other CaMeL Pressure ( ) { if ( cached CaMeL Value CaMeL Needed ( ) ) return cached CaMeL Other CaMeL Pressure ; else return other CaMeL Pressure ; }	return other CaMeL Pressure ;
Node . Jump result = new Node . Jump ( Token . LOOP , lineno ) ; result . add CaMeL Child CaMeL To CaMeL Back ( body CaMeL Target ) ; result . add CaMeL Children CaMeL To CaMeL Back ( body ) ;  <CTX>  private Node create CaMeL Loop ( int loop CaMeL Type , Node body , Node cond , Node init , Node incr , int lineno ) { Node . Target body CaMeL Target = new Node . Target ( ) ; Node . Target cond CaMeL Target = new Node . Target ( ) ; if ( loop CaMeL Type == LOOP _ FOR && cond . get CaMeL Type ( ) == Token . EMPTY ) { cond = new Node ( Token . TRUE ) ; } Node . Jump IFEQ = new Node . Jump ( Token . IFEQ , cond ) ; IFEQ . target = body CaMeL Target ; Node . Target break CaMeL Target = new Node . Target ( ) ; Node . Jump result = new Node . Jump ( Token . LOOP , lineno ) ; result . add CaMeL Child CaMeL To CaMeL Back ( body CaMeL Target ) ; result . add CaMeL Children CaMeL To CaMeL Back ( body ) ; if ( loop CaMeL Type == LOOP _ WHILE || loop CaMeL Type == LOOP _ FOR ) { / / propagate lineno to condition result . add CaMeL Children CaMeL To CaMeL Back ( new Node ( Token . EMPTY , lineno ) ) ; } result . add CaMeL Child CaMeL To CaMeL Back ( cond CaMeL Target ) ; result . add CaMeL Child CaMeL To CaMeL Back ( IFEQ ) ; result . add CaMeL Child CaMeL To CaMeL Back ( break CaMeL Target ) ; result . target = break CaMeL Target ; Node . Target continue CaMeL Target = cond CaMeL Target ; if ( loop CaMeL Type == LOOP _ WHILE || loop CaMeL Type == LOOP _ FOR ) { / / Just add a GOTO to the condition in the do . . while Node . Jump GOTO = new Node . Jump ( Token . GOTO ) ; GOTO . target = cond CaMeL Target ; result . add CaMeL Child CaMeL To CaMeL Front ( GOTO ) ; if ( loop CaMeL Type == LOOP _ FOR ) { if ( init . get CaMeL Type ( ) != Token . EMPTY ) { if ( init . get CaMeL Type ( ) != Token . VAR ) { init = new Node ( Token . EXPR _ VOID , init ) ; } result . add CaMeL Child CaMeL To CaMeL Front ( init ) ; } Node . Target incr CaMeL Target = new Node . Target ( ) ; result . add CaMeL Child CaMeL After ( incr CaMeL Target , body ) ; if ( incr . get CaMeL Type ( ) != Token . EMPTY ) { incr = new Node ( Token . EXPR _ VOID , incr ) ; result . add CaMeL Child CaMeL After ( incr , incr CaMeL Target ) ; } continue CaMeL Target = incr CaMeL Target ; } } result . set CaMeL Continue ( continue CaMeL Target ) ; return result ; }	loop . add CaMeL Child CaMeL To CaMeL Back ( body CaMeL Target ) ; loop . add CaMeL Children CaMeL To CaMeL Back ( body ) ;
byte [ ] bytes = str . get CaMeL Bytes ( ) ;  <CTX>  public static String base 64 _ encode ( String str ) { Char CaMeL Buffer cb = new Char CaMeL Buffer ( ) ; byte [ ] bytes = str . get CaMeL Bytes ( ) ; Base 64 . encode ( cb , bytes , 0 , bytes . length ) ; return cb . to CaMeL String ( ) ; }	Temp CaMeL Buffer tb = Temp CaMeL Buffer . allocate ( ) ; byte [ ] buffer = tb . get CaMeL Buffer ( ) ;
System . arraycopy ( buf , afp - array . length , array , 0 , n ) ;  <CTX>  public int read ( byte [ ] array ) throws IO CaMeL Exception { int status = check CaMeL Efficiency ( array . length ) ; int n = 0 ; if ( status == DIS ) { n = dis . read ( array ) ; } else if ( status == ARRAY ) { n = array . length ; if ( ( buf . length - afp + array . length ) < array . length ) { n = buf . length - afp + array . length ; } System . arraycopy ( buf , afp - array . length , array , 0 , n ) ; } else { n = raf . read ( array ) ; } afp += n ; if ( status == DIS ) fp += n ; return n ; }	System . arraycopy ( buf , afp , array , 0 , n ) ;
Selection s = selection [ i ] ; set CaMeL Selected CaMeL Text ( s , Text CaMeL Utilities . tabs CaMeL To CaMeL Spaces ( get CaMeL Selected CaMeL Text ( s ) , buffer . get CaMeL Tab CaMeL Size ( ) ) ) ;  <CTX>  public void tabs CaMeL To CaMeL Spaces ( ) { Selection [ ] selection = get CaMeL Selection ( ) ; if ( ! buffer . is CaMeL Editable ( ) || selection . length == 0 ) { get CaMeL Toolkit ( ) . beep ( ) ; return ; } buffer . begin CaMeL Compound CaMeL Edit ( ) ; for ( int i = 0 ; i < selection . length ; i ++ ) { Selection s = selection [ i ] ; set CaMeL Selected CaMeL Text ( s , Text CaMeL Utilities . tabs CaMeL To CaMeL Spaces ( get CaMeL Selected CaMeL Text ( s ) , buffer . get CaMeL Tab CaMeL Size ( ) ) ) ; } buffer . end CaMeL Compound CaMeL Edit ( ) ; } / / } } }	set CaMeL Text ( Text CaMeL Utilities . tabs CaMeL To CaMeL Spaces ( get CaMeL Text ( ) , buffer . get CaMeL Tab CaMeL Size ( ) ) ) ; } else { for ( int i = 0 ; i < selection . length ; i ++ ) { Selection s = selection [ i ] ; set CaMeL Selected CaMeL Text ( s , Text CaMeL Utilities . tabs CaMeL To CaMeL Spaces ( get CaMeL Selected CaMeL Text ( s ) , buffer . get CaMeL Tab CaMeL Size ( ) ) ) ; }
int length = _ _ len _ _ ( ) ; int step = get CaMeL Step ( s _ step ) ; int start = get CaMeL Start ( s _ start , step , length ) ; int stop = get CaMeL Stop ( s _ stop , start , step , length ) ; return getslice ( start , stop , step ) ;  <CTX>  final synchronized Py CaMeL Object seq _ _ _ getslice _ _ ( Py CaMeL Object s _ start , Py CaMeL Object s _ stop , Py CaMeL Object s _ step ) { int length = _ _ len _ _ ( ) ; int step = get CaMeL Step ( s _ step ) ; int start = get CaMeL Start ( s _ start , step , length ) ; int stop = get CaMeL Stop ( s _ stop , start , step , length ) ; return getslice ( start , stop , step ) ; }	return seq _ _ _ getslice _ _ ( s _ start , s _ stop , null ) ;
if ( jq . Bootstr@@ apping ) {  <CTX>  public static double getstatic _ D ( jq _ Static CaMeL Field f ) { jq . Assert ( f . get CaMeL Type ( ) == jq _ Primitive . DOUBLE ) ; if ( jq . Bootstr@@ apping ) { Object o = obj _ trav . get CaMeL Static CaMeL Field CaMeL Value ( f ) ; if ( o == null ) return 0 L ; return ( ( Double ) o ) . double CaMeL Value ( ) ; } return Double . long CaMeL Bits CaMeL To CaMeL Double ( getstatic _ L ( f ) ) ; }	if ( ! jq . Running CaMeL Native ) {
selected CaMeL Index = 0 ;  <CTX>  protected Filter CaMeL Combo CaMeL Box CaMeL Model ( ) { filters = new File CaMeL Filter [ 1 ] ; filters [ 0 ] = get CaMeL Accept CaMeL All CaMeL File CaMeL Filter ( get CaMeL File CaMeL Chooser ( ) ) ; selected CaMeL Index = 0 ; }	selected = filters [ 0 ] ;
CFG cfg = get CaMeL CFG ( method ) ;  <CTX>  public Depth CaMeL First CaMeL Search get CaMeL Depth CaMeL First CaMeL Search ( Method method ) throws CFG CaMeL Builder CaMeL Exception { Depth CaMeL First CaMeL Search dfs = dfs CaMeL Map . get ( method ) ; if ( dfs == null ) { CFG cfg = get CaMeL CFG ( method ) ; dfs = new Depth CaMeL First CaMeL Search ( cfg ) ; dfs . search ( ) ; dfs CaMeL Map . put ( method , dfs ) ; } return dfs ; }	CFG cfg = get CaMeL Raw CaMeL CFG ( method ) ;
sub CaMeL Iterator = ( Key CaMeL Iterator ) fs . key CaMeL Iterator ( ) ;  <CTX>  public Object next ( ) { while ( true ) { / / tail - recurse so we get infinite loop instead of OOM in case of a loop . . . if ( sub CaMeL Iterator != null && sub CaMeL Iterator . has CaMeL Next ( ) ) return sub CaMeL Iterator . next ( ) ; if ( sub CaMeL Iterator != null ) sub CaMeL Iterator = null ; if ( map CaMeL Iterator . has CaMeL Next ( ) ) { String key = ( String ) map CaMeL Iterator . next ( ) ; Object value = map . get ( key ) ; if ( value instanceof String ) return value ; else { Simple CaMeL Field CaMeL Set fs = ( Simple CaMeL Field CaMeL Set ) value ; sub CaMeL Iterator = ( Key CaMeL Iterator ) fs . key CaMeL Iterator ( ) ; continue ; } } return null ; } }	sub CaMeL Iterator = fs . key CaMeL Iterator ( ( prefix . length ( ) == 0 ) ? key : ( prefix + MULTI _ LEVEL _ CHAR + key ) ) ;
column . set CaMeL Min CaMeL Width ( column CaMeL Width ) ; column . set CaMeL Max CaMeL Width ( column CaMeL Width ) ;  <CTX>  public void init CaMeL Column CaMeL Widths ( J CaMeL Table table ) { Table CaMeL Column CaMeL Model columns = table . get CaMeL Column CaMeL Model ( ) ; for ( int i = 0 ; i < columns . get CaMeL Column CaMeL Count ( ) - 1 ; ++ i ) { Table CaMeL Column column = columns . get CaMeL Column ( i ) ; int column CaMeL Index = column . get CaMeL Model CaMeL Index ( ) ; Table CaMeL Cell CaMeL Renderer renderer = table . get CaMeL Cell CaMeL Renderer ( 0 , i ) ; Component c = renderer . get CaMeL Table CaMeL Cell CaMeL Renderer CaMeL Component ( table , get CaMeL Prototype CaMeL For ( column CaMeL Index ) , false , false , 0 , i ) ; final int column CaMeL Width = c . get CaMeL Preferred CaMeL Size ( ) . width + columns . get CaMeL Column CaMeL Margin ( ) ; if ( column CaMeL Width >= 0 ) { column . set CaMeL Preferred CaMeL Width ( column CaMeL Width ) ; column . set CaMeL Min CaMeL Width ( column CaMeL Width ) ; column . set CaMeL Max CaMeL Width ( column CaMeL Width ) ; } } }	} if ( get CaMeL Column CaMeL Class ( column CaMeL Index ) == Boolean . class ) { column . set CaMeL Resizable ( false ) ;
void write CaMeL Chars ( String s ) throws IO CaMeL Exception ;  <CTX>  void write CaMeL Chars ( String s ) throws IO CaMeL Exception ;	void write CaMeL Chars ( String value ) throws IO CaMeL Exception ;
if ( i != null )  <CTX>  private static final int find CaMeL Localized CaMeL Key CaMeL Code ( String token ) { if ( localized CaMeL Key CaMeL Codes == null ) init CaMeL Localized CaMeL Key CaMeL Codes ( ) ; token = token . to CaMeL Upper CaMeL Case ( ) ; Integer i = ( Integer ) localized CaMeL Key CaMeL Codes . get ( token ) ; if ( i != null ) return i . int CaMeL Value ( ) ; if ( token . length ( ) == 1 ) return token . char CaMeL At ( 0 ) ; return - 1 ; }	if ( i != null ) {
super ( control . get CaMeL Shell ( ) , Popup CaMeL Dialog . INF@@ OP@@ OP@@ UP _ SHE@@ LL@@ STYLE , false , false , false , false , null , info CaMeL Text ) ;  <CTX>  Content CaMeL Proposal CaMeL Popup ( String info CaMeL Text ) { super ( control . get CaMeL Shell ( ) , Popup CaMeL Dialog . INF@@ OP@@ OP@@ UP _ SHE@@ LL@@ STYLE , false , false , false , false , null , info CaMeL Text ) ; this . proposals = get CaMeL Proposals ( filter CaMeL Text ) ; }	super ( control . get CaMeL Shell ( ) , Popup CaMeL Dialog . INF@@ OP@@ OP@@ U@@ PRE@@ SIZE _ SHE@@ LL@@ STYLE , false , false , false , false , null , info CaMeL Text ) ;
restore CaMeL Item . set CaMeL Enabled ( selecting CaMeL View ) ;  <CTX>  public void fill ( Menu menu , int index ) { / / TODO Auto - generated method stub super . fill ( menu , index ) ; orientation CaMeL Item = new Menu CaMeL Item ( menu , SWT . CASCADE , index ++ ) ; { orientation CaMeL Item . set CaMeL Text ( Workbench CaMeL Messages . Fast CaMeL View CaMeL Bar _ view _ orientation ) ; Menu orientation CaMeL Swt CaMeL Menu = new Menu ( orientation CaMeL Item ) ; Radio CaMeL Menu orientation CaMeL Menu = new Radio CaMeL Menu ( orientation CaMeL Swt CaMeL Menu , current CaMeL Orientation ) ; orientation CaMeL Menu . add CaMeL Menu CaMeL Item ( Workbench CaMeL Messages . Fast CaMeL View CaMeL Bar _ horizontal , new Integer ( SWT . HORIZONTAL ) ) ; orientation CaMeL Menu . add CaMeL Menu CaMeL Item ( Workbench CaMeL Messages . Fast CaMeL View CaMeL Bar _ vertical , new Integer ( SWT . VERTICAL ) ) ; orientation CaMeL Item . set CaMeL Menu ( orientation CaMeL Swt CaMeL Menu ) ; } restore CaMeL Item = new Menu CaMeL Item ( menu , SWT . CHECK , index ++ ) ; restore CaMeL Item . set CaMeL Selection ( true ) ; restore CaMeL Item . set CaMeL Text ( Workbench CaMeL Messages . View CaMeL Pane _ fast CaMeL View ) ; restore CaMeL Item . add CaMeL Selection CaMeL Listener ( new Selection CaMeL Adapter ( ) { public void widget CaMeL Selected ( Selection CaMeL Event e ) { bar . restore CaMeL View ( selected CaMeL View ) ; } } ) ; close CaMeL Item = new Menu CaMeL Item ( menu , SWT . NONE , index ++ ) ; close CaMeL Item . set CaMeL Text ( Workbench CaMeL Messages . Workbench CaMeL Window _ close ) ; close CaMeL Item . add CaMeL Selection CaMeL Listener ( new Selection CaMeL Adapter ( ) { public void widget CaMeL Selected ( Selection CaMeL Event e ) { if ( selected CaMeL View != null ) { Workbench CaMeL Page page = bar . get CaMeL Window ( ) . get CaMeL Active CaMeL Workbench CaMeL Page ( ) ; if ( page != null ) { page . hide CaMeL View ( selected CaMeL View ) ; } } } } ) ; new Menu CaMeL Item ( menu , SWT . SEPARATOR , index ++ ) ; show CaMeL On = new Menu CaMeL Item ( menu , SWT . CASCADE , index ++ ) ; { show CaMeL On . set CaMeL Text ( Workbench CaMeL Messages . Fast CaMeL View CaMeL Bar _ dock _ on ) ; sides CaMeL Menu = new Menu ( show CaMeL On ) ; radio CaMeL Buttons = new Radio CaMeL Menu ( sides CaMeL Menu , bar . side ) ; radio CaMeL Buttons . add CaMeL Menu CaMeL Item ( Workbench CaMeL Messages . Fast CaMeL View CaMeL Bar _ Left , new Integer ( SWT . LEFT ) ) ; radio CaMeL Buttons . add CaMeL Menu CaMeL Item ( Workbench CaMeL Messages . Fast CaMeL View CaMeL Bar _ Right , new Integer ( SWT . RIGHT ) ) ; radio CaMeL Buttons . add CaMeL Menu CaMeL Item ( Workbench CaMeL Messages . Fast CaMeL View CaMeL Bar _ Bottom , new Integer ( SWT . BOTTOM ) ) ; show CaMeL On . set CaMeL Menu ( sides CaMeL Menu ) ; } boolean selecting CaMeL View = ( selected CaMeL View != null ) ; restore CaMeL Item . set CaMeL Enabled ( selecting CaMeL View ) ; restore CaMeL Item . set CaMeL Selection ( true ) ; if ( selecting CaMeL View ) { Workbench CaMeL Page page = bar . get CaMeL Window ( ) . get CaMeL Active CaMeL Workbench CaMeL Page ( ) ; close CaMeL Item . set CaMeL Enabled ( page != null && page . is CaMeL Closeable ( selected CaMeL View ) ) ; } else { close CaMeL Item . set CaMeL Enabled ( false ) ; } orientation CaMeL Item . set CaMeL Enabled ( selecting CaMeL View ) ; if ( selecting CaMeL View ) { / / Set the new orientation , but avoid re - sending the event to our own / / listener current CaMeL Orientation . set ( bar . get CaMeL Orientation ( selected CaMeL View ) , orientation CaMeL Change CaMeL Listener ) ; } }	Workbench CaMeL Page page = bar . get CaMeL Window ( ) . get CaMeL Active CaMeL Workbench CaMeL Page ( ) ; if ( selecting CaMeL View ) { restore CaMeL Item . set CaMeL Enabled ( page != null && page . is CaMeL Moveable ( selected CaMeL View ) ) ; } else { restore CaMeL Item . set CaMeL Enabled ( false ) ; }
cmb CaMeL Anchor . select ( name CaMeL Set . get CaMeL Safe CaMeL Name CaMeL Index ( get CaMeL T@@ rendline ( ) . get CaMeL Label CaMeL Anchor ( )  <CTX>  private void populate CaMeL Lists ( ) { / / Set block Anchor property Name CaMeL Set name CaMeL Set = Literal CaMeL Helper . anchor CaMeL Set ; cmb CaMeL Anchor . set CaMeL Items ( name CaMeL Set . get CaMeL Display CaMeL Names ( ) ) ; cmb CaMeL Anchor . select ( name CaMeL Set . get CaMeL Safe CaMeL Name CaMeL Index ( get CaMeL T@@ rendline ( ) . get CaMeL Label CaMeL Anchor ( ) . get CaMeL Name ( ) ) ) ; / / Set Legend Position property / / name CaMeL Set = Literal CaMeL Helper . full CaMeL Position CaMeL Set ; / / cmb CaMeL Position . set CaMeL Items ( name CaMeL Set . get CaMeL Display CaMeL Names ( ) ) ; / / cmb CaMeL Position . select ( name CaMeL Set . get CaMeL Safe CaMeL Name CaMeL Index ( get CaMeL T@@ rendline ( / / ) . get CaMeL Position ( ) / / . get CaMeL Name ( ) ) ) ; }	cmb CaMeL Anchor . select ( name CaMeL Set . get CaMeL Safe CaMeL Name CaMeL Index ( Chart CaMeL UI CaMeL Util . get CaMeL Flipped CaMeL Anchor ( get CaMeL T@@ rendline ( ) . get CaMeL Label CaMeL Anchor ( ) , is CaMeL Flipped CaMeL Axes ( ) )
tree CaMeL Event . set CaMeL New CaMeL Value ( content CaMeL Roots ) ; LOG . assert CaMeL True ( my CaMeL Old CaMeL Content CaMeL Roots != null ) ; tree CaMeL Event . set CaMeL Old CaMeL Value ( my CaMeL Old CaMeL Content CaMeL Roots ) ; my CaMeL Old CaMeL Content CaMeL Roots = null ; my CaMeL Manager . property CaMeL Changed ( tree CaMeL Event ) ;  <CTX>  public void run ( ) { Repository CaMeL Manager repository CaMeL Manager = my CaMeL Manager . get CaMeL Repository CaMeL Manager ( ) ; remove CaMeL Invalid CaMeL Files CaMeL And CaMeL Dirs ( true ) ; if ( repository CaMeL Manager != null ) { repository CaMeL Manager . update CaMeL By CaMeL Roots CaMeL Change ( ) ; } Psi CaMeL Tree CaMeL Change CaMeL Event CaMeL Impl tree CaMeL Event = new Psi CaMeL Tree CaMeL Change CaMeL Event CaMeL Impl ( my CaMeL Manager ) ; tree CaMeL Event . set CaMeL Property CaMeL Name ( Psi CaMeL Tree CaMeL Change CaMeL Event . PROP _ ROOTS ) ; final Virtual CaMeL File [ ] content CaMeL Roots = my CaMeL Project CaMeL Root CaMeL Manager . get CaMeL Content CaMeL Roots ( ) ; tree CaMeL Event . set CaMeL New CaMeL Value ( content CaMeL Roots ) ; LOG . assert CaMeL True ( my CaMeL Old CaMeL Content CaMeL Roots != null ) ; tree CaMeL Event . set CaMeL Old CaMeL Value ( my CaMeL Old CaMeL Content CaMeL Roots ) ; my CaMeL Old CaMeL Content CaMeL Roots = null ; my CaMeL Manager . property CaMeL Changed ( tree CaMeL Event ) ; }	LOG . assert CaMeL True ( my CaMeL Old CaMeL Content CaMeL Roots == null ) ; my CaMeL Old CaMeL Content CaMeL Roots = content CaMeL Roots ; tree CaMeL Event . set CaMeL Old CaMeL Value ( content CaMeL Roots ) ; my CaMeL Manager . before CaMeL Property CaMeL Change ( tree CaMeL Event ) ;
/ * ( non - Javadoc )  <CTX>  public static boolean prompt CaMeL To CaMeL Confirm ( final Shell shell , final String title , String message , I CaMeL Resource CaMeL Delta delta , String [ ] ignore CaMeL Model CaMeL Provider CaMeL Ids , boolean sync CaMeL Exec ) { I CaMeL Status status = Resource CaMeL Change CaMeL Validator . get CaMeL Validator ( ) . validate CaMeL Change ( delta , null ) ; if ( status . is CaMeL OK ( ) ) { return true ; } final I CaMeL Status display CaMeL Status ; if ( status . is CaMeL Multi CaMeL Status ( ) ) { List result = new Array CaMeL List ( ) ; I CaMeL Status [ ] children = status . get CaMeL Children ( ) ; for ( int i = 0 ; i < children . length ; i ++ ) { I CaMeL Status child = children [ i ] ; if ( ! is CaMeL Ignored CaMeL Status ( child , ignore CaMeL Model CaMeL Provider CaMeL Ids ) ) { result . add ( child ) ; } } if ( result . is CaMeL Empty ( ) ) { return true ; } if ( result . size ( ) == 1 ) { display CaMeL Status = ( I CaMeL Status ) result . get ( 0 ) ; } else { display CaMeL Status = new Multi CaMeL Status ( status . get CaMeL Plugin ( ) , status . get CaMeL Code ( ) , ( I CaMeL Status [ ] ) result . to CaMeL Array ( new I CaMeL Status [ result . size ( ) ] ) , status . get CaMeL Message ( ) , status . get CaMeL Exception ( ) ) ; } } else { if ( is CaMeL Ignored CaMeL Status ( status , ignore CaMeL Model CaMeL Provider CaMeL Ids ) ) { return true ; } display CaMeL Status = status ; } if ( message == null ) { message = IDE CaMeL Workbench CaMeL Messages . IDE _ side CaMeL Effect CaMeL Warning ; } final String dialog CaMeL Message = NLS . bind ( IDE CaMeL Workbench CaMeL Messages . IDE _ are CaMeL You CaMeL Sure , message ) ; final boolean [ ] result = new boolean [ ] { false } ; Runnable runnable = new Runnable ( ) { public void run ( ) { Error CaMeL Dialog dialog = new Error CaMeL Dialog ( shell , title , dialog CaMeL Message , display CaMeL Status , I CaMeL Status . ERROR | I CaMeL Status . WARNING | I CaMeL Status . INFO ) { protected void create CaMeL Buttons CaMeL For CaMeL Button CaMeL Bar ( Composite parent ) { create CaMeL Button ( parent , I CaMeL Dialog CaMeL Constants . YES _ ID , I CaMeL Dialog CaMeL Constants . YES _ LABEL , false ) ; create CaMeL Button ( parent , I CaMeL Dialog CaMeL Constants . NO _ ID , I CaMeL Dialog CaMeL Constants . NO _ LABEL , true ) ; create CaMeL Details CaMeL Button ( parent ) ; } / * ( non - Javadoc ) * @ see org . eclipse . jface . dialogs . Error CaMeL Dialog # button CaMeL Pressed ( int ) * / protected void button CaMeL Pressed ( int id ) { if ( id == I CaMeL Dialog CaMeL Constants . YES _ ID ) { super . button CaMeL Pressed ( I CaMeL Dialog CaMeL Constants . OK _ ID ) ; } else if ( id == I CaMeL Dialog CaMeL Constants . NO _ ID ) { super . button CaMeL Pressed ( I CaMeL Dialog CaMeL Constants . CANCEL _ ID ) ; } super . button CaMeL Pressed ( id ) ; } } ; int code = dialog . open ( ) ; result [ 0 ] = code == 0 ; } } ; if ( sync CaMeL Exec ) { shell . get CaMeL Display ( ) . sync CaMeL Exec ( runnable ) ; } else { runnable . run ( ) ; } return result [ 0 ] ; }	/ * * ( non - Javadoc ) *
void handle CaMeL Set CaMeL Change ( I CaMeL Observable CaMeL Set source , Set CaMeL Diff diff ) ;  <CTX>  void handle CaMeL Set CaMeL Change ( I CaMeL Observable CaMeL Set source , Set CaMeL Diff diff ) ;	void handle CaMeL Set CaMeL Change ( Set CaMeL Change CaMeL Event event ) ;
if ( element instanceof Psi CaMeL Doc CaMeL Token ) return ( ( Psi CaMeL Doc CaMeL Token ) element ) . get CaMeL Token CaMeL Type ( ) == my CaMeL Type ; else if ( element instanceof Xml CaMeL Token ) return ( ( Xml CaMeL Token ) element ) . get CaMeL Token CaMeL Type ( ) == my CaMeL Type ;  <CTX>  public boolean is CaMeL Acceptable ( Object element , Psi CaMeL Element context ) { if ( element instanceof Psi CaMeL Doc CaMeL Token ) return ( ( Psi CaMeL Doc CaMeL Token ) element ) . get CaMeL Token CaMeL Type ( ) == my CaMeL Type ; else if ( element instanceof Xml CaMeL Token ) return ( ( Xml CaMeL Token ) element ) . get CaMeL Token CaMeL Type ( ) == my CaMeL Type ; return false ; }	if ( element instanceof Psi CaMeL Element ) { final AST CaMeL Node node = ( ( Psi CaMeL Element ) element ) . get CaMeL Node ( ) ; return node != null ? node . get CaMeL Element CaMeL Type ( ) == my CaMeL Type : false ; } else if ( element instanceof AST CaMeL Node ) { return ( ( AST CaMeL Node ) element ) . get CaMeL Element CaMeL Type ( ) == my CaMeL Type ; }
return key ;  <CTX>  public String get CaMeL Key ( ) { return key ; }	return key . to CaMeL String ( ) ;
return get CaMeL Animated CaMeL Length CaMeL Attribute ( null , SVG _ REF _ X _ ATTRIBUTE , SVG _ MARKER _ REF _ X _ DEFAULT _ VALUE , SVGOM CaMeL Animated CaMeL Length . HORIZONTAL _ LENGTH , false ) ;  <CTX>  public SVG CaMeL Animated CaMeL Length get CaMeL Ref CaMeL X ( ) { return get CaMeL Animated CaMeL Length CaMeL Attribute ( null , SVG _ REF _ X _ ATTRIBUTE , SVG _ MARKER _ REF _ X _ DEFAULT _ VALUE , SVGOM CaMeL Animated CaMeL Length . HORIZONTAL _ LENGTH , false ) ; }	return ref CaMeL X ;
event . get CaMeL Alarm ( ) . get CaMeL Al@@ ar@@ mid ( ) } ;  <CTX>  public int persist ( Onms CaMeL Event event ) { Object [ ] parms = new Object [ ] { event . get CaMeL Id ( ) , / / event CaMeL ID event . get CaMeL Event CaMeL Uei ( ) , / / event CaMeL Uei event . get CaMeL Node ( ) . get CaMeL Id ( ) , / / node CaMeL ID event . get CaMeL Event CaMeL Time ( ) , / / event CaMeL Time event . get CaMeL Event CaMeL Host ( ) , / / event CaMeL Host event . get CaMeL Event CaMeL Source ( ) , / / event CaMeL Source event . get CaMeL Ip CaMeL Addr ( ) , / / ip CaMeL Addr event . get CaMeL Dist CaMeL Poller ( ) . get CaMeL Name ( ) , / / event CaMeL Dp CaMeL Name event . get CaMeL Event CaMeL Snmp CaMeL Host ( ) , / / event CaMeL Sn@@ mp@@ host event . get CaMeL Service ( ) . get CaMeL Id ( ) , / / service CaMeL ID event . get CaMeL Event CaMeL Snmp ( ) , / / event CaMeL Snmp event . get CaMeL Event CaMeL Parms ( ) , / / event CaMeL Parms event . get CaMeL Event CaMeL Create CaMeL Time ( ) , / / event CaMeL Create CaMeL Time event . get CaMeL Event CaMeL Descr ( ) , / / event CaMeL Descr event . get CaMeL Event CaMeL Log CaMeL Group ( ) , / / event CaMeL Log@@ group event . get CaMeL Event CaMeL Log CaMeL Msg ( ) , / / event CaMeL Logmsg event . get CaMeL Event CaMeL Severity ( ) , / / event CaMeL Severity event . get CaMeL Event CaMeL Path CaMeL Outage ( ) , / / event CaMeL Path CaMeL Outage event . get CaMeL Event CaMeL Correlation ( ) , / / event CaMeL Correlation event . get CaMeL Event CaMeL Suppressed CaMeL Count ( ) , / / event CaMeL Suppressed CaMeL Count event . get CaMeL Event CaMeL Oper CaMeL Instr@@ uct ( ) , / / event CaMeL Oper CaMeL Instr@@ uct event . get CaMeL Event CaMeL Auto CaMeL Action ( ) , / / event CaMeL Auto CaMeL Action event . get CaMeL Event CaMeL Oper CaMeL Action ( ) , / / event CaMeL Oper CaMeL Action event . get CaMeL Event CaMeL Oper CaMeL Action CaMeL Menu CaMeL Text ( ) , / / event CaMeL Oper CaMeL Action CaMeL Menu CaMeL Text event . get CaMeL Event CaMeL Notification ( ) , / / event CaMeL Notification event . get CaMeL Event CaMeL T CaMeL Ticket ( ) , / / event CaMeL T@@ ticket event . get CaMeL Event CaMeL T CaMeL Ticket CaMeL State ( ) , / / event CaMeL T@@ ticket CaMeL State event . get CaMeL Event CaMeL Forward ( ) , / / event CaMeL Forward event . get CaMeL Event CaMeL Mouse CaMeL Over CaMeL Text ( ) , / / event CaMeL Mouse CaMeL Over CaMeL Text event . get CaMeL Event CaMeL Log ( ) , / / event CaMeL Log event . get CaMeL Event CaMeL Display ( ) , / / event CaMeL Display event . get CaMeL Event CaMeL Ack CaMeL User ( ) , / / event CaMeL Ack CaMeL User event . get CaMeL Event CaMeL Ack CaMeL Time ( ) , / / event CaMeL Ack CaMeL Time event . get CaMeL Alarm ( ) . get CaMeL Al@@ ar@@ mid ( ) } ; / / alarm CaMeL ID return update ( parms ) ; }	event . get CaMeL Alarm ( ) . get CaMeL Id ( ) } ;
Object [ ] children = parent . get CaMeL Children ( ) ;  <CTX>  protected Wizard CaMeL Collection CaMeL Element get CaMeL Child CaMeL With CaMeL ID ( Wizard CaMeL Collection CaMeL Element parent , String id ) { Object [ ] children = parent . get CaMeL Children ( ) ; for ( int i = 0 ; i < children . length ; ++ i ) { Wizard CaMeL Collection CaMeL Element current CaMeL Child = ( Wizard CaMeL Collection CaMeL Element ) children [ i ] ; if ( current CaMeL Child . get CaMeL Id ( ) . equals ( id ) ) return current CaMeL Child ; } return null ; }	Object [ ] children = parent . get CaMeL Children ( null ) ;
chars CaMeL In CaMeL Byte CaMeL Array ( byte [ ] buf , int offset , int len ) throws Char CaMeL Conversion CaMeL Exception ;  <CTX>  chars CaMeL In CaMeL Byte CaMeL Array ( byte [ ] buf , int offset , int len ) throws Char CaMeL Conversion CaMeL Exception ;	chars CaMeL In CaMeL Byte CaMeL Array ( byte [ ] buf ) throws Char CaMeL Conversion CaMeL Exception { return ( chars CaMeL In CaMeL Byte CaMeL Array ( buf , 0 , buf . length ) ) ; }
notifier . e CaMeL Adapters ( ) . add CaMeL All ( adapters ) ;  <CTX>  private void add CaMeL Adapters ( Notifier notifier ) { if ( adapters != null ) { notifier . e CaMeL Adapters ( ) . add CaMeL All ( adapters ) ; } }	notifier . e CaMeL Adapters ( ) . add CaMeL All ( wizard CaMeL Context . get CaMeL Model ( ) . e CaMeL Adapters ( ) ) ;
String get CaMeL Summary CaMeL Html ( Connection conn , Timestamp start CaMeL Date , Timestamp end CaMeL Date ) ;  <CTX>  String get CaMeL Summary CaMeL Html ( Connection conn , Timestamp start CaMeL Date , Timestamp end CaMeL Date ) ;	String get CaMeL Summary CaMeL Html ( Connection conn , Timestamp start CaMeL Date , Timestamp end CaMeL Date , Map < String , Object > extra CaMeL Params ) ;
return current . get CaMeL System CaMeL Font ( ) ;  <CTX>  Font default CaMeL Font ( ) { Display current = Display . get CaMeL Current ( ) ; if ( current == null ) { Shell shell = new Shell ( ) ; Font font = shell . get CaMeL Font ( ) ; shell . dispose ( ) ; return font ; } else return current . get CaMeL System CaMeL Font ( ) ; }	return new Font ( current , current . get CaMeL System CaMeL Font ( ) . get CaMeL Font CaMeL Data ( ) ) ;
my CaMeL Panel . reset ( ) ;  <CTX>  public void reset ( ) { my CaMeL Panel . reset ( ) ; }	if ( my CaMeL Panel != null ) { my CaMeL Panel . reset ( ) ; }
buffer = Byte CaMeL Buffer . allocate CaMeL Direct ( buffer CaMeL Size ) ;  <CTX>  public Socket CaMeL Channel CaMeL Output CaMeL Stream ( Socket CaMeL Channel channel , int buffer CaMeL Size ) { this . channel = channel ; buffer = Byte CaMeL Buffer . allocate CaMeL Direct ( buffer CaMeL Size ) ; }	buffer = Byte CaMeL Buffer . allocate ( 8 ) ;
|| TAG _ COMMON _ WIZARD . equals ( element CaMeL Name ) ;  <CTX>  protected boolean read CaMeL Element ( I CaMeL Configuration CaMeL Element element ) { String element CaMeL Name = element . get CaMeL Name ( ) ; / * These are all of the valid root tags that exist * / return TAG _ ACTION _ PROVIDER . equals ( element CaMeL Name ) || TAG _ NAVIGATOR _ CONTENT . equals ( element CaMeL Name ) || TAG _ COMMON _ WIZARD . equals ( element CaMeL Name ) ; }	|| TAG _ COMMON _ WIZARD . equals ( element CaMeL Name ) || TAG _ COMMON _ FILTER . equals ( element CaMeL Name ) ;
if ( object == null ) return ;  <CTX>  public void reply CaMeL Message CaMeL Received ( Unique CaMeL ID id , Spy CaMeL Event spy CaMeL Event ) { if ( ! controller . is CaMeL Monitoring ( ) ) return ; Active CaMeL Object object = find CaMeL Active CaMeL Object ( id ) ; if ( object == null ) return ; if ( ! object . is CaMeL Monitoring CaMeL Reply CaMeL Sender ( ) ) return ; communication CaMeL Event CaMeL Listener . reply CaMeL Message CaMeL Received ( object , spy CaMeL Event ) ; }	if ( object == null ) { return ; }
. get CaMeL Option ( Input CaMeL Options . OPT _ IS _ MASTER _ PAGE _ CONTENT ) ;  <CTX>  public void render CaMeL Report ( String doc CaMeL Name , String page CaMeL Range , Input CaMeL Options render CaMeL Options , Output CaMeL Stream out ) throws Report CaMeL Service CaMeL Exception { I CaMeL Report CaMeL Document doc = Report CaMeL Engine CaMeL Service . get CaMeL Instance ( ) . open CaMeL Report CaMeL Document ( get CaMeL Report CaMeL Design CaMeL Name ( render CaMeL Options ) , doc CaMeL Name ) ; Http CaMeL Servlet CaMeL Request request = ( Http CaMeL Servlet CaMeL Request ) render CaMeL Options . get CaMeL Option ( Input CaMeL Options . OPT _ REQUEST ) ; Locale locale = ( Locale ) render CaMeL Options . get CaMeL Option ( Input CaMeL Options . OPT _ LOCALE ) ; Boolean is CaMeL Master CaMeL Page CaMeL Content = ( Boolean ) render CaMeL Options . get CaMeL Option ( Input CaMeL Options . OPT _ IS _ MASTER _ PAGE _ CONTENT ) ; boolean is CaMeL Master CaMeL Page = is CaMeL Master CaMeL Page CaMeL Content == null ? false : is CaMeL Master CaMeL Page CaMeL Content . boolean CaMeL Value ( ) ; Boolean svg CaMeL Flag = ( Boolean ) render CaMeL Options . get CaMeL Option ( Input CaMeL Options . OPT _ IS _ MASTER _ PAGE _ CONTENT ) ; boolean is CaMeL Svg = svg CaMeL Flag == null ? false : svg CaMeL Flag . boolean CaMeL Value ( ) ; Boolean is CaMeL Rtl = ( Boolean ) render CaMeL Options . get CaMeL Option ( Input CaMeL Options . OPT _ RTL ) ; Long page CaMeL Num = null ; if ( page CaMeL Range != null && page CaMeL Range . trim ( ) . length ( ) >= 0 ) page CaMeL Num = Long . value CaMeL Of ( page CaMeL Range ) ; long page = 1 ; if ( page CaMeL Num != null ) page = page CaMeL Num . long CaMeL Value ( ) ; try { Report CaMeL Engine CaMeL Service . get CaMeL Instance ( ) . render CaMeL Report ( out , request , doc , page , is CaMeL Master CaMeL Page , is CaMeL Svg , null , locale , is CaMeL Rtl . boolean CaMeL Value ( ) ) ; doc . close ( ) ; } catch ( Remote CaMeL Exception e ) { throw new Report CaMeL Service CaMeL Exception ( e . get CaMeL Localized CaMeL Message ( ) ) ; } }	. get CaMeL Option ( Input CaMeL Options . OPT _ SVG _ FLAG ) ;
return get CaMeL Local CaMeL Property ( module , prop ) ;  <CTX>  public Object get CaMeL Local CaMeL Property ( Module module , String member CaMeL Name ) { Property CaMeL Defn prop = ( Property CaMeL Defn ) get CaMeL Defn ( ) . get CaMeL Member ( member CaMeL Name ) ; if ( prop == null ) return null ; return get CaMeL Local CaMeL Property ( module , prop ) ; }	if ( prop CaMeL Defn . is CaMeL Intrinsic ( ) ) return get CaMeL Intrinsic CaMeL Property ( prop CaMeL Defn . get CaMeL Name ( ) ) ; return null ;
abstract public Result parse ( Page page , Config cfg , Session session ) throws Parsing CaMeL Exception ;  <CTX>  abstract public Result parse ( Page page , Config cfg , Session session ) throws Parsing CaMeL Exception ;	public abstract Result parse ( Page page , Config cfg , Session session ) throws Parsing CaMeL Exception ;
if ( sz < MINIMUM _ BOTTOM _ WIDTH ) { tool CaMeL Bar CaMeL Data . width CaMeL Hint = MINIMUM _ BOTTOM _ WIDTH ;  <CTX>  public void update ( boolean force ) { fast CaMeL View CaMeL Bar . update ( force ) ; Tool CaMeL Item [ ] items = fast CaMeL View CaMeL Bar . get CaMeL Control ( ) . get CaMeL Items ( ) ; if ( get CaMeL Side ( ) == SWT . BOTTOM ) { tool CaMeL Bar CaMeL Data . width CaMeL Hint = SWT . DEFAULT ; int sz = fast CaMeL View CaMeL Bar . get CaMeL Control ( ) . compute CaMeL Size ( SWT . DEFAULT , SWT . DEFAULT ) . x ; if ( sz < MINIMUM _ BOTTOM _ WIDTH ) { tool CaMeL Bar CaMeL Data . width CaMeL Hint = MINIMUM _ BOTTOM _ WIDTH ; } } else { boolean should CaMeL Expand = items . length > 0 ; if ( should CaMeL Expand != visible ) { get CaMeL Tool CaMeL Bar ( ) . set CaMeL Visible ( true ) ; if ( ! should CaMeL Expand ) { tool CaMeL Bar CaMeL Data . width CaMeL Hint = HIDDEN _ WIDTH ; } else { tool CaMeL Bar CaMeL Data . width CaMeL Hint = SWT . DEFAULT ; } visible = should CaMeL Expand ; } } if ( items . length != old CaMeL Length ) { control . get CaMeL Parent ( ) . layout ( ) ; old CaMeL Length = items . length ; } for ( int idx = 0 ; idx < items . length ; idx ++ ) { I CaMeL View CaMeL Reference view = get CaMeL View CaMeL For ( items [ idx ] ) ; view CaMeL Orientation . put ( view . get CaMeL Id ( ) , new Integer ( is CaMeL Horizontal ( view ) ? SWT . HORIZONTAL : SWT . VERTICAL ) ) ; } }	get CaMeL Tool CaMeL Bar ( ) . set CaMeL Visible ( true ) ; if ( ! should CaMeL Expand ) { tool CaMeL Bar CaMeL Data . width CaMeL Hint = HIDDEN _ WIDTH ; } else { tool CaMeL Bar CaMeL Data . width CaMeL Hint = SWT . DEFAULT ;
m CaMeL Config . set CaMeL Catch CaMeL Block ( extract CaMeL Block CaMeL Option ( a CaMeL To ) ) ;  <CTX>  public void run ( ) { m CaMeL Config . set CaMeL Catch CaMeL Block ( extract CaMeL Block CaMeL Option ( a CaMeL To ) ) ; }	m CaMeL Config . set CaMeL Try CaMeL Block ( extract CaMeL Block CaMeL Option ( a CaMeL To ) ) ;
handle CaMeL Remove CaMeL Pressed ( ) ;  <CTX>  public void widget CaMeL Selected ( Selection CaMeL Event e ) { handle CaMeL Remove CaMeL Pressed ( ) ; }	handle CaMeL Restore CaMeL Pressed ( ) ;
if ( get CaMeL Scope CaMeL Stack ( ) . has CaMeL Local CaMeL Values ( ) ) {  <CTX>  public I CaMeL Ruby CaMeL Object get CaMeL Backref ( ) { if ( get CaMeL Scope CaMeL Stack ( ) . has CaMeL Local CaMeL Values ( ) ) { return get CaMeL Scope CaMeL Stack ( ) . get CaMeL Value ( 1 ) ; } return ruby . get CaMeL Nil ( ) ; }	if ( get CaMeL Scope CaMeL Stack ( ) . has CaMeL Local CaMeL Variables ( ) ) {
set CaMeL Enabled ( Util . is CaMeL Single CaMeL Concrete CaMeL Selection ( selection ) ) ; }  <CTX>  public void selection CaMeL Changed ( I CaMeL Structured CaMeL Selection selection ) { set CaMeL Enabled ( Util . is CaMeL Single CaMeL Concrete CaMeL Selection ( selection ) ) ; }	set CaMeL Enabled ( Util . all CaMeL Concrete CaMeL Selection ( selection ) ) ; }
Battle battle = ( Battle ) iter . next ( ) ; if ( battle . get CaMeL Territory ( ) . equals ( t ) && battle . is CaMeL Bombing CaMeL Run ( ) == bombing ) return battle ;  <CTX>  public Battle get CaMeL Pending CaMeL Battle ( Territory t , boolean bombing ) { Iterator iter = m _ pending CaMeL Battles . iterator ( ) ; while ( iter . has CaMeL Next ( ) ) { Battle battle = ( Battle ) iter . next ( ) ; if ( battle . get CaMeL Territory ( ) . equals ( t ) && battle . is CaMeL Bombing CaMeL Run ( ) == bombing ) return battle ; } return null ; }	Iterator iter = m _ pending CaMeL Battles . iterator ( ) ; while ( iter . has CaMeL Next ( ) ) { Battle battle = ( Battle ) iter . next ( ) ; if ( battle . get CaMeL Territory ( ) . equals ( t ) && battle . is CaMeL Bombing CaMeL Run ( ) == bombing ) return battle ; } return null ;
double old CaMeL Value = get CaMeL Double ( name ) ; if ( get CaMeL Default CaMeL Double ( name ) == value ) get CaMeL Store CaMeL Preferences ( ) . remove ( name ) ; else get CaMeL Store CaMeL Preferences ( ) . put CaMeL Double ( name , value ) ; fire CaMeL Property CaMeL Change CaMeL Event ( name , new Double ( old CaMeL Value ) , new Double ( value ) ) ; silent CaMeL Running = false ;  <CTX>  public void set CaMeL Value ( String name , double value ) { silent CaMeL Running = true ; / / Turn off updates from the store double old CaMeL Value = get CaMeL Double ( name ) ; if ( get CaMeL Default CaMeL Double ( name ) == value ) get CaMeL Store CaMeL Preferences ( ) . remove ( name ) ; else get CaMeL Store CaMeL Preferences ( ) . put CaMeL Double ( name , value ) ; fire CaMeL Property CaMeL Change CaMeL Event ( name , new Double ( old CaMeL Value ) , new Double ( value ) ) ; silent CaMeL Running = false ; / / Restart listening to preferences }	try { double old CaMeL Value = get CaMeL Double ( name ) ; if ( get CaMeL Default CaMeL Double ( name ) == value ) get CaMeL Store CaMeL Preferences ( ) . remove ( name ) ; else get CaMeL Store CaMeL Preferences ( ) . put CaMeL Double ( name , value ) ; if ( old CaMeL Value != value ) fire CaMeL Property CaMeL Change CaMeL Event ( name , new Double ( old CaMeL Value ) , new Double ( value ) ) ; } finally { silent CaMeL Running = false ; }
Table CaMeL Item row = cursor . get CaMeL Row ( ) ; if ( row == null ) return ; int rownr = table . index CaMeL Of ( row ) ; if ( rownr >= 0 )  <CTX>  private void move CaMeL Row CaMeL Up ( boolean edit ) { Table CaMeL Item row = cursor . get CaMeL Row ( ) ; if ( row == null ) return ; int rownr = table . index CaMeL Of ( row ) ; if ( rownr >= 0 ) { move CaMeL Row ( rownr + 1 , rownr ) ; Trans CaMeL Action ta = new Trans CaMeL Action ( ) ; ta . set CaMeL Item CaMeL Move ( new int [ ] { rownr + 1 } , new int [ ] { rownr } ) ; add CaMeL Undo ( ta ) ; if ( edit ) edit ( rownr , 1 ) ; set CaMeL Row CaMeL Nums ( ) ; } }	if ( active CaMeL Table CaMeL Item == null ) return ; if ( active CaMeL Table CaMeL Row > 0 )
return new Ruby CaMeL Fixnum ( ruby , 0 ) ;  <CTX>  public static Ruby CaMeL Object rmdir ( Ruby ruby , Ruby CaMeL Object recv , Ruby CaMeL String path ) { new File ( path . to CaMeL String ( ) ) . delete ( ) ; return new Ruby CaMeL Fixnum ( ruby , 0 ) ; }	return Ruby CaMeL Fixnum . new CaMeL Fixnum ( ruby , 0 ) ;
return channel != null && channel . is CaMeL Open ( ) ;  <CTX>  public boolean valid ( ) { return channel != null && channel . is CaMeL Open ( ) ; }	Byte CaMeL Channel c = channel ; return ( c != null ) && ( c . is CaMeL Open ( ) ) ;
Intention CaMeL Action CaMeL With CaMeL Text CaMeL Caching action = new Intention CaMeL Action CaMeL With CaMeL Text CaMeL Caching ( pair . first ) ;  <CTX>  private Intention CaMeL Action CaMeL With CaMeL Text CaMeL Caching [ ] wrap CaMeL Actions ( List < Pair < Intention CaMeL Action , List < Intention CaMeL Action >> >> >> actions ) { Intention CaMeL Action CaMeL With CaMeL Text CaMeL Caching [ ] composite CaMeL Actions = new Intention CaMeL Action CaMeL With CaMeL Text CaMeL Caching [ actions . size ( ) ] ; int index = 0 ; for ( Pair < Intention CaMeL Action , List < Intention CaMeL Action >> pair : actions ) { if ( pair . first != null ) { Intention CaMeL Action CaMeL With CaMeL Text CaMeL Caching action = new Intention CaMeL Action CaMeL With CaMeL Text CaMeL Caching ( pair . first ) ; if ( pair . second != null ) { for ( Intention CaMeL Action intention CaMeL Action : pair . second ) { action . add CaMeL Action ( intention CaMeL Action , my CaMeL Quick CaMeL Fixes . contains ( intention CaMeL Action ) ) ; } } composite CaMeL Actions [ index ++ ] = action ; } } return composite CaMeL Actions ; }	Intention CaMeL Action CaMeL With CaMeL Text CaMeL Caching action = new Intention CaMeL Action CaMeL With CaMeL Text CaMeL Caching ( pair . first . first , pair . first . second ) ;
return new Hashtable ( ) ;  <CTX>  public Hashtable get CaMeL File CaMeL Elements ( ) { return new Hashtable ( ) ; }	return file CaMeL Elements ;
if ( ! Boolean . get CaMeL Boolean ( PROP _ GC ) )  <CTX>  IDE CaMeL Idle CaMeL Helper ( I CaMeL Workbench CaMeL Configurer a CaMeL Configurer ) { this . configurer = a CaMeL Configurer ; if ( ! Boolean . get CaMeL Boolean ( PROP _ GC ) ) return ; / / init gc interval Integer prop = Integer . get CaMeL Integer ( PROP _ GC _ INTERVAL ) ; if ( prop != null && prop . int CaMeL Value ( ) >= 0 ) min CaMeL GC CaMeL Interval = next CaMeL GC CaMeL Interval = prop . int CaMeL Value ( ) ; / / init max gc interval prop = Integer . get CaMeL Integer ( PROP _ GC _ MAX ) ; if ( prop != null ) max CaMeL GC = prop . int CaMeL Value ( ) ; / / hook idle handler final Display display = configurer . get CaMeL Workbench ( ) . get CaMeL Display ( ) ; final Runnable handler = new Runnable ( ) { public void run ( ) { if ( ! configurer . get CaMeL Workbench ( ) . is CaMeL Closing ( ) ) display . timer CaMeL Exec ( perform CaMeL GC ( ) , this ) ; } } ; idle CaMeL Listener = new Listener ( ) { public void handle CaMeL Event ( Event event ) { display . timer CaMeL Exec ( IDLE _ INTERVAL , handler ) ; } } ; display . add CaMeL Filter ( SWT . Key CaMeL Up , idle CaMeL Listener ) ; display . add CaMeL Filter ( SWT . Mouse CaMeL Up , idle CaMeL Listener ) ; }	String enabled = System . get CaMeL Property ( PROP _ GC ) ; if ( enabled != null && enabled . equals CaMeL Ignore CaMeL Case ( Boolean . FALSE . to CaMeL String ( ) ) )
if ( ! updates CaMeL Required . contains ( project ) ) { updates CaMeL Required . add ( project ) ;  <CTX>  public void queue CaMeL Update CaMeL Module ( I CaMeL Project project ) { synchronized ( this ) { if ( pause CaMeL Count > 0 ) { if ( ! updates CaMeL Required . contains ( project ) ) { updates CaMeL Required . add ( project ) ; } return ; } } update CaMeL Module ( project ) ; }	if ( ! module CaMeL Updates CaMeL Required . contains ( project ) ) { module CaMeL Updates CaMeL Required . add ( project ) ;
if ( chosen CaMeL Font != null ) font CaMeL Dialog . set CaMeL Font CaMeL List ( chosen CaMeL Font ) ;  <CTX>  protected Button get CaMeL Change CaMeL Control ( Composite parent ) { if ( change CaMeL Font CaMeL Button == null ) { change CaMeL Font CaMeL Button = new Button ( parent , SWT . PUSH ) ; if ( change CaMeL Button CaMeL Text != null ) change CaMeL Font CaMeL Button . set CaMeL Text ( change CaMeL Button CaMeL Text ) ; change CaMeL Font CaMeL Button . add CaMeL Selection CaMeL Listener ( new Selection CaMeL Adapter ( ) { public void widget CaMeL Selected ( Selection CaMeL Event event ) { Font CaMeL Dialog font CaMeL Dialog = new Font CaMeL Dialog ( change CaMeL Font CaMeL Button . get CaMeL Shell ( ) ) ; if ( chosen CaMeL Font != null ) font CaMeL Dialog . set CaMeL Font CaMeL List ( chosen CaMeL Font ) ; Font CaMeL Data font = font CaMeL Dialog . open ( ) ; if ( font != null ) { Font CaMeL Data [ ] old CaMeL Font = chosen CaMeL Font ; if ( old CaMeL Font == null ) old CaMeL Font = J CaMeL Face CaMeL Resources . get CaMeL Default CaMeL Font ( ) . get CaMeL Font CaMeL Data ( ) ; set CaMeL Pres@@ ents CaMeL Default CaMeL Value ( false ) ; Font CaMeL Data [ ] new CaMeL Data = new Font CaMeL Data [ 1 ] ; new CaMeL Data [ 0 ] = font ; update CaMeL Font ( new CaMeL Data ) ; fire CaMeL Value CaMeL Changed ( VALUE , old CaMeL Font [ 0 ] , font ) ; } } } ) ; change CaMeL Font CaMeL Button . add CaMeL Dispose CaMeL Listener ( new Dispose CaMeL Listener ( ) { public void widget CaMeL Disposed ( Dispose CaMeL Event event ) { change CaMeL Font CaMeL Button = null ; } } ) ; change CaMeL Font CaMeL Button . set CaMeL Font ( parent . get CaMeL Font ( ) ) ; set CaMeL Button CaMeL Layout CaMeL Data ( change CaMeL Font CaMeL Button ) ; } else { check CaMeL Parent ( change CaMeL Font CaMeL Button , parent ) ; } return change CaMeL Font CaMeL Button ; }	if ( chosen CaMeL Font != null ) { font CaMeL Dialog . set CaMeL Font CaMeL List ( chosen CaMeL Font ) ; }
return next != null && next != _ tail@@ ptr ;  <CTX>  public final boolean has CaMeL Next ( Dou@@ bly CaMeL Linked CaMeL List . Item i ) { Dou@@ bly CaMeL Linked CaMeL List . Item next = i . get CaMeL Next ( ) ; return next != null && next != _ tail@@ ptr ; }	return ( next != null ) && ( next != _ tail@@ ptr ) ;
super ( detail CaMeL Display CaMeL Name , date ) ; date . get CaMeL Time ( ) ;  <CTX>  public Calendar CaMeL Detail ( String detail CaMeL Display CaMeL Name , Calendar date ) { super ( detail CaMeL Display CaMeL Name , date ) ; date . get CaMeL Time ( ) ; }	super ( detail CaMeL Display CaMeL Name , date ) ;
target CaMeL Chooser . set CaMeL Text ( Choice CaMeL Set CaMeL Factory . get CaMeL Display CaMeL Name CaMeL From CaMeL Choice CaMeL Set ( input CaMeL Handle . get CaMeL Target CaMeL Window ( ) , CHOIC@@ E@@ SET _ TARGET ) ) ;  <CTX>  private void init CaMeL Display CaMeL Area ( ) { if ( Design CaMeL Choice CaMeL Constants . ACTION _ LINK _ TYPE _ HYPERLINK . equals ( selected CaMeL Type ) ) { if ( input CaMeL Handle . get CaMeL URI ( ) != null ) { location CaMeL Editor . set CaMeL Text ( input CaMeL Handle . get CaMeL URI ( ) ) ; } if ( input CaMeL Handle . get CaMeL Target CaMeL Window ( ) != null ) { target CaMeL Chooser . set CaMeL Text ( Choice CaMeL Set CaMeL Factory . get CaMeL Display CaMeL Name CaMeL From CaMeL Choice CaMeL Set ( input CaMeL Handle . get CaMeL Target CaMeL Window ( ) , CHOIC@@ E@@ SET _ TARGET ) ) ; } else { target CaMeL Chooser . select ( 0 ) ; } } else if ( Design CaMeL Choice CaMeL Constants . ACTION _ LINK _ TYPE _ BOOKMARK _ LINK . equals ( selected CaMeL Type ) ) { if ( input CaMeL Handle . get CaMeL Target CaMeL Bookmark ( ) != null ) { bookmark CaMeL Editor . set CaMeL Text ( input CaMeL Handle . get CaMeL Target CaMeL Bookmark ( ) ) ; } init CaMeL Bookmark CaMeL List ( Session CaMeL Handle CaMeL Adapter . get CaMeL Instance ( ) . get CaMeL Report CaMeL Design CaMeL Handle ( ) ) ; } else if ( Design CaMeL Choice CaMeL Constants . ACTION _ LINK _ TYPE _ DRI@@ LL _ THROUGH . equals ( selected CaMeL Type ) ) { if ( input CaMeL Handle . get CaMeL Target CaMeL Bookmark ( ) != null ) { bookmark CaMeL Editor . set CaMeL Text ( input CaMeL Handle . get CaMeL Target CaMeL Bookmark ( ) ) ; } if ( input CaMeL Handle . get CaMeL Report CaMeL Name ( ) != null ) { location CaMeL Editor . set CaMeL Text ( input CaMeL Handle . get CaMeL Report CaMeL Name ( ) ) ; } else { init CaMeL Paramter CaMeL Bindings ( ) ; init CaMeL Bookmark CaMeL List ( null ) ; } if ( input CaMeL Handle . get CaMeL Target CaMeL Window ( ) != null ) { target CaMeL Chooser . set CaMeL Text ( Choice CaMeL Set CaMeL Factory . get CaMeL Display CaMeL Name CaMeL From CaMeL Choice CaMeL Set ( input CaMeL Handle . get CaMeL Target CaMeL Window ( ) , CHOIC@@ E@@ SET _ TARGET ) ) ; } else { target CaMeL Chooser . select ( 0 ) ; } if ( input CaMeL Handle . get CaMeL Format CaMeL Type ( ) != null ) { format CaMeL Chooser . set CaMeL Text ( Choice CaMeL Set CaMeL Factory . get CaMeL Display CaMeL Name CaMeL From CaMeL Choice CaMeL Set ( input CaMeL Handle . get CaMeL Format CaMeL Type ( ) , CHOIC@@ E@@ SET _ FORMAT ) ) ; } else { format CaMeL Chooser . select ( 0 ) ; } } update CaMeL Buttons ( ) ; }	pdf CaMeL Button . set CaMeL Selection ( true ) ;
