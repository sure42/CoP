if ( cutAction != null ) cutAction . addPropertyChangeListener ( cutActionListener ) ; <CTX> public void setCutAction ( IAction action ) { if ( cutAction == action ) return ; if ( cutAction != null ) cutAction . removePropertyChangeListener ( cutActionListener ) ; cutAction = action ; if ( cutAction != null ) cutAction . addPropertyChangeListener ( cutActionListener ) ; cellCutAction . updateEnabledState ( ) ; }	if ( cutAction != null ) { cutAction . addPropertyChangeListener ( cutActionListener ) ; }
errors . add ( field . getKey ( ) , Resources . getActionMessage ( request , va , field ) ) ; <CTX> public static Object validateShort ( Object bean , ValidatorAction va , Field field , ActionMessages errors , HttpServletRequest request ) { Object result = null ; String value = null ; if ( isString ( bean ) ) { value = ( String ) bean ; } else { value = ValidatorUtils . getValueAsString ( bean , field . getProperty ( ) ) ; } if ( GenericValidator . isBlankOrNull ( value ) ) { return Boolean . TRUE ; } result = GenericTypeValidator . formatShort ( value ) ; if ( result == null ) { errors . add ( field . getKey ( ) , Resources . getActionMessage ( request , va , field ) ) ; } return result == null ? Boolean . FALSE : result ; }	errors . add ( field . getKey ( ) , Resources . getActionMessage ( validator , request , va , field ) ) ;
iVisited . accept (_Payload ) ; <CTX> public void visitOpAsgnOrNode ( OpAsgnOrNode iVisited ) { iVisited . accept (_Payload ) ; }	_ Payload . visitOpAsgnOrNode ( iVisited ) ;
return new LocalQuickFix [ 0 ] ; <CTX> private static LocalQuickFix [ ] getQuickFixes ( final GenericDomValue element ) { final Converter converter = element . getConverter ( ) ; if ( converter instanceof ResolvingConverter ) { final ResolvingConverter resolvingConverter = ( ResolvingConverter ) converter ; return resolvingConverter . getQuickFixes ( new ConvertContextImpl ( DomManagerImpl . getDomInvocationHandler ( element ) ) ) ; } return new LocalQuickFix [ 0 ] ; }	if ( reference instanceof LocalQuickFixProvider ) { result . addAll ( Arrays . asList ( ( ( LocalQuickFixProvider ) reference ) . getQuickFixes ( ) ) ) ; } return result . toArray ( new LocalQuickFix [ result . size ( ) ] ) ;
ArrayList othersList = new ArrayList ( Arrays . asList ( page . getEditorReferences ( ) ) ) ; if ( othersList . isEmpty ( ) ) { return null ; } IEditorReference active = page . getActiveEditorReference ( ) ; if ( active != null ) { othersList . remove ( active ) ; ArrayList activeList = new ArrayList ( 1 ) ; activeList . add ( active ) ; IEditorPart match = findEditor ( input , activeList ) ; if ( match != null ) { return match ; } } return findEditor ( input , othersList ) ; <CTX> public IEditorPart findEditor ( IEditorInput input ) { ArrayList othersList = new ArrayList ( Arrays . asList ( page . getEditorReferences ( ) ) ) ; if ( othersList . isEmpty ( ) ) { return null ; } IEditorReference active = page . getActiveEditorReference ( ) ; if ( active != null ) { othersList . remove ( active ) ; ArrayList activeList = new ArrayList ( 1 ) ; activeList . add ( active ) ; IEditorPart match = findEditor ( input , activeList ) ; if ( match != null ) { return match ; } } return findEditor ( input , othersList ) ; }	return findEditor ( null , input , WorkbenchPage . MATCH_INPUT ) ;
return context . declaration . getExtractor ( ) . getBooleanValue ( left ) == ( ( BooleanVariableContextEntry ) context ) . right ; <CTX> public boolean evaluateCachedRight ( final VariableContextEntry context , final Object left ) { return context . declaration . getExtractor ( ) . getBooleanValue ( left ) == ( ( BooleanVariableContextEntry ) context ) . right ; }	return context . getVariableDeclaration ( ) . getExtractor ( ) . getBooleanValue ( left ) == ( ( BooleanVariableContextEntry ) context ) . right ;
int min = calculateMaxTabWidth ( tabPlacement ) ; width = Math . max ( min , width ) ; int tabAreaHeight = preferredTabAreaHeight ( tabPlacement , width - tabAreaInsets . left - tabAreaInsets . right ) ; height += tabAreaHeight ; <CTX> protected Dimension calculateSize ( boolean minimum ) { int tabPlacement = tabPane . getTabPlacement ( ) ; int width = 0 ; int height = 0 ; Component c ; Dimension dims ; / / Find out the minimum / preferred size to display the largest child / / of the tabbed pane . for ( int i = 0 ; i < tabPane . getTabCount ( ) ; i ++ ) { c = tabPane . getComponentAt ( i ) ; if ( c == null ) continue ; dims = minimum ? c . getMinimumSize ( ) : c . getPreferredSize ( ) ; if ( dims != null ) { height = Math . max ( height , dims . height ) ; width = Math . max ( width , dims . width ) ; } } Insets tabAreaInsets = getTabAreaInsets ( tabPlacement ) ; if ( tabPlacement == SwingConstants . TOP || tabPlacement == SwingConstants . BOTTOM ) { int min = calculateMaxTabWidth ( tabPlacement ) ; width = Math . max ( min , width ) ; int tabAreaHeight = preferredTabAreaHeight ( tabPlacement , width - tabAreaInsets . left - tabAreaInsets . right ) ; height += tabAreaHeight ; } else { int min = calculateMaxTabHeight ( tabPlacement ) ; height = Math . max ( min , height ) ; int tabAreaWidth = preferredTabAreaWidth ( tabPlacement , height - tabAreaInsets . top - tabAreaInsets . bottom ) ; width += tabAreaWidth ; } Insets tabPaneInsets = tabPane . getInsets ( ) ; return new Dimension ( width + tabPaneInsets . left + tabPaneInsets . right , height + tabPaneInsets . top + tabPaneInsets . bottom ) ; }	width = Math . max ( calculateMaxTabWidth ( tabPlacement ) , width ) ; height += preferredTabAreaHeight ( tabPlacement , width - tabAreaInsets . left - tabAreaInsets . right ) ;
jMenuItemNewProjectActionPerformed ( evt ) ; <CTX> public void actionPerformed ( java . awt . event . ActionEvent evt ) { jMenuItemNewProjectActionPerformed ( evt ) ; }	jCheckBoxToggleFullscreenActionPerformed ( evt ) ;
if ( index >= 0 ) <CTX> public void bundleChanged ( BundleEvent event ) { int eventType = event . getType ( ) ; String bundleName ; synchronized ( this ) { if ( eventType == BundleEvent . STARTING ) { starting . add ( bundleName = event . getBundle ( ) . getSymbolicName ( ) ) ; } else if ( eventType == BundleEvent . STARTED ) { progressCount ++ ; if ( progressCount <= maximumProgressCount ) progressMonitor . worked ( 1 ) ; int index = starting . lastIndexOf ( event . getBundle ( ) . getSymbolicName ( ) ) ; if ( index >= 0 ) starting . remove ( index ) ; if ( index != starting . size ( ) ) return ; / / not currently displayed bundleName = index == 0 ? null : ( String ) starting . get ( index - 1 ) ; } else { return ; / / uninteresting event } } String taskName ; if ( bundleName == null ) taskName = WorkbenchMessages . Startup_Loading_Workbench ; else taskName = NLS . bind ( WorkbenchMessages . Startup_Loading , bundleName ) ; progressMonitor . subTask ( taskName ) ; }	if ( index >= 0 ) {
String newStr = getSqueeze ( args ) ; if ( newStr . equals ( getValue ( ) ) ) { <CTX> public IRubyObject squeeze_bang ( IRubyObject [ ] args ) { String newStr = getSqueeze ( args ) ; if ( newStr . equals ( getValue ( ) ) ) { return getRuntime ( ) . getNil ( ) ; } setValue ( newStr ) ; return this ; }	StringBuffer newStr = getSqueeze ( args ) ; if ( sameAs ( newStr ) ) {
switch ( evt . getID ( ) ) { case WindowEvent . WINDOW_ACTIVATED : windowListener . windowActivated ( evt ) ; break ; case WindowEvent . WINDOW_CLOSED : windowListener . windowClosed ( evt ) ; break ; case WindowEvent . WINDOW_CLOSING : windowListener . windowClosing ( evt ) ; break ; case WindowEvent . WINDOW_DEACTIVATED : windowListener . windowDeactivated ( evt ) ; break ; case WindowEvent . WINDOW_DEICONIFIED : windowListener . windowDeiconified ( evt ) ; break ; case WindowEvent . WINDOW_ICONIFIED : windowListener . windowIconified ( evt ) ; break ; case WindowEvent . WINDOW_OPENED : windowListener . windowOpened ( evt ) ; break ; case WindowEvent . WINDOW_GAINED_FOCUS : case WindowEvent . WINDOW_LOST_FOCUS : processWindowFocusEvent ( evt ) ; break ; case WindowEvent . WINDOW_STATE_CHANGED : processWindowStateEvent ( evt ) ; break ; } <CTX> protected void processWindowEvent ( WindowEvent evt ) { if ( windowListener != null ) { switch ( evt . getID ( ) ) { case WindowEvent . WINDOW_ACTIVATED : windowListener . windowActivated ( evt ) ; break ; case WindowEvent . WINDOW_CLOSED : windowListener . windowClosed ( evt ) ; break ; case WindowEvent . WINDOW_CLOSING : windowListener . windowClosing ( evt ) ; break ; case WindowEvent . WINDOW_DEACTIVATED : windowListener . windowDeactivated ( evt ) ; break ; case WindowEvent . WINDOW_DEICONIFIED : windowListener . windowDeiconified ( evt ) ; break ; case WindowEvent . WINDOW_ICONIFIED : windowListener . windowIconified ( evt ) ; break ; case WindowEvent . WINDOW_OPENED : windowListener . windowOpened ( evt ) ; break ; case WindowEvent . WINDOW_GAINED_FOCUS : case WindowEvent . WINDOW_LOST_FOCUS : processWindowFocusEvent ( evt ) ; break ; case WindowEvent . WINDOW_STATE_CHANGED : processWindowStateEvent ( evt ) ; break ; } } }	if ( windowListener != null ) { switch ( evt . getID ( ) ) { case WindowEvent . WINDOW_ACTIVATED : windowListener . windowActivated ( evt ) ; break ; case WindowEvent . WINDOW_CLOSED : windowListener . windowClosed ( evt ) ; break ; case WindowEvent . WINDOW_CLOSING : windowListener . windowClosing ( evt ) ; break ; case WindowEvent . WINDOW_DEACTIVATED : windowListener . windowDeactivated ( evt ) ; break ; case WindowEvent . WINDOW_DEICONIFIED : windowListener . windowDeiconified ( evt ) ; break ; case WindowEvent . WINDOW_ICONIFIED : windowListener . windowIconified ( evt ) ; break ; case WindowEvent . WINDOW_OPENED : windowListener . windowOpened ( evt ) ; break ; default : break ; } }
getAddedFigure ( ) . displayBox ( getAnchorPoint ( ) , new Point ( x , y ) ) ; <CTX> public void mouseDrag ( MouseEvent e , int x , int y ) { if ( getAddedFigure ( ) != null ) { getAddedFigure ( ) . displayBox ( getAnchorPoint ( ) , new Point ( x , y ) ) ; } }	getAddedFigure ( ) . displayBox ( new Point ( getAnchorX ( ) , getAnchorY ( ) ) , new Point ( x , y ) ) ;
onInternalEndRender ( ) ; <CTX> public final void render ( ) { / / Rendering is beginning onInternalBeginRender ( ) ; onBeginRender ( ) ; RuntimeException exception = null ; try { / / Get request cycle to render to final RequestCycle cycle = getRequestCycle ( ) ; / / Save original Response final Response originalResponse = cycle . getResponse ( ) ; / / If component is not visible , set response to NullResponse if ( ! isVisible ( ) ) { cycle . setResponse ( NullResponse . getInstance ( ) ) ; } / / Synchronize on model lock while rendering to help ensure / / that the model doesn t change while its being read synchronized ( getModelLock ( ) ) { / / Call implementation to render component onRender ( ) ; / / Tell the page that the component rendered getPage ( ) . componentRendered ( this ) ; } / / Restore original response cycle . setResponse ( originalResponse ) ; } catch ( RuntimeException e ) { / / Remember the exception until finally block is / / done and then re - throw it . exception = e ; } finally { try { / / Rendering has completed onEndRender ( ) ; onInternalEndRender ( ) ; / / Detach models now that rendering is fully completed detachModels ( ) ; } catch ( RuntimeException ex ) { / / Prepare for re - throw only if another exception / / is not yet registered if ( exception == null ) { exception = ex ; } } } / / Ret - throw the exception if ( exception != null ) { throw exception ; } }	internalOnEndRender ( ) ;
if ( this == subTree ) return true ; <CTX> public boolean sameDirection ( boolean isVertical , LayoutTreeNode subTree ) { boolean treeVertical = getSash ( ) . isVertical ( ) ; if ( treeVertical != isVertical ) return false ; while ( subTree != null ) { if ( this == subTree ) return true ; if ( subTree . children [ 0 ] . isVisible ( ) && subTree . children [ 1 ] . isVisible ( ) ) if ( subTree . getSash ( ) . isVertical ( ) != isVertical ) return false ; subTree = subTree . getParent ( ) ; } return true ; }	if ( this == subTree ) { return true ; }
return new PsiBuilderImpl ( lang , project , SharedImplUtil . findCharTableByTree ( tree ) , seq ) ; <CTX> public PsiBuilder createBuilder ( ASTNode tree , Language lang , CharSequence seq , final Project project ) { return new PsiBuilderImpl ( lang , project , SharedImplUtil . findCharTableByTree ( tree ) , seq ) ; }	return new PsiBuilderImpl ( lang , tree , project , seq ) ;
addMethod ( name , new CallbackMethod ( method ) , Constants . NOEX_PRIVATE | Constants . NOEX_CFUNC ) ; <CTX> public void definePrivateMethod ( String name , Callback method ) { addMethod ( name , new CallbackMethod ( method ) , Constants . NOEX_PRIVATE | Constants . NOEX_CFUNC ) ; }	addMethod ( name , new CallbackMethod ( method , Visibility . PRIVATE ) ) ;
ClassContext ( ClassType type ) throws SemanticException { <CTX> ClassContext ( ClassType type ) throws SemanticException { this . type = type ; this . ts = type . getTypeSystem ( ) ; }	ClassContext ( ClassType type ) {
IPatch myPatch = myModel . getPatchAt ( table . getSelectedRow ( ) ) ; new SysexStoreDialog ( myPatch ) ; <CTX> public void storeSelectedPatch ( ) { IPatch myPatch = myModel . getPatchAt ( table . getSelectedRow ( ) ) ; new SysexStoreDialog ( myPatch ) ; }	new SysexStoreDialog ( getSelectedPatch ( ) , 0 ) ;
getMessageTextArea ( ) . append ( lineSeparator + lineSeparator + exception . getMessage ( ) ) ; getMessageFrame ( ) . show ( ) ; <CTX> private void handleException ( Throwable exception ) { / / Write exceptions to the log - window getMessageTextArea ( ) . append ( lineSeparator + lineSeparator + exception . getMessage ( ) ) ; getMessageFrame ( ) . show ( ) ; }	StringWriter sw = new StringWriter ( ) ; exception . printStackTrace ( new PrintWriter ( sw ) ) ; String trace = new String ( sw . getBuffer ( ) ) ; getMessageTextArea ( ) . append ( lineSeparator + lineSeparator + trace ) ; getMessageFrame ( ) . show ( ) ;
return getComponentAt ( x , y ) ; <CTX> public Component locate ( int x , int y ) { return getComponentAt ( x , y ) ; }	return contains ( x , y ) ? this : null ;
enabled = en ; setChanged ( ) ; <CTX> public void setEnabled ( boolean en ) { enabled = en ; setChanged ( ) ; }	setEnabled ( true ) ;
super ( ValueType . INTEGER_TYPE , <CTX> private IntegerGreaterEvaluator ( ) { super ( ValueType . INTEGER_TYPE , Operator . GREATER ) ; }	super ( ValueType . PINTEGER_TYPE ,
TextFragmentBox box = null ; int i ; for ( i = fragments . size ( ) - 1 ; i >= 0 ; i -- ) { box = ( TextFragmentBox ) fragments . get ( i ) ; if ( box . getBaseline ( ) < p . y ) break ; box = null ; <CTX> private int findPreviousLineOffset ( Point p ) { if ( getBounds ( ) . y > p . y ) return - 1 ; TextFragmentBox box = null ; int i ; for ( i = fragments . size ( ) - 1 ; i >= 0 ; i -- ) { box = ( TextFragmentBox ) fragments . get ( i ) ; if ( box . getBaseline ( ) < p . y ) break ; box = null ; } if ( box == null ) return - 1 ; TextLayout layout = FlowUtilities . getTextLayout ( ) ; layout . setFont ( getFont ( ) ) ; String fragString ; if ( bidiInfo == null ) fragString = text . substring ( box . offset , box . offset + box . length ) ; else fragString = getBidiSubstring ( box , i ) ; layout . setText ( fragString ) ; int trailing [ ] = new int [ 1 ] ; int x = p . x - box . getX ( ) ; if ( isMirrored ( ) ) x = box . getWidth ( ) - x ; int layoutOffset = layout . getOffset ( x , p . y - box . getTextTop ( ) , trailing ) + trailing [ 0 ] ; layoutOffset -= getBidiPrefixLength ( box , i ) ; return box . offset + layoutOffset ; }	TextFragmentBox closestBox = null ; int index = 0 ; for ( int i = fragments . size ( ) - 1 ; i >= 0 ; i -- ) { TextFragmentBox box = ( TextFragmentBox ) fragments . get ( i ) ; if ( box . getBaseline ( ) + box . getLineRoot ( ) . contentDescent < p . y && ( closestBox == null || box . getBaseline ( ) > closestBox . getBaseline ( ) || hDistanceBetween ( box , p . x ) < hDistanceBetween ( closestBox , p . x ) ) ) { closestBox = box ; index = i ; }
if ( textControl == null ) return ; <CTX> public void removeText ( Text textControl ) { if ( textControl == null ) return ; textControl . removeListener ( SWT . Activate , textControlListener ) ; textControl . removeListener ( SWT . Deactivate , textControlListener ) ; textControl . removeMouseListener ( mouseAdapter ) ; textControl . removeKeyListener ( keyAdapter ) ; activeTextControl = null ; updateActionsEnableState ( ) ; }	if ( textControl == null ) { return ; }
Asserts . isTrue ( isCurrent ( ) ) ; <CTX> public void notifyStarted ( ) { Asserts . isTrue ( isCurrent ( ) ) ; synchronized ( hasStartedLock ) { hasStarted = true ; hasStartedLock . notifyAll ( ) ; } }	assert isCurrent ( ) ;
IStyle rowStyle = ( lastRow == null ? null : lastRowArea . getContent ( ) . getComputedStyle ( ) ) ; <CTX> protected void closeTableLayout ( ) { closeLayout ( new IBottomBorderResolverStrategy ( ) { public int resolveBottomBorder ( CellArea cell ) { IStyle tableStyle = tableContent . getComputedStyle ( ) ; IStyle rowStyle = ( lastRow == null ? null : lastRowArea . getContent ( ) . getComputedStyle ( ) ) ; IStyle columnStyle = getColumnStyle ( cell . getColumnID ( ) ) ; IStyle cellContentStyle = cell . getContent ( ) . getComputedStyle ( ) ; IStyle cellAreaStyle = cell . getStyle ( ) ; bcr . resolveTableBottomBorder ( tableStyle , rowStyle , columnStyle , cellContentStyle , cellAreaStyle ) ; return getDimensionValue ( cellAreaStyle . getProperty ( StyleConstants . STYLE_BORDER_BOTTOM_WIDTH ) ) ; } } ) ; }	IContent cellContent = cell . getContent ( ) ; IStyle rowStyle = ( ( IContent ) cellContent . getParent ( ) ) . getComputedStyle ( ) ;
return RubyBoolean . newBoolean ( runtime , obj . isKindOf ( this ) ) ; <CTX> public RubyBoolean op_eqq ( IRubyObject obj ) { return RubyBoolean . newBoolean ( runtime , obj . isKindOf ( this ) ) ; }	return getRuntime ( ) . newBoolean ( obj . isKindOf ( this ) ) ;
ViewedMessage msg = ( ViewedMessage ) path . getTip ( ) ; <CTX> synchronized Vector getSelectedViewedMessageVector ( ) { Vector msgVector = new Vector ( ) ; SelectionManager selection = fMessageTree . getSelectionManager ( ) ; Enumeration messages = selection . getSelection ( ) ; while ( messages . hasMoreElements ( ) ) { TreePath path = ( TreePath ) messages . nextElement ( ) ; ViewedMessage msg = ( ViewedMessage ) path . getTip ( ) ; if ( msg != null ) { msgVector . insertElementAt ( msg , msgVector . size ( ) ) ; } } return msgVector ; }	ViewedMessage msg = ( ViewedMessage ) path . getPath ( ) [ path . getPath ( ) . length - 1 ] ;
DbMailbox . updateHighestItem ( this ) ; <CTX> private int getNextItemId ( int idFromRedo ) throws ServiceException { int lastId = getLastItemId ( ) ; int nextId = ( idFromRedo == ID_AUTO_INCREMENT ? lastId + 1 : idFromRedo ) ; if ( nextId > lastId ) { mCurrentChange . itemId = nextId ; if ( nextId / DbMailbox . ITEM_CHECKPOINT_INCREMENT > lastId / DbMailbox . ITEM_CHECKPOINT_INCREMENT ) DbMailbox . updateHighestItem ( this ) ; } return nextId ; }	DbMailbox . updateMailboxStats ( this ) ;
excptnClass != Exception . class ) { <CTX> public void handleNativeException ( Exception exception ) { if ( exception instanceof RaiseException ) { throw ( RaiseException ) exception ; } Class excptnClass = exception . getClass ( ) ; RubyProc handler = ( RubyProc ) exceptionHandlers . get ( excptnClass . getName ( ) ) ; while ( handler == null && excptnClass != Exception . class ) { excptnClass = excptnClass . getSuperclass ( ) ; } if ( handler != null ) { handler . call ( new IRubyObject [ ] { JavaUtil . convertJavaToRuby ( runtime , exception ) } ) ; } else { throw createRaiseException ( exception ) ; } }	excptnClass != Throwable . class ) {
return mavenProjectBuilder . buildWithDependencies ( mavenProject , localRepository , profileManager ) ; <CTX> public MavenProject readProjectWithDependencies ( File mavenProject ) throws ProjectBuildingException , ArtifactResolutionException { return mavenProjectBuilder . buildWithDependencies ( mavenProject , localRepository , profileManager ) ; }	return mavenProjectBuilder . buildWithDependencies ( mavenProject , localRepository , profileManager , transferListener ) ;
this . propertyOnDelete = propertyOnDelete ; <CTX> public void setPropertyOnDelete ( String propertyOnDelete ) { this . propertyOnDelete = propertyOnDelete ; }	properties . assignPropertyOnDeleteName ( propertyOnDelete ) ;
if ( superClass != null ) { return superClass . getCustomBuildStep ( ) ; <CTX> public boolean getCustomBuildStep ( ) { if ( customBuildStep == null ) { if ( superClass != null ) { return superClass . getCustomBuildStep ( ) ; } else { return false ; / / default is false } } return customBuildStep . booleanValue ( ) ; }	if ( getSuperClass ( ) != null ) { return getSuperClass ( ) . getCustomBuildStep ( ) ;
( ( IPrivileged ) channel ) . setPortalControlStructures ( pcs ) ; <CTX> public void setPortalControlStructures ( PortalControlStructures pcs ) throws PortalException { ( ( IPrivileged ) channel ) . setPortalControlStructures ( pcs ) ; }	( ( IMultithreadedPrivileged ) channel ) . setPortalControlStructures ( pcs , uid ) ;
Component getComponent ( ISettings settings ) ; <CTX> Component getComponent ( ISettings settings ) ;	Component getComponent ( ISettings settings , DataEngine dataEngine ) ;
return this . encodeRedirectUrl ( url ) ; <CTX> public String encodeRedirectUrl ( String url ) { return this . encodeRedirectUrl ( url ) ; }	return this . delegate . encodeRedirectUrl ( url ) ;
URL url = Platform . find ( bundle , new Path ( editorInfo . getIconPath ( ) ) ) ; <CTX> public ImageDescriptor getImageDescriptor ( String editorKind ) { CheatSheetRegistryReader . TaskEditorNode editorInfo = CheatSheetRegistryReader . getInstance ( ) . findTaskEditor ( editorKind ) ; if ( editorInfo != null ) { Bundle bundle = Platform . getBundle ( editorInfo . getPluginId ( ) ) ; URL url = Platform . find ( bundle , new Path ( editorInfo . getIconPath ( ) ) ) ; if ( url != null ) { try { url = Platform . resolve ( url ) ; return ImageDescriptor . createFromURL ( url ) ; } catch ( IOException e ) { return null ; } } } return null ; }	URL url = FileLocator . find ( bundle , new Path ( editorInfo . getIconPath ( ) ) , null ) ;
return RubyString . newString ( runtime , new PrintfFormat ( Locale . US , getValue ( ) ) . sprintf ( args ) ) ; <CTX> public IRubyObject format ( IRubyObject arg ) { if ( arg instanceof RubyArray ) { Object [ ] args = new Object [ ( ( RubyArray ) arg ) . getLength ( ) ] ; for ( int i = 0 ; i < args . length ; i ++ ) { args [ i ] = JavaUtil . convertRubyToJava ( ( ( RubyArray ) arg ) . entry ( i ) ) ; } return RubyString . newString ( runtime , new PrintfFormat ( Locale . US , getValue ( ) ) . sprintf ( args ) ) ; } return RubyString . newString ( runtime , new PrintfFormat ( Locale . US , getValue ( ) ) . sprintf ( JavaUtil . convertRubyToJava ( arg ) ) ) ; }	return getRuntime ( ) . newString ( new PrintfFormat ( Locale . US , getValue ( ) ) . sprintf ( args ) ) ;
if ( gapOffset < offset ) root . contentInserted ( gapOffset , offset , gapWidth ) ; <CTX> public synchronized void contentInserted ( int offset , int length ) { if ( root == null ) { gapWidth = 0 ; return ; } int newGapOffset ; PosBottomHalf highest = root . findHighest ( offset ) ; if ( highest == null ) newGapOffset = 0 ; else newGapOffset = highest . getOffset ( ) + 1 ; if ( gapWidth != 0 ) { if ( gapOffset < offset ) root . contentInserted ( gapOffset , offset , gapWidth ) ; else root . contentInserted ( offset , gapOffset , - gapWidth ) ; } gapOffset = newGapOffset ; gapWidth += length ; } / / } } }	if ( gapStartsAt . offset < offset ) root . contentInserted ( gapStartsAt . offset , offset , gapWidth ) ;
while ( iterator . hasNext ( ) ) Util . assertInstance ( iterator . next ( ) , ActivityDefinition . class ) ; <CTX> static void writeActivityDefinitions ( IMemento memento , String name , List activityDefinitions ) { if ( memento == null || name == null || activityDefinitions == null ) throw new NullPointerException ( ) ; activityDefinitions = new ArrayList ( activityDefinitions ) ; Iterator iterator = activityDefinitions . iterator ( ) ; while ( iterator . hasNext ( ) ) Util . assertInstance ( iterator . next ( ) , ActivityDefinition . class ) ; iterator = activityDefinitions . iterator ( ) ; while ( iterator . hasNext ( ) ) writeActivityDefinition ( memento . createChild ( name ) , ( ActivityDefinition ) iterator . next ( ) ) ; }	while ( iterator . hasNext ( ) ) { Util . assertInstance ( iterator . next ( ) , ActivityDefinition . class ) ; }
boolean doors , boolean hotspots ) { <CTX> public static void loadData ( HackModule hm , boolean sprites , boolean doors , boolean hotspots ) { loadMapAddresses ( hm . rom ) ; loadDrawTilesets ( hm . rom ) ; if ( sprites ) { TPTEditor . readFromRom ( hm ) ; SpriteEditor . readFromRom ( hm . rom ) ; loadSpriteData ( hm . rom ) ; } if ( doors ) loadDoorData ( hm . rom ) ; if ( hotspots ) HotspotEditor . readFromRom ( hm ) ; }	boolean doors , boolean hotspots , boolean enemies , boolean mapChanges ) {
Iterator < String > i = bugCodeList . iterator ( ) ; while ( i . hasNext ( ) ) { if ( bugCode . equals ( i . next ( ) ) ) <CTX> public boolean match ( BugInstance bugInstance ) { String bugCode = bugInstance . getAbbrev ( ) ; Iterator < String > i = bugCodeList . iterator ( ) ; while ( i . hasNext ( ) ) { if ( bugCode . equals ( i . next ( ) ) ) return true ; } return false ; }	for ( String aBugCodeList : bugCodeList ) { if ( bugCode . equals ( aBugCodeList ) )
return r . bounds ; <CTX> public Rectangle getBounds ( TreePath path , Rectangle rect ) { if ( dirty ) update ( ) ; Object last = path . getLastPathComponent ( ) ; NodeRecord r = ( NodeRecord ) nodes . get ( last ) ; if ( r == null ) / / This node is not visible . return new Rectangle ( ) ; else { if ( r . bounds == null ) { Rectangle dim = getNodeDimensions ( last , r . row , r . depth , r . isExpanded , rect ) ; r . bounds = dim ; } return r . bounds ; } }	rect . setRect ( r . bounds ) ;
return new CrossJoinFunDef ( dummyFunDef ) ; <CTX> protected FunDef createFunDef ( Exp [ ] args , FunDef dummyFunDef ) { return new CrossJoinFunDef ( dummyFunDef ) ; }	return new FunDefBase ( dummyFunDef ) { public Object evaluate ( Evaluator evaluator , Exp [ ] args ) { HashSet set = new HashSet ( ) ; set . addAll ( ( List ) getArg ( evaluator , args , 1 ) ) ; List set 1 = ( List ) getArg ( evaluator , args , 0 ) ; List result = new ArrayList ( ) ; for ( int i = 0 , count = set 1 . size ( ) ; i < count ; i ++ ) { Object o = set 1 . get ( i ) ; if ( ! set . contains ( o ) ) { result . add ( o ) ; } } return result ; } } ;
return model . findParameter ( paramName ) ; <CTX> public ParameterHandle findParameter ( String paramName ) throws ReportServiceException { if ( paramName == null ) return null ; IReportRunnable runnable = ( IReportRunnable ) this . reportDesignHandle . getDesignObject ( ) ; assert runnable != null ; ModuleHandle model = runnable . getDesignHandle ( ) . getModuleHandle ( ) ; assert model != null ; return model . findParameter ( paramName ) ; }	if ( runnable != null ) model = runnable . getDesignHandle ( ) . getModuleHandle ( ) ; if ( model != null ) return model . findParameter ( paramName ) ; else return null ;
return valueMap . keySet ( ) . iterator ( ) ; <CTX> private Iterator keyIterator ( ) { return valueMap . keySet ( ) . iterator ( ) ; }	return new ArrayList ( valueMap . keySet ( ) ) . iterator ( ) ;
void setBigDecimal ( int parameterIndex , BigDecimal x ) throws <CTX> void setBigDecimal ( int parameterIndex , BigDecimal x ) throws SQLException ;	void setBigDecimal ( int index , BigDecimal value ) throws
ArrayList list = handle . getListValue ( ) ; if ( list != null ) <CTX> private final void clearUnusedColumnHints ( DataSetHandle dataSetHandle , IResultMetaData metaData ) throws BirtException { PropertyHandle handle = dataSetHandle . getPropertyHandle ( DataSetHandle . COLUMN_HINTS_PROP ) ; ArrayList list = handle . getListValue ( ) ; if ( list != null ) { int count = list . size ( ) ; for ( int n = count - 1 ; n >= 0 ; n -- ) { ColumnHint hint = ( ColumnHint ) list . get ( n ) ; String columnName = ( String ) hint . getProperty ( handle . getDesign ( ) , ColumnHint . COLUMN_NAME_MEMBER ) ; boolean found = false ; if ( ! isEmpty ( hint , handle . getModule ( ) . getModuleHandle ( ) ) ) { for ( int m = 0 ; m < metaData . getColumnCount ( ) && ! found ; m ++ ) { found = columnName . equals ( metaData . getColumnName ( m + 1 ) ) ; } } if ( ! found ) { try { / / remove the item handle . removeItem ( hint ) ; } catch ( PropertyValueException e ) { } } } } }	if ( handle != null && handle . getListValue ( ) != null )
setStreet ( STREET_DEFAULT ) ; <CTX> public void resetPropertyValue ( Object property ) { if ( P_ID_POSTALCODE . equals ( property ) ) { setPostalCode ( POSTALCODE_DEFAULT ) ; return ; } if ( P_ID_CITY . equals ( property ) ) { setCity ( CITY_DEFAULT ) ; return ; } if ( P_ID_PROVINCE . equals ( property ) ) { setProvince ( PROVINCE_DEFAULT ) ; return ; } ; if ( P_ID_STREET . equals ( property ) ) { setStreet ( STREET_DEFAULT ) ; return ; } }	setStreet ( new StreetAddress ( ) ) ;
return new FontRenderContext ( null , true , true ) ; <CTX> public FontRenderContext getFontRenderContext ( ) { return new FontRenderContext ( null , true , true ) ; }	boolean antialias = RenderingHints . VALUE_TEXT_ANTIALIAS_ON . equals ( getRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING ) ) ; boolean fractions = RenderingHints . VALUE_FRACTIONALMETRICS_ON . equals ( getRenderingHint ( RenderingHints . KEY_FRACTIONALMETRICS ) ) ; return new FontRenderContext ( new AffineTransform ( ) , antialias , fractions ) ;
saveProjectAsItemActionPerformed ( evt ) ; <CTX> public void actionPerformed ( java . awt . event . ActionEvent evt ) { saveProjectAsItemActionPerformed ( evt ) ; }	loadBugsItemActionPerformed ( evt ) ;
view . setSorter ( dialog . getSorter ( ) ) ; <CTX> public void run ( ) { if ( dialog . open ( ) == Window . OK && dialog . isDirty ( ) ) { view . setSorter ( dialog . getSorter ( ) ) ; } }	view . setComparator ( dialog . getSorter ( ) ) ;
this . callListeners . remove ( listener ) ; <CTX> public void removeCallChangeListener ( CallChangeListener listener ) { this . callListeners . remove ( listener ) ; }	synchronized ( callListeners ) { this . callListeners . remove ( listener ) ; }
comp . method . compile_push_string ( symbol . toString ( ) ) ; <CTX> public void compile ( Compilation comp , boolean ignore_result ) { if ( ignore_result ) return ; if ( binding != null ) compile_load ( binding , comp ) ; else { comp . method . compile_push_string ( symbol . toString ( ) ) ; comp . method . compile_invoke_static ( comp . lookupGlobalMethod ) ; } }	comp . compileConstant ( symbol ) ; if ( comp . immediate ) comp . method . compile_checkcast ( comp . scmSymbolType ) ;
Asserts . isTrue ( arity >= 0 ) ; <CTX> public static Arity fixed ( int arity ) { Asserts . isTrue ( arity >= 0 ) ; return createArity ( arity ) ; }	assert arity >= 0 ;
return new LineSeriesAttributeComposite ( parent , SWT . NONE , series ) ; <CTX> public Composite getSeriesAttributeSheet ( Composite parent , Series series , IUIServiceProvider builder , Object oContext ) { return new LineSeriesAttributeComposite ( parent , SWT . NONE , series ) ; }	return new LineSeriesAttributeComposite ( parent , SWT . NONE , context , series ) ;
OutputStreamWriter osw = new OutputStreamWriter ( outputStream , getCharacterSet ( ) . getName ( ) ) ; <CTX> public void write ( OutputStream outputStream ) throws IOException { if ( getValue ( ) != null ) { OutputStreamWriter osw = new OutputStreamWriter ( outputStream , getCharacterSet ( ) . getName ( ) ) ; osw . write ( getValue ( ) ) ; } }	OutputStreamWriter osw = null ; if ( getCharacterSet ( ) != null ) { osw = new OutputStreamWriter ( outputStream , getCharacterSet ( ) . getName ( ) ) ; } else { osw = new OutputStreamWriter ( outputStream ) ; }
&&_group != null && !_socket . isClosed ( ) ) {_socket . leaveGroup (_group ) ; <CTX> void setListeningSocket ( MulticastSocket multicastSocket ) throws IOException { / / a ) Close old socket ( if non - null ) to alert lock holders . . . if (_socket != null )_socket . close ( ) ; / / b ) Replace with new sock . Notify the udpThread . synchronized (_receiveLock ) { / / synchronized (_sendLock ) { / / if the input is null , then the service will shut off ; ) . / / leave the group if we re shutting off the service . if ( multicastSocket == null &&_socket != null &&_group != null && !_socket . isClosed ( ) ) {_socket . leaveGroup (_group ) ; }_socket = ( MulticastSocket ) multicastSocket ;_receiveLock . notify ( ) ; / /_sendLock . notify ( ) ; / / } } }	&&_group != null ) { try {_socket . leaveGroup (_group ) ; } catch ( IOException ignored ) { }
return convertToClass ( ( ( ParameterizedType ) type ) . getActualTypeArguments ( ) [ 0 ] ) ; <CTX> public Class getScalarType ( ) { if ( this . typeInformationValid ) { Type type = this . leaf . getValueType ( ) ; Class clazz = convertToClass ( type ) ; if ( clazz . isArray ( ) ) { return clazz . getComponentType ( ) ; } else if ( Collection . class . isAssignableFrom ( clazz ) ) { if ( type instanceof ParameterizedType ) { return convertToClass ( ( ( ParameterizedType ) type ) . getActualTypeArguments ( ) [ 0 ] ) ; } else { return String . class ; } } else if ( Map . class . isAssignableFrom ( clazz ) ) { if ( type instanceof ParameterizedType ) { return convertToClass ( ( ( ParameterizedType ) type ) . getActualTypeArguments ( ) [ 1 ] ) ; } else { return String . class ; } } else { return clazz ; } } else { return null ; } }	return convertToClass ( ( ( ParameterizedType ) type ) . getActualTypeArguments ( ) [ 0 ] , this . leaf ) ;
target [ 0 ] = new CDebugTarget ( launch , ICDebugTargetType . TARGET_TYPE_LOCAL_RUN , <CTX> public void run ( IProgressMonitor m ) { target [ 0 ] = new CDebugTarget ( launch , ICDebugTargetType . TARGET_TYPE_LOCAL_RUN , cdiTarget , name , debuggeeProcess , debuggerProcess , file , allowTerminate , allowDisconnect ) ; }	target [ 0 ] = new CDebugTarget ( launch , ICDebugTargetType . TARGET_TYPE_LOCAL_ATTACH ,
if ( newWork . getPeek ( ) == null && newWork . getPop ( ) == null && newWork . getPush ( ) == null ) { <CTX> public void setInitWork ( JMethodDeclaration newWork ) { / / if new work function has no I / O rates and old one does , / / then transfer rates to new one . This is an ugly remnant of / / the old mode of operation , where I / O rates were stored / / outside the function . if ( newWork . getPeek ( ) == null && newWork . getPop ( ) == null && newWork . getPush ( ) == null ) { newWork . setPeek ( getInitWork ( ) . getPeek ( ) ) ; newWork . setPop ( getInitWork ( ) . getPop ( ) ) ; newWork . setPush ( getInitWork ( ) . getPush ( ) ) ; } addReplacementMethod ( newWork , getInitWork ( ) ) ; getInitPhases ( ) [ 0 ] = newWork ; checkRep ( ) ; }	if ( ! newWork . doesIO ( ) ) {
String o 0 = getStringArg ( evaluator , args , 0 , null ) ; String o 1 = getStringArg ( evaluator , args , 1 , null ) ; if ( o 0 == null || o 1 == null ) { <CTX> public Object evaluate ( Evaluator evaluator , Exp [ ] args ) { String o 0 = getStringArg ( evaluator , args , 0 , null ) ; String o 1 = getStringArg ( evaluator , args , 1 , null ) ; if ( o 0 == null || o 1 == null ) { return null ; } return Boolean . valueOf ( o 0 . compareTo ( o 1 ) > 0 ) ; }	Double o 0 = getDoubleArg ( evaluator , args , 0 ) ; Double o 1 = getDoubleArg ( evaluator , args , 1 ) ; if ( o 0 . isNaN ( ) || o 1 . isNaN ( ) ) {
this . projectFile = new File ( projectFile ) ; <CTX> public void setProjectFile ( String projectFile ) { this . projectFile = new File ( projectFile ) ; }	this . projectAttribute = projectAttribute ;
if ( ! nameStatus . isOK ( ) ) <CTX> private String checkValidName ( ) { String name = this . projectNameField . getText ( ) ; IWorkspace workspace = getProject ( ) . getWorkspace ( ) ; IStatus nameStatus = workspace . validateName ( name , IResource . PROJECT ) ; if ( ! nameStatus . isOK ( ) ) return nameStatus . getMessage ( ) ; IProject newProject = workspace . getRoot ( ) . getProject ( name ) ; if ( newProject . exists ( ) ) { return NLS . bind ( IDEWorkbenchMessages . CopyProjectAction_alreadyExists , name ) ; } return null ; }	if ( ! nameStatus . isOK ( ) ) {
synchronized ( messages ) { for ( Iterator iter = messages . iterator ( ) ; iter . hasNext ( ) ; ) { try { MessageReference r = ( MessageReference ) iter . next ( ) ; if ( messageId . equals ( r . getMessageId ( ) . toString ( ) ) ) { r . incrementReferenceCount ( ) ; try { Message m = r . getMessage ( ) ; BrokerSupport . resend ( context , m , dest ) ; } finally { r . decrementReferenceCount ( ) ; } return true ; } } catch ( IOException e ) { } } } return false ; <CTX> public boolean copyMessageTo ( ConnectionContext context , String messageId , ActiveMQDestination dest ) throws Exception { synchronized ( messages ) { for ( Iterator iter = messages . iterator ( ) ; iter . hasNext ( ) ; ) { try { MessageReference r = ( MessageReference ) iter . next ( ) ; if ( messageId . equals ( r . getMessageId ( ) . toString ( ) ) ) { r . incrementReferenceCount ( ) ; try { Message m = r . getMessage ( ) ; BrokerSupport . resend ( context , m , dest ) ; } finally { r . decrementReferenceCount ( ) ; } return true ; } } catch ( IOException e ) { } } } return false ; }	return copyMatchingMessages ( context , createMessageIdFilter ( messageId ) , dest , 1 ) > 0 ;
if ( objects . size ( ) == 1 ) return commonClass ; <CTX> private Class getCommonClass ( List objects ) { if ( objects == null || objects . size ( ) == 0 ) return null ; Class commonClass = objects . get ( 0 ) . getClass ( ) ; / / try easy if ( objects . size ( ) == 1 ) return commonClass ; / / try harder for ( int i = 1 ; i < objects . size ( ) ; i ++ ) { Object object = objects . get ( i ) ; Class newClass = object . getClass ( ) ; / / try the short cut if ( newClass . equals ( commonClass ) ) continue ; / / compute common class commonClass = getCommonClass ( commonClass , newClass ) ; / / give up if ( commonClass == null ) return null ; } return commonClass ; }	if ( objects . size ( ) == 1 ) { return commonClass ;
SingleVariableDeclaration result = targetAst . newSingleVariableDeclaration ( ) ; <CTX> public ASTNode sample ( AST targetAst , boolean parented ) { SingleVariableDeclaration result = targetAst . newSingleVariableDeclaration ( ) ; if ( parented ) { targetAst . newCatchClause ( ) . setException ( result ) ; } return result ; }	Block result = targetAst . newBlock ( ) ;
assert propDefn . isList ( ) ; <CTX> private static Object validateList ( DesignElementHandle element , ElementPropertyDefn propDefn , Object value ) throws SemanticException { if ( ! ( value instanceof List ) ) return null ; assert propDefn . isList ( ) ; List retList = new ArrayList ( ) ; List list = ( List ) value ; IStructureDefn structDefn = propDefn . getStructDefn ( ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { IStructure item = ( IStructure ) list . get ( i ) ; if ( item . getDefn ( ) != structDefn ) throw new PropertyValueException ( element . getElement ( ) , propDefn , item , PropertyValueException . DESIGN_EXCEPTION_WRONG_ITEM_TYPE ) ; retList . add ( doValidateStructure ( element , structDefn , item ) ) ; } return retList ; }	IPropertyDefn tmpPropDefn = propDefn ; if ( memberDefn != null ) tmpPropDefn = memberDefn ; assert tmpPropDefn . isList ( ) ;
SVNClientException . wrapException ( e ) ; <CTX> private void diff ( String oldPath , SVNRevision oldPathRevision , String newPath , SVNRevision newPathRevision , File outFile , boolean recurse ) { if ( newPath == null ) newPath = oldPath ; if ( oldPathRevision == null ) oldPathRevision = SVNRevision . BASE ; if ( newPathRevision == null ) newPathRevision = SVNRevision . WORKING ; try { InputStream is =_cmd . diff ( oldPath , toString ( oldPathRevision ) , newPath , toString ( newPathRevision ) , recurse ) ; streamToFile ( is , outFile ) ; } catch ( IOException e ) { / / this should never happen } catch ( CmdLineException e ) { SVNClientException . wrapException ( e ) ; } }	throw SVNClientException . wrapException ( e ) ;
init_properties ( ) ; <CTX> public static String getProperty ( String property ) { if ( secman != null ) secman . checkPropertyAccess ( property ) ; init_properties ( ) ; return properties . getProperty ( property ) ; }	if ( properties == null ) init_properties ( ) ;
getXPathHandler ( ) . number ( Integer . parseInt ( token . getTokenText ( ) ) ) ; <CTX> void numberInteger ( ) throws org . jaxen . saxpath . SAXPathException { Token token = match ( INTEGER ) ; getXPathHandler ( ) . number ( Integer . parseInt ( token . getTokenText ( ) ) ) ; }	String text = token . getTokenText ( ) ; try { getXPathHandler ( ) . number ( Integer . parseInt ( text ) ) ; } catch ( NumberFormatException ex ) { getXPathHandler ( ) . number ( Double . parseDouble ( text ) ) ; }
reindex ( ) ; <CTX> protected void removeUpdate ( DefaultDocumentEvent event ) { reindex ( ) ; super . removeUpdate ( event ) ; }	super . removeUpdate ( event ) ;
return new SimpleXMLElementValue ( data , className , options ) ; <CTX> public SimpleXMLElementValue simplexml_load_string ( Env env , @ NotNull String data , @ Optional String className , @ Optional int options ) { return new SimpleXMLElementValue ( data , className , options ) ; }	DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; try { DocumentBuilder builder = factory . newDocumentBuilder ( ) ; Document document = builder . parse ( new ByteArrayInputStream ( data . getBytes ( ) ) ) ; return new SimpleXMLElementClass ( document . getDocumentElement ( ) ) ; } catch ( Exception e ) { log . log ( Level . FINE , L . l ( e . toString ( ) ) , e ) ; return NullValue . NULL ; }
throw new ReturnJump ( eval ( iVisited . getValueNode ( ) ) ) ; <CTX> public void visitReturnNode ( ReturnNode iVisited ) { throw new ReturnJump ( eval ( iVisited . getValueNode ( ) ) ) ; }	throw new ReturnJump ( eval ( iVisited . getValueNode ( ) ) , iVisited . getTarget ( ) ) ;
return null ; <CTX> public static EObject resolve ( EObject object ) { if ( object != null ) { if ( object . eIsProxy ( ) ) return EMFCoreUtil . resolve ( TransactionUtil . getEditingDomain ( object ) , object ) ; else return object ; } return null ; }	return object ;
boolean modify = false ; <CTX> public void addFeatures ( ITargetFeature [ ] features ) { boolean modify = false ; for ( int i = 0 ; i < features . length ; i ++ ) { String id = features [ i ] . getId ( ) ; if ( fFeatures . containsKey ( id ) ) continue ; modify = true ; features [ i ] . setModel ( getModel ( ) ) ; fFeatures . put ( id , features [ i ] ) ; } if ( isEditable ( ) && modify ) fireStructureChanged ( features , IModelChangedEvent . INSERT ) ; }	ArrayList list = new ArrayList ( ) ;
setDomNode ( document_. getHtmlPage ( ) ) ; <CTX> public Object get ( final String name , final Scriptable start ) { / / If the DomNode hasn t been set yet then do it now . if ( getDomNodeOrNull ( ) == null && document_!= null ) { setDomNode ( document_. getHtmlPage ( ) ) ; } Object result = super . get ( name , start ) ; final Window thisWindow = ( Window ) start ; / / If we are in a frameset or have an iframe then this might be a frame name if ( result == NOT_FOUND ) { final DomNode domNode = thisWindow . getDomNodeOrNull ( ) ; if ( domNode != null ) { result = getFrameByName ( domNode . getPage ( ) , name ) ; } } / / See if it is an attempt to access an element directly by name or id if we are emulating IE . if ( result == NOT_FOUND ) { / / this tests are quite silly and should be removed when custom JS objects have a clean / / way to get the WebClient they are running in . final DomNode domNode = thisWindow . getDomNodeOrNull ( ) ; if ( domNode != null && domNode . getPage ( ) . getWebClient ( ) . getBrowserVersion ( ) . isIE ( ) ) { final ElementArray array = ( ElementArray ) thisWindow . document_. jsxFunction_getElementsByName ( name ) ; if ( array . jsGet_length ( ) == 1 ) { result = array . get ( 0 , array ) ; } else if ( array . jsGet_length ( ) > 1 ) { result = array ; } else { result = thisWindow . document_. jsxFunction_getElementById ( name ) ; } } } return result ; }	final HtmlPage htmlPage = document_. getHtmlPageOrNull ( ) ; if ( htmlPage != null ) { setDomNode ( htmlPage ) ; }
return ++ errorCount > MAX_ERRORS ? PROCESS_ABORT : PROCESS_CONTINUE ; <CTX> protected void addSymbols ( IASTTranslationUnit ast ) throws InterruptedException , CoreException { / / Add in the includes IASTPreprocessorIncludeStatement [ ] includes = ast . getIncludeDirectives ( ) ; for ( int i = 0 ; i < includes . length ; ++ i ) { IASTPreprocessorIncludeStatement include = includes [ i ] ; IASTFileLocation sourceLoc = include . getFileLocation ( ) ; String sourcePath = sourceLoc != null ? sourceLoc . getFileName ( ) : ast . getFilePath ( ) ; / / command - line includes IIndexFragmentFile sourceFile = codeReaderFactory . createCachedFile ( index , sourcePath ) ; String destPath = include . getPath ( ) ; IIndexFragmentFile destFile = codeReaderFactory . createCachedFile ( index , destPath ) ; index . addInclude ( sourceFile , destFile ) ; } / / Add in the macros IASTPreprocessorMacroDefinition [ ] macros = ast . getMacroDefinitions ( ) ; for ( int i = 0 ; i < macros . length ; ++ i ) { IASTPreprocessorMacroDefinition macro = macros [ i ] ; IASTFileLocation sourceLoc = macro . getFileLocation ( ) ; if ( sourceLoc == null ) continue ; / / skip built - ins and command line macros String filename = sourceLoc . getFileName ( ) ; IIndexFragmentFile sourceFile = codeReaderFactory . createCachedFile ( index , filename ) ; index . addMacro ( sourceFile , macro ) ; } / / Add in the names ast . accept ( new ASTVisitor ( ) { { shouldVisitNames = true ; shouldVisitDeclarations = true ; } public int visit ( IASTName name ) { try { IASTFileLocation nameLoc = name . getFileLocation ( ) ; if ( nameLoc != null ) index . addName ( codeReaderFactory . createCachedFile ( index , nameLoc . getFileName ( ) ) , name ) ; return PROCESS_CONTINUE ; } catch ( Throwable e ) { CCorePlugin . log ( e ) ; return ++ errorCount > MAX_ERRORS ? PROCESS_ABORT : PROCESS_CONTINUE ; } } } ) ; }	return ++ fErrorCount > MAX_ERRORS ? PROCESS_ABORT : PROCESS_CONTINUE ;
return myCachedDetachedType ; <CTX> public PsiType getDetachedType ( PsiElement context ) { if ( myCachedDetachedType != null ) return myCachedDetachedType ; try { myCachedDetachedType = getManager ( ) . getElementFactory ( ) . createTypeFromText ( getText ( ) , context ) ; } catch ( IncorrectOperationException e ) { return getType ( ) ; } return myCachedDetachedType ; }	return type ;
return ( IASTTypeId [ ] ) ArrayUtil . removeNulls ( IASTTypeId . class , typeIds ) ; <CTX> public IASTTypeId [ ] getExceptionSpecification ( ) { if ( typeIds == null ) return IASTTypeId . EMPTY_TYPEID_ARRAY ; return ( IASTTypeId [ ] ) ArrayUtil . removeNulls ( IASTTypeId . class , typeIds ) ; }	typeIds = ( IASTTypeId [ ] ) ArrayUtil . removeNullsAfter ( IASTTypeId . class , typeIds , typeIdsPos ) ; return typeIds ;
current_mode = initial_mode ; <CTX> private static void reset ( ) { if ( ! current_mode . equals ( initial_mode ) ) resetDisplayMode ( ) ; current_mode = initial_mode ; }	current_mode = initial_mode ; }
if ( e . findChild ( child . getId ( ) ) == null ) { <CTX> private void addDeletedChildrenDifferences ( DirectoryEntry e , Difference d ) { for ( Entry child : myChildren ) { if ( e . findChild ( child . getId ( ) ) == null ) { d . addChild ( child . asDeletedDifference ( ) ) ; } } }	if ( e . findDirectChild ( child . getId ( ) ) == null ) {
if ( slot . complexSlotFlag != 0 ) { <CTX> public Object get ( String name , Scriptable start ) { Slot slot = getNamedSlot ( name ) ; if ( slot == null ) { return Scriptable . NOT_FOUND ; } if ( slot . complexSlotFlag != 0 ) { GetterSlot gslot = ( GetterSlot ) slot ; if ( gslot . getter != null ) { return getByGetter ( gslot , start ) ; } } return slot . value ; }	if ( slot instanceof GetterSlot ) {
if ( child . isRequiresLayout ( ) && ! child . getMaster ( ) . getStyle ( ) . isAlternateFlow ( ) ) { <CTX> private void layoutAbsoluteChildren ( LayoutContext c ) { List children = getChildren ( ) ; if ( children . size ( ) > 0 ) { LayoutState state = c . captureLayoutState ( ) ; for ( int i = 0 ; i < children . size ( ) ; i ++ ) { Layer child = ( Layer ) children . get ( i ) ; if ( child . isRequiresLayout ( ) && ! child . getMaster ( ) . getStyle ( ) . isAlternateFlow ( ) ) { layoutAbsoluteChild ( c , child ) ; if ( child . getMaster ( ) . getStyle ( ) . isAvoidPageBreakInside ( ) && child . getMaster ( ) . crossesPageBreak ( c ) ) { ( ( BlockBox ) child . getMaster ( ) ) . setNeedPageClear ( true ) ; child . getMaster ( ) . detach ( ) ; layoutAbsoluteChild ( c , child ) ; ( ( BlockBox ) child . getMaster ( ) ) . setNeedPageClear ( false ) ; } child . setRequiresLayout ( false ) ; child . finish ( c ) ; } } c . restoreLayoutState ( state ) ; } }	if ( child . isRequiresLayout ( ) && ! child . isAlternateFlow ( ) ) {
return ( ( Integer ) Support . convert ( this , data . getValue ( ) , Types . INTEGER , null ) ) . intValue ( ) ; <CTX> private int getRowStat ( ) throws SQLException { ColData data = currentRow [ columns . length - 1 ] ; return ( ( Integer ) Support . convert ( this , data . getValue ( ) , Types . INTEGER , null ) ) . intValue ( ) ; }	return ( ( Integer ) Support . convert ( this , data , Types . INTEGER , null ) ) . intValue ( ) ;
void add ( ColorDefinition desc ) { if ( findColor ( desc . getId ( ) ) != null ) return ; colors . add ( desc ) ; <CTX> void add ( ColorDefinition desc ) { if ( findColor ( desc . getId ( ) ) != null ) return ; colors . add ( desc ) ; }	void add ( IThemeDescriptor desc ) { if ( findTheme ( desc . getId ( ) ) != null ) { return ; } themes . add ( desc ) ;
if ( result != getParent ( ) ) <CTX> ClassLoader basicFindClassLoader ( ) { Class [ ] stack = contextFinder . getClassContext ( ) ; ClassLoader result = null ; for ( int i = 1 ; i < stack . length ; i ++ ) { ClassLoader tmp = stack [ i ] . getClassLoader ( ) ; if ( stack [ i ] != ContextFinder . class && tmp != null ) { result = tmp ; break ; } } if ( result != getParent ( ) ) return result ; return null ; }	if ( checkClassLoader ( result ) )
return new ConversionSet ( valueMap . entrySet ( ) ) ; <CTX> public Set entrySet ( ) { / / TODO : Set . Entry must be wrapped appropriately . . . ? return new ConversionSet ( valueMap . entrySet ( ) ) ; }	return new ConversionMapEntrySet ( getRuntime ( ) , valueMap . entrySet ( ) ) ;
Method getIndexedClassAdderMethod ( ) ; <CTX> Method getIndexedClassAdderMethod ( ) ;	JavaMethod getIndexedClassAdderMethod ( ) ;
if ( getEditorInput ( ) instanceof IFileEditorInput ) <CTX> private void setAllInput ( FileEditorInput input ) { setInput ( input ) ; if ( getEditorInput ( ) instanceof IFileEditorInput ) { setPartName ( getEditorInput ( ) . getName ( ) ) ; } for ( Iterator it = pages . iterator ( ) ; it . hasNext ( ) ; ) { Object page = it . next ( ) ; if ( page instanceof IReportEditorPage ) { ( ( IReportEditorPage ) page ) . setInput ( input ) ; } } }	if ( getEditorInput ( ) != null )
if ( tvrt . additionalInterfaceBounds . length != additionalInterfaceBounds . length ) return false ; <CTX> private boolean matchingBounds ( TypeVariableReferenceType tvrt ) { if ( tvrt . getUpperBound ( ) != getUpperBound ( ) ) return false ; if ( tvrt . hasLowerBound ( ) != ( getLowerBound ( ) != null ) ) return false ; if ( tvrt . hasLowerBound ( ) && tvrt . getLowerBound ( ) != getLowerBound ( ) ) return false ; / / either we both have bounds , or neither of us have bounds if ( ( tvrt . additionalInterfaceBounds != null ) != ( additionalInterfaceBounds != null ) ) return false ; if ( additionalInterfaceBounds != null ) { / / we both have bounds , compare if ( tvrt . additionalInterfaceBounds . length != additionalInterfaceBounds . length ) return false ; Set aAndNotB = new HashSet ( ) ; Set bAndNotA = new HashSet ( ) ; for ( int i = 0 ; i < additionalInterfaceBounds . length ; i ++ ) { aAndNotB . add ( additionalInterfaceBounds [ i ] ) ; } for ( int i = 0 ; i < tvrt . additionalInterfaceBounds . length ; i ++ ) { bAndNotA . add ( tvrt . additionalInterfaceBounds [ i ] ) ; } for ( int i = 0 ; i < additionalInterfaceBounds . length ; i ++ ) { bAndNotA . remove ( additionalInterfaceBounds [ i ] ) ; } for ( int i = 0 ; i < tvrt . additionalInterfaceBounds . length ; i ++ ) { aAndNotB . remove ( tvrt . additionalInterfaceBounds [ i ] ) ; } if ( ! ( aAndNotB . isEmpty ( ) && bAndNotA . isEmpty ( ) ) ) return false ; } return true ; }	if ( tvrtBounds . length != additionalInterfaceBounds . length ) return false ;
sink . text ( caption ) ; <CTX> protected void tableCaption ( String caption ) { sink . tableCaption ( ) ; sink . text ( caption ) ; sink . tableCaption_( ) ; }	text ( caption ) ;
selectField . setForeground ( color ) ; <CTX> public void actionPerformed ( ActionEvent e ) { Color color = StyleUtil . randomColor ( ) ; selectField . setForeground ( color ) ; }	selectField 1 . setForeground ( color ) ;
. toString ( ) ) ) selectedResources . add ( currentFile ) ; <CTX> protected void selectAppropriateFolderContents ( IContainer resource ) { try { IResource [ ] members = resource . members ( ) ; for ( int i = 0 ; i < members . length ; i ++ ) { if ( members [ i ] . getType ( ) == IResource . FILE ) { IFile currentFile = ( IFile ) members [ i ] ; if ( hasExportableExtension ( currentFile . getFullPath ( ) . toString ( ) ) ) selectedResources . add ( currentFile ) ; } if ( members [ i ] . getType ( ) == IResource . FOLDER ) { selectAppropriateFolderContents ( ( IContainer ) members [ i ] ) ; } } } catch ( CoreException e ) { / / don t show children if there are errors -- should at least log this } }	. toString ( ) ) ) { selectedResources . add ( currentFile ) ; }
VMPlainDatagramSocketImpl . connect ( this , addr , port ) ; <CTX> protected void connect ( InetAddress addr , int port ) throws SocketException { VMPlainDatagramSocketImpl . connect ( this , addr , port ) ; }	channel . connect ( new InetSocketAddress ( addr , port ) , 0 ) ;
synchronized ( AbstractTreeUpdater . this ) { if ( myRunAfterUpdate != null ) { myRunAfterUpdate . run ( ) ; myRunAfterUpdate = null ; } <CTX> public void run ( ) { synchronized ( AbstractTreeUpdater . this ) { if ( myRunAfterUpdate != null ) { myRunAfterUpdate . run ( ) ; myRunAfterUpdate = null ; } } }	synchronized ( AbstractTreeUpdater . this ) { if ( myRunAfterUpdate != null ) { myRunAfterUpdate . run ( ) ; myRunAfterUpdate = null ;
numberFormat = new NumberFormatter ( context . getLocale ( ) ) ; <CTX> protected boolean formatValue ( Object value , String formatStr , StyleDesign style , StringBuffer formattedStr ) { if ( value == null ) { return false ; } assert style != null && formattedStr != null ; assert context . getLocale ( ) != null ; if ( ( value instanceof Number ) ) { NumberFormatter numberFormat ; if ( formatStr == null || formatStr . length ( ) == 0 ) { numberFormat = style . getNumberFormatObject ( ) ; / / initial number - format for the first time if ( numberFormat == null ) { numberFormat = new NumberFormatter ( context . getLocale ( ) ) ; formatStr = style . getNumberFormat ( ) ; if ( formatStr != null ) { numberFormat . applyPattern ( formatStr ) ; } style . setNumberFormatObject ( numberFormat ) ; } else { formatStr = numberFormat . getPattern ( ) ; } } else / / deal with value - of for text item { numberFormat = new NumberFormatter ( context . getLocale ( ) ) ; numberFormat . applyPattern ( formatStr ) ; } formattedStr . append ( numberFormat . format ( ( ( Number ) value ) . doubleValue ( ) ) ) ; } else if ( value instanceof Date ) { DateFormatter dateFormat ; if ( formatStr == null || formatStr . length ( ) == 0 ) { dateFormat = style . getDateFormatObject ( ) ; / / initial date - format for the first time if ( dateFormat == null ) { dateFormat = new DateFormatter ( context . getLocale ( ) ) ; formatStr = style . getDateTimeFormat ( ) ; if ( formatStr != null ) { dateFormat . applyPattern ( formatStr ) ; } style . setDateFormatObject ( dateFormat ) ; } else { formatStr = dateFormat . getPattern ( ) ; } } else / / deal with value - of for text item { dateFormat = new DateFormatter ( context . getLocale ( ) ) ; dateFormat . applyPattern ( formatStr ) ; } formattedStr . append ( dateFormat . format ( ( Date ) value ) ) ; } else if ( value instanceof String ) { StringFormatter stringFormat ; if ( formatStr == null || formatStr . length ( ) == 0 ) { stringFormat = style . getStringFormatObject ( ) ; / / initial string - format for the first time if ( stringFormat == null ) { stringFormat = new StringFormatter ( ) ; / / use default stringFormat stringFormat . setLocale ( context . getLocale ( ) ) ; / / get format pattern from style formatStr = style . getStringFormat ( ) ; if ( formatStr != null ) { stringFormat . applyPattern ( formatStr ) ; } style . setStringFormatObject ( stringFormat ) ; } else { formatStr = stringFormat . getPattern ( ) ; } } else / / deal with value - of for text item { stringFormat = new StringFormatter ( ) ; stringFormat . setLocale ( context . getLocale ( ) ) ; stringFormat . applyPattern ( formatStr ) ; } formattedStr . append ( stringFormat . format ( value . toString ( ) ) ) ; } else { formattedStr . append ( value . toString ( ) ) ; return false ; } if ( formatStr == null || formatStr . length ( ) == 0 ) { return false ; } return true ; }	formatStr = style . getNumberFormat ( ) ;
sendUnsubscribeEvent ( this . proxy , this . url ) ; <CTX> public void unsubscribe ( ) { sendUnsubscribeEvent ( this . proxy , this . url ) ; }	sendUnsubscribeEvent ( m_proxy , m_url ) ;
toolTip = new JToolTip ( toolTipText ) ; <CTX> public JToolTip createToolTip ( ) { if ( toolTip == null ) toolTip = new JToolTip ( toolTipText ) ; return toolTip ; }	{ toolTip = new JToolTip ( ) ; toolTip . setTipText ( toolTipText ) ; }
IRubyObject [ ] newArgs = new IRubyObject [ count - 1 ] ; System . arraycopy ( args , 1 , newArgs , 0 , count - 1 ) ; IRubyObject nextLine = io . internalGets ( newArgs ) ; while ( ! nextLine . isNil ( ) ) { getRuntime ( ) . yield ( nextLine ) ; nextLine = io . internalGets ( newArgs ) ; } io . close ( ) ; <CTX> public IRubyObject foreach ( IRubyObject [ ] args ) { int count = checkArgumentCount ( args , 1 , - 1 ) ; IRubyObject filename = args [ 0 ] . convertToString ( ) ; filename . checkSafeString ( ) ; RubyIO io = ( RubyIO ) RubyFile . open ( getRuntime ( ) . getClasses ( ) . getFileClass ( ) , new IRubyObject [ ] { filename } , false ) ; if ( ! io . isNil ( ) && io . isOpen ( ) ) { IRubyObject [ ] newArgs = new IRubyObject [ count - 1 ] ; System . arraycopy ( args , 1 , newArgs , 0 , count - 1 ) ; IRubyObject nextLine = io . internalGets ( newArgs ) ; while ( ! nextLine . isNil ( ) ) { getRuntime ( ) . yield ( nextLine ) ; nextLine = io . internalGets ( newArgs ) ; } io . close ( ) ; } return getRuntime ( ) . getNil ( ) ; }	try { IRubyObject [ ] newArgs = new IRubyObject [ count - 1 ] ; System . arraycopy ( args , 1 , newArgs , 0 , count - 1 ) ; IRubyObject nextLine = io . internalGets ( newArgs ) ; while ( ! nextLine . isNil ( ) ) { getRuntime ( ) . yield ( nextLine ) ; nextLine = io . internalGets ( newArgs ) ; } } finally { io . close ( ) ; }
