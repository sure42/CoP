if ( model != null ) <CTX> private void addFeaturePlugins ( IFeature feature , HashMap map ) { PluginModelManager manager = PDECore . getDefault ( ) . getModelManager ( ) ; IFeaturePlugin [ ] plugins = feature . getPlugins ( ) ; for ( int i = 0 ; i < plugins . length ; i ++ ) { String id = plugins [ i ] . getId ( ) ; if ( id == null || map . containsKey ( id ) ) continue ; IPluginModelBase model = manager . findModel ( id ) ; if ( model != null ) map . put ( id , model ) ; } }	if ( model != null && TargetPlatform . matchesCurrentEnvironment ( model ) )
int sum = 0 ; <CTX> public double add ( int [ ] array ) { int sum = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) sum += array [ i ] ; return sum ; }	double sum = 0 ;
if ( rowBeingEdited > - 1 && columnBeingEdited > - 1 ) { if ( getValueAt ( rowBeingEdited , columnBeingEdited ) instanceof JTextField ) <CTX> public void editingCanceled ( ChangeEvent event ) { if ( rowBeingEdited > - 1 && columnBeingEdited > - 1 ) { if ( getValueAt ( rowBeingEdited , columnBeingEdited ) instanceof JTextField ) { remove ( ( Component ) getValueAt ( rowBeingEdited , columnBeingEdited ) ) ; setValueAt ( oldCellValue , rowBeingEdited , columnBeingEdited ) ; } rowBeingEdited = - 1 ; columnBeingEdited = - 1 ; } editorTimer . stop ( ) ; editorComp = null ; cellEditor = null ; requestFocusInWindow ( false ) ; repaint ( ) ; }	if ( editorComp != null )
if ( currentWindow == null ) return ; <CTX> public static void animateDown ( Rectangle startPosition ) { IWorkbenchWindow currentWindow = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; if ( currentWindow == null ) return ; WorkbenchWindow internalWindow = ( WorkbenchWindow ) currentWindow ; ProgressRegion progressRegion = internalWindow . getProgressRegion ( ) ; if ( progressRegion == null ) return ; Rectangle endPosition = progressRegion . getControl ( ) . getBounds ( ) ; Point windowLocation = internalWindow . getShell ( ) . getLocation ( ) ; endPosition . x += windowLocation . x ; endPosition . y += windowLocation . y ; RectangleAnimation animation = new RectangleAnimation ( internalWindow . getShell ( ) , startPosition , endPosition ) ; animation . schedule ( ) ; }	if ( currentWindow == null ) { return ; }
RubyArray ary = RubyArray . newArray ( getRuntime ( ) ) ; <CTX> public IRubyObject scan ( IRubyObject arg ) { RubyRegexp pat = RubyRegexp . regexpValue ( arg ) ; int start = 0 ; if ( ! getRuntime ( ) . isBlockGiven ( ) ) { RubyArray ary = RubyArray . newArray ( getRuntime ( ) ) ; while ( pat . search ( this , start ) != - 1 ) { RubyMatchData md = ( RubyMatchData ) getRuntime ( ) . getBackref ( ) ; if ( md . getSize ( ) == 1 ) { ary . append ( md . group ( 0 ) ) ; } else { ary . append ( md . subseq ( 1 , md . getSize ( ) ) ) ; } if ( md . matchEndPosition ( ) == md . matchStartPosition ( ) ) { start ++ ; } else { start = md . matchEndPosition ( ) ; } } return ary ; } while ( pat . search ( this , start ) != - 1 ) { RubyMatchData md = ( RubyMatchData ) getRuntime ( ) . getBackref ( ) ; if ( md . getSize ( ) == 1 ) { getRuntime ( ) . yield ( md . group ( 0 ) ) ; } else { getRuntime ( ) . yield ( md . subseq ( 1 , md . getSize ( ) ) ) ; } if ( md . matchEndPosition ( ) == md . matchStartPosition ( ) ) { start ++ ; } else { start = md . matchEndPosition ( ) ; } } return this ; }	RubyArray ary = getRuntime ( ) . newArray ( ) ;
return firstSibling ( member , evaluator ) ; <CTX> public Member evaluateMember ( Evaluator evaluator ) { Member member = memberCalc . evaluateMember ( evaluator ) ; return firstSibling ( member , evaluator ) ; }	return firstChild ( evaluator , member ) ;
if (_address != null && addr ._address == null ) <CTX> public boolean equals ( Object o ) { if ( ! ( o instanceof FreenetInetAddress ) ) { return false ; } FreenetInetAddress addr = ( FreenetInetAddress ) o ; if ( hostname != null ) { if ( addr . hostname == null ) return false ; if ( ! hostname . equalsIgnoreCase ( addr . hostname ) ) { return false ; } / / Now that we know we have the same hostname , we can propagate the IP . if (_address != null && addr ._address == null ) addr ._address =_address ; if ( addr ._address != null &&_address == null )_address = addr ._address ; / / Except if we actually do have two different looked - up IPs ! if ( addr ._address != null &&_address != null && ! addr ._address . equals (_address ) ) return false ; / / Equal . return true ; } / / No hostname , go by address . if ( !_address . equals ( addr ._address ) ) { return false ; } return true ; }	if ( (_address != null ) && ( addr ._address == null ) )
return new SimpleDateFormat ( DateConstants . DATETIME_SECONDS_FORMAT_STRING ) . format ( date ) ; <CTX> private static String makeSqlStringFromDate ( Date date ) { if ( null == date ) { return null ; } return new SimpleDateFormat ( DateConstants . DATETIME_SECONDS_FORMAT_STRING ) . format ( date ) ; }	return new SimpleDateFormat ( DateConstants . DATETIME_FORMAT_STRING ) . format ( date ) ;
if ( bindings . isFullyResolved ( n ) ) { <CTX> public IBinding [ ] find ( String name ) { char [ ] n = name . toCharArray ( ) ; if ( bindings . isFullyResolved ( n ) ) { Object o = bindings . get ( n ) ; if ( o instanceof IBinding [ ] ) return ( IBinding [ ] ) ArrayUtil . trim ( IBinding . class , ( Object [ ] ) o ) ; return new IBinding [ ] { ( IBinding ) o } ; } LookupData data = new LookupData ( n ) ; try { data . foundItems = CPPSemantics . lookupInScope ( data , this , null , null ) ; } catch ( DOMException e ) { } if ( data . foundItems != null ) { IASTName [ ] ns = ( IASTName [ ] ) data . foundItems ; ObjectSet set = new ObjectSet ( ns . length ) ; for ( int i = 0 ; i < ns . length && ns [ i ] != null ; i ++ ) { set . put ( ns [ i ] . resolveBinding ( ) ) ; } return ( IBinding [ ] ) ArrayUtil . trim ( IBinding . class , set . keyArray ( ) , true ) ; } return new IBinding [ 0 ] ; }	if ( bindings != null && bindings . isFullyResolved ( n ) ) {
int count = 0 ; Player player = getActivePlayer ( ) ; for ( int i = 0 ; i < getNumCritters ( ) ; i ++ ) { Critter critter = getCritter ( i ) ; if ( critter . getPlayer ( ) == player ) { if ( ! critter . hasMoved ( ) && ! critter . isInContact ( false ) ) { count ++ ; BattleHex hex = critter . getCurrentHex ( ) ; hex . select ( ) ; hex . repaint ( ) ; } } } return count ; <CTX> public int highlightMovableChits ( ) { map . unselectAllHexes ( ) ; int count = 0 ; Player player = getActivePlayer ( ) ; for ( int i = 0 ; i < getNumCritters ( ) ; i ++ ) { Critter critter = getCritter ( i ) ; if ( critter . getPlayer ( ) == player ) { if ( ! critter . hasMoved ( ) && ! critter . isInContact ( false ) ) { count ++ ; BattleHex hex = critter . getCurrentHex ( ) ; hex . select ( ) ; hex . repaint ( ) ; } } } return count ; }	map . selectHexesByLabels ( set ) ; return set . size ( ) ;
NavigatorContentExtension [ ] resultInstances = findRelevantContentExtensions ( anElement ) ; <CTX> public ITreeContentProvider [ ] findParentContentProviders ( Object anElement ) { NavigatorContentExtension [ ] resultInstances = findRelevantContentExtensions ( anElement ) ; return extractContentProviders ( resultInstances ) ; }	NavigatorContentExtension [ ] resultInstances = findContentExtensionsByTriggerPoint ( anElement ) ;
Collection filters = newFilters ( extension ) ; registeredFilters . addAll ( filters ) ; Iterator newFilters = filters . iterator ( ) ; while ( newFilters . hasNext ( ) ) { tracker . registerObject ( extension , newFilters . next ( ) , IExtensionTracker . REF_STRONG ) ; } <CTX> public void addExtension ( IExtensionTracker tracker , IExtension extension ) { Collection filters = newFilters ( extension ) ; registeredFilters . addAll ( filters ) ; Iterator newFilters = filters . iterator ( ) ; while ( newFilters . hasNext ( ) ) { tracker . registerObject ( extension , newFilters . next ( ) , IExtensionTracker . REF_STRONG ) ; } }	processExtension ( tracker , extension ) ;
if ( featureId . regionMatches ( prefixLength , Constants . SCHEMA_NORMALIZED_VALUE , 0 , Constants . SCHEMA_NORMALIZED_VALUE . length ( ) ) ) { <CTX> protected void checkFeature ( String featureId ) throws XMLConfigurationException { / / / / Xerces Features / / if ( featureId . startsWith ( Constants . XERCES_FEATURE_PREFIX ) ) { final int prefixLength = Constants . XERCES_FEATURE_PREFIX . length ( ) ; / / / / http : / / apache . org / xml / features / validation / schema / / Lets the user turn Schema validation support on / off . / / if ( featureId . regionMatches ( prefixLength , Constants . SCHEMA_VALIDATION_FEATURE , 0 , Constants . SCHEMA_VALIDATION_FEATURE . length ( ) ) ) { return ; } / / activate full schema checking if ( featureId . regionMatches ( prefixLength , Constants . SCHEMA_FULL_CHECKING , 0 , Constants . SCHEMA_FULL_CHECKING . length ( ) ) ) { return ; } / / Feature identifier : expose schema normalized value / / http : / / apache . org / xml / features / validation / schema / normalized - value if ( featureId . regionMatches ( prefixLength , Constants . SCHEMA_NORMALIZED_VALUE , 0 , Constants . SCHEMA_NORMALIZED_VALUE . length ( ) ) ) { return ; } / / Feature identifier : send element default value via characters ( ) / / http : / / apache . org / xml / features / validation / schema / element - default if ( featureId . regionMatches ( prefixLength , Constants . SCHEMA_ELEMENT_DEFAULT , 0 , Constants . SCHEMA_ELEMENT_DEFAULT . length ( ) ) ) { return ; } } / / / / Not recognized / / super . checkFeature ( featureId ) ; } / / checkFeature ( String )	if ( suffixLength == Constants . SCHEMA_NORMALIZED_VALUE . length ( ) && featureId . endsWith ( Constants . SCHEMA_NORMALIZED_VALUE ) ) {
IReportProvider provider = EditorUtil . getReportProvider ( this , getEditorInput ( ) ) ; if ( provider != null && getErrorLIine ( ) > - 1 ) <CTX> public void doSave ( IProgressMonitor progressMonitor ) { super . doSave ( progressMonitor ) ; IReportProvider provider = EditorUtil . getReportProvider ( this , getEditorInput ( ) ) ; if ( provider != null && getErrorLIine ( ) > - 1 ) { ModuleHandle model = provider . getReportModuleHandle ( getEditorInput ( ) , true ) ; SessionHandleAdapter . getInstance ( ) . setReportDesignHandle ( model ) ; } }	IReportProvider provider = getProvider ( ) ; if ( provider != null && getErrorLIine ( ) == - 1 )
TimerTask makeTask ( ) { <CTX> TimerTask makeTask ( ) { return new Task ( ) ; }	Runnable makeTask ( ) {
handler = new IOHandlerSocket ( getRuntime ( ) , socket . getInputStream ( ) , socket . getOutputStream ( ) ) ; <CTX> public IRubyObject initialize ( IRubyObject arg ) { socket = extractSocket ( arg ) ; try { handler = new IOHandlerSocket ( getRuntime ( ) , socket . getInputStream ( ) , socket . getOutputStream ( ) ) ; } catch ( IOException e ) { throw getRuntime ( ) . newIOError ( e . getMessage ( ) ) ; } registerIOHandler ( handler ) ; modes = handler . getModes ( ) ; return this ; }	handler = new IOHandlerNio ( getRuntime ( ) , socketChannel ) ;
queueForDecoration ( element , adaptedElement ) ; <CTX> public String decorateWithText ( String text , Object element , Object adaptedElement ) { / / We do not support decoration of null if ( element == null ) return text ; DecorationResult decoration = ( DecorationResult ) resultCache . get ( element ) ; if ( decoration == null ) { queueForDecoration ( element , adaptedElement ) ; return text ; } else return decoration . decorateWithText ( text ) ; }	queueForDecoration ( element , adaptedElement , false ) ;
super ( reportContext ) ; <CTX> public DataSetScriptExecutor ( DataSetHandle dataSetHandle , IReportContext reportContext ) { super ( reportContext ) ; this . dataSetHandle = dataSetHandle ; String className = dataSetHandle . getEventHandlerClass ( ) ; initEventHandler ( className ) ; }	super ( context ) ;
if ( sealed ) { f . sealObject ( ) ; } ScriptableObject . defineProperty ( scope , name , f , attributes ) ; <CTX> public static void defineConstructor ( Scriptable scope , String name , IdFunctionMaster master , int id , int attributes , boolean sealed ) { IdFunction f = new IdFunction ( master , name , id ) ; f . setParentScope ( scope ) ; f . useCallAsConstructor = true ; if ( sealed ) { f . sealObject ( ) ; } ScriptableObject . defineProperty ( scope , name , f , attributes ) ; }	f . defineAsScopeProperty ( scope , attributes , seal ) ;
m_logPrefix = prefix ; <CTX> public void setLogPrefix ( String prefix ) { m_logPrefix = prefix ; }	synchronized ( this ) { m_logPrefix = prefix ; }
iVisited . accept (_Payload ) ; <CTX> public void visitMAsgnNode ( MAsgnNode iVisited ) { iVisited . accept (_Payload ) ; }	_ Payload . visitMAsgnNode ( iVisited ) ;
if ( ! ( p instanceof RealmPrincipal ) ) { RealmPrincipal rp = new RealmPrincipal ( loginDomainName , p , realmName ) ; if ( ! processedPrincipals . contains ( rp ) ) { list . add ( ContextManager . registerPrincipal ( rp ) ) ; processedPrincipals . add ( p ) ; } <CTX> public void processPrincipals ( String loginDomainName ) { List list = new LinkedList ( ) ; for ( Iterator it = subject . getPrincipals ( ) . iterator ( ) ; it . hasNext ( ) ; ) { Principal p = ( Principal ) it . next ( ) ; if ( ! ( p instanceof RealmPrincipal ) ) { RealmPrincipal rp = new RealmPrincipal ( loginDomainName , p , realmName ) ; if ( ! processedPrincipals . contains ( rp ) ) { list . add ( ContextManager . registerPrincipal ( rp ) ) ; processedPrincipals . add ( p ) ; } } } subject . getPrincipals ( ) . addAll ( list ) ; }	if ( ! ( p instanceof RealmPrincipal ) && ! processedPrincipals . contains ( p ) ) { list . add ( ContextManager . registerPrincipal ( new RealmPrincipal ( loginDomainName , p , realmName ) ) ) ; processedPrincipals . add ( p ) ;
ConflictsDialog conflictsDialog = new ConflictsDialog ( myProject ) ; <CTX> public boolean checkConflicts ( PullUpDialog dialog ) { final MemberInfo [ ] infos = dialog . getSelectedMemberInfos ( ) ; PsiClass superClass = dialog . getSuperClass ( ) ; if ( ! checkWritable ( superClass , infos ) ) return false ; String [ ] conflicts = PullUpConflictsUtil . checkConflicts ( infos , mySubclass , superClass , null , null , dialog . getContainmentVerifier ( ) ) ; if ( conflicts . length > 0 ) { ConflictsDialog conflictsDialog = new ConflictsDialog ( myProject ) ; conflictsDialog . show ( ) ; return conflictsDialog . isOK ( ) ; } return true ; }	ConflictsDialog conflictsDialog = new ConflictsDialog ( myProject , conflicts ) ;
int type ) <CTX> private static Object doScriptableIncrDecr ( Scriptable target , String id , Scriptable protoChainStart , Object value , int type ) { boolean post = ( type == Node . POST_INC || type == Node . POST_DEC ) ; double number ; if ( value instanceof Number ) { number = ( ( Number ) value ) . doubleValue ( ) ; } else { number = toNumber ( value ) ; if ( post ) { / / convert result to number value = new Double ( number ) ; } } if ( type == Node . PRE_INC || type == Node . POST_INC ) { ++ number ; } else { -- number ; } Number result = new Double ( number ) ; target . put ( id , protoChainStart , result ) ; if ( post ) { return value ; } else { return result ; } }	int incrDecrMask )
if ( this == obj ) return true ; <CTX> public boolean equals ( Object obj ) { / / Compare handles . if ( this == obj ) return true ; / / Compare class . if ( ! ( obj instanceof DrillFrame ) ) return false ; / / Compare contents . DrillFrame oOther = ( DrillFrame ) obj ; return ( ( fElement == oOther . fElement ) && ( fPropertyName . equals ( oOther . fPropertyName ) ) ) ; }	if ( this == obj ) { return true ; }
eDynamicUnset ( eFeature ) ; <CTX> public void eUnset ( EStructuralFeature eFeature ) { switch ( eDerivedStructuralFeatureID ( eFeature ) ) { case LayoutPackage . BLOCK__ CHILDREN : getChildren ( ) . clear ( ) ; return ; case LayoutPackage . BLOCK__ BOUNDS : setBounds ( ( Bounds ) null ) ; return ; case LayoutPackage . BLOCK__ ANCHOR : unsetAnchor ( ) ; return ; case LayoutPackage . BLOCK__ STRETCH : unsetStretch ( ) ; return ; case LayoutPackage . BLOCK__ INSETS : setInsets ( ( Insets ) null ) ; return ; case LayoutPackage . BLOCK__ ROW : unsetRow ( ) ; return ; case LayoutPackage . BLOCK__ COLUMN : unsetColumn ( ) ; return ; case LayoutPackage . BLOCK__ ROWSPAN : unsetRowspan ( ) ; return ; case LayoutPackage . BLOCK__ COLUMNSPAN : unsetColumnspan ( ) ; return ; case LayoutPackage . BLOCK__ MIN_SIZE : setMinSize ( ( Size ) null ) ; return ; case LayoutPackage . BLOCK__ OUTLINE : setOutline ( ( LineAttributes ) null ) ; return ; case LayoutPackage . BLOCK__ BACKGROUND : setBackground ( ( Fill ) null ) ; return ; case LayoutPackage . BLOCK__ VISIBLE : unsetVisible ( ) ; return ; case LayoutPackage . BLOCK__ TRIGGERS : getTriggers ( ) . clear ( ) ; return ; } eDynamicUnset ( eFeature ) ; }	super . eUnset ( featureID ) ;
int index = layeredPane . getIndexOf ( this ) ; <CTX> public void hide ( ) { JLayeredPane layeredPane ; layeredPane = SwingUtilities . getRootPane ( invoker ) . getLayeredPane ( ) ; int index = layeredPane . getIndexOf ( this ) ; layeredPane . remove ( index ) ; }	int index = layeredPane . getIndexOf ( c ) ;
return true ; <CTX> protected boolean isChildrenFinished ( ) { for ( int i = 0 ; i < childrenLayouts . size ( ) ; i ++ ) { boolean childFinished = ( ( Boolean ) childrenFinished . get ( i ) ) . booleanValue ( ) ; if ( ! childFinished ) { return true ; } } return false ; }	return false ;
Thread [ ] parsers = new Thread [ options . proc ] ; int length = tree . length / options . proc ; <CTX> protected void parseMultiProc ( final JCompilationUnit [ ] tree ) { try { Thread [ ] parsers = new Thread [ options . proc ] ; int length = tree . length / options . proc ; for ( int i = 0 ; i < options . proc ; i ++ ) { parsers [ i ] = new ThreadedParser ( this , infiles , tree , i * length , i == options . proc - 1 ? tree . length : ( i + 1 ) * length ) ; parsers [ i ] . start ( ) ; } for ( int i = 0 ; i < options . proc ; i ++ ) { parsers [ i ] . join ( ) ; } } catch ( InterruptedException ie ) { ie . printStackTrace ( ) ; } }	Thread [ ] parsers = new Thread [ KjcOptions . proc ] ; int length = tree . length / KjcOptions . proc ;
synchronized ( m_executionInfo ) <CTX> ExecutionInfo ( final ThreadPool pool , final Runnable command , final long delay , final long interval , final Logger logger ) { m_pool = pool ; m_command = command ; m_delay = delay ; m_interval = interval ; m_logger = logger ; m_nextRun = System . currentTimeMillis ( ) + delay ; synchronized ( m_executionInfo ) { m_executionInfo . add ( this ) ; m_executionInfo . notifyAll ( ) ; } }	synchronized ( m_commandStack )
DEFAULT_CHART_WIDTH , DEFAULT_CHART_HEIGHT ) ) ; <CTX> private void resizeChart ( Chart chartModelCurrent ) { if ( chartModelCurrent . getBlock ( ) . getBounds ( ) == null || chartModelCurrent . getBlock ( ) . getBounds ( ) . getWidth ( ) == 0 || chartModelCurrent . getBlock ( ) . getBounds ( ) . getHeight ( ) == 0 ) { if ( chartModelCurrent instanceof ChartWithoutAxesImpl ) { chartModelCurrent . getBlock ( ) . setBounds ( BoundsImpl . create ( 0 , 0 , DEFAULT_CHART_WITHOUT_AXIS_WIDTH , DEFAULT_CHART_WITHOUT_AXIS_HEIGHT ) ) ; } else { chartModelCurrent . getBlock ( ) . setBounds ( BoundsImpl . create ( 0 , 0 , DEFAULT_CHART_WIDTH , DEFAULT_CHART_HEIGHT ) ) ; } } }	DEFAULT_CHART_BLOCK_WIDTH , DEFAULT_CHART_BLOCK_HEIGHT ) ) ;
return new StringValueImpl ( String . valueOf ( value ) ) ; <CTX> public static StringValue create ( char value ) { if ( value < CHAR_STRINGS . length ) return CHAR_STRINGS [ value ] ; else return new StringValueImpl ( String . valueOf ( value ) ) ; }	return new StringValueImpl ( value ) ;
return RubyArray . newArray ( ruby , Arrays . asList ( values ) ) ; <CTX> public RubyArray to_a ( ) { return RubyArray . newArray ( ruby , Arrays . asList ( values ) ) ; }	return RubyArray . newArray ( ruby , values ) ;
Level level = getLevelArg ( evaluator , args , 0 , true ) ; return level . getUniqueName ( ) ; <CTX> public Object evaluate ( Evaluator evaluator , Exp [ ] args ) { Level level = getLevelArg ( evaluator , args , 0 , true ) ; return level . getUniqueName ( ) ; }	Object o = getArg ( evaluator , args , 0 ) ; StringBuffer buf = new StringBuffer ( ) ; appendMemberOrTuple ( buf , o ) ; return buf . toString ( ) ;
new XmlAutoLookupHandler ( ) . invoke ( myProject , editor , file ) ; } } , null , null ) ; <CTX> public void autoPopupXmlLookup ( final Editor editor ) { if ( ApplicationManager . getApplication ( ) . isUnitTestMode ( ) ) return ; final CodeInsightSettings settings = CodeInsightSettings . getInstance ( ) ; if ( settings . AUTO_POPUP_XML_LOOKUP ) { final PsiFile file = PsiDocumentManager . getInstance ( myProject ) . getPsiFile ( editor . getDocument ( ) ) ; if ( file == null ) return ; final Runnable request = new Runnable ( ) { public void run ( ) { PsiDocumentManager . getInstance ( myProject ) . commitAllDocuments ( ) ; CommandProcessor . getInstance ( ) . executeCommand ( myProject , new Runnable ( ) { public void run ( ) { new XmlAutoLookupHandler ( ) . invoke ( myProject , editor , file ) ; } } , null , null ) ; } } ; / / invoke later prevents cancelling request by keyPressed from the same action ApplicationManager . getApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { myAlarm . addRequest ( request , settings . XML_LOOKUP_DELAY ) ; } } ) ; } }	CommandProcessor . getInstance ( ) . executeCommand ( myProject , new Runnable ( ) { public void run ( ) { new XmlAutoLookupHandler ( ) . invoke ( myProject , editor , file ) ; } } , null , null ) ; } } ) ;
if ( this . binder . isAllowedCachedLeft ( object ) ) { <CTX> public void assertTuple ( final ReteTuple leftTuple , final PropagationContext context , final InternalWorkingMemory workingMemory ) { final BetaMemory memory = ( BetaMemory ) workingMemory . getNodeMemory ( this ) ; memory . getTupleMemory ( ) . add ( leftTuple ) ; this . binder . updateFromTuple ( workingMemory , leftTuple ) ; for ( final java . util . Iterator it = this . dataProvider . getResults ( leftTuple , workingMemory , context ) ; it . hasNext ( ) ; ) { final Object object = it . next ( ) ; / / First alpha node filters for ( int i = 0 , length = this . constraints . length ; i < length ; i ++ ) { if ( ! this . constraints [ i ] . isAllowed ( object , workingMemory ) ) { / / next iteration continue ; } } if ( this . binder . isAllowedCachedLeft ( object ) ) { final InternalFactHandle handle = workingMemory . getFactHandleFactory ( ) . newFactHandle ( object ) ; memory . getCreatedHandles ( ) . put ( leftTuple , handle ) ; this . sink . propagateAssertTuple ( leftTuple , handle , context , workingMemory ) ; } } }	if ( this . betaConstraints . isAllowedCachedLeft ( object ) ) {
String str = RubyString . stringValue ( target ) . getValue ( ) ; <CTX> public int search ( IRubyObject target , int pos ) { String str = RubyString . stringValue ( target ) . getValue ( ) ; if ( pos > str . length ( ) ) { return - 1 ; } recompileIfNeeded ( ) ; / / If nothing match then nil will be returned IRubyObject result = match ( str , pos ) ; getRuntime ( ) . getCurrentContext ( ) . setBackref ( result ) ; / / If nothing match then - 1 will be returned return result instanceof RubyMatchData ? ( ( RubyMatchData ) result ) . matchStartPosition ( ) : - 1 ; }	String str = RubyString . stringValue ( target ) . toString ( ) ;
this . outStream = outStream ; <CTX> public CommandlineParser ( String [ ] arguments , PrintStream outStream ) { this . arguments = arguments ; this . outStream = outStream ; processArguments ( ) ; }	this . main = main ;
if ( bestData == null ) return null ; <CTX> public FontData [ ] bestDataArray ( FontData [ ] fonts , Display display ) { FontData bestData = bestData ( fonts , display ) ; if ( bestData == null ) return null ; FontData [ ] datas = new FontData [ 1 ] ; datas [ 0 ] = bestData ; return datas ; }	if ( bestData == null ) { return null ; }
block . setMarginBottomOverride ( 0 ) ; <CTX> public static void collapseVerticalMargins ( Context c , Box block , Content content , float parentWidth ) { if ( content instanceof CollapsableContent ) { CollapsableContent collapsableContent = ( CollapsableContent ) content ; if ( ! collapsableContent . isCollapsed ( ) ) { List adjoining = areMarginsAdjoining ( c , collapsableContent , parentWidth ) ; if ( adjoining != null ) { boolean returnImmediately = collapseInBetweenAdjoining ( c , block , collapsableContent , adjoining ) ; if ( returnImmediately ) { return ; } } } if ( collapsableContent . isTopMarginCollapsed ( ) ) { block . setMarginTopOverride ( 0 ) ; } else if ( mayCollapseInto ( c , collapsableContent ) ) { Float collapsedTopMargin = collapseTopMargin ( c , collapsableContent , parentWidth ) ; if ( collapsedTopMargin != null ) { block . setMarginTopOverride ( collapsedTopMargin . intValue ( ) ) ; } } else { Float collapsedTopMargin = calculateCollapsedTop ( c , content , parentWidth ) ; block . setMarginTopOverride ( collapsedTopMargin . intValue ( ) ) ; } if ( collapsableContent . isBottomMarginCollapsed ( ) ) { block . setMarginBottomOverride ( 0 ) ; } else if ( mayCollapseInto ( c , collapsableContent ) ) { Float collapsedBottomMargin = collapseBottomMargin ( c , collapsableContent , parentWidth ) ; if ( collapsedBottomMargin != null ) { block . setMarginBottomOverride ( collapsedBottomMargin . intValue ( ) ) ; } } else { Float collapsedBottomMargin = calculateAdjustedMarginBottom ( c , content , parentWidth ) ; block . setMarginBottomOverride ( collapsedBottomMargin . intValue ( ) ) ; } } }	style . setMarginBottomOverride ( 0 ) ;
if ( StringEditorDialog . saveCreatedProperty ( myBundle , dlg . getName ( ) , dlg . getValue ( ) ) ) return ; <CTX> public void actionPerformed ( ActionEvent e ) { NewKeyDialog dlg = new NewKeyDialog ( getWindow ( ) ) ; dlg . show ( ) ; if ( dlg . isOK ( ) ) { if ( StringEditorDialog . saveCreatedProperty ( myBundle , dlg . getName ( ) , dlg . getValue ( ) ) ) return ; fillPropertyList ( ) ; myModel . update ( ) ; selectKey ( dlg . getName ( ) ) ; } }	if ( ! StringEditorDialog . saveCreatedProperty ( myBundle , dlg . getName ( ) , dlg . getValue ( ) ) ) return ;
if ( ! Workbench . getInstance ( ) . isRunning ( ) ) <CTX> public void bundleChanged ( BundleEvent event ) { if ( event . getBundle ( ) . getState ( ) != Bundle . ACTIVE ) return ; / / If the workbench isn t running anymore simply return . if ( ! Workbench . getInstance ( ) . isRunning ( ) ) return ; WorkingSetDescriptor [ ] descriptors = WorkbenchPlugin . getDefault ( ) . getWorkingSetRegistry ( ) . getDescriptorsForNamespace ( event . getBundle ( ) . getSymbolicName ( ) ) ; synchronized ( updaters ) { for ( int i = 0 ; i < descriptors . length ; i ++ ) { WorkingSetDescriptor descriptor = descriptors [ i ] ; List workingSets = getWorkingSetsForId ( descriptor . getId ( ) ) ; if ( workingSets . size ( ) == 0 ) continue ; IWorkingSetUpdater updater = getUpdater ( descriptor ) ; for ( Iterator iter = workingSets . iterator ( ) ; iter . hasNext ( ) ; ) { IWorkingSet workingSet = ( IWorkingSet ) iter . next ( ) ; if ( ! updater . contains ( workingSet ) ) updater . add ( workingSet ) ; } } } }	if ( ! Workbench . getInstance ( ) . isRunning ( ) ) {
TreeModel mod = tree . getModel ( ) ; setModel ( mod ) ; if ( mod != null ) { Object root = mod . getRoot ( ) ; if ( root != null ) { TreePath path = new TreePath ( root ) ; if ( ! tree . isExpanded ( path ) ) toggleExpandState ( path ) ; } } <CTX> public void installUI ( JComponent c ) { tree = ( JTree ) c ; prepareForUIInstall ( ) ; super . installUI ( c ) ; installDefaults ( ) ; installComponents ( ) ; installKeyboardActions ( ) ; installListeners ( ) ; setCellEditor ( createDefaultCellEditor ( ) ) ; createdCellEditor = true ; isEditing = false ; TreeModel mod = tree . getModel ( ) ; setModel ( mod ) ; if ( mod != null ) { Object root = mod . getRoot ( ) ; if ( root != null ) { TreePath path = new TreePath ( root ) ; if ( ! tree . isExpanded ( path ) ) toggleExpandState ( path ) ; } } treeSelectionModel = tree . getSelectionModel ( ) ; completeUIInstall ( ) ; }	setModel ( tree . getModel ( ) ) ;
BLOCKED_ADDR_TO_TIME . remove ( addr ) ; <CTX> private static void cleanExpiredServerBlocks ( ) { synchronized ( BLOCKED_ADDR_TO_TIME ) { while ( ! BLOCKED_ADDR_QUEUE . isEmpty ( ) ) { InetAddress addr = ( InetAddress ) BLOCKED_ADDR_QUEUE . getLast ( ) ; long time = ( ( Long ) BLOCKED_ADDR_TO_TIME . get ( addr ) ) . longValue ( ) ; if ( time <= System . currentTimeMillis ( ) ) { BLOCKED_ADDR_TO_TIME . remove ( addr ) ; BLOCKED_ADDR_QUEUE . removeLast ( ) ; } else { break ; } } } }	BLOCKED_ADDR_TO_TIME . remove ( host ) ;
initialize ( resources , in , true ) ; <CTX> public static void initialize ( ValidatorResources resources , InputStream in ) throws IOException { initialize ( resources , in , true ) ; }	return initialize ( new BufferedInputStream ( new FileInputStream ( fileName ) ) ) ;
void registerProtocolHandlers ( ClassLoader loader , String pkgs ) <CTX> void registerProtocolHandlers ( ClassLoader loader , String pkgs ) { synchronized ( protocolHandlers ) { protocolHandlers . add ( new ProtoHandlerDesc ( loader , pkgs ) ) ; } }	public void registerProtocolHandlers ( ClassLoader loader , String pkgs )
names = new String [ itsData . itsVariableTable . size ( ) + 1 ] ; names [ 0 ] = itsData . itsName ; for ( int i = 0 ; i < itsData . itsVariableTable . size ( ) ; i ++ ) names [ i + 1 ] = itsData . itsVariableTable . getName ( i ) ; <CTX> void init ( Context cx ) { / / probably too much copying going on from theData to the InterpretedFunction object / / should pass them as parameters - unless we need them in the data block anyway ? names = new String [ itsData . itsVariableTable . size ( ) + 1 ] ; names [ 0 ] = itsData . itsName ; for ( int i = 0 ; i < itsData . itsVariableTable . size ( ) ; i ++ ) names [ i + 1 ] = itsData . itsVariableTable . getName ( i ) ; argCount = ( short ) itsData . itsVariableTable . getParameterCount ( ) ; source = itsData . itsSource ; nestedFunctions = itsData . itsNestedFunctions ; if ( cx != null ) version = ( short ) cx . getLanguageVersion ( ) ; }	functionName = itsData . itsName ; int N = itsData . itsVariableTable . size ( ) ; if ( N != 0 ) { argNames = new String [ N ] ; for ( int i = 0 ; i != N ; i ++ ) { argNames [ i ] = itsData . itsVariableTable . getName ( i ) ; } }
iVisited . accept (_Payload ) ; <CTX> public void visitAliasNode ( AliasNode iVisited ) { iVisited . accept (_Payload ) ; }	_ Payload . visitAliasNode ( iVisited ) ;
super ( xpath , null ) ; <CTX> public Matcher ( Field . XPath xpath , ValueStore store ) { super ( xpath , null ) ; fStore = store ; } / / < init > ( Field . XPath , ValueStore )	super ( xpath ) ;
super ( conn , fields , tuples , status , updateCount , insertOID ) ; <CTX> public UpdateableResultSet ( Connection conn , Field [ ] fields , Vector tuples , String status , int updateCount , int insertOID ) { super ( conn , fields , tuples , status , updateCount , insertOID ) ; }	super ( conn , fields , tuples , status , updateCount , insertOID , binaryCursor ) ;
return v != null && v . contains ( value ) ; <CTX> public boolean containsElement ( Object key , Object value ) { synchronized ( table ) { Vector v = ( Vector ) table . get ( key ) ; return v != null && v . contains ( value ) ; } }	return ( v != null ) && v . contains ( value ) ;
if ( entry . factory . plugin == pmsg . getPluginJAR ( ) ) { if ( entry . container != null ) entry . container . unregister ( entry ) ; iter . remove ( ) ; } <CTX> public void handleMessage ( EBMessage msg ) { if ( msg instanceof DockableWindowUpdate ) { if ( ( ( DockableWindowUpdate ) msg ) . getWhat ( ) == DockableWindowUpdate . PROPERTIES_CHANGED ) propertiesChanged ( ) ; } else if ( msg instanceof PropertiesChanged ) propertiesChanged ( ) ; else if ( msg instanceof PluginUpdate ) { PluginUpdate pmsg = ( PluginUpdate ) msg ; if ( pmsg . getWhat ( ) == PluginUpdate . LOADED ) { Iterator iter = dockableWindowFactories . values ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Factory factory = ( Factory ) iter . next ( ) ; if ( factory . plugin == pmsg . getPluginJAR ( ) ) addEntry ( factory ) ; } propertiesChanged ( ) ; } else if ( pmsg . isExiting ( ) ) { / / we don t care } else if ( pmsg . getWhat ( ) == PluginUpdate . DEACTIVATED ) { Iterator iter = windows . values ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry entry = ( Entry ) iter . next ( ) ; if ( entry . factory . plugin == pmsg . getPluginJAR ( ) ) { if ( entry . container != null && entry . container . isVisible ( entry ) ) { entry . container . remove ( entry ) ; } } } iter = clones . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry entry = ( Entry ) iter . next ( ) ; if ( entry . factory . plugin == pmsg . getPluginJAR ( ) ) { if ( entry . container != null ) entry . container . unregister ( entry ) ; iter . remove ( ) ; } } } else if ( pmsg . getWhat ( ) == PluginUpdate . UNLOADED ) { Iterator iter = windows . values ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry entry = ( Entry ) iter . next ( ) ; if ( entry . factory . plugin == pmsg . getPluginJAR ( ) ) { if ( entry . container != null ) entry . container . unregister ( entry ) ; iter . remove ( ) ; } } } } } / / } } }	entry . container . unregister ( entry ) ; entry . win = null ; entry . container = null ;
viewExtent = newSize ; <CTX> public void setViewSize ( Dimension newSize ) { viewExtent = newSize ; fireStateChanged ( ) ; }	viewSize = newSize ; Component view = getView ( ) ; if ( view != null ) view . setSize ( newSize ) ;
this . startDay = day ; <CTX> public void setStartRule ( int month , int day , int dayOfWeek , int time ) { this . startMode = checkRule ( month , day , dayOfWeek ) ; this . startMonth = month ; this . startDay = day ; this . startDayOfWeek = Math . abs ( dayOfWeek ) ; if ( this . startTimeMode == WALL_TIME || this . startTimeMode == STANDARD_TIME ) this . startTime = time ; else / / Convert from UTC to STANDARD this . startTime = time + this . rawOffset ; useDaylight = true ; }	this . startDay = Math . abs ( day ) ;
return false ; <CTX> public boolean isReadOnly ( ) { return false ; }	return true ;
add ( component ) ; <CTX> public void addItemByName ( String name , JMenuItem component ) { controls . put ( name , component ) ; add ( component ) ; }	super . add ( component ) ;
openIndexWriter ( false ) ; addDocumentToIndex ( document , indexWriter ) ; closeIndexWriter ( ) ; <CTX> private void addDocumentToIndex ( DocumentDomainObject document ) throws IOException { openIndexWriter ( false ) ; addDocumentToIndex ( document , indexWriter ) ; closeIndexWriter ( ) ; }	IndexWriter indexWriter = createIndexWriter ( indexDirectory , false ) ; try { addDocumentToIndex ( document , indexWriter ) ; } finally { indexWriter . close ( ) ; }
il 1 . append ( fact . ALOAD_0 ) ; il 1 . append ( fact . createLoad ( fieldType , 1 ) ) ; <CTX> private boolean mungePerObjectInterface ( BcelClassWeaver weaver , PerObjectInterfaceTypeMunger munger ) { LazyClassGen gen = weaver . getLazyClassGen ( ) ; if ( couldMatch ( gen . getBcelObjectType ( ) , munger . getTestPointcut ( ) ) ) { FieldGen fg = makeFieldGen ( gen , AjcMemberMaker . perObjectField ( gen . getType ( ) , aspectType ) ) ; gen . addField ( fg . getField ( ) ) ; Type fieldType = BcelWorld . makeBcelType ( aspectType ) ; LazyMethodGen mg = new LazyMethodGen ( Modifier . PUBLIC , fieldType , NameMangler . perObjectInterfaceGet ( aspectType ) , new Type [ 0 ] , new String [ 0 ] , gen ) ; InstructionList il = new InstructionList ( ) ; InstructionFactory fact = gen . getFactory ( ) ; il . append ( fact . ALOAD_0 ) ; il . append ( fact . createFieldAccess ( gen . getClassName ( ) , fg . getName ( ) , fieldType , Constants . GETFIELD ) ) ; il . append ( fact . createReturn ( fieldType ) ) ; mg . getBody ( ) . insert ( il ) ; gen . addMethodGen ( mg ) ; LazyMethodGen mg 1 = new LazyMethodGen ( Modifier . PUBLIC , Type . VOID , NameMangler . perObjectInterfaceSet ( aspectType ) , new Type [ ] { fieldType , } , new String [ 0 ] , gen ) ; InstructionList il 1 = new InstructionList ( ) ; il 1 . append ( fact . ALOAD_0 ) ; il 1 . append ( fact . createLoad ( fieldType , 1 ) ) ; il 1 . append ( fact . createFieldAccess ( gen . getClassName ( ) , fg . getName ( ) , fieldType , Constants . PUTFIELD ) ) ; il 1 . append ( fact . createReturn ( Type . VOID ) ) ; mg 1 . getBody ( ) . insert ( il 1 ) ; gen . addMethodGen ( mg 1 ) ; gen . addInterface ( munger . getInterfaceType ( ) ) ; return true ; } else { return false ; } }	il 1 . append ( InstructionConstants . ALOAD_0 ) ; il 1 . append ( InstructionFactory . createLoad ( fieldType , 1 ) ) ;
String parentRepoPath = PathTranslator . toRepositoryPath ( parentNode . getParent ( ) . getPath ( ) ) ; return getTicket ( parentRepoPath , id ) ; <CTX> public Object doInJcr ( Session session ) throws RepositoryException { String repoPath = PathTranslator . toRepositoryPath ( path ) ; Node parentNode = findDeepestExistingNodeInPath ( session , repoPath ) ; Node ticketNode = findChildTicketNode ( parentNode , id ) ; if ( ticketNode == null ) { if ( parentNode . getDepth ( ) == 0 ) { return null ; } String parentRepoPath = PathTranslator . toRepositoryPath ( parentNode . getParent ( ) . getPath ( ) ) ; return getTicket ( parentRepoPath , id ) ; } return TicketMapper . nodeToTicket ( ticketNode ) ; }	String parentClientPath = PathTranslator . toClientPath ( parentNode . getParent ( ) . getPath ( ) ) ; return getTicket ( parentClientPath , id ) ;
newStr . infectObject ( this ) ; <CTX> public IRubyObject dup ( ) { RubyString newStr = newString ( getValue ( ) ) ; newStr . infectObject ( this ) ; return newStr ; }	newStr . infectBy ( this ) ;
if ( VM . VerifyAssertions ) VM . assert ( i == numBlocks ) ; <CTX> private OPT_BasicBlock [ ] exileInfrequentBlocks ( OPT_IR ir ) { OPT_BasicBlock [ ] newOrdering = new OPT_BasicBlock [ numBlocks ] ; int i = 0 ; / / First append frequent blocks to newOrdering for ( OPT_BasicBlock bb = ir . cfg . firstInCodeOrder ( ) ; bb != null ; bb = bb . nextBasicBlockInCodeOrder ( ) ) { if ( ! bb . getInfrequent ( ) ) newOrdering [ i ++ ] = bb ; } / / Next append infrequent blocks to newOrdering for ( OPT_BasicBlock bb = ir . cfg . firstInCodeOrder ( ) ; bb != null ; bb = bb . nextBasicBlockInCodeOrder ( ) ) { if ( bb . getInfrequent ( ) ) newOrdering [ i ++ ] = bb ; } if ( VM . VerifyAssertions ) VM . assert ( i == numBlocks ) ; return newOrdering ; }	if ( VM . VerifyAssertions ) VM ._assert ( i == numBlocks ) ;
_ portNumber = portNumber ; <CTX> public void setPortNumber ( int portNumber ) {_portNumber = portNumber ; }	this . portNumber = portNumber ;
TriVertex ( EMFInputStream emf ) throws IOException { x = emf . readLONG ( ) ; y = emf . readLONG ( ) ; color = emf . readCOLOR 16 ( ) ; <CTX> TriVertex ( EMFInputStream emf ) throws IOException { x = emf . readLONG ( ) ; y = emf . readLONG ( ) ; color = emf . readCOLOR 16 ( ) ; }	public TriVertex ( int x , int y , Color color ) { this . x = x ; this . y = y ; this . color = color ;
if ( dval == null || dorg != StyleMap . USER_ORIGIN || ! dimp ) { <CTX> protected void putAuthorProperty ( StyleMap dest , int idx , Value sval , boolean imp , short origin ) { Value dval = dest . getValue ( idx ) ; short dorg = dest . getOrigin ( idx ) ; boolean dimp = dest . isImportant ( idx ) ; if ( dval == null || dorg != StyleMap . USER_ORIGIN || ! dimp ) { dest . putValue ( idx , sval ) ; dest . putImportant ( idx , imp ) ; dest . putOrigin ( idx , origin ) ; } }	boolean cond = dval == null ; if ( ! cond ) { switch ( dorg ) { case StyleMap . USER_ORIGIN : cond = ! dimp ; break ; case StyleMap . AUTHOR_ORIGIN : cond = ! dimp || imp ; break ; default : cond = true ; } } if ( cond ) {
m_writer = new SerializerTraceWriter ( writer , m_tracer ) ; <CTX> public void setWriter ( Writer writer ) { / / if we are tracing events we need to trace what / / characters are written to the output writer . if ( m_tracer != null && ! ( writer instanceof SerializerTraceWriter ) ) m_writer = new SerializerTraceWriter ( writer , m_tracer ) ; else m_writer = writer ; }	setWriterInternal ( new SerializerTraceWriter ( writer , m_tracer ) , true ) ;
_ description = description ; <CTX> public void setDescription ( String description ) {_description = description ; }	this . description = description ;
saveArray ( filter ( element . getRawChildren ( ) ) , outputNamespace ) ; <CTX> private void saveContributions ( KeyedHashSet [ ] contributions ) throws IOException { FileOutputStream fosNamespace = new FileOutputStream ( contributionsFile ) ; DataOutputStream outputNamespace = new DataOutputStream ( new BufferedOutputStream ( fosNamespace ) ) ; KeyedElement [ ] newElements = contributions [ 0 ] . elements ( ) ; KeyedElement [ ] formerElements = contributions [ 1 ] . elements ( ) ; / / get count of contributions that will be cached int cacheSize = 0 ; for ( int i = 0 ; i < newElements . length ; i ++ ) { if ( ( ( Contribution ) newElements [ i ] ) . shouldPersist ( ) ) cacheSize ++ ; } for ( int i = 0 ; i < formerElements . length ; i ++ ) { if ( ( ( Contribution ) formerElements [ i ] ) . shouldPersist ( ) ) cacheSize ++ ; } outputNamespace . writeInt ( cacheSize ) ; for ( int i = 0 ; i < newElements . length ; i ++ ) { Contribution element = ( Contribution ) newElements [ i ] ; if ( element . shouldPersist ( ) ) { writeStringOrNull ( element . getContributorId ( ) , outputNamespace ) ; saveArray ( filter ( element . getRawChildren ( ) ) , outputNamespace ) ; } } for ( int i = 0 ; i < formerElements . length ; i ++ ) { Contribution element = ( Contribution ) formerElements [ i ] ; if ( element . shouldPersist ( ) ) { writeStringOrNull ( element . getContributorId ( ) , outputNamespace ) ; saveArray ( filter ( element . getRawChildren ( ) ) , outputNamespace ) ; } } outputNamespace . flush ( ) ; fosNamespace . getFD ( ) . sync ( ) ; outputNamespace . close ( ) ; }	saveArray ( filterContributionChildren ( element ) , outputNamespace ) ;
DocumentDomainObject doc = documentMapper . getDocument ( documentId ) ; <CTX> public Document getDocument ( int documentId ) throws NoPermissionException { DocumentDomainObject doc = documentMapper . getDocument ( documentId ) ; Document result = null ; if ( null != doc ) { result = wrapDocumentDomainObject ( doc ) ; securityChecker . hasAtLeastDocumentReadPermission ( result ) ; } return result ; }	DocumentDomainObject doc = getDocumentMapper ( ) . getDocument ( documentId ) ;
else if ( e . widget . equals ( btnMoreOpt ) ) <CTX> public void widgetSelected ( SelectionEvent e ) { / / detach popup dialogue if ( detachPopup ( e . widget ) ) { return ; } if ( e . widget instanceof Button && ( ( ( Button ) e . widget ) . getStyle ( ) & SWT . TOGGLE ) == SWT . TOGGLE && ( ( Button ) e . widget ) . getSelection ( ) ) { selectAllButtons ( false ) ; ( ( Button ) e . widget ) . setSelection ( true ) ; } if ( e . widget . equals ( btnTitleVisible ) ) { getChart ( ) . getLegend ( ) . getTitle ( ) . setVisible ( ( ( Button ) e . widget ) . getSelection ( ) ) ; txtTitle . setEnabled ( getChart ( ) . getLegend ( ) . getTitle ( ) . isVisible ( ) ) ; refreshPopupSheet ( ) ; } else if ( e . widget . equals ( btnOutlineVisible ) ) { getChart ( ) . getLegend ( ) . getClientArea ( ) . getOutline ( ) . setVisible ( ( ( Button ) e . widget ) . getSelection ( ) ) ; refreshPopupSheet ( ) ; } else if ( e . widget . equals ( btnShowValue ) ) { getChart ( ) . getLegend ( ) . setShowValue ( ( ( Button ) e . widget ) . getSelection ( ) ) ; } else if ( e . widget . equals ( btnMoreOpt ) ) { popupShell = createPopupShell ( ) ; popupSheet = new MoreOptionsChartLegendSheet ( popupShell , getChart ( ) ) ; getWizard ( ) . attachPopup ( btnMoreOpt . getText ( ) , - 1 , - 1 ) ; } else if ( e . widget . equals ( btnLegendText ) ) { popupShell = createPopupShell ( ) ; popupSheet = new LegendTextSheet ( popupShell , getChart ( ) ) ; getWizard ( ) . attachPopup ( btnLegendText . getText ( ) , - 1 , - 1 ) ; } }	else if ( e . widget . equals ( btnAreaProp ) )
lastVisible = viewer . getElementAt ( viewer . getTable ( ) . getItemCount ( ) - 1 ) ; <CTX> private int nextRemoval ( int maximumToRemove ) { ArrayList result = new ArrayList ( maximumToRemove ) ; int counter = maximumToRemove ; Iterator iter = pendingRemovals . iterator ( ) ; while ( iter . hasNext ( ) && counter > 0 ) { Object next = iter . next ( ) ; result . add ( next ) ; if ( lastVisible != null && lastVisible . equals ( next ) ) { lastDirty = true ; } iter . remove ( ) ; counter -- ; } synchronized ( visibleItems ) { visibleItems . removeAll ( result ) ; } viewer . remove ( result . toArray ( ) ) ; if ( lastDirty ) { lastVisible = viewer . getElementAt ( viewer . getTable ( ) . getItemCount ( ) - 1 ) ; } return result . size ( ) ; }	lastVisible = getElementAt ( viewer , viewer . getTree ( ) . getItemCount ( ) - 1 ) ;
boolean addAll ( Collection c ) ; <CTX> boolean addAll ( Collection c ) ;	boolean addAll ( int index , Collection c ) ;
Iterator iter = dndList . iterator ( ) ; <CTX> public StatusItem getStatusItem ( String label ) { Iterator iter = dndList . iterator ( ) ; while ( iter . hasNext ( ) ) { StatusItem item = ( StatusItem ) iter . next ( ) ; if ( item . getText ( ) . equals ( label ) ) { return item ; } } return null ; }	Iterator iter = statusList . iterator ( ) ;
Tile t = s . getTile ( 0 ) ; <CTX> public void addTileset ( TileSet s ) { if ( s == null || tilesets . indexOf ( s ) > - 1 ) { return ; } Tile t = s . getTile ( 0 ) ; if ( t != null ) { int tw = t . getWidth ( ) ; int th = t . getHeight ( ) ; if ( tw != tileWidth ) { if ( tileWidth == 0 ) { tileWidth = tw ; tileHeight = th ; } } } tilesets . add ( s ) ; fireMapChanged ( ) ; }	Tile t = tileset . getTile ( 0 ) ;
void translateFrom ( Series sourceSeries , Chart chart ) ; <CTX> void translateFrom ( Series sourceSeries , Chart chart ) ;	void translateFrom ( Series sourceSeries , int iSeriesDefinitionIndex , Chart chart ) ;
return new VM_Address ( value - v ) ; <CTX> public VM_Address sub ( int v ) { if ( VM . VerifyAssertions && VM . runningVM ) VM ._assert ( VM . NOT_REACHED ) ; / / call site should have been hijacked by magic in compiler return new VM_Address ( value - v ) ; }	return new VM_Address ( value - offset . toInt ( ) ) ;
DatabaseHandler . queryHandler . insertVirtualWiki ( virtualWiki , conn ) ; <CTX> private void addVirtualWiki ( VirtualWiki virtualWiki , Connection conn ) throws Exception { if ( virtualWiki . getVirtualWikiId ( ) < 1 ) { int virtualWikiId = DatabaseHandler . queryHandler . nextVirtualWikiId ( conn ) ; virtualWiki . setVirtualWikiId ( virtualWikiId ) ; } DatabaseHandler . queryHandler . insertVirtualWiki ( virtualWiki , conn ) ; }	WikiDatabase . getQueryHandler ( ) . insertVirtualWiki ( virtualWiki , conn ) ;
java . lang . String topicId , java . lang . String messageId , boolean addCommunityPermissions , boolean addGuestPermissions ) <CTX> public void addMessageResources ( java . lang . String categoryId , java . lang . String topicId , java . lang . String messageId , boolean addCommunityPermissions , boolean addGuestPermissions ) throws com . liferay . portal . PortalException , com . liferay . portal . SystemException ;	java . lang . String messageId , boolean addCommunityPermissions , boolean addGuestPermissions )
itsData . itsLineNumberTable . put ( new Integer ( lineNumber ) , new Integer ( iCodeTop ) ) ; <CTX> private int updateLineNumber ( Node node , int iCodeTop ) { Object datum = node . getDatum ( ) ; if ( datum == null || ! ( datum instanceof Number ) ) return iCodeTop ; short lineNumber = ( ( Number ) datum ) . shortValue ( ) ; if ( lineNumber != itsLineNumber ) { itsLineNumber = lineNumber ; if ( itsData . itsLineNumberTable == null && Context . getCurrentContext ( ) . isGeneratingDebug ( ) ) { itsData . itsLineNumberTable = new java . util . Hashtable ( ) ; } if ( itsData . itsLineNumberTable != null ) { itsData . itsLineNumberTable . put ( new Integer ( lineNumber ) , new Integer ( iCodeTop ) ) ; } iCodeTop = addByte ( ( byte ) TokenStream . LINE , iCodeTop ) ; iCodeTop = addByte ( ( byte ) ( lineNumber >> 8 ) , iCodeTop ) ; iCodeTop = addByte ( ( byte ) ( lineNumber & 0 xff ) , iCodeTop ) ; } return iCodeTop ; }	itsData . itsLineNumberTable . put ( lineNumber , iCodeTop ) ;
SimpleDateFormat df = new SimpleDateFormat ( datePattern ) ; <CTX> public static Calendar getToday ( ) throws ParseException { Date today = new Date ( ) ; SimpleDateFormat df = new SimpleDateFormat ( datePattern ) ; / / This seems like quite a hack ( date -> string -> date ) , / / but it works ; - ) String todayAsString = df . format ( today ) ; Calendar cal = new GregorianCalendar ( ) ; cal . setTime ( convertStringToDate ( todayAsString ) ) ; return cal ; }	SimpleDateFormat df = new SimpleDateFormat ( getDatePattern ( ) ) ;
this ( locale , ( String ) null , locPattern ) ; <CTX> public ByteLocaleConverter ( Locale locale , boolean locPattern ) { this ( locale , ( String ) null , locPattern ) ; }	this ( false ) ;
{ return missingParameter ; <CTX> public boolean isMissingParameter ( ) { return missingParameter ; }	{ Map values = null ; if ( reportDocumentInstance != null ) values = reportDocumentInstance . getParameterValues ( ) ; else values = this . parameters ; return ReportEngineService . getInstance ( ) . validateParameters ( this . parameterTask , values ) ;
Calendar result = Calendar . getInstance ( ) ; result . setTime ( this . getOfficial ( ) ) ; return result ; <CTX> public Calendar getOfficialDate ( ) { Calendar result = Calendar . getInstance ( ) ; result . setTime ( this . getOfficial ( ) ) ; return result ; }	if ( this . getOfficial ( ) != null ) { Calendar result = Calendar . getInstance ( ) ; result . setTime ( this . getOfficial ( ) ) ; return result ; } return null ;
return res . cache ; <CTX> public boolean getCache ( ) { return res . cache ; }	return res . isCacheable ( ) ;
collectContainedFunctions ( tree . getFirstChild ( ) ) ; <CTX> public Node transform ( Node tree , Node enclosing ) { / / Collect all of the contained functions into a hashtable / / so that the call optimizer can access the class name & parameter / / count for any call it encounters collectContainedFunctions ( tree . getFirstChild ( ) ) ; return super . transform ( tree , enclosing ) ; }	if ( tree . getType ( ) == TokenStream . SCRIPT ) { collectContainedFunctions ( tree . getFirstChild ( ) ) ; }
case IProblem . InterfaceAmbiguous : <CTX> public static boolean hasCorrections ( int problemId ) { switch ( problemId ) { case IProblem . UnterminatedString : case IProblem . UnusedImport : case IProblem . DuplicateImport : case IProblem . CannotImportPackage : case IProblem . ConflictingImport : case IProblem . UndefinedMethod : case IProblem . UndefinedConstructor : case IProblem . ParameterMismatch : case IProblem . MethodButWithConstructorName : case IProblem . UndefinedField : case IProblem . UndefinedName : case IProblem . PublicClassMustMatchFileName : case IProblem . PackageIsNotExpectedPackage : case IProblem . UndefinedType : case IProblem . FieldTypeNotFound : case IProblem . ArgumentTypeNotFound : case IProblem . ReturnTypeNotFound : case IProblem . SuperclassNotFound : case IProblem . ExceptionTypeNotFound : case IProblem . InterfaceNotFound : case IProblem . TypeMismatch : case IProblem . UnhandledException : case IProblem . UnreachableCatch : case IProblem . VoidMethodReturnsValue : case IProblem . ShouldReturnValue : case IProblem . MissingReturnType : case IProblem . NonExternalizedStringLiteral : case IProblem . NonStaticAccessToStaticField : case IProblem . NonStaticAccessToStaticMethod : case IProblem . StaticMethodRequested : case IProblem . NonStaticFieldFromStaticInvocation : case IProblem . InstanceMethodDuringConstructorInvocation : case IProblem . InstanceFieldDuringConstructorInvocation : case IProblem . NotVisibleMethod : case IProblem . NotVisibleConstructor : case IProblem . NotVisibleType : case IProblem . SuperclassNotVisible : case IProblem . InterfaceNotVisible : case IProblem . FieldTypeNotVisible : case IProblem . ArgumentTypeNotVisible : case IProblem . ReturnTypeNotVisible : case IProblem . ExceptionTypeNotVisible : case IProblem . NotVisibleField : case IProblem . ImportNotVisible : case IProblem . BodyForAbstractMethod : case IProblem . AbstractMethodInAbstractClass : case IProblem . AbstractMethodMustBeImplemented : case IProblem . BodyForNativeMethod : case IProblem . OuterLocalMustBeFinal : case IProblem . UninitializedLocalVariable : case IProblem . UndefinedConstructorInDefaultConstructor : case IProblem . UnhandledExceptionInDefaultConstructor : case IProblem . NotVisibleConstructorInDefaultConstructor : case IProblem . FieldTypeAmbiguous : case IProblem . ArgumentTypeAmbiguous : case IProblem . ExceptionTypeAmbiguous : case IProblem . ReturnTypeAmbiguous : case IProblem . SuperclassAmbiguous : case IProblem . InterfaceAmbiguous : return true ; default : return false ; } }	case IProblem . InterfaceAmbiguous : case IProblem . AmbiguousType :
code . emitLoad ( curLambda . heapFrame ) ; else if ( curLambda . closureEnv != null ) code . emitLoad ( curLambda . closureEnv ) ; <CTX> public void loadHeapFrame ( Compilation comp ) { LambdaExp curLambda = comp . curLambda ; while ( curLambda != this && curLambda . getInlineOnly ( ) ) curLambda = curLambda . getCaller ( ) ; gnu . bytecode . CodeAttr code = comp . getCode ( ) ; if ( curLambda . heapFrame != null && this == curLambda ) code . emitLoad ( curLambda . heapFrame ) ; else if ( curLambda . closureEnv != null ) code . emitLoad ( curLambda . closureEnv ) ; else code . emitPushThis ( ) ; if ( this != curLambda ) { LambdaExp parent = curLambda . outerLambda ( ) ; while ( parent != this ) { if ( parent . staticLinkField != null ) code . emitGetField ( parent . staticLinkField ) ; / / curLambda = parent ; parent = parent . outerLambda ( ) ; } } }	{ code . emitLoad ( curLambda . heapFrame ) ; return ; } ClassType curType ; if ( curLambda . closureEnv != null ) { code . emitLoad ( curLambda . closureEnv ) ; curType = ( ClassType ) curLambda . closureEnv . getType ( ) ; }
while ( pat . search ( this , start ) != - 1 ) { <CTX> public IRubyObject scan ( IRubyObject arg ) { RubyRegexp pat = RubyRegexp . regexpValue ( arg ) ; int start = 0 ; if ( ! getRuntime ( ) . getCurrentContext ( ) . isBlockGiven ( ) ) { RubyArray ary = getRuntime ( ) . newArray ( ) ; while ( pat . search ( this , start ) != - 1 ) { RubyMatchData md = ( RubyMatchData ) getRuntime ( ) . getCurrentContext ( ) . getBackref ( ) ; if ( md . getSize ( ) == 1 ) { ary . append ( md . group ( 0 ) ) ; } else { ary . append ( md . subseq ( 1 , md . getSize ( ) ) ) ; } if ( md . matchEndPosition ( ) == md . matchStartPosition ( ) ) { start ++ ; } else { start = md . matchEndPosition ( ) ; } } return ary ; } while ( pat . search ( this , start ) != - 1 ) { RubyMatchData md = ( RubyMatchData ) getRuntime ( ) . getCurrentContext ( ) . getBackref ( ) ; if ( md . getSize ( ) == 1 ) { getRuntime ( ) . getCurrentContext ( ) . yield ( md . group ( 0 ) ) ; } else { getRuntime ( ) . getCurrentContext ( ) . yield ( md . subseq ( 1 , md . getSize ( ) ) ) ; } if ( md . matchEndPosition ( ) == md . matchStartPosition ( ) ) { start ++ ; } else { start = md . matchEndPosition ( ) ; } } return this ; }	while ( pattern . search ( this , start ) != - 1 ) {
if ( methodId == Id_constructor ) return 1 ; return super . methodArity ( methodId ) ; <CTX> public int methodArity ( int methodId ) { if ( methodId == Id_constructor ) return 1 ; return super . methodArity ( methodId ) ; }	if ( f . methodId == Id_constructor ) return 1 ; return super . methodArity ( f ) ;
if ( uri != null && uri != SchemaSymbols . URI_SCHEMAFORSCHEMA && uri != SchemaSymbols . URI_XSI && uri != XMLSymbols . PREFIX_XMLNS && uri != XMLSymbols . PREFIX_XMLNS ) <CTX> private boolean hasNonSchemaAttributes ( XMLAttributes attributes ) { for ( int i = 0 ; i < attributes . getLength ( ) ; i ++ ) { String uri = attributes . getURI ( i ) ; if ( uri != null && uri != SchemaSymbols . URI_SCHEMAFORSCHEMA && uri != SchemaSymbols . URI_XSI && uri != XMLSymbols . PREFIX_XMLNS && uri != XMLSymbols . PREFIX_XMLNS ) return true ; } return false ; }	if ( uri != null && uri != SchemaSymbols . URI_SCHEMAFORSCHEMA && uri != NamespaceContext . XMLNS_URI && ! ( uri == NamespaceContext . XML_URI && attributes . getQName ( i ) == SchemaSymbols . ATT_XML_LANG && element . localpart == SchemaSymbols . ELT_SCHEMA ) ) {
return Integer . valueOf ( getString ( context , KEY_PROJECT_GROUP_ID ) ) . intValue ( ) ; <CTX> public static int getProjectGroupId ( Map context ) { return Integer . valueOf ( getString ( context , KEY_PROJECT_GROUP_ID ) ) . intValue ( ) ; }	return getInteger ( context , KEY_PROJECT_GROUP_ID ) ;
if ( wizardActionIds != null ) for ( int i = 0 ; i < wizardActionIds . length ; i ++ ) if ( ( action = getAction ( wizardActionIds [ i ] ) ) != null ) <CTX> public void fillContextMenu ( IMenuManager menu ) { Assert . isTrue ( ! disposed ) ; IAction action = null ; if ( wizardActionIds != null ) for ( int i = 0 ; i < wizardActionIds . length ; i ++ ) if ( ( action = getAction ( wizardActionIds [ i ] ) ) != null ) menu . add ( action ) ; }	if ( wizardActionIds != null ) { for ( int i = 0 ; i < wizardActionIds . length ; i ++ ) { if ( ( action = getAction ( wizardActionIds [ i ] ) ) != null ) {
image = ( Image ) imageCache . get ( imageDescritor ) ; <CTX> public void releaseReferences ( ) { id = null ; tooltip = null ; title = null ; if ( image != null && imageDescritor != null ) { / / make sure part has inc . the reference count . if ( part != null ) part . getTitleImage ( ) ; ReferenceCounter imageCache = WorkbenchImages . getImageCache ( ) ; image = ( Image ) imageCache . get ( imageDescritor ) ; if ( image != null ) { imageCache . removeRef ( imageDescritor ) ; } image = null ; imageDescritor = null ; } }	image = ( Image ) imageCache . get ( imageDescriptor ) ;
ArrayList res = new ArrayList ( ) ; <CTX> public List getKeys ( int appdefType , int appdefTypeId ) { CpropKeyDAO cpHome ; Collection keys ; ArrayList res = new ArrayList ( ) ; try { keys = DAOFactory . getDAOFactory ( ) . getCpropKeyDAO ( ) . findByAppdefType ( appdefType , appdefTypeId ) ; } catch ( HibernateException exc ) { return res ; } for ( Iterator i = keys . iterator ( ) ; i . hasNext ( ) ; ) { CpropKey key = ( CpropKey ) i . next ( ) ; res . add ( key . getCPropKeyValue ( ) ) ; } return res ; }	List res = new ArrayList ( ) ;
return Utilities . drawTabbedText ( segment , x , y , g , this , 0 ) ; <CTX> protected int drawSelectedText ( Graphics g , int x , int y , int p 0 , int p 1 ) throws BadLocationException { g . setColor ( selectedColor ) ; Segment segment = getLineBuffer ( ) ; getDocument ( ) . getText ( p 0 , p 1 - p 0 , segment ) ; return Utilities . drawTabbedText ( segment , x , y , g , this , 0 ) ; }	return Utilities . drawTabbedText ( segment , x , y , g , this , p 0 ) ;
return Result . createSingleDependency ( psi , host ) ; <CTX> public Result < PsiElement > compute ( ) { final TextRange documentWindow = host . getTextRange ( ) . cutOut ( range ) ; final VirtualFile hostVirtualFile = host . getContainingFile ( ) . getVirtualFile ( ) ; final DocumentEx document = ( DocumentEx ) PsiDocumentManager . getInstance ( host . getProject ( ) ) . getDocument ( host . getContainingFile ( ) ) ; DocumentRange documentRange = new DocumentRange ( document , documentWindow ) ; Language language = host . getManager ( ) . getInjectedLanguage ( host ) ; final VirtualFile virtualFile = new VirtualFileDelegate ( hostVirtualFile , documentWindow , language , text ) ; FileDocumentManagerImpl . registerDocument ( documentRange , virtualFile ) ; PsiElement psi = parseInjectedPsiFile ( text , host . getManager ( ) , language , virtualFile ) ; if ( psi != null ) { psi . putUserData ( ResolveUtil . INJECTED_IN_ELEMENT , host ) ; / / . getContainingFile ( ) ) ; } return Result . createSingleDependency ( psi , host ) ; }	return Result . createSingleDependency ( result , host ) ;
if ( style == CURRENCY ) { <CTX> public NumberFormat getNumberFormat ( int style ) { try { NumberFormat result = null ; if ( numberFormats != null ) { Object temp = numberFormats [ style ] ; if ( temp instanceof NumberFormat ) { result = ( NumberFormat ) temp ; } else { result = new DecimalFormat ( ( String ) temp , new DecimalFormatSymbols ( getDateLocale ( ) ) ) ; } } if ( result != null ) { result = ( NumberFormat ) result . clone ( ) ; / / clone for safety ( later optimize ) if ( style == CURRENCY ) { result . setCurrency ( getCurrency ( ) ) ; } return result ; } / / In the case of date formats , we don t have to look at more than one / / locale . May be different for other cases switch ( style ) { case NUMBER : return NumberFormat . getInstance ( getNumberLocale ( ) ) ; case SCIENTIFIC : return NumberFormat . getScientificInstance ( getNumberLocale ( ) ) ; case INTEGER : return NumberFormat . getIntegerInstance ( getNumberLocale ( ) ) ; case PERCENT : return NumberFormat . getPercentInstance ( getNumberLocale ( ) ) ; case CURRENCY : result = NumberFormat . getCurrencyInstance ( getNumberLocale ( ) ) ; result . setCurrency ( getCurrency ( ) ) ; return result ; } } catch ( RuntimeException e ) { } throw new IllegalArgumentException ( ) ; / / fix later }	if ( style == NF_CURRENCY ) {
ValueBaseHelper . write ( this , value ) ; <CTX> public void write_value ( Serializable value ) { ValueBaseHelper . write ( this , value ) ; }	Vio . write ( this , value ) ;
iVisited . accept (_Payload ) ; <CTX> public void visitCallNode ( CallNode iVisited ) { iVisited . getRecvNode ( ) . accept ( this ) ; for ( Node node = iVisited . getArgsNode ( ) ; node != null ; node = node . getNextNode ( ) ) { node . getHeadNode ( ) . accept ( this ) ; } iVisited . accept (_Payload ) ; }	_ Payload . visitCallNode ( iVisited ) ;
throw new EvaluatorException ( message , sourceName , line , lineSource , lineOffset ) ; <CTX> public EvaluatorException runtimeError ( String message , String sourceName , int line , String lineSource , int lineOffset ) { throw new EvaluatorException ( message , sourceName , line , lineSource , lineOffset ) ; }	if ( chainedReporter != null ) { return chainedReporter . runtimeError ( message , sourceURI , line , lineText , lineOffset ) ; } else { return new EvaluatorException ( message , sourceURI , line , lineText , lineOffset ) ; }
this . system = system ; <CTX> public ActivationGroupID ( ActivationSystem system ) { this . system = system ; }	system = aSystem ; uid = new UID ( ) ;
File dir = FileUtils . getParentFile ( file ) ; <CTX> public FileDesc addFileIfShared ( File file ) { / / Make sure capitals are resolved properly , etc . File f = null ; try { f = FileUtils . getCanonicalFile ( file ) ; if ( ! f . exists ( ) ) return null ; } catch ( IOException e ) { return null ; } File dir = FileUtils . getParentFile ( file ) ; if ( dir == null ) return null ; / / TODO : if overwriting an existing , take special care . boolean directoryShared ; synchronized ( this ) { directoryShared =_sharedDirectories . containsKey ( dir ) ;_numPendingFiles ++ ; } FileDesc fd ; if ( directoryShared ) fd = addFile ( file ) ; else fd = null ; synchronized ( this ) {_numPendingFiles -- ; } return fd ; }	File dir = FileUtils . getParentFile ( f ) ;
else if ( autoSave == IPreferences . AUTO_SAVE_ASK ) <CTX> public void build ( IFile doxyfile ) { / / Retrieves the plugin preferences . Preferences preferences = Plugin . getDefault ( ) . getPluginPreferences ( ) ; / / Ask the user if he wants to save all opened editors before proceeding to build . final String autoSave = preferences . getString ( IPreferences . AUTO_SAVE ) ; if ( autoSave == IPreferences . AUTO_SAVE_ALWAYS ) { PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) . saveAllEditors ( false ) ; } else if ( autoSave == IPreferences . AUTO_SAVE_ASK ) { boolean saved ; saved = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) . saveAllEditors ( true ) ; if ( saved == false ) { return ; } } / / Retreives the build job for the given doxyfile . BuildJob job = BuildJob . getJob ( doxyfile ) ; / / Attaches a listener if applicable . if ( jobHistory . contains ( job ) == false ) { job . addBuidJobListener ( new MyJobListener ( ) ) ; } / / Updates the job history . int preferedHistorySize = preferences . getInt ( IPreferences . BUILD_HISTORY_SIZE ) ; jobHistory . remove ( job ) ; if ( jobHistory . size ( ) >= preferedHistorySize && jobHistory . isEmpty ( ) == false ) { jobHistory . remove ( 0 ) ; } jobHistory . add ( job ) ; / / Updates the console . ConsoleManager consoleManager = Plugin . getDefault ( ) . getConsoleManager ( ) ; consoleManager . showConsole ( job ) ; / / Schedule the job to build . job . schedule ( ) ; }	else if ( autoSave . equals ( IPreferences . AUTO_SAVE_ASK ) )
result = self . getInternalClass ( ) . call ( self . toRubyObject ( ) , iVisited . getName ( ) , args , 1 ) ; <CTX> public void visitFCallNode ( FCallNode iVisited ) { Block tmpBlock = ArgsUtil . beginCallArgs ( ruby ) ; IRubyObject [ ] args = ArgsUtil . setupArgs ( ruby , this , iVisited . getArgsNode ( ) ) ; ArgsUtil . endCallArgs ( ruby , tmpBlock ) ; result = self . getInternalClass ( ) . call ( self . toRubyObject ( ) , iVisited . getName ( ) , args , 1 ) ; }	result = self . getInternalClass ( ) . call ( self , iVisited . getName ( ) , args , 1 ) ;
int colNumber = columnNumber - columnWithWidth ; int aw = ( maxWidth - colSum ) / colNumber ; distributeWidth ( columns , colNumber , aw ) ; <CTX> public int [ ] resolve ( int specifiedWidth , int maxWidth ) { assert ( specifiedWidth <= maxWidth ) ; int columnNumber = table . getColumnCount ( ) ; int [ ] columns = new int [ columnNumber ] ; int columnWithWidth = 0 ; int colSum = 0 ; for ( int j = 0 ; j < table . getColumnCount ( ) ; j ++ ) { IColumn column = ( IColumn ) table . getColumn ( j ) ; int columnWidth = getDimensionValue ( column . getWidth ( ) , tableWidth ) ; if ( columnWidth > 0 ) { columns [ j ] = columnWidth ; colSum += columnWidth ; columnWithWidth ++ ; } else { columns [ j ] = - 1 ; } } if ( columnWithWidth == columnNumber ) { if ( colSum <= maxWidth ) { return columns ; } else { int delta = ( colSum - maxWidth ) / columnNumber ; assert ( delta >= 0 ) ; for ( int i = 0 ; i < columnNumber ; i ++ ) { columns [ i ] -= delta ; } return columns ; } } else { if ( specifiedWidth == 0 ) { if ( colSum < maxWidth ) { int colNumber = columnNumber - columnWithWidth ; int aw = ( maxWidth - colSum ) / colNumber ; distributeWidth ( columns , colNumber , aw ) ; } else { distributeWidth ( columns , columnNumber , maxWidth / columnNumber ) ; } } else { if ( colSum < specifiedWidth ) { int colNumber = columnNumber - columnWithWidth ; int aw = ( specifiedWidth - colSum ) / colNumber ; distributeWidth ( columns , colNumber , aw ) ; } else { if ( colSum < maxWidth ) { int colNumber = columnNumber - columnWithWidth ; int aw = ( maxWidth - colSum ) / colNumber ; distributeWidth ( columns , colNumber , aw ) ; } else { distributeWidth ( columns , columnNumber , specifiedWidth / columnNumber ) ; } } } } return columns ; }	distributeLeftWidth ( columns , ( maxWidth - colSum ) / ( columnNumber - columnWithWidth ) ) ;
if ( attr == null ) return null ; <CTX> public String getString ( String key ) { Attr attr = element . getAttributeNode ( key ) ; if ( attr == null ) return null ; return attr . getValue ( ) ; }	if ( attr == null ) { return null ; }
return oldMap . size ( ) >= newMap . size ( ) ; <CTX> private static boolean isCompatibleRSMap ( Map oldMap , Map newMap ) { if ( oldMap == newMap ) return true ; else if ( oldMap == null ) return newMap . size ( ) == 0 ; else if ( newMap == null ) return oldMap . size ( ) == 0 ; return oldMap . size ( ) >= newMap . size ( ) ; }	if ( newMap . size ( ) > oldMap . size ( ) ) return false ; Iterator it = newMap . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { Object key = it . next ( ) ; Object oldObj = oldMap . get ( key ) ; Object newObj = newMap . get ( key ) ; if ( oldObj != null ) { if ( isTwoExpressionEqual ( ( IBaseExpression ) newObj , ( IBaseExpression ) oldObj ) ) return false ; } else { return false ; } } return true ;
contexts . remove ( cx ) ; <CTX> public void contextReleased ( Context cx ) { contexts . remove ( cx ) ; }	synchronized ( contexts ) { contexts . remove ( cx ) ; }
if ( perspectiveSwitcher != null ) perspectiveSwitcher . update ( false ) ; <CTX> public void setActivePage ( final IWorkbenchPage in ) { if ( getActiveWorkbenchPage ( ) == in ) return ; / / 1 FVGTNR : ITPUI : WINNT - busy cursor for switching perspectives BusyIndicator . showWhile ( getShell ( ) . getDisplay ( ) , new Runnable ( ) { public void run ( ) { / / Deactivate old persp . WorkbenchPage currentPage = getActiveWorkbenchPage ( ) ; if ( currentPage != null ) { currentPage . onDeactivate ( ) ; } / / Activate new persp . if ( in == null || pageList . contains ( in ) ) pageList . setActive ( in ) ; WorkbenchPage newPage = pageList . getActive ( ) ; Composite parent = getPageComposite ( ) ; StackLayout layout = ( StackLayout ) parent . getLayout ( ) ; if ( newPage != null ) { layout . topControl = newPage . getClientComposite ( ) ; parent . layout ( ) ; hideEmptyWindowContents ( ) ; newPage . onActivate ( ) ; firePageActivated ( newPage ) ; if ( newPage . getPerspective ( ) != null ) firePerspectiveActivated ( newPage , newPage . getPerspective ( ) ) ; } else { layout . topControl = null ; parent . layout ( ) ; } updateFastViewBar ( ) ; if ( isClosing ( ) ) return ; updateDisabled = false ; / / Update action bars ( implicitly calls updateActionBars ( ) ) updateActionSets ( ) ; if ( perspectiveSwitcher != null ) perspectiveSwitcher . update ( false ) ; getMenuManager ( ) . update ( IAction . TEXT ) ; } } ) ; }	updateActionSets ( ) ; submitGlobalActions ( ) ;
while ( true ) { try { result = getIterNode ( ) . eval ( ruby , self ) ; break ; } catch ( RetryException rExcptn ) { } catch ( ReturnException rExcptn ) { result = rExcptn . getReturnValue ( ) ; break ; } catch ( BreakException bExcptn ) { result = ruby . getNil ( ) ; break ; <CTX> public RubyObject eval ( Ruby ruby , RubyObject self ) { RubyObject result ; ruby . getBlock ( ) . push ( getVarNode ( ) , getBodyNode ( ) , self ) ; ruby . getIter ( ) . push ( RubyIter . ITER_PRE ) ; while ( true ) { try { result = getIterNode ( ) . eval ( ruby , self ) ; break ; } catch ( RetryException rExcptn ) { } catch ( ReturnException rExcptn ) { result = rExcptn . getReturnValue ( ) ; break ; } catch ( BreakException bExcptn ) { result = ruby . getNil ( ) ; break ; } } ruby . getIter ( ) . pop ( ) ; ruby . getBlock ( ) . pop ( ) ; return result ; }	try { while ( true ) { try { return getIterNode ( ) . eval ( ruby , self ) ; } catch ( RetryException rExcptn ) { }
if ( processesFrame . isVisible ( ) ) { processesFrame . setVisible ( false ) ; <CTX> public void actionPerformed ( java . awt . event . ActionEvent e ) { if ( processesFrame . isVisible ( ) ) { processesFrame . setVisible ( false ) ; } else { processesFrame . setVisible ( true ) ; } }	if ( jobMonitorFrame . isVisible ( ) ) { jobMonitorFrame . setVisible ( false ) ;
keywordMap = null ; <CTX> private static Completion [ ] getCompletions ( Buffer buffer , String word , int caret ) { / / build a list of unique words in all visible buffers Set completions = new TreeSet ( new MiscUtilities . StringICaseCompare ( ) ) ; Set buffers = new HashSet ( ) ; View views = jEdit . getFirstView ( ) ; while ( views != null ) { EditPane [ ] panes = views . getEditPanes ( ) ; for ( int i = 0 ; i < panes . length ; i ++ ) { Buffer b = panes [ i ] . getBuffer ( ) ; if ( buffers . contains ( b ) ) continue ; buffers . add ( b ) ; / / only complete current buffer s keyword map KeywordMap keywordMap ; if ( b == buffer ) { keywordMap = b . getKeywordMapAtOffset ( caret ) ; } else keywordMap = null ; int offset = ( b == buffer ? caret : 0 ) ; String noWordSep = getNonAlphaNumericWordChars ( b , keywordMap , offset ) ; getCompletions ( b , word , keywordMap , noWordSep , offset , completions ) ; } views = views . getNext ( ) ; } Completion [ ] completionArray = ( Completion [ ] ) completions . toArray ( new Completion [ completions . size ( ) ] ) ; return completionArray ; } / / } } }	_ keywordMap = null ;
if ( showSelections ( ) && ! showChildrenHierarchy ( ) ) return IResource . DEPTH_ZERO ; <CTX> int getResourceDepth ( ) { if ( showSelections ( ) && ! showChildrenHierarchy ( ) ) return IResource . DEPTH_ZERO ; return IResource . DEPTH_INFINITE ; }	if ( showSelections ( ) && ! showChildrenHierarchy ( ) ) { return IResource . DEPTH_ZERO ; }
endpointReferences . add ( ( EndpointReference ) digester . pop ( ) ) ; <CTX> public void end ( String endpointName , String endpointName 1 ) throws Exception { endpointReferences . add ( ( EndpointReference ) digester . pop ( ) ) ; }	digester . pop ( ) ;
map . put ( d . getManagementKey ( ) , artifact ) ; <CTX> private Map createManagedVersionMap ( DependencyManagement dependencyManagement ) { Map map = new HashMap ( ) ; for ( Iterator i = dependencyManagement . getDependencies ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Dependency d = ( Dependency ) i . next ( ) ; Artifact artifact = artifactFactory . createArtifact ( d . getGroupId ( ) , d . getArtifactId ( ) , d . getVersion ( ) , d . getScope ( ) , d . getType ( ) , null ) ; map . put ( d . getManagementKey ( ) , artifact ) ; } return map ; }	map . put ( d . getManagementKey ( ) , artifact ) ; } } else { map = Collections . EMPTY_MAP ;
return make . This ( pos , Ident ( pos , sym ) ) . setType ( sym . thisType ( ) ) ; <CTX> public Tree This ( int pos , Symbol sym ) { return make . This ( pos , Ident ( pos , sym ) ) . setType ( sym . thisType ( ) ) ; }	Type type = sym . thisType ( ) ; return make . This ( pos , TypeTerm ( pos , type ) ) . setType ( type ) ;
contextListeners = ListenerArray . remove ( contextListeners , listener ) ; <CTX> public static void removeContextListener ( ContextListener listener ) { synchronized ( contextListenersLock ) { contextListeners = ListenerArray . remove ( contextListeners , listener ) ; } }	contextListeners = Kit . removeListener ( contextListeners , listener ) ;
Fact factAtLocation = getFactAtLocation ( new Location ( handle , basicBlock ) ) ; <CTX> public void transfer ( BasicBlock basicBlock , InstructionHandle end , Fact start , Fact result ) throws DataflowAnalysisException { copy ( start , result ) ; if ( isFactValid ( result ) ) { Iterator < InstructionHandle > i = isForwards ( ) ? basicBlock . instructionIterator ( ) : basicBlock . instructionReverseIterator ( ) ; while ( i . hasNext ( ) ) { InstructionHandle handle = i . next ( ) ; if ( handle == end ) break ; / / Record the fact at this location Fact factAtLocation = getFactAtLocation ( new Location ( handle , basicBlock ) ) ; copy ( result , factAtLocation ) ; / / Transfer the dataflow value transferInstruction ( handle , basicBlock , result ) ; } } }	Location location = new Location ( handle , basicBlock ) ; Fact factAtLocation = getFactAtLocation ( location ) ;
boolean [ ] breakableLines = this . breakableLines ; if ( breakableLines != null && line < breakableLines . length ) { return breakableLines [ line ] ; <CTX> boolean breakableLine ( int line ) { boolean [ ] breakableLines = this . breakableLines ; if ( breakableLines != null && line < breakableLines . length ) { return breakableLines [ line ] ; } return false ; }	boolean [ ] breakableLines = this . breakableLines ; if ( breakableLines != null && line < breakableLines . length ) { return breakableLines [ line ] ; } return false ;
return new RubyArray ( ruby ) { <CTX> public static RubyArray nilArray ( Ruby ruby ) { return new RubyArray ( ruby ) { public boolean isNil ( ) { return true ; } } ; }	return new RubyArray ( ruby , null ) {
return new UTF_16 Encoder ( this , UTF_16 Encoder . BIG_ENDIAN , false ) ; <CTX> public CharsetEncoder newEncoder ( ) { return new UTF_16 Encoder ( this , UTF_16 Encoder . BIG_ENDIAN , false ) ; }	return new UTF_16 Encoder ( this , UTF_16 Encoder . BIG_ENDIAN , true ) ;
return fullDefinitions . length > 0 ; <CTX> public boolean prepareDecoration ( Object element , String originalText ) { / / Check if there is a decoration ready or if there is no lightweight decorators to be applied if ( scheduler . isDecorationReady ( element ) || ! getLightweightManager ( ) . hasEnabledDefinitions ( ) ) { return true ; } / / Force an update if there is a text already boolean force = true ; / / If not then do not force as the undecorated value is fine if ( originalText == null || originalText . length ( ) == 0 ) force = false ; / / Queue the decoration . scheduler . queueForDecoration ( element , getResourceAdapter ( element ) , force , originalText ) ; / / If all that is there is deferred ones then defer decoration . / / For the sake of effeciency we do not test for enablement at this / / point and just abandon deferment if there are any to run right / / away return fullDefinitions . length > 0 ; }	return getFullDefinitions ( ) . length > 0 ;
IDomainValidator domainValidator ) { this ( modelToTargetConverter , targetToModelConverter , targetValidator , domainValidator , null , null , null ) ; <CTX> public BindSpec ( IConverter modelToTargetConverter , IConverter targetToModelConverter , IValidator targetValidator , IDomainValidator domainValidator ) { this ( modelToTargetConverter , targetToModelConverter , targetValidator , domainValidator , null , null , null ) ; }	IDomainValidator domainValidator , Integer modelUpdatePolicy , Integer validatePolicy , Integer targetUpdatePolicy ) { this . modelToTargetConverters [ 0 ] = modelToTargetConverter ; this . targetToModelConverters [ 0 ] = targetToModelConverter ; this . targetValidators [ 0 ] = targetValidator ; this . domainValidator = domainValidator ; this . modelUpdatePolicy = modelUpdatePolicy ; this . validatePolicy = validatePolicy ; this . targetUpdatePolicy = targetUpdatePolicy ;
jsi . itsData = new InterpreterData ( itsData . securityDomain , itsData . languageVersion ) ; jsi . itsData . parentData = itsData ; jsi . itsData . itsSourceFile = itsData . itsSourceFile ; jsi . itsData . encodedSource = itsData . encodedSource ; <CTX> private void generateNestedFunctions ( Context cx ) { int functionCount = scriptOrFn . getFunctionCount ( ) ; if ( functionCount == 0 ) return ; InterpreterData [ ] array = new InterpreterData [ functionCount ] ; for ( int i = 0 ; i != functionCount ; i ++ ) { FunctionNode def = scriptOrFn . getFunctionNode ( i ) ; Interpreter jsi = new Interpreter ( ) ; jsi . compilerEnv = compilerEnv ; jsi . scriptOrFn = def ; jsi . itsData = new InterpreterData ( itsData . securityDomain , itsData . languageVersion ) ; jsi . itsData . parentData = itsData ; jsi . itsData . itsSourceFile = itsData . itsSourceFile ; jsi . itsData . encodedSource = itsData . encodedSource ; jsi . itsData . itsCheckThis = def . getCheckThis ( ) ; jsi . itsInFunctionFlag = true ; jsi . generateFunctionICode ( cx ) ; array [ i ] = jsi . itsData ; } itsData . itsNestedFunctions = array ; }	jsi . itsData = new InterpreterData ( itsData ) ;
this ( Location . UNKNOWN , value ) ; <CTX> public StringLiteralExpr ( String value ) { this ( Location . UNKNOWN , value ) ; }	super ( location ) ;_value = new InternStringValue ( value ) ;
return ( ( page == specPage && page . isPageComplete ( ) && structurePage . isInitialized ( ) ) || ( page == structurePage && page . isPageComplete ( ) ) || ( page == pluginListPage && page . isPageComplete ( ) ) ) ; <CTX> public boolean canFinish ( ) { IWizardPage page = getContainer ( ) . getCurrentPage ( ) ; return ( ( page == specPage && page . isPageComplete ( ) && structurePage . isInitialized ( ) ) || ( page == structurePage && page . isPageComplete ( ) ) || ( page == pluginListPage && page . isPageComplete ( ) ) ) ; }	return ( ( page == specPage && page . isPageComplete ( ) ) || ( page == pluginListPage && page . isPageComplete ( ) ) ) ;
int leftBits = floatToIntBits ( this . floatValue ( ) ) ; int rightBits = floatToIntBits ( ( ( Float ) obj ) . floatValue ( ) ) ; int nanBits = floatToIntBits ( NaN ) ; int posBits = floatToIntBits ( POSITIVE_INFINITY ) ; int negBits = floatToIntBits ( NEGATIVE_INFINITY ) ; <CTX> public boolean equals ( Object obj ) { if ( ( obj != null ) && ( obj instanceof Float ) ) { int leftBits = floatToIntBits ( this . floatValue ( ) ) ; int rightBits = floatToIntBits ( ( ( Float ) obj ) . floatValue ( ) ) ; int nanBits = floatToIntBits ( NaN ) ; int posBits = floatToIntBits ( POSITIVE_INFINITY ) ; int negBits = floatToIntBits ( NEGATIVE_INFINITY ) ; if ( ( this . isNaN ( ) == true ) && ( ( ( Float ) obj ) . isNaN ( ) == true ) ) { return true ; } if ( ( ( leftBits == posBits ) && ( rightBits == negBits ) ) || ( ( leftBits == posBits ) && ( rightBits == negBits ) ) ) { return true ; } return ( leftBits == rightBits ) ; } else { return false ; } }	final int leftBits = floatToIntBits ( this . value ) ; final int rightBits = floatToIntBits ( ( ( Float ) obj ) . value ) ; final int posBits = floatToIntBits ( POSITIVE_INFINITY ) ; final int negBits = floatToIntBits ( NEGATIVE_INFINITY ) ;
return this . nestedThrowable ; <CTX> public Throwable getCause ( ) { return this . nestedThrowable ; }	return nestedThrowable ;
if ( event . widget . equals ( fccCandle ) ) { series . setFill ( ( Fill ) event . data ) ; } else if ( event . widget . equals ( liacStock ) ) <CTX> public void handleEvent ( Event event ) { if ( event . widget . equals ( fccCandle ) ) { series . setFill ( ( Fill ) event . data ) ; } else if ( event . widget . equals ( liacStock ) ) { if ( event . type == LineAttributesComposite . VISIBILITY_CHANGED_EVENT ) { series . getLineAttributes ( ) . setVisible ( ( ( Boolean ) event . data ) . booleanValue ( ) ) ; } else if ( event . type == LineAttributesComposite . STYLE_CHANGED_EVENT ) { series . getLineAttributes ( ) . setStyle ( ( LineStyle ) event . data ) ; } else if ( event . type == LineAttributesComposite . WIDTH_CHANGED_EVENT ) { series . getLineAttributes ( ) . setThickness ( ( ( Integer ) event . data ) . intValue ( ) ) ; } else if ( event . type == LineAttributesComposite . COLOR_CHANGED_EVENT ) { series . getLineAttributes ( ) . setColor ( ( ColorDefinition ) event . data ) ; } } }	if ( event . widget . equals ( liacStock ) )
return UNCHANGED ; <CTX> private static byte doubleNeg ( OPT_Instruction s ) { if ( CF_DOUBLE ) { OPT_Operand op = Unary . getVal ( s ) ; if ( op . isDoubleConstant ( ) ) { / / CONSTANT : FOLD double val = op . asDoubleConstant ( ) . value ; Move . mutate ( s , DOUBLE_MOVE , Unary . getClearResult ( s ) , DC ( - val ) ) ; return MOVE_FOLDED ; } } return UNCHANGED ; }	return DefUseEffect . UNCHANGED ;
repository = SvnConnect . getInstance ( ) . getRepository ( ) ; <CTX> public SvnCommit ( ) throws SVNException { / / super ( SVNWCUtil . createDefaultAuthenticationManager ( SvnConnect . getInstance ( ) . getName ( ) , SvnConnect . getInstance ( ) . getPassword ( ) ) , SVNWCUtil . createDefaultOptions ( true ) ) ; repository = SvnConnect . getInstance ( ) . getRepository ( ) ; svnCC = new SVNCommitClient ( repository . getAuthenticationManager ( ) , SVNWCUtil . createDefaultOptions ( true ) ) ; }	repository = SvnConnect . getInstance ( url , name , password ) . getRepository ( ) ;
} , project ) ; <CTX> public DomManagerImpl ( final PomModel pomModel , final Project project , final ReferenceProvidersRegistry registry , final PsiManager psiManager , final XmlAspect xmlAspect , final WolfTheProblemSolver solver , final DomElementAnnotationsManagerImpl annotationsManager , final VirtualFileManager virtualFileManager ) { myProject = project ; myAnnotationsManager = annotationsManager ; pomModel . addModelListener ( new PomModelListener ( ) { public synchronized void modelChanged ( PomModelEvent event ) { final XmlChangeSet changeSet = ( XmlChangeSet ) event . getChangeSet ( xmlAspect ) ; if ( changeSet != null ) { if ( ! myChanging ) { new ExternalChangeProcessor ( DomManagerImpl . this , changeSet ) . processChanges ( ) ; } final XmlFile xmlFile = changeSet . getChangedFile ( ) ; if ( xmlFile == null ) return ; final FileDescriptionCachedValueProvider provider = getCachedValueProvider ( xmlFile ) ; if ( provider != null ) { final DomFileDescription description = provider . getFileDescription ( ) ; if ( description != null ) { final DomFileElementImpl < DomElement > fileElement = getFileElement ( xmlFile ) ; final Set < XmlFile > toUpdate = new THashSet < XmlFile > ( ) ; for ( final DomFileDescription < ? > domFileDescription : myFileDescriptionDependencies . get ( description ) ) { toUpdate . addAll ( domFileDescription . getDomModelDependentFiles ( fileElement ) ) ; toUpdate . addAll ( ContainerUtil . map ( myFileDescriptions . get ( domFileDescription ) , new Function < DomFileElementImpl , XmlFile > ( ) { public XmlFile fun ( final DomFileElementImpl s ) { return s . getFile ( ) ; } } ) ) ; } for ( final XmlFile file : toUpdate ) { updateFileDomness ( file , fileElement ) ; } } } } } public boolean isAspectChangeInteresting ( PomModelAspect aspect ) { return xmlAspect . equals ( aspect ) ; } } , project ) ; myReferenceProvidersRegistry = registry ; myElementFactory = psiManager . getElementFactory ( ) ; solver . registerFileHighlightFilter ( new Condition < VirtualFile > ( ) { public boolean value ( final VirtualFile file ) { final PsiFile psiFile = ApplicationManager . getApplication ( ) . runReadAction ( new Computable < PsiFile > ( ) { public @ Nullable PsiFile compute ( ) { return psiManager . findFile ( file ) ; } } ) ; return isDomFile ( psiFile ) ; } } , project ) ; }	} ) ;
void setParentLayer ( EditorFigNode parent ) { <CTX> void setParentLayer ( EditorFigNode parent ) {_parent = parent ; }	void setParentLayer ( ModuleFigNode parent ) {
MemberExpressionNode ( Node base , Node name ) { <CTX> MemberExpressionNode ( Node base , Node name ) { this . base = base ; this . name = name ; }	MemberExpressionNode ( Node base , Node name , int pos ) { super ( pos ) ;
DocumentMapper documentMapper = ApplicationServer . getIMCServiceInterface ( ) . getDocumentMapper ( ) ; <CTX> private synchronized Attributes . LazilyLoadedDocumentAttributes getLazilyLoadedDocumentAttributes ( ) { if ( null == attributes . lazilyLoadedDocumentAttributes ) { attributes . lazilyLoadedDocumentAttributes = new Attributes . LazilyLoadedDocumentAttributes ( ) ; DocumentMapper documentMapper = ApplicationServer . getIMCServiceInterface ( ) . getDocumentMapper ( ) ; documentMapper . initLazilyLoadedDocumentAttributes ( this ) ; } return attributes . lazilyLoadedDocumentAttributes ; }	DocumentMapper documentMapper = Imcms . getServices ( ) . getDocumentMapper ( ) ;
XObject pred = m_predicates [ i ] . execute ( xctxt ) ; <CTX> private final int getProximityPosition ( XPathContext xctxt , int predPos ) { int pos = 0 ; int context = xctxt . getCurrentNode ( ) ; DTM dtm = xctxt . getDTM ( context ) ; int parent = dtm . getParent ( context ) ; try { DTMAxisTraverser traverser = dtm . getAxisTraverser ( Axis . CHILD ) ; for ( int child = traverser . first ( parent ) ; DTM . NULL != child ; child = traverser . next ( parent , child ) ) { try { xctxt . pushCurrentNode ( child ) ; if ( NodeTest . SCORE_NONE != super . execute ( xctxt , child ) ) { boolean pass = true ; try { xctxt . pushSubContextList ( this ) ; for ( int i = 0 ; i < predPos ; i ++ ) { XObject pred = m_predicates [ i ] . execute ( xctxt ) ; try { if ( XObject . CLASS_NUMBER == pred . getType ( ) ) { if ( ( pos + 1 ) != ( int ) pred . numWithSideEffects ( ) ) { pass = false ; break ; } } else if ( ! pred . boolWithSideEffects ( ) ) { pass = false ; break ; } } finally { pred . detach ( ) ; } } } finally { xctxt . popSubContextList ( ) ; } if ( pass ) pos ++ ; if ( child == context ) { return pos ; } } } finally { xctxt . popCurrentNode ( ) ; } } } catch ( javax . xml . transform . TransformerException se ) { / / TODO : should keep throw sax exception . . . throw new java . lang . RuntimeException ( se . getMessage ( ) ) ; } return pos ; }	xctxt . pushPredicatePos ( i ) ;
args = null ; flags = FRAME_ALLOCA ; <CTX> public void push ( ) { Frame oldFrame = new Frame ( self , args , lastFunc , lastClass , cbase , prev , tmp , file , line , iter , flags ) ; prev = oldFrame ; tmp = null ; / / file = null / / line = / / iter = / / cbase = cbase ; args = null ; flags = FRAME_ALLOCA ; }	iter = ruby . getInterpreter ( ) . getRubyIter ( ) . getIter ( ) ; args = null ; flags = FRAME_ALLOCA ;
_ bits = new byte [ ( int ) (_size / 8 ) + (_size % 8 == 0 ? 0 : 1 ) ] ; dis . read (_bits ) ; <CTX> public BitArray ( DataInputStream dis ) throws IOException {_size = dis . readInt ( ) ;_bits = new byte [ ( int ) (_size / 8 ) + (_size % 8 == 0 ? 0 : 1 ) ] ; dis . read (_bits ) ; }	_ bits = new byte [ (_size / 8 ) + (_size % 8 == 0 ? 0 : 1 ) ] ; dis . readFully (_bits ) ;
return person . getAttributeNames ( ) ; <CTX> public Enumeration getAttributeNames ( ) { return person . getAttributeNames ( ) ; }	return this . person . getAttributeNames ( ) ;
loadedClasses = new Class [ classBytes . length ] ; <CTX> public SchemeLoader ( byte [ ] [ ] classBytes ) { this . classBytes = classBytes ; loadedClasses = new Class [ classBytes . length ] ; }	size = classBytes . length ; loadedClasses = new Class [ size ] ;
ICSourceLocator sl = getSourceLocator ( ) ; if ( sl != null ) return ( sl . findSourceElement ( handle ) != null ) ; <CTX> public boolean isTargetBreakpoint ( ICBreakpoint breakpoint ) { / / Problem : gdb doesn t accept breakpoint if the file is specified by full path ( depends on the current directory ) . / / This prevents us from using gdb as a breakpoint filter . The case when two unrelated projects contain files / / with the same name will cause problems . / / Current solution : the source locator is used as a breakpoint filter . IResource resource = breakpoint . getMarker ( ) . getResource ( ) ; if ( breakpoint instanceof ICAddressBreakpoint ) return supportsAddressBreakpoint ( ( ICAddressBreakpoint ) breakpoint ) ; if ( breakpoint instanceof ICLineBreakpoint ) { try { String handle = breakpoint . getSourceHandle ( ) ; ICSourceLocator sl = getSourceLocator ( ) ; if ( sl != null ) return ( sl . findSourceElement ( handle ) != null ) ; } catch ( CoreException e ) { return false ; } } else { IProject project = resource . getProject ( ) ; if ( project != null && project . exists ( ) ) { ICSourceLocator sl = getSourceLocator ( ) ; if ( sl != null ) return sl . contains ( project ) ; if ( project . equals ( getProject ( ) ) ) return true ; return CDebugUtils . isReferencedProject ( getProject ( ) , project ) ; } } return true ; }	ISourceLocator sl = getSourceLocator ( ) ; if ( sl instanceof ICSourceLocator ) return ( ( ( ICSourceLocator ) sl ) . findSourceElement ( handle ) != null ) ; else if ( sl instanceof CSourceLookupDirector ) { return true ; }
if ( hasIdValue ( id ) ) { <CTX> Object [ ] getIds ( boolean getAll ) { Object [ ] result = super . getIds ( getAll ) ; if ( maxId != 0 ) { Object [ ] ids = null ; int count = 0 ; for ( int id = maxId ; id != 0 ; -- id ) { if ( hasIdValue ( id ) ) { if ( getAll || ( getAttributes ( id ) & DONTENUM ) == 0 ) { if ( count == 0 ) { / / Need extra room for nor more then [ 1 . . id ] names ids = new Object [ id ] ; } ids [ count ++ ] = getIdName ( id ) ; } } } if ( count != 0 ) { if ( result . length == 0 && ids . length == count ) { result = ids ; } else { Object [ ] tmp = new Object [ result . length + count ] ; System . arraycopy ( result , 0 , tmp , 0 , result . length ) ; System . arraycopy ( ids , 0 , tmp , result . length , count ) ; } } } return result ; }	if ( hasValue ( id ) ) {
validatePage ( ) ; <CTX> public void modifyText ( ModifyEvent e ) { validatePage ( ) ; }	setPageComplete ( validatePage ( ) ) ;
moveDown ( ) ; <CTX> public void handleEvent ( Event e ) { moveDown ( ) ; }	moveUp ( ) ;
this ( strRep , false ) ; <CTX> public OID ( String strRep ) { this ( strRep , false ) ; }	this ( components , false ) ;
if ( value instanceof UnicodeValue ) return ( UnicodeValue ) value ; <CTX> public Value unmarshall ( Env env , Object value ) { if ( value instanceof UnicodeValue ) return ( UnicodeValue ) value ; else if ( value instanceof Value ) return ( ( Value ) value ) . toUnicodeValue ( env ) ; else return new StringValueImpl ( String . valueOf ( value ) ) ; }	if ( value instanceof BinaryValue ) return ( BinaryValue ) value ;
IWorkbenchAction action = new CyclePartAction ( window , false ) ; <CTX> public IWorkbenchAction create ( IWorkbenchWindow window ) { if ( window == null ) { throw new IllegalArgumentException ( ) ; } IWorkbenchAction action = new CyclePartAction ( window , false ) ; action . setId ( getId ( ) ) ; return action ; }	IWorkbenchAction action = new CycleEditorAction ( window , false ) ;
return null ; <CTX> public XMLSource make ( String localeID ) { / / TODO Auto - generated method stub return null ; }	return mySource . make ( localeID ) ;
chemObject . addMolecule ( new Molecule ( ) ) ; <CTX> public void testStateChanged_ChemObjectChangeEvent ( ) { ChemObjectListenerImpl listener = new ChemObjectListenerImpl ( ) ; SetOfMolecules chemObject = new SetOfMolecules ( ) ; chemObject . addListener ( listener ) ; chemObject . addMolecule ( new Molecule ( ) ) ; assertTrue ( listener . changed ) ; }	chemObject . addMolecule ( builder . newMolecule ( ) ) ;
return encodeMetadata ( meta , mColor , mContentType , mFragment , mRevisionList ) ; <CTX> Metadata encodeMetadata ( Metadata meta ) { return encodeMetadata ( meta , mColor , mContentType , mFragment , mRevisionList ) ; }	return encodeMetadata ( meta , mColor , mContentType , mRevisionList ) ;
Object statementsResult = Utils . execute ( uriResolver , jaxenContext , variableContext , statements ) ; <CTX> public Object execute ( URIResolver uriResolver , Object context , VariableContextImpl variableContext ) { List result = new ArrayList ( ) ; List selected = Utils . evaluateToList ( uriResolver , context , variableContext , getLocationData ( ) , select , namespaceContext ) ; Context jaxenContext = new Context ( null ) ; jaxenContext . setSize ( selected . size ( ) ) ; for ( int i = 0 ; i < selected . size ( ) ; i ++ ) { jaxenContext . setPosition ( i + 1 ) ; jaxenContext . setNodeSet ( Arrays . asList ( new Object [ ] { selected . get ( i ) } ) ) ; Object statementsResult = Utils . execute ( uriResolver , jaxenContext , variableContext , statements ) ; if ( statementsResult instanceof List ) { result . addAll ( ( List ) statementsResult ) ; } else { result . add ( statementsResult ) ; } } return result . size ( ) == 1 ? result . get ( 0 ) : result ; }	Object statementsResult = Utils . execute ( uriResolver , jaxenContext , variableContext , documentContext , statements ) ;
c =_content . get ( ) ; <CTX> public int read ( ) throws IOException { int c = - 1 ; if ( blockForContent ( ) ) c =_content . get ( ) ; return c ; }	c = 0 xff &_content . get ( ) ;
return task . getIcon ( ) ; <CTX> private Image getIcon ( ) { return task . getIcon ( ) ; }	return labelProvider . getImage ( task ) ;
if ( mouseEvent . getClickCount ( ) == 0 || ! isShown ( ) ) { <CTX> public void eventDispatched ( AWTEvent event ) { MouseEvent mouseEvent = ( MouseEvent ) event ; if ( mouseEvent . getClickCount ( ) == 0 || ! isShown ( ) ) { return ; } final Component sourceComponent = mouseEvent . getComponent ( ) ; final Point originalPoint = mouseEvent . getPoint ( ) ; final Lookup activeLookup = LookupManager . getInstance ( getEditor ( ) . getProject ( ) ) . getActiveLookup ( ) ; if ( activeLookup != null ) { final DebuggerTree tree = myNode . getTree ( ) ; final JLayeredPane layeredPane = tree . getRootPane ( ) . getLayeredPane ( ) ; final Point layeredPoint = SwingUtilities . convertPoint ( sourceComponent , originalPoint , layeredPane ) ; if ( activeLookup . getBounds ( ) . contains ( layeredPoint ) ) { return ; / / mouse click inside lookup } else { ( ( LookupImpl ) activeLookup ) . hide ( ) ; / / hide popup on mouse position changed } } final Point point = SwingUtilities . convertPoint ( sourceComponent , originalPoint , myInplaceEditorComponent ) ; if ( myInplaceEditorComponent . contains ( point ) ) { return ; } final Component componentAtPoint = SwingUtilities . getDeepestComponentAt ( sourceComponent , originalPoint . x , originalPoint . y ) ; for ( Component comp = componentAtPoint ; comp != null ; comp = comp . getParent ( ) ) { if ( comp instanceof ComboPopup ) { return ; } } cancelEditing ( ) ; }	if ( mouseEvent . getClickCount ( ) == 0 ) {
super ( position ) ; <CTX> public UndefNode ( ISourcePosition position , String name ) { super ( position ) ; this . name = name . intern ( ) ; }	super ( position , NodeTypes . UNDEFNODE ) ;
return BigDecimal . valueOf ( ( ( Integer ) obj ) . intValue ( ) ) ; <CTX> public Object convert ( Object obj , String param ) { return BigDecimal . valueOf ( ( ( Integer ) obj ) . intValue ( ) ) ; }	return new BigDecimal ( ( ( Double ) obj ) . toString ( ) ) ;
if ( state != MOUSE_DOWN ) { <CTX> private void updateImage ( boolean over ) { this . over = over ; if ( ! over ) { currentImage = normalImage ; currentColor = normalColor ; state = NORMAL ; } else { if ( mouseDown ) { if ( state != MOUSE_DOWN ) { if ( mouseDownSound != null ) { mouseDownSound . play ( ) ; } currentImage = mouseDownImage ; currentColor = mouseDownColor ; state = MOUSE_DOWN ; listener . componentActivated ( this ) ; } } else { if ( state != MOUSE_OVER ) { if ( mouseOverSound != null ) { mouseOverSound . play ( ) ; } currentImage = mouseOverImage ; currentColor = mouseOverColor ; state = MOUSE_OVER ; } } } mouseDown = false ; state = NORMAL ; }	if ( ( state != MOUSE_DOWN ) && ( mouseUp ) ) {
return InfoEnrolmentEvaluation . newInfoFromDomain ( enrolment . getLatestEnrolmentEvaluation ( ) ) ; <CTX> public InfoEnrolmentEvaluation getInfoEnrolmentEvaluation ( ) { return InfoEnrolmentEvaluation . newInfoFromDomain ( enrolment . getLatestEnrolmentEvaluation ( ) ) ; }	return InfoEnrolmentEvaluationWithResponsibleForGrade . newInfoFromDomain ( enrolment . getLatestEnrolmentEvaluation ( ) ) ;
int count = 0 ; for ( int i = 0 ; i < m_units . size ( ) ; i ++ ) { Unit current = m_units . get ( i ) ; if ( current . getOwner ( ) . equals ( owner ) ) count ++ ; } return count ; <CTX> public int getUnitCount ( PlayerID owner ) { int count = 0 ; for ( int i = 0 ; i < m_units . size ( ) ; i ++ ) { Unit current = m_units . get ( i ) ; if ( current . getOwner ( ) . equals ( owner ) ) count ++ ; } return count ; }	return m_units . size ( ) ;
getImpl ( ) . handleArtifactSent ( sentBy , sentOn , containerUniqueId , containerVersionId , containerName , artifactUniqueId , artifactVersionId , artifactName , artifactType , artifactChecksum , artifactBytes ) ; <CTX> public void handleArtifactSent ( final JabberId sentBy , final Calendar sentOn , final UUID containerUniqueId , final Long containerVersionId , final String containerName , final UUID artifactUniqueId , final Long artifactVersionId , final String artifactName , final ArtifactType artifactType , final String artifactChecksum , final byte [ ] artifactBytes ) { synchronized ( getImplLock ( ) ) { getImpl ( ) . handleArtifactSent ( sentBy , sentOn , containerUniqueId , containerVersionId , containerName , artifactUniqueId , artifactVersionId , artifactName , artifactType , artifactChecksum , artifactBytes ) ; } }	getImpl ( ) . handleArtifactSent ( uniqueId , versionId , name , artifactUniqueId , artifactVersionId , artifactName , artifactType , artifactChecksum , artifactBytes , sentBy , sentOn ) ;
void setMaxRows ( int max ) throws SQLException ; <CTX> void setMaxRows ( int max ) throws SQLException ;	void setMaxRows ( int maxRows ) throws SQLException ;
switch ( eDerivedStructuralFeatureID ( eFeature ) ) <CTX> public void eSet ( EStructuralFeature eFeature , Object newValue ) { switch ( eDerivedStructuralFeatureID ( eFeature ) ) { case AttributePackage . IMAGE__ TYPE : setType ( ( ( Integer ) newValue ) . intValue ( ) ) ; return ; case AttributePackage . IMAGE__ URL : setURL ( ( String ) newValue ) ; return ; } eDynamicSet ( eFeature , newValue ) ; }	switch ( featureID )
if ( dirName . length ( ) == 0 ) dirName = previouslyBrowsedDirectory ; <CTX> private void handleLocationBrowseButtonPressed ( ) { DirectoryDialog dialog = new DirectoryDialog ( locationPathField . getShell ( ) ) ; dialog . setMessage ( DataTransferMessages . WizardExternalProjectImportPage_directoryLabel ) ; String dirName = getProjectLocationFieldValue ( ) ; if ( dirName . length ( ) == 0 ) dirName = previouslyBrowsedDirectory ; if ( dirName . length ( ) == 0 ) dialog . setFilterPath ( getWorkspace ( ) . getRoot ( ) . getLocation ( ) . toOSString ( ) ) ; else { File path = new File ( dirName ) ; if ( path . exists ( ) ) dialog . setFilterPath ( new Path ( dirName ) . toOSString ( ) ) ; } String selectedDirectory = dialog . open ( ) ; if ( selectedDirectory != null ) { previouslyBrowsedDirectory = selectedDirectory ; locationPathField . setText ( previouslyBrowsedDirectory ) ; setProjectName ( projectFile ( previouslyBrowsedDirectory ) ) ; } }	if ( dirName . length ( ) == 0 ) { dirName = previouslyBrowsedDirectory ; }
return Util . equals ( this . window , that . window ) ; <CTX> public boolean equals ( final Object object ) { if ( object instanceof WorkbenchWindowExpression ) { final WorkbenchWindowExpression that = ( WorkbenchWindowExpression ) object ; return Util . equals ( this . window , that . window ) ; } return false ; }	return equals ( this . window , that . window ) ;
void changeTask ( ) ; <CTX> void changeTask ( ) ;	void changeTask ( Notification notification ) ;
i = ( Integer ) it . next ( ) ; cachedResultSet [ cachedResultSetRowNo ] [ i . intValue ( ) ] = cachedColumns . get ( i ) . toString ( ) ; <CTX> private void populateNestedXMLDataMappingColumns ( ) { if ( ! isNotNestedXMLTable ) { Iterator it = cachedColumns . keySet ( ) . iterator ( ) ; Integer i = null ; while ( it . hasNext ( ) ) { i = ( Integer ) it . next ( ) ; cachedResultSet [ cachedResultSetRowNo ] [ i . intValue ( ) ] = cachedColumns . get ( i ) . toString ( ) ; } } }	for ( int j = 0 ; j < namesOfColumns . length ; j ++ ) { if ( namesOfCachedColumns [ i ] . equals ( namesOfColumns [ j ] ) ) { cachedResultSet [ cachedResultSetRowNo ] [ j ] = this . spNestedQueryHelper . getNestedColumnValue ( namesOfCachedColumns [ i ] , path ) ; } }
return ArgsUtil . arrayify ( begin ( node ) ) ; <CTX> private IRubyObject [ ] setupArgs ( IRuby runtime , ThreadContext context , Node node ) { if ( node == null ) { return IRubyObject . NULL_ARRAY ; } if ( node instanceof ArrayNode ) { ISourcePosition position = context . getPosition ( ) ; ArrayList list = new ArrayList ( ( ( ArrayNode ) node ) . size ( ) ) ; for ( Iterator iter = ( ( ArrayNode ) node ) . iterator ( ) ; iter . hasNext ( ) ; ) { final Node next = ( Node ) iter . next ( ) ; if ( next instanceof SplatNode ) { list . addAll ( ( ( RubyArray ) begin ( next ) ) . getList ( ) ) ; } else { list . add ( begin ( next ) ) ; } } context . setPosition ( position ) ; return ( IRubyObject [ ] ) list . toArray ( new IRubyObject [ list . size ( ) ] ) ; } return ArgsUtil . arrayify ( begin ( node ) ) ; }	return ArgsUtil . arrayify ( eval ( context , node , self ) ) ;
if ( mi instanceof InterTypeMemberInstance ) methods . add ( mi . container ( cd . type ( ) ) . flags ( ( ( InterTypeMemberInstance ) mi ) . origFlags ( ) ) ) ; <CTX> public NodeVisitor enter ( Node n ) { if ( n instanceof ClassDecl ) { ClassDecl cd = ( ClassDecl ) n ; List methods = cd . type ( ) . methods ( ) ; List fields = cd . type ( ) . fields ( ) ; List constructors = cd . type ( ) . constructors ( ) ; for ( Iterator inIt = cd . type ( ) . interfaces ( ) . iterator ( ) ; inIt . hasNext ( ) ; ) { ClassType interf = ( ( ClassType ) inIt . next ( ) ) ; for ( Iterator mit = interf . methods ( ) . iterator ( ) ; mit . hasNext ( ) ; ) { MethodInstance mi = ( MethodInstance ) mit . next ( ) ; if ( mi instanceof InterTypeMemberInstance ) methods . add ( mi . container ( cd . type ( ) ) . flags ( ( ( InterTypeMemberInstance ) mi ) . origFlags ( ) ) ) ; } for ( Iterator fit = interf . fields ( ) . iterator ( ) ; fit . hasNext ( ) ; ) { FieldInstance fi = ( FieldInstance ) fit . next ( ) ; if ( fi instanceof InterTypeMemberInstance ) fields . add ( fi ) ; } for ( Iterator cit = interf . constructors ( ) . iterator ( ) ; cit . hasNext ( ) ; ) { ConstructorInstance ci = ( ConstructorInstance ) cit . next ( ) ; if ( ci instanceof InterTypeMemberInstance ) constructors . add ( ci . container ( cd . type ( ) ) ) ; } } } return this ; }	if ( mi instanceof InterTypeMemberInstance ) { abc . aspectj . ast . IntertypeMethodDecl_c . overrideITDmethod ( cd . type ( ) , mi . container ( cd . type ( ) ) . flags ( ( ( InterTypeMemberInstance ) mi ) . origFlags ( ) ) ) ; }
String handle = TaskRepositoryManager . getHandle ( bugReport . getRepositoryUrl ( ) , bugReport . getId ( ) ) ; <CTX> private void internalSubmitBugReport ( IBugzillaBug bugReport , BugzillaReportSubmitForm form ) { try { form . submitReportToRepository ( ) ; removeReport ( bugReport ) ; String handle = TaskRepositoryManager . getHandle ( bugReport . getRepositoryUrl ( ) , bugReport . getId ( ) ) ; ITask task = MylarTaskListPlugin . getTaskListManager ( ) . getTaskForHandle ( handle , false ) ; synchronize ( task , true , null ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }	String handle = AbstractRepositoryTask . getHandle ( bugReport . getRepositoryUrl ( ) , bugReport . getId ( ) ) ;
else { dtm . removeRow ( angebotNr ) ; <CTX> public void insertAngebot ( Angebot angebot , int angebotNr ) { DefaultTableModel dtm = ( DefaultTableModel ) tableAngebote . getModel ( ) ; Object [ ] o = { new Integer ( dtm . getRowCount ( ) + 1 ) , angebot , angebot . getDatum ( ) , new Float ( angebot . getSumme ( ) ) , new Boolean ( false ) } ; if ( angebotNr == - 1 ) dtm . addRow ( o ) ; else { dtm . removeRow ( angebotNr ) ; dtm . insertRow ( angebotNr , o ) ; } dtm . fireTableRowsInserted ( dtm . getRowCount ( ) , dtm . getRowCount ( ) ) ; }	} else { Object [ ] o = { new Integer ( angebotNr + 1 ) , angebot , angebot . getDatum ( ) , new Float ( angebot . getSumme ( ) ) , new Boolean ( false ) } ;
if ( isDelete ( ) ) { HandleAdapterFactory . getInstance ( ) . remove ( getModel ( ) ) ; } <CTX> public void deactivate ( ) { if ( ! isActive ( ) ) return ; removeGuideFeedBack ( ) ; super . deactivate ( ) ; if ( isDelete ( ) ) { HandleAdapterFactory . getInstance ( ) . remove ( getModel ( ) ) ; } }	HandleAdapterFactory . getInstance ( ) . remove ( getModel ( ) ) ;
if ( index > 0 ) { <CTX> public void backward ( ) { if ( index > 0 ) { index -- ; gotoEntry ( ) ; enableActions ( ) ; } }	IEditorPart editor = page . getActiveEditor ( ) ; boolean activateEditor = editor != null && editor != page . getActivePart ( ) ; if ( activateEditor ) { NavigationHistoryEntry e = new NavigationHistoryEntry ( ) ; e . part = editor ; gotoEntry ( e ) ; } else if ( index > 0 ) {
} } <CTX> private void populateList ( ) { try { this . okButton . setEnabled ( false ) ; / / Execute the query and populate this list BaseQueryDefinition query = ( BaseQueryDefinition ) DataSetManager . getCurrentInstance ( ) . getPreparedQuery ( getDataSetHandle ( ) , true , false ) . getReportQueryDefn ( ) ; ScriptExpression expression = new ScriptExpression ( getExpression ( ) ) ; GroupDefinition defn = new GroupDefinition ( ) ; defn . setKeyExpression ( getExpression ( ) ) ; query . setUsesDetails ( false ) ; query . addGroup ( defn ) ; query . addExpression ( expression , BaseTransform . BEFORE_FIRST_ROW ) ; IPreparedQuery preparedQuery = DataSetManager . getCurrentInstance ( ) . getEngine ( ) . prepare ( ( IQueryDefinition ) query ) ; IQueryResults results = preparedQuery . execute ( null ) ; selectValueList . removeAll ( ) ; if ( results != null ) { IResultIterator iter = results . getResultIterator ( ) ; if ( iter != null ) { while ( iter . next ( ) ) { String value = iter . getString ( expression ) ; if ( value != null ) { selectValueList . add ( value ) ; } } } results . close ( ) ; } if ( selectValueList . getItemCount ( ) > 0 ) { selectValueList . select ( 0 ) ; this . okButton . setEnabled ( true ) ; } } catch ( Exception e ) { ExceptionHandler . handle ( e ) ; } }	}
double [ ] dvals = ( double [ ] ) value ; int leng = Math . min ( dvals . length , nel ) ; <CTX> void writeValue ( DataOutput stream , Object value ) throws IOException { int i = 0 ; if ( value != null ) { double [ ] dvals = ( double [ ] ) value ; int leng = Math . min ( dvals . length , nel ) ; for ( ; i < leng ; i ++ ) { stream . writeDouble ( dvals [ i ] ) ; } } for ( ; i < nel ; i ++ ) { stream . writeDouble ( PAD ) ; } }	long [ ] lvals = ( long [ ] ) value ; int leng = Math . min ( lvals . length , nel ) ;
if ( ! showIntro ) return ; <CTX> public void openIntro ( IWorkbenchWindowConfigurer configurer ) { if ( introOpened ) return ; introOpened = true ; boolean showIntro = PrefUtil . getAPIPreferenceStore ( ) . getBoolean ( IWorkbenchPreferenceConstants . SHOW_INTRO ) ; if ( ! showIntro ) return ; if ( getWorkbenchConfigurer ( ) . getWorkbench ( ) . getIntroManager ( ) . hasIntro ( ) ) { getWorkbenchConfigurer ( ) . getWorkbench ( ) . getIntroManager ( ) . showIntro ( configurer . getWindow ( ) , false ) ; PrefUtil . getAPIPreferenceStore ( ) . setValue ( IWorkbenchPreferenceConstants . SHOW_INTRO , false ) ; PrefUtil . saveAPIPrefs ( ) ; } }	if ( ! showIntro ) { return ; }
File myDir = myFile . getCanonicalFile ( ) . getParentFile ( ) ; if ( modules != null ) <CTX> public String getModulePathAdjustment ( MavenProject moduleProject ) throws IOException { File module = moduleProject . getFile ( ) ; if ( module == null ) { return null ; } module = module . getCanonicalFile ( ) ; if ( moduleFiles == null ) { moduleFiles = new HashMap ( ) ; List modules = getModules ( ) ; File myFile = getFile ( ) ; if ( myFile != null ) { File myDir = myFile . getCanonicalFile ( ) . getParentFile ( ) ; if ( modules != null ) { for ( Iterator it = modules . iterator ( ) ; it . hasNext ( ) ; ) { String modulePath = ( String ) it . next ( ) ; File moduleFile = new File ( myDir , modulePath ) . getCanonicalFile ( ) ; moduleFiles . put ( moduleFile , modulePath ) ; } } } } return ( String ) moduleFiles . get ( module ) ; }	for ( Iterator it = modules . iterator ( ) ; it . hasNext ( ) ; )
} else if ( ex instanceof WrappedException ) { Object w = ( ( WrappedException ) ex ) . unwrap ( ) ; if ( w instanceof Throwable ) { ex = w ; continue ; } break ; } else { <CTX> private static Object unwrapException ( Object ex ) { for ( ; ; ) { if ( ex instanceof JavaScriptException ) { ex = ScriptRuntime . unwrapJavaScriptException ( ( JavaScriptException ) ex ) ; } else if ( ex instanceof EcmaError ) { ex = ( ( EcmaError ) ex ) . getErrorObject ( ) ; } else if ( ex instanceof NativeJavaObject ) { ex = ( ( NativeJavaObject ) ex ) . unwrap ( ) ; break ; } else if ( ex instanceof WrappedException ) { Object w = ( ( WrappedException ) ex ) . unwrap ( ) ; if ( w instanceof Throwable ) { ex = w ; continue ; } break ; } else { break ; } } return ex ; }	} else if ( ex instanceof WrappedException ) { ex = ( ( WrappedException ) ex ) . getWrappedException ( ) ; continue ; } else {
Double o 0 = getDoubleArg ( evaluator , args , 0 ) ; <CTX> public Object evaluate ( Evaluator evaluator , Exp [ ] args ) { Double o 0 = getDoubleArg ( evaluator , args , 0 ) ; return new Double ( - o 0 . doubleValue ( ) ) ; }	Double o 0 = getDoubleArg ( evaluator , args , 0 , null ) ; if ( o 0 == null ) return null ;
sql = escapeSql ( sql ) ; <CTX> public boolean execute ( String sql ) throws SQLException { if ( escapeProcessing ) sql = escapeSql ( sql ) ; result = connection . ExecSQL ( sql ) ; return ( result != null && ( ( org . postgresql . ResultSet ) result ) . reallyResultSet ( ) ) ; }	sql = escapeSQL ( sql ) ;
Object removed = fHistory . remove ( key ) ; <CTX> public synchronized Object removeKey ( Object key ) { Object removed = fHistory . remove ( key ) ; rebuildPositions ( ) ; return removed ; }	Object removed = history . remove ( key ) ;
( ( RubyModule ) state . begin ( iVisited . getPathNode ( ) ) ) . defineConstant ( iVisited . getName ( ) , value ) ; <CTX> public Instruction visitConstDeclNode ( ConstDeclNode iVisited ) { if ( iVisited . getPathNode ( ) == null ) { state . getThreadContext ( ) . getRubyClass ( ) . defineConstant ( iVisited . getName ( ) , value ) ; } else { ( ( RubyModule ) state . begin ( iVisited . getPathNode ( ) ) ) . defineConstant ( iVisited . getName ( ) , value ) ; } return null ; }	( ( RubyModule ) EvaluationState . eval ( runtime . getCurrentContext ( ) , iVisited . getPathNode ( ) , runtime . getCurrentContext ( ) . getFrameSelf ( ) ) ) . defineConstant ( iVisited . getName ( ) , value ) ;
return Node . createList ( optArgs , blockArgNode ) ; <CTX> public List childNodes ( ) { return Node . createList ( optArgs , blockArgNode ) ; }	return Node . createList ( arguments , optArgs , blockArgNode ) ;
continue ; <CTX> public Iterator < E > iterator ( ) { return new Iterator < E > ( ) { int index = - 1 ; int count = 0 ; public boolean hasNext ( ) { return count < used ; } public E next ( ) { while ( storage [ ++ index ] == null ) continue ; ++ count ; return storage [ index ] ; } public void remove ( ) { PriorityQueue . this . remove ( index ) ; } } ; }	;
if ( ! isTag ( ) || m_attrList == null ) <CTX> public String getAttribute ( String name ) { if ( ! isTag ( ) || m_attrList == null ) return null ; XMLAttribute attr = null ; for ( int i = 0 ; i < m_attrList . size ( ) ; i ++ ) { attr = ( XMLAttribute ) m_attrList . get ( i ) ; if ( attr . name . equals ( name ) ) break ; else attr = null ; } if ( attr == null ) return null ; else return attr . value ; }	if ( n < 0 || ! isTag ( ) || m_attrList == null || n > m_attrList . size ( ) ) {
return methodToParents . getParentList ( method ) ; <CTX> public synchronized List < Member > getMembersWithMethodAsList ( String method ) { return methodToParents . getParentList ( method ) ; }	return new ArrayList < Member > ( methodToParents . getParentList ( method ) ) ;
return MessageFormat . format ( messageFormat , parameters ) ; <CTX> public String getMessage ( ) { return MessageFormat . format ( messageFormat , parameters ) ; }	return MessageFormat . format ( MessageFormat . autoQuoteApostrophe ( messageFormat ) , parameters ) ;
return new SubscriptionIterator ( this . subscriptions ) ; <CTX> public SubscriptionIterator iterator ( ) { return new SubscriptionIterator ( this . subscriptions ) ; }	return new SubscriptionIterator ( this . subscriptions , this . proxyHost , this . proxyPort ) ;
contextListeners = ListenerArray . remove ( contextListeners , listener ) ; <CTX> public static void removeContextListener ( ContextListener listener ) { synchronized ( contextListenersLock ) { contextListeners = ListenerArray . remove ( contextListeners , listener ) ; } }	contextListeners = Kit . removeListener ( contextListeners , listener ) ;
return UsageInfo . EMPTY_ARRAY ; <CTX> protected UsageInfo [ ] findUsages ( ) { return UsageInfo . EMPTY_ARRAY ; }	return myChangeSingleUsageSignature ? super . findUsages ( ) : UsageInfo . EMPTY_ARRAY ;
activityId = SecurityConstants . CIENT_REMOVE_FEE_TYPE_FROM_CLIENT_ACCOUNT ; <CTX> private short getActivityIdForApplyCharges ( AccountTypes accountTypes , CustomerLevel customerLevel ) { short activityId = - 1 ; if ( accountTypes . equals ( AccountTypes . LOANACCOUNT ) ) activityId = SecurityConstants . LOAN_REMOVE_FEE_TYPE_ATTACHED_TO_ACCOUNT ; else if ( accountTypes . equals ( AccountTypes . CUSTOMERACCOUNT ) ) { if ( customerLevel . equals ( CustomerLevel . CENTER ) ) activityId = SecurityConstants . CENTER_REMOVE_FEE_TYPE_FROM_CENTER_ACCOUNT ; else if ( customerLevel . equals ( CustomerLevel . GROUP ) ) activityId = SecurityConstants . GROUP_REMOVE_FEE_TYPE_FROM_GROUP_ACCOUNT ; else if ( customerLevel . equals ( CustomerLevel . CLIENT ) ) activityId = SecurityConstants . CIENT_REMOVE_FEE_TYPE_FROM_CLIENT_ACCOUNT ; } return activityId ; }	activityId = SecurityConstants . CLIENT_CAN_APPLY_CHARGES ;
if ( result < 0 ) { return getRuntime ( ) . getNil ( ) ; } return RubyFixnum . newFixnum ( getRuntime ( ) , result ) ; <CTX> public IRubyObject match ( IRubyObject target ) { if ( target . isNil ( ) ) { return getRuntime ( ) . getFalse ( ) ; } int result = search ( target , 0 ) ; if ( result < 0 ) { return getRuntime ( ) . getNil ( ) ; } return RubyFixnum . newFixnum ( getRuntime ( ) , result ) ; }	return result < 0 ? getRuntime ( ) . getNil ( ) : RubyFixnum . newFixnum ( getRuntime ( ) , result ) ;
resetAction . setChecked ( true ) ; <CTX> private void createStyleMenu ( IMenuManager menuManager , String group_name ) { MenuManager menu = new MenuManager ( STYLE_MENU_ITEM_TEXT ) ; MenuManager subMenu = new MenuManager ( APPLY_STYLE_MENU_ITEM_TEXT ) ; SharedStyleHandle oldStyle = getStyleHandle ( ) ; ApplyStyleAction resetAction = new ApplyStyleAction ( null ) ; resetAction . setSelection ( getSelection ( ) ) ; if ( oldStyle == null ) { resetAction . setChecked ( true ) ; } subMenu . add ( resetAction ) ; subMenu . add ( new Separator ( ) ) ; Iterator iter = SessionHandleAdapter . getInstance ( ) . getReportDesignHandle ( ) . getStyles ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { SharedStyleHandle handle = ( SharedStyleHandle ) iter . next ( ) ; ApplyStyleAction action = new ApplyStyleAction ( handle ) ; action . setSelection ( getSelection ( ) ) ; if ( oldStyle == handle ) { action . setChecked ( true ) ; } else { action . setChecked ( false ) ; } subMenu . add ( action ) ; } menu . add ( subMenu ) ; menu . add ( new Separator ( ) ) ; menu . add ( getAction ( AddStyleRuleAction . ID ) ) ; appendMenuToGroup ( menu , group_name , menuManager ) ; }	reset . setChecked ( true ) ;
setEnabled ( selection != null && ! selection . isEmpty ( ) ) ; } <CTX> public void selectionChanged ( IStructuredSelection selection ) { setEnabled ( selection != null && ! selection . isEmpty ( ) ) ; }	setEnabled ( hasSingleConcreteSelection ( selection ) ) ; }
errors = true ; Out . error ( f , ErrorMessages . LOOKAHEAD_ERROR , rs . getLine ( i ) , - 1 ) ; <CTX> public static void check ( RegExps rs , Macros m , char max , File f ) { macros = m ; maxChar = max ; boolean errors = false ; int num = rs . getNum ( ) ; for ( int i = 0 ; i < num ; i ++ ) { RegExp r = rs . getRegExp ( i ) ; RegExp l = rs . getLookAhead ( i ) ; if ( ! checkLookAhead ( r , l ) ) { errors = true ; Out . error ( f , ErrorMessages . LOOKAHEAD_ERROR , rs . getLine ( i ) , - 1 ) ; } } if ( errors ) throw new GeneratorException ( ) ; }	Out . warning ( f , ErrorMessages . LOOKAHEAD_ERROR , rs . getLine ( i ) , - 1 ) ;
TaskUiUtil . openEditor ( modifiedTask , false ) ; <CTX> public void done ( IJobChangeEvent event ) { close ( ) ; TaskUiUtil . openEditor ( modifiedTask , false ) ; }	TasksUiUtil . openEditor ( modifiedTask , false ) ;
result = ruby . yield ( result . toRubyObject ( ) , null , null , false ) ; <CTX> public void visitYieldNode ( YieldNode iVisited ) { eval ( iVisited . getArgsNode ( ) ) ; if ( iVisited . getArgsNode ( ) instanceof ExpandArrayNode && ( ( RubyArray ) result ) . getLength ( ) == 1 ) { result = ( ( RubyArray ) result ) . entry ( 0 ) ; } result = ruby . yield ( result . toRubyObject ( ) , null , null , false ) ; }	result = ruby . yield ( result , null , null , false ) ;
return ( TreeElement ) parent . getFirstChildNode ( ) ; } else { return ( TreeElement ) firstValid . getTreeNext ( ) ; <CTX> private static TreeElement returnFirstChangedNode ( final List < ASTNode > treePrev , final CompositeElement parent ) { if ( treePrev == null ) { return ( TreeElement ) parent . getFirstChildNode ( ) ; } else { ASTNode firstValid = findFirstValid ( treePrev ) ; if ( firstValid == null ) { return ( TreeElement ) parent . getFirstChildNode ( ) ; } else { return ( TreeElement ) firstValid . getTreeNext ( ) ; } } }	return parent . getFirstChildNode ( ) ; } else { return ( TreeElement ) firstValid . getTreeNext ( ) ;
static protected boolean matchTemplateParameterAndArgument ( ICPPTemplateParameter param , IType argument ) { <CTX> static protected boolean matchTemplateParameterAndArgument ( ICPPTemplateParameter param , IType argument ) { if ( ! isValidArgument ( param , argument ) ) { return false ; } if ( param instanceof ICPPTemplateTypeParameter ) return true ; else if ( param instanceof ICPPTemplateTemplateParameter ) { if ( ! ( argument instanceof ICPPTemplateDefinition ) ) return false ; ICPPTemplateParameter [ ] pParams = null , aParams = null ; try { pParams = ( ( ICPPTemplateTemplateParameter ) param ) . getTemplateParameters ( ) ; aParams = ( ( ICPPTemplateDefinition ) argument ) . getTemplateParameters ( ) ; } catch ( DOMException e ) { return false ; } int size = pParams . length ; if ( aParams . length != size ) { return false ; } for ( int i = 0 ; i < size ; i ++ ) { if ( ( pParams [ i ] instanceof ICPPTemplateTypeParameter && ! ( aParams [ i ] instanceof ICPPTemplateTypeParameter ) ) || ( pParams [ i ] instanceof ICPPTemplateTemplateParameter && ! ( aParams [ i ] instanceof ICPPTemplateTemplateParameter ) ) || ( pParams [ i ] instanceof ICPPTemplateNonTypeParameter && ! ( aParams [ i ] instanceof ICPPTemplateNonTypeParameter ) ) ) { return false ; } } return true ; } else { try { IType pType = ( ( ICPPTemplateNonTypeParameter ) param ) . getType ( ) ; Cost cost = CPPSemantics . checkStandardConversionSequence ( argument , pType ) ; if ( cost == null || cost . rank == Cost . NO_MATCH_RANK ) { return false ; } } catch ( DOMException e ) { return false ; } } return true ; }	static protected boolean matchTemplateParameterAndArgument ( ICPPTemplateParameter param , IType argument , ObjectMap map ) {
return RubyFixnum . newFixnum ( getRuntime ( ) , - 1 ) ; <CTX> public IRubyObject infinite_p ( ) { if ( getValue ( ) == Double . POSITIVE_INFINITY ) { return RubyFixnum . newFixnum ( getRuntime ( ) , 1 ) ; } else if ( getValue ( ) == Double . NEGATIVE_INFINITY ) { return RubyFixnum . newFixnum ( getRuntime ( ) , - 1 ) ; } else { return getRuntime ( ) . getNil ( ) ; } }	return getRuntime ( ) . newFixnum ( - 1 ) ;
if ( addingConnection ) <CTX> public void mouseDragged ( NSEvent theEvent ) { NSPoint point = convertPointFromView ( theEvent . locationInWindow ( ) , null ) ; if ( addingConnection ) { endPoint = point ; draggingConnection = true ; setNeedsDisplay ( true ) ; } else { rdfAuthorDocument . moveCurrentObjectToPoint ( point ) ; } }	switch ( currentEditingMode )
stack [ stackTop ] = DBL_MRK ; <CTX> private static void do_add ( Object [ ] stack , double [ ] sDbl , int stackTop , Context cx ) { Object rhs = stack [ stackTop + 1 ] ; Object lhs = stack [ stackTop ] ; double d ; boolean leftRightOrder ; if ( rhs == DBL_MRK ) { d = sDbl [ stackTop + 1 ] ; if ( lhs == DBL_MRK ) { sDbl [ stackTop ] += d ; return ; } leftRightOrder = true ; / / fallthrough to object + number code } else if ( lhs == DBL_MRK ) { d = sDbl [ stackTop ] ; lhs = rhs ; leftRightOrder = false ; / / fallthrough to object + number code } else { if ( lhs instanceof Scriptable || rhs instanceof Scriptable ) { stack [ stackTop ] = ScriptRuntime . add ( lhs , rhs , cx ) ; } else if ( lhs instanceof String ) { String lstr = ( String ) lhs ; String rstr = ScriptRuntime . toString ( rhs ) ; stack [ stackTop ] = lstr . concat ( rstr ) ; } else if ( rhs instanceof String ) { String lstr = ScriptRuntime . toString ( lhs ) ; String rstr = ( String ) rhs ; stack [ stackTop ] = lstr . concat ( rstr ) ; } else { double lDbl = ( lhs instanceof Number ) ? ( ( Number ) lhs ) . doubleValue ( ) : ScriptRuntime . toNumber ( lhs ) ; double rDbl = ( rhs instanceof Number ) ? ( ( Number ) rhs ) . doubleValue ( ) : ScriptRuntime . toNumber ( rhs ) ; stack [ stackTop ] = DBL_MRK ; sDbl [ stackTop ] = lDbl + rDbl ; } return ; } / / handle object ( lhs ) + number ( d ) code if ( lhs instanceof Scriptable ) { rhs = ScriptRuntime . wrapNumber ( d ) ; if ( ! leftRightOrder ) { Object tmp = lhs ; lhs = rhs ; rhs = tmp ; } stack [ stackTop ] = ScriptRuntime . add ( lhs , rhs , cx ) ; } else if ( lhs instanceof String ) { String lstr = ( String ) lhs ; String rstr = ScriptRuntime . toString ( d ) ; if ( leftRightOrder ) { stack [ stackTop ] = lstr . concat ( rstr ) ; } else { stack [ stackTop ] = rstr . concat ( lstr ) ; } } else { double lDbl = ( lhs instanceof Number ) ? ( ( Number ) lhs ) . doubleValue ( ) : ScriptRuntime . toNumber ( lhs ) ; stack [ stackTop ] = DBL_MRK ; sDbl [ stackTop ] = lDbl + d ; } }	stack [ stackTop ] = UniqueTag . DOUBLE_MARK ;
TransformerImpl ti = getTransformer ( ) ; if ( null != ti ) { Exception e = ti . getExceptionThrown ( ) ; if ( null != e ) throwParseError ( e ) ; } <CTX> protected void throwIfParseError ( ) { TransformerImpl ti = getTransformer ( ) ; if ( null != ti ) { Exception e = ti . getExceptionThrown ( ) ; if ( null != e ) throwParseError ( e ) ; } }	if ( null != m_doc . m_exceptionThrown ) throwParseError ( m_doc . m_exceptionThrown ) ;
initCopy ( newObj ) ; <CTX> public IRubyObject rbClone ( ) { RubyRegexp newObj = new RubyRegexp ( getRuntime ( ) ) ; newObj . pattern = pattern ; newObj . code = code ; initCopy ( newObj ) ; return newObj ; }	newObj . setTaint ( isTaint ( ) ) ; newObj . initCopy ( this ) ; newObj . setFrozen ( isFrozen ( ) ) ;
Set < TaskRepository > repositories = MylarTaskListPlugin . getRepositoryManager ( ) . getRepositories ( REPOSITORY_KIND ) ; <CTX> public void start ( BundleContext context ) throws Exception { super . start ( context ) ; plugin = this ; authenticator = UpdateUI . getDefault ( ) . getAuthenticator ( ) ; if ( authenticator == null ) { authenticator = new BugzillaAuthenticator ( ) ; } Authenticator . setDefault ( authenticator ) ; setDefaultQueryOptions ( ) ; readFavoritesFile ( ) ; readOfflineReportsFile ( ) ; Set < TaskRepository > repositories = MylarTaskListPlugin . getRepositoryManager ( ) . getRepositories ( REPOSITORY_KIND ) ; for ( TaskRepository repository : repositories ) { readCachedProductConfiguration ( repository . getUrl ( ) . toExternalForm ( ) ) ; } }	final Set < TaskRepository > repositories = MylarTaskListPlugin . getRepositoryManager ( ) . getRepositories ( REPOSITORY_KIND ) ;
_ notifyScreenLineChanges ( ) ; <CTX> public void collapseFold ( int line ) { int lineCount = buffer . getLineCount ( ) ; int start = 0 ; int end = lineCount - 1 ; / / if the caret is on a collapsed fold , collapse the / / parent fold if ( line != 0 && line != buffer . getLineCount ( ) - 1 && buffer . isFoldStart ( line ) && ! isLineVisible ( line + 1 ) ) { line -- ; } int initialFoldLevel = buffer . getFoldLevel ( line ) ; / / { { { Find fold start and end . . . if ( line != lineCount - 1 && buffer . getFoldLevel ( line + 1 ) > initialFoldLevel ) { / / this line is the start of a fold start = line + 1 ; for ( int i = line + 1 ; i < lineCount ; i ++ ) { if ( buffer . getFoldLevel ( i ) <= initialFoldLevel ) { end = i - 1 ; break ; } } } else { boolean ok = false ; / / scan backwards looking for the start for ( int i = line - 1 ; i >= 0 ; i -- ) { if ( buffer . getFoldLevel ( i ) < initialFoldLevel ) { start = i + 1 ; ok = true ; break ; } } if ( ! ok ) { / / no folds in buffer return ; } for ( int i = line + 1 ; i < lineCount ; i ++ ) { if ( buffer . getFoldLevel ( i ) < initialFoldLevel ) { end = i - 1 ; break ; } } } / / } } } / / Collapse the fold . . . hideLineRange ( start , end ) ;_notifyScreenLineChanges ( ) ; textArea . foldStructureChanged ( ) ; } / / } } }	notifyScreenLineChanges ( ) ;
if ( element . getElementType ( ) == IJavaElement . COMPILATION_UNIT ) return ( ICompilationUnit ) element ; if ( element instanceof IMember ) return ( ( IMember ) element ) . getCompilationUnit ( ) ; return findCompilationUnit ( element . getParent ( ) ) ; <CTX> static ICompilationUnit findCompilationUnit ( IJavaElement element ) { if ( element == null ) return null ; if ( element . getElementType ( ) == IJavaElement . COMPILATION_UNIT ) return ( ICompilationUnit ) element ; if ( element instanceof IMember ) return ( ( IMember ) element ) . getCompilationUnit ( ) ; return findCompilationUnit ( element . getParent ( ) ) ; }	return ( ICompilationUnit ) element . getAncestor ( IJavaElement . COMPILATION_UNIT ) ;
request . run ( ) ; <CTX> public void run ( ) { synchronized ( LOCK ) { myOriginalToThreadRequestMap . remove ( request ) ; } try { request . run ( ) ; } catch ( Throwable e ) { LOG . error ( e ) ; } }	if ( ! myDisposed ) { request . run ( ) ; }
save ( o ) ; <CTX> public void restoreUserInfo ( BwUserInfo o ) throws Throwable { if ( globals . onlyUsers && ( globals . onlyUsersMap . get ( o . getUser ( ) . getAccount ( ) ) == null ) ) { return ; } openSess ( ) ; save ( o ) ; closeSess ( ) ; }	hibSave ( o ) ;
exactTypeSet . or ( ( ( TypeFrame ) other_) . exactTypeSet ) ; <CTX> public void copyFrom ( Frame < Type > other_) { clearExactSet ( ) ; exactTypeSet . or ( ( ( TypeFrame ) other_) . exactTypeSet ) ; super . copyFrom ( other_) ; }	TypeFrame other = ( TypeFrame ) other_; this . exactTypeSet . or ( other . exactTypeSet ) ; this . instanceOfType = other . instanceOfType ; this . instanceOfValueNumber = other . instanceOfValueNumber ;
execute ( Collections . singletonList ( project ) , goals , eventMonitor , transferListener , executionRootDirectory ) ; <CTX> public void execute ( MavenProject project , List goals , EventMonitor eventMonitor , TransferListener transferListener , File executionRootDirectory ) throws CycleDetectedException , LifecycleExecutionException , MojoExecutionException { execute ( Collections . singletonList ( project ) , goals , eventMonitor , transferListener , executionRootDirectory ) ; }	execute ( Collections . singletonList ( project ) , goals , eventMonitor , transferListener , properties , executionRootDirectory ) ;
overlay . notifyListeners ( new TransformEvent ( text ) ) ; <CTX> public void mouseDrag ( float x , float y , int [ ] pos , int mods ) { if ( text == null ) return ; text . setCoords ( x , y ) ; overlay . notifyListeners ( new TransformEvent ( text ) ) ; }	overlay . notifyListeners ( new TransformEvent ( overlay ) ) ;
this ( constraintId , indexId ) ; this . keyConstraintId = keyConstraintId ; this . raDeleteRule = raDeleteRule ; this . raUpdateRule = raUpdateRule ; <CTX> public SubKeyConstraintDescriptor ( UUID constraintId , UUID indexId , UUID keyConstraintId , int raDeleteRule , int raUpdateRule ) { this ( constraintId , indexId ) ; this . keyConstraintId = keyConstraintId ; this . raDeleteRule = raDeleteRule ; this . raUpdateRule = raUpdateRule ; }	super ( constraintId ) ; this . indexId = indexId ;
e . printStackTrace ( ) ; <CTX> private Buffer TSnewFile ( ) { final Buffer [ ] retVal = new Buffer [ 1 ] ; try { SwingUtilities . invokeAndWait ( new Runnable ( ) { public void run ( ) { retVal [ 0 ] = jEdit . newFile ( null ) ; } } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return retVal [ 0 ] ; }	Log . log ( Log . ERROR , this , e ) ;
IContentEmitter emitter , IRowData rowData ) ; <CTX> abstract protected void accessHeader ( ListingDesign list , IContentEmitter emitter , IRowData rowData ) ;	IContentEmitter emitter , IResultIterator rsIterator ) ;
Map ret = metric . getKerningInfo ( ) ; if ( ret != null ) { return ret ; <CTX> public Map getKerning ( ) { Map ret = metric . getKerningInfo ( ) ; if ( ret != null ) { return ret ; } else { return java . util . Collections . EMPTY_MAP ; } }	if ( metric . hasKerningInfo ( ) ) { return metric . getKerningInfo ( ) ;
targetList . dispose ( ) ; modelList . dispose ( ) ; disposed = true ; <CTX> public void dispose ( ) { targetList . removeListChangeListener ( targetChangeListener ) ; modelList . removeListChangeListener ( modelChangeListener ) ; targetList . dispose ( ) ; modelList . dispose ( ) ; disposed = true ; }	super . dispose ( ) ;
docDecl . DIAG_BAD_TAGNAME_WRAPUP , sti . qName , <CTX> private final String diagnoseBadTagName ( StartTagInfo sti ) { final CombinedChildContentExpCreator cccc = docDecl . cccec ; / / try creating combined child content pattern without tag name check . Expression r = cccc . get ( expression , sti , false ) . content ; if ( r == Expression . nullSet ) / / no element is allowed here at all . return docDecl . localizeMessage ( docDecl . DIAG_ELEMENT_NOT_ALLOWED , sti . qName ) ; if ( cccc . isComplex ( ) ) { / / probably < concur > is used . / / there is no easy way to tell which what tag name is expected . / / TODO : we can reduce strength by treating concur as choice . / / do it . return null ; } / / we are now sure that combined child content expression will be / / the choice of all elements of concern . / / so if tag name satisfies one of those elements , / / it can be accepted . / / therefore we can provide candidates for users . Set s = new java . util . HashSet ( ) ; boolean more = false ; / / if there is a SimpleNameClass with the same localName / / but with a different namespace URI , / / this variable will receive that URI . String wrongNamespace = null ; final ElementExp [ ] eocs = cccc . getMatchedElements ( ) ; final int len = cccc . numMatchedElements ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( eocs [ i ] . contentModel . getExpandedExp ( docDecl . pool ) == Expression . nullSet ) / / this element is not allowed to appear . continue ; / / test some typical name class patterns . final NameClass nc = eocs [ i ] . getNameClass ( ) ; if ( nc instanceof SimpleNameClass ) { SimpleNameClass snc = ( SimpleNameClass ) nc ; if ( snc . localName . equals ( sti . localName ) ) { / / sometimes , people simply forget to add namespace decl , / / or declare the wrong name . wrongNamespace = snc . namespaceURI ; } s . add ( docDecl . localizeMessage ( docDecl . DIAG_SIMPLE_NAMECLASS , nc . toString ( ) ) ) ; continue ; } if ( nc instanceof NamespaceNameClass ) { s . add ( docDecl . localizeMessage ( docDecl . DIAG_NAMESPACE_NAMECLASS , ( ( NamespaceNameClass ) nc ) . namespaceURI ) ) ; continue ; } if ( nc instanceof NotNameClass ) { NameClass ncc = ( ( NotNameClass ) nc ) . child ; if ( ncc instanceof NamespaceNameClass ) { s . add ( docDecl . localizeMessage ( docDecl . DIAG_NOT_NAMESPACE_NAMECLASS , ( ( NamespaceNameClass ) ncc ) . namespaceURI ) ) ; continue ; } } / / this name class is very complex and / / therefore we were unable to provide appropriate suggestion . more = true ; } / / no candidate was collected . bail out . if ( s . size ( ) == 0 ) return null ; if ( wrongNamespace != null ) { if ( s . size ( ) == 1 ) / / only one candidate . return docDecl . localizeMessage ( docDecl . DIAG_BAD_TAGNAME_WRONG_NAMESPACE , sti . localName , wrongNamespace ) ; else / / probably wrong namespace , / / but show the user that he / she has other choices . return docDecl . localizeMessage ( docDecl . DIAG_BAD_TAGNAME_PROBABLY_WRONG_NAMESPACE , sti . localName , wrongNamespace ) ; } / / there is no clue about user s intention . return docDecl . localizeMessage ( docDecl . DIAG_BAD_TAGNAME_WRAPUP , sti . qName , concatenateMessages ( s , more , docDecl . DIAG_BAD_TAGNAME_SEPARATOR , docDecl . DIAG_BAD_TAGNAME_MORE ) ) ; }	REDocumentDeclaration . DIAG_BAD_TAGNAME_WRAPUP , sti . qName ,
int index = logicalView . getViewIndex ( startOffset , Position . Bias . Forward ) ; View retVal = null ; if ( index >= 0 ) { retVal = logicalView . getView ( index ) ; <CTX> protected View createView ( FlowView fv , int startOffset , int spanLeft , int rowIndex ) { View logicalView = getLogicalView ( fv ) ; / / FIXME : Handle the bias thing correctly . int index = logicalView . getViewIndex ( startOffset , Position . Bias . Forward ) ; View retVal = null ; if ( index >= 0 ) { retVal = logicalView . getView ( index ) ; if ( retVal . getStartOffset ( ) != startOffset ) retVal = retVal . createFragment ( startOffset , retVal . getEndOffset ( ) ) ; } return retVal ; }	int index = logicalView . getViewIndex ( startOffset , Position . Bias . Forward ) ; View retVal = logicalView . getView ( index ) ;
header . getModel ( ) . getUnderlyingResource ( ) , target ) } ; <CTX> public IHyperlink [ ] detectHyperlinks ( ITextViewer textViewer , IRegion region , boolean canShowMultipleHyperlinks ) { if ( region == null || canShowMultipleHyperlinks ) return null ; IDocumentRange element = fSourcePage . getRangeElement ( region . getOffset ( ) ) ; if ( ! ( element instanceof ManifestHeader ) ) return null ; ManifestHeader header = ( ManifestHeader ) element ; if ( ! header . getModel ( ) . isEditable ( ) ) return null ; if ( region . getOffset ( ) <= header . getOffset ( ) + header . getName ( ) . length ( ) ) return null ; if ( header instanceof BundleActivatorHeader ) { / / add else if statments for other headers String target = ( ( BundleActivatorHeader ) element ) . getClassName ( ) ; if ( target == null || target . length ( ) == 0 ) return null ; IDocumentRange range = BundleSourcePage . getSpecificRange ( header . getModel ( ) , header , target ) ; if ( range == null ) return null ; return new IHyperlink [ ] { new JavaHyperlink ( new Region ( range . getOffset ( ) , range . getLength ( ) ) , header . getModel ( ) . getUnderlyingResource ( ) , target ) } ; } else if ( header instanceof BasePackageHeader || header instanceof RequireBundleHeader ) { return matchLinkFor ( header , region . getOffset ( ) ) ; } return null ; }	target , header . getModel ( ) . getUnderlyingResource ( ) ) } ;
if ( ! invalid [ r ] && sent [ r ] < retries ) <CTX> send ( Message query ) throws IOException { int q , r ; Message best = null ; IOException bestException = null ; boolean [ ] invalid = new boolean [ resolvers . size ( ) ] ; byte [ ] sent = new byte [ resolvers . size ( ) ] ; Vector queue = new Vector ( ) ; Hashtable idMap = new Hashtable ( ) ; Receiver receiver = new Receiver ( queue , idMap ) ; while ( true ) { Message m ; boolean waiting = false ; QElement qe ; synchronized ( queue ) { for ( r = 0 ; r < resolvers . size ( ) ; r ++ ) { if ( sent [ r ] == 0 ) { sendTo ( query , receiver , idMap , r ) ; sent [ r ] ++ ; waiting = true ; break ; } if ( ! invalid [ r ] && sent [ r ] < retries ) waiting = true ; } if ( ! waiting ) break ; try { queue . wait ( ) ; } catch ( InterruptedException e ) { } if ( queue . size ( ) == 0 ) continue ; qe = ( QElement ) queue . firstElement ( ) ; queue . removeElement ( qe ) ; if ( qe . obj instanceof Message ) m = ( Message ) qe . obj ; else m = null ; r = qe . res ; } if ( m == null ) { IOException e = ( IOException ) qe . obj ; if ( ! ( e instanceof InterruptedIOException ) ) invalid [ r ] = true ; if ( bestException == null ) bestException = e ; } else { byte rcode = m . getHeader ( ) . getRcode ( ) ; if ( rcode == Rcode . NOERROR ) return m ; else { if ( best == null ) best = m ; else { byte bestrcode ; bestrcode = best . getHeader ( ) . getRcode ( ) ; if ( rcode == Rcode . NXDOMAIN && bestrcode != Rcode . NXDOMAIN ) best = m ; } invalid [ r ] = true ; } } } if ( best != null ) return best ; throw bestException ; }	else if ( recvd [ r ] < sent [ r ] )
return System . getProperties ( ) ; <CTX> public Object run ( ) { return System . getProperties ( ) ; }	return FrameworkProperties . getProperties ( ) ;
AddressDequeue src = cycleBufferB ; <CTX> private final void doCollectPhase ( ) { VM_Address object ; AddressDequeue src = cycleBufferB ; phase = COLLECT ; while ( ! ( object = src . pop ( ) ) . isZero ( ) ) { if ( VM_Interface . VerifyAssertions ) VM_Interface ._assert ( ! RCBaseHeader . isGreen ( object ) ) ; RCBaseHeader . clearBufferedBit ( object ) ; collectWhite ( object ) ; } }	AddressDeque src = cycleBufferB ;
JComboBox box = new JComboBox ( mEditor . getTags ( ) ) ; <CTX> protected Component createComboBox ( ) { / / Populate the box with the tags JComboBox box = new JComboBox ( mEditor . getTags ( ) ) ; / / box . setBorder ( BorderFactory . createLoweredBevelBorder ( ) ) ; box . setSelectedItem ( mEditor . getAsText ( ) ) ; box . setFont ( box . getFont ( ) . deriveFont ( Font . PLAIN ) ) ; box . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { stopCellEditing ( ) ; } } ) ; return box ; }	final JComboBox box = new JComboBox ( mEditor . getTags ( ) ) ;
if (_marginBottomOverrideSet ) { result . bottom = ( int )_marginBottomOverride ; <CTX> public Border getMarginWidth ( Context c , float parentWidth ) { Border result = c . getCurrentStyle ( ) . getMarginWidth ( parentWidth , parentWidth , c . getCtx ( ) ) ; if (_marginTopOverrideSet ) { result . top = ( int )_marginTopOverride ; } if (_marginBottomOverrideSet ) { result . bottom = ( int )_marginBottomOverride ; } return result ; }	if ( this . marginBottomOverrideSet ) { result . bottom = ( int ) this . marginBottomOverride ;
data [ i + offset ] = ( float ) val ; <CTX> public void setElem ( int i , int val ) { data [ i + offset ] = ( float ) val ; }	data [ i + offset ] = val ;
return RubyFixnum . newFixnum ( recv . getRuntime ( ) , count ) ; <CTX> public static IRubyObject each_object ( IRubyObject recv , IRubyObject [ ] args ) { RubyModule rubyClass ; if ( args . length == 0 ) { rubyClass = recv . getRuntime ( ) . getClasses ( ) . getObjectClass ( ) ; } else { rubyClass = ( RubyModule ) args [ 0 ] ; } int count = 0 ; Iterator iter = recv . getRuntime ( ) . objectSpace . iterator ( rubyClass ) ; while ( iter . hasNext ( ) ) { count ++ ; recv . getRuntime ( ) . yield ( ( IRubyObject ) iter . next ( ) ) ; } return RubyFixnum . newFixnum ( recv . getRuntime ( ) , count ) ; }	return recv . getRuntime ( ) . newFixnum ( count ) ;
boolean delistResource ( XAResource xaResource , int i ) throws IllegalStateException , SystemException ; <CTX> boolean delistResource ( XAResource xaResource , int i ) throws IllegalStateException , SystemException ;	boolean delistResource ( XAResource xaRes , int flag ) throws IllegalStateException , SystemException ;
return Integer . valueOf ( s ) . intValue ( ) ; <CTX> public static int stringToInt ( String s ) { try { return Integer . valueOf ( s ) . intValue ( ) ; } catch ( NumberFormatException e ) { return ( - 1 ) ; / / ? ? ? } }	return Integer . parseInt ( s ) ;
ObjectPool createPool ( UMODescriptor descriptor ) ; <CTX> ObjectPool createPool ( UMODescriptor descriptor ) ;	ObjectPool createPool ( UMODescriptor descriptor , ObjectFactory factory ) ;
getSeriesMarker ( ) . setType ( MarkerType . get ( getSelectedMarkerName ( ) ) ) ; <CTX> public void widgetSelected ( SelectionEvent e ) { if ( e . getSource ( ) . equals ( btnCurve ) ) { ( ( LineSeries ) series ) . setCurve ( btnCurve . getSelection ( ) ) ; } else if ( e . getSource ( ) . equals ( btnPalette ) ) { ( ( LineSeries ) series ) . setPaletteLineColor ( btnPalette . getSelection ( ) ) ; } else if ( e . getSource ( ) . equals ( btnMarkerVisible ) ) { ( ( LineSeries ) series ) . getMarker ( ) . setVisible ( btnMarkerVisible . getSelection ( ) ) ; cmbMarkerTypes . setEnabled ( btnMarkerVisible . getSelection ( ) ) ; iscMarkerSize . setEnabled ( btnMarkerVisible . getSelection ( ) ) ; } else if ( e . getSource ( ) . equals ( cmbMarkerTypes ) ) { if ( MarkerType . get ( getSelectedMarkerName ( ) ) == MarkerType . ICON_LITERAL ) { MarkerIconDialog iconDialog = new MarkerIconDialog ( this . getShell ( ) , getSeriesMarker ( ) . getIconPalette ( ) ) ; if ( iconDialog . applyMarkerIcon ( ) ) { if ( iconDialog . getIconPalette ( ) . eAdapters ( ) . isEmpty ( ) ) { / / Add adapters to new EObject iconDialog . getIconPalette ( ) . eAdapters ( ) . addAll ( getSeriesMarker ( ) . eAdapters ( ) ) ; } getSeriesMarker ( ) . setIconPalette ( iconDialog . getIconPalette ( ) ) ; } else { cmbMarkerTypes . setText ( LiteralHelper . markerTypeSet . getDisplayNameByName ( getSeriesMarker ( ) . getType ( ) . getName ( ) ) ) ; } } getSeriesMarker ( ) . setType ( MarkerType . get ( getSelectedMarkerName ( ) ) ) ; } }	getSeriesMarker ( ) . setType ( MarkerType . getByName ( getSelectedMarkerName ( ) ) ) ;
getUndoActivity ( ) . setAffectedFigures ( view ( ) . selection ( ) ) ; <CTX> public void execute ( ) { super . execute ( ) ; setUndoActivity ( createUndoActivity ( ) ) ; getUndoActivity ( ) . setAffectedFigures ( view ( ) . selection ( ) ) ; deleteFigures ( getUndoActivity ( ) . getAffectedFigures ( ) ) ; view ( ) . checkDamage ( ) ; }	/ * ricardo_padilha : bugfix for correct delete / undelete behavior * When enumerating the affected figures we must not forget the dependent * figures , since they are deleted as well ! * / FigureEnumeration fe = view ( ) . selection ( ) ; List affected = CollectionsFactory . current ( ) . createList ( ) ; Figure f ; FigureEnumeration dfe ; while ( fe . hasNextFigure ( ) ) { f = fe . nextFigure ( ) ; affected . add ( f ) ; dfe = f . getDependendFigures ( ) ; if ( dfe != null ) { while ( dfe . hasNextFigure ( ) ) { affected . add ( dfe . nextFigure ( ) ) ; } } } fe = new FigureEnumerator ( affected ) ; getUndoActivity ( ) . setAffectedFigures ( fe ) ; / * ricardo_padilha : end of bugfix * /
super ( position ) ; <CTX> public ClassVarNode ( ISourcePosition position , String name ) { super ( position ) ; this . name = name . intern ( ) ; }	super ( position , NodeTypes . CLASSVARNODE ) ;
if ( text == null || StringUtil . isBlank ( text ) || ! DEUtil . isValidNumber ( text ) ) { previewText = null ; } else { previewText = text ; } updatePreview ( ) ; <CTX> public void setPreviewText ( String text ) { if ( text == null || StringUtil . isBlank ( text ) || ! DEUtil . isValidNumber ( text ) ) { previewText = null ; } else { previewText = text ; } updatePreview ( ) ; return ; }	previewTextBox . setText ( text == null ? DEFAULT_PREVIEW_TEXT : text ) ;
if ( formatStr != null ) <CTX> protected void formatValue ( Object value , String formatStr , StyleDesign style , StringBuffer formattedStr ) { if ( value == null ) { return ; } assert style != null && formattedStr != null ; if ( ( value instanceof Number ) ) { NumberFormatter numberFormat = null ; if ( formatStr == null || formatStr . length ( ) == 0 ) { numberFormat = style . getNumberFormatObject ( ) ; / / initial number - format for the first time if ( numberFormat == null ) { formatStr = style . getNumberFormat ( ) ; if ( formatStr != null ) { numberFormat = new NumberFormatter ( formatStr , context . getLocale ( ) ) ; style . setNumberFormatObject ( numberFormat ) ; } } } else / / deal with value - of for text item { numberFormat = new NumberFormatter ( formatStr , context . getLocale ( ) ) ; } if ( numberFormat == null ) { numberFormat = new NumberFormatter ( context . getLocale ( ) ) ; } formattedStr . append ( numberFormat . format ( ( ( Number ) value ) . doubleValue ( ) ) ) ; return ; } else if ( value instanceof Date ) { DateFormatter dateFormat = null ; if ( formatStr == null || formatStr . length ( ) == 0 ) { dateFormat = style . getDateFormatObject ( ) ; / / initial date - format for the first time if ( dateFormat == null ) { formatStr = style . getDateTimeFormat ( ) ; if ( formatStr != null ) { dateFormat = new DateFormatter ( formatStr , context . getLocale ( ) ) ; style . setDateFormatObject ( dateFormat ) ; } } } else / / deal with value - of for text item { dateFormat = new DateFormatter ( formatStr , context . getLocale ( ) ) ; } if ( dateFormat == null ) { dateFormat = new DateFormatter ( context . getLocale ( ) ) ; } formattedStr . append ( dateFormat . format ( ( Date ) value ) ) ; return ; } else if ( value instanceof String ) { StringFormatter stringFormat = null ; if ( formatStr == null || formatStr . length ( ) == 0 ) { stringFormat = style . getStringFormatObject ( ) ; / / initial string - format for the first time if ( stringFormat == null ) { / / get format pattern from style formatStr = style . getStringFormat ( ) ; if ( formatStr != null ) { / / use default stringFormat stringFormat = new StringFormatter ( formatStr , context . getLocale ( ) ) ; style . setStringFormatObject ( stringFormat ) ; } } } else / / deal with value - of for text item { stringFormat = new StringFormatter ( formatStr , context . getLocale ( ) ) ; } if ( stringFormat != null ) { formattedStr . append ( stringFormat . format ( value . toString ( ) ) ) ; return ; } } formattedStr . append ( value . toString ( ) ) ; }	if ( formatStr != null && formatStr . length ( ) != 0 )
this . image = createImage ( new FilteredImageSource ( tempImage . getSource ( ) , new KeyAlphaFilter ( TRANSPARENT ) ) ) ; <CTX> public void prepare ( ) { / / create image for buffer Image tempImage = createImage ( bounds . width , bounds . height ) ; Graphics graph = tempImage . getGraphics ( ) ; / / fill with key color graph . setColor ( new Color ( TRANSPARENT ) ) ; graph . fillRect ( 0 , 0 , bounds . width , bounds . height ) ; / / draw attack poly graph . setColor ( color ) ; graph . drawPolygon ( hexPoly ) ; / / create final image this . image = createImage ( new FilteredImageSource ( tempImage . getSource ( ) , new KeyAlphaFilter ( TRANSPARENT ) ) ) ; }	if ( zoomIndex == BASE_ZOOM_INDEX ) { image = createImage ( new FilteredImageSource ( tempImage . getSource ( ) , new KeyAlphaFilter ( TRANSPARENT ) ) ) ; } else { image = getScaledImage ( createImage ( new FilteredImageSource ( tempImage . getSource ( ) , new KeyAlphaFilter ( TRANSPARENT ) ) ) ) ; } graph . dispose ( ) ; tempImage . flush ( ) ;
_ switchPaneFocus ( true ) ; <CTX> public void actionPerformed ( ActionEvent ae ) {_switchPaneFocus ( true ) ; }	_ model . setActiveNextDocument ( ) ;
this ( bytes , 0 , bytes . length , 0 , false ) ; <CTX> public BitString ( byte [ ] bytes ) { this ( bytes , 0 , bytes . length , 0 , false ) ; }	this ( bytes , 0 , bytes . length , ignoredBits , doShift ) ;
experiment . removeExperimentListener ( listener ) ; <CTX> public void actionPerformed ( ActionEvent e ) { String s = ( ( AbstractButton ) e . getSource ( ) ) . getActionCommand ( ) ; if ( s . equals ( NamedFrame . COMMUNITY ) ) { makeCommunityGraph ( ) ; } else if ( s . equals ( NamedFrame . AGENT ) ) { makeSocietyGraph ( ) ; / / only the name changes ! } else if ( s . equals ( NamedFrame . PLAN ) ) { makePlanGraph ( ) ; } else if ( s . equals ( NamedFrame . THREAD ) ) { makeThreadGraph ( ) ; } else if ( s . equals ( NamedFrame . METRICS ) ) { makeMetricsGraph ( ) ; } else if ( s . equals ( OPEN_GRAPH_MENU_ITEM ) ) { openGraph ( ) ; } else if ( s . equals ( OPEN_METRIC_MENU_ITEM ) ) { openMetrics ( ) ; } else if ( s . equals ( MONITOR_MENU_ITEM ) ) { getAgentURL ( ) ; } else if ( s . equals ( EXIT_MENU_ITEM ) ) { if ( csmart == null ) System . exit ( 0 ) ; / / if running standalone , exit else { closeSubWindows ( ) ; experiment . removeExperimentListener ( listener ) ; NamedFrame . getNamedFrame ( ) . removeFrame ( this ) ; dispose ( ) ; } } else if ( s . equals ( HELP_MENU_ITEM ) ) { URL help = ( URL ) getClass ( ) . getResource ( HELP_DOC ) ; if ( help != null ) Browser . setPage ( help ) ; } else if ( s . equals ( ABOUT_CSMART_ITEM ) ) { URL about = ( URL ) getClass ( ) . getResource ( ABOUT_DOC ) ; if ( about != null ) Browser . setPage ( about ) ; } else { JFrame f = NamedFrame . getNamedFrame ( ) . getFrame ( s ) ; if ( f != null ) { f . toFront ( ) ; f . setState ( Frame . NORMAL ) ; } } }	if ( experiment != null ) experiment . removeExperimentListener ( listener ) ;
String class_name = br . readLine ( ) ; <CTX> private static HClass readClass ( Linker linker , BufferedReader br ) throws IOException { String class_name = br . readLine ( ) ; HClass hc = ( HClass ) primitives . get ( class_name ) ; if ( hc == null ) hc = linker . forName ( class_name ) ; return hc ; }	String class_name = readString ( br ) ;
return new KeyStroke ( modifierKeys , naturalKey ) ; <CTX> public static KeyStroke getInstance ( SortedSet modifierKeys , NaturalKey naturalKey ) { return new KeyStroke ( modifierKeys , naturalKey ) ; }	if ( modifierKey == null ) { throw new NullPointerException ( ) ; } return new KeyStroke ( new TreeSet ( Collections . singletonList ( modifierKey ) ) , naturalKey ) ;
_ saveProject ( ) ; <CTX> private void_saveAll ( ) { try {_saveProject ( ) ;_model . saveAllFiles (_saveSelector ) ; } catch ( IOException ioe ) {_showIOError ( ioe ) ; } }	if (_model . isProjectActive ( ) ) {_saveProject ( ) ; }
newVal = new BooleanValue ( srcVal . getBoolean ( ) ) ; <CTX> public static Value copy ( Value srcVal ) throws IllegalStateException { Value newVal = null ; try { switch ( srcVal . getType ( ) ) { case PropertyType . BINARY : newVal = new BinaryValue ( srcVal . getStream ( ) ) ; break ; case PropertyType . BOOLEAN : newVal = new BooleanValue ( srcVal . getBoolean ( ) ) ; break ; case PropertyType . DATE : newVal = new DateValue ( srcVal . getDate ( ) ) ; break ; case PropertyType . DOUBLE : newVal = new DoubleValue ( srcVal . getDouble ( ) ) ; break ; case PropertyType . LONG : newVal = new LongValue ( srcVal . getLong ( ) ) ; break ; case PropertyType . PATH : newVal = PathValue . valueOf ( srcVal . getString ( ) ) ; break ; case PropertyType . NAME : newVal = NameValue . valueOf ( srcVal . getString ( ) ) ; break ; case PropertyType . REFERENCE : newVal = ReferenceValue . valueOf ( srcVal . getString ( ) ) ; break ; case PropertyType . STRING : newVal = new StringValue ( srcVal . getString ( ) ) ; break ; } } catch ( RepositoryException re ) { / / should never get here } return newVal ; }	newVal = new BooleanValue ( srcValue . getBoolean ( ) ) ;
table . setRows ( getRows ( ) ) ; <CTX> public void populateTable ( StatusTable table ) throws StatusService . NoSuchTableException { table . setColumnDescriptors ( columnDescriptors ) ; table . setDefaultSortRules ( sortRules ) ; table . setRows ( getRows ( ) ) ; table . setSummaryInfo ( getSummaryInfo ( ) ) ; }	table . setRows ( getRows ( table . getOptions ( ) . get ( StatusTable . OPTION_INCLUDE_INTERNAL_AUS ) ) ) ;
methodCache . put ( name , result ) ; <CTX> protected CacheEntry getMethodBodyCached ( String name ) { CacheEntry result = ( CacheEntry ) methodCache . get ( name ) ; if ( result != null ) { return result ; } name = name . intern ( ) ; ICallable method = searchMethod ( name ) ; if ( method . isUndefined ( ) ) { CacheEntry undefinedEntry = CacheEntry . createUndefined ( name , this ) ; methodCache . put ( name , undefinedEntry ) ; return undefinedEntry ; } result = new CacheEntry ( name , this ) ; method . initializeCacheEntry ( result ) ; methodCache . put ( name , result ) ; return result ; }	if ( result . getOrigin ( ) == this || ! ( this instanceof MetaClass ) ) { methodCache . put ( name , result ) ; }
Map paramters , Map globalVariables , boolean isComplete ) <CTX> TransientReportDocument ( IReportDocument document , long pageNumber , Map paramters , Map globalVariables , boolean isComplete ) { this . document = document ; this . pageNumber = pageNumber ; this . parameters = paramters ; this . globalVariables = globalVariables ; this . isComplete = isComplete ; }	Map paramters , Map parameterDisplayTexts , Map globalVariables , boolean isComplete )
Iterator enum = pageContributions . iterator ( ) ; while ( enum . hasNext ( ) ) { preferenceManager . addToRoot ( ( IPreferenceNode ) enum . next ( ) ) ; <CTX> public PreferenceManager getPreferenceManager ( ) { if ( preferenceManager == null ) { preferenceManager = new PreferenceManager ( PREFERENCE_PAGE_CATEGORY_SEPARATOR ) ; / / Get the pages from the registry PreferencePageRegistryReader registryReader = new PreferencePageRegistryReader ( getWorkbench ( ) ) ; List pageContributions = registryReader . getPreferenceContributions ( Platform . getExtensionRegistry ( ) ) ; / / Add the contributions to the manager Iterator enum = pageContributions . iterator ( ) ; while ( enum . hasNext ( ) ) { preferenceManager . addToRoot ( ( IPreferenceNode ) enum . next ( ) ) ; } }	Iterator iterator = pageContributions . iterator ( ) ; while ( iterator . hasNext ( ) ) { preferenceManager . addToRoot ( ( IPreferenceNode ) iterator . next ( ) ) ;
list . add ( new Integer ( backtraceTable [ i ] [ j ] ) ) ; <CTX> LinkedList backtrace ( int [ ] [ ] backtraceTable ) { LinkedList list = new LinkedList ( ) ; int i = referenceWords . size ( ) ; int j = hypothesisWords . size ( ) ; while ( ( i >= 0 ) && ( j >= 0 ) ) { list . add ( new Integer ( backtraceTable [ i ] [ j ] ) ) ; switch ( backtraceTable [ i ] [ j ] ) { case OK : i -- ; j -- ; break ; case SUBSTITUTION : i -- ; j -- ; substitutions ++ ; break ; case INSERTION : j -- ; insertions ++ ; break ; case DELETION : i -- ; deletions ++ ; break ; } } return list ; }	list . add ( backtraceTable [ i ] [ j ] ) ;
catch ( InvocationTargetException e ) { e . fillInStackTrace ( ) ; throwables [ 0 ] = e . getTargetException ( ) ; <CTX> public void run ( ) { try { IdeaTestCase . super . runTest ( ) ; / * method . invoke ( IdeaTestCase . this , new Class [ 0 ] ) ; * / } catch ( InvocationTargetException e ) { e . fillInStackTrace ( ) ; throwables [ 0 ] = e . getTargetException ( ) ; } catch ( IllegalAccessException e ) { e . fillInStackTrace ( ) ; throwables [ 0 ] = e ; } catch ( Throwable e ) { throwables [ 0 ] = e ; } }	catch ( Throwable throwable ) { throwables [ 0 ] = throwable ;
setLayoutManager ( new RulerLayout ( ) ) ; <CTX> public EditorRulerFigure ( boolean isHorizontal , int measurementUnit ) { super ( isHorizontal , measurementUnit ) ; setHorizontal ( isHorizontal ) ; setUnit ( measurementUnit ) ; setBackgroundColor ( ColorConstants . listBackground ) ; setForegroundColor ( ColorConstants . listForeground ) ; setOpaque ( true ) ; setLayoutManager ( new RulerLayout ( ) ) ; }	setLayoutManager ( new EditorRulerLayout ( ) ) ;
switch ( eDerivedStructuralFeatureID ( eFeature ) ) <CTX> public boolean eIsSet ( EStructuralFeature eFeature ) { switch ( eDerivedStructuralFeatureID ( eFeature ) ) { case AttributePackage . STYLE__ FONT : return font != null ; case AttributePackage . STYLE__ COLOR : return color != null ; case AttributePackage . STYLE__ BACKGROUND_COLOR : return backgroundColor != null ; case AttributePackage . STYLE__ BACKGROUND_IMAGE : return backgroundImage != null ; case AttributePackage . STYLE__ PADDING : return padding != null ; } return eDynamicIsSet ( eFeature ) ; }	switch ( featureID )
object = workDequeue . pop ( ) ; <CTX> private final boolean markGrey ( VM_Address object , long timeCap ) throws VM_PragmaInline { boolean abort = false ; if ( VM_Interface . VerifyAssertions ) VM_Interface ._assert ( workDequeue . pop ( ) . isZero ( ) ) ; while ( ! object . isZero ( ) ) { if ( VM_Interface . VerifyAssertions ) VM_Interface ._assert ( ! RCBaseHeader . isGreen ( object ) ) ; visitCount ++ ; if ( visitCount % GREY_VISIT_GRAIN == 0 && VM_Interface . cycles ( ) > timeCap ) { abort = true ; } if ( ! abort && ! RCBaseHeader . isGrey ( object ) ) { RCBaseHeader . makeGrey ( object ) ; ScanObject . enumeratePointers ( object , greyEnum ) ; } object = workDequeue . pop ( ) ; } return ! abort ; }	object = workDeque . pop ( ) ;
Object data [ ] ; data = context . popOperands ( 1 ) ; context . operands . push ( data [ 0 ] ) ; context . operands . push ( data [ 0 ] ) ; <CTX> public void execute ( PAContext context ) throws PainterException { Object data [ ] ; data = context . popOperands ( 1 ) ; context . operands . push ( data [ 0 ] ) ; context . operands . push ( data [ 0 ] ) ; }	double data [ ] ; data = context . popNumberOperands ( 1 ) ; context . operands . push ( new Double ( Math . log ( data [ 0 ] ) ) ) ;
if ( lastNodeId == null ) <CTX> void addMessage ( String routingKey , Message message , Map queueNameToNodeIdMap , String lastNodeId , long channelID ) { / / If we only ever send messages to the same node for this tx , then we can unicast rather than multicast / / This is how we determine that if ( lastNodeId == null ) { multicast = true ; } else { if ( ! lastNodeId . equals ( toNodeId ) ) { multicast = true ; } else { toNodeId = lastNodeId ; } } MessageHolder holder = new MessageHolder ( routingKey , message , queueNameToNodeIdMap ) ; if ( message . isReliable ( ) ) { if ( persistent == null ) { persistent = new ArrayList ( ) ; } persistent . add ( holder ) ; checkChannelID = channelID ; } else { if ( nonPersistent == null ) { nonPersistent = new ArrayList ( ) ; } nonPersistent . add ( holder ) ; } }	if ( lastNodeId == - 1 )
if ( restoreItem != null ) { if ( selectedView != null ) { restoreItem . setEnabled ( page != null && page . isMoveable ( selectedView ) ) ; } else { restoreItem . setEnabled ( false ) ; } restoreItem . setSelection ( true ) ; <CTX> public void fill ( Menu menu , int index ) { / / TODO Auto - generated method stub super . fill ( menu , index ) ; if ( bar . isTrueFastView ( ) ) { orientationItem = new MenuItem ( menu , SWT . CASCADE , index ++ ) ; { orientationItem . setText ( WorkbenchMessages . FastViewBar_view_orientation ) ; Menu orientationSwtMenu = new Menu ( orientationItem ) ; RadioMenu orientationMenu = new RadioMenu ( orientationSwtMenu , currentOrientation ) ; orientationMenu . addMenuItem ( WorkbenchMessages . FastViewBar_horizontal , new Integer ( SWT . HORIZONTAL ) ) ; orientationMenu . addMenuItem ( WorkbenchMessages . FastViewBar_vertical , new Integer ( SWT . VERTICAL ) ) ; orientationItem . setMenu ( orientationSwtMenu ) ; } restoreItem = new MenuItem ( menu , SWT . CHECK , index ++ ) ; restoreItem . setText ( WorkbenchMessages . ViewPane_fastView ) ; restoreItem . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { bar . restoreView ( selectedView , true ) ; } } ) ; } closeItem = new MenuItem ( menu , SWT . NONE , index ++ ) ; closeItem . setText ( WorkbenchMessages . WorkbenchWindow_close ) ; closeItem . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { if ( selectedView != null ) { WorkbenchPage page = bar . getWindow ( ) . getActiveWorkbenchPage ( ) ; if ( page != null ) { page . hideView ( selectedView ) ; } } } } ) ; / / Set menu item enablement etc based on whether a view is selected WorkbenchPage page = bar . getWindow ( ) . getActiveWorkbenchPage ( ) ; if ( restoreItem != null ) { if ( selectedView != null ) { restoreItem . setEnabled ( page != null && page . isMoveable ( selectedView ) ) ; } else { restoreItem . setEnabled ( false ) ; } restoreItem . setSelection ( true ) ; } if ( selectedView != null ) { closeItem . setEnabled ( page != null && page . isCloseable ( selectedView ) ) ; } else { closeItem . setEnabled ( false ) ; } if ( orientationItem != null ) { orientationItem . setEnabled ( selectedView != null ) ; if ( selectedView != null ) { / / Set the new orientation , but avoid re - sending the event to our own / / listener currentOrientation . set ( bar . getOrientation ( selectedView ) , orientationChangeListener ) ; } } }	if ( selectedView != null ) { restoreItem . setEnabled ( page != null && page . isMoveable ( selectedView ) ) ; } else { restoreItem . setEnabled ( false ) ;
if ( returnValue != null ) return returnValue ; <CTX> public Object getPropertyValue ( Object key ) { Object returnValue = super . getPropertyValue ( key ) ; if ( returnValue != null ) return returnValue ; if ( key . equals ( IResourcePropertyConstants . P_SIZE_RES ) ) return getSizeString ( ( IFile ) element ) ; return null ; }	if ( returnValue != null ) { return returnValue ; }
reuseEditorsThreshold . getLabelControl ( groupComposite ) . setEnabled ( reuseEditors . getSelection ( ) ) ; reuseEditorsThreshold . getTextControl ( groupComposite ) . setEnabled ( reuseEditors . getSelection ( ) ) ; <CTX> public void widgetSelected ( SelectionEvent e ) { reuseEditorsThreshold . getLabelControl ( groupComposite ) . setEnabled ( reuseEditors . getSelection ( ) ) ; reuseEditorsThreshold . getTextControl ( groupComposite ) . setEnabled ( reuseEditors . getSelection ( ) ) ; }	reuseEditorsThreshold . getLabelControl ( editorReuseGroup ) . setEnabled ( reuseEditors . getSelection ( ) ) ; reuseEditorsThreshold . getTextControl ( editorReuseGroup ) . setEnabled ( reuseEditors . getSelection ( ) ) ;
m_outgoingEvents . clear ( ) ; <CTX> protected void flushEvents ( ) { synchronized ( m_outgoingEvents ) { for ( Iterator itor = m_outgoingEvents . iterator ( ) ; itor . hasNext ( ) ; ) ( ( DeferredEvent ) itor . next ( ) ) . dispatch ( m_sessions ) ; m_outgoingEvents . clear ( ) ; } }	m_deferredEvents . clear ( ) ;
return ( iCode [ pc ] << 8 ) + ( iCode [ pc + 1 ] & 0 xFF ) ; <CTX> private static int getShort ( byte [ ] iCode , int pc ) { return ( iCode [ pc ] << 8 ) + ( iCode [ pc + 1 ] & 0 xFF ) ; }	return ( iCode [ pc ] << 8 ) | ( iCode [ pc + 1 ] & 0 xFF ) ;
return Factory . createLeafElement ( isType ? JavaDocTokenType . DOC_TYPE_TEXT : JavaDocTokenType . DOC_REFERENCE_TEXT , buffer , startOffset , <CTX> private LeafElement parseReferenceOrType ( char [ ] buffer , int startOffset , int endOffset , boolean isType , int lexerState ) { return Factory . createLeafElement ( isType ? JavaDocTokenType . DOC_TYPE_TEXT : JavaDocTokenType . DOC_REFERENCE_TEXT , buffer , startOffset , endOffset , lexerState , myContext . getCharTable ( ) ) ; }	return Factory . createLeafElement ( isType ? JavaDocElementType . DOC_TYPE_HOLDER : JavaDocElementType . DOC_REFERENCE_HOLDER , buffer , startOffset ,
void loadDistribution ( String filePath ) throws IOException ; <CTX> void loadDistribution ( String filePath ) throws IOException ;	void loadDistribution ( File file ) throws IOException ;
log . error ( ex ) ; <CTX> public void sendClearPanelMsg ( ) { int tmp [ ] = new int [ 1 ] ; tmp [ 0 ] = 0 ; DrawCommand comm = new DrawCommand ( DrawCommand . CLEAR ) ; ObjectOutputStream os ; try { out . reset ( ) ; os = new ObjectOutputStream ( out ) ; os . writeObject ( comm ) ; os . flush ( ) ; channel . send ( new Message ( null , null , out . toByteArray ( ) ) ) ; } catch ( Exception ex ) { log . error ( ex ) ; } }	System . err . println ( ex ) ;
if ( setChangeListeners == null ) { boolean hadListeners = hasListeners ( ) ; setChangeListeners = listener ; if ( ! hadListeners ) { firstListenerAdded ( ) ; } return ; } Collection listenerList ; if ( setChangeListeners instanceof Collection ) { listenerList = ( Collection ) setChangeListeners ; } else { ISetChangeListener l = ( ISetChangeListener ) setChangeListeners ; listenerList = new ArrayList ( ) ; listenerList . add ( l ) ; setChangeListeners = listenerList ; } if ( listenerList . size ( ) > 16 ) { HashSet listenerSet = new HashSet ( ) ; listenerSet . addAll ( listenerList ) ; setChangeListeners = listenerList ; } listenerList . add ( listener ) ; <CTX> public void addSetChangeListener ( ISetChangeListener listener ) { if ( setChangeListeners == null ) { boolean hadListeners = hasListeners ( ) ; setChangeListeners = listener ; if ( ! hadListeners ) { firstListenerAdded ( ) ; } return ; } Collection listenerList ; if ( setChangeListeners instanceof Collection ) { listenerList = ( Collection ) setChangeListeners ; } else { ISetChangeListener l = ( ISetChangeListener ) setChangeListeners ; listenerList = new ArrayList ( ) ; listenerList . add ( l ) ; setChangeListeners = listenerList ; } if ( listenerList . size ( ) > 16 ) { HashSet listenerSet = new HashSet ( ) ; listenerSet . addAll ( listenerList ) ; setChangeListeners = listenerList ; } listenerList . add ( listener ) ; }	changeSupport . addListener ( SetChangeEvent . TYPE , listener ) ;
} ) ; <CTX> public PropertiesReferenceManager ( Project project , PropertiesFilesManager propertiesFilesManager , FileTypeManager fileTypeManager ) { myProject = project ; myPropertiesFilesManager = propertiesFilesManager ; fileTypeManager . addFileTypeListener ( new FileTypeListener ( ) { public void beforeFileTypesChanged ( FileTypeEvent event ) { } public void fileTypesChanged ( FileTypeEvent event ) { StartupManager . getInstance ( myProject ) . runWhenProjectIsInitialized ( new Runnable ( ) { public void run ( ) { refreshAllPropFilesInProject ( ) ; } } ) ; } } ) ; }	} ; fileTypeManager . addFileTypeListener ( myFileTypeChangedListener ) ;
sourceFilePaths . add ( path ) ; <CTX> public void addSourceFilePath ( String path ) { change ( ) ; sourceFilePaths . add ( path ) ; }	sourceFilePaths . add ( getCorrectedPath ( path ) ) ;
} * / <CTX> public Double computeEctsCredits ( ) { Double result = 0 . 0 ; if ( this . getEctsCredits ( ) != null ) { result = this . getEctsCredits ( ) ; } / * else if ( this . getCompetenceCourse ( ) != null && this . getCompetenceCourse ( ) . getEctsCredits ( ) != null ) { result = this . getCompetenceCourse ( ) . getEctsCredits ( ) ; } * / return result ; }	}
textArea 1 . setText ( listNames . getSelectedItem ( ) ) ; <CTX> void listNames_ItemStateChanged ( java . awt . event . ItemEvent event ) { String cur = listNames . getSelectedItem ( ) ; if ( currentAction == VIEWKNOWNPERSONS ) textArea 1 . setText ( myAgent . getPerson ( cur ) . toString ( ) ) ; else if ( currentAction == VIEWKNOWNDF ) textArea 1 . setText ( listNames . getSelectedItem ( ) ) ; }	textArea 1 . setText ( cur ) ;
ClientKeyBlock realGetKey ( ClientKey key , boolean localOnly , boolean cache ) throws LowLevelGetException ; <CTX> ClientKeyBlock realGetKey ( ClientKey key , boolean localOnly , boolean cache ) throws LowLevelGetException ;	ClientKeyBlock realGetKey ( ClientKey key , boolean localOnly , boolean cache , boolean ignoreStore ) throws LowLevelGetException ;
if ( fUpdateJob == null || fUpdateJob . getState ( ) != Job . RUNNING ) { <CTX> public void setSelection ( int [ ] selection ) { if ( selection == null || selection . length == 0 ) fList . deselectAll ( ) ; else { / / If there is a current working update defer the setting if ( fUpdateJob == null || fUpdateJob . getState ( ) != Job . RUNNING ) { fList . setSelection ( selection ) ; fList . notifyListeners ( SWT . Selection , new Event ( ) ) ; } else fUpdateJob . updateSelection ( selection ) ; } }	if ( fUpdateJob == null ) {
return result ; <CTX> public Object resolveInstance ( PicoContainer container , ComponentAdapter adapter , Class expectedType ) throws PicoInstantiationException { / / type check is done in isResolvable Object result = null ; if ( componentKey != null ) { result = container . getComponentInstance ( componentKey ) ; } else { result = container . getComponentInstanceOfType ( expectedType ) ; } return result ; }	return null ;
if ( descriptors [ j ] . getId ( ) == MetaModelUtil <CTX> protected ILabelProvider getLabelProvider ( Object propertyId ) { IPropertySource propertySource = propertiesProvider . getPropertySource ( getSingleInput ( ) ) ; ILabelProvider labelProvider = null ; NotationPropertyDescriptor pdNotation = null ; IPropertyDescriptor [ ] descriptors = null ; if ( null != propertySource ) { descriptors = propertySource . getPropertyDescriptors ( ) ; for ( int i = 0 ; i < descriptors . length ; i ++ ) { if ( descriptors [ i ] . getId ( ) == NotationPackage . eINSTANCE . getView_Styles ( ) ) { pdNotation = ( NotationPropertyDescriptor ) descriptors [ i ] ; break ; } } } if ( null != pdNotation ) { propertySource = ( IPropertySource ) pdNotation . getPropertyValue ( ) ; descriptors = propertySource . getPropertyDescriptors ( ) ; for ( int j = 0 ; j < descriptors . length ; j ++ ) { if ( descriptors [ j ] . getId ( ) == MetaModelUtil . getElement ( propertyId . toString ( ) ) ) { labelProvider = descriptors [ j ] . getLabelProvider ( ) ; break ; } } } return labelProvider ; }	if ( descriptors [ j ] . getId ( ) == PackageUtil
if ( sourcePart instanceof IShowInTargetList ) { return ( IShowInTargetList ) sourcePart ; } Object o = sourcePart . getAdapter ( IShowInTargetList . class ) ; if ( o instanceof IShowInTargetList ) { return ( IShowInTargetList ) o ; } return null ; <CTX> private IShowInTargetList getShowInTargetList ( IWorkbenchPart sourcePart ) { if ( sourcePart instanceof IShowInTargetList ) { return ( IShowInTargetList ) sourcePart ; } Object o = sourcePart . getAdapter ( IShowInTargetList . class ) ; if ( o instanceof IShowInTargetList ) { return ( IShowInTargetList ) o ; } return null ; }	return ( IShowInTargetList ) Util . getAdapter ( sourcePart , IShowInTargetList . class ) ;
Set < Language > owners = SModelRepository . getInstance ( ) . getOwners ( md , Language . class ) ; for ( Language l : myLanguages ) { if ( owners . contains ( l ) ) return l ; } return null ; <CTX> public Language getLanguageForModel ( SModelDescriptor md ) { Set < Language > owners = SModelRepository . getInstance ( ) . getOwners ( md , Language . class ) ; for ( Language l : myLanguages ) { if ( owners . contains ( l ) ) return l ; } return null ; }	Set < Language > owners = SModelRepository . getInstance ( ) . getOwners ( md , Language . class ) ; for ( Language l : myLanguages ) { if ( owners . contains ( l ) ) return l ;
return ( ChangeListener [ ] ) changeListenerList . getListenerList ( ) ; <CTX> public ChangeListener [ ] getChangeListeners ( ) { return ( ChangeListener [ ] ) changeListenerList . getListenerList ( ) ; }	return ( ChangeListener [ ] ) listenerList . getListeners ( ChangeListener . class ) ;
super . setInputFormat ( new Instances ( instanceInfo , 0 ) ) ; m_ClassAttribute = instanceInfo . classAttribute ( ) ; m_Random = new Random ( m_Seed ) ; int numClasses = instanceInfo . numClasses ( ) ; m_Converter = new double [ numClasses ] ; m_ClassCounts = new double [ numClasses ] ; return false ; } <CTX> public boolean setInputFormat ( Instances instanceInfo ) throws Exception { super . setInputFormat ( new Instances ( instanceInfo , 0 ) ) ; m_ClassAttribute = instanceInfo . classAttribute ( ) ; m_Random = new Random ( m_Seed ) ; int numClasses = instanceInfo . numClasses ( ) ; m_Converter = new double [ numClasses ] ; m_ClassCounts = new double [ numClasses ] ; return false ; }	int numClasses = instanceInfo . numClasses ( ) ; m_Converter = new double [ numClasses ] ; m_ClassCounts = new double [ numClasses ] ; return false ; }
if ( workingSet . isVisible ( ) ) <CTX> public IWorkingSet [ ] getWorkingSets ( ) { SortedSet visibleSubset = new TreeSet ( WorkingSetComparator . INSTANCE ) ; for ( Iterator i = workingSets . iterator ( ) ; i . hasNext ( ) ; ) { IWorkingSet workingSet = ( IWorkingSet ) i . next ( ) ; if ( workingSet . isVisible ( ) ) visibleSubset . add ( workingSet ) ; } return ( IWorkingSet [ ] ) visibleSubset . toArray ( new IWorkingSet [ visibleSubset . size ( ) ] ) ; }	if ( workingSet . isVisible ( ) ) {
if ( protocol == null ) { <CTX> public boolean handlesProtocol ( String protocol ) { if ( protocol == null ) { return false ; } for ( int i = 0 ; i < protocols . length ; i ++ ) { if ( protocol . equalsIgnoreCase ( protocols [ i ] ) ) { return true ; } } return false ; }	if ( protocol == null || protocols == null ) {
return getMessageBusiness ( ) . getNumberOfMessages ( messageCode . getCode ( ) , iwc . getCurrentUser ( ) ) ; <CTX> protected int getMessageCount ( IWContext iwc ) { try { return getMessageBusiness ( ) . getNumberOfMessages ( messageCode . getCode ( ) , iwc . getCurrentUser ( ) ) ; } catch ( IDOException ie ) { ie . printStackTrace ( ) ; return 0 ; } catch ( RemoteException re ) { log ( re ) ; return 0 ; } }	return getMessageBusiness ( ) . getNumberOfMessages ( messageType , iwc . getCurrentUser ( ) ) ;
Object invoke ( Object component , UMOEventContext context , Method method ) throws InvocationTargetException , <CTX> Object invoke ( Object component , UMOEventContext context , Method method ) throws InvocationTargetException , IllegalAccessException , TransformerException ;	Object invoke ( Object component , UMOEventContext context ) throws InvocationTargetException ,
return ComponentPackage . eINSTANCE . getGrid ( ) ; <CTX> protected EClass eStaticClass ( ) { return ComponentPackage . eINSTANCE . getGrid ( ) ; }	return ComponentPackage . Literals . GRID ;
Entry entry = ( Entry ) delegateGet ( i ) ; if ( validator . isValid ( entry . getEStructuralFeature ( ) ) ) <CTX> public Object [ ] toArray ( EStructuralFeature feature ) { List result = new BasicEList ( ) ; FeatureMapUtil . Validator validator = FeatureMapUtil . getValidator ( owner . eClass ( ) , feature ) ; for ( int i = 0 , size = delegateSize ( ) ; i < size ; ++ i ) { Entry entry = ( Entry ) delegateGet ( i ) ; if ( validator . isValid ( entry . getEStructuralFeature ( ) ) ) { result . add ( entry . getValue ( ) ) ; } } return result . toArray ( ) ; }	for ( int i = 0 , size = delegateSize ( ) ; i < size ; ++ i )
String [ ]_poa_names = new String [ poas . size ( ) ] ; Enumeration_poa_enum = poas . elements ( ) ; <CTX> protected String [ ] getPOANames ( ) { / / not synchronizing here since this method is only called / / prior to destructing this object . String [ ]_poa_names = new String [ poas . size ( ) ] ; Enumeration_poa_enum = poas . elements ( ) ; int_i = 0 ; while (_poa_enum . hasMoreElements ( ) )_poa_names [_i ++ ] = ( ( ImRPOAInfo )_poa_enum . nextElement ( ) ) . name ; return_poa_names ; }	final String [ ] names ; synchronized ( poas ) { ImRPOAInfo [ ]_poas = ( ImRPOAInfo [ ] ) poas . toArray ( new POAInfo [ poas . size ( ) ] ) ;
int height = ( end + 1 ) * fm . getHeight ( ) ; <CTX> public void invalidateScreenLineRange ( int start , int end ) { FontMetrics fm = painter . getFontMetrics ( ) ; int y = start * fm . getHeight ( ) ; int height = ( end + 1 ) * fm . getHeight ( ) ; painter . repaint ( 0 , y , painter . getWidth ( ) , height ) ; gutter . repaint ( 0 , y , gutter . getWidth ( ) , height ) ; } / / } } }	int height = ( end - start + 1 ) * fm . getHeight ( ) ;
String str = RubyString . stringValue ( target ) . getValue ( ) ; <CTX> public int search ( IRubyObject target , int pos ) { String str = RubyString . stringValue ( target ) . getValue ( ) ; if ( pos > str . length ( ) ) { return - 1 ; } recompileIfNeeded ( ) ; / / If nothing match then nil will be returned IRubyObject result = match ( str , pos ) ; getRuntime ( ) . getCurrentContext ( ) . setBackref ( result ) ; / / If nothing match then - 1 will be returned return result instanceof RubyMatchData ? ( ( RubyMatchData ) result ) . matchStartPosition ( ) : - 1 ; }	String str = RubyString . stringValue ( target ) . toString ( ) ;
return m_launcherClass ; <CTX> public String getLauncherClass ( ) { return m_launcherClass ; }	if ( m_launcherClass != null ) { return m_launcherClass ; } else { return C_UNKNOWN_LAUNCHER ; }
MessageDialog . openError ( window . getShell ( ) , PAGE_PROBLEMS_TITLE , e . getMessage ( ) ) ; <CTX> private static void openInNewPage ( IPerspectiveDescriptor desc ) { IWorkbenchWindow window = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; if ( window == null ) return ; / / If the active perspective is the same , then reuse it IWorkbenchPage page = window . getActivePage ( ) ; if ( page != null ) { IPerspectiveDescriptor persp = page . getPerspective ( ) ; if ( persp != null && persp . getId ( ) . equals ( desc . getId ( ) ) ) return ; } / / If the perspective is already open , then reuse it . IWorkbenchPage [ ] pages = window . getPages ( ) ; for ( int i = 0 ; i < pages . length ; i ++ ) { IPerspectiveDescriptor persp = pages [ i ] . getPerspective ( ) ; if ( persp != null && persp . getId ( ) . equals ( desc . getId ( ) ) ) { window . setActivePage ( pages [ i ] ) ; return ; } } / / Open the page . try { window . openPage ( desc . getId ( ) , ResourcesPlugin . getWorkspace ( ) . getRoot ( ) ) ; } catch ( WorkbenchException e ) { MessageDialog . openError ( window . getShell ( ) , PAGE_PROBLEMS_TITLE , e . getMessage ( ) ) ; } }	ErrorDialog . openError ( window . getShell ( ) , PAGE_PROBLEMS_TITLE , e . getMessage ( ) , e . getStatus ( ) ) ;
Iterator removee =_qGuidsToRemove . iterator ( ) ; while ( removee . hasNext ( ) ) { GUID currGuid = ( GUID ) removee . next ( ) ; <CTX> private void purgeGuidsInternal ( ) { synchronized (_qGuidsToRemove ) { Iterator removee =_qGuidsToRemove . iterator ( ) ; while ( removee . hasNext ( ) ) { GUID currGuid = ( GUID ) removee . next ( ) ;_queries . remove ( currGuid ) ; } } }	for ( GUID currGuid :_qGuidsToRemove )
return this . type ; <CTX> public String getType ( ) { return this . type ; }	return this . type . getName ( ) ;
return connection . maxrows ; <CTX> public int getMaxRows ( ) throws SQLException { return connection . maxrows ; }	return maxrows ;
return Collections . EMPTY_LIST ; <CTX> public List childNodes ( ) { return Collections . EMPTY_LIST ; }	return EMPTY_LIST ;
submission = new HandlerSubmission ( null , dialog . getShell ( ) , null , <CTX> private void registerKeybindings ( IAction action ) { IHandler handler = new ActionHandler ( action ) ; submission = new HandlerSubmission ( null , dialog . getShell ( ) , null , action . getActionDefinitionId ( ) , handler , Priority . MEDIUM ) ; PlatformUI . getWorkbench ( ) . getCommandSupport ( ) . addHandlerSubmission ( submission ) ; }	HandlerSubmission submission = new HandlerSubmission ( null , dialog . getShell ( ) , null ,
String getScriptClassName ( String functionName , boolean primary ) <CTX> String getScriptClassName ( String functionName , boolean primary ) { String result = nameHelper . getScriptClassName ( functionName , primary ) ; / / We wish to produce unique class names between calls to reset ( ) / / we disregard case since we may write the class names to file / / systems that are case insensitive String lowerResult = result . toLowerCase ( ) ; String base = lowerResult ; int count = 0 ; while ( classNames . has ( lowerResult ) ) { lowerResult = base ++ ++ count ; } classNames . put ( lowerResult , 0 ) ; return count == 0 ? result : ( result + count ) ; }	private String getScriptClassName ( String functionName , boolean primary )
return_sendStringParametersAsUnicode ; <CTX> public boolean getSendStringParametersAsUnicode ( ) { return_sendStringParametersAsUnicode ; }	return sendStringParametersAsUnicode ;
IStyle areaStyle = root . getStyle ( ) ; setOffsetX ( getDimensionValue ( areaStyle . getProperty ( StyleConstants . STYLE_BORDER_LEFT_WIDTH ) ) + getDimensionValue ( areaStyle . getProperty ( StyleConstants . STYLE_PADDING_LEFT ) ) ) ; setOffsetY ( isFirst ? ( getDimensionValue ( areaStyle . getProperty ( StyleConstants . STYLE_BORDER_TOP_WIDTH ) ) + getDimensionValue ( areaStyle . getProperty ( StyleConstants . STYLE_PADDING_TOP ) ) ) : 0 ) ; <CTX> protected void newContext ( ) { createRoot ( ) ; / / validateBoxProperty ( root . getStyle ( ) ) ; if ( null != parent ) { / / support user defined width int max = parent . getMaxAvaWidth ( ) - parent . getCurrentIP ( ) ; if ( content != null ) { int specifiedWidth = getDimensionValue ( content . getWidth ( ) ) ; if ( specifiedWidth > 0 ) { max = Math . min ( max , specifiedWidth ) ; } } root . setAllocatedWidth ( max ) ; setMaxAvaWidth ( root . getContentWidth ( ) ) ; root . setAllocatedHeight ( parent . getMaxAvaHeight ( ) - parent . getCurrentBP ( ) ) ; setMaxAvaHeight ( root . getContentHeight ( ) ) ; } / / initialize offsetX and offsetY IStyle areaStyle = root . getStyle ( ) ; setOffsetX ( getDimensionValue ( areaStyle . getProperty ( StyleConstants . STYLE_BORDER_LEFT_WIDTH ) ) + getDimensionValue ( areaStyle . getProperty ( StyleConstants . STYLE_PADDING_LEFT ) ) ) ; setOffsetY ( isFirst ? ( getDimensionValue ( areaStyle . getProperty ( StyleConstants . STYLE_BORDER_TOP_WIDTH ) ) + getDimensionValue ( areaStyle . getProperty ( StyleConstants . STYLE_PADDING_TOP ) ) ) : 0 ) ; / / can be removed ? setCurrentBP ( 0 ) ; setCurrentIP ( 0 ) ; }	setOffsetX ( root . getContentX ( ) ) ; setOffsetY ( isFirst ? root . getContentY ( ) : 0 ) ;
} else extendButton . setEnabled ( false ) ; <CTX> private void updateExtendButtonState ( ) { PathVariablesGroup . PathVariableElement [ ] selection = pathVariablesGroup . getSelection ( ) ; Button extendButton = getButton ( EXTEND_ID ) ; if ( extendButton == null ) return ; if ( selection . length == 1 ) { IFileInfo info = IDEResourceInfoUtils . getFileInfo ( selection [ 0 ] . path ) ; if ( info . exists ( ) && info . isDirectory ( ) ) extendButton . setEnabled ( true ) ; else extendButton . setEnabled ( false ) ; } else extendButton . setEnabled ( false ) ; }	} else { extendButton . setEnabled ( false ) ; }
builder = new TomcatModuleBuilder ( null , false , tomcatContainerObjectName , null , null , kernel ) ; <CTX> protected void setUp ( ) throws Exception { builder = new TomcatModuleBuilder ( null , false , tomcatContainerObjectName , null , null , kernel ) ; }	builder = new TomcatModuleBuilder ( null , false , tomcatContainerObjectName , null , null ) ;
return defaultValueCallback != null && args . length > 0 ? defaultValueCallback . execute ( this , args ) : getRuntime ( ) . getNil ( ) ; <CTX> public IRubyObject getDefaultValue ( IRubyObject [ ] args ) { return defaultValueCallback != null && args . length > 0 ? defaultValueCallback . execute ( this , args ) : getRuntime ( ) . getNil ( ) ; }	if ( defaultValueCallback == null || ( args . length == 0 && ! capturedDefaultProc . isNil ( ) ) ) { return getRuntime ( ) . getNil ( ) ; } return defaultValueCallback . execute ( this , args ) ;
start = Math . max ( 0 , start ) ; end = Math . min ( getLength ( ) , end ) ; <CTX> public void select ( int start , int end ) { start = Math . max ( 0 , start ) ; end = Math . min ( getLength ( ) , end ) ; if ( start <= end ) { selectionStart = start ; selectionEnd = end ; biasLeft = false ; } else { selectionStart = end ; selectionEnd = start ; biasLeft = true ; } int oldSelectionStartLine = selectionStartLine ; int oldSelectionEndLine = selectionEndLine ; selectionStartLine = getLineOfOffset ( selectionStart ) ; selectionEndLine = getLineOfOffset ( selectionEnd ) ; textArea . getPainter ( ) ._invalidateLineRange ( Math . min ( oldSelectionStartLine , selectionStartLine ) , Math . max ( oldSelectionEndLine , selectionEndLine ) ) ; int line = getCaretLine ( ) ; int lineStart = getLineStartOffset ( line ) ; if ( ! textArea . scrollTo ( line , getCaretPosition ( ) - start ) ) textArea . getPainter ( ) . repaint ( ) ; }	int newStart , newEnd ; boolean newBias ;
getStructuredViewer ( ) . refresh ( ) ; <CTX> public void refresh ( ) { if ( isAvailable ( ) ) { getView ( ) . showViewer ( ) ; getStructuredViewer ( ) . refresh ( ) ; } }	getStructuredViewer ( ) . refresh ( element ) ;
return new TagLibMetaClass ( metaRegistry , theClass , meta ) ; <CTX> public static TagLibMetaClass getTagLibInstance ( Class theClass ) throws IntrospectionException { MetaClassRegistry metaRegistry = InvokerHelper . getInstance ( ) . getMetaRegistry ( ) ; MetaClass meta = metaRegistry . getMetaClass ( theClass ) ; return new TagLibMetaClass ( metaRegistry , theClass , meta ) ; }	TagLibMetaClass m = new TagLibMetaClass ( metaRegistry , theClass , meta ) ; m . initialise ( ) ; return m ;
CommonDropAdapterDescriptor aDropDescriptor ) { dropDescriptors . put ( aContentDescriptor , aDropDescriptor ) ; <CTX> private void addCommonDropAdapter ( INavigatorContentDescriptor aContentDescriptor , CommonDropAdapterDescriptor aDropDescriptor ) { dropDescriptors . put ( aContentDescriptor , aDropDescriptor ) ; }	CommonDropAdapterDescriptor aDropDescriptor ) { getDropDescriptors ( aContentDescriptor ) . add ( aDropDescriptor ) ;
UserChoice . NAME_PROP , choice . getName ( ) , false ) ; <CTX> protected void writeUserPropertyDefns ( DesignElement obj ) { List props = obj . getLocalUserProperties ( ) ; if ( props == null || props . size ( ) == 0 ) return ; writer . startElement ( DesignSchemaConstants . LIST_PROPERTY_TAG ) ; writer . attribute ( DesignSchemaConstants . NAME_ATTRIB , DesignElement . USER_PROPERTIES_PROP ) ; Iterator iter = props . iterator ( ) ; while ( iter . hasNext ( ) ) { UserPropertyDefn propDefn = ( UserPropertyDefn ) iter . next ( ) ; writer . startElement ( DesignSchemaConstants . STRUCTURE_TAG ) ; property ( propDefn , UserPropertyDefn . NAME_MEMBER ) ; property ( propDefn , UserPropertyDefn . TYPE_MEMBER ) ; resourceKey ( propDefn , UserPropertyDefn . DISPLAY_NAME_ID_MEMBER , UserPropertyDefn . DISPLAY_NAME_MEMBER ) ; / / write default value if ( propDefn . getDefault ( ) != null ) writeEntry ( DesignSchemaConstants . PROPERTY_TAG , UserPropertyDefn . DEFAULT_MEMBER , propDefn . getXmlValue ( null , propDefn . getDefault ( ) ) , false ) ; IChoiceSet choiceSet = propDefn . getChoices ( ) ; if ( choiceSet != null && choiceSet . getChoices ( ) != null && choiceSet . getChoices ( ) . length > 0 ) { writer . startElement ( DesignSchemaConstants . LIST_PROPERTY_TAG ) ; writer . attribute ( DesignSchemaConstants . NAME_ATTRIB , UserPropertyDefn . CHOICES_MEMBER ) ; IChoice [ ] choices = choiceSet . getChoices ( ) ; for ( int i = 0 ; i < choices . length ; i ++ ) { UserChoice choice = ( UserChoice ) choices [ i ] ; writer . startElement ( DesignSchemaConstants . STRUCTURE_TAG ) ; writeEntry ( DesignSchemaConstants . PROPERTY_TAG , UserChoice . NAME_PROP , choice . getName ( ) , false ) ; if ( choice . getValue ( ) != null ) { writeEntry ( DesignSchemaConstants . PROPERTY_TAG , UserChoice . VALUE_PROP , choice . getValue ( ) . toString ( ) , false ) ; } writeResouceKey ( DesignSchemaConstants . TEXT_PROPERTY_TAG , UserChoice . DISPLAY_NAME_PROP , choice . getDisplayNameKey ( ) , choice . getDisplayName ( ) , false ) ; writer . endElement ( ) ; } writer . endElement ( ) ; } writer . endElement ( ) ; } writer . endElement ( ) ; }	Choice . NAME_PROP , choice . getName ( ) , false ) ;
GuiBoardUtils . showPointStringList ( guiBoard , pointList , <CTX> public static String show ( AnalyzeCommand command , GuiBoard guiBoard , Board board , String response ) throws GtpError { GoPoint pointArg = command . getPointArg ( ) ; ArrayList pointListArg = command . getPointListArg ( ) ; guiBoard . clearAllSelect ( ) ; GuiBoardUtils . setSelect ( guiBoard , pointListArg , true ) ; if ( pointArg != null ) guiBoard . setSelect ( pointArg , true ) ; int type = command . getType ( ) ; int size = board . getSize ( ) ; String statusText = null ; switch ( type ) { case AnalyzeCommand . BWBOARD : { String b [ ] [ ] = GtpUtils . parseStringBoard ( response , size ) ; GuiBoardUtils . showBWBoard ( guiBoard , b ) ; } break ; case AnalyzeCommand . CBOARD : { String colors [ ] [ ] = GtpUtils . parseStringBoard ( response , size ) ; GuiBoardUtils . showColorBoard ( guiBoard , colors ) ; } break ; case AnalyzeCommand . DBOARD : { double b [ ] [ ] = GtpUtils . parseDoubleBoard ( response , size ) ; GuiBoardUtils . showDoubleBoard ( guiBoard , b ) ; } break ; case AnalyzeCommand . GFX : { statusText = showGfx ( response , guiBoard ) ; } break ; case AnalyzeCommand . PLIST : { GoPoint list [ ] = GtpUtils . parsePointList ( response , size ) ; GuiBoardUtils . showPointList ( guiBoard , list ) ; } break ; case AnalyzeCommand . HPSTRING : case AnalyzeCommand . PSTRING : { GoPoint list [ ] = GtpUtils . parsePointString ( response , size ) ; GuiBoardUtils . showPointList ( guiBoard , list ) ; } break ; case AnalyzeCommand . PSPAIRS : { ArrayList pointList = new ArrayList ( 32 ) ; ArrayList stringList = new ArrayList ( 32 ) ; GtpUtils . parsePointStringList ( response , pointList , stringList , size ) ; GuiBoardUtils . showPointStringList ( guiBoard , pointList , stringList ) ; } break ; case AnalyzeCommand . SBOARD : { String b [ ] [ ] = GtpUtils . parseStringBoard ( response , size ) ; GuiBoardUtils . showStringBoard ( guiBoard , b ) ; } break ; case AnalyzeCommand . VAR : { showVariation ( guiBoard , response , board . getToMove ( ) ) ; } break ; case AnalyzeCommand . VARB : { showVariation ( guiBoard , response , GoColor . BLACK ) ; } break ; case AnalyzeCommand . VARC : { showVariation ( guiBoard , response , command . getColorArg ( ) ) ; } break ; case AnalyzeCommand . VARW : { showVariation ( guiBoard , response , GoColor . WHITE ) ; } break ; case AnalyzeCommand . VARP : { GoColor c = getColor ( board , pointArg , pointListArg ) ; if ( c != GoColor . EMPTY ) showVariation ( guiBoard , response , c ) ; } break ; case AnalyzeCommand . VARPO : { GoColor c = getColor ( board , pointArg , pointListArg ) ; if ( c != GoColor . EMPTY ) showVariation ( guiBoard , response , c . otherColor ( ) ) ; } break ; default : break ; } return statusText ; }	GuiBoardUtil . showPointStringList ( guiBoard , pointList ,
return ( Snip ) cacheMap . get ( name ) ; <CTX> public Snip storageLoad ( String name ) { return ( Snip ) cacheMap . get ( name ) ; }	return ( Snip ) cacheMap . get ( name . toUpperCase ( ) ) ;
return getInputMethodListeners ( ) ; <CTX> public EventListener [ ] getListeners ( Class < ? > listenerType ) { if ( ComponentListener . class . isAssignableFrom ( listenerType ) ) { return getComponentListeners ( ) ; } else if ( FocusListener . class . isAssignableFrom ( listenerType ) ) { return getFocusListeners ( ) ; } else if ( HierarchyBoundsListener . class . isAssignableFrom ( listenerType ) ) { return getHierarchyBoundsListeners ( ) ; } else if ( HierarchyListener . class . isAssignableFrom ( listenerType ) ) { return getHierarchyListeners ( ) ; } else if ( InputMethodListener . class . isAssignableFrom ( listenerType ) ) { return getInputMethodListeners ( ) ; } else if ( KeyListener . class . isAssignableFrom ( listenerType ) ) { return getKeyListeners ( ) ; } else if ( MouseWheelListener . class . isAssignableFrom ( listenerType ) ) { return getMouseWheelListeners ( ) ; } else if ( MouseMotionListener . class . isAssignableFrom ( listenerType ) ) { return getMouseMotionListeners ( ) ; } else if ( MouseListener . class . isAssignableFrom ( listenerType ) ) { return getMouseListeners ( ) ; } else if ( PropertyChangeListener . class . isAssignableFrom ( listenerType ) ) { return getPropertyChangeListeners ( ) ; } return new EventListener [ 0 ] ; }	return ( T [ ] ) getInputMethodListeners ( ) ;
else return null ; <CTX> public Profile selectProfile ( List profiles , ClientConnectionManager ccm ) { if ( profiles . size ( ) > 0 ) return ( Profile ) profiles . get ( 0 ) ; else return null ; }	} return null ;
return parentBackgroundColor ; <CTX> public Color getBackground ( Object element ) { if ( element instanceof ITaskContainer ) { return parentBackgroundColor ; } else { return super . getBackground ( element ) ; } }	return categoryBackgroundColor ;
create ( members [ i ] , bodyDeclarations , declaringCuNode , rewrite ) ; <CTX> private void createAll ( MemberActionInfo [ ] members , List bodyDeclarations , CompilationUnit declaringCuNode , OldASTRewrite rewrite ) throws JavaModelException { for ( int i = 0 ; i < members . length ; i ++ ) { create ( members [ i ] , bodyDeclarations , declaringCuNode , rewrite ) ; } }	create ( members [ i ] , declaration , declaringCuNode , mapping , rewrite ) ;
&& endDayOfWeek == zone . endDayOfWeek && endTime == zone . endTime ) ; <CTX> public boolean hasSameRules ( TimeZone other ) { if ( this == other ) return true ; if ( ! ( other instanceof SimpleTimeZone ) ) return false ; SimpleTimeZone zone = ( SimpleTimeZone ) other ; if ( zone . hashCode ( ) != hashCode ( ) || rawOffset != zone . rawOffset || useDaylight != zone . useDaylight ) return false ; if ( ! useDaylight ) return true ; return ( startYear == zone . startYear && startMonth == zone . startMonth && startDay == zone . startDay && startDayOfWeek == zone . startDayOfWeek && startTime == zone . startTime && endMonth == zone . endMonth && endDay == zone . endDay && endDayOfWeek == zone . endDayOfWeek && endTime == zone . endTime ) ; }	&& endDayOfWeek == zone . endDayOfWeek && endTime == zone . endTime && endTimeMode == zone . endTimeMode ) ;
return Collections . EMPTY_LIST ; <CTX> public List childNodes ( ) { return Collections . EMPTY_LIST ; }	return EMPTY_LIST ;
return Collections . EMPTY_LIST ; <CTX> public List childNodes ( ) { return Collections . EMPTY_LIST ; }	return EMPTY_LIST ;
usages . add ( usageNode . getUsage ( ) ) ; <CTX> private void collectUsages ( DefaultMutableTreeNode node , Set < Usage > usages ) { if ( node instanceof UsageNode ) { UsageNode usageNode = ( UsageNode ) node ; usages . add ( usageNode . getUsage ( ) ) ; } Enumeration enumeration = node . children ( ) ; while ( enumeration . hasMoreElements ( ) ) { DefaultMutableTreeNode child = ( DefaultMutableTreeNode ) enumeration . nextElement ( ) ; collectUsages ( child , usages ) ; } }	final Usage usage = usageNode . getUsage ( ) ; if ( usage != null && usage . isValid ( ) ) { usages . add ( usage ) ; }
this . path = calculatePath ( dirPath , name ) ; <CTX> public File ( String dirPath , String name ) { if ( name != null ) { if ( dirPath == null ) { this . path = name ; } else { this . path = calculatePath ( dirPath , name ) ; } } else throw new NullPointerException ( ) ; }	this . path = calculatePath ( dir . getPath ( ) , name ) ;
return JFaceResources . getImageRegistry ( ) . get ( Dialog . DLG_IMG_INFO ) ; <CTX> protected Image getImage ( ) { return JFaceResources . getImageRegistry ( ) . get ( Dialog . DLG_IMG_INFO ) ; }	return getShell ( ) . getDisplay ( ) . getSystemImage ( SWT . ICON_INFORMATION ) ;
this . blkid = r . nextLong ( ) ; <CTX> public Block ( ) { this . blkid = r . nextLong ( ) ; this . len = 0 ; }	this . blkid = 0 ;
ICDIMemoryBlock createMemoryBlock ( String address , int length ) <CTX> ICDIMemoryBlock createMemoryBlock ( String address , int length ) throws CDIException ;	ICDIMemoryBlock createMemoryBlock ( String address , int units , int wordSize )
return ActionFormList . ACTIONS . size ( ) + 1 ; <CTX> public int getSize ( ) { return ActionFormList . ACTIONS . size ( ) + 1 ; }	return actions . size ( ) + 1 ;
if ( ! tryToMakeAccessible ( method ) ) { <CTX> Object invoke ( Object target , Object [ ] args ) { Method method = method ( ) ; try { try { return method . invoke ( target , args ) ; } catch ( IllegalAccessException ex ) { Method accessible = searchAccessibleMethod ( method , argTypes ) ; if ( accessible != null ) { memberObject = accessible ; method = accessible ; } else { if ( ! tryToMakeAccessible ( method ) ) { throw Context . throwAsScriptRuntimeEx ( ex ) ; } } / / Retry after recovery return method . invoke ( target , args ) ; } } catch ( IllegalAccessException ex ) { throw Context . throwAsScriptRuntimeEx ( ex ) ; } catch ( InvocationTargetException ex ) { throw Context . throwAsScriptRuntimeEx ( ex ) ; } }	if ( ! VMBridge . instance . tryToMakeAccessible ( method ) ) {
if ( src != dst || srcIdx >= ( dstIdx + BYTES_IN_ADDRESS / BYTES_IN_CHAR ) ) { VM_Memory . arraycopy 16 Bit ( src , srcIdx , dst , dstIdx , len ) ; <CTX> public static void arraycopy ( char [ ] src , int srcIdx , char [ ] dst , int dstIdx , int len ) { / / Don t do any of the assignments if the offsets and lengths / / are in error if ( srcIdx >= 0 && dstIdx >= 0 && len >= 0 && ( srcIdx + len ) >= 0 && ( srcIdx + len ) <= src . length && ( dstIdx + len ) >= 0 && ( dstIdx + len ) <= dst . length ) { if ( src != dst || srcIdx >= ( dstIdx + BYTES_IN_ADDRESS / BYTES_IN_CHAR ) ) { VM_Memory . arraycopy 16 Bit ( src , srcIdx , dst , dstIdx , len ) ; } else { arraycopyOverlap ( src , srcIdx , dst , dstIdx , len ) ; } } else { failWithIndexOutOfBoundsException ( ) ; } }	if ( src != dst || srcIdx >= ( dstIdx + BYTES_IN_ADDRESS ) ) { VM_Memory . arraycopy 8 Bit ( src , srcIdx , dst , dstIdx , len ) ;
vmode = ruby . getInterpreter ( ) . getScope_vmode ( ) ; <CTX> public void push ( NODE v , NODE b , RubyObject newSelf ) { RubyBlock oldBlock = new RubyBlock ( var , body , self , frame , scope , klass , iter , vmode , flags , dynamicVars , origThread , prev , ruby ) ; var = v ; body = b ; self = newSelf ; frame = ruby . getInterpreter ( ) . getRubyFrame ( ) ; klass = ruby . getInterpreter ( ) . getRuby_class ( ) ; / /_block . frame . file = ruby_sourcefile ; / /_block . frame . line = ruby_sourceline ; scope = ruby . rubyScope ; prev = oldBlock ; iter = ruby . getInterpreter ( ) . getRubyIter ( ) . getIter ( ) ; vmode = ruby . getInterpreter ( ) . getScope_vmode ( ) ; flags = BLOCK_D_SCOPE ; dynamicVars = ruby . getInterpreter ( ) . getDynamicVars ( ) ; }	vmode = ruby . getInterpreter ( ) . getActMethodScope ( ) ;
Browser browser = getBrowser ( ( WebBrowserEditor ) part ) ; <CTX> public void partOpened ( IWorkbenchPart part ) { if ( part instanceof WebBrowserEditor ) { currentBrowserPart = part ; / / ( ( WebBrowserEditor ) part ) . get ` Browser browser = getBrowser ( ( WebBrowserEditor ) part ) ; if ( browser != null ) { browser . addLocationListener ( urlTrackingListener ) ; } } / / else if ( part instanceof MylarTaskEditor ) { / / currentBrowserPart = part ; / / Browser browser = ( ( MylarTaskEditor ) part ) . getWebBrowser ( ) ; / / if ( browser != null ) / / browser . addLocationListener ( urlTrackingListener ) ; / / } }	final Browser browser = getBrowser ( ( WebBrowserEditor ) part ) ;
if ( needSame ) { if ( decl != first ) { throw new ParserSymbolTableException ( ParserSymbolTableException . r_AmbiguousName ) ; <CTX> static private Declaration ResolveAmbiguities ( LookupData data , LinkedList items ) throws ParserSymbolTableException { Declaration decl = null ; int size = items . size ( ) ; if ( size == 0 ) { return null ; } else if ( size == 1 ) { return ( Declaration ) items . getFirst ( ) ; } else { Declaration first = ( Declaration ) items . removeFirst ( ) ; / / if first one is a class - name , the next ones hide it if ( first . getType ( ) >= Declaration . t_class && first . getType ( ) <= Declaration . t_enumeration ) { return ResolveAmbiguities ( data , items ) ; } / / else , if the first is an object ( ie not a function ) , the rest must be the same / / declaration . otherwise ( ie it is a function ) , the rest must be functions . boolean needSame = ( first . getType ( ) != Declaration . t_function ) ; Iterator iter = items . iterator ( ) ; for ( int i = ( size - 1 ) ; i > 0 ; i -- ) { decl = ( Declaration ) iter . next ( ) ; if ( needSame ) { if ( decl != first ) { throw new ParserSymbolTableException ( ParserSymbolTableException . r_AmbiguousName ) ; } } else { if ( decl . getType ( ) != Declaration . t_function ) { throw new ParserSymbolTableException ( ParserSymbolTableException . r_AmbiguousName ) ; } } } if ( needSame ) { return first ; } else { items . addFirst ( first ) ; return ResolveFunction ( data , items ) ; } } }	if ( decl . isType ( TypeInfo . t_function ) ) { if ( functionList == null ) { functionList = new LinkedList ( ) ;
return ( state != STATE_DEAD ) ; <CTX> public boolean isAlive ( ) { return ( state != STATE_DEAD ) ; }	return isAlive ;
return leftFilter . accept ( object ) || rightFilter . accept ( object ) ; <CTX> public boolean accept ( Object object ) { return leftFilter . accept ( object ) || rightFilter . accept ( object ) ; }	return leftFilter . accept ( message ) || rightFilter . accept ( message ) ;
Macros . runScript ( null , new File ( directory , snippets [ i ] ) . getPath ( ) , true ) ; <CTX> private static void runStartupScripts ( File directory ) { if ( ! directory . isDirectory ( ) ) return ; String [ ] snippets = directory . list ( ) ; if ( snippets == null ) return ; MiscUtilities . quicksort ( snippets , new MiscUtilities . StringICaseCompare ( ) ) ; for ( int i = 0 ; i < snippets . length ; ++ i ) { Macros . runScript ( null , new File ( directory , snippets [ i ] ) . getPath ( ) , true ) ; } } / / } } }	File snippet = snippets [ i ] ; Macros . Handler handler = Macros . getHandlerForFileName ( snippet . getName ( ) ) ; if ( handler == null ) continue ; try { Macros . Macro newMacro = handler . createMacro ( snippet . getName ( ) , snippet . getPath ( ) ) ; handler . runMacro ( null , newMacro , false ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , jEdit . class , e ) ; }
return ourNotAntElementFilter ; <CTX> protected ElementFilter createAttributeCompletionFilter ( ) { return ourNotAntElementFilter ; }	return TrueFilter . INSTANCE ;
String result = iter . getString ( expression ) ; <CTX> private void refreshValues ( ) { resultList . clear ( ) ; if ( columnChooser . isEnabled ( ) ) { try { BaseQueryDefinition query = ( BaseQueryDefinition ) DataSetManager . getCurrentInstance ( ) . getPreparedQuery ( getDataSetHandle ( ) ) . getReportQueryDefn ( ) ; String queryExpr = null ; for ( int i = 0 ; i < columns . length ; i ++ ) { if ( columns [ i ] . getName ( ) . equals ( columnChooser . getText ( ) ) ) { queryExpr = DEUtil . getExpression ( columns [ i ] ) ; break ; } } if ( queryExpr == null ) { return ; } ScriptExpression expression = new ScriptExpression ( queryExpr ) ; query . addExpression ( expression , BaseTransform . ON_EACH_ROW ) ; IPreparedQuery preparedQuery = DataSetManager . getCurrentInstance ( ) . getEngine ( ) . prepare ( ( IQueryDefinition ) query ) ; IQueryResults results = preparedQuery . execute ( null ) ; if ( results != null ) { IResultIterator iter = results . getResultIterator ( ) ; if ( iter != null ) { while ( iter . next ( ) ) { String result = iter . getString ( expression ) ; if ( ! StringUtil . isBlank ( result ) && ! resultList . contains ( result ) ) { resultList . add ( result ) ; } } } results . close ( ) ; } } catch ( Exception e ) { ExceptionHandler . handle ( e ) ; valueList . removeAll ( ) ; valueList . deselectAll ( ) ; updateButtons ( ) ; } filteValues ( ) ; } else { valueList . removeAll ( ) ; valueList . deselectAll ( ) ; updateButtons ( ) ; } }	String result = null ; if ( selectedColumn . getDataType ( ) == DataType . DATE_TYPE ) { result = formater . format ( iter . getDate ( expression ) ) ; } else { result = iter . getString ( expression ) ; }
super ( ValueType . FLOAT_TYPE , <CTX> private FloatEqualEvaluator ( ) { super ( ValueType . FLOAT_TYPE , Operator . EQUAL ) ; }	super ( ValueType . PFLOAT_TYPE ,
Object rval = execSub ( cx , thisObj , args , funObj , true , funObj ) ; <CTX> public static Object test ( Context cx , Scriptable thisObj , Object [ ] args , Function funObj ) { Object rval = execSub ( cx , thisObj , args , funObj , true , funObj ) ; if ( rval == null || ! rval . equals ( Boolean . TRUE ) ) rval = Boolean . FALSE ; return rval ; }	Object rval = execSub ( cx , thisObj , args , funObj , TEST , funObj ) ;
a = mProv . get ( AccountBy . NAME , key ) ; <CTX> private Account lookupAccount ( String key ) throws ServiceException { Account a = null ; switch ( guessType ( key ) ) { case BY_ID : a = mProv . get ( AccountBy . ID , key ) ; break ; case BY_EMAIL : a = mProv . get ( AccountBy . NAME , key ) ; break ; case BY_NAME : a = mProv . get ( AccountBy . NAME , key ) ; break ; } if ( a == null ) throw AccountServiceException . NO_SUCH_ACCOUNT ( key ) ; else return a ; }	a = mProv . get ( AccountBy . name , key ) ;
if ( cElement != null ) editorPart = EditorUtility . openInEditor ( cElement ) ; <CTX> private boolean openTypeInEditor ( ITypeReference location ) { ICElement cElement = location . getCElement ( ) ; IEditorPart editorPart = null ; try { if ( cElement != null ) editorPart = EditorUtility . openInEditor ( cElement ) ; if ( editorPart == null ) { / / open as external file IPath path = location . getLocation ( ) ; if ( path != null ) { IStorage storage = new FileStorage ( path ) ; editorPart = EditorUtility . openInEditor ( storage ) ; } } / / highlight the type in the editor if ( editorPart != null && editorPart instanceof ITextEditor ) { ITextEditor editor = ( ITextEditor ) editorPart ; editor . selectAndReveal ( location . getOffset ( ) , location . getLength ( ) ) ; return true ; } } catch ( CModelException ex ) { ex . printStackTrace ( ) ; return false ; } catch ( PartInitException ex ) { ex . printStackTrace ( ) ; return false ; } return false ; }	if ( unit != null ) editorPart = EditorUtility . openInEditor ( unit ) ;
inputParameterGroup . clearContents ( IParameterGroupModel . PARAMETERS_SLOT ) ; for ( Iterator iter = inputParameters . iterator ( ) ; iter . hasNext ( ) ; ) { Object obj = iter . next ( ) ; if ( obj instanceof ScalarParameterHandle ) { ScalarParameterHandle param = ( ScalarParameterHandle ) obj ; inputParameterGroup . getParameters ( ) . add ( param ) ; } } <CTX> protected void okPressed ( ) { try { inputParameterGroup . clearContents ( IParameterGroupModel . PARAMETERS_SLOT ) ; for ( Iterator iter = inputParameters . iterator ( ) ; iter . hasNext ( ) ; ) { Object obj = iter . next ( ) ; if ( obj instanceof ScalarParameterHandle ) { ScalarParameterHandle param = ( ScalarParameterHandle ) obj ; inputParameterGroup . getParameters ( ) . add ( param ) ; } } inputParameterGroup . setName ( cascadingNameEditor . getText ( ) ) ; inputParameterGroup . setDataSet ( dataSet ) ; } catch ( SemanticException e ) { ExceptionHandler . handle ( e ) ; cascadingNameEditor . setFocus ( ) ; return ; } setResult ( inputParameterGroup ) ; super . okPressed ( ) ; }	saveParameterProperties ( ) ;
TSOTransaction ( TSOObjectStore ostore , ClassLoader loader , long time , long tiebreaker , DataSpace mainDataSpace ) { <CTX> TSOTransaction ( TSOObjectStore ostore , ClassLoader loader , long time , long tiebreaker , DataSpace mainDataSpace ) { this . ostore = ostore ; this . loader = loader ; transactionID = new StatisticalUUID ( ) ; this . time = time ; this . tiebreaker = tiebreaker ; this . mainDataSpace = mainDataSpace ; }	TSOTransaction ( TSOObjectStore ostore , ClassLoader loader , long creationTime , long tiebreaker , DataSpace mainDataSpace ) {
return null ; <CTX> public List getClusters ( ) { return null ; }	return clusters ;
return master . execMethod ( methodId , this , cx , scope , thisObj , args ) ; <CTX> public Object call ( Context cx , Scriptable scope , Scriptable thisObj , Object [ ] args ) throws JavaScriptException { return master . execMethod ( methodId , this , cx , scope , thisObj , args ) ; }	return master . execMethod ( this , cx , scope , thisObj , args ) ;
return SIZE ; <CTX> public Dimension getPreferredSize ( int wHint , int hHint ) { return SIZE ; }	return new Dimension ( prefSize ) ;
Reaction [ ] reactions = reactionSet . getReactions ( ) ; for ( int i = 0 ; i < reactions . length ; i ++ ) { paintReaction ( reactions [ i ] , graphics ) ; <CTX> public void paintSetOfReactions ( SetOfReactions reactionSet , Graphics graphics ) { Reaction [ ] reactions = reactionSet . getReactions ( ) ; for ( int i = 0 ; i < reactions . length ; i ++ ) { paintReaction ( reactions [ i ] , graphics ) ; } }	Reaction [ ] reactions = reactionSet . getReactions ( ) ; for ( int i = 0 ; i < reactions . length ; i ++ ) { paintReaction ( reactions [ i ] , graphics ) ; }
resultSet . updateShort ( columnIndex , x ) ; <CTX> public void updateShort ( int columnIndex , short x ) throws SQLException { resultSet . updateShort ( columnIndex , x ) ; }	getResultSet ( ) . updateShort ( columnIndex , x ) ;
getExecutionDegree ( ) . getDegree ( ) . getDegreeType ( ) , degreeCandidacy ) ; <CTX> protected Registration createRegistration ( ) { final DegreeCandidacy degreeCandidacy = getDegreeCandidacy ( ) ; final Registration registration = new Registration ( getDegreeCandidacy ( ) . getPerson ( ) , Student . generateStudentNumber ( ) , StudentKind . readByStudentType ( StudentType . NORMAL ) , new StudentState ( StudentState . INSCRITO ) , Boolean . valueOf ( false ) , Boolean . valueOf ( false ) , getExecutionDegree ( ) . getDegree ( ) . getDegreeType ( ) , degreeCandidacy ) ; registration . getStudent ( ) . setPersonalDataAuthorizationForCurrentExecutionYear ( getDegreeCandidacy ( ) . getStudentPersonalDataAuthorizationChoice ( ) ) ; if ( getDegreeCandidacy ( ) . getApplyForResidence ( ) ) { registration . getStudent ( ) . setResidenceCandidacyForCurrentExecutionYear ( getDegreeCandidacy ( ) . getNotesAboutResidenceAppliance ( ) ) ; } return registration ; }	degreeCandidacy ) ;
boolean trace ) { super ( trace ) ; <CTX> protected TFTPBase ( INetworkImplBase network , boolean trace ) { super ( trace ) ; this . network = network ; }	OutputStream debug ) { super ( debug ) ;
int countFieldsToPrint ( ReadablePeriod period , int stopAt , Locale iLocale ) ; <CTX> int countFieldsToPrint ( ReadablePeriod period , int stopAt , Locale iLocale ) ;	int countFieldsToPrint ( ReadablePeriod period , int stopAt , Locale locale ) ;
LinkedList list = CSearchPattern . scanForParameters ( signature ) ; char [ ] [ ] parameters = new char [ 0 ] [ ] ; parameters = ( char [ ] [ ] ) list . toArray ( parameters ) ; return parameters ; <CTX> private char [ ] [ ] getFunctionSignature ( ) { String signature = ( String ) tagExtensionField . get ( CTagsConsoleParser . SIGNATURE ) ; LinkedList list = CSearchPattern . scanForParameters ( signature ) ; char [ ] [ ] parameters = new char [ 0 ] [ ] ; parameters = ( char [ ] [ ] ) list . toArray ( parameters ) ; return parameters ; }	return CSearchPattern . scanForParameters ( signature ) ;
addEntries ( new Entry [ ] { entry } , force ) ; <CTX> public void addEntry ( Entry entry , boolean force ) throws IOException { addEntries ( new Entry [ ] { entry } , force ) ; }	addEntry ( entry , false ) ;
if ( featureId . regionMatches ( prefixLength , Constants . LOAD_DTD_GRAMMAR_FEATURE , 0 , Constants . LOAD_DTD_GRAMMAR_FEATURE . length ( ) ) ) { <CTX> protected void checkFeature ( String featureId ) throws XMLConfigurationException { / / / / Xerces Features / / if ( featureId . startsWith ( Constants . XERCES_FEATURE_PREFIX ) ) { final int prefixLength = Constants . XERCES_FEATURE_PREFIX . length ( ) ; / / / / http : / / apache . org / xml / features / validation / dynamic / / Allows the parser to validate a document only when it / / contains a grammar . Validation is turned on / off based / / on each document instance , automatically . / / if ( featureId . regionMatches ( prefixLength , Constants . DYNAMIC_VALIDATION_FEATURE , 0 , Constants . DYNAMIC_VALIDATION_FEATURE . length ( ) ) ) { return ; } / / / / http : / / apache . org / xml / features / validation / default - attribute - values / / if ( featureId . regionMatches ( prefixLength , Constants . DEFAULT_ATTRIBUTE_VALUES_FEATURE , 0 , Constants . DEFAULT_ATTRIBUTE_VALUES_FEATURE . length ( ) ) ) { / / REVISIT short type = XMLConfigurationException . NOT_SUPPORTED ; throw new XMLConfigurationException ( type , featureId ) ; } / / / / http : / / apache . org / xml / features / validation / default - attribute - values / / if ( featureId . regionMatches ( prefixLength , Constants . VALIDATE_CONTENT_MODELS_FEATURE , 0 , Constants . VALIDATE_CONTENT_MODELS_FEATURE . length ( ) ) ) { / / REVISIT short type = XMLConfigurationException . NOT_SUPPORTED ; throw new XMLConfigurationException ( type , featureId ) ; } / / / / http : / / apache . org / xml / features / validation / nonvalidating / load - dtd - grammar / / if ( featureId . regionMatches ( prefixLength , Constants . LOAD_DTD_GRAMMAR_FEATURE , 0 , Constants . LOAD_DTD_GRAMMAR_FEATURE . length ( ) ) ) { return ; } / / / / http : / / apache . org / xml / features / validation / nonvalidating / load - external - dtd / / if ( featureId . regionMatches ( prefixLength , Constants . LOAD_EXTERNAL_DTD_FEATURE , 0 , Constants . LOAD_EXTERNAL_DTD_FEATURE . length ( ) ) ) { return ; } / / / / http : / / apache . org / xml / features / validation / default - attribute - values / / if ( featureId . regionMatches ( prefixLength , Constants . VALIDATE_DATATYPES_FEATURE , 0 , Constants . VALIDATE_DATATYPES_FEATURE . length ( ) ) ) { short type = XMLConfigurationException . NOT_SUPPORTED ; throw new XMLConfigurationException ( type , featureId ) ; } } / / / / Not recognized / / super . checkFeature ( featureId ) ; } / / checkFeature ( String )	if ( suffixLength == Constants . LOAD_DTD_GRAMMAR_FEATURE . length ( ) && featureId . endsWith ( Constants . LOAD_DTD_GRAMMAR_FEATURE ) ) {
XObject xobject = XObject . create ( value ) ; <CTX> public void setParameter ( String name , String namespace , Object value ) { VariableStack varstack = getXPathContext ( ) . getVarStack ( ) ; QName qname = new QName ( namespace , name ) ; XObject xobject = XObject . create ( value ) ; StylesheetRoot sroot = m_stylesheetRoot ; Vector vars = sroot . getVariablesAndParamsComposed ( ) ; int i = vars . size ( ) ; while ( -- i >= 0 ) { ElemVariable variable = ( ElemVariable ) vars . elementAt ( i ) ; if ( variable . getXSLToken ( ) == Constants . ELEMNAME_PARAMVARIABLE && variable . getName ( ) . equals ( qname ) ) { varstack . setGlobalVariable ( i , xobject ) ; } } }	XObject xobject = XObject . create ( value , getXPathContext ( ) ) ;
overwrite , jdkName , jdkLevel , wildcardResourcePatterns , ideaVersion ) ; <CTX> private void rewriteProject ( ) throws MojoExecutionException { IdeaProjectMojo mojo = new IdeaProjectMojo ( ) ; mojo . initParam ( project , artifactFactory , localRepo , artifactResolver , artifactMetadataSource , getLog ( ) , overwrite , jdkName , jdkLevel , wildcardResourcePatterns , ideaVersion ) ; mojo . execute ( ) ; }	overwrite , jdkName , jdkLevel , wildcardResourcePatterns , ideaVersion , macros ) ;
if (_step != null ) return_step ; if (_exp == null ) return null ; <CTX> public Step getStep ( ) { if (_step != null ) return_step ; if (_exp == null ) return null ; if (_exp instanceof EqualityExpr ) { EqualityExpr exp = ( EqualityExpr )_exp ; Expression left = exp . getLeft ( ) ; Expression right = exp . getRight ( ) ; if ( left instanceof CastExpr ) left = ( ( CastExpr ) left ) . getExpr ( ) ; if ( left instanceof Step )_step = ( Step ) left ; if ( right instanceof CastExpr ) right = ( ( CastExpr ) right ) . getExpr ( ) ; if ( right instanceof Step )_step = ( Step ) right ; } return_step ; }	if (_step != null ) { return_step ; } if (_exp == null ) { return null ; }
myDocument = document ; <CTX> public DocumentFoldingInfo ( Project project , Document document ) { myProject = project ; myDocument = document ; }	myFile = FileDocumentManager . getInstance ( ) . getFile ( document ) ;
if ( dim < 0 ) return 0 ; if ( dim + width > max ) return max - width ; <CTX> private int checkBounds ( int dim , int max , int width ) { if ( dim < 0 ) return 0 ; if ( dim + width > max ) return max - width ; return dim ; }	if ( ! scrollThroughBorders ) { if ( dim < 0 ) return 0 ; if ( dim + width > max ) return max - width ; } else { if ( dim < 0 ) return dim + max - width ; if ( dim + width > max ) return dim + width - max ; }
if ( (_uname == null ) || (_passwd == null ) ) { <CTX> public Connection createConnection ( ) throws SQLException { if ( null ==_props ) { if ( (_uname == null ) || (_passwd == null ) ) { return DriverManager . getConnection (_connectUri ) ; } else { return DriverManager . getConnection (_connectUri ,_uname ,_passwd ) ; } } else { return DriverManager . getConnection (_connectUri ,_props ) ; } }	if ( (_uname == null ) && (_passwd == null ) ) {
String parameterName , <CTX> public IASTParameterDeclaration createParameterDeclaration ( boolean isConst , boolean isVolatile , IASTTypeSpecifier getTypeSpecifier , List pointerOperators , List arrayModifiers , List parameters , ASTPointerOperator pointerOp , String parameterName , IASTInitializerClause initializerClause , int startingOffset , int startingLine , int nameOffset , int nameEndOffset , int nameLine , int endingOffset , int endingLine , char [ ] fn ) { / / TODO Auto - generated method stub return null ; }	char [ ] parameterName ,
return NativeError . getMessage ( errorObject ) ; <CTX> public String getMessage ( ) { return NativeError . getMessage ( errorObject ) ; }	return errorMessage ;
_ block . iter = ruby_iter . iter ; <CTX> private BLOCK PUSH_BLOCK ( NODE v , NODE b , VALUE self ) { BLOCK_block = new BLOCK ( ) ; / /_block . tag = new_blktag ( ) ;_block . var = v ;_block . body = b ;_block . self = self ;_block . frame = rubyFrame ;_block . klass = ruby_class ; / /_block . frame . file = ruby_sourcefile ; / /_block . frame . line = ruby_sourceline ;_block . scope = getRuby ( ) . rubyScope ;_block . prev = ruby_block ;_block . iter = ruby_iter . iter ;_block . vmode = scope_vmode ;_block . flags = BLOCK_D_SCOPE ;_block . dyna_vars = getDynamicVars ( ) ; ruby_block =_block ; return_block ; }	_ block . iter = rubyIter . getIter ( ) ;
IStructuredSelection selection = ( IStructuredSelection ) fViewer . getSelection ( ) ; <CTX> private Object getSelectedObject ( ) { IStructuredSelection selection = ( IStructuredSelection ) fViewer . getSelection ( ) ; if ( selection . isEmpty ( ) || selection . size ( ) != 1 ) return null ; return selection . getFirstElement ( ) ; }	IStructuredSelection selection = getSelection ( ) ;
charEntry . binaryProperties |= ( 1 << binProp ) ; <CTX> static void setBinaryProperty ( int cp , int binProp ) { UData charEntry = getEntry ( cp ) ; charEntry . binaryProperties |= ( 1 << binProp ) ; }	charEntry . binaryProperties |= ( 1 L << binProp ) ;
destinationStatistics . getMessages ( ) . decrement ( ) ; synchronized ( messages ) { garbageSize ++ ; if ( garbageSize > garbageSizeBeforeCollection ) { gc ( ) ; } } <CTX> public void dropEvent ( ) { / / TODO : need to also decrement when messages expire . destinationStatistics . getMessages ( ) . decrement ( ) ; synchronized ( messages ) { garbageSize ++ ; if ( garbageSize > garbageSizeBeforeCollection ) { gc ( ) ; } } }	dropEvent ( false ) ;
ReportDesign design = ( ReportDesign ) element ; <CTX> public void setTheme ( String name ) throws SemanticException { name = StringUtil . trimString ( name ) ; ReportDesign design = ( ReportDesign ) element ; / / Ensure that the theme exists . Theme theme = null ; Theme oldTheme = design . getTheme ( ) ; if ( name != null ) { theme = getModule ( ) . findTheme ( name ) ; / / the theme in the element is the same with the new set value if ( theme == oldTheme ) return ; if ( theme == null ) throw new StyleException ( element , name , StyleException . DESIGN_EXCEPTION_NOT_FOUND ) ; } else { / / the new name is null and the theme in the element is un - set if ( oldTheme == null ) return ; } design . getActivityStack ( ) . startTrans ( ) ; / / Make the change for the theme property . PropertyCommand propCommand = new PropertyCommand ( module , module ) ; propCommand . setProperty ( IModuleModel . THEME_PROP , name ) ; / / adjust the back references for styles in the theme ThemeRecord themeEffects = new ThemeRecord ( design , theme , oldTheme ) ; design . getActivityStack ( ) . execute ( themeEffects ) ; design . getActivityStack ( ) . commit ( ) ; }	Module currentModule = ( Module ) element ;
return analysis ; <CTX> protected DominatorsAnalysis analyze ( Method method ) throws DataflowAnalysisException , CFGBuilderException { CFG cfg = getCFG ( method ) ; DepthFirstSearch dfs = getDepthFirstSearch ( method ) ; DominatorsAnalysis analysis = new DominatorsAnalysis ( cfg , dfs , true ) ; Dataflow < java . util . BitSet , DominatorsAnalysis > dataflow = new Dataflow < java . util . BitSet , DominatorsAnalysis > ( cfg , analysis ) ; dataflow . execute ( ) ; return analysis ; }	return dataflow ;
else_clause . compile ( comp , flags ) ; <CTX> public void compile ( Compilation comp , int flags ) { test . compile ( comp , 0 ) ; comp . compileConstant ( Interpreter . falseObject ) ; Label else_label = new Label ( comp . method ) ; comp . method . compile_goto_ifeq ( else_label ) ; then_clause . compile ( comp , flags ) ; Label end_label ; if ( else_clause == null && ( flags & IGNORED ) != 0 ) end_label = null ; else { end_label = new Label ( comp . method ) ; if ( comp . method . reachableHere ( ) ) comp . method . compile_goto ( end_label ) ; } else_label . define ( comp . method ) ; if ( else_clause != null ) else_clause . compile ( comp , flags ) ; else if ( ( flags & IGNORED ) == 0 ) comp . compileConstant ( Interpreter . voidObject ) ; if ( end_label != null ) end_label . define ( comp . method ) ; }	else_clause . compile_with_linenumber ( comp , flags ) ;
return buildDone ; <CTX> public boolean shouldRun ( ) { return buildDone ; }	return buildDone && PlatformUI . isWorkbenchRunning ( ) ;
long now =_context . clock ( ) . now ( ) ; <CTX> private void cleanupCloves ( ) { / / this should be in its own thread perhaps ? and maybe_cloves should be / / synced to disk ? List toRemove = new ArrayList ( 32 ) ; long now =_context . clock ( ) . now ( ) ; synchronized (_cloves ) { for ( Iterator iter =_cloves . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { Long id = ( Long ) iter . next ( ) ; Date exp = ( Date )_cloves . get ( id ) ; if ( exp == null ) continue ; / / wtf , not sure how this can happen yet , but i ve seen it . grr . if ( now > exp . getTime ( ) ) toRemove . add ( id ) ; } for ( int i = 0 ; i < toRemove . size ( ) ; i ++ )_cloves . remove ( toRemove . get ( i ) ) ; } }	long now = getContext ( ) . clock ( ) . now ( ) ;
int pointerSizeInBytes ) { <CTX> public MachineDescription ( int charSizeInBytes , int shortSizeInBytes , int intSizeInBytes , int longSizeInBytes , int int 64 SizeInBytes , int floatSizeInBytes , int doubleSizeInBytes , int pointerSizeInBytes ) { this . charSizeInBytes = charSizeInBytes ; this . shortSizeInBytes = shortSizeInBytes ; this . intSizeInBytes = intSizeInBytes ; this . longSizeInBytes = longSizeInBytes ; this . int 64 SizeInBytes = int 64 SizeInBytes ; this . floatSizeInBytes = floatSizeInBytes ; this . doubleSizeInBytes = doubleSizeInBytes ; this . pointerSizeInBytes = pointerSizeInBytes ; }	int pointerSizeInBytes , int structAlignmentInBytes ) {
result = null ; <CTX> public void close ( ) throws SQLException { result = null ; }	super . close ( ) ; result = null ;
return sqlQuery . quoteIdentifier ( name ) ; <CTX> private String quoteId ( String name ) { return sqlQuery . quoteIdentifier ( name ) ; }	return sqlQuery . getDialect ( ) . quoteIdentifier ( name ) ;
Main . getMainFrame ( ) . getTileRack ( ) . setButton ( msg . index , msg . labelAfter , msg . hoteltypeAfter ) ; <CTX> private void handleReviewTileRackButton ( ReviewTileRackButton msg , int direction ) { if ( direction == DIRECTION_BACKWARD ) { Main . getMainFrame ( ) . getTileRack ( ) . setButton ( msg . index , msg . labelBefore , msg . hoteltypeBefore ) ; } else { Main . getMainFrame ( ) . getTileRack ( ) . setButton ( msg . index , msg . labelAfter , msg . hoteltypeAfter ) ; } }	if ( msg . isVisibleAfter ) { Main . getMainFrame ( ) . getTileRack ( ) . setButton ( msg . index , msg . labelAfter , msg . hoteltypeAfter ) ; } else { Main . getMainFrame ( ) . getTileRack ( ) . setButtonVisible ( msg . index , msg . isVisibleAfter ) ; }
getElementsBox ( ) . addNewVersion ( txNumber ) ; <CTX> public void addNewVersion ( int txNumber ) { getElementsBox ( ) . addNewVersion ( txNumber ) ; }	VBox < FunctionalSet < E >> box = elementsRef . get ( ) ; if ( box != null ) { box . addNewVersion ( txNumber ) ; }
hide ( ) ; <CTX> public void actionPerformed ( ActionEvent e ) { hide ( ) ; }	setVisible ( false ) ;
if ( element != null ) { <CTX> private Object findElement ( TreeItem [ ] items ) { for ( int i = 0 ; i < items . length ; i ++ ) { Object element = items [ i ] . getData ( ) ; if ( matcher == null ) return element ; TreeItem parentItem = items [ i ] . getParentItem ( ) ; Object parentElement = null ; if ( parentItem != null ) { parentElement = parentItem . getData ( ) ; } if ( element != null ) { String [ ] label = getMatchNames ( element , parentElement ) ; for ( int j = 0 ; j < label . length ; j ++ ) { if ( matcher . match ( label [ j ] ) ) return element ; } } element = findElement ( items [ i ] . getItems ( ) ) ; if ( element != null ) return element ; } return null ; }	if ( element != null && isMatchable ( element ) ) {
KeyStrokeData data = ( KeyStrokeData )_actionToDataMap . get (_a ) ;_keyToDataMap . remove (_ks ) ; <CTX> public void optionChanged ( OptionEvent < KeyStroke > oce ) { if ( shouldUpdate ( oce . value ,_a ) ) { KeyStrokeData data = ( KeyStrokeData )_actionToDataMap . get (_a ) ;_keyToDataMap . remove (_ks ) ; / / check for conflicting key binding if (_keyToDataMap . containsKey ( oce . value ) &&_shouldCheckConflict ) { / / if new key in map , and shouldUpdate returns true , we are overwriting it KeyStrokeData conflictKSD = ( KeyStrokeData )_keyToDataMap . get ( oce . value ) ; conflictKSD . setKeyStroke ( KeyStrokeOption . NULL_KEYSTROKE ) ;_updateMenuItem ( conflictKSD ) ;_keyToDataMap . remove ( oce . value ) ; DrJava . getConfig ( ) . setSetting ( conflictKSD . getOption ( ) , KeyStrokeOption . NULL_KEYSTROKE ) ; } if ( oce . value != KeyStrokeOption . NULL_KEYSTROKE ) {_keyToDataMap . put ( oce . value , data ) ; } data . setKeyStroke ( oce . value ) ;_updateMenuItem ( data ) ; / / Check associated shift - version s binding Action shiftAction = ( Action ) data . getShiftAction ( ) ; if ( shiftAction != null ) { / /_keyToActionMap . remove ( addShiftModifier (_ks ) ) ; KeyStrokeData shiftKSD = ( KeyStrokeData )_actionToDataMap . get ( shiftAction ) ;_keyToDataMap . remove ( shiftKSD . getKeyStroke ( ) ) ; shiftKSD . setKeyStroke ( addShiftModifier ( oce . value ) ) ;_keyToDataMap . put ( shiftKSD . getKeyStroke ( ) , shiftKSD ) ; / / mapInsert ( addShiftModifier ( oce . value ) , shiftAction ) ; }_ks = oce . value ; } else if (_ks != oce . value ) { DrJava . getConfig ( ) . setSetting ( oce . option ,_ks ) ; } }	KeyStrokeData data =_actionToDataMap . get (_a ) ; if ( data == null ) { return ; } if ( data . equals (_keyToDataMap . get (_ks ) ) ) {_keyToDataMap . remove (_ks ) ; }
abstract Metadata decodeMetadata ( String metadata ) throws ServiceException ; <CTX> abstract Metadata decodeMetadata ( String metadata ) throws ServiceException ;	void decodeMetadata ( String metadata ) throws ServiceException { decodeMetadata ( new Metadata ( metadata , this ) ) ; }
m_ssn = ssn ; m_pssn = ssn . getProtoSession ( ) ; m_pc = pc ; m_query = new Query ( m_pc . getDataSet ( ) . getQuery ( ) , null ) ; <CTX> DataQueryImpl ( Session ssn , PersistentCollection pc ) { m_ssn = ssn ; m_pssn = ssn . getProtoSession ( ) ; m_pc = pc ; m_query = new Query ( m_pc . getDataSet ( ) . getQuery ( ) , null ) ; }	this ( ssn , pc . getDataSet ( ) . getQuery ( ) ) ;
if ( isProtected ( ) && ( f . isPackage ( ) || f . isPublic ( ) ) ) { <CTX> public boolean moreRestrictiveThan ( Flags f ) { if ( isPrivate ( ) && ( f . isProtected ( ) || f . isPackage ( ) || f . isPublic ( ) ) ) { return true ; } if ( isProtected ( ) && ( f . isPackage ( ) || f . isPublic ( ) ) ) { return true ; } if ( isPackage ( ) && f . isPublic ( ) ) { return true ; } return false ; }	if ( isPackage ( ) && ( f . isProtected ( ) || f . isPublic ( ) ) ) {
int totalLength ; if ( localeFromSessionParameter != null ) { totalLength = 1 + localesFromBrowserSetting . length + DEFAULT_LOCALES . length ; } else { totalLength = localesFromBrowserSetting . length + DEFAULT_LOCALES . length ; } <CTX> public Locale [ ] getLocales ( ) { int i = 0 ; if ( localeAware == false ) return null ; int totalLength ; if ( localeFromSessionParameter != null ) { totalLength = 1 + localesFromBrowserSetting . length + DEFAULT_LOCALES . length ; } else { totalLength = localesFromBrowserSetting . length + DEFAULT_LOCALES . length ; } Locale [ ] allLocales = new Locale [ totalLength ] ; / / the highest priority is locale from session parameter ` locale if ( localeFromSessionParameter != null ) { allLocales [ i ++ ] = localeFromSessionParameter ; } / / the second priority is locales from browser setting if ( localesFromBrowserSetting != null ) { System . arraycopy ( localesFromBrowserSetting , 0 , allLocales , i , localesFromBrowserSetting . length ) ; } / / the third priority is uPortal - wide default locales if ( DEFAULT_LOCALES != null ) { System . arraycopy ( DEFAULT_LOCALES , 0 , allLocales , localesFromBrowserSetting . length + i , DEFAULT_LOCALES . length ) ; } return allLocales ; }	int totalLength = getLengthOfSessionParameter ( ) + getLengthOfBrowserSetting ( ) + getLengthOfDefaultLocales ( ) ;
Report report = process ( filename , rule ) ; assertEquals ( expectedResults , report . size ( ) ) ; <CTX> public void runTest ( String filename , int expectedResults , Rule rule ) throws Throwable { Report report = process ( filename , rule ) ; assertEquals ( expectedResults , report . size ( ) ) ; }	assertEquals ( expectedResults , process ( filename , rule ) . size ( ) ) ;
if ( ! f . name . equals ( name ) ) return ( false ) ; if ( f . size != size ) return ( false ) ; if ( f . style != style ) return ( false ) ; return ( true ) ; } <CTX> public boolean equals ( Object obj ) { if ( obj == null ) return ( false ) ; if ( ! ( obj instanceof Font ) ) return ( false ) ; Font f = ( Font ) obj ; if ( ! f . name . equals ( name ) ) return ( false ) ; if ( f . size != size ) return ( false ) ; if ( f . style != style ) return ( false ) ; return ( true ) ; }	return ( f . getName ( ) . equals ( this . getName ( ) ) && f . getFamily ( ) . equals ( this . getFamily ( ) ) && f . getFontName ( ) . equals ( this . getFontName ( ) ) && f . getTransform ( ) . equals ( this . getTransform ( ) ) && f . getSize ( ) == this . getSize ( ) && f . getStyle ( ) == this . getStyle ( ) ) ; }
assertTrue ( sqlServer . sproc_CheckAdminRights ( ADMIN_ID ) ) ; assertFalse ( sqlServer . sproc_CheckAdminRights ( USER_ID ) ) ; <CTX> public void test_sproc_CheckAdminRights ( ) { assertTrue ( sqlServer . sproc_CheckAdminRights ( ADMIN_ID ) ) ; assertFalse ( sqlServer . sproc_CheckAdminRights ( USER_ID ) ) ; assertTrue ( mySql . sproc_CheckAdminRights ( ADMIN_ID ) ) ; assertFalse ( mySql . sproc_CheckAdminRights ( USER_ID ) ) ; assertTrue ( mimer . sproc_CheckAdminRights ( ADMIN_ID ) ) ; assertFalse ( mimer . sproc_CheckAdminRights ( USER_ID ) ) ; }	assertTrue ( sqlServer . sproc_CheckAdminRights ( ADMIN_USER_ID ) ) ; assertFalse ( sqlServer . sproc_CheckAdminRights ( USER_USER_ID ) ) ;
if ( sorter != null ) <CTX> private ViewerSorter getSorter ( CommonSorterDescriptor descriptor ) { ViewerSorter sorter = ( ViewerSorter ) sorters . get ( descriptor ) ; if ( sorter != null ) return sorter ; synchronized ( sorters ) { sorter = ( ViewerSorter ) sorters . get ( descriptor ) ; if ( sorter == null ) sorters . put ( descriptor , sorter = descriptor . createSorter ( ) ) ; } return sorter ; }	if ( sorter != null ) {
releaseLock ( conn , LOCK_TRIGGER_ACCESS , transOwner ) ; closeConnection ( conn ) ; <CTX> public boolean removeTrigger ( SchedulingContext ctxt , String triggerName , String groupName ) throws JobPersistenceException { Connection conn = getConnection ( ) ; boolean transOwner = false ; try { getLockHandler ( ) . obtainLock ( conn , LOCK_TRIGGER_ACCESS ) ; transOwner = true ; return removeTrigger ( conn , ctxt , triggerName , groupName ) ; } finally { releaseLock ( conn , LOCK_TRIGGER_ACCESS , transOwner ) ; closeConnection ( conn ) ; } }	try { releaseLock ( conn , LOCK_TRIGGER_ACCESS , transOwner ) ; } finally { closeConnection ( conn ) ; }
nextSibling = element . getContainingFile ( ) . findElementAt ( element . getTextOffset ( ) + 1 ) ; if ( nextSibling != null ) nextSibling = nextSibling . getParent ( ) ; <CTX> private static boolean filterJspErrors ( final PsiErrorElement element ) { PsiElement nextSibling = element . getNextSibling ( ) ; if ( nextSibling == null ) { nextSibling = element . getContainingFile ( ) . findElementAt ( element . getTextOffset ( ) + 1 ) ; if ( nextSibling != null ) nextSibling = nextSibling . getParent ( ) ; } while ( nextSibling instanceof PsiWhiteSpace ) { nextSibling = nextSibling . getNextSibling ( ) ; } if ( nextSibling instanceof JspText || nextSibling instanceof JspExpression || nextSibling instanceof ELExpressionHolder ) { return true ; } final XmlAttributeValue parentOfType = PsiTreeUtil . getParentOfType ( element , XmlAttributeValue . class ) ; return parentOfType != null && parentOfType . getUserData ( XmlHighlightVisitor . DO_NOT_VALIDATE_KEY ) != null ; }	final PsiFile containingFile = element . getContainingFile ( ) ; if ( containingFile instanceof JspFile ) { nextSibling = ( ( JspFile ) containingFile ) . getBaseLanguageRoot ( ) . findElementAt ( element . getTextOffset ( ) + 1 ) ; }
getSelectedObjects ( ) { if ( selectedIndex == - 1 ) return null ; <CTX> getSelectedObjects ( ) { if ( selectedIndex == - 1 ) return null ; Object [ ] objs = new Object [ 1 ] ; objs [ 0 ] = pItems . elementAt ( selectedIndex ) ; return ( objs ) ; }	public synchronized Object [ ] getSelectedObjects ( ) { if ( selectedIndex == - 1 ) return null ;
return ( RubyString ) self . newString ( self . getValue ( ) + str . getValue ( ) ) . infectBy ( str ) ; <CTX> public IRubyObject invoke ( RubyString self , IRubyObject [ ] args ) { IRubyObject other = args [ 0 ] ; RubyString str = RubyString . stringValue ( other ) ; return ( RubyString ) self . newString ( self . getValue ( ) + str . getValue ( ) ) . infectBy ( str ) ; }	return ( RubyString ) self . newString ( self . toString ( ) + str . toString ( ) ) . infectBy ( str ) ;
return underlinedChar ; <CTX> public int getDisplayedMnemonicIndex ( ) { return underlinedChar ; }	return displayedMnemonicIndex ;
trace . remove ( obj ) ; <CTX> public synchronized void invalidateObject ( Object obj ) throws Exception { if ( config != null && config . getRemoveAbandoned ( ) ) { trace . remove ( obj ) ; } super . invalidateObject ( obj ) ; }	synchronized ( trace ) { trace . remove ( obj ) ; }
LOG . assertTrue ( psiFile != null , fileOrDir . getName ( ) ) ; <CTX> public boolean processFile ( VirtualFile fileOrDir ) { if ( fileOrDir . isDirectory ( ) ) return true ; if ( moduleFileIndex . isInSourceContent ( fileOrDir ) && ( myIncludeTestSource ? true : ! moduleFileIndex . isInTestSourceContent ( fileOrDir ) ) ) { PsiFile psiFile = PsiManager . getInstance ( module . getProject ( ) ) . findFile ( fileOrDir ) ; LOG . assertTrue ( psiFile != null , fileOrDir . getName ( ) ) ; psiFile . accept ( visitor ) ; } return true ; }	if ( psiFile == null ) return true ;
return null ; <CTX> public OSTask [ ] getOSTasks ( Install installer ) { return null ; }	return new OSTask [ 0 ] ;
ErrorDialog . openError ( getShell ( info ) , NLS . bind ( UndoMessages . AbstractWorkspaceOperation_UndoErrorTitle , getLabel ( ) ) , null , e . getStatus ( ) ) ; <CTX> public void run ( ) { ErrorDialog . openError ( getShell ( info ) , NLS . bind ( UndoMessages . AbstractWorkspaceOperation_UndoErrorTitle , getLabel ( ) ) , null , e . getStatus ( ) ) ; }	propagateException [ 0 ] = handleCoreException ( e , getShell ( info ) , NLS . bind ( UndoMessages . AbstractWorkspaceOperation_UndoErrorTitle , getLabel ( ) ) ) ;
emptyWindowContents = getAdvisor ( ) . createEmptyWindowContents ( getWindowConfigurer ( ) , parent ) ; <CTX> private void showEmptyWindowContents ( ) { if ( ! emptyWindowContentsCreated ) { Composite parent = getPageComposite ( ) ; emptyWindowContents = getAdvisor ( ) . createEmptyWindowContents ( getWindowConfigurer ( ) , parent ) ; emptyWindowContentsCreated = true ; / / force the empty window composite to be layed out parent . layout ( ) ; } }	emptyWindowContents = getWindowAdvisor ( ) . createEmptyWindowContents ( parent ) ;
if ( isEditorActivated ) { <CTX> public void setCaretPosition ( int caretPosition ) { if ( isEditorActivated ) { myEditorWindow . myTextLine . setCaretPosition ( caretPosition ) ; myEditorWindow . repaint ( ) ; } else { myCachedCaretPosition = caretPosition ; } }	if ( myEditorActivated ) {
getWorkbenchWindow ( ) . getFastViewBar ( ) . restoreView ( getReference ( ) , true ) ; } <CTX> public void run ( ) { if ( viewPane . getPane ( ) instanceof ViewPane ) { if ( ! isChecked ( ) ) { Rectangle viewBounds = DragUtil . getDisplayBounds ( viewPane . getControl ( ) ) ; Rectangle fvbBounds = DragUtil . getDisplayBounds ( getWorkbenchWindow ( ) . getFastViewBar ( ) . getControl ( ) ) ; RectangleAnimation animation = new RectangleAnimation ( getWorkbenchWindow ( ) . getShell ( ) , viewBounds , fvbBounds ) ; getWorkbenchWindow ( ) . getFastViewBar ( ) . adoptView ( getReference ( ) , - 1 , true , false ) ; animation . schedule ( ) ; } else { getWorkbenchWindow ( ) . getFastViewBar ( ) . restoreView ( getReference ( ) , true ) ; } } }	pane . doRemoveFast ( ) ; }
return nanoseconds ; <CTX> public int getNanos ( ) { return nanoseconds ; }	return nanos ;
data . widthHint = Math . max ( widthHint , button . computeSize ( SWT . DEFAULT , SWT . DEFAULT , true ) . x ) ; <CTX> protected void setButtonLayoutData ( Button button ) { GridData data = new GridData ( GridData . HORIZONTAL_ALIGN_FILL ) ; data . heightHint = convertVerticalDLUsToPixels ( IDialogConstants . BUTTON_HEIGHT ) ; int widthHint = convertHorizontalDLUsToPixels ( IDialogConstants . BUTTON_WIDTH ) ; data . widthHint = Math . max ( widthHint , button . computeSize ( SWT . DEFAULT , SWT . DEFAULT , true ) . x ) ; button . setLayoutData ( data ) ; }	Point minSize = button . computeSize ( SWT . DEFAULT , SWT . DEFAULT , true ) ; data . widthHint = Math . max ( widthHint , minSize . x ) ; data . heightHint = Math . max ( heightHint , minSize . y ) ;
super ( position ) ; <CTX> public CaseNode ( ISourcePosition position , Node caseNode , Node caseBody ) { super ( position ) ; this . caseNode = caseNode ; this . caseBody = caseBody ; }	super ( position , NodeTypes . CASENODE ) ;
Vector v = ( Vector ) pendingCreates . get ( src ) ; <CTX> synchronized Block allocateBlock ( UTF 8 src ) { Block b = new Block ( ) ; Vector v = ( Vector ) pendingCreates . get ( src ) ; v . add ( b ) ; pendingCreateBlocks . add ( b ) ; return b ; }	FileUnderConstruction v = ( FileUnderConstruction ) pendingCreates . get ( src ) ;
cdrBufInput profile = c . read_encapsulation ( ) ; <CTX> public void_read_no_endian ( cdrInput c ) throws IOException , BAD_PARAM { Id = c . read_string ( ) ; int n_profiles = c . read_long ( ) ; if ( n_profiles == 0 ) { Id = null ; Internet = null ; return ; } for ( int i = 0 ; i < n_profiles ; i ++ ) { int tag = c . read_long ( ) ; cdrBufInput profile = c . read_encapsulation ( ) ; if ( tag == Internet_profile . TAG_INTERNET_IOP ) { Internet = new Internet_profile ( ) ; Internet . version = Version . read_version ( profile ) ; Internet . host = profile . read_string ( ) ; Internet . port = profile . gnu_read_ushort ( ) ; key = profile . read_sequence ( ) ; / / Read tagged components . int n_components = 0 ; try { if ( Internet . version . since_inclusive ( 1 , 1 ) ) n_components = profile . read_long ( ) ; for ( int t = 0 ; t < n_components ; t ++ ) { int ctag = profile . read_long ( ) ; if ( ctag == CodeSets_profile . TAG_CODE_SETS ) { Internet . CodeSets . read ( profile ) ; } else { / / Construct a generic component for codesets / / profile . TaggedComponent pc = new TaggedComponent ( ) ; pc . tag = ctag ; pc . component_data = profile . read_sequence ( ) ; Internet . components . add ( pc ) ; } } } catch ( Unexpected ex ) { ex . printStackTrace ( ) ; } } else { / / Construct a generic profile . TaggedProfile p = new TaggedProfile ( ) ; p . tag = tag ; p . profile_data = profile . buffer . getBuffer ( ) ; profiles . add ( p ) ; } } }	BufferredCdrInput profile = c . read_encapsulation ( ) ;
return VMIOUtils . getAPI ( ) . isDirectory ( string ) ; <CTX> static boolean isDirectory ( String string ) { try { return VMIOUtils . getAPI ( ) . isDirectory ( string ) ; } catch ( IOException ex ) { return false ; } }	return VMIOUtils . getAPI ( ) . isDirectory ( getNormalizedPath ( path ) ) ;
return filter . getMarkerLimit ( ) ; } <CTX> private int getMarkerLimit ( ) { MarkerFilter filter = getFilter ( ) ; if ( ! filter . isEnabled ( ) || ! filter . getFilterOnMarkerLimit ( ) ) { return - 1 ; } return filter . getMarkerLimit ( ) ; }	if ( limit >= 0 ) limit = Math . min ( limit , filter . getMarkerLimit ( ) ) ; else limit = filter . getMarkerLimit ( ) ; } return limit ; }
return ( RubyModule ) objectClass . getConstant ( name , false ) ; <CTX> public RubyModule getModule ( String name ) { return ( RubyModule ) objectClass . getConstant ( name , false ) ; }	return ( RubyModule ) objectClass . getConstantAt ( name ) ;
testJobRan = true ; <CTX> public IStatus runInUIThread ( IProgressMonitor monitor ) { testJobRan = true ; return Status . OK_STATUS ; }	backgroundThreadFinishedBeforeUIJob = backgroundThreadFinished ; uiJobFinished = true ;
if ( result . toString ( ) . equals ( name ) ) <CTX> public static MarkerType get ( String name ) { for ( int i = 0 ; i < VALUES_ARRAY . length ; ++ i ) { MarkerType result = VALUES_ARRAY [ i ] ; if ( result . toString ( ) . equals ( name ) ) { return result ; } } return null ; }	if ( result . toString ( ) . equals ( literal ) )
while ( predIter . hasNext ( ) ) <CTX> protected void evaluatePredicates ( List contextNodeSet , ContextSupport support ) throws JaxenException { List newNodeSet = new ArrayList ( ) ; List predicates = getPredicates ( ) ; Iterator predIter = predicates . iterator ( ) ; Predicate eachPred = null ; Object contextNode = null ; int contextSize = 0 ; Object predResult = null ; Context predContext = new Context ( support ) ; while ( predIter . hasNext ( ) ) { eachPred = ( Predicate ) predIter . next ( ) ; contextSize = contextNodeSet . size ( ) ; for ( int i = 0 ; i < contextSize ; ++ i ) { contextNode = contextNodeSet . get ( i ) ; List list = new ArrayList ( 1 ) ; list . add ( contextNode ) ; predContext . setNodeSet ( list ) ; predContext . setPosition ( i + 1 ) ; predContext . setSize ( contextSize ) ; predResult = eachPred . evaluate ( predContext ) ; if ( predResult instanceof Number ) { int proximity = ( ( Number ) predResult ) . intValue ( ) ; if ( proximity == ( i + 1 ) ) { newNodeSet . add ( contextNode ) ; } } else { Boolean includes = BooleanFunction . evaluate ( predResult , predContext . getNavigator ( ) ) ; if ( includes . booleanValue ( ) ) { newNodeSet . add ( contextNode ) ; } } } contextNodeSet . clear ( ) ; contextNodeSet . addAll ( newNodeSet ) ; newNodeSet . clear ( ) ; } }	if ( predIter . hasNext ( ) )
. getElements ( IModuleNameSpace . ARBITARY_LEVEL ) ; <CTX> public List getAllDataSets ( ) { IModuleNameSpace namescope = module . getModuleNameSpace ( Module . DATA_SET_NAME_SPACE ) ; List elementList = namescope . getElements ( IModuleNameSpace . ARBITARY_LEVEL ) ; return generateHandleList ( elementList ) ; }	. getElements ( IModuleNameScope . ARBITARY_LEVEL ) ;
return ( float ) currentSize / ( float ) clientSize ; <CTX> public float getCurrentRatio ( ) { if ( currentPane == null ) { return 0 . 0 f ; } boolean isVertical = ! Geometry . isHorizontal ( side ) ; Rectangle clientArea = clientComposite . getClientArea ( ) ; int clientSize = Geometry . getDimension ( clientArea , isVertical ) ; int currentSize = Geometry . getDimension ( getBounds ( ) , isVertical ) ; return ( float ) currentSize / ( float ) clientSize ; }	return ( float ) size / ( float ) clientSize ;
return this . gitterbutton . isSelected ( ) ; } <CTX> public boolean gitterGewaehlt ( ) { return this . gitterbutton . isSelected ( ) ; } / / gitterGewaehlt ( )	return this . gridButton . isSelected ( ) ; }
if ( breakCallStack ) { return ; } breakCallStack = true ; super . tearDown ( ) ; <CTX> protected void doTearDown ( ) throws Exception { try { s . close ( ) ; } catch ( Exception e ) { } / / avoid infinite recursion resulting in stack overflow if ( breakCallStack ) { return ; } breakCallStack = true ; super . tearDown ( ) ; }	super . doTearDown ( ) ;
RubyArray result = RubyArray . newArray ( getRuntime ( ) , constructors . length ) ; <CTX> public RubyArray constructors ( ) { Constructor [ ] constructors = javaClass . getConstructors ( ) ; RubyArray result = RubyArray . newArray ( getRuntime ( ) , constructors . length ) ; for ( int i = 0 ; i < constructors . length ; i ++ ) { result . append ( new JavaConstructor ( getRuntime ( ) , constructors [ i ] ) ) ; } return result ; }	RubyArray result = getRuntime ( ) . newArray ( constructors . length ) ;
throw new RuntimeException ( ex ) ; <CTX> public void onResponse ( ) { / / we don t have to write variable data -> this already / / happened in the nativeAPI impl FaultData fault = null ; Element response ; try { response = getBpelRuntimeContext ( ) . getPartnerResponse ( mexId ) ; } catch ( Exception ex ) { / / TODO : Better error handling throw new RuntimeException ( ex ) ; } getBpelRuntimeContext ( ) . initializeVariable ( outputVar , response ) ; try { for ( OScope . CorrelationSet anInitCorrelationsOutput :_oinvoke . initCorrelationsOutput ) { initializeCorrelation (_scopeFrame . resolve ( anInitCorrelationsOutput ) , outputVar ) ; } if (_oinvoke . partnerLink . hasPartnerRole ( ) ) { / / Trying to initialize partner epr based on a message - provided epr / session . if ( ! getBpelRuntimeContext ( ) . isPartnerRoleEndpointInitialized (_scopeFrame . resolve (_oinvoke . partnerLink ) ) ) { Node fromEpr = getBpelRuntimeContext ( ) . getSourceEPR ( mexId ) ; if ( fromEpr != null ) { getBpelRuntimeContext ( ) . writeEndpointReference (_scopeFrame . resolve (_oinvoke . partnerLink ) , ( Element ) fromEpr ) ; } } String partnersSessionId = getBpelRuntimeContext ( ) . getSourceSessionId ( mexId ) ; if ( partnersSessionId != null ) getBpelRuntimeContext ( ) . initializePartnersSessionId (_scopeFrame . resolve (_oinvoke . partnerLink ) , partnersSessionId ) ; } } catch ( FaultException e ) {__ log . error ( e ) ; fault = createFault ( e . getQName ( ) ,_oinvoke ) ; } / / TODO update output variable with data from non - initiate / / correlation sets_self . parent . completed ( fault , CompensationHandler . emptySet ( ) ) ; }	throw new RuntimeException ( e ) ;
return RubyArray . newArray ( getRuntime ( ) , ( IRubyObject [ ] ) rubyThreadList . values ( ) . toArray ( new IRubyObject [ rubyThreadList . size ( ) ] ) ) ; <CTX> public IRubyObject list ( ) { return RubyArray . newArray ( getRuntime ( ) , ( IRubyObject [ ] ) rubyThreadList . values ( ) . toArray ( new IRubyObject [ rubyThreadList . size ( ) ] ) ) ; }	return getRuntime ( ) . newArray ( ( IRubyObject [ ] ) rubyThreadList . values ( ) . toArray ( new IRubyObject [ rubyThreadList . size ( ) ] ) ) ;
return indexImpl . terminate ( ) ; <CTX> public Index terminate ( ) { return indexImpl . terminate ( ) ; }	return indexModel . terminate ( ) ;
( Integer ) m_nameToIdMapping . get ( fieldName . toUpperCase ( ) ) ; <CTX> public int getFieldIndex ( String fieldName ) { Integer i = ( Integer ) m_nameToIdMapping . get ( fieldName . toUpperCase ( ) ) ; return ( i == null ) ? - 1 : i . intValue ( ) ; }	( Integer ) m_nameToIdMapping . get ( fieldName ) ;
boolean isPureVirtual , List constructorChain , boolean isDefinition , boolean hasFunctionTryBlock ) throws ASTSemanticException , Exception ; <CTX> public IASTFunction createFunction ( IASTScope scope , ITokenDuple name , List parameters , IASTAbstractDeclaration returnType , IASTExceptionSpecification exception , boolean isInline , boolean isFriend , boolean isStatic , int startOffset , int nameOffset , int nameEndOffset , IASTTemplate ownerTemplate , boolean isConst , boolean isVolatile , boolean isVirtual , boolean isExplicit , boolean isPureVirtual , List constructorChain , boolean isDefinition , boolean hasFunctionTryBlock ) throws ASTSemanticException , Exception ;	boolean isPureVirtual , List constructorChain , boolean isDefinition , boolean hasFunctionTryBlock ) throws ASTSemanticException ;
throws ClassNotFoundException , DataflowAnalysisException { <CTX> private CachedExceptionSet computeBlockExceptionSet ( BasicBlock basicBlock , TypeFrame result ) throws ClassNotFoundException , DataflowAnalysisException { CachedExceptionSet cachedExceptionSet = getCachedExceptionSet ( basicBlock ) ; if ( ! cachedExceptionSet . isUpToDate ( result ) ) { ExceptionSet exceptionSet = computeThrownExceptionTypes ( basicBlock ) ; TypeFrame copyOfResult = createFact ( ) ; copy ( result , copyOfResult ) ; cachedExceptionSet = new CachedExceptionSet ( copyOfResult , exceptionSet ) ; thrownExceptionSetMap . put ( basicBlock , cachedExceptionSet ) ; } return cachedExceptionSet ; }	throws DataflowAnalysisException {
VirtualFileManager . getInstance ( ) . addVirtualFileListener ( myVfsListener ) ; <CTX> public void projectOpened ( ) { VirtualFileManager . getInstance ( ) . addVirtualFileListener ( myVfsListener ) ; StartupManager . getInstance ( myProject ) . registerPostStartupActivity ( new Runnable ( ) { public void run ( ) { markEverythingDirty ( ) ; } } ) ; }	if ( ( ( ApplicationEx ) ApplicationManager . getApplication ( ) ) . isInternal ( ) ) { VirtualFileManager . getInstance ( ) . addVirtualFileListener ( myVfsListener ) ;
Object result = finalResources . get ( className ) ; if ( result == null ) { try { Class cgClass = Class . forName ( className , true , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; result = cgClass . newInstance ( ) ; finalResources . put ( className , result ) ; } catch ( Exception ex ) { log . fatal ( null , ex ) ; } <CTX> public static Object makeCG ( String className ) { Object result = finalResources . get ( className ) ; if ( result == null ) { try { Class cgClass = Class . forName ( className , true , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; result = cgClass . newInstance ( ) ; finalResources . put ( className , result ) ; } catch ( Exception ex ) { log . fatal ( null , ex ) ; } } return result ; }	/ * changed this method due to NoClassDefFoundError at Tomcat startup . * see http : * / Object result = null ; try { Class cgClass = Class . forName ( className , true , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; result = cgClass . newInstance ( ) ; finalResources . put ( className , result ) ; } catch ( Exception ex ) { log . fatal ( null , ex ) ;
throw StandardException . newException ( SQLState . LANG_FILE_ERROR , ioe . toString ( ) , ioe ) ; <CTX> public Object readJarFile ( String schemaName , String sqlName ) throws StandardException { DataDictionaryContext ddc = ( DataDictionaryContext ) ContextService . getContext ( DataDictionaryContext . CONTEXT_ID ) ; DataDictionary dd = ddc . getDataDictionary ( ) ; SchemaDescriptor sd = dd . getSchemaDescriptor ( schemaName , null , true ) ; FileInfoDescriptor fid = dd . getFileInfoDescriptor ( sd , sqlName ) ; if ( fid == null ) throw StandardException . newException ( SQLState . LANG_FILE_DOES_NOT_EXIST , sqlName , schemaName ) ; long generationId = fid . getGenerationId ( ) ; FileResource fr = af . getTransaction ( ddc . getContextManager ( ) ) . getFileHandler ( ) ; String externalName = org . apache . derby . impl . sql . execute . JarDDL . mkExternalName ( schemaName , sqlName , fr . getSeparatorChar ( ) ) ; Object f = fr . getAsFile ( externalName , generationId ) ; if ( f instanceof java . io . File ) return f ; try { return fr . getAsStream ( externalName , generationId ) ; } catch ( java . io . IOException ioe ) { throw StandardException . newException ( SQLState . LANG_FILE_ERROR , ioe . toString ( ) , ioe ) ; } }	throw StandardException . newException ( SQLState . LANG_FILE_ERROR , ioe , ioe . toString ( ) ) ;
xctxt . pushPredicatePos ( i ) ; try <CTX> protected static XObject executePredicates ( XPathContext xctxt , StepPattern prevStep , XObject score , int context , int predicateRootContext ) throws javax . xml . transform . TransformerException { int n = prevStep . getPredicateCount ( ) ; if ( n != 0 ) { try { xctxt . pushCurrentNode ( context ) ; xctxt . pushSubContextList ( prevStep ) ; xctxt . pushPredicateRoot ( predicateRootContext ) ; for ( int i = 0 ; i < n ; i ++ ) { xctxt . pushPredicatePos ( i ) ; try { XObject pred = prevStep . m_predicates [ i ] . execute ( xctxt ) ; if ( XObject . CLASS_NUMBER == pred . getType ( ) ) { int pos = ( int ) pred . num ( ) ; if ( prevStep . getProximityPosition ( xctxt , i ) != pos ) { score = NodeTest . SCORE_NONE ; break ; } } else if ( ! pred . bool ( ) ) { score = NodeTest . SCORE_NONE ; break ; } } finally { xctxt . popPredicatePos ( ) ; } } } finally { xctxt . popCurrentNode ( ) ; xctxt . popSubContextList ( ) ; xctxt . popPredicateRoot ( ) ; } } return score ; }	XObject pred = m_predicates [ i ] . execute ( xctxt ) ; if ( XObject . CLASS_NUMBER == pred . getType ( ) )
( ( RegistryBrowserContentProvider ) treeViewer . getContentProvider ( ) ) . setShowType ( ShowPluginsMenu . SHOW_ALL_PLUGINS ) ; treeViewer . refresh ( ) ; } <CTX> public void run ( ) { ( ( RegistryBrowserContentProvider ) treeViewer . getContentProvider ( ) ) . setShowType ( ShowPluginsMenu . SHOW_ALL_PLUGINS ) ; treeViewer . refresh ( ) ; }	treeViewer . refresh ( ) ; }
return RubyFixnum . newFixnum ( runtime , cal . get ( Calendar . MINUTE ) ) ; <CTX> public RubyInteger min ( ) { return RubyFixnum . newFixnum ( runtime , cal . get ( Calendar . MINUTE ) ) ; }	return getRuntime ( ) . newFixnum ( cal . get ( Calendar . MINUTE ) ) ;
if ( element != null && element . getElementType ( ) == ElementType . JSP_SCRIPTLET_START ) { <CTX> private Block buildBlockForScriptletNode ( final ASTNode child , final Indent indent ) { if ( ! ( child . getPsi ( ) instanceof JspText ) ) return null ; ASTNode element = child . getPsi ( ) . getContainingFile ( ) . getPsiRoots ( ) [ 0 ] . getNode ( ) . findLeafElementAt ( child . getTextRange ( ) . getStartOffset ( ) ) ; if ( element != null && element . getElementType ( ) == ElementType . JSP_SCRIPTLET_START ) { final ArrayList < Block > subBlocks = new ArrayList < Block > ( ) ; while ( element != null && element . getTextRange ( ) . getEndOffset ( ) <= child . getTextRange ( ) . getEndOffset ( ) ) { if ( ! containsWhiteSpacesOnly ( element ) ) { subBlocks . add ( createChildBlock ( element , null , null , Formatter . getInstance ( ) . getNoneIndent ( ) ) ) ; } element = element . getTreeNext ( ) ; } return new SyntheticBlock ( subBlocks , this , indent , myXmlFormattingPolicy , getFormatter ( ) . createNormalIndent ( ) ) ; } else { return null ; } }	if ( element != null && ( element . getElementType ( ) == ElementType . JSP_SCRIPTLET_START || element . getElementType ( ) == ElementType . JSP_DECLARATION_START ) ) {
selectedHostExports . add ( hostExports [ j ] . getExportPackageDescription ( ) ) ; ExportPackageDescription [ ] hostExportsArray = ( ExportPackageDescription [ ] ) selectedHostExports . toArray ( new ExportPackageDescription [ selectedHostExports . size ( ) ] ) ; <CTX> private void stateResolveBundle ( ResolverBundle rb ) { / / Gather selected exports ResolverExport [ ] exports = rb . getSelectedExports ( ) ; ArrayList selectedExports = new ArrayList ( exports . length ) ; for ( int i = 0 ; i < exports . length ; i ++ ) { selectedExports . add ( exports [ i ] . getExportPackageDescription ( ) ) ; } ExportPackageDescription [ ] selectedExportsArray = ( ExportPackageDescription [ ] ) selectedExports . toArray ( new ExportPackageDescription [ selectedExports . size ( ) ] ) ; / / Gather exports that have been wired to ResolverImport [ ] imports = rb . getImportPackages ( ) ; ArrayList exportsWiredTo = new ArrayList ( imports . length ) ; for ( int i = 0 ; i < imports . length ; i ++ ) { if ( imports [ i ] . getMatchingExport ( ) != null ) { exportsWiredTo . add ( imports [ i ] . getMatchingExport ( ) . getExportPackageDescription ( ) ) ; } } ExportPackageDescription [ ] exportsWiredToArray = ( ExportPackageDescription [ ] ) exportsWiredTo . toArray ( new ExportPackageDescription [ exportsWiredTo . size ( ) ] ) ; / / Gather bundles that have been wired to BundleConstraint [ ] requires = rb . getRequires ( ) ; ArrayList bundlesWiredTo = new ArrayList ( requires . length ) ; for ( int i = 0 ; i < requires . length ; i ++ ) if ( requires [ i ] . getMatchingBundle ( ) != null ) bundlesWiredTo . add ( requires [ i ] . getMatchingBundle ( ) . getBundle ( ) ) ; BundleDescription [ ] bundlesWiredToArray = ( BundleDescription [ ] ) bundlesWiredTo . toArray ( new BundleDescription [ bundlesWiredTo . size ( ) ] ) ; BundleDescription [ ] hostBundles = null ; if ( rb . isFragment ( ) ) { ResolverBundle [ ] matchingBundles = rb . getHost ( ) . getMatchingBundles ( ) ; if ( matchingBundles != null && matchingBundles . length > 0 ) { hostBundles = new BundleDescription [ matchingBundles . length ] ; for ( int i = 0 ; i < matchingBundles . length ; i ++ ) { hostBundles [ i ] = matchingBundles [ i ] . getBundle ( ) ; if ( rb . isNewFragmentExports ( ) ) { / / update the host s set of selected exports ResolverBundle hostRB = ( ResolverBundle ) bundleMapping . get ( hostBundles [ i ] ) ; ResolverExport [ ] hostExports = hostRB . getSelectedExports ( ) ; ArrayList selectedHostExports = new ArrayList ( hostExports . length ) ; for ( int j = 0 ; j < hostExports . length ; j ++ ) selectedHostExports . add ( hostExports [ j ] . getExportPackageDescription ( ) ) ; ExportPackageDescription [ ] hostExportsArray = ( ExportPackageDescription [ ] ) selectedHostExports . toArray ( new ExportPackageDescription [ selectedHostExports . size ( ) ] ) ; state . resolveBundle ( hostBundles [ i ] , true , null , hostExportsArray , hostBundles [ i ] . getResolvedRequires ( ) , hostBundles [ i ] . getResolvedImports ( ) ) ; } } } } / / Resolve the bundle in the state state . resolveBundle ( rb . getBundle ( ) , true , hostBundles , selectedExportsArray , bundlesWiredToArray , exportsWiredToArray ) ; }	hostExportsArray [ j ] = hostExports [ j ] . getExportPackageDescription ( ) ;
super . viewTopic ( request , next , topic ) ; <CTX> private void viewTopic ( HttpServletRequest request , ModelAndView next ) throws Exception { String topic = JAMWikiServlet . getTopicFromURI ( request ) ; if ( ! StringUtils . hasText ( topic ) ) { String virtualWikiName = getVirtualWikiFromURI ( request ) ; VirtualWiki virtualWiki = WikiBase . getHandler ( ) . lookupVirtualWiki ( virtualWikiName ) ; topic = virtualWiki . getDefaultTopicName ( ) ; } super . viewTopic ( request , next , topic ) ; }	super . viewTopic ( request , next , pageInfo , topic ) ;
registerError ( expression ) ; <CTX> private void checkCondition ( PsiExpression expression , PsiStatement context ) { if ( expression instanceof PsiInstanceOfExpression ) { final PsiInstanceOfExpression instanceOfExpression = ( PsiInstanceOfExpression ) expression ; final PsiExpression operand = instanceOfExpression . getOperand ( ) ; checkCondition ( operand , context ) ; } else if ( expression instanceof PsiBinaryExpression ) { final PsiBinaryExpression binaryExpression = ( PsiBinaryExpression ) expression ; PsiExpression lhs = binaryExpression . getLOperand ( ) ; PsiExpression rhs = binaryExpression . getROperand ( ) ; if ( rhs == null ) { return ; } lhs = ParenthesesUtils . stripParentheses ( lhs ) ; rhs = ParenthesesUtils . stripParentheses ( rhs ) ; if ( ComparisonUtils . isComparison ( binaryExpression ) ) { if ( lhs instanceof PsiLiteralExpression ) { checkCondition ( rhs , context ) ; } else if ( rhs instanceof PsiLiteralExpression ) { checkCondition ( lhs , context ) ; } } else { checkCondition ( rhs , context ) ; checkCondition ( lhs , context ) ; } } else if ( expression instanceof PsiReferenceExpression ) { final PsiReferenceExpression referenceExpression = ( PsiReferenceExpression ) expression ; final PsiElement element = referenceExpression . resolve ( ) ; if ( element instanceof PsiLocalVariable ) { final PsiLocalVariable variable = ( PsiLocalVariable ) element ; if ( ! VariableAccessUtils . variableIsAssigned ( variable , context ) ) { registerError ( expression ) ; } } else if ( element instanceof PsiParameter ) { final PsiParameter parameter = ( PsiParameter ) element ; if ( ! VariableAccessUtils . variableIsAssigned ( parameter , context ) ) { registerError ( expression ) ; } } } else if ( expression instanceof PsiPrefixExpression ) { final PsiPrefixExpression prefixExpression = ( PsiPrefixExpression ) expression ; final PsiJavaToken sign = prefixExpression . getOperationSign ( ) ; final IElementType tokenType = sign . getTokenType ( ) ; if ( JavaTokenType . EXCL . equals ( tokenType ) ) { final PsiExpression operand = prefixExpression . getOperand ( ) ; checkCondition ( operand , context ) ; } } }	registerError ( condition ) ;
indexManager . addSource ( ( IFile ) tempResource , tempResource . getProject ( ) . getFullPath ( ) ) ; <CTX> protected void processDelta ( ICElementDelta delta ) throws CModelException { int kind = delta . getKind ( ) ; int flags = delta . getFlags ( ) ; ICElement element = delta . getElement ( ) ; switch ( kind ) { case ICElementDelta . CHANGED : if ( ( flags & ICElementDelta . F_CHANGED_PATHENTRY_INCLUDE ) != 0 || ( flags & ICElementDelta . F_CHANGED_PATHENTRY_MACRO ) != 0 || ( flags & ICElementDelta . F_ADDED_PATHENTRY_SOURCE ) != 0 ) { IResource tempResource = element . getResource ( ) ; SourceRoot tempRootElement = null ; if ( tempResource == null ) return ; switch ( tempResource . getType ( ) ) { case IResource . FILE : indexManager . addSource ( ( IFile ) tempResource , tempResource . getProject ( ) . getFullPath ( ) ) ; break ; case IResource . FOLDER : tempRootElement = ( SourceRoot ) getElementSource ( element ) ; if ( tempRootElement != null ) { IProject theProj = tempResource . getProject ( ) ; indexManager . indexSourceFolder ( theProj , tempResource . getFullPath ( ) , tempRootElement . getSourceEntry ( ) . fullExclusionPatternChars ( ) ) ; } break ; case IResource . PROJECT : indexManager . indexAll ( tempResource . getProject ( ) ) ; break ; } } else if ( ( flags & ICElementDelta . F_REMOVED_PATHENTRY_SOURCE ) != 0 ) { IResource tempResource = element . getResource ( ) ; IProject project = tempResource . getProject ( ) ; if ( indexManager . indexProblemsEnabled ( project ) != 0 ) { indexManager . removeIndexerProblems ( tempResource ) ; } } break ; } ICElementDelta [ ] affectedChildren = delta . getAffectedChildren ( ) ; for ( int i = 0 ; i < affectedChildren . length ; i ++ ) { processDelta ( affectedChildren [ i ] ) ; } }	indexManager . addSource ( ( IFile ) tempResource , tempResource . getProject ( ) . getFullPath ( ) , false ) ;
super ( toolkit , label , new SwingLabel ( label ) ) ; final JLabel jLabel = ( JLabel ) jComponent ; SwingToolkit . add ( label , jLabel ) ; SwingToolkit . copyAwtProperties ( label , jLabel ) ; setText ( label . getText ( ) ) ; } <CTX> public SwingLabelPeer ( SwingToolkit toolkit , Label label ) { super ( toolkit , label , new SwingLabel ( label ) ) ; final JLabel jLabel = ( JLabel ) jComponent ; SwingToolkit . add ( label , jLabel ) ; SwingToolkit . copyAwtProperties ( label , jLabel ) ; setText ( label . getText ( ) ) ; }	super ( toolkit , label , new SwingLabel ( label ) ) ; SwingToolkit . add ( label , jComponent ) ; SwingToolkit . copyAwtProperties ( label , jComponent ) ; setText ( label . getText ( ) ) ; setAlignment ( label . getAlignment ( ) ) ; }
list . add ( new ExtendsException ( element , element . getExtendsName ( ) , ExtendsException . DESIGN_EXCEPTION_NOT_FOUND ) ) ; <CTX> public List validate ( Module module , DesignElement element ) { List list = new ArrayList ( ) ; if ( ! StringUtil . isEmpty ( element . getExtendsName ( ) ) && element . getExtendsElement ( ) == null ) { list . add ( new ExtendsException ( element , element . getExtendsName ( ) , ExtendsException . DESIGN_EXCEPTION_NOT_FOUND ) ) ; } return list ; }	list . add ( new InvalidParentException ( element , element . getExtendsName ( ) , InvalidParentException . DESIGN_EXCEPTION_PARENT_NOT_FOUND ) ) ;
if ( val == null || get ( ) . contains ( val ) ) return ; <CTX> public void set ( String val ) throws InvalidConfigValueException { if ( val == null || get ( ) . contains ( val ) ) return ; addPlugin ( val , true ) ; } ;	if ( val == null || get ( ) . indexOf ( val ) >= 0 ) return ;
support . unreadMany ( here . getLastLineLength ( ) ) ; <CTX> void heredoc_restore ( ) { HereDocNode here = ( HereDocNode ) lex_strterm ; / / Maybe we need to unread more than this ? support . unreadMany ( here . getLastLineLength ( ) ) ; }	support . setBuffer ( here . getLastLine ( ) , here . getPosition ( ) ) ;
osw = ( ObjectStoreWriterInterMineImpl ) ObjectStoreWriterFactory . getObjectStoreWriter ( oswAlias ) ; <CTX> public void setUp ( ) throws Exception { osw = ( ObjectStoreWriterInterMineImpl ) ObjectStoreWriterFactory . getObjectStoreWriter ( oswAlias ) ; }	ObjectStore objectStore = ObjectStoreWriterFactory . getObjectStoreWriter ( oswAlias ) ; osw = ( ObjectStoreWriterInterMineImpl ) objectStore ;
if ( path != null && objPath != null ) return path . equals ( objPath ) ; <CTX> public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj instanceof IStorage ) { IPath path = getFullPath ( ) ; IPath objPath = ( ( IStorage ) obj ) . getFullPath ( ) ; if ( path != null && objPath != null ) return path . equals ( objPath ) ; } return super . equals ( obj ) ; }	if ( p != null && objPath != null ) return p . equals ( objPath ) ;
test . testIt ( ) ; <CTX> public static void main ( String [ ] args ) { RandomStructureGeneratorTest test = new RandomStructureGeneratorTest ( ) ; test . setStandAlone ( true ) ; test . testIt ( ) ; }	try { test . testIt ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; }
setDocumentFromRequest ( document , request ) ; <CTX> protected void dispatchOkFromEditPage ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { setDocumentFromRequest ( document , request ) ; }	DocumentPermissionsPage documentPermissionsPage = new DocumentPermissionsPage ( document ) ; documentPermissionsPage . setFromRequest ( request ) ;
if ( myChooseDifferentProfile ) { myPanel . apply ( ) ; final InspectionProfileImpl editedProfile = ( InspectionProfileImpl ) myPanel . getSelectedProfile ( ) . getParentProfile ( ) ; InspectionProfileManager . getInstance ( ) . setRootProfile ( editedProfile . getName ( ) ) ; myInspectionProfile . copyFrom ( editedProfile ) ; InspectionProjectProfileManager . getInstance ( myProject ) . initProfileWrapper ( myInspectionProfile ) ; } else { final InspectionProfileImpl editedProfile = ( InspectionProfileImpl ) myPanel . getSelectedProfile ( ) ; myInspectionProfile . copyFrom ( editedProfile ) ; myInspectionProfile . save ( ) ; myPanel . initDescriptors ( ) ; } <CTX> public void apply ( ) throws ConfigurationException { if ( myChooseDifferentProfile ) { myPanel . apply ( ) ; final InspectionProfileImpl editedProfile = ( InspectionProfileImpl ) myPanel . getSelectedProfile ( ) . getParentProfile ( ) ; InspectionProfileManager . getInstance ( ) . setRootProfile ( editedProfile . getName ( ) ) ; myInspectionProfile . copyFrom ( editedProfile ) ; InspectionProjectProfileManager . getInstance ( myProject ) . initProfileWrapper ( myInspectionProfile ) ; } else { final InspectionProfileImpl editedProfile = ( InspectionProfileImpl ) myPanel . getSelectedProfile ( ) ; myInspectionProfile . copyFrom ( editedProfile ) ; myInspectionProfile . save ( ) ; myPanel . initDescriptors ( ) ; } }	myPanel . apply ( ) ; ErrorOptionsConfigurable . getInstance ( myProject ) . fireItemsChangedExternally ( ) ;
} else <CTX> protected void updateService ( Viewer aViewer , Object anOldInput , Object aNewInput ) { synchronized ( this ) { if ( structuredViewerManager == null ) { structuredViewerManager = new StructuredViewerManager ( aViewer ) ; structuredViewerManager . inputChanged ( anOldInput , aNewInput ) ; } else structuredViewerManager . inputChanged ( aViewer , anOldInput , aNewInput ) ; for ( Iterator contentItr = contentExtensions . values ( ) . iterator ( ) ; contentItr . hasNext ( ) ; ) structuredViewerManager . initialize ( ( ( NavigatorContentExtension ) contentItr . next ( ) ) . getContentProvider ( ) ) ; rootContentProviders = extractContentProviders ( findRootContentExtensions ( aNewInput ) ) ; } }	} else {
return createProject ( projectName , location , ManagedBuilderCorePlugin . MANAGED_MAKE_PROJECT_ID , projectTypeId ) ; <CTX> static public IProject createProject ( String projectName , File zip , IPath location , String projectTypeId ) throws CoreException , InvocationTargetException , IOException { IWorkspaceRoot root = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) ; IProject project = root . getProject ( projectName ) ; if ( project . exists ( ) ) removeProject ( projectName ) ; IPath destPath = ( location != null ) ? location : project . getFullPath ( ) ; if ( zip != null ) { importFilesFromZip ( new ZipFile ( zip ) , destPath , null ) ; } return createProject ( projectName , location , ManagedBuilderCorePlugin . MANAGED_MAKE_PROJECT_ID , projectTypeId ) ; }	if ( ! project . isOpen ( ) ) { project . open ( new NullProgressMonitor ( ) ) ; } return project ;
throws DatabaseUnitException , SQLException <CTX> protected int executeRowOperation ( IPreparedBatchStatement statement , Column [ ] columns , ITable table , int row ) throws DatabaseUnitException , SQLException { for ( int i = 0 ; i < columns . length ; i ++ ) { Object value = table . getValue ( row , columns [ i ] . getColumnName ( ) ) ; statement . addValue ( value , columns [ i ] . getDataType ( ) ) ; } statement . addBatch ( ) ; int result = statement . executeBatch ( ) ; statement . clearBatch ( ) ; return result ; }	throws DataSetException , SQLException
LibraryTableEditor . editLibraryTable ( getProjectLibrariesProvider ( ) ) . createAddLibraryAction ( true , myWholePanel ) . actionPerformed ( null ) ; <CTX> public void actionPerformed ( AnActionEvent e ) { LibraryTableEditor . editLibraryTable ( getProjectLibrariesProvider ( ) ) . createAddLibraryAction ( true , myWholePanel ) . actionPerformed ( null ) ; }	LibraryTableEditor . editLibraryTable ( getProjectLibrariesProvider ( ) , myProject ) . createAddLibraryAction ( true , myWholePanel ) . actionPerformed ( null ) ;
activationsBySourcePriority [ i ] = null ; <CTX> final void deactivateHandler ( final IHandlerActivation activation ) { / / First we update the handlerActivationsByCommandId map . final String commandId = activation . getCommandId ( ) ; final Object value = handlerActivationsByCommandId . get ( commandId ) ; if ( value instanceof Collection ) { final Collection handlerActivations = ( Collection ) value ; if ( handlerActivations . contains ( activation ) ) { handlerActivations . remove ( activation ) ; if ( handlerActivations . isEmpty ( ) ) { handlerActivationsByCommandId . remove ( commandId ) ; updateCommand ( commandId , null ) ; } else if ( handlerActivations . size ( ) == 1 ) { final IHandlerActivation remainingActivation = ( IHandlerActivation ) handlerActivations . iterator ( ) . next ( ) ; handlerActivationsByCommandId . put ( commandId , remainingActivation ) ; updateCommand ( commandId , ( evaluate ( remainingActivation ) ? remainingActivation : null ) ) ; } else { updateCommand ( commandId , resolveConflicts ( commandId , handlerActivations ) ) ; } } } else if ( value instanceof IHandlerActivation ) { if ( value == activation ) { handlerActivationsByCommandId . remove ( commandId ) ; updateCommand ( commandId , null ) ; } } / / Next we update the source priority bucket sort of activations . final int sourcePriority = activation . getSourcePriority ( ) ; for ( int i = 1 ; i <= 32 ; i ++ ) { if ( ( sourcePriority & ( 1 << i ) ) != 0 ) { final Set activations = activationsBySourcePriority [ i ] ; if ( activations == null ) { continue ; } activations . remove ( activation ) ; if ( activations . isEmpty ( ) ) { activationsBySourcePriority [ i ] = null ; } } } }	activationsByExpression . remove ( expression ) ; } if ( activationsByExpression . isEmpty ( ) ) { activationsByExpressionBySourcePriority [ i ] = null ;
if ( selectionListener != null && stepViewer != null ) stepViewer . addSelectionChangedListener ( selectionListener ) ; <CTX> public void setSelectionListener ( ISelectionChangedListener listener ) { if ( selectionListener != null && stepViewer != null ) stepViewer . removeSelectionChangedListener ( selectionListener ) ; selectionListener = listener ; if ( selectionListener != null && stepViewer != null ) stepViewer . addSelectionChangedListener ( selectionListener ) ; }	if ( selectionListener != null && stepViewer != null ) { stepViewer . addSelectionChangedListener ( selectionListener ) ; }
checkPermissions ( context , resource , I_CmsConstants . C_READ_ACCESS , true , filter ) ; <CTX> public List readChildResources ( CmsRequestContext context , CmsResource resource , CmsResourceFilter filter , boolean getFolders , boolean getFiles ) throws CmsException { / / check the access permissions checkPermissions ( context , resource , I_CmsConstants . C_READ_ACCESS , true , filter ) ; if ( ( ! filter . isValid ( context , resource ) ) ) { / / the parent folder was found , but it is invalid according to the selected filter / / child resources are not available return Collections . EMPTY_LIST ; } String folderName = resource . getRootPath ( ) ; / / try to get the sub resources from the cache String cacheKey ; if ( getFolders && getFiles ) { cacheKey = CmsCacheKey . C_CACHE_KEY_SUBALL ; } else if ( getFolders ) { cacheKey = CmsCacheKey . C_CACHE_KEY_SUBFOLDERS ; } else { cacheKey = CmsCacheKey . C_CACHE_KEY_SUBFILES ; } cacheKey = getCacheKey ( context . currentUser ( ) . getName ( ) + cacheKey + filter . getCacheId ( ) , context . currentProject ( ) , folderName ) ; List subResources = ( List ) m_resourceListCache . get ( cacheKey ) ; if ( subResources != null && subResources . size ( ) > 0 ) { / / the parent folder is not deleted , and the sub resources were cached , no further operations required / / we must however still filter the cached results for release / expiration date return setFullResourceNames ( context , subResources , filter ) ; } / / read the result form the database subResources = m_vfsDriver . readChildResources ( context . currentProject ( ) , resource , getFolders , getFiles ) ; for ( int i = 0 ; i < subResources . size ( ) ; i ++ ) { CmsResource currentResource = ( CmsResource ) subResources . get ( i ) ; int perms = hasPermissions ( context , currentResource , I_CmsConstants . C_READ_OR_VIEW_ACCESS , true , filter ) ; if ( PERM_DENIED == perms ) { subResources . remove ( i -- ) ; } } / / cache the sub resources m_resourceListCache . put ( cacheKey , subResources ) ; / / filter the result to remove resources outside release / expiration time window / / the setting of resource names aboce is NOR redundant , since the loop above / / is much more efficient than reading the path again return setFullResourceNames ( context , subResources , filter ) ; }	checkPermissions ( context , resource , CmsPermissionSet . ACCESS_READ , true , CmsResourceFilter . ALL ) ;
} fireLabelProviderChanged ( new LabelProviderChangedEvent ( PresentationLabelProvider . this ) ) ; <CTX> public void dispose ( ) { super . dispose ( ) ; colorRegistry . removeListener ( listener ) ; fontRegistry . removeListener ( listener ) ; for ( Iterator i = images . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { ( ( Image ) i . next ( ) ) . dispose ( ) ; } images . clear ( ) ; for ( Iterator i = fonts . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { ( ( Font ) i . next ( ) ) . dispose ( ) ; } fonts . clear ( ) ; if ( emptyImage != null ) { emptyImage . dispose ( ) ; emptyImage = null ; } fireLabelProviderChanged ( new LabelProviderChangedEvent ( PresentationLabelProvider . this ) ) ; }	} clearFontCache ( ) ;
if ( system . getData ( ) != null ) return ( TradingSystemPlugin ) system . getData ( ) ; TradingSystemPlugin plugin = TradingPlugin . createTradingSystemPlugin ( system . getPluginId ( ) ) ; system . setData ( plugin ) ; <CTX> public static TradingSystemPlugin createTradingSystemPlugin ( TradingSystem system ) { if ( system . getData ( ) != null ) return ( TradingSystemPlugin ) system . getData ( ) ; TradingSystemPlugin plugin = TradingPlugin . createTradingSystemPlugin ( system . getPluginId ( ) ) ; system . setData ( plugin ) ; plugin . setAccount ( system . getAccount ( ) ) ; plugin . setSecurity ( system . getSecurity ( ) ) ; plugin . setMaxExposure ( system . getMaxExposure ( ) ) ; plugin . setMinAmount ( system . getMinAmount ( ) ) ; plugin . setMaxAmount ( system . getMaxAmount ( ) ) ; plugin . setParameters ( system . getParameters ( ) ) ; return plugin ; }	TradingSystemPlugin plugin = ( TradingSystemPlugin ) system . getData ( ) ; if ( plugin == null ) { plugin = TradingPlugin . createTradingSystemPlugin ( system . getPluginId ( ) ) ; system . setData ( plugin ) ; }
autoResize ( index + position ) ; <CTX> public Object set ( int index , Object element ) { autoResize ( index + position ) ; return delegate . set ( index + position , element ) ; }	autoResize ( index + position + 1 ) ;
DaemonCodeAnalyzerImpl daemonCodeAnalyzer = ( DaemonCodeAnalyzerImpl ) DaemonCodeAnalyzer . getInstance ( myProject ) ; <CTX> public void doApplyInformationToEditor ( ) { if ( myHighlights == null ) return ; UpdateHighlightersUtil . setHighlightersToEditor ( myProject , myDocument , myStartOffset , myEndOffset , myHighlights , Pass . POST_UPDATE_ALL ) ; DaemonCodeAnalyzerImpl daemonCodeAnalyzer = ( DaemonCodeAnalyzerImpl ) DaemonCodeAnalyzer . getInstance ( myProject ) ; daemonCodeAnalyzer . getFileStatusMap ( ) . markFileUpToDate ( myDocument , FileStatusMap . NORMAL_HIGHLIGHTERS ) ; if ( timeToOptimizeImports ( ) && myEditor != null ) { optimizeImportsOnTheFly ( ) ; } }	DaemonCodeAnalyzer daemonCodeAnalyzer = DaemonCodeAnalyzer . getInstance ( myProject ) ;
if ( RegexpUtil . hasFlag ( options , MATCH_MULTILINE ) ) <CTX> protected int getCompilerOptions ( int options ) { int cOptions = RE . MATCH_NORMAL ; if ( RegexpUtil . hasFlag ( options , MATCH_CASE_INSENSITIVE ) ) cOptions |= RE . MATCH_CASEINDEPENDENT ; if ( RegexpUtil . hasFlag ( options , MATCH_MULTILINE ) ) cOptions |= RE . MATCH_MULTILINE ; if ( RegexpUtil . hasFlag ( options , MATCH_SINGLELINE ) ) cOptions |= RE . MATCH_SINGLELINE ; return cOptions ; }	} if ( RegexpUtil . hasFlag ( options , MATCH_MULTILINE ) ) {
} else throw new XMLConfigurationException ( XMLConfigurationException . NOT_RECOGNIZED , propertyId ) ; <CTX> public void setProperty ( String propertyId , Object state ) throws XMLConfigurationException { if ( propertyId . equals ( SYMBOL_TABLE ) ) { fSymbolTable = ( SymbolTable ) state ; } else if ( propertyId . equals ( ERROR_REPORTER ) ) { fErrorReporter = ( XMLErrorReporter ) state ; } else if ( propertyId . equals ( ERROR_HANDLER ) ) { fErrorReporter . setProperty ( propertyId , state ) ; } else if ( propertyId . equals ( ENTITY_RESOLVER ) ) { fEntityResolver = ( XMLEntityResolver ) state ; } else if ( propertyId . equals ( XMLGRAMMAR_POOL ) ) { fGrammarPool = ( XMLGrammarPool ) state ; } else if ( propertyId . equals ( SCHEMA_LOCATION ) ) { fExternalSchemas = ( String ) state ; } else if ( propertyId . equals ( SCHEMA_NONS_LOCATION ) ) { fExternalNoNSSchema = ( String ) state ; } else if ( propertyId . equals ( JAXP_SCHEMA_SOURCE ) ) { fJAXPSource = state ; fJAXPProcessed = false ; } else throw new XMLConfigurationException ( XMLConfigurationException . NOT_RECOGNIZED , propertyId ) ; } / / setProperty ( String , Object )	} else if ( propertyId . equals ( XMLGRAMMAR_POOL ) ) { fGrammarPool = ( XMLGrammarPool ) state ; } else if ( propertyId . equals ( SCHEMA_LOCATION ) ) { fExternalSchemas = ( String ) state ; } else if ( propertyId . equals ( SCHEMA_NONS_LOCATION ) ) { fExternalNoNSSchema = ( String ) state ; } else if ( propertyId . equals ( ENTITY_RESOLVER ) ) { fEntityManager . setProperty ( ENTITY_RESOLVER , state ) ; }
TunnelInfo info =_inboundExploratory . selectTunnel ( ) ; <CTX> public TunnelInfo selectInboundTunnel ( ) { TunnelInfo info =_inboundExploratory . selectTunnel ( ) ; if ( info == null ) {_inboundExploratory . buildFallback ( ) ; / / still can be null , but probably not info =_inboundExploratory . selectTunnel ( ) ; } return info ; }	TunnelPool pool =_inboundExploratory ; if ( pool == null ) return null ; TunnelInfo info = pool . selectTunnel ( ) ;
return new UTF 8 DataChunk ( stringPool , prev ) ; <CTX> public static UTF 8 DataChunk createChunk ( StringPool stringPool , UTF 8 DataChunk prev ) { if ( fgFreeChunks != null ) { UTF 8 DataChunk newChunk = fgFreeChunks ; fgFreeChunks = newChunk . fNextChunk ; newChunk . fNextChunk = null ; newChunk . init ( stringPool , prev ) ; return newChunk ; } return new UTF 8 DataChunk ( stringPool , prev ) ; }	UTF 8 DataChunk chunk = new UTF 8 DataChunk ( stringPool , prev ) ; return chunk ;
int reference = indenter . findReferencePosition ( c . offset , false , true , false , false ) ; <CTX> private void smartIndentAfterClosingBracket ( IDocument d , DocumentCommand c ) { if ( c . offset == - 1 || d . getLength ( ) == 0 ) return ; try { int p = ( c . offset == d . getLength ( ) ? c . offset - 1 : c . offset ) ; int line = d . getLineOfOffset ( p ) ; int start = d . getLineOffset ( line ) ; int whiteend = findEndOfWhiteSpace ( d , start , c . offset ) ; CHeuristicScanner scanner = new CHeuristicScanner ( d ) ; CIndenter indenter = new CIndenter ( d , scanner , fProject ) ; / / shift only when line does not contain any text up to the closing bracket if ( whiteend == c . offset ) { / / evaluate the line with the opening bracket that matches out closing bracket int reference = indenter . findReferencePosition ( c . offset , false , true , false , false ) ; int indLine = d . getLineOfOffset ( reference ) ; if ( indLine != - 1 && indLine != line ) { / / take the indent of the found line StringBuffer replaceText = new StringBuffer ( getIndentOfLine ( d , indLine ) ) ; / / add the rest of the current line including the just added close bracket replaceText . append ( d . get ( whiteend , c . offset - whiteend ) ) ; replaceText . append ( c . text ) ; / / modify document command c . length += c . offset - start ; c . offset = start ; c . text = replaceText . toString ( ) ; } } } catch ( BadLocationException e ) { CUIPlugin . getDefault ( ) . log ( e ) ; } }	int reference = indenter . findReferencePosition ( c . offset , false , true , false , false , false ) ;
int rows = numRows - 1 ; <CTX> private void copyStackEndsTimepoints ( int from , int to ) { control . copyStack ( from , to ) ; int rows = numRows - 1 ; PlaneArea pa ; int z ; for ( int i = 0 ; i < rows ; i ++ ) { z = rows - i ; pa = control . getPlaneArea ( z , from ) ; setSelectedCell ( pa , i , from ) ; setSelectedCell ( pa , i , to ) ; } view . table . repaint ( from * numColumns , 0 , to * cellWidth , numRows * cellHeight ) ; }	int rows = numRows ;
return ( additionalCKeywords . get ( tokenImage ) != null ) ; <CTX> public boolean isExtensionKeyword ( ParserLanguage language , String tokenImage ) { if ( language == ParserLanguage . CPP ) return ( additionalCPPKeywords . get ( tokenImage ) != null ) ; else if ( language == ParserLanguage . C ) return ( additionalCKeywords . get ( tokenImage ) != null ) ; return false ; }	return ( additionalCKeywords . containsKey ( tokenImage ) ) ;
int ruleAction = TokenMarker . SPAN | ( ( noLineBreak ) ? TokenMarker . NO_LINE_BREAK : 0 ) | ( ( atLineStart ) ? TokenMarker . AT_LINE_START : 0 ) | ( ( excludeMatch ) ? TokenMarker . EXCLUDE_MATCH : 0 ) | ( ( noWordBreak ) ? TokenMarker . NO_WORD_BREAK : 0 ) ; <CTX> public static final ParserRule createSpanRule ( String begin , String end , String delegate , byte id , boolean noLineBreak , boolean atLineStart , boolean excludeMatch , boolean noWordBreak ) { int ruleAction = TokenMarker . SPAN | ( ( noLineBreak ) ? TokenMarker . NO_LINE_BREAK : 0 ) | ( ( atLineStart ) ? TokenMarker . AT_LINE_START : 0 ) | ( ( excludeMatch ) ? TokenMarker . EXCLUDE_MATCH : 0 ) | ( ( noWordBreak ) ? TokenMarker . NO_WORD_BREAK : 0 ) ; return new ParserRule ( ruleAction , begin . toCharArray ( ) , end . toCharArray ( ) , delegate , id ) ; } / / } } }	int ruleAction = SPAN | ( ( noLineBreak ) ? NO_LINE_BREAK : 0 ) | ( ( atLineStart ) ? AT_LINE_START : 0 ) | ( ( excludeMatch ) ? EXCLUDE_MATCH : 0 ) | ( ( noWordBreak ) ? NO_WORD_BREAK : 0 ) ;
if ( ( session == null ) || ( getMode ( ) != Portlet . Mode . EDIT ) ) return ; <CTX> public void setData ( PortletData data ) { if ( ( session == null ) || ( getMode ( ) != Portlet . Mode . EDIT ) ) return ; req . setAttribute ( GridSphereProperties . PORTLETDATA , data ) ; }	if ( ( portletSession == null ) || ( getMode ( ) != Portlet . Mode . EDIT ) ) return ;
RubyArray resultArray = RubyArray . newArray ( runtime , result . size ( ) ) ; <CTX> public RubyArray results ( ) { process ( ) ; RubyArray resultArray = RubyArray . newArray ( runtime , result . size ( ) ) ; Iterator iter = result . iterator ( ) ; while ( iter . hasNext ( ) ) { resultArray . append ( RubyString . newString ( runtime , ( String ) iter . next ( ) ) ) ; } return resultArray ; }	RubyArray resultArray = runtime . newArray ( result . size ( ) ) ;
void updateText ( Main . SourceInfo sourceInfo ) { <CTX> void updateText ( Main . SourceInfo sourceInfo ) { this . sourceInfo = sourceInfo ; String newText = sourceInfo . source ( ) ; if ( ! textArea . getText ( ) . equals ( newText ) ) { textArea . setText ( newText ) ; int pos = 0 ; if ( currentPos != - 1 ) { pos = currentPos ; } textArea . select ( pos ) ; } fileHeader . update ( ) ; fileHeader . repaint ( ) ; }	void updateText ( Dim . SourceInfo sourceInfo ) {
void setInputWindowEnd ( int value ) { int w = view . getDomainPane ( ) . getWavelengths ( ) . getSelectedIndex ( ) ; setInputWindowEnd ( value , w ) ; } <CTX> void setInputWindowEnd ( int value ) { int w = view . getDomainPane ( ) . getWavelengths ( ) . getSelectedIndex ( ) ; setInputWindowEnd ( value , w ) ; }	void setInputWindowEnd ( int value , int w ) { DomainPaneManager dpManager = view . getDomainPane ( ) . getManager ( ) ; GraphicsRepresentationManager grManager = view . getGRepresentation ( ) . getManager ( ) ; dpManager . setInputWindowEnd ( value ) ; grManager . setInputWindowEnd ( value , getGlobalChannelWindowStart ( w ) , getGlobalChannelWindowEnd ( w ) ) ; }
if ( event . type == SWT . Activate ) activateEditor ( e ) ; <CTX> public Composite createInnerPartControl ( Composite parent , final IEditorPart e ) { Composite content = new Composite ( parent , SWT . NONE ) ; content . setLayout ( new FillLayout ( ) ) ; e . createPartControl ( content ) ; parent . addListener ( SWT . Activate , new Listener ( ) { public void handleEvent ( Event event ) { if ( event . type == SWT . Activate ) activateEditor ( e ) ; } } ) ; return content ; }	if ( event . type == SWT . Activate ) { activateEditor ( e ) ; }
tt = ts . getToken ( flagsTS ) ; <CTX> private int peekToken ( int flagsTS ) throws IOException { int tt = currentFlaggedToken ; if ( tt == Token . EOF ) { tt = ts . getToken ( flagsTS ) ; if ( tt == Token . EOL ) { do { tt = ts . getToken ( flagsTS ) ; } while ( tt == Token . EOL ) ; tt |= TI_AFTER_EOL ; } currentFlaggedToken = tt ; } return tt & CLEAR_TI_MASK ; }	tt = ts . getToken ( ) ;
return ( Extension [ ] ) fExtensions . toArray ( new Extension [ fExtensions . size ( ) ] ) ; <CTX> public Extension [ ] getExtensions ( ) { return ( Extension [ ] ) fExtensions . toArray ( new Extension [ fExtensions . size ( ) ] ) ; }	return fExtensions . toArray ( new Extension [ fExtensions . size ( ) ] ) ;
context . popClass ( ) ; <CTX> public IRubyObject call ( Ruby runtime , IRubyObject receiver , String name , IRubyObject [ ] args , boolean noSuper ) { ThreadContext context = runtime . getCurrentContext ( ) ; RubyProc optionalBlockArg = null ; if ( argsNode . getBlockArgNode ( ) != null && context . isBlockGiven ( ) ) { optionalBlockArg = RubyProc . newProc ( runtime ) ; } context . getScopeStack ( ) . push ( ) ; if ( body . getLocalNames ( ) != null ) { context . getScopeStack ( ) . resetLocalVariables ( body . getLocalNames ( ) ) ; } context . pushDynamicVars ( ) ; context . pushClass ( module ) ; try { if ( argsNode != null ) { prepareArguments ( runtime , receiver , args ) ; } if ( optionalBlockArg != null ) { context . getScopeStack ( ) . setValue ( argsNode . getBlockArgNode ( ) . getCount ( ) , optionalBlockArg ) ; } traceCall ( runtime , receiver , name ) ; return receiver . eval ( body . getBodyNode ( ) ) ; } catch ( ReturnJump rj ) { if ( rj . getTarget ( ) == this ) { return rj . getReturnValue ( ) ; } throw rj ; } finally { context . popClass ( ) ; context . popDynamicVars ( ) ; context . getScopeStack ( ) . pop ( ) ; traceReturn ( runtime , receiver , name ) ; } }	context . setClassStack ( oldStack ) ;
return ( new TemplatesHandlerImpl ( ) ) ; <CTX> public TemplatesHandler newTemplatesHandler ( ) throws TransformerConfigurationException { return ( new TemplatesHandlerImpl ( ) ) ; }	final TemplatesHandlerImpl handler = new TemplatesHandlerImpl ( ) ; handler . init ( ) ; return handler ;
getServletContext ( ) . setAttribute ( GrailsRequestAttributes . APPLICATION_CONTEXT , webContext ) ; <CTX> protected WebApplicationContext createWebApplicationContext ( WebApplicationContext parent ) throws BeansException { / / use config file locations if available ApplicationContext grailsContext = ( ApplicationContext ) getServletContext ( ) . getAttribute ( GrailsRequestAttributes . APPLICATION_CONTEXT ) ; GrailsApplication application ; WebApplicationContext webContext ; if ( grailsContext != null ) { XmlWebApplicationContext xmlContext = new XmlWebApplicationContext ( ) ; xmlContext . setParent ( grailsContext ) ; webContext = xmlContext ; application = ( GrailsApplication ) webContext . getBean ( GrailsApplication . APPLICATION_ID , GrailsApplication . class ) ; } else { String [ ] locations = null ; if ( null != getContextConfigLocation ( ) ) { locations = StringUtils . tokenizeToStringArray ( getContextConfigLocation ( ) , ConfigurableWebApplicationContext . CONFIG_LOCATION_DELIMITERS ) ; } / / construct the SpringConfig for the container managed application application = ( GrailsApplication ) parent . getBean ( GrailsApplication . APPLICATION_ID , GrailsApplication . class ) ; SpringConfig springConfig = new SpringConfig ( application ) ; / / return a context that obeys grails settings webContext = new XmlWebApplicationContextDriver ( ) . getWebApplicationContext ( springConfig . getBeanReferences ( ) , parent , getServletContext ( ) , getNamespace ( ) , locations ) ; getServletContext ( ) . setAttribute ( GrailsRequestAttributes . APPLICATION_CONTEXT , webContext ) ; } / / init the Grails application GrailsBootstrapClass [ ] bootstraps = application . getGrailsBootstrapClasses ( ) ; for ( int i = 0 ; i < bootstraps . length ; i ++ ) { bootstraps [ i ] . callInit ( getServletContext ( ) ) ; } return webContext ; }	getServletContext ( ) . setAttribute ( GrailsApplicationAttributes . APPLICATION_CONTEXT , webContext ) ;
this . path = path ; <CTX> public SchedulerEventGenerator ( java . io . File path , String userName , String schedulerName , JobStateMonitor monitor ) { this . path = path ; this . userName = userName ; this . schedulerName = schedulerName ; this . proc = null ; this . shutdownCalled = false ; this . timeStamp = null ; this . monitor = monitor ; lastRestart = 0 ; }	this . globusLocation = globusLocation ;
Hashtable t = null ; return ( Object ) t ; <CTX> public Object getDatatypeObject ( ) { Hashtable t = null ; return ( Object ) t ; }	return ( Object ) null ;
Locale_lcl ) <CTX> SwingEventHandler ( LinkedHashMap_lhmAllTriggers , IUpdateNotifier_jc , Locale_lcl ) { lhmAllTriggers =_lhmAllTriggers ; iun =_jc ; lcl =_lcl ; }	ULocale_lcl )
super ( valueView ) ; <CTX> public MyModelEventListener ( final IModelElement model , final Text valueView ) { super ( valueView ) ; fModel = model ; this . valueView = valueView ; }	super ( model , valueView ) ;
NodeState parent = validator . getNodeState ( operation . getParentId ( ) ) ; <CTX> public void visit ( AddNode operation ) throws LockException , ConstraintViolationException , AccessDeniedException , ItemExistsException , NoSuchNodeTypeException , UnsupportedRepositoryOperationException , VersionException , RepositoryException { int options = ItemStateValidator . CHECK_LOCK | ItemStateValidator . CHECK_COLLISION | ItemStateValidator . CHECK_VERSIONING | ItemStateValidator . CHECK_CONSTRAINTS ; NodeState parent = validator . getNodeState ( operation . getParentId ( ) ) ; QNodeDefinition def = validator . getApplicableNodeDefinition ( operation . getNodeName ( ) , operation . getNodeTypeName ( ) , parent ) ; addNodeState ( parent , operation . getNodeName ( ) , operation . getNodeTypeName ( ) , operation . getUuid ( ) , def , options ) ; transientStateMgr . addOperation ( operation ) ; }	NodeState parent = getNodeState ( operation . getParentId ( ) ) ;
return new DelegatingNotation ( baseNode , this ) ; <CTX> protected DelegatingNotation createDelegatingNotation ( Notation baseNode ) { return new DelegatingNotation ( baseNode , this ) ; }	return baseNode == null ? null : new DelegatingNotation ( baseNode , this ) ;
return respond_to ( RubySymbol . newSymbol ( getRuby ( ) , methodName ) ) . isTrue ( ) ; <CTX> public boolean respondsTo ( String methodName ) { return respond_to ( RubySymbol . newSymbol ( getRuby ( ) , methodName ) ) . isTrue ( ) ; }	return respond_to ( new RubyObject [ ] { RubySymbol . newSymbol ( getRuby ( ) , methodName ) } ) . isTrue ( ) ;
DelegatingMetaClass metaClass = ( DelegatingMetaClass ) InvokerHelper . getInstance ( ) . getMetaRegistry ( ) . getMetaClass ( target . getClass ( ) ) ; <CTX> protected Object handleValidationError ( Object target , Errors errors ) { HibernateTemplate t = getHibernateTemplate ( ) ; / / if the target is within the session evict it / / this is so that if validation fails hibernate doesn t save / / the object automatically when the session is flushed if ( t . contains ( target ) ) { t . evict ( target ) ; } if ( target instanceof GroovyObject ) { ( ( GroovyObject ) target ) . setProperty ( DomainClassMethods . ERRORS_PROPERTY , errors ) ; } else { DelegatingMetaClass metaClass = ( DelegatingMetaClass ) InvokerHelper . getInstance ( ) . getMetaRegistry ( ) . getMetaClass ( target . getClass ( ) ) ; metaClass . setProperty ( target , DomainClassMethods . ERRORS_PROPERTY , errors ) ; } return null ; }	DynamicMethodsMetaClass metaClass = ( DynamicMethodsMetaClass ) InvokerHelper . getInstance ( ) . getMetaRegistry ( ) . getMetaClass ( target . getClass ( ) ) ;
if ( menu instanceof SubMenuManager ) <CTX> public IContributionItem find ( String id ) { IContributionItem item = getParentMenuManager ( ) . find ( id ) ; if ( item instanceof SubContributionItem ) / / Return the item passed to us , not the wrapper . item = unwrap ( item ) ; if ( item instanceof IMenuManager ) { / / if it is a menu manager wrap it before returning IMenuManager menu = ( IMenuManager ) item ; if ( menu instanceof SubMenuManager ) / / it it is already wrapped then remover the wrapper and / / rewrap . We have a table of wrappers so we reuse wrappers / / we create . menu = ( IMenuManager ) ( ( SubMenuManager ) menu ) . getParent ( ) ; item = getWrapper ( menu ) ; } return item ; }	if ( menu instanceof SubMenuManager ) {
throw new JcrDavException ( e ) ; <CTX> public void removeProperty ( DavPropertyName propertyName ) throws DavException { if ( isLocked ( this ) ) { throw new DavException ( DavServletResponse . SC_LOCKED ) ; } if ( ! exists ( ) ) { throw new DavException ( DavServletResponse . SC_NOT_FOUND ) ; } try { removeJcrProperty ( propertyName ) ; node . save ( ) ; } catch ( RepositoryException e ) { throw new JcrDavException ( e ) ; } }	JcrDavException je = new JcrDavException ( e ) ; try { node . refresh ( false ) ; } catch ( RepositoryException re ) { } throw je ;
} finally { if ( httpMethod != null && closeConnection ) <CTX> protected HttpMethod execute ( UMOEvent event , HttpMethod httpMethod , boolean closeConnection ) throws Exception { / / todo set connection timeout buffer etc try { URI uri = event . getEndpoint ( ) . getEndpointURI ( ) . getUri ( ) ; try { processCookies ( event ) ; client . executeMethod ( getHostConfig ( uri ) , httpMethod ) ; } catch ( Exception e ) { logger . error ( e , e ) ; } return httpMethod ; } catch ( Exception e ) { throw new DispatchException ( event . getMessage ( ) , event . getEndpoint ( ) , e ) ; } finally { if ( httpMethod != null && closeConnection ) httpMethod . releaseConnection ( ) ; } }	} finally { if ( httpMethod != null && closeConnection ) {
int size =_type . size ( ) ; java . lang . String [ ] mArray = new String [ size ] ; for ( int index = 0 ; index < size ; index ++ ) { mArray [ index ] = ( String )_type . elementAt ( index ) ; <CTX> public java . lang . String [ ] getType ( ) { int size =_type . size ( ) ; java . lang . String [ ] mArray = new String [ size ] ; for ( int index = 0 ; index < size ; index ++ ) { mArray [ index ] = ( String )_type . elementAt ( index ) ; } return mArray ; } / / -- java . lang . String [ ] getType ( )	if ( ( index < 0 ) || ( index >_type . size ( ) ) ) { throw new IndexOutOfBoundsException ( ) ;
} else <CTX> protected ILightweightLabelDecorator internalGetDecorator ( ) throws CoreException { if ( labelProviderCreationFailed ) return null ; final CoreException [ ] exceptions = new CoreException [ 1 ] ; if ( decorator == null ) { if ( isDeclarative ( ) ) decorator = new DeclarativeDecorator ( definingElement , getIconLocation ( ) ) ; else { Platform . run ( new ISafeRunnable ( ) { public void run ( ) { try { decorator = ( ILightweightLabelDecorator ) WorkbenchPlugin . createExtension ( definingElement , DecoratorDefinition . ATT_CLASS ) ; decorator . addListener ( WorkbenchPlugin . getDefault ( ) . getDecoratorManager ( ) ) ; } catch ( CoreException exception ) { exceptions [ 0 ] = exception ; } } / * * ( non - Javadoc ) Method declared on ISafeRunnable . * / public void handleException ( Throwable e ) { / / Do nothing as Core will handle the logging } } ) ; } } else return decorator ; if ( decorator == null ) { this . labelProviderCreationFailed = true ; setEnabled ( false ) ; } if ( exceptions [ 0 ] != null ) throw exceptions [ 0 ] ; return decorator ; }	} else {
value . createForeignKey ( ) ; <CTX> private static Property createProperty ( Value value , PersistentClass persistentClass , GrailsDomainClassProperty grailsProperty , Mappings mappings ) { / / set type value . setTypeUsingReflection ( persistentClass . getClassName ( ) , grailsProperty . getName ( ) ) ; / / if it is a ManyToOne or OneToOne relationship if ( value instanceof ToOne ) { ToOne toOne = ( ToOne ) value ; String propertyRef = toOne . getReferencedPropertyName ( ) ; if ( propertyRef != null ) { / / TODO : Hmm this method has package visibility . Why ? / / mappings . addUniquePropertyReference ( toOne . getReferencedEntityName ( ) , propertyRef ) ; } } else if ( value instanceof Collection ) { / / Collection collection = ( Collection ) value ; / / String propertyRef = collection . getReferencedPropertyName ( ) ; } value . createForeignKey ( ) ; Property prop = new Property ( ) ; prop . setValue ( value ) ; bindProperty ( grailsProperty , prop , mappings ) ; return prop ; }	if ( value . getTable ( ) != null ) value . createForeignKey ( ) ;
return TasklistImages . getImage ( TasklistImages . CATEGORY_ARCHIVE ) ; <CTX> public Image getIcon ( ) { if ( isArchive ( ) ) { return TasklistImages . getImage ( TasklistImages . CATEGORY_ARCHIVE ) ; } else { return TasklistImages . getImage ( TasklistImages . CATEGORY ) ; } }	return TaskListImages . getImage ( TaskListImages . CATEGORY_ARCHIVE ) ;
RubyNumeric other = numericValue ( num ) ; if ( getRubyClass ( ) == other . getRubyClass ( ) ) { return RubyArray . newArray ( getRuby ( ) , this , other ) ; } else { return RubyArray . newArray ( getRuby ( ) , Arrays . asList ( getCoerce ( ( RubyNumeric ) num ) ) ) ; } } <CTX> public RubyArray coerce ( RubyObject num ) { RubyNumeric other = numericValue ( num ) ; if ( getRubyClass ( ) == other . getRubyClass ( ) ) { return RubyArray . newArray ( getRuby ( ) , this , other ) ; } else { return RubyArray . newArray ( getRuby ( ) , Arrays . asList ( getCoerce ( ( RubyNumeric ) num ) ) ) ; } }	RubyNumeric other = numericValue ( num ) ; if ( getRubyClass ( ) == other . getRubyClass ( ) ) { return RubyArray . newArray ( getRuby ( ) , other , this ) ; } else { return RubyArray . newArray ( getRuby ( ) , RubyFloat . newFloat ( getRuby ( ) , other . getDoubleValue ( ) ) , RubyFloat . newFloat ( getRuby ( ) , getDoubleValue ( ) ) ) ; } }
if ( paramValueObj != null ) <CTX> protected Map getParsedParameters ( IViewerReportDesignHandle design , Collection parameterList , HttpServletRequest request , InputOptions options ) throws ReportServiceException { Map params = new HashMap ( ) ; if ( parameterList == null || this . parametersAsString == null ) return params ; for ( Iterator iter = parameterList . iterator ( ) ; iter . hasNext ( ) ; ) { ScalarParameterHandle parameter = null ; Object parameterObj = iter . next ( ) ; if ( parameterObj instanceof ScalarParameterHandle ) { parameter = ( ScalarParameterHandle ) parameterObj ; } / / if current object is not Scalar parameter handle , then skip it if ( parameter == null ) continue ; String paramName = parameter . getName ( ) ; Object paramValueObj = this . parametersAsString . get ( paramName ) ; if ( paramValueObj != null ) { / / if default value is Date object , put map directly if ( paramValueObj instanceof Date ) { params . put ( paramName , paramValueObj ) ; continue ; } try { / / convert parameter to object String format = ParameterAccessor . getFormat ( request , paramName ) ; if ( format == null || format . length ( ) <= 0 ) { format = parameter . getPattern ( ) ; } paramValueObj = DataUtil . validate ( parameter . getDataType ( ) , format , paramValueObj . toString ( ) , locale ) ; params . put ( paramName , paramValueObj ) ; } catch ( ValidationValueException e ) { / / if in PREVIEW mode , then throw exception directly if ( ParameterAccessor . SERVLET_PATH_PREVIEW . equalsIgnoreCase ( request . getServletPath ( ) ) ) { this . exception = e ; break ; } } } else { params . put ( paramName , null ) ; } } return params ; }	if ( paramValue != null )
return stamp . getDate ( ) ; <CTX> public Date getRunDate ( ) { String date = this . getMetaData ( METADATA_RUN_DATE ) ; if ( date != null ) { IWTimestamp stamp = new IWTimestamp ( date ) ; return stamp . getDate ( ) ; } return null ; }	return stamp . getTimestamp ( ) ;
int c = count == null ? 0 : count . intValue ( ) ; <CTX> public ActiveList purge ( ) { int fillerCount = 0 ; Map countMap = new HashMap ( ) ; Collections . sort ( tokenList , Token . COMPARATOR ) ; / / remove word duplicates for ( ListIterator i = tokenList . listIterator ( ) ; i . hasNext ( ) ; ) { Token token = ( Token ) i . next ( ) ; WordSearchState wordState = ( WordSearchState ) token . getSearchState ( ) ; Word word = wordState . getPronunciation ( ) . getWord ( ) ; / / only allow maxFiller words if ( maxFiller > 0 ) { if ( word . isFiller ( ) ) { if ( fillerCount < maxFiller ) { fillerCount ++ ; } else { i . remove ( ) ; continue ; } } } if ( maxPathsPerWord > 0 ) { Integer count = ( Integer ) countMap . get ( word ) ; int c = count == null ? 0 : count . intValue ( ) ; / / Since the tokens are sorted by score we only / / keep the n tokens for a particular word if ( c < maxPathsPerWord - 1 ) { countMap . put ( word , new Integer ( c + 1 ) ) ; } else { i . remove ( ) ; } } } if ( tokenList . size ( ) > absoluteBeamWidth ) { tokenList = tokenList . subList ( 0 , absoluteBeamWidth ) ; } return this ; }	int c = count == null ? 0 : count ;
IEnrolment enrollment = enrollmentDAO . readByStudentCurricularPlanAndCurricularCourseAndExecutionPeriod ( <CTX> private void searchForEnrollmentInExtraCurricularCourseAndDeleteIt ( IEnrolment oldEnrollment , IStudentCurricularPlan toStudentCurricularPlan ) throws ExcepcaoPersistencia { ISuportePersistente persistenceDAO = SuportePersistenteOJB . getInstance ( ) ; IPersistentEnrolment enrollmentDAO = persistenceDAO . getIPersistentEnrolment ( ) ; IEnrolment enrollment = enrollmentDAO . readByStudentCurricularPlanAndCurricularCourseAndExecutionPeriod ( toStudentCurricularPlan , oldEnrollment . getCurricularCourse ( ) , oldEnrollment . getExecutionPeriod ( ) ) ; if ( ( enrollment != null ) && ( enrollment instanceof EnrolmentInExtraCurricularCourse ) ) { enrollmentDAO . deleteByOID ( Enrolment . class , enrollment . getIdInternal ( ) ) ; } }	IEnrollment enrollment = enrollmentDAO . readByStudentCurricularPlanAndCurricularCourseAndExecutionPeriod (
sb . append ( arr [ i ] ) . append ( URLEncoder . encode ( delimiter ) ) ; <CTX> public static String arrayToString ( String [ ] arr ) { if ( arr == null ) return null ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) sb . append ( arr [ i ] ) . append ( URLEncoder . encode ( delimiter ) ) ; return sb . toString ( ) ; }	sb . append ( URLEncoder . encode ( arr [ i ] ) ) . append ( delimiter ) ;
return runtime . newFixnum ( 0 ) ; <CTX> public static RubyFixnum zero ( IRuby runtime ) { return runtime . newFixnum ( 0 ) ; }	return newFixnum ( runtime , 0 ) ;
return realThis ( thisObj , f ) . jsFunction_toString ( ) ; <CTX> public Object execMethod ( int methodId , IdFunction f , Context cx , Scriptable scope , Scriptable thisObj , Object [ ] args ) throws JavaScriptException { if ( prototypeFlag ) { if ( methodId == Id_constructor ) { return jsConstructor ( cx , args , f , thisObj == null ) ; } else if ( methodId == Id_toString ) { return realThis ( thisObj , f ) . jsFunction_toString ( ) ; } } return super . execMethod ( methodId , f , cx , scope , thisObj , args ) ; }	return realThis ( thisObj , f ) . toString ( ) ;
if ( minSize != null ) { GridData gd = ( GridData ) viewer . getControl ( ) . getLayoutData ( ) ; gd . widthHint = minSize . x ; gd . heightHint = minSize . y ; <CTX> private void applyMinimumSize ( ) { if ( minSize != null ) { GridData gd = ( GridData ) viewer . getControl ( ) . getLayoutData ( ) ; gd . widthHint = minSize . x ; gd . heightHint = minSize . y ; } }	if ( fMinSize != null ) { GridData gd = ( GridData ) fViewer . getControl ( ) . getLayoutData ( ) ; gd . widthHint = fMinSize . x ; gd . heightHint = fMinSize . y ;
if ( match ) { <CTX> private boolean needToDeclareNamespace ( Element parent , String prefix , String uri ) { boolean match = visiblyUtilized ( parent , prefix , uri ) ; if ( match ) { return noOutputAncestorUsesPrefix ( parent , prefix , uri ) ; } return false ; }	if ( match || inclusiveNamespacePrefixes . contains ( prefix ) ) {
if ( kappa > maxKappa ) { <CTX> private void sortLearners ( ) { ArrayList unsortedLearners = new ArrayList ( ) ; String [ ] classNames = schema . validClassNames ( ) ; ArrayList unsortedClassNames = new ArrayList ( ) ; sortedClassNames = new String [ schema . getNumberOfClasses ( ) ] ; for ( int i = 0 ; i < innerLearner . size ( ) ; i ++ ) { unsortedLearners . add ( ( BatchClassifierLearner ) innerLearner . get ( i ) ) ; unsortedClassNames . add ( classNames [ i ] ) ; } / / clear list so that it can be reconstructed in sorted order innerLearner . clear ( ) ; int position = 0 ; while ( ! unsortedLearners . isEmpty ( ) ) { double maxKappa = 0 . 0 ; int learnerIndex = - 1 ; / / find learner with max positive examples for ( int j = 0 ; j < unsortedLearners . size ( ) ; j ++ ) { try { BatchClassifierLearner learner = ( ( BatchClassifierLearner ) unsortedLearners . get ( j ) ) ; Evaluation evaluation = ( Evaluation ) eval . get ( j ) ; double kappa = evaluation . kappa ( ) ; if ( kappa > maxKappa ) { maxKappa = kappa ; learnerIndex = j ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } / / add learner to sortedLearners ClassifierLearner learner = ( ClassifierLearner ) unsortedLearners . remove ( learnerIndex ) ; innerLearner . add ( learner ) ; String className = ( String ) unsortedClassNames . remove ( learnerIndex ) ; sortedClassNames [ position ] = className ; position ++ ; } }	if ( kappa >= maxKappa ) {
RubyString str = stringValue ( other ) ; if ( this == other || getValue ( ) . equals ( str . getValue ( ) ) ) { <CTX> public RubyString replace ( IRubyObject other ) { RubyString str = stringValue ( other ) ; if ( this == other || getValue ( ) . equals ( str . getValue ( ) ) ) { return this ; } setValue ( str . getValue ( ) ) ; return ( RubyString ) infectBy ( str ) ; }	RubyString newValue = stringValue ( other ) ; if ( this == other || sameAs ( newValue ) ) {
return getDataDirectory ( ) + DEFAULT_PATH_SEPARATOR + DEFAULT_BACKUP_FOLDER_NAME ; <CTX> public String getBackupFolderPath ( ) { return getDataDirectory ( ) + DEFAULT_PATH_SEPARATOR + DEFAULT_BACKUP_FOLDER_NAME ; }	return getDataDirectory ( ) + DEFAULT_PATH_SEPARATOR + ITasksUiConstants . DEFAULT_BACKUP_FOLDER_NAME ;
return RubyBoolean . newBoolean ( getRuntime ( ) , javaClass . isPrimitive ( ) ) ; <CTX> public RubyBoolean primitive_p ( ) { return RubyBoolean . newBoolean ( getRuntime ( ) , javaClass . isPrimitive ( ) ) ; }	return RubyBoolean . newBoolean ( getRuntime ( ) , isPrimitive ( ) ) ;
if ( editorWorkbooks . size ( ) < 1 ) setActiveWorkbook ( createDefaultWorkbook ( ) , false ) ; else setActiveWorkbook ( ( EditorStack ) editorWorkbooks . get ( 0 ) , false ) ; <CTX> public EditorStack getActiveWorkbook ( ) { if ( activeEditorWorkbook == null ) { if ( editorWorkbooks . size ( ) < 1 ) setActiveWorkbook ( createDefaultWorkbook ( ) , false ) ; else setActiveWorkbook ( ( EditorStack ) editorWorkbooks . get ( 0 ) , false ) ; } return activeEditorWorkbook ; }	if ( editorWorkbooks . size ( ) < 1 ) { setActiveWorkbook ( createDefaultWorkbook ( ) , false ) ; } else { setActiveWorkbook ( ( EditorStack ) editorWorkbooks . get ( 0 ) , false ) ; }
ILabelEventHandler eh = ( ILabelEventHandler ) getInstance ( ( LabelHandle ) labelDesign . getHandle ( ) ) ; <CTX> public static void handleOnRender ( LabelContent content , ExecutionContext context ) { try { ReportItemDesign labelDesign = ( ReportItemDesign ) content . getGenerateBy ( ) ; ILabelInstance label = new LabelInstance ( content , context ) ; if ( handleJS ( label , labelDesign . getOnRender ( ) , context ) . didRun ( ) ) return ; ILabelEventHandler eh = ( ILabelEventHandler ) getInstance ( ( LabelHandle ) labelDesign . getHandle ( ) ) ; if ( eh != null ) eh . onRender ( label , context . getReportContext ( ) ) ; } catch ( Exception e ) { log . log ( Level . WARNING , e . getMessage ( ) , e ) ; } }	ILabelEventHandler eh = getEventHandler ( labelDesign , context ) ;
BodyAdapter rbody = ( BodyAdapter ) bodies . get ( id ) ; <CTX> public BodyAdapter getRemoteAdapter ( UniqueID id ) { BodyAdapter rbody = ( BodyAdapter ) bodies . get ( id ) ; ProActiveRuntimeForwarderImpl partf = ( ProActiveRuntimeForwarderImpl ) ProActiveRuntimeImpl . getProActiveRuntime ( ) ; return new BodyAdapterForwarder ( partf . getBodyAdapterForwarder ( ) , rbody ) ; }	BodyAdapter rbody = bodies . get ( id ) ;
BeanWrapper superBean = new BeanWrapperImpl ( superClass ) ; if ( superBean . isReadableProperty ( this . name ) ) { <CTX> public DefaultGrailsDomainClassProperty ( DefaultGrailsDomainClass domainClass , PropertyDescriptor descriptor ) { this . domainClass = domainClass ; / / required by default this . optional = false ; / / persistant by default this . persistant = true ; this . name = descriptor . getName ( ) ; this . naturalName = GrailsClassUtils . getNaturalName ( descriptor . getName ( ) ) ; this . type = descriptor . getPropertyType ( ) ; this . identity = descriptor . getName ( ) . equals ( IDENTITY ) ; / / figure out if this property is inherited if ( ! domainClass . isRoot ( ) ) { Class superClass = domainClass . getClazz ( ) . getSuperclass ( ) ; BeanWrapper superBean = new BeanWrapperImpl ( superClass ) ; if ( superBean . isReadableProperty ( this . name ) ) { this . inherited = true ; } } / / get the not required descritor from the owner bean List optionalProps ; List transientProps ; optionalProps = ( List ) domainClass . getPropertyValue ( OPTIONAL , List . class ) ; transientProps = ( List ) domainClass . getPropertyValue ( TRANSIENT , List . class ) ; / / Undocumented feature alert ! Steve insisted on this : - ) List evanescent = ( List ) domainClass . getPropertyValue ( EVANESCENT , List . class ) ; if ( evanescent != null ) { if ( transientProps == null ) transientProps = new ArrayList ( ) ; transientProps . addAll ( evanescent ) ; } / / establish of property is required if ( optionalProps != null ) { for ( Iterator i = optionalProps . iterator ( ) ; i . hasNext ( ) ; ) { / / make sure its a string otherwise ignore . Note : Maybe put a warning here ? Object currentObj = i . next ( ) ; if ( currentObj instanceof String ) { String propertyName = ( String ) currentObj ; / / if the property name in the not required list / / matches this property name set not required if ( propertyName . equals ( this . name ) ) { this . optional = true ; break ; } } } } / / establish if property is persistant if ( transientProps != null ) { for ( Iterator i = transientProps . iterator ( ) ; i . hasNext ( ) ; ) { / / make sure its a string otherwise ignore . Note : Again maybe a warning ? Object currentObj = i . next ( ) ; if ( currentObj instanceof String ) { String propertyName = ( String ) currentObj ; / / if the property name is on the not persistant list / / then set persistant to false if ( propertyName . equals ( this . name ) ) { this . persistant = false ; break ; } } } } }	PropertyDescriptor pd = BeanUtils . getPropertyDescriptor ( superClass , this . name ) ; if ( pd != null && pd . getReadMethod ( ) != null ) {
int width = table . getColumnModel ( ) . getTotalColumnWidth ( ) ; int height = table . getRowCount ( ) * ( table . getRowHeight ( ) + table . getRowMargin ( ) ) ; return new Dimension ( width , height ) ; <CTX> public Dimension getPreferredSize ( JComponent comp ) { int width = table . getColumnModel ( ) . getTotalColumnWidth ( ) ; int height = table . getRowCount ( ) * ( table . getRowHeight ( ) + table . getRowMargin ( ) ) ; return new Dimension ( width , height ) ; }	int prefTotalColumnWidth = 0 ; for ( int i = 0 ; i < table . getColumnCount ( ) ; i ++ ) { TableColumn col = table . getColumnModel ( ) . getColumn ( i ) ; prefTotalColumnWidth += col . getPreferredWidth ( ) ; } return new Dimension ( prefTotalColumnWidth , getHeight ( ) ) ;
validateLoginStatement = connection . prepareStatement ( SystemGlobals . getValue ( CONF_QUERY_VALIDATE_LOGIN ) ) ; selectNameStatement = connection . prepareStatement ( SystemGlobals . getValue ( CONF_QUERY_SELECT_NAME ) ) ; selectGroupsStatement = connection . prepareStatement ( SystemGlobals . getValue ( CONF_QUERY_SELECT_GROUPS ) ) ; <CTX> public JdbcLoginServer ( ) throws SQLException { connection = DriverManager . getConnection ( SystemGlobals . getValue ( CONF_CONNECTION ) ) ; validateLoginStatement = connection . prepareStatement ( SystemGlobals . getValue ( CONF_QUERY_VALIDATE_LOGIN ) ) ; selectNameStatement = connection . prepareStatement ( SystemGlobals . getValue ( CONF_QUERY_SELECT_NAME ) ) ; selectGroupsStatement = connection . prepareStatement ( SystemGlobals . getValue ( CONF_QUERY_SELECT_GROUPS ) ) ; }	validateLoginStatement = connection . prepareStatement ( SystemGlobals . getValue ( ConfigKeys . EXTERNAL_QUERY_VALIDATE_LOGIN ) ) ; selectNameStatement = connection . prepareStatement ( SystemGlobals . getValue ( ConfigKeys . EXTERNAL_QUERY_SELECT_NAME ) ) ; selectGroupsStatement = connection . prepareStatement ( SystemGlobals . getValue ( ConfigKeys . EXTERNAL_QUERY_SELECT_GROUPS ) ) ;
IModuleNameSpace namescope = module <CTX> public List getVisibleDataSources ( ) { IModuleNameSpace namescope = module . getModuleNameSpace ( Module . DATA_SOURCE_NAME_SPACE ) ; List elementList = namescope . getElements ( IModuleNameSpace . NATIVE_LEVEL ) ; return generateHandleList ( elementList ) ; }	IModuleNameScope namescope = module
tmp . add ( tq , false , false ) ; <CTX> public static Query formSimilarQuery ( String body , Analyzer a , String field , Set stop ) throws IOException { TokenStream ts = a . tokenStream ( field , new StringReader ( body ) ) ; org . apache . lucene . analysis . Token t ; BooleanQuery tmp = new BooleanQuery ( ) ; Set already = new HashSet ( ) ; / / ignore dups while ( ( t = ts . next ( ) ) != null ) { String word = t . termText ( ) ; / / ignore opt stop words if ( stop != null && stop . contains ( word ) ) continue ; / / ignore dups if ( ! already . add ( word ) ) continue ; / / add to query TermQuery tq = new TermQuery ( new Term ( field , word ) ) ; try { tmp . add ( tq , false , false ) ; } catch ( BooleanQuery . TooManyClauses too ) { / / fail - safe , just return what we have , not the end of the world break ; } } return tmp ; }	tmp . add ( tq , BooleanClause . Occur . SHOULD ) ;
enabledSubmissions . add ( new EnabledSubmission ( workbenchSite , null , <CTX> public void setScopes ( String [ ] scopes ) { if ( disposed ) return ; / / Either deactivate myself , or remove the previous submissions myself . boolean active = false ; if ( ( parent != null ) && ( parent . activeService == this ) ) { active = true ; parent . deactivateNestedService ( ) ; } else { Workbench . getInstance ( ) . getContextSupport ( ) . removeEnabledSubmissions ( enabledSubmissions ) ; } enabledSubmissions . clear ( ) ; / / Determine the new list of submissions . enabledContextIds = new HashSet ( Arrays . asList ( scopes ) ) ; for ( Iterator iterator = enabledContextIds . iterator ( ) ; iterator . hasNext ( ) ; ) { String contextId = ( String ) iterator . next ( ) ; enabledSubmissions . add ( new EnabledSubmission ( workbenchSite , null , contextId ) ) ; } / / Submit the new contexts myself , or simply re - active myself . if ( parent != null ) { if ( active ) { parent . activateNestedService ( this ) ; } } else { Workbench . getInstance ( ) . getContextSupport ( ) . addEnabledSubmissions ( enabledSubmissions ) ; } }	enabledSubmissions . add ( new EnabledSubmission ( null , workbenchSite ,
( PsiBinaryExpression ) expression ; <CTX> private void checkCondition ( PsiExpression expression , PsiStatement context ) { if ( expression instanceof PsiInstanceOfExpression ) { final PsiInstanceOfExpression instanceOfExpression = ( PsiInstanceOfExpression ) expression ; final PsiExpression operand = instanceOfExpression . getOperand ( ) ; checkCondition ( operand , context ) ; } else if ( expression instanceof PsiBinaryExpression ) { final PsiBinaryExpression binaryExpression = ( PsiBinaryExpression ) expression ; PsiExpression lhs = binaryExpression . getLOperand ( ) ; PsiExpression rhs = binaryExpression . getROperand ( ) ; if ( rhs == null ) { return ; } lhs = ParenthesesUtils . stripParentheses ( lhs ) ; rhs = ParenthesesUtils . stripParentheses ( rhs ) ; if ( ComparisonUtils . isComparison ( binaryExpression ) ) { if ( lhs instanceof PsiLiteralExpression ) { checkCondition ( rhs , context ) ; } else if ( rhs instanceof PsiLiteralExpression ) { checkCondition ( lhs , context ) ; } } else { checkCondition ( rhs , context ) ; checkCondition ( lhs , context ) ; } } else if ( expression instanceof PsiReferenceExpression ) { final PsiReferenceExpression referenceExpression = ( PsiReferenceExpression ) expression ; final PsiElement element = referenceExpression . resolve ( ) ; if ( element instanceof PsiLocalVariable ) { final PsiLocalVariable variable = ( PsiLocalVariable ) element ; if ( ! VariableAccessUtils . variableIsAssigned ( variable , context ) ) { registerError ( expression ) ; } } else if ( element instanceof PsiParameter ) { final PsiParameter parameter = ( PsiParameter ) element ; if ( ! VariableAccessUtils . variableIsAssigned ( parameter , context ) ) { registerError ( expression ) ; } } } else if ( expression instanceof PsiPrefixExpression ) { final PsiPrefixExpression prefixExpression = ( PsiPrefixExpression ) expression ; final PsiJavaToken sign = prefixExpression . getOperationSign ( ) ; final IElementType tokenType = sign . getTokenType ( ) ; if ( JavaTokenType . EXCL . equals ( tokenType ) ) { final PsiExpression operand = prefixExpression . getOperand ( ) ; checkCondition ( operand , context ) ; } } }	( PsiBinaryExpression ) condition ;
advice . append ( getFactory ( ) . createDup ( tempVarType . getSize ( ) ) ) ; <CTX> public void weaveAfterReturning ( BcelAdvice munger ) { InstructionFactory fact = getFactory ( ) ; List returns = new ArrayList ( ) ; Instruction ret = null ; for ( InstructionHandle ih = range . getStart ( ) ; ih != range . getEnd ( ) ; ih = ih . getNext ( ) ) { if ( ih . getInstruction ( ) instanceof ReturnInstruction ) { returns . add ( ih ) ; ret = Utility . copyInstruction ( ih . getInstruction ( ) ) ; } } InstructionList retList ; InstructionHandle afterAdvice ; if ( ret != null ) { retList = new InstructionList ( ret ) ; afterAdvice = retList . getStart ( ) ; } else / * if ( munger . hasDynamicTests ( ) ) * / { retList = new InstructionList ( fact . NOP ) ; afterAdvice = retList . getStart ( ) ; / / } else { / / retList = new InstructionList ( ) ; / / afterAdvice = null ; } InstructionList advice = new InstructionList ( ) ; BcelVar tempVar = null ; if ( munger . hasExtraParameter ( ) ) { TypeX tempVarType = getReturnType ( ) ; if ( tempVarType . equals ( ResolvedTypeX . VOID ) ) { tempVar = genTempVar ( TypeX . OBJECT ) ; advice . append ( getFactory ( ) . ACONST_NULL ) ; tempVar . appendStore ( advice , getFactory ( ) ) ; } else { tempVar = genTempVar ( tempVarType ) ; advice . append ( getFactory ( ) . createDup ( tempVarType . getSize ( ) ) ) ; tempVar . appendStore ( advice , getFactory ( ) ) ; } } advice . append ( munger . getAdviceInstructions ( this , tempVar , afterAdvice ) ) ; if ( ret != null ) { InstructionHandle gotoTarget = advice . getStart ( ) ; for ( Iterator i = returns . iterator ( ) ; i . hasNext ( ) ; ) { InstructionHandle ih = ( InstructionHandle ) i . next ( ) ; Utility . replaceInstruction ( ih , fact . createBranchInstruction ( Constants . GOTO , gotoTarget ) , enclosingMethod ) ; } range . append ( advice ) ; range . append ( retList ) ; } else { range . append ( advice ) ; range . append ( retList ) ; } }	advice . append ( InstructionFactory . createDup ( tempVarType . getSize ( ) ) ) ;
hider . setEnabled ( true ) ; fastViewSash . setVisible ( false ) ; <CTX> public void setState ( int newState ) { super . setState ( newState ) ; ViewPane pane = currentPane ; switch ( newState ) { case IStackPresentationSite . STATE_MINIMIZED : currentPane . getPage ( ) . toggleFastView ( currentPane . getViewReference ( ) ) ; break ; case IStackPresentationSite . STATE_MAXIMIZED : hider . setEnabled ( false ) ; fastViewSash . setVisible ( false ) ; getPresentation ( ) . setBounds ( getBounds ( ) ) ; break ; case IStackPresentationSite . STATE_RESTORED : hider . setEnabled ( true ) ; fastViewSash . setVisible ( false ) ; getPresentation ( ) . setBounds ( getBounds ( ) ) ; break ; default : } }	sash . setVisible ( true ) ;
initComponent ( ( BaseComponent ) componentInstance , ( Class ) componentKey ) ; <CTX> public Object getComponentInstance ( PicoContainer picoContainer ) throws PicoInitializationException , PicoIntrospectionException { Object componentInstance = super . getComponentInstance ( picoContainer ) ; initComponent ( ( BaseComponent ) componentInstance , ( Class ) componentKey ) ; return componentInstance ; }	if ( componentInstance instanceof BaseComponent ) { initComponent ( ( BaseComponent ) componentInstance , ( Class ) componentKey ) ; }
out . writeObject ( destination ) ; out . writeObject ( replyToDestination ) ; <CTX> public void writeExternal ( ObjectOutput out ) throws IOException { super . writeExternal ( out ) ; out . writeObject ( destination ) ; out . writeObject ( replyToDestination ) ; writeString ( out , jmsType ) ; writeMap ( out , properties ) ; if ( correlationIDBytes == null ) { out . writeInt ( - 1 ) ; } else { out . writeInt ( correlationIDBytes . length ) ; out . write ( correlationIDBytes ) ; } writeString ( out , correlationID ) ; writeString ( out , connectionID ) ; }	writeDestination ( out , replyToDestination ) ;
DATASOURCE , PUBLICATION , HERBARIUM , / * CREATEDWHEN , * / / * UPDATEDWHEN , * / METADATA , NOTE ) ; <CTX> public List < String > getColumns ( ) { return asList ( UNITIDDB , UNITVALUE , HABITAT , PLANT , YEARCOLLECTED , MONTHCOLLECTED , DAYCOLLECTED , TIMECOLLECTED , ISODATETIMEBEGIN , DATASOURCE , PUBLICATION , HERBARIUM , / * CREATEDWHEN , * / / * UPDATEDWHEN , * / METADATA , NOTE ) ; }	DATASOURCE , PUBLICATION , HERBARIUM , METADATA , NOTE , DELETED ) ;
synchronized ( localNames ) { if ( ! ( localNames . contains ( name ) ) ) { return false ; } <CTX> public boolean unregister ( String name ) { boolean ret = true ; / / quick - check locally synchronized ( localNames ) { if ( ! ( localNames . contains ( name ) ) ) { return false ; } } / / unregister globally try { globReg . unbind ( name ) ; } catch ( Exception e ) { / / ignore ret = false ; } / / unregister locally try { localReg . unregister ( name ) ; } catch ( RuntimeException re ) { / / ignore ret = false ; } / / release local name synchronized ( localNames ) { localNames . remove ( name ) ; } return ret ; }	if ( get ( name ) == null ) { return false ;
boolean isDerived = ( ( Boolean ) value ) . booleanValue ( ) ; showDerived = isDerived ; if ( isDerived ) lastComplitedMacher = null ; setSearchPattern ( patternString ) ; <CTX> public void setFilterParam ( int param , Object value ) { if ( param == PATTERN ) { setSearchPattern ( ( String ) value ) ; } if ( param == DERIVED ) { boolean isDerived = ( ( Boolean ) value ) . booleanValue ( ) ; showDerived = isDerived ; if ( isDerived ) lastComplitedMacher = null ; setSearchPattern ( patternString ) ; } }	setSearchDerived ( ( ( Boolean ) value ) . booleanValue ( ) ) ;
Runtime getRunTimeCodeBase ( ) ; <CTX> Runtime getRunTimeCodeBase ( ) ;	RunTime getRunTimeCodeBase ( ) ;
setMessage ( message ) ; <CTX> public void handleEvent ( Event event ) { setMessage ( message ) ; }	shell . getDisplay ( ) . asyncExec ( new Runnable ( ) { public void run ( ) { setMessage ( message ) ; } } ) ;
} else { client . finishedClientRequest ( this ) ; } <CTX> private void finish ( ) { if ( persistenceType == ClientRequest . PERSIST_CONNECTION ) { origHandler . finishedClientRequest ( this ) ; } else { client . finishedClientRequest ( this ) ; } }	client . finishedClientRequest ( this ) ;
infoMessages . add ( message ) ; <CTX> public void addInfoMessage ( String message ) { infoMessages . add ( message ) ; }	this . infoMessages . add ( message ) ;
gapWidth -= length ; <CTX> public synchronized void contentRemoved ( int offset , int length ) { if ( root == null ) { gapWidth = 0 ; return ; } if ( gapWidth != 0 && gapOffset < offset ) { root . contentRemoved ( gapOffset , offset , offset + length , gapWidth , true ) ; } else if ( gapWidth != 0 && gapOffset > offset + length ) { root . contentRemoved ( offset , offset + length , gapOffset , gapWidth , false ) ; } else { root . contentRemoved ( offset , offset + length , offset + length , gapWidth , false ) ; } gapOffset = offset ; gapWidth -= length ; } / / } } }	gapWidth -= length ; * /
return getIndex ( ) ; <CTX> public int getBlockStartIndex ( ) { return getIndex ( ) ; }	if ( linearIterator != null ) return linearIterator . getBlockStart ( ) ; else return deltasIterator . getIndex ( ) ;
MEditingDomainGetter . getMEditingDomain ( ( View ) getModel ( ) ) . runAsRead ( new MRunnable ( ) { <CTX> public String isValid ( final Object value ) { if ( value instanceof String ) { / / final IElement element = resolveModelReference ( ) ; final IParserEditStatus isValid [ ] = { null } ; final IParser descParser = getParser ( ) ; try { MEditingDomainGetter . getMEditingDomain ( ( View ) getModel ( ) ) . runAsRead ( new MRunnable ( ) { public Object run ( ) { isValid [ 0 ] = descParser . isValidEditString ( null , ( String ) value ) ; return null ; } } ) ; } catch ( Exception e ) { Log . error ( DiagramUIPlugin . getInstance ( ) , IStatus . ERROR , e . getMessage ( ) , e ) ; } return isValid [ 0 ] . getCode ( ) == ParserEditStatus . EDITABLE ? null : isValid [ 0 ] . getMessage ( ) ; } return null ; }	IParserEditStatus isValid = ( IParserEditStatus ) getEditingDomain ( ) . runExclusive ( new RunnableWithResult . Impl ( ) {
return getBooleanProperty ( Style . CAN_SHRINK_PROP ) ; <CTX> public boolean canShrink ( ) { return getBooleanProperty ( Style . CAN_SHRINK_PROP ) ; }	return getBooleanProperty ( IStyleModel . CAN_SHRINK_PROP ) ;
Compiler batchCompiler = <CTX> private void compile ( ) throws InvalidInputException , InterruptedException { final INameEnvironment environment = getEnvironment ( ) ; Compiler batchCompiler = new Compiler ( environment , getHandlingPolicy ( ) , getCompilerOptions ( ) , getBatchRequestor ( ) , getProblemFactory ( ) ) ; batchCompiler . compile ( getCompilationUnits ( ) ) ; myCompilationResults . offer ( END_OF_STREAM ) ; environment . cleanup ( ) ; }	Compiler compiler =
if ( object == null ) return ; object . setWaitingForRequest ( false ) ; <CTX> public void objectWaitingByNecessity ( UniqueID id , SpyEvent spyEvent ) { if ( ! controller . isMonitoring ( ) ) return ; ActiveObject object = findActiveObject ( id ) ; if ( object == null ) return ; object . setWaitingForRequest ( false ) ; communicationEventListener . objectWaitingByNecessity ( object , spyEvent ) ; }	if ( object == null ) { return ; } object . setServingStatus ( object . getServingStatus ( ) == ActiveObject . STATUS_SERVING_REQUEST ? ActiveObject . STATUS_WAITING_BY_NECESSITY_WHILE_SERVING : ActiveObject . STATUS_WAITING_BY_NECESSITY_WHILE_ACTIVE ) ;
} else { IStatus locationStatus = existingProject . getWorkspace ( ) . validateProjectLocationURI ( existingProject , newPath ) ; if ( ! locationStatus . isOK ( ) ) { return locationStatus . getMessage ( ) ; } <CTX> public String checkValidLocation ( ) { if ( isDefault ( ) ) { return null ; } String locationFieldContents = locationPathField . getText ( ) ; if ( locationFieldContents . length ( ) == 0 ) { return ( IDEWorkbenchMessages . WizardNewProjectCreationPage_projectLocationEmpty ) ; } URI newPath = getProjectLocationURI ( ) ; if ( newPath == null ) { return IDEWorkbenchMessages . ProjectLocationSelectionDialog_locationError ; } if ( existingProject == null ) { IPath projectPath = new Path ( locationFieldContents ) ; if ( Platform . getLocation ( ) . isPrefixOf ( projectPath ) ) { return IDEWorkbenchMessages . WizardNewProjectCreationPage_defaultLocationError ; } } else { IStatus locationStatus = existingProject . getWorkspace ( ) . validateProjectLocationURI ( existingProject , newPath ) ; if ( ! locationStatus . isOK ( ) ) { return locationStatus . getMessage ( ) ; } URI projectPath = existingProject . getLocationURI ( ) ; if ( projectPath != null && URIUtil . equals ( projectPath , newPath ) ) { return IDEWorkbenchMessages . ProjectLocationSelectionDialog_locationError ; } } return null ; }	if ( ! locationStatus . isOK ( ) ) { return locationStatus . getMessage ( ) ; } if ( existingProject != null ) {
static void init ( ) { <CTX> static void init ( ) { gcBarrier = new VM_GCSynchronizationBarrier ( ) ; collectorThreads = new VM_CollectorThread [ 1 + VM_Scheduler . MAX_PROCESSORS ] ; }	static void init ( ) throws VM_PragmaInterruptible {
Variable var = mgr . createVariable ( ( StackFrame ) context , getQualifiedName ( ) ) ; <CTX> public ICDIValue getValue ( ICDIStackFrame context ) throws CDIException { Session session = ( Session ) getTarget ( ) . getSession ( ) ; RegisterManager mgr = session . getRegisterManager ( ) ; Variable var = mgr . createVariable ( ( StackFrame ) context , getQualifiedName ( ) ) ; return var . getValue ( ) ; }	Variable var = mgr . createShadowRegister ( this , ( StackFrame ) context , getQualifiedName ( ) ) ;
Offset methodOffset = Offset . fromIntSignExtend ( cm . getOsrJTOCoffset ( ) ) ; <CTX> protected final void emit_invoke_compiledmethod ( VM_CompiledMethod cm ) { Offset methodOffset = Offset . fromIntSignExtend ( cm . getOsrJTOCoffset ( ) ) ; boolean takeThis = ! cm . method . isStatic ( ) ; VM_MethodReference ref = cm . method . getMemberRef ( ) . asMethodReference ( ) ; genParameterRegisterLoad ( ref , takeThis ) ; asm . emitCALL_RegDisp ( JTOC , methodOffset ) ; genResultRegisterUnload ( ref ) ; }	Offset methodOffset = cm . getOsrJTOCoffset ( ) ;
else if ( GrailsClassUtils . isDomainClass ( relatedClassType ) ) { <CTX> private void establishRelationshipForSet ( DefaultGrailsDomainClassProperty property ) { / / is it a relationship Class relatedClassType = getRelatedClassType ( property . getName ( ) ) ; if ( relatedClassType != null ) { / / set the referenced type in the property property . setReferencedPropertyType ( relatedClassType ) ; / / if the related class is the same as this class / / its a circular one - to - many if ( relatedClassType . getName ( ) . equals ( getFullName ( ) ) ) { property . setOneToMany ( true ) ; property . setBidirectional ( true ) ; } / / if the related type is a domain class / / then figure out what kind of relationship it is else if ( GrailsClassUtils . isDomainClass ( relatedClassType ) ) { / / check the relationship defined in the referenced type / / if it is also a Set / domain class etc . Map relatedClassRelationships = GrailsDomainConfigurationUtil . getAssociationMap ( relatedClassType ) ; Class relatedClassPropertyType = null ; / / if the related type has a relationships map it may be a many - to - many / / figure out if there is a many - to - many relationship defined if ( relatedClassRelationships != null && ! relatedClassRelationships . isEmpty ( ) ) { String relatedClassPropertyName = null ; / / retrieve the relationship property for ( Iterator i = relatedClassRelationships . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String currentKey = ( String ) i . next ( ) ; Class currentClass = ( Class ) relatedClassRelationships . get ( currentKey ) ; if ( currentClass . getName ( ) . equals ( getClazz ( ) . getName ( ) ) ) { relatedClassPropertyName = currentKey ; break ; } } / / if there is one defined get the type if ( relatedClassPropertyName != null ) { relatedClassPropertyType = GrailsClassUtils . getProperyType ( relatedClassType , relatedClassPropertyName ) ; } } / / otherwise figure out if there is a one - to - many relationship by retrieving any properties that are of the related type / / if there is more than one property then ( for the moment ) ignore the relationship if ( relatedClassPropertyType == null ) { PropertyDescriptor [ ] descriptors = GrailsClassUtils . getPropertiesOfType ( relatedClassType , getClazz ( ) ) ; if ( descriptors . length == 1 ) { relatedClassPropertyType = descriptors [ 0 ] . getPropertyType ( ) ; } } establishRelationshipForSetToType ( property , relatedClassPropertyType ) ; / / if its a many - to - many figure out the owning side of the relationship if ( property . isManyToMany ( ) ) { establishOwnerOfManyToMany ( property , relatedClassType ) ; } } / / otherwise set it to not persistent as you can t persist / / relationships to non - domain classes else { property . setPersistant ( false ) ; } } else { / / no relationship defined for set . / / set not persistent property . setPersistant ( false ) ; } }	if ( GrailsClassUtils . isDomainClass ( relatedClassType ) ) {
return new Point ( trim . width , trim . height ) ; <CTX> public Point computeSize ( int wHint , int hHint , boolean changed ) { checkWidget ( ) ; int minWidth = 0 ; int minHeight = 0 ; / / preferred width of tab area to show all tabs GC gc = new GC ( this ) ; for ( int i = 0 ; i < items . length ; i ++ ) { minWidth += items [ i ] . preferredWidth ( gc ) ; } gc . dispose ( ) ; / / preferred size of controls in tab items for ( int i = 0 ; i < items . length ; i ++ ) { Control control = items [ i ] . getControl ( ) ; if ( control != null && ! control . isDisposed ( ) ) { Point size = control . computeSize ( wHint , hHint ) ; minWidth = Math . max ( minWidth , size . x ) ; minHeight = Math . max ( minHeight , size . y ) ; } } if ( minWidth == 0 ) minWidth = DEFAULT_WIDTH ; if ( minHeight == 0 ) minHeight = DEFAULT_HEIGHT ; if ( wHint != SWT . DEFAULT ) minWidth = wHint ; if ( hHint != SWT . DEFAULT ) minHeight = hHint ; Rectangle trim = computeTrim ( 0 , 0 , minWidth , minHeight ) ; return new Point ( trim . width , trim . height ) ; }	return new Point ( trim . width - trim . x , trim . height - trim . y ) ;
return comment . getCreated ( ) ; <CTX> public Date getDate ( ) { return comment . getCreated ( ) ; }	return attachment . getDateCreated ( ) ;
input = new Channel ( Short . TYPE , 1 ) ; <CTX> public void init ( ) { input = new Channel ( Short . TYPE , 1 ) ; }	input = new Channel ( Float . TYPE , 1 ) ;
String strval = newValue . toString ( ) ; <CTX> public void userChangedValue ( Object newValue ) { if ( ! unlocked && ! isEditable ( ) ) { / / if this data is read - only , / / restore its old value in case the user messed it up . if ( consumer != null ) consumer . repositoryChangedValue ( ) ; } else try { / / parse the new value . lastValue = value ; if ( newValue instanceof Boolean ) setBoolean ( ( Boolean ) newValue ) ; else { String strval = newValue . toString ( ) ; if ( strval == null || strval . length ( ) == 0 ) value = ( optional ? null : getNullValue ( ) ) ; else if ( strval . equals ( RESTORE_DEFAULT_COMMAND ) ) value = RESTORE_DEFAULT_TOKEN ; else setString ( strval ) ; } / / if the data value has changed , if ( value == null || lastValue == null || ! value . saveString ( ) . equals ( lastValue . saveString ( ) ) ) { / / save it to the repository . data . putValue ( dataName , value ) ; lastValue = value ; } / / This could be a MalformedValueException / / ( from the setString call ) or RemoteException } catch ( Exception e ) { / / ( from the putValue call ) . value = lastValue ; / / restore original value of element . if ( consumer != null ) / / restore the HTMLField to the old value . consumer . repositoryChangedValue ( ) ; } }	String strval = null ; if ( newValue != null ) strval = newValue . toString ( ) ;
Resource resource = domain . findResource ( storagePath , loadOptions ) ; if ( resource == null ) { resource = domain . createResource ( storagePath ) ; } domain . loadResource ( resource , loadOptions , contents ) ; <CTX> public Resource load ( MEditingDomain domain , int loadOptions , IProgressMonitor monitor ) throws CoreException { InputStream contents = fStorage . getContents ( ) ; String storagePath = fStorage . getFullPath ( ) . toString ( ) ; Resource resource = domain . findResource ( storagePath , loadOptions ) ; if ( resource == null ) { resource = domain . createResource ( storagePath ) ; } domain . loadResource ( resource , loadOptions , contents ) ; return resource ; }	Resource resource = editingDomain . getResourceSet ( ) . getResource ( URI . createPlatformResourceURI ( storagePath , true ) , true ) ;
try { pushIterator ( navigator . getSelfAxisIterator ( contextNode ) ) ; } catch ( UnsupportedAxisException e ) { } init ( contextNode , navigator ) ; <CTX> public DescendantOrSelfAxisIterator ( Object contextNode , Navigator navigator ) { try { pushIterator ( navigator . getSelfAxisIterator ( contextNode ) ) ; } catch ( UnsupportedAxisException e ) { } init ( contextNode , navigator ) ; }	super ( navigator , new SingletonList ( contextNode ) . iterator ( ) ) ;
return ( IScannerInfo ) getBuildInfo ( resource , false ) ; <CTX> public IScannerInfo getScannerInformation ( IResource resource ) { return ( IScannerInfo ) getBuildInfo ( resource , false ) ; }	return ( IScannerInfo ) getBuildInfo ( resource . getProject ( ) , false ) ;
return category . getDescription ( false ) ; <CTX> public String getCategoryName ( ) { return category . getDescription ( false ) ; }	return category . getDescription ( ) ;
if ( textControl == null ) return ; <CTX> public void addText ( Text textControl ) { if ( textControl == null ) return ; activeTextControl = textControl ; textControl . addListener ( SWT . Activate , textControlListener ) ; textControl . addListener ( SWT . Deactivate , textControlListener ) ; / / We really want a selection listener but it is not supported so we / / use a key listener and a mouse listener to know when selection changes / / may have occured textControl . addKeyListener ( keyAdapter ) ; textControl . addMouseListener ( mouseAdapter ) ; }	if ( textControl == null ) { return ; }
NumberDataValue getDataValue ( int value ) ; <CTX> NumberDataValue getDataValue ( int value ) ;	NumberDataValue getDataValue ( Integer value ) ;
return getStringProperty ( Cell . EVENT_HANDLER_CLASS_PROP ) ; <CTX> public String getEventHandleClass ( ) { return getStringProperty ( Cell . EVENT_HANDLER_CLASS_PROP ) ; }	return getStringProperty ( IDesignElementModel . EVENT_HANDLER_CLASS_PROP ) ;
} else if ( accessibility == ProgramElementNode . Accessibility . PRIVILEGED ) { <CTX> public Icon getAccessibilitySwingIcon ( ProgramElementNode . Accessibility accessibility ) { if ( accessibility == ProgramElementNode . Accessibility . PUBLIC ) { return ACCESSIBILITY_PUBLIC ; } else if ( accessibility == ProgramElementNode . Accessibility . PACKAGE ) { return ACCESSIBILITY_PACKAGE ; } else if ( accessibility == ProgramElementNode . Accessibility . PROTECTED ) { return ACCESSIBILITY_PROTECTED ; } else if ( accessibility == ProgramElementNode . Accessibility . PRIVATE ) { return ACCESSIBILITY_PRIVATE ; } else if ( accessibility == ProgramElementNode . Accessibility . PRIVILEGED ) { return ACCESSIBILITY_PRIVILEGED ; } else { return null ; } }	} else if ( accessibility == IProgramElement . Accessibility . PRIVILEGED ) {
return ( Direction ) AttributeFactory . eINSTANCE . createFromString ( AttributePackage . eINSTANCE . getDirection ( ) , <CTX> public Direction createDirectionObjectFromString ( EDataType eDataType , String initialValue ) { return ( Direction ) AttributeFactory . eINSTANCE . createFromString ( AttributePackage . eINSTANCE . getDirection ( ) , initialValue ) ; }	return ( Direction ) createDirectionFromString ( AttributePackage . Literals . DIRECTION ,
SysViewImportHandler ( Importer importer , NamespaceResolver nsContext ) { super ( importer , nsContext ) ; <CTX> SysViewImportHandler ( Importer importer , NamespaceResolver nsContext ) { super ( importer , nsContext ) ; }	SysViewImportHandler ( Importer importer ) { super ( importer ) ;
if ( ! model . isForward ( ) ) { <CTX> public static boolean searchAgain ( Project project , FileEditor fileEditor ) { if ( ! ( fileEditor instanceof TextEditor ) ) return false ; TextEditor textEditor = ( TextEditor ) fileEditor ; Editor editor = textEditor . getEditor ( ) ; FindManager findManager = FindManager . getInstance ( project ) ; if ( ! findManager . findWasPerformed ( ) ) { find ( project , editor ) ; return false ; } FindModel model = findManager . getFindNextModel ( ) ; if ( model == null ) { model = findManager . getFindInFileModel ( ) ; } model = ( FindModel ) model . clone ( ) ; int offset ; if ( DOWN . equals ( editor . getUserData ( KEY ) ) && model . isForward ( ) ) { offset = 0 ; } else if ( UP . equals ( editor . getUserData ( KEY ) ) && ! model . isForward ( ) ) { offset = editor . getDocument ( ) . getTextLength ( ) ; } else { editor . putUserData ( KEY , null ) ; offset = editor . getCaretModel ( ) . getOffset ( ) ; if ( ! model . isForward ( ) ) { offset -- ; } } return searchAgain ( project , editor , offset , model ) ; }	if ( ! model . isForward ( ) && offset > 0 ) {
return new EventJDOM ( makeChildElement ( EventJDOM . BIRTH ) ) ; <CTX> public Event getBirthEvent ( ) { return new EventJDOM ( makeChildElement ( EventJDOM . BIRTH ) ) ; }	return new EventJDOM ( JDOMUtils . findOrMakeChildElement ( EventJDOM . BIRTH , element ) ) ;
getPendingConnection ( connId ) . send ( packet ) ; <CTX> private void sendToPending ( int connId , Packet packet ) { getPendingConnection ( connId ) . send ( packet ) ; }	if ( getPendingConnection ( connId ) != null ) { getPendingConnection ( connId ) . send ( packet ) ; } else { }
this . output . addRef ( encodeTypeEntry ( elaboratedType . getFullyQualifiedNameCharArrays ( ) , FWD_CLASS , ICSearchConstants . DECLARATIONS ) ) ; <CTX> public void addElaboratedForwardDeclaration ( IASTElaboratedTypeSpecifier elaboratedType ) { if ( elaboratedType . getClassKind ( ) . equals ( ASTClassKind . CLASS ) ) { this . output . addRef ( encodeTypeEntry ( elaboratedType . getFullyQualifiedNameCharArrays ( ) , FWD_CLASS , ICSearchConstants . DECLARATIONS ) ) ; } else if ( elaboratedType . getClassKind ( ) . equals ( ASTClassKind . STRUCT ) ) { this . output . addRef ( encodeTypeEntry ( elaboratedType . getFullyQualifiedNameCharArrays ( ) , FWD_STRUCT , ICSearchConstants . DECLARATIONS ) ) ; } else if ( elaboratedType . getClassKind ( ) . equals ( ASTClassKind . UNION ) ) { this . output . addRef ( encodeTypeEntry ( elaboratedType . getFullyQualifiedNameCharArrays ( ) , FWD_UNION , ICSearchConstants . DECLARATIONS ) ) ; } }	this . output . addRef ( encodeTypeEntry ( elaboratedType . getFullyQualifiedNameCharArrays ( ) , FWD_CLASS , ICSearchConstants . DECLARATIONS ) , indexFlag ) ;
synchronized ( Animator . this ) { Animator . this . notify ( ) ; } <CTX> public void run ( ) { / / Try to get OpenGL context optimization since we know we / / will be rendering this one drawable continually from / / this thread ; make the context current once instead of / / making it current and freeing it each frame . drawable . setRenderingThread ( Thread . currentThread ( ) ) ; / / Since setRenderingThread is currently advisory ( because / / of the poor JAWT implementation in the Motif AWT , which / / performs excessive locking ) we also prevent repaint ( ) , / / which is called from the AWT thread , from having an / / effect for better multithreading behavior . This call is / / not strictly necessary , but if end users write their / / own animation loops which update multiple drawables per / / tick then it may be necessary to enforce the order of / / updates . drawable . setNoAutoRedrawMode ( true ) ; boolean noException = false ; try { while ( ! shouldStop ) { noException = false ; drawable . display ( ) ; noException = true ; } } finally { shouldStop = false ; drawable . setNoAutoRedrawMode ( false ) ; if ( noException ) { try { drawable . setRenderingThread ( null ) ; } finally { thread = null ; synchronized ( Animator . this ) { Animator . this . notify ( ) ; } } } } }	Animator . this . notify ( ) ;
return ; <CTX> private void processNestedInclusions ( int fileNumber , IASTInclusionNode [ ] inclusions , IASTInclusionNode parent ) { for ( int i = 0 ; i < inclusions . length ; i ++ ) { IASTInclusionNode inclusion = inclusions [ i ] ; / / Quick check to see if the name is in an already indexed external header file if ( IndexEncoderUtil . nodeInVisitedExternalHeader ( inclusion . getIncludeDirective ( ) , getIndexer ( ) ) ) return ; String include = inclusion . getIncludeDirective ( ) . getPath ( ) ; if ( areProblemMarkersEnabled ( ) ) { IPath newPath = new Path ( include ) ; IFile tempFile = CCorePlugin . getWorkspace ( ) . getRoot ( ) . getFileForLocation ( newPath ) ; if ( tempFile != null ) { / / File is in the workspace requestRemoveMarkers ( tempFile , resourceFile ) ; } } getOutput ( ) . addIncludeRef ( fileNumber , include ) ; getOutput ( ) . addRelatives ( fileNumber , include , ( parent != null ) ? parent . getIncludeDirective ( ) . getPath ( ) : null ) ; NamedEntry namedEntry = new NamedEntry ( IIndex . INCLUDE , IIndex . REFERENCE , new char [ ] [ ] { include . toCharArray ( ) } , 0 , fileNumber ) ; namedEntry . setNameOffset ( 1 , 1 , IIndex . OFFSET ) ; namedEntry . serialize ( getOutput ( ) ) ; / * See if this file has been encountered before * / indexer . haveEncounteredHeader ( resourceFile . getProject ( ) . getFullPath ( ) , new Path ( include ) , true ) ; / / recurse processNestedInclusions ( fileNumber , inclusion . getNestedInclusions ( ) , inclusion ) ; } }	continue ;
Object rtxt = messageInfo . getMetaData ( BindingProviderProperties . JAXWS_RUNTIME_CONTEXT ) ; return rtxt == null ? null : ( RuntimeContext ) rtxt ; <CTX> public static RuntimeContext getRuntimeContext ( MessageInfo messageInfo ) { Object rtxt = messageInfo . getMetaData ( BindingProviderProperties . JAXWS_RUNTIME_CONTEXT ) ; return rtxt == null ? null : ( RuntimeContext ) rtxt ; }	return ( RuntimeContext ) messageInfo . getMetaData ( BindingProviderProperties . JAXWS_RUNTIME_CONTEXT ) ;
if ( selectedView != null ) { restoreItem . setEnabled ( page != null && page . isMoveable ( selectedView ) ) ; } else { restoreItem . setEnabled ( false ) ; <CTX> public void fill ( Menu menu , int index ) { / / TODO Auto - generated method stub super . fill ( menu , index ) ; orientationItem = new MenuItem ( menu , SWT . CASCADE , index ++ ) ; { orientationItem . setText ( WorkbenchMessages . FastViewBar_view_orientation ) ; Menu orientationSwtMenu = new Menu ( orientationItem ) ; RadioMenu orientationMenu = new RadioMenu ( orientationSwtMenu , currentOrientation ) ; orientationMenu . addMenuItem ( WorkbenchMessages . FastViewBar_horizontal , new Integer ( SWT . HORIZONTAL ) ) ; orientationMenu . addMenuItem ( WorkbenchMessages . FastViewBar_vertical , new Integer ( SWT . VERTICAL ) ) ; orientationItem . setMenu ( orientationSwtMenu ) ; } restoreItem = new MenuItem ( menu , SWT . CHECK , index ++ ) ; restoreItem . setText ( WorkbenchMessages . ViewPane_fastView ) ; restoreItem . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { bar . restoreView ( selectedView , true , true ) ; } } ) ; closeItem = new MenuItem ( menu , SWT . NONE , index ++ ) ; closeItem . setText ( WorkbenchMessages . WorkbenchWindow_close ) ; closeItem . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { if ( selectedView != null ) { WorkbenchPage page = bar . getWindow ( ) . getActiveWorkbenchPage ( ) ; if ( page != null ) { page . hideView ( selectedView ) ; } } } } ) ; / / Set menu item enablement etc based on whether a view is selected WorkbenchPage page = bar . getWindow ( ) . getActiveWorkbenchPage ( ) ; if ( selectedView != null ) { restoreItem . setEnabled ( page != null && page . isMoveable ( selectedView ) ) ; } else { restoreItem . setEnabled ( false ) ; } restoreItem . setSelection ( true ) ; if ( selectedView != null ) { closeItem . setEnabled ( page != null && page . isCloseable ( selectedView ) ) ; } else { closeItem . setEnabled ( false ) ; } orientationItem . setEnabled ( selectedView != null ) ; if ( selectedView != null ) { / / Set the new orientation , but avoid re - sending the event to our own / / listener currentOrientation . set ( bar . getOrientation ( selectedView ) , orientationChangeListener ) ; } }	if ( restoreItem != null ) { if ( selectedView != null ) { restoreItem . setEnabled ( page != null && page . isMoveable ( selectedView ) ) ; } else { restoreItem . setEnabled ( false ) ; } restoreItem . setSelection ( true ) ;
this . glassPane = ( JPanel ) getGlassPane ( ) ; this . progressBar = new JProgressBar ( ) ; <CTX> public WaitCursor ( Object component , String message ) { this . component = component ; this . message = message ; this . glassPane = ( JPanel ) getGlassPane ( ) ; this . progressBar = new JProgressBar ( ) ; }	this . glassPane = ( JPanel ) findGlassPane ( component ) ; this . statusReporter = statusReporter ;
Iterator iter = targetList . listIterator ( ) ; <CTX> public void updateOwner ( IResource resource ) { / / Check to see if the owner is the same as the argument if ( resource != null ) { if ( ! owner . equals ( resource ) ) { owner = resource ; / / Do the same for the targets Iterator iter = targetList . listIterator ( ) ; while ( iter . hasNext ( ) ) { ITarget target = ( ITarget ) iter . next ( ) ; target . updateOwner ( resource ) ; } } } }	Iterator iter = getTargets ( ) . listIterator ( ) ;
setDisableMessageTimestamp ( boolean value ) throws JMSException ; <CTX> setDisableMessageTimestamp ( boolean value ) throws JMSException ;	void setDisableMessageTimestamp ( boolean value ) throws JMSException ;
if ( ! workspace . getRoot ( ) . getProject ( projectName ) . exists ( ) ) <CTX> private String getCopyNameFor ( String projectName ) { IWorkspace workspace = getProject ( ) . getWorkspace ( ) ; if ( ! workspace . getRoot ( ) . getProject ( projectName ) . exists ( ) ) return projectName ; int counter = 1 ; while ( true ) { String nameSegment ; if ( counter > 1 ) { nameSegment = NLS . bind ( IDEWorkbenchMessages . CopyProjectAction_copyNameTwoArgs , new Integer ( counter ) , projectName ) ; } else { nameSegment = NLS . bind ( IDEWorkbenchMessages . CopyProjectAction_copyNameOneArg , projectName ) ; } if ( ! workspace . getRoot ( ) . getProject ( nameSegment ) . exists ( ) ) return nameSegment ; counter ++ ; } }	if ( ! workspace . getRoot ( ) . getProject ( projectName ) . exists ( ) ) {
showTab (_junitErrorPanel ) ;_junitErrorPanel . setJUnitInProgress ( docs ) ;_junitAction . setEnabled ( false ) ;_junitAllAction . setEnabled ( false ) ; <CTX> public void run ( ) { / / MainFrame . this . hourglassOn ( ) ; showTab (_junitErrorPanel ) ;_junitErrorPanel . setJUnitInProgress ( docs ) ;_junitAction . setEnabled ( false ) ;_junitAllAction . setEnabled ( false ) ; }	_ model . setActiveDocument ( doc ) ; showTab (_interactionsPane ) ;
return ( false ) ; <CTX> equals ( Object obj ) { if ( obj == null ) return ( false ) ; if ( ! ( obj instanceof Font ) ) return ( false ) ; Font f = ( Font ) obj ; return ( f . getName ( ) . equals ( this . getName ( ) ) && f . getFamily ( ) . equals ( this . getFamily ( ) ) && f . getFontName ( ) . equals ( this . getFontName ( ) ) && f . getTransform ( ) . equals ( this . getTransform ( ) ) && f . getSize ( ) == this . getSize ( ) && f . getStyle ( ) == this . getStyle ( ) ) ; }	return false ;
removeWorkspaceDescriptors ( ( IPluginModelBase ) removed [ i ] ) ; <CTX> public void modelsChanged ( IModelProviderEvent e ) { int type = e . getEventTypes ( ) ; if ( ( type & IModelProviderEvent . MODELS_ADDED ) != 0 ) { IModel [ ] added = e . getAddedModels ( ) ; for ( int i = 0 ; i < added . length ; i ++ ) { loadWorkspaceDescriptors ( ( IPluginModelBase ) added [ i ] ) ; } } if ( ( type & IModelProviderEvent . MODELS_REMOVED ) != 0 ) { IModel [ ] removed = e . getRemovedModels ( ) ; for ( int i = 0 ; i < removed . length ; i ++ ) { removeWorkspaceDescriptors ( ( IPluginModelBase ) removed [ i ] ) ; } } if ( ( type & IModelProviderEvent . MODELS_CHANGED ) != 0 ) { IModel [ ] changed = e . getChangedModels ( ) ; if ( dirtyWorkspaceModels == null ) dirtyWorkspaceModels = new Vector ( ) ; for ( int i = 0 ; i < changed . length ; i ++ ) { dirtyWorkspaceModels . add ( ( IPluginModelBase ) changed [ i ] ) ; } } }	IModel model = removed [ i ] ; if ( ! ( model instanceof IPluginModelBase ) ) continue ; removeWorkspaceDescriptors ( ( IPluginModelBase ) model ) ;
target [ 0 ] = new CDebugTarget ( launch , ICDebugTargetType . TARGET_TYPE_LOCAL_CORE_DUMP , cdiTarget , name , null , debuggerProcess , file , true , false ) ; <CTX> public void run ( IProgressMonitor m ) { target [ 0 ] = new CDebugTarget ( launch , ICDebugTargetType . TARGET_TYPE_LOCAL_CORE_DUMP , cdiTarget , name , null , debuggerProcess , file , true , false ) ; }	target [ 0 ] = new CCoreFileDebugTarget ( launch , cdiTarget , name , debuggerProcess , file ) ;
void buildLabel ( ViewerLabel updateLabel , Object element , IViewerLabelProvider labelProvider ) { <CTX> void buildLabel ( ViewerLabel updateLabel , Object element , IViewerLabelProvider labelProvider ) { labelProvider . updateLabel ( updateLabel , element ) ; colorAndFontCollector . setUsedDecorators ( ) ; if ( updateLabel . hasNewBackground ( ) ) { colorAndFontCollector . setBackground ( updateLabel . getBackground ( ) ) ; } if ( updateLabel . hasNewForeground ( ) ) { colorAndFontCollector . setForeground ( updateLabel . getForeground ( ) ) ; } if ( updateLabel . hasNewFont ( ) ) { colorAndFontCollector . setFont ( updateLabel . getFont ( ) ) ; } }	protected void buildLabel ( ViewerLabel updateLabel , Object element ) {
( ( Hashtable ) colors ) . clear ( ) ; <CTX> public void setMode ( Mode mode ) { if ( this . mode == mode ) return ; if ( this . mode != null ) this . mode . leave ( this ) ; this . mode = mode ; if ( mode == null ) { tokenMarker = null ; } else { setTokenMarker ( mode . createTokenMarker ( ) ) ; ( ( Hashtable ) colors ) . clear ( ) ; / / XXX mode . enter ( this ) ; } fireBufferEvent ( new BufferEvent ( BufferEvent . MODE_CHANGED , this ) ) ; }	( ( Hashtable ) getColors ( ) ) . clear ( ) ;
catch ( java . awt . datatransfer . UnsupportedFlavorException e ) { } catch ( IOException e ) { <CTX> public void a_paste ( ) { java . awt . datatransfer . Clipboard clipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; java . awt . datatransfer . Transferable contents = clipboard . getContents ( null ) ; if ( contents != null ) { try { String text = ( String ) contents . getTransferData ( java . awt . datatransfer . DataFlavor . stringFlavor ) ; propList . pastePropertiesString ( text ) ; } catch ( java . awt . datatransfer . UnsupportedFlavorException e ) { } catch ( IOException e ) { } } }	else { try { String text = ( String ) contents . getTransferData ( java . awt . datatransfer . DataFlavor . stringFlavor ) ; propList . pastePropertiesString ( text ) ; } catch ( UnsupportedFlavorException e ) { } catch ( IOException e ) { }
return ++ absoluteSequenceID ; <CTX> private synchronized long getNextSequenceID ( ) { return ++ absoluteSequenceID ; }	return bodyID . toString ( ) . hashCode ( ) ++ ++ absoluteSequenceID ;
return new ISourceContainer [ 0 ] ; <CTX> public ISourceContainer [ ] computeSourceContainers ( ILaunchConfiguration configuration , IProgressMonitor monitor ) throws CoreException { String projectName = configuration . getAttribute ( ICDTLaunchConfigurationConstants . ATTR_PROJECT_NAME , ( String ) null ) ; if ( projectName != null ) { IProject project = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getProject ( projectName ) ; if ( project . exists ( ) ) { return new ISourceContainer [ ] { new ProjectSourceContainer ( project , true ) } ; } } return new ISourceContainer [ 0 ] ; }	return ( ISourceContainer [ ] ) containers . toArray ( new ISourceContainer [ containers . size ( ) ] ) ;
return RubyModule . m_newModule ( ruby , ( RubyClass ) klass ) ; <CTX> public VALUE rb_module_s_new ( VALUE klass ) { return RubyModule . m_newModule ( ruby , ( RubyClass ) klass ) ; }	return RubyModule . m_new ( ruby , ( RubyObject ) klass ) ;
if ( data == null ) { return getIdValue ( id ) ; <CTX> public Object get ( String name , Scriptable start ) { if ( maxId != 0 ) { int id = getId ( name ) ; if ( id != 0 ) { Object [ ] data = idMapData ; if ( data == null ) { return getIdValue ( id ) ; } else { Object value = data [ id - 1 ] ; if ( value == null ) { value = getIdValue ( id ) ; } else if ( value == NULL_TAG ) { value = null ; } return value ; } } } return super . get ( name , start ) ; }	if ( data == null ) { int id = mapNameToId ( name ) ; if ( id != 0 ) { return getIdValue ( id ) ; }
setStringProperty ( Style . WHITE_SPACE_PROP , value ) ; <CTX> public void setWhiteSpace ( String value ) throws SemanticException { setStringProperty ( Style . WHITE_SPACE_PROP , value ) ; }	setStringProperty ( IStyleModel . WHITE_SPACE_PROP , value ) ;
if ( children . contains ( content ) ) <CTX> public void startContent ( IContent content ) { List children = root . getChildren ( ) ; if ( parent != null ) { children = parent . getChildren ( ) ; } if ( children . contains ( content ) ) { children . add ( content ) ; } parent = content ; }	if ( ! children . contains ( content ) )
if ( rga . isEmpty ( ) || item == null ) { <CTX> public synchronized RandomGrabArrayItem removeRandom ( ) { while ( true ) { if ( grabArrays . length == 0 ) return null ; int x = rand . nextInt ( grabArrays . length ) ; RemoveRandomWithClient rga = grabArrays [ x ] ; RandomGrabArrayItem item = rga . removeRandom ( ) ; if ( rga . isEmpty ( ) || item == null ) { Object client = rga . getClient ( ) ; grabArraysByClient . remove ( client ) ; RandomGrabArrayWithClient [ ] newArray = new RandomGrabArrayWithClient [ grabArrays . length - 1 ] ; if ( x > 0 ) System . arraycopy ( grabArrays , 0 , newArray , 0 , x ) ; if ( x < grabArrays . length - 1 ) System . arraycopy ( grabArrays , x + 1 , newArray , x , grabArrays . length - ( x + 1 ) ) ; grabArrays = newArray ; } if ( item == null ) continue ; if ( item . isFinished ( ) ) continue ; return item ; } }	if ( rga . isEmpty ( ) || ( item == null ) ) {
iCodeTop = addShort ( index , iCodeTop ) ; lastStringIndex = index ; <CTX> private int addString ( String str , int iCodeTop ) { int index = itsStrings . get ( str , - 1 ) ; if ( index == - 1 ) { index = itsStrings . size ( ) ; itsStrings . put ( str , index ) ; } iCodeTop = addShort ( index , iCodeTop ) ; lastStringIndex = index ; return iCodeTop ; }	iCodeTop = addIndex ( index , iCodeTop ) ; lastAddString = str ;
getCellEditor ( ) . addCellEditorListener ( this ) ; <CTX> protected AccessibleJTable ( ) { getModel ( ) . addTableModelListener ( this ) ; getSelectionModel ( ) . addListSelectionListener ( this ) ; getColumnModel ( ) . addColumnModelListener ( this ) ; getCellEditor ( ) . addCellEditorListener ( this ) ; }	lastSelectedRow = getSelectedRow ( ) ; lastSelectedColumn = getSelectedColumn ( ) ; TableCellEditor editor = getCellEditor ( ) ; if ( editor != null ) editor . addCellEditorListener ( this ) ;
* color . The fix is to send a fake WM_SETFOCUS event to cause <CTX> void setBackgroundPixel ( int pixel ) { if ( background == pixel ) return ; super . setBackgroundPixel ( pixel ) ; / * * Bug in Windows . Changing the background color of the Scale * widget and calling InvalidateRect ( ) still draws with the old * color . The fix is to send a fake WM_SETFOCUS event to cause * it to redraw with the new background color . * / ignoreFocus = true ; OS . SendMessage ( handle , OS . WM_SETFOCUS , 0 , 0 ) ; ignoreFocus = false ; }	* color . The fix is to send a fake WM_SIZE event to cause
{ acc . add ( attr ) ; } <CTX> void addNamespaceAttributes ( Node context , Collection acc ) { NamedNodeMap attrs = context . getAttributes ( ) ; if ( attrs != null ) { int attrLen = attrs . getLength ( ) ; for ( int i = 0 ; i < attrLen ; i ++ ) { Node attr = attrs . item ( i ) ; if ( isNamespaceAttribute ( attr ) ) { acc . add ( attr ) ; } } } }	acc . add ( attr ) ;
switch ( eDerivedStructuralFeatureID ( eFeature ) ) <CTX> public Object eGet ( EStructuralFeature eFeature , boolean resolve ) { switch ( eDerivedStructuralFeatureID ( eFeature ) ) { case LayoutPackage . LEGEND__ CHILDREN : return getChildren ( ) ; case LayoutPackage . LEGEND__ BOUNDS : return getBounds ( ) ; case LayoutPackage . LEGEND__ ANCHOR : return getAnchor ( ) ; case LayoutPackage . LEGEND__ STRETCH : return getStretch ( ) ; case LayoutPackage . LEGEND__ INSETS : return getInsets ( ) ; case LayoutPackage . LEGEND__ ROW : return new Integer ( getRow ( ) ) ; case LayoutPackage . LEGEND__ COLUMN : return new Integer ( getColumn ( ) ) ; case LayoutPackage . LEGEND__ ROWSPAN : return new Integer ( getRowspan ( ) ) ; case LayoutPackage . LEGEND__ COLUMNSPAN : return new Integer ( getColumnspan ( ) ) ; case LayoutPackage . LEGEND__ MIN_SIZE : return getMinSize ( ) ; case LayoutPackage . LEGEND__ OUTLINE : return getOutline ( ) ; case LayoutPackage . LEGEND__ BACKGROUND : return getBackground ( ) ; case LayoutPackage . LEGEND__ VISIBLE : return isVisible ( ) ? Boolean . TRUE : Boolean . FALSE ; case LayoutPackage . LEGEND__ TRIGGERS : return getTriggers ( ) ; case LayoutPackage . LEGEND__ HORIZONTAL_SPACING : return new Integer ( getHorizontalSpacing ( ) ) ; case LayoutPackage . LEGEND__ VERTICAL_SPACING : return new Integer ( getVerticalSpacing ( ) ) ; case LayoutPackage . LEGEND__ CLIENT_AREA : return getClientArea ( ) ; case LayoutPackage . LEGEND__ TEXT : return getText ( ) ; case LayoutPackage . LEGEND__ ORIENTATION : return getOrientation ( ) ; case LayoutPackage . LEGEND__ DIRECTION : return getDirection ( ) ; case LayoutPackage . LEGEND__ SEPARATOR : return getSeparator ( ) ; case LayoutPackage . LEGEND__ POSITION : return getPosition ( ) ; case LayoutPackage . LEGEND__ ITEM_TYPE : return getItemType ( ) ; case LayoutPackage . LEGEND__ TITLE : return getTitle ( ) ; case LayoutPackage . LEGEND__ TITLE_POSITION : return getTitlePosition ( ) ; case LayoutPackage . LEGEND__ SHOW_VALUE : return isShowValue ( ) ? Boolean . TRUE : Boolean . FALSE ; case LayoutPackage . LEGEND__ SHOW_PERCENT : return isShowPercent ( ) ? Boolean . TRUE : Boolean . FALSE ; case LayoutPackage . LEGEND__ SHOW_TOTAL : return isShowTotal ( ) ? Boolean . TRUE : Boolean . FALSE ; } return eDynamicGet ( eFeature , resolve ) ; }	switch ( featureID )
node . element = new String ( tag . name ) ; <CTX> public static void coerceNode ( Lexer lexer , Node node , Dict tag ) { Node tmp = lexer . inferredTag ( tag . name ) ; Report . warning ( lexer , node , tmp , Report . OBSOLETE_ELEMENT ) ; node . was = node . tag ; node . tag = tag ; node . type = StartTag ; node . implicit = true ; node . element = new String ( tag . name ) ; }	node . element = tag . name ;
} int span = ( int ) child . getPreferredSpan ( flowAxis ) ; if ( span > spanLeft ) { offset = - 1 ; <CTX> protected int layoutRow ( FlowView fv , int rowIndex , int pos ) { int spanLeft = fv . getFlowSpan ( rowIndex ) ; if ( spanLeft <= 0 ) return - 1 ; int offset = pos ; View row = fv . getView ( rowIndex ) ; int flowAxis = fv . getFlowAxis ( ) ; while ( spanLeft > 0 ) { View child = createView ( fv , offset , spanLeft , rowIndex ) ; if ( child == null ) { offset = - 1 ; break ; } int span = ( int ) child . getPreferredSpan ( flowAxis ) ; if ( span > spanLeft ) { offset = - 1 ; break ; } row . append ( child ) ; spanLeft -= span ; offset = child . getEndOffset ( ) ; } return offset ; }	View view = createView ( fv , offset , span , rowIndex ) ; if ( view == null )
seedFromExternalStuff ( ) ; <CTX> public void checkpoint ( ) { seedFromExternalStuff ( ) ; }	seedFromExternalStuff ( true ) ;
addItem ( String item ) { add ( item ) ; } <CTX> addItem ( String item ) { add ( item ) ; }	public synchronized void addItem ( String item ) { add ( item ) ; }
java . lang . String folderId , java . lang . String name , java . lang . String title , java . lang . String description ) <CTX> public static com . liferay . portlet . documentlibrary . model . DLFileEntry updateFileEntry ( java . lang . String folderId , java . lang . String name , java . lang . String title , java . lang . String description ) throws com . liferay . portal . PortalException , java . rmi . RemoteException , com . liferay . portal . SystemException { DLFileEntryService dlFileEntryService = DLFileEntryServiceFactory . getService ( ) ; return dlFileEntryService . updateFileEntry ( folderId , name , title , description ) ; }	java . lang . String folderId , java . lang . String newFolderId , java . lang . String name , java . lang . String sourceFileName , java . lang . String title , java . lang . String description , byte [ ] byteArray )
newestSuccessfulBuild = new BuildInfo ( newestSuccessfulLogfile . getName ( ) ) ; <CTX> public void setProjectDirectory ( File directory ) { File newestLogfile = CruiseControlTagSupport . getLatestLogFile ( directory ) ; if ( newestLogfile == null ) { newestBuild = null ; } else { try { newestBuild = new BuildInfo ( newestLogfile . getName ( ) ) ; } catch ( ParseException pe ) { newestBuild = null ; } } File newestSuccessfulLogfile = CruiseControlTagSupport . getLatestSuccessfulLogFile ( directory ) ; if ( newestSuccessfulLogfile == null ) { newestSuccessfulBuild = null ; } else { try { newestSuccessfulBuild = new BuildInfo ( newestSuccessfulLogfile . getName ( ) ) ; } catch ( ParseException pe ) { newestBuild = null ; } } }	newestSuccessfulBuild = new BuildInfo ( newestSuccessfulLogfile ) ;
InetAddress ( byte [ ] address , String hostname ) <CTX> InetAddress ( byte [ ] address , String hostname ) { addr = address ; hostName = hostname ; if ( address != null ) family = getFamily ( address ) ; }	InetAddress ( byte [ ] address )
create ( GDK_WINDOW_TYPE_HINT_DIALOG , true ) ; <CTX> void create ( ) { / / Create a decorated dialog window . create ( GDK_WINDOW_TYPE_HINT_DIALOG , true ) ; Dialog dialog = ( Dialog ) awtComponent ; gtkWindowSetModal ( dialog . isModal ( ) ) ; setTitle ( dialog . getTitle ( ) ) ; setResizable ( dialog . isResizable ( ) ) ; }	create ( GDK_WINDOW_TYPE_HINT_DIALOG , ! ( ( Dialog ) awtComponent ) . isUndecorated ( ) ) ;
if ( coolBarManager instanceof CoolBarManager ) { return ( ( CoolBarManager ) coolBarManager ) . createControl ( composite ) ; <CTX> protected Control createCoolBarControl ( Composite composite ) { if ( coolBarManager instanceof CoolBarManager ) { return ( ( CoolBarManager ) coolBarManager ) . createControl ( composite ) ; } return null ; }	if ( coolBarManager != null ) { return coolBarManager . createControl ( composite ) ;
catchCond = new Node ( TokenStream . PRIMARY , new Integer ( TokenStream . TRUE ) ) ; <CTX> public Object createCatch ( String varName , Object catchCond , Object stmts , int lineno ) { if ( catchCond == null ) catchCond = new Node ( TokenStream . PRIMARY , new Integer ( TokenStream . TRUE ) ) ; Node result = new Node ( TokenStream . CATCH , ( Node ) createName ( varName ) , ( Node ) catchCond , ( Node ) stmts ) ; result . setDatum ( new Integer ( lineno ) ) ; return result ; }	catchCond = new Node ( TokenStream . PRIMARY , TokenStream . TRUE ) ;
File module = moduleProject . getFile ( ) ; <CTX> public String getModulePathAdjustment ( MavenProject moduleProject ) throws IOException { File module = moduleProject . getFile ( ) ; if ( module == null ) { return null ; } module = module . getCanonicalFile ( ) ; if ( moduleFiles == null ) { moduleFiles = new HashMap ( ) ; List modules = getModules ( ) ; File myFile = getFile ( ) ; if ( myFile != null ) { File myDir = myFile . getCanonicalFile ( ) . getParentFile ( ) ; if ( modules != null ) { for ( Iterator it = modules . iterator ( ) ; it . hasNext ( ) ; ) { String modulePath = ( String ) it . next ( ) ; File moduleFile = new File ( myDir , modulePath ) . getCanonicalFile ( ) ; moduleFiles . put ( moduleFile , modulePath ) ; } } } } return ( String ) moduleFiles . get ( module ) ; }	String module = moduleProject . getArtifactId ( ) ;
q . setParameter ( i , queryArgs [ i ] ) ; <CTX> public Object doInHibernate ( Session session ) throws HibernateException , SQLException { Query q = session . createQuery ( query ) ; Object [ ] queryArgs = null ; if ( arguments . length > 1 ) { if ( arguments [ 1 ] instanceof List ) { queryArgs = ( ( List ) arguments [ 1 ] ) . toArray ( ) ; } else if ( arguments [ 1 ] . getClass ( ) . isArray ( ) ) { queryArgs = ( Object [ ] ) arguments [ 1 ] ; } } if ( queryArgs != null ) { for ( int i = 0 ; i < queryArgs . length ; i ++ ) { q . setParameter ( i , queryArgs [ i ] ) ; } } / / only want one result , could have used uniqueObject here / / but it throws an exception if its not unique which is / / undesirable q . setMaxResults ( 1 ) ; List results = q . list ( ) ; if ( results . size ( ) > 0 ) return results . get ( 0 ) ; return null ; }	if ( queryArgs [ 0 ] instanceof GString ) { q . setParameter ( i , queryArgs [ i ] . toString ( ) ) ; } else { q . setParameter ( i , queryArgs [ i ] ) ; }
return openThumbImage ( id , 0 ) . getWidth ( ) ; <CTX> public int getThumbSizeX ( String id ) throws FormatException , IOException { return openThumbImage ( id , 0 ) . getWidth ( ) ; }	if ( ! id . equals ( currentId ) ) initFile ( id ) ; if ( ifds . length == 1 ) return super . getThumbSizeX ( id ) ; return TiffTools . getIFDIntValue ( ifds [ 1 ] , TiffTools . IMAGE_WIDTH , false , 1 ) ;
result = new Boolean ( true ) ; <CTX> public void doit ( ) throws ProcessingException { LEAVES_COMPOUNDS . getResult ( ) ; getGlyphInspector ( ) . processUndueStems ( ) ; result = new Boolean ( true ) ; getGlyphInspector ( ) . evaluateGlyphs ( GlyphInspector . getCleanupMaxGrade ( ) ) ; }	result = Boolean . valueOf ( true ) ;
gd . verticalAlignment = gd . BEGINNING ; <CTX> protected void doFillIntoGrid ( Composite parent , int numColumns ) { Control control = getLabelControl ( parent ) ; GridData gd = new GridData ( ) ; gd . horizontalSpan = numColumns ; control . setLayoutData ( gd ) ; list = getListControl ( parent ) ; gd = new GridData ( GridData . FILL_HORIZONTAL ) ; gd . verticalAlignment = gd . FILL ; gd . horizontalSpan = numColumns - 1 ; gd . grabExcessHorizontalSpace = true ; list . setLayoutData ( gd ) ; buttonBox = getButtonBoxControl ( parent ) ; gd = new GridData ( ) ; gd . verticalAlignment = gd . BEGINNING ; buttonBox . setLayoutData ( gd ) ; }	gd . verticalAlignment = GridData . BEGINNING ;
if ( element . isPopulated ( ) ) return getChildren ( element ) . length > 0 ; else { <CTX> public boolean hasChildren ( Object o ) { if ( o instanceof MinimizedFileSystemElement ) { MinimizedFileSystemElement element = ( MinimizedFileSystemElement ) o ; if ( element . isPopulated ( ) ) return getChildren ( element ) . length > 0 ; else { / / If we have not populated then wait until asked return true ; } } return false ; }	if ( element . isPopulated ( ) ) { return getChildren ( element ) . length > 0 ; } else {
return_parent [ node ] ; <CTX> public int next ( ) { int node ; while ( ( node =_source . next ( ) ) != END ) { String val = getNodeValue ( node ) ; if (_value . equals ( val ) ==_op ) { return_parent [ node ] ; } } return END ; }	if (_returnType == RETURN_CURRENT ) return returnNode ( node ) ; else return returnNode (_parent [ node ] ) ;
context . finishProcess ( context . getCurrentProcess ( ) ) ; } else { context . enterState ( destination ) ; <CTX> protected void followTransition ( ProcessContext context , Transition transition ) throws InvalidMotionException { State destination = transition . getDestination ( ) ; context . exitState ( context . getCurrentState ( ) ) ; if ( destination == null ) { context . finishProcess ( context . getCurrentProcess ( ) ) ; } else { context . enterState ( destination ) ; } }	location . finishProcess ( context . getCurrentProcess ( ) ) ;
ParsedClassType createClassType ( ) ; <CTX> ParsedClassType createClassType ( ) ;	ParsedClassType createClassType ( LazyClassInitializer init ) ;
if ( ! canSelect || selectedColumnName != null ) <CTX> private void updateButtons ( ) { boolean okEnable = false ; if ( ! canSelect || selectedColumnName != null ) { okEnable = true ; } getOkButton ( ) . setEnabled ( okEnable ) ; int min = 0 ; int max = bindingTable . getTable ( ) . getItemCount ( ) - 1 ; if ( ( min <= selectIndex ) && ( selectIndex <= max ) ) { btnDel . setEnabled ( true ) ; if ( btnEdit != null ) btnEdit . setEnabled ( true ) ; } else { btnDel . setEnabled ( false ) ; if ( btnEdit != null ) btnEdit . setEnabled ( false ) ; } bindingTable . getTable ( ) . select ( selectIndex ) ; }	if ( ! canSelect || ( selectedColumnName != null && getDataSetName ( ) != null ) )
jsi . itsData = new InterpreterData ( itsData . securityDomain , itsData . languageVersion ) ; jsi . itsData . parentData = itsData ; jsi . itsData . itsSourceFile = itsData . itsSourceFile ; jsi . itsData . encodedSource = itsData . encodedSource ; <CTX> private void generateNestedFunctions ( Context cx ) { int functionCount = scriptOrFn . getFunctionCount ( ) ; if ( functionCount == 0 ) return ; InterpreterData [ ] array = new InterpreterData [ functionCount ] ; for ( int i = 0 ; i != functionCount ; i ++ ) { FunctionNode def = scriptOrFn . getFunctionNode ( i ) ; Interpreter jsi = new Interpreter ( ) ; jsi . compilerEnv = compilerEnv ; jsi . scriptOrFn = def ; jsi . itsData = new InterpreterData ( itsData . securityDomain , itsData . languageVersion ) ; jsi . itsData . parentData = itsData ; jsi . itsData . itsSourceFile = itsData . itsSourceFile ; jsi . itsData . encodedSource = itsData . encodedSource ; jsi . itsData . itsCheckThis = def . getCheckThis ( ) ; jsi . itsInFunctionFlag = true ; jsi . generateFunctionICode ( cx ) ; array [ i ] = jsi . itsData ; } itsData . itsNestedFunctions = array ; }	jsi . itsData = new InterpreterData ( itsData ) ;
( ( OptLocalVariable ) theVariables . get ( i ) ) . assignType ( TypeEvent . AnyType ) ; <CTX> void markAnyTypeVariables ( VariableTable theVariables ) { for ( int i = 0 ; i < theVariables . size ( ) ; i ++ ) if ( itsLiveOnEntrySet . test ( i ) ) ( ( OptLocalVariable ) theVariables . get ( i ) ) . assignType ( TypeEvent . AnyType ) ; }	( ( OptLocalVariable ) theVariables . getVariable ( i ) ) . assignType ( TypeEvent . AnyType ) ;
this ( source , id , when , modifiers , keyCode , keyChar , KEY_LOCATION_UNKNOWN ) ; <CTX> public KeyEvent ( Component source , int id , long when , int modifiers , int keyCode , char keyChar ) { this ( source , id , when , modifiers , keyCode , keyChar , KEY_LOCATION_UNKNOWN ) ; }	super ( source , id , when , modifiers ) ; this . keyCode = keyCode ; this . keyChar = keyChar ; this . keyLocation = keyLocation ; if ( ( id == KEY_TYPED && ( keyCode != VK_UNDEFINED || keyChar == CHAR_UNDEFINED ) ) || keyLocation < KEY_LOCATION_UNKNOWN || keyLocation > KEY_LOCATION_NUMPAD ) throw new IllegalArgumentException ( ) ;
return RubyFixnum . newFixnum ( runtime , id ) ; <CTX> public RubyFixnum to_i ( ) { return RubyFixnum . newFixnum ( runtime , id ) ; }	return getRuntime ( ) . newFixnum ( id ) ;
return readers [ index ] . getSizeZ ( id ) ; <CTX> public int getSizeZ ( String id ) throws FormatException , IOException { if ( ! id . equals ( currentId ) ) initFile ( id ) ; return readers [ index ] . getSizeZ ( id ) ; }	return readers [ current ] . getSizeZ ( id ) ;
return NotationPackage . eINSTANCE . getImageStyle ( ) ; } <CTX> protected EClass eStaticClass ( ) { return NotationPackage . eINSTANCE . getImageStyle ( ) ; }	return NotationPackage . Literals . IMAGE_STYLE ; }
if ( value instanceof Integer ) <CTX> protected Object getDistinctColorProperty ( DesignElementHandle handle , DesignElementHandle parentHandle , String name ) { Object value ; Object parentValue ; value = handle . getProperty ( name ) ; parentValue = parentHandle . getProperty ( name ) ; boolean canInherit = StyleDesign . canInherit ( name ) ; int intValue = getColorValue ( value ) ; if ( value != null && ( ! canInherit || intValue != getColorValue ( parentValue ) ) && ( canInherit || intValue != getColorValue ( StyleDesign . getDefaultValue ( name ) ) ) ) { if ( value instanceof Integer ) { return StringUtil . toRgbText ( intValue ) ; } return value ; } return null ; }	int parentValue = getColorValue ( parentHandle . getProperty ( name ) ) ; if ( intValue != parentValue )
aDialog . show ( ) ; <CTX> public void actionPerformed ( ActionEvent e ) { SearchDirectoryDialog aDialog = new SearchDirectoryDialog ( getParentFrame ( ) ) ; / / display the new card dialog aDialog . show ( ) ; aDialog . dispose ( ) ; }	aDialog . setVisible ( true ) ;
if ( getControl ( ) != null ) return ; <CTX> public void createControl ( Composite parent ) { if ( getControl ( ) != null ) return ; partReference . addPropertyListener ( this ) ; / / Create view form . control = new Composite ( parent , SWT . NONE ) ; control . setLayout ( new FillLayout ( ) ) ; / / the part should never be visible by default . It will be made visible / / by activation . This allows us to have views appear in tabs without / / becoming active by default . control . setVisible ( false ) ; control . moveAbove ( null ) ; / / Create a title bar . createTitleBar ( ) ; / / When the pane or any child gains focus , notify the workbench . control . addListener ( SWT . Activate , this ) ; control . addTraverseListener ( traverseListener ) ; }	if ( getControl ( ) != null ) { return ; }
Object instance = ( ( NativeJavaObject ) value ) . unwrap ( ) ; <CTX> public boolean hasInstance ( Scriptable value ) { if ( ! ( value instanceof NativeJavaObject ) ) return false ; Object instance = ( ( NativeJavaObject ) value ) . unwrap ( ) ; return cls . isInstance ( instance ) ; }	Object instance = ( ( Wrapper ) value ) . unwrap ( ) ;
rowData [ i ] = new ColData ( TdsData . readData ( in , columns [ i ] , readTextMode ) , tdsVersion ) ; <CTX> private void tdsRowToken ( ) throws IOException , ProtocolException { for ( int i = 0 ; i < columns . length ; i ++ ) { rowData [ i ] = new ColData ( TdsData . readData ( in , columns [ i ] , readTextMode ) , tdsVersion ) ; } readTextMode = false ; }	rowData [ i ] = new ColData ( TdsData . readData ( connection , in , columns [ i ] , readTextMode ) , tdsVersion ) ;
result . addChildAfter ( incrTarget , body ) ; <CTX> private Node createLoop ( int loopType , Node body , Node cond , Node init , Node incr , int lineno ) { Node . Target bodyTarget = new Node . Target ( ) ; Node . Target condTarget = new Node . Target ( ) ; if ( loopType == LOOP_FOR && cond . getType ( ) == Token . EMPTY ) { cond = new Node ( Token . TRUE ) ; } Node . Jump IFEQ = new Node . Jump ( Token . IFEQ , cond ) ; IFEQ . target = bodyTarget ; Node . Target breakTarget = new Node . Target ( ) ; Node . Jump result = new Node . Jump ( Token . LOOP , lineno ) ; result . addChildToBack ( bodyTarget ) ; result . addChildrenToBack ( body ) ; if ( loopType == LOOP_WHILE || loopType == LOOP_FOR ) { / / propagate lineno to condition result . addChildrenToBack ( new Node ( Token . EMPTY , lineno ) ) ; } result . addChildToBack ( condTarget ) ; result . addChildToBack ( IFEQ ) ; result . addChildToBack ( breakTarget ) ; result . target = breakTarget ; Node . Target continueTarget = condTarget ; if ( loopType == LOOP_WHILE || loopType == LOOP_FOR ) { / / Just add a GOTO to the condition in the do . . while Node . Jump GOTO = new Node . Jump ( Token . GOTO ) ; GOTO . target = condTarget ; result . addChildToFront ( GOTO ) ; if ( loopType == LOOP_FOR ) { if ( init . getType ( ) != Token . EMPTY ) { if ( init . getType ( ) != Token . VAR ) { init = new Node ( Token . EXPR_VOID , init ) ; } result . addChildToFront ( init ) ; } Node . Target incrTarget = new Node . Target ( ) ; result . addChildAfter ( incrTarget , body ) ; if ( incr . getType ( ) != Token . EMPTY ) { incr = new Node ( Token . EXPR_VOID , incr ) ; result . addChildAfter ( incr , incrTarget ) ; } continueTarget = incrTarget ; } } result . setContinue ( continueTarget ) ; return result ; }	loop . addChildAfter ( incrTarget , body ) ;
RenderInternal ( rw ) ; <CTX> public synchronized void Render ( ) { if ( ! rendering ) { rendering = true ; if ( ren . VisibleActorCount ( ) == 0 ) return ; if ( rw != null ) { if ( windowset == 0 ) { / / set the window id and the active camera cam = ren . GetActiveCamera ( ) ; ren . AddLight ( lgt ) ; lgt . SetPosition ( cam . GetPosition ( ) ) ; lgt . SetFocalPoint ( cam . GetFocalPoint ( ) ) ; RenderCreate ( rw ) ; windowset = 1 ; } RenderInternal ( rw ) ; rendering = false ; } } }	Lock ( ) ; rw . Render ( ) ; UnLock ( ) ;
return JavaUtil . convertJavaToRuby ( ruby , proc . call ( JavaUtil . convertJavaToRuby ( ruby , args ) ) ) ; <CTX> public Object invoke ( Object recv , Method imethod , Object [ ] args ) { return JavaUtil . convertJavaToRuby ( ruby , proc . call ( JavaUtil . convertJavaToRuby ( ruby , args ) ) ) ; }	return JavaUtil . convertJavaToRuby ( ruby , proc . call ( JavaUtil . convertJavaArrayToRuby ( ruby , args ) ) ) ;
return DataPackage . eINSTANCE . getNumberDataElement ( ) ; <CTX> protected EClass eStaticClass ( ) { return DataPackage . eINSTANCE . getNumberDataElement ( ) ; }	return DataPackage . Literals . NUMBER_DATA_ELEMENT ;
if ( hasBeenSeen ( ) ) { return BrowserConstants . DefaultFont ; } <CTX> public Font getTextFont ( ) { if ( hasBeenSeen ( ) ) { return BrowserConstants . DefaultFont ; } else { return BrowserConstants . DefaultFontBold ; } }	if ( isSeen ( ) ) { return BrowserConstants . DefaultFont ; }
throw XMPPErrorTranslator . translate ( iox ) ; <CTX> public void send ( final ContainerVersion container , final Map < DocumentVersion , InputStream > documents , final List < JabberId > sendTo , final JabberId sentBy , final Calendar sentOn ) throws SmackException { try { xmppContainer . send ( container , documents , sendTo , sentBy , sentOn ) ; } catch ( final IOException iox ) { throw XMPPErrorTranslator . translate ( iox ) ; } }	throw translateError ( iox ) ;
Rectangle newBounds = Geometry . getExtrudedEdge ( bounds , - SASH_SIZE , oppositeSide ) ; <CTX> private void updateFastViewSashBounds ( Rectangle bounds ) { int oppositeSide = Geometry . getOppositeSide ( side ) ; Rectangle newBounds = Geometry . getExtrudedEdge ( bounds , - SASH_SIZE , oppositeSide ) ; fastViewSash . setBounds ( newBounds ) ; fastViewSash . moveAbove ( null ) ; }	Rectangle newBounds = Geometry . getExtrudedEdge ( bounds , SASH_SIZE , oppositeSide ) ;
return getEditors ( filename , null ) ; <CTX> public IEditorDescriptor [ ] getEditors ( String filename ) { return getEditors ( filename , null ) ; }	return getEditors ( filename , guessAtContentType ( filename ) ) ;
return ( m_actionErrors != null ) && ! m_actionErrors . isEmpty ( ) ; <CTX> public synchronized boolean hasActionErrors ( ) { return ( m_actionErrors != null ) && ! m_actionErrors . isEmpty ( ) ; }	return ( actionErrors != null ) && ! actionErrors . isEmpty ( ) ;
withSingleThreadedWorkaroundDo ( displayOnEventDispatchThreadAction , displayAction , false ) ; <CTX> public void display ( ) { withSingleThreadedWorkaroundDo ( displayOnEventDispatchThreadAction , displayAction , false ) ; }	maybeDoSingleThreadedWorkaround ( displayOnEventDispatchThreadAction , displayAction , false ) ;
intervalBaseText . setEnabled ( intervalBaseButton . getSelection ( ) ) ; <CTX> public void widgetSelected ( SelectionEvent e ) { intervalBaseText . setEnabled ( intervalBaseButton . getSelection ( ) ) ; }	intervalRange . setEnabled ( intervalType . getSelectionIndex ( ) != 0 ) ; intervalBaseButton . setEnabled ( intervalType . getSelectionIndex ( ) != 0 && ( getColumnType ( ) != String . class ) ) ; intervalBaseText . setEnabled ( intervalBaseButton . getEnabled ( ) && intervalBaseButton . getSelection ( ) ) ;
else { <CTX> void consumeExcludes ( IConfigurationElement element ) { Assert . isTrue ( NavigatorViewerDescriptor . TAG_EXCLUDES . equals ( element . getName ( ) ) ) ; IConfigurationElement [ ] contentExtensionPatterns = element . getChildren ( TAG_EXTENSION ) ; String patternString = null ; Pattern compiledPattern = null ; for ( int i = 0 ; i < contentExtensionPatterns . length ; i ++ ) { patternString = contentExtensionPatterns [ i ] . getAttribute ( NavigatorViewerDescriptor . ATT_PATTERN ) ; if ( patternString == null ) NavigatorPlugin . logError ( 0 , NLS . bind ( CommonNavigatorMessages . Attribute_Missing_Warning , new Object [ ] { NavigatorViewerDescriptor . ATT_PATTERN , element . getDeclaringExtension ( ) . getUniqueIdentifier ( ) , element . getDeclaringExtension ( ) . getNamespace ( ) } ) , null ) ; else { compiledPattern = Pattern . compile ( patternString ) ; excludePatterns . add ( compiledPattern ) ; } } }	} else {
ContainerTransactionContext ctx = prepareExistingBNewA ( ) ; <CTX> public void testBSetAExistingBNewA ( ) throws Exception { ContainerTransactionContext ctx = prepareExistingBNewA ( ) ; b . setA ( a ) ; ctx . commit ( ) ; assertStateExistingBNewA ( ) ; }	TransactionContext ctx = prepareExistingBNewA ( ) ;
newX = checkBounds ( newX , m_originalImage . getWidth ( this ) , this . getWidth ( ) ) ; <CTX> protected void setTopLeft ( int x , int y ) { int newX = x ; newX = checkBounds ( newX , m_originalImage . getWidth ( this ) , this . getWidth ( ) ) ; int newY = y ; newY = checkBounds ( newY , m_originalImage . getHeight ( this ) , this . getHeight ( ) ) ; setCoords ( newX , newY ) ; m_control . setLargeCoords ( newX , newY ) ; }	newX = checkBounds ( newX , m_originalImage . getWidth ( this ) , this . getWidth ( ) , true ) ;
m_inspectionClasses . add ( UnnecessaryInterfaceModifierInspection . class ) ; m_inspectionClasses . add ( UnnecessaryEnumModifierInspection . class ) ; <CTX> private void registerVerboseInspections ( ) { m_inspectionClasses . add ( UnnecessaryLabelOnBreakStatementInspection . class ) ; m_inspectionClasses . add ( UnnecessaryLabelOnContinueStatementInspection . class ) ; m_inspectionClasses . add ( PointlessBooleanExpressionInspection . class ) ; m_inspectionClasses . add ( ReplaceAssignmentWithOperatorAssignmentInspection . class ) ; m_inspectionClasses . add ( TrivialIfInspection . class ) ; m_inspectionClasses . add ( UnnecessaryConditionalExpressionInspection . class ) ; m_inspectionClasses . add ( ConstantConditionalExpressionInspection . class ) ; m_inspectionClasses . add ( ConstantIfStatementInspection . class ) ; m_inspectionClasses . add ( UnnecessaryParenthesesInspection . class ) ; m_inspectionClasses . add ( UnnecessaryLocalVariableInspection . class ) ; m_inspectionClasses . add ( UnnecessaryThisInspection . class ) ; m_inspectionClasses . add ( UnnecessaryBlockStatementInspection . class ) ; m_inspectionClasses . add ( UnnecessaryInterfaceModifierInspection . class ) ; m_inspectionClasses . add ( UnnecessaryEnumModifierInspection . class ) ; m_inspectionClasses . add ( UnnecessaryReturnInspection . class ) ; m_inspectionClasses . add ( UnnecessaryContinueInspection . class ) ; m_inspectionClasses . add ( UnnecessarySemicolonInspection . class ) ; m_inspectionClasses . add ( UnnecessaryFullyQualifiedNameInspection . class ) ; m_inspectionClasses . add ( UnnecessaryQualifierForThisInspection . class ) ; m_inspectionClasses . add ( UnusedLabelInspection . class ) ; m_inspectionClasses . add ( RedundantFieldInitializationInspection . class ) ; m_inspectionClasses . add ( RedundantImplementsInspection . class ) ; m_inspectionClasses . add ( ExtendsObjectInspection . class ) ; m_inspectionClasses . add ( TypeParameterExtendsObjectInspection . class ) ; m_inspectionClasses . add ( PointlessArithmeticExpressionInspection . class ) ; m_inspectionClasses . add ( PointlessBitwiseExpressionInspection . class ) ; m_inspectionClasses . add ( UnnecessarySuperConstructorInspection . class ) ; m_inspectionClasses . add ( UnnecessaryConstructorInspection . class ) ; m_inspectionClasses . add ( ForLoopReplaceableByWhileInspection . class ) ; m_inspectionClasses . add ( UnnecessaryDefaultInspection . class ) ; m_inspectionClasses . add ( UnnecessaryBoxingInspection . class ) ; m_inspectionClasses . add ( UnnecessaryUnboxingInspection . class ) ; m_inspectionClasses . add ( UnnecessaryFinalOnParameterInspection . class ) ; m_inspectionClasses . add ( UnnecessaryFinalOnLocalVariableInspection . class ) ; m_inspectionClasses . add ( ForCanBeForeachInspection . class ) ; m_inspectionClasses . add ( WhileCanBeForeachInspection . class ) ; }	m_inspectionClasses . add ( com . siyeh . ig . verbose . UnnecessaryInterfaceModifierInspection . class ) ; m_inspectionClasses . add ( com . siyeh . ig . verbose . UnnecessaryEnumModifierInspection . class ) ;
getFileNameFromJarFile ( jar ) ) ; <CTX> protected void okPressed ( ) { Utility . setPreferenceStoredMap ( JdbcPlugin . JAR_MAP_PREFERENCE_KEY , jarMap ) ; Utility . setPreferenceStoredMap ( JdbcPlugin . DRIVER_MAP_PREFERENCE_KEY , driverMap ) ; for ( int i = 0 ; i < jarsToBeCopied . size ( ) ; i ++ ) { JarFile jar = ( JarFile ) jarsToBeCopied . get ( i ) ; jar . copyJarToODADir ( ) ; Utility . removeMapEntryFromPreferenceStoredMap ( JdbcPlugin . DELETED_JAR_MAP_PREFERENCE_KEY , getFileNameFromJarFile ( jar ) ) ; } for ( int i = 0 ; i < jarsToBeDeleted . size ( ) ; i ++ ) { JarFile jar = ( JarFile ) jarsToBeDeleted . get ( i ) ; jar . deleteJarFromODADir ( ) ; Utility . putPreferenceStoredMapValue ( JdbcPlugin . DELETED_JAR_MAP_PREFERENCE_KEY , getFileNameFromJarFile ( jar ) , jar ) ; } refreshDriverPage ( ) ; super . okPressed ( ) ; }	jar . getFileName ( ) ) ;
return ( SymbolTable ) packageTable . get ( name ) ; <CTX> public static SymbolTable make ( String name ) { return ( SymbolTable ) packageTable . get ( name ) ; }	SymbolTable p = ( SymbolTable ) packageTable . get ( name ) ; if ( p == null ) { p = new SymbolTable ( ) ; p . setName ( name ) ; packageTable . put ( name , p ) ; } return p ;
if ( isCompatibleClass ( paramTypes [ i ] , arguments [ i ] , includeCoerce ) ) continue ; <CTX> public static boolean isValidMethod ( Class [ ] paramTypes , Class [ ] arguments , boolean includeCoerce ) { if ( arguments == null ) { return true ; } int size = arguments . length ; if ( ( size >= paramTypes . length || size == paramTypes . length - 1 ) && paramTypes . length > 0 && paramTypes [ paramTypes . length - 1 ] . isArray ( ) ) { / / first check normal number of parameters for ( int i = 0 ; i < paramTypes . length - 1 ; i ++ ) { if ( isCompatibleClass ( paramTypes [ i ] , arguments [ i ] , includeCoerce ) ) continue ; return false ; } / / check varged Class clazz = paramTypes [ paramTypes . length - 1 ] . getComponentType ( ) ; for ( int i = paramTypes . length ; i < size ; i ++ ) { if ( isCompatibleClass ( clazz , arguments [ i ] , includeCoerce ) ) continue ; return false ; } return true ; } else if ( paramTypes . length == size ) { / / lets check the parameter types match for ( int i = 0 ; i < size ; i ++ ) { if ( isCompatibleClass ( paramTypes [ i ] , arguments [ i ] , includeCoerce ) ) continue ; return false ; } return true ; } else if ( paramTypes . length == 1 && size == 0 ) { return true ; } return false ; }	if ( isAssignableFrom ( paramTypes [ i ] , arguments [ i ] ) ) continue ;
return smallFixNums [ ( int ) ival - minFixNum ] ; <CTX> private BigInteger canonicalize ( ) { if ( words != null && ( ival = BigInteger . wordsNeeded ( words , ival ) ) <= 1 ) { if ( ival == 1 ) ival = words [ 0 ] ; words = null ; } if ( words == null && ival >= minFixNum && ival <= maxFixNum ) return smallFixNums [ ( int ) ival - minFixNum ] ; return this ; }	return smallFixNums [ ival - minFixNum ] ;
initializePath ( p_path ) ; <CTX> public void setPath ( String p_path ) throws MalformedURIException { if ( p_path == null ) { m_path = null ; m_queryString = null ; m_fragment = null ; } else { initializePath ( p_path ) ; } }	initializePath ( p_path , 0 ) ;
return ( ICompilationUnit ) cu . getOriginal ( cu ) ; return cu ; <CTX> public static ICompilationUnit toOriginal ( ICompilationUnit cu ) { if ( cu != null && cu . isWorkingCopy ( ) ) return ( ICompilationUnit ) cu . getOriginal ( cu ) ; return cu ; }	return ( IMember ) cu . getOriginal ( member ) ; return member ;
NodeIdentificationService nis = ( NodeIdentificationService ) serviceBroker . getService ( <CTX> protected Servlet createServlet ( ) { AgentIdentificationService ais = ( AgentIdentificationService ) serviceBroker . getService ( this , AgentIdentificationService . class , null ) ; if ( ais != null ) { this . agentId = ais . getMessageAddress ( ) ; serviceBroker . releaseService ( this , AgentIdentificationService . class , ais ) ; } NodeIdentificationService nis = ( NodeIdentificationService ) serviceBroker . getService ( this , NodeIdentificationService . class , null ) ; if ( nis != null ) { this . nodeId = nis . getMessageAddress ( ) ; serviceBroker . releaseService ( this , NodeIdentificationService . class , nis ) ; } return new MyServlet ( ) ; }	/ * NodeIdentificationService nis = ( NodeIdentificationService ) serviceBroker . getService (
if ( isReferenced ( n ) ) { String combined = combine ( n ) ; <CTX> private void delete ( OsmPrimitive osm ) { if ( osm instanceof Node ) { Node n = ( Node ) osm ; if ( isReferenced ( n ) ) { String combined = combine ( n ) ; if ( combined != null ) { JOptionPane . showMessageDialog ( Main . main , combined ) ; return ; } } / / now , the node isn t referenced anymore , so delete it . ds . nodes . remove ( n ) ; } else if ( osm instanceof LineSegment ) { LinkedList < Track > tracksToDelete = new LinkedList < Track > ( ) ; for ( Track t : ds . tracks ( ) ) { t . remove ( ( LineSegment ) osm ) ; if ( t . segments ( ) . isEmpty ( ) ) tracksToDelete . add ( t ) ; } for ( Track t : tracksToDelete ) ds . removeTrack ( t ) ; ds . destroyPendingLineSegment ( ( LineSegment ) osm ) ; } else if ( osm instanceof Track ) { ds . removeTrack ( ( Track ) osm ) ; for ( LineSegment ls : ( ( Track ) osm ) . segments ( ) ) ds . addPendingLineSegment ( ls ) ; } }	if ( isReferenced ( n , ds ) ) { String combined = combine ( n , ds ) ;
HttpServletRequest request , HttpServletResponse response ) <CTX> public ActionForward execute ( ActionMapping mapping , ActionForm form , HttpServletRequest request , HttpServletResponse response ) throws Exception { / / Call the deprecated method for backwards compatibility return ( perform ( mapping , form , request , response ) ) ; }	ServletRequest request , ServletResponse response )
ScalarParameterHandle reportParam ) throws SemanticException <CTX> private void updateInputParameterAttrsToReportParam ( InputParameterAttributes inputParamAttrs , InputParameterAttributes cachedInputParamAttrs , ScalarParameterHandle reportParam ) throws SemanticException { if ( inputParamAttrs == null ) return ; InputParameterUIHints paramUiHints = inputParamAttrs . getUiHints ( ) ; if ( paramUiHints != null && reportParam . getContainer ( ) instanceof ParameterGroupHandle ) { ParameterGroupHandle paramGroup = ( ParameterGroupHandle ) reportParam . getContainer ( ) ; InputParameterUIHints cachedParamUiHints = cachedInputParamAttrs == null ? null : cachedInputParamAttrs . getUiHints ( ) ; String cachedGroupPromptDisplayName = cachedParamUiHints == null ? null : cachedParamUiHints . getGroupPromptDisplayName ( ) ; String groupPromptDisplayName = paramUiHints . getGroupPromptDisplayName ( ) ; if ( cachedGroupPromptDisplayName == null || ! cachedGroupPromptDisplayName . equals ( groupPromptDisplayName ) ) paramGroup . setDisplayName ( paramUiHints . getGroupPromptDisplayName ( ) ) ; } updateInputElementAttrsToReportParam ( inputParamAttrs . getElementAttributes ( ) , cachedInputParamAttrs == null ? null : cachedInputParamAttrs . getElementAttributes ( ) , reportParam ) ; }	ScalarParameterHandle reportParam , OdaDataSetHandle setHandle ) throws SemanticException
ui . show ( ) ; <CTX> public static void main ( String argv [ ] ) { UI ui = new UI ( ) ; ui . show ( ) ; }	ui . setVisible ( true ) ;
SQLExceptionHandler . throwSQLException ( e ) ; throw e ; <CTX> public BigDecimal getBigDecimal ( int parameterIndex ) throws SQLException { try { return ( ( java . sql . CallableStatement ) m_stmt ) . getBigDecimal ( parameterIndex ) ; } catch ( SQLException e ) { SQLExceptionHandler . throwSQLException ( e ) ; throw e ; / / code should never get here , but just in case } }	throw m_conn . wrap ( e ) ;
while ( cls != Object . class ) { <CTX> private String [ ] findInheritedStringArray ( Class cls , Class annotationClass , String methodName ) { Map < String , String > vResult = new HashMap < String , String > ( ) ; while ( cls != Object . class ) { Annotation annotation = cls . getAnnotation ( annotationClass ) ; if ( annotation != null ) { String [ ] g = ( String [ ] ) invokeMethod ( annotation , methodName ) ; for ( String s : g ) { vResult . put ( s , s ) ; } } cls = cls . getSuperclass ( ) ; } String [ ] result = vResult . keySet ( ) . toArray ( new String [ vResult . size ( ) ] ) ; return result ; }	while ( cls != null && cls != Object . class ) {
} catch ( ReturnJump rExcptn ) { result = rExcptn . getReturnValue ( ) ; <CTX> public void visitIterNode ( IterNode iVisited ) { threadContext . getBlockStack ( ) . push ( iVisited . getVarNode ( ) , new EvaluateMethod ( iVisited . getBodyNode ( ) ) , self ) ; threadContext . getIterStack ( ) . push ( Iter . ITER_PRE ) ; try { while ( true ) { try { result = eval ( iVisited . getIterNode ( ) ) ; return ; } catch ( RetryJump rExcptn ) { } } } catch ( ReturnJump rExcptn ) { result = rExcptn . getReturnValue ( ) ; } catch ( BreakJump bExcptn ) { result = runtime . getNil ( ) ; } finally { threadContext . getIterStack ( ) . pop ( ) ; threadContext . getBlockStack ( ) . pop ( ) ; } }	/ * } catch ( ReturnJump rExcptn ) { result = rExcptn . getReturnValue ( ) ; * /
} else if ( valueChangingListeners . size ( ) > 16 ) { HashSet listenerList = new HashSet ( ) ; listenerList . addAll ( valueChangingListeners ) ; valueChangingListeners = listenerList ; <CTX> public void addValueChangingListener ( IValueChangingListener listener ) { if ( valueChangingListeners == null ) { boolean hadListeners = hasListeners ( ) ; valueChangingListeners = new ArrayList ( ) ; valueChangingListeners . add ( listener ) ; if ( ! hadListeners ) { firstListenerAdded ( ) ; } } else if ( valueChangingListeners . size ( ) > 16 ) { HashSet listenerList = new HashSet ( ) ; listenerList . addAll ( valueChangingListeners ) ; valueChangingListeners = listenerList ; valueChangingListeners . add ( listener ) ; } }	} else {
( XMLEntityResolver ) fConfiguration . getEntityResolver ( ) ; <CTX> public EntityResolver getEntityResolver ( ) { EntityResolver entityResolver = null ; try { XMLEntityResolver xmlEntityResolver = ( XMLEntityResolver ) fConfiguration . getEntityResolver ( ) ; if ( xmlEntityResolver != null && xmlEntityResolver instanceof EntityResolverWrapper ) { entityResolver = ( ( EntityResolverWrapper ) xmlEntityResolver ) . getEntityResolver ( ) ; } } catch ( XMLConfigurationException e ) { / / do nothing } return entityResolver ; } / / getEntityResolver ( ) : EntityResolver	( XMLEntityResolver ) fConfiguration . getProperty ( ENTITY_RESOLVER ) ;
return annotationClass . endsWith ( NONNULL_ANNOTATION_CLASS ) || annotationClass . endsWith ( CHECK_FOR_NULL_ANNOTATION_CLASS ) || annotationClass . endsWith ( POSSIBLY_NULL_ANNOTATION_CLASS ) ; <CTX> private static boolean isNonNullAnnotation ( String annotationClass ) { return annotationClass . endsWith ( NONNULL_ANNOTATION_CLASS ) || annotationClass . endsWith ( CHECK_FOR_NULL_ANNOTATION_CLASS ) || annotationClass . endsWith ( POSSIBLY_NULL_ANNOTATION_CLASS ) ; }	return annotationClass . endsWith ( NONNULL_ANNOTATION_CLASS ) ;
tree . setType ( definitions . UNIT_TYPE ) ; <CTX> public ValDef ValDef ( Symbol sym , Tree rhs ) { ValDef tree = make . ValDef ( sym . pos , sym , TypeTerm ( sym . pos , sym . nextType ( ) ) , rhs ) ; tree . setType ( definitions . UNIT_TYPE ) ; return tree ; }	tree . setType ( Type . NoType ) ;
this . ctx = OmeroContext . getClientContext ( ) ; <CTX> public ServiceFactory ( ) { this . ctx = OmeroContext . getClientContext ( ) ; }	if ( getDefaultContext ( ) != null ) { this . ctx = OmeroContext . getInstance ( getDefaultContext ( ) ) ; }
return false ; <CTX> public boolean isBoolean ( ) { return false ; }	return e . isBoolean ( ) ;
Dependency d = new Dependency ( groupId , artifactId , version , type ) ; <CTX> public File getArtifactFile ( String groupId , String artifactId , String version , String type ) { Dependency d = new Dependency ( groupId , artifactId , version , type ) ; return getArtifactFile ( d ) ; }	Dependency d = new Dependency ( groupId , artifactId , version , type , Collections . EMPTY_LIST ) ;
ParserRule targetRule = getEnclosingRuleAtPosition ( textPane . getCaretPosition ( ) ) ; <CTX> public void actionPerformed ( ActionEvent event ) { ParserRule targetRule = getEnclosingRuleAtPosition ( textPane . getCaretPosition ( ) ) ; int nextRuleIndex = parser . getRules ( ) . indexOf ( targetRule ) + 1 ; ParserRule sourceRule = parser . getRuleAtIndex ( nextRuleIndex ) ; if ( sourceRule != null ) { moveRule ( sourceRule , targetRule , true ) ; selectNextRule = true ; } }	ParserRule targetRule = getEnclosingRuleAtPosition ( editor . getCaretPosition ( ) ) ;
if (_test . getClassLoader ( ) != null ) <CTX> protected Object buildObjectModel ( String builderName ) throws java . lang . Exception { Class builderClass = null ; if (_test . getClassLoader ( ) != null ) builderClass =_test . getClassLoader ( ) . loadClass ( builderName ) ; else builderClass = this . getClass ( ) . getClassLoader ( ) . loadClass ( builderName ) ; ObjectModelBuilder builder = ( ObjectModelBuilder ) builderClass . newInstance ( ) ; return builder . buildInstance ( ) ; }	if (_test . getClassLoader ( ) != null ) {
PropertyList propertyList , FObj fo ) { <CTX> public Property convertProperty ( Property p , PropertyList propertyList , FObj fo ) { if ( p instanceof NumberProperty ) { return p ; } if ( p instanceof EnumProperty ) { return new EnumNumber ( p ) ; } Number val = p . getNumber ( ) ; if ( val != null ) { return new NumberProperty ( val ) ; } return convertPropertyDatatype ( p , propertyList , fo ) ; }	PropertyList propertyList , FObj fo ) throws PropertyException {
arguments . put ( ChainDynamicMethod . ARGUMENT_ACTION , showAction ) ; arguments . put ( ChainDynamicMethod . ARGUMENT_MODEL , model ) ; arguments . put ( ChainDynamicMethod . ARGUMENT_PARAMS , model ) ; return controller . invokeMethod ( ChainDynamicMethod . METHOD_SIGNATURE , new Object [ ] { arguments } ) ; <CTX> public Object call ( Object [ ] args ) { ScaffoldCallback callback = new DefaultScaffoldCallback ( ) ; / / save Map model = this . scaffoldRequestHandler . handleUpdate ( request , response , callback ) ; if ( callback . isInvoked ( ) ) { Closure showAction = ( Closure ) controller . getProperty ( SHOW_ACTION ) ; Map arguments = new HashMap ( ) ; arguments . put ( ChainDynamicMethod . ARGUMENT_ACTION , showAction ) ; arguments . put ( ChainDynamicMethod . ARGUMENT_MODEL , model ) ; arguments . put ( ChainDynamicMethod . ARGUMENT_PARAMS , model ) ; return controller . invokeMethod ( ChainDynamicMethod . METHOD_SIGNATURE , new Object [ ] { arguments } ) ; } else { Map arguments = new HashMap ( ) ; arguments . put ( RenderDynamicMethod . ARGUMENT_VIEW , EDIT_ACTION ) ; arguments . put ( RenderDynamicMethod . ARGUMENT_MODEL , model ) ; return controller . invokeMethod ( RenderDynamicMethod . METHOD_SIGNATURE , new Object [ ] { arguments } ) ; } }	arguments . put ( RedirectDynamicMethod . ARGUMENT_ACTION , showAction ) ; arguments . put ( RedirectDynamicMethod . ARGUMENT_ID , model . get ( RedirectDynamicMethod . ARGUMENT_ID ) ) ; return controller . invokeMethod ( RedirectDynamicMethod . METHOD_SIGNATURE , new Object [ ] { arguments } ) ;
super ( message ) ; <CTX> public XPathSyntaxException ( String xpath , int position , String message ) { super ( message ) ; this . xpath = xpath ; this . position = position ; }	super ( e ) ;
eDynamicSet ( eFeature , newValue ) ; <CTX> public void eSet ( EStructuralFeature eFeature , Object newValue ) { switch ( eDerivedStructuralFeatureID ( eFeature ) ) { case AttributePackage . JAVA_NUMBER_FORMAT_SPECIFIER__ PATTERN : setPattern ( ( String ) newValue ) ; return ; case AttributePackage . JAVA_NUMBER_FORMAT_SPECIFIER__ MULTIPLIER : setMultiplier ( ( ( Double ) newValue ) . doubleValue ( ) ) ; return ; } eDynamicSet ( eFeature , newValue ) ; }	super . eSet ( featureID , newValue ) ;
throw org . postgresql . Driver . notImplemented ( ) ; <CTX> public java . sql . ResultSet getCrossReference ( String primaryCatalog , String primarySchema , String primaryTable , String foreignCatalog , String foreignSchema , String foreignTable ) throws SQLException { throw org . postgresql . Driver . notImplemented ( ) ; }	return getImportedExportedKeys ( primaryCatalog , primarySchema , primaryTable , foreignTable ) ;
exportResource ( resource , 1 ) ; <CTX> protected void exportResource ( IResource resource ) throws InterruptedException { exportResource ( resource , 1 ) ; }	exportResource ( exportResource , 1 ) ;
rebind ( orb . object_to_string ( fwd . forward ) ) ; <CTX> public void invokeInterceptors ( ClientRequestInfoImpl info , short op ) throws RemarshalException { ClientInterceptorIterator intercept_iter = orb . getInterceptorManager ( ) . getClientIterator ( ) ; try { intercept_iter . iterate ( info , op ) ; } catch ( org . omg . PortableInterceptor . ForwardRequest fwd ) { rebind ( orb . object_to_string ( fwd . forward ) ) ; throw new RemarshalException ( ) ; } catch ( org . omg . CORBA . UserException ue ) { if ( logger . isErrorEnabled ( ) ) logger . error ( ue . getMessage ( ) ) ; } }	rebind ( fwd . forward ) ;
viewType = LayerUtils . intFromProperties ( properties , prefix + ETOPOViewTypeProperty , COLOREDSHADING ) ; <CTX> public void setProperties ( String prefix , java . util . Properties properties ) { super . setProperties ( prefix , properties ) ; path = properties . getProperty ( prefix + ETOPOPathProperty ) ; opaqueness = LayerUtils . intFromProperties ( properties , prefix + OpaquenessProperty , DEFAULT_OPAQUENESS ) ; viewType = LayerUtils . intFromProperties ( properties , prefix + ETOPOViewTypeProperty , COLOREDSHADING ) ; slopeAdjust = LayerUtils . intFromProperties ( properties , prefix + ETOPOSlopeAdjustProperty , DEFAULT_SLOPE_ADJUST ) ; minuteSpacing = LayerUtils . intFromProperties ( properties , prefix + ETOPOMinuteSpacingProperty , DEFAULT_MINUTE_SPACING ) ; }	viewType = PropUtils . intFromProperties ( properties , prefix + ETOPOViewTypeProperty , COLOREDSHADING ) ;
currentLoader = new ThumbnailLoader ( component , browser . getImages ( ) ) ; <CTX> void fireThumbnailLoading ( ) { state = HiViewer . LOADING_THUMBNAILS ; currentLoader = new ThumbnailLoader ( component , browser . getImages ( ) ) ; currentLoader . load ( ) ; }	currentLoader = new ThumbnailLoader ( component , images ) ;
Promise lookup ( String s ) ; <CTX> Promise lookup ( String s ) ;	Promise lookup ( C_Var [ ] vars , int index ) ;
suite . addTest ( suiteForJavadocSupport ( level , testClass , constructor , support ) ) ; <CTX> public static Test suiteForComplianceLevel ( String level , Class testClass ) { TestSuite suite = new TestSuite ( level ) ; try { Class [ ] paramTypes = new Class [ ] { String . class } ; Constructor constructor = testClass . getConstructor ( paramTypes ) ; / / Javadoc ENABLED String support = CompilerOptions . DISABLED ; if ( DOC_COMMENT_SUPPORT == null ) { suite . addTest ( suiteForJavadocSupport ( level , testClass , constructor , CompilerOptions . ENABLED ) ) ; } else { support = DOC_COMMENT_SUPPORT ; } / / Javadoc DISABLED suite . addTest ( suiteForJavadocSupport ( level , testClass , constructor , support ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } return suite ; }	suite . addTest ( suiteForJavadocSupport ( level , testClass , support ) ) ;
switch ( event . type ) { case SWT . Selection : if ( menuItem . getSelection ( ) ) { IDE . setDefaultEditor ( file , null ) ; try { IEditorDescriptor desc = IDE . getEditorDescriptor ( file ) ; ( ( WorkbenchPage ) page ) . openEditor ( new FileEditorInput ( file ) , desc . getId ( ) , true , WorkbenchPage . MATCH_BOTH ) ; } catch ( PartInitException e ) { DialogUtil . openError ( page . getWorkbenchWindow ( ) . getShell ( ) , IDEWorkbenchMessages . OpenWithMenu_dialogTitle , e . getMessage ( ) , e ) ; } } break ; } } <CTX> public void handleEvent ( Event event ) { switch ( event . type ) { case SWT . Selection : if ( menuItem . getSelection ( ) ) { IDE . setDefaultEditor ( file , null ) ; try { IEditorDescriptor desc = IDE . getEditorDescriptor ( file ) ; ( ( WorkbenchPage ) page ) . openEditor ( new FileEditorInput ( file ) , desc . getId ( ) , true , WorkbenchPage . MATCH_BOTH ) ; } catch ( PartInitException e ) { DialogUtil . openError ( page . getWorkbenchWindow ( ) . getShell ( ) , IDEWorkbenchMessages . OpenWithMenu_dialogTitle , e . getMessage ( ) , e ) ; } } break ; } }	switch ( event . type ) { case SWT . Selection : openEditor ( entry , false ) ; break ; } }
if ( MarkerUtil . isMarkerType ( marker , IMarker . TASK ) ) return MarkerUtil . getPriority ( marker ) ; <CTX> private int getPriorityOrder ( IMarker marker ) { if ( MarkerUtil . isMarkerType ( marker , IMarker . TASK ) ) return MarkerUtil . getPriority ( marker ) ; return - 1 ; }	if ( MarkerUtil . isMarkerType ( marker , IMarker . TASK ) ) { return MarkerUtil . getPriority ( marker ) ; }
if ( ( length = astLengthStack [ astLengthPtr -- ] ) != 0 ) { <CTX> protected void consumeInterfaceDeclaration ( ) { / / see consumeClassDeclaration in case of changes : duplicated code / / InterfaceDeclaration :: = InterfaceHeader InterfaceBody int length ; if ( ( length = astLengthStack [ astLengthPtr -- ] ) != 0 ) { / / there are length declarations / / dispatch . . . . . according to the type of the declarations dispatchDeclarationInto ( length ) ; } TypeDeclaration typeDecl = ( TypeDeclaration ) astStack [ astPtr ] ; / / mark initializers with local type mark if needed markInitializersWithLocalType ( typeDecl ) ; / / convert constructor that do not have the type s name into methods typeDecl . checkConstructors ( this ) ; / / always add < clinit > ( will be remove at code gen time if empty ) if ( this . scanner . containsAssertKeyword ) { typeDecl . bits |= ASTNode . AddAssertionMASK ; } typeDecl . addClinit ( ) ; typeDecl . bodyEnd = endStatementPosition ; if ( length == 0 && ! containsComment ( typeDecl . bodyStart , typeDecl . bodyEnd ) ) { typeDecl . bits |= ASTNode . UndocumentedEmptyBlockMASK ; } typeDecl . declarationSourceEnd = flushCommentsDefinedPriorTo ( endStatementPosition ) ; }	if ( ( length = this . astLengthStack [ this . astLengthPtr -- ] ) != 0 ) {
updater . doSwitch ( new File ( absolutePath ) . getAbsoluteFile ( ) , url , revision , ! getCommandLine ( ) . hasArgument ( SVNArgument . NON_RECURSIVE ) ) ; <CTX> public void run ( final PrintStream out , final PrintStream err ) throws SVNException { String url = getCommandLine ( ) . getURL ( 0 ) ; String absolutePath = getCommandLine ( ) . getPathAt ( 0 ) ; SVNRevision revision = parseRevision ( getCommandLine ( ) ) ; if ( ! revision . isValid ( ) ) { revision = SVNRevision . HEAD ; } getClientManager ( ) . setEventHandler ( new SVNCommandEventProcessor ( out , err , false , false ) ) ; SVNUpdateClient updater = getClientManager ( ) . getUpdateClient ( ) ; try { if ( getCommandLine ( ) . hasArgument ( SVNArgument . RELOCATE ) ) { updater . doRelocate ( new File ( absolutePath ) . getAbsoluteFile ( ) , url , getCommandLine ( ) . getURL ( 1 ) , ! getCommandLine ( ) . hasArgument ( SVNArgument . NON_RECURSIVE ) ) ; } else { updater . doSwitch ( new File ( absolutePath ) . getAbsoluteFile ( ) , url , revision , ! getCommandLine ( ) . hasArgument ( SVNArgument . NON_RECURSIVE ) ) ; } } catch ( Throwable th ) { SVNDebugLog . log ( th ) ; println ( err , th . getMessage ( ) ) ; println ( err ) ; System . exit ( 1 ) ; } }	updater . doSwitch ( new File ( absolutePath ) . getAbsoluteFile ( ) , switchURL , revision , ! getCommandLine ( ) . hasArgument ( SVNArgument . NON_RECURSIVE ) ) ;
{ this . view = view ; this . agentCtrl = agentCtrl ; pNodes = new TreeMap ( ) ; initListeners ( ) ; treeLoaded = false ; } <CTX> ExplorerPaneManager ( ExplorerPane view , DataManagerCtrl agentCtrl ) { this . view = view ; this . agentCtrl = agentCtrl ; pNodes = new TreeMap ( ) ; initListeners ( ) ; treeLoaded = false ; }	{ this . view = view ; this . agentCtrl = agentCtrl ; pNodes = new TreeMap ( ) ; cDNodes = new TreeMap ( ) ; initListeners ( ) ; treeLoaded = false ; }
return_defaultValue ; <CTX> public long getDefaultValue ( ) { return_defaultValue ; }	return defaultValue ;
String [ ] lines = new DocumentWrapper ( myDocument ) . getLines ( myFirstChangedLine , myLastChangedLine ) ; String [ ] uLines = new DocumentWrapper ( myUpToDateDocument ) <CTX> private List < Range > getNewChangedRanges ( ) { String [ ] lines = new DocumentWrapper ( myDocument ) . getLines ( myFirstChangedLine , myLastChangedLine ) ; String [ ] uLines = new DocumentWrapper ( myUpToDateDocument ) . getLines ( myUpToDateFirstLine , myUpToDateLastLine ) ; return new RangesBuilder ( lines , uLines , myFirstChangedLine , myUpToDateFirstLine ) . getRanges ( ) ; }	List < String > lines = new DocumentWrapper ( myDocument ) . getLines ( myFirstChangedLine , myLastChangedLine ) ; List < String > uLines = new DocumentWrapper ( myUpToDateDocument )
return VM_Magic . addressAsObjectArray ( VM_Address . fromInt ( slots [ slot ] ) ) ; <CTX> public static Object [ ] getSlotContentsAsObjectArray ( int slot ) throws VM_PragmaUninterruptible { / / - # if RVM_FOR_64_ADDR return VM_Magic . addressAsObjectArray ( VM_Address . fromLong ( getSlotContentsAsLong ( slot ) ) ) ; / / - # else return VM_Magic . addressAsObjectArray ( VM_Address . fromInt ( slots [ slot ] ) ) ; / / - # endif }	return VM_Magic . addressAsObjectArray ( VM_Address . fromIntZeroExtend ( slots [ slot ] ) ) ;
boolean reuseEditor = WorkbenchPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( IPreferenceConstants . REUSE_EDITORS_BOOLEAN ) ; <CTX> public boolean shouldBeVisible ( ) { if ( editorPane == null ) { return false ; } boolean reuseEditor = WorkbenchPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( IPreferenceConstants . REUSE_EDITORS_BOOLEAN ) ; return reuseEditor ; }	IPreferenceStore store = WorkbenchPlugin . getDefault ( ) . getPreferenceStore ( ) ; boolean reuseEditor = store . getBoolean ( IPreferenceConstants . REUSE_EDITORS_BOOLEAN ) | store . getBoolean ( IPreferenceConstants . EDITOR_EXPERIMENTAL_TAB_BEHAVIOUR ) ;
if ( type == IResource . ROOT ) <CTX> public static String getShortContainerName ( IMarker marker ) { try { Object pathAttribute = marker . getAttribute ( MarkerViewUtil . PATH_ATTRIBUTE ) ; if ( pathAttribute != null ) return pathAttribute . toString ( ) ; } catch ( CoreException exception ) { / / Log the exception and fall back . log ( exception ) ; } IResource resource = marker . getResource ( ) ; int type = resource . getType ( ) ; / / Cannot be project relative if it is the root or a project if ( type == IResource . PROJECT ) return resource . getName ( ) ; if ( type == IResource . ROOT ) return MarkerMessages . Util_WorkspaceRoot ; String result = marker . getResource ( ) . getProjectRelativePath ( ) . removeLastSegments ( 1 ) . toOSString ( ) ; if ( result . trim ( ) . length ( ) == 0 ) return MarkerMessages . Util_ProjectRoot ; return result ; }	if ( type == IResource . ROOT ) {
OpenFile ( JSDebugger db , Scriptable scope , String fileName ) { <CTX> OpenFile ( JSDebugger db , Scriptable scope , String fileName ) { this . scope = scope ; this . fileName = fileName ; this . db = db ; }	OpenFile ( Main db , Scriptable scope , String fileName ) {
( ( Main ) compiler ) . reJoin ( unit ) ; <CTX> protected void_override ( FjOverrideable instance , CompilerBase compiler ) { FjOverrideClassDeclaration . setOverridingSuperClass ( instance , compiler ) ; JCompilationUnit unit = ( JCompilationUnit ) compilationUnitMap . get ( instance ) ; ( ( Main ) compiler ) . reJoin ( unit ) ; }	( ( Main ) compiler ) . join ( unit ) ;
throw postgresql . Driver . notImplemented ( ) ; <CTX> public boolean last ( ) throws SQLException { throw postgresql . Driver . notImplemented ( ) ; }	if ( rows . size ( ) <= 0 ) return false ; current_row = rows . size ( ) - 1 ; this_row = ( byte [ ] [ ] ) rows . elementAt ( current_row ) ; return true ;
switch ( eDerivedStructuralFeatureID ( eFeature ) ) <CTX> public void eUnset ( EStructuralFeature eFeature ) { switch ( eDerivedStructuralFeatureID ( eFeature ) ) { case TypePackage . BAR_SERIES__ VISIBLE : unsetVisible ( ) ; return ; case TypePackage . BAR_SERIES__ LABEL : setLabel ( ( Label ) null ) ; return ; case TypePackage . BAR_SERIES__ DATA_DEFINITION : getDataDefinition ( ) . clear ( ) ; return ; case TypePackage . BAR_SERIES__ SERIES_IDENTIFIER : setSeriesIdentifier ( SERIES_IDENTIFIER_EDEFAULT ) ; return ; case TypePackage . BAR_SERIES__ DATA_POINT : setDataPoint ( ( DataPoint ) null ) ; return ; case TypePackage . BAR_SERIES__ DATA_SETS : getDataSets ( ) . clear ( ) ; return ; case TypePackage . BAR_SERIES__ LABEL_POSITION : unsetLabelPosition ( ) ; return ; case TypePackage . BAR_SERIES__ STACKED : unsetStacked ( ) ; return ; case TypePackage . BAR_SERIES__ TRIGGERS : getTriggers ( ) . clear ( ) ; return ; case TypePackage . BAR_SERIES__ TRANSLUCENT : unsetTranslucent ( ) ; return ; case TypePackage . BAR_SERIES__ CURVE_FITTING : setCurveFitting ( ( CurveFitting ) null ) ; return ; case TypePackage . BAR_SERIES__ RISER : unsetRiser ( ) ; return ; case TypePackage . BAR_SERIES__ RISER_OUTLINE : setRiserOutline ( ( ColorDefinition ) null ) ; return ; } eDynamicUnset ( eFeature ) ; }	switch ( featureID )
( ( IndexReader ) readers . get ( i ) ) . doUndeleteAll ( ) ; <CTX> protected void doUndeleteAll ( ) throws IOException { for ( int i = 0 ; i < readers . size ( ) ; i ++ ) { ( ( IndexReader ) readers . get ( i ) ) . doUndeleteAll ( ) ; } hasDeletions = false ; }	( ( IndexReader ) readers . get ( i ) ) . undeleteAll ( ) ;
if ( checkRecalculate ( ) ) { myOffset = calcOffset ( ) ; } <CTX> public int getOffset ( ) { if ( checkRecalculate ( ) ) { myOffset = calcOffset ( ) ; } return myOffset ; }	updateData ( ) ;
if ( widgets . length == 0 ) return ; <CTX> public void add ( Object parentElementOrTreePath , Object [ ] childElements ) { Assert . isNotNull ( parentElementOrTreePath ) ; assertElementsNotNull ( childElements ) ; Widget [ ] widgets = internalFindItems ( parentElementOrTreePath ) ; / / If parent hasn t been realized yet , just ignore the add . if ( widgets . length == 0 ) return ; for ( int i = 0 ; i < widgets . length ; i ++ ) { internalAdd ( widgets [ i ] , parentElementOrTreePath , childElements ) ; } }	if ( widgets . length == 0 ) { return ; }
return executeQuery ( jdbcConnection , sql , - 1 , component ) ; <CTX> public static ResultSet executeQuery ( Connection jdbcConnection , String sql , String component ) throws SQLException { return executeQuery ( jdbcConnection , sql , - 1 , component ) ; }	return executeQuery ( jdbcConnection , sql , - 1 , component , - 1 , - 1 ) ;
coll . setCollectionTable ( owner . getTable ( ) ) ; <CTX> public Collection create ( GrailsDomainClassProperty property , PersistentClass owner , Mappings mappings ) throws MappingException { org . hibernate . mapping . Set coll = new org . hibernate . mapping . Set ( owner ) ; coll . setCollectionTable ( owner . getTable ( ) ) ; bindCollection ( property , coll , owner , mappings ) ; return coll ; }	if ( property . isManyToMany ( ) ) { String tableName = calculateTableForMany ( property ) ; Table t = mappings . addTable ( mappings . getSchemaName ( ) , mappings . getCatalogName ( ) , tableName , null , false ) ; coll . setCollectionTable ( t ) ; if ( ! property . isOwningSide ( ) ) { coll . setInverse ( true ) ; } } else { coll . setCollectionTable ( owner . getTable ( ) ) ; }
IFolder folder = null ; <CTX> public static boolean validate ( final IJavaProject jproj , final String folderName ) { IFolder folder = null ; try { folder = jproj . getProject ( ) . getFolder ( folderName ) ; } catch ( IllegalArgumentException e ) { return false ; } return folder != null ; }	boolean succeeded = false ;
if ( result == null ) result = defaultMap . get ( key ) ; <CTX> public FileEditorMapping get ( String key ) { Object result = map . get ( key ) ; if ( result == null ) result = defaultMap . get ( key ) ; return ( FileEditorMapping ) result ; }	if ( result == null ) { result = defaultMap . get ( key ) ; }
if ( variableNames != null ) { <CTX> private void handleVariablesButtonPressed ( ) { PathVariableSelectionDialog dialog = new PathVariableSelectionDialog ( linkTargetField . getShell ( ) , IResource . FILE | IResource . FOLDER ) ; if ( dialog . open ( ) == IDialogConstants . OK_ID ) { String [ ] variableNames = ( String [ ] ) dialog . getResult ( ) ; if ( variableNames != null ) { linkTargetField . setText ( variableNames [ 0 ] ) ; } } }	if ( variableNames != null && variableNames . length == 1 ) {
getPreferenceStore ( ) . setValue ( MylarUiPrefContstants . INTERSECTION_MODE , isIntersectionMode ) ; <CTX> public void setIntersectionMode ( boolean isIntersectionMode ) { getPreferenceStore ( ) . setValue ( MylarUiPrefContstants . INTERSECTION_MODE , isIntersectionMode ) ; }	getPreferenceStore ( ) . setValue ( ContextUiPrefContstants . INTERSECTION_MODE , isIntersectionMode ) ;
super . setCamera ( ( Camera ) newCamera ) ; <CTX> public void setCamera ( RemoteCamera newCamera ) { super . setCamera ( ( Camera ) newCamera ) ; }	super . setCamera ( ( de . jreality . scene . Camera ) newCamera ) ;
trimSize [ LEFT ] = maxDimensions ( controls [ LEFT ] , SWT . DEFAULT , heightHint ) . x ; <CTX> private int [ ] getTrimSizes ( int widthHint , int heightHint ) { int [ ] trimSize = new int [ controls . length ] ; for ( int idx = 0 ; idx < trimSizes . length ; idx ++ ) { if ( controls [ idx ] . isEmpty ( ) ) { trimSize [ idx ] = 0 ; } else { trimSize [ idx ] = trimSizes [ idx ] ; } } if ( trimSize [ TOP ] == SWT . DEFAULT ) { trimSize [ TOP ] = maxDimensions ( controls [ TOP ] , widthHint , SWT . DEFAULT ) . y ; } if ( trimSize [ BOTTOM ] == SWT . DEFAULT ) { trimSize [ BOTTOM ] = maxDimensions ( controls [ BOTTOM ] , widthHint , SWT . DEFAULT ) . y ; } if ( trimSize [ LEFT ] == SWT . DEFAULT ) { trimSize [ LEFT ] = maxDimensions ( controls [ LEFT ] , SWT . DEFAULT , heightHint ) . x ; } if ( trimSize [ RIGHT ] == SWT . DEFAULT ) { trimSize [ RIGHT ] = maxDimensions ( controls [ RIGHT ] , SWT . DEFAULT , heightHint ) . x ; } return trimSize ; }	trimSize [ LEFT ] = maxDimension ( controls [ LEFT ] , heightHint , true ) ;
int srcProduce = FlatNode . getItemsPushed ( src , dst ) * getMult ( src , true ) ; <CTX> static private int leftoveritemsJoiner ( FlatNode src , FlatNode dst ) { int incomingWeight = dst . getIncomingWeight ( src ) ; / / or error if no connection . int dstConsume = getMult ( dst , true ) * incomingWeight ; int srcProduce = FlatNode . getItemsPushed ( src , dst ) * getMult ( src , true ) ; int enqueued = 0 ; if ( dst . isFeedbackJoiner ( ) && src == dst . incoming [ 1 ] ) { / / if feedback edge on feedback loop then account for enqueued values enqueued = ( ( SIRFeedbackLoop ) ( ( SIRJoiner ) dst . contents ) . getParent ( ) ) . getDelayInt ( ) ; } int remaining = ( srcProduce + enqueued ) - dstConsume ; assert remaining >= 0 ; return remaining ; }	int srcProduce = getInitItemsPushed ( src , dst ) ;
( ( PortLabel ) getFigure ( ) ) . layoutChildren ( getModelNode ( ) . getLocation ( ) . getValue ( ) ) ; <CTX> protected void refreshVisuals ( ) { Point loc = new Point ( getModelNode ( ) . getX ( ) , getModelNode ( ) . getY ( ) ) ; Dimension dim = new Dimension ( ) ; ModelFactory mf = new ModelFactory ( ) ; Contained obj = getModelNode ( ) . getContained ( ) ; ( ( PortLabel ) getFigure ( ) ) . setName ( ( ( Node ) getModel ( ) ) . getContained ( ) . getIdentifier ( ) ) ; / / every location needs a special PortLabel - layout ( ( PortLabel ) getFigure ( ) ) . layoutChildren ( getModelNode ( ) . getLocation ( ) . getValue ( ) ) ; dim = getFigure ( ) . getPreferredSize ( - 1 , - 1 ) ; mf . setType ( obj , getFigure ( ) ) ; Rectangle r = new Rectangle ( loc , dim ) ; / / the PortLabelEditParts are children of the ViewEditPart ! ! ! ( ( GraphicalEditPart ) getParent ( ) ) . setLayoutConstraint ( this , getFigure ( ) , r ) ; }	PortLabel portLabel = ( PortLabel ) getFigure ( ) ; if ( portLabel instanceof ReceptacleLabel ) { ( ( ReceptacleLabel ) portLabel ) . setMultiple ( ( ( UsesDef ) obj ) . isMultipleItf ( ) ) ; ( ( ReceptacleLabel ) portLabel ) . layoutChildren ( getModelNode ( ) . getLocation ( ) . getValue ( ) ) ; } else portLabel . layoutChildren ( getModelNode ( ) . getLocation ( ) . getValue ( ) ) ;
if ( ( foundItem instanceof ToolBarContributionItem ) ) { toolBarContributionItem = ( ToolBarContributionItem ) foundItem ; coolItemToolBarMgr = toolBarContributionItem . getToolBarManager ( ) ; <CTX> public IToolBarManager getToolBarManager ( ) { / / by pass the sub coolBar and use the real cool bar . ICoolBarManager coolBarManager = getCastedParent ( ) . getCoolBarManager ( ) ; if ( coolBarManager == null ) { return null ; } / / add the editor group if the app did not add it already , / / otherwise the references to it below will fail if ( coolBarManager . find ( IWorkbenchActionConstants . GROUP_EDITOR ) == null ) { coolBarManager . add ( new GroupMarker ( IWorkbenchActionConstants . GROUP_EDITOR ) ) ; } if ( toolBarContributionItem == null ) { IContributionItem foundItem = coolBarManager . find ( type ) ; if ( ( foundItem instanceof ToolBarContributionItem ) ) { toolBarContributionItem = ( ToolBarContributionItem ) foundItem ; coolItemToolBarMgr = toolBarContributionItem . getToolBarManager ( ) ; if ( coolItemToolBarMgr == null ) { coolItemToolBarMgr = new ToolBarManager ( coolBarManager . getStyle ( ) ) ; toolBarContributionItem = new ToolBarContributionItem ( coolItemToolBarMgr , type ) ; / / Add editor item to group coolBarManager . prependToGroup ( IWorkbenchActionConstants . GROUP_EDITOR , toolBarContributionItem ) ; } } else { coolItemToolBarMgr = new ToolBarManager ( coolBarManager . getStyle ( ) ) ; if ( ( coolBarManager instanceof ContributionManager ) && ( foundItem instanceof PlaceholderContributionItem ) ) { PlaceholderContributionItem placeholder = ( PlaceholderContributionItem ) foundItem ; toolBarContributionItem = placeholder . createToolBarContributionItem ( ( ToolBarManager ) coolItemToolBarMgr ) ; / / Restore from a placeholder ( ( ContributionManager ) coolBarManager ) . replaceItem ( type , toolBarContributionItem ) ; } else { toolBarContributionItem = new ToolBarContributionItem ( coolItemToolBarMgr , type ) ; / / Add editor item to group coolBarManager . prependToGroup ( IWorkbenchActionConstants . GROUP_EDITOR , toolBarContributionItem ) ; } } ( ( ToolBarManager ) coolItemToolBarMgr ) . setOverrides ( new Overrides ( ) ) ; toolBarContributionItem . setVisible ( getActive ( ) ) ; coolItemToolBarMgr . markDirty ( ) ; } return coolItemToolBarMgr ; }	if ( ( foundItem instanceof IToolBarContributionItem ) ) { toolBarContributionItem = ( IToolBarContributionItem ) foundItem ; coolItemToolBarMgr = toolBarContributionItem . getToolBarManager ( ) ;
iVisited . accept (_Payload ) ; <CTX> public void visitAndNode ( AndNode iVisited ) { iVisited . getFirstNode ( ) . accept ( this ) ; iVisited . accept (_Payload ) ; iVisited . getSecondNode ( ) . accept ( this ) ; }	_ Payload . visitAndNode ( iVisited ) ;
long rev = eword . getAttributeLong ( MailService . A_VERSION , - 1 ) ; <CTX> public Element handle ( Element request , Map context ) throws ServiceException { ZimbraContext lc = getZimbraContext ( context ) ; OperationContext octxt = lc . getOperationContext ( ) ; Element eword = request . getElement ( MailService . E_WIKIWORD ) ; String word = eword . getAttribute ( MailService . A_NAME ) ; long rev = eword . getAttributeLong ( MailService . A_VERSION , - 1 ) ; Element response = lc . createElement ( MailService . GET_WIKI_RESPONSE ) ; WikiWord w = Wiki . getInstance ( ) . lookupWiki ( word ) ; if ( w == null ) { / / error handling here return response ; } if ( rev > 0 ) { ToXML . encodeWiki ( response , lc , w . getWikiItem ( octxt , rev ) ) ; } else { ToXML . encodeWiki ( response , lc , w . getWikiItem ( octxt ) ) ; } return response ; }	int rev = ( int ) eword . getAttributeLong ( MailService . A_VERSION , - 1 ) ;
if ( listener != null ) <CTX> public void helpRequested ( HelpEvent e ) { HelpListener listener = null ; if ( handler != null ) { / / if we have a handler , see if it has a help listener listener = handler . getHelpListener ( ) ; if ( listener == null ) / / use our own help listener listener = localHelpListener ; } if ( listener != null ) / / pass on the event listener . helpRequested ( e ) ; }	if ( listener != null ) {
try { Thread . sleep ( autoActivationDelay ) ; } catch ( InterruptedException e ) { } if ( ! isValid ( ) ) { return ; } getControl ( ) . getDisplay ( ) . syncExec ( new Runnable ( ) { public void run ( ) { openProposalPopup ( ) ; } } ) ; <CTX> public void run ( ) { try { Thread . sleep ( autoActivationDelay ) ; } catch ( InterruptedException e ) { } if ( ! isValid ( ) ) { return ; } getControl ( ) . getDisplay ( ) . syncExec ( new Runnable ( ) { public void run ( ) { openProposalPopup ( ) ; } } ) ; }	try { Thread . sleep ( autoActivationDelay ) ; } catch ( InterruptedException e ) {
if ( page != null && page . getPerspective ( ) != null ) perspId = page . getPerspective ( ) . getId ( ) ; else perspId = workbenchWindow . getWorkbench ( ) <CTX> public void run ( ) { if ( workbenchWindow == null ) { / / action has been disposed return ; } try { String perspId ; IWorkbenchPage page = workbenchWindow . getActivePage ( ) ; if ( page != null && page . getPerspective ( ) != null ) perspId = page . getPerspective ( ) . getId ( ) ; else perspId = workbenchWindow . getWorkbench ( ) . getPerspectiveRegistry ( ) . getDefaultPerspective ( ) ; workbenchWindow . getWorkbench ( ) . openWorkbenchWindow ( perspId , pageInput ) ; } catch ( WorkbenchException e ) { ErrorDialog . openError ( workbenchWindow . getShell ( ) , WorkbenchMessages . OpenInNewWindowAction_errorTitle , e . getMessage ( ) , e . getStatus ( ) ) ; } }	if ( page != null && page . getPerspective ( ) != null ) { perspId = page . getPerspective ( ) . getId ( ) ; } else { perspId = workbenchWindow . getWorkbench ( )
switch ( eDerivedStructuralFeatureID ( eFeature ) ) <CTX> public void eSet ( EStructuralFeature eFeature , Object newValue ) { switch ( eDerivedStructuralFeatureID ( eFeature ) ) { case ComponentPackage . AXIS__ TYPE : setType ( ( AxisType ) newValue ) ; return ; case ComponentPackage . AXIS__ TITLE : setTitle ( ( Label ) newValue ) ; return ; case ComponentPackage . AXIS__ SUB_TITLE : setSubTitle ( ( Label ) newValue ) ; return ; case ComponentPackage . AXIS__ TITLE_POSITION : setTitlePosition ( ( Position ) newValue ) ; return ; case ComponentPackage . AXIS__ ASSOCIATED_AXES : getAssociatedAxes ( ) . clear ( ) ; getAssociatedAxes ( ) . addAll ( ( Collection ) newValue ) ; return ; case ComponentPackage . AXIS__ ANCILLARY_AXES : getAncillaryAxes ( ) . clear ( ) ; getAncillaryAxes ( ) . addAll ( ( Collection ) newValue ) ; return ; case ComponentPackage . AXIS__ SERIES_DEFINITIONS : getSeriesDefinitions ( ) . clear ( ) ; getSeriesDefinitions ( ) . addAll ( ( Collection ) newValue ) ; return ; case ComponentPackage . AXIS__ GAP_WIDTH : setGapWidth ( ( ( Double ) newValue ) . doubleValue ( ) ) ; return ; case ComponentPackage . AXIS__ ORIENTATION : setOrientation ( ( Orientation ) newValue ) ; return ; case ComponentPackage . AXIS__ LINE_ATTRIBUTES : setLineAttributes ( ( LineAttributes ) newValue ) ; return ; case ComponentPackage . AXIS__ LABEL : setLabel ( ( Label ) newValue ) ; return ; case ComponentPackage . AXIS__ FORMAT_SPECIFIER : setFormatSpecifier ( ( FormatSpecifier ) newValue ) ; return ; case ComponentPackage . AXIS__ LABEL_POSITION : setLabelPosition ( ( Position ) newValue ) ; return ; case ComponentPackage . AXIS__ STAGGERED : setStaggered ( ( ( Boolean ) newValue ) . booleanValue ( ) ) ; return ; case ComponentPackage . AXIS__ MARKER_LINES : getMarkerLines ( ) . clear ( ) ; getMarkerLines ( ) . addAll ( ( Collection ) newValue ) ; return ; case ComponentPackage . AXIS__ MARKER_RANGES : getMarkerRanges ( ) . clear ( ) ; getMarkerRanges ( ) . addAll ( ( Collection ) newValue ) ; return ; case ComponentPackage . AXIS__ MAJOR_GRID : setMajorGrid ( ( Grid ) newValue ) ; return ; case ComponentPackage . AXIS__ MINOR_GRID : setMinorGrid ( ( Grid ) newValue ) ; return ; case ComponentPackage . AXIS__ SCALE : setScale ( ( Scale ) newValue ) ; return ; case ComponentPackage . AXIS__ ORIGIN : setOrigin ( ( AxisOrigin ) newValue ) ; return ; case ComponentPackage . AXIS__ PRIMARY_AXIS : setPrimaryAxis ( ( ( Boolean ) newValue ) . booleanValue ( ) ) ; return ; case ComponentPackage . AXIS__ CATEGORY_AXIS : setCategoryAxis ( ( ( Boolean ) newValue ) . booleanValue ( ) ) ; return ; case ComponentPackage . AXIS__ PERCENT : setPercent ( ( ( Boolean ) newValue ) . booleanValue ( ) ) ; return ; } eDynamicSet ( eFeature , newValue ) ; }	switch ( featureID )
scriptExpr = ( IScriptExpression ) expr ; <CTX> private void populateExprMap ( ) { assert expressions != null ; if ( exprMap == null ) { exprMap = new HashMap ( ) ; } Iterator iter = expressions . iterator ( ) ; while ( iter . hasNext ( ) ) { IBaseExpression expr = ( IBaseExpression ) iter . next ( ) ; IScriptExpression scriptExpr = null ; if ( expr instanceof IConditionalExpression ) { IConditionalExpression condExpr = ( IConditionalExpression ) expr ; scriptExpr = condExpr . getExpression ( ) ; } else { scriptExpr = ( IScriptExpression ) expr ; } exprMap . put ( scriptExpr . getText ( ) , scriptExpr ) ; } }	exprText = ( ( IScriptExpression ) expr ) . getText ( ) ;
if ( runLength > 0 ) <CTX> public void close ( ) throws IOException { if ( closed ) return ; if ( runLength > 0 ) writeRun ( ) ; currentChar = - 1 ; endBlock ( ) ; endCompression ( ) ; closed = true ; super . close ( ) ; bsStream . close ( ) ; }	if ( runLength > 0 ) {
static boolean instanceOfFinal ( Object object , int targetTibOffset ) throws UninterruptiblePragma { <CTX> static boolean instanceOfFinal ( Object object , int targetTibOffset ) throws UninterruptiblePragma { if ( object == null ) return false ; / / null is not an instance of any type Object lhsTib = VM_Magic . getObjectAtOffset ( VM_Magic . getJTOC ( ) , targetTibOffset ) ; Object rhsTib = VM_ObjectModel . getTIB ( object ) ; return lhsTib == rhsTib ; }	static boolean instanceOfFinal ( Object object , Offset targetTibOffset ) throws UninterruptiblePragma {
nativeWebShell = BrowserControlNativeShim . webShellCreate ( windowPtr , bounds ) ; <CTX> public void createWindow ( int windowPtr , Rectangle bounds ) throws Exception { nativeWebShell = BrowserControlNativeShim . webShellCreate ( windowPtr , bounds ) ; }	nativeWebShell = BrowserControlNativeShim . webShellCreate ( windowPtr , bounds , this ) ;
endVisualLine = getVisibleLineCount ( ) ; <CTX> private void changedUpdate ( DocumentEvent e ) { if ( myScrollPane == null ) return ; stopOptimizedScrolling ( ) ; mySelectionModel . removeBlockSelection ( ) ; mySizeContainer . changedUpdate ( e ) ; validateSize ( ) ; int startVisualLine = offsetToVisualPosition ( e . getOffset ( ) ) . line ; int endVisualLine = offsetToVisualPosition ( e . getOffset ( ) + e . getNewLength ( ) ) . line ; if ( myDocument . getTextLength ( ) > 0 ) { int startDocLine = myDocument . getLineNumber ( e . getOffset ( ) ) ; int endDocLine = myDocument . getLineNumber ( e . getOffset ( ) + e . getNewLength ( ) ) ; if ( e . getOldLength ( ) > e . getNewLength ( ) || startDocLine != endDocLine ) { updateGutterSize ( ) ; endVisualLine = getVisibleLineCount ( ) ; / / Lines inserted or removed . Need to repaint till the end of file . } } updateCaretCursor ( ) ; repaintLines ( startVisualLine , endVisualLine ) ; Point caretLocation = visualPositionToXY ( getCaretModel ( ) . getVisualPosition ( ) ) ; int scrollOffset = caretLocation . y - myCaretUpdateVShift ; getScrollingModel ( ) . scrollVertically ( scrollOffset ) ; }	} if ( e . getOldLength ( ) > e . getNewLength ( ) && startDocLine != endDocLine ) { repaintToScreenBotton ( startLine ) ; painted = true ;
if ( ! readElement ( elements [ i ] ) ) logUnknownElement ( elements [ i ] ) ; <CTX> protected void readElements ( IConfigurationElement [ ] elements ) { for ( int i = 0 ; i < elements . length ; i ++ ) { if ( ! readElement ( elements [ i ] ) ) logUnknownElement ( elements [ i ] ) ; } }	if ( ! readElement ( elements [ i ] ) ) { logUnknownElement ( elements [ i ] ) ; }
getHandlerCollection ( ) . removeHandler ( handler ) ; <CTX> public void removeHandler ( Handler handler ) throws Exception { getHandlerCollection ( ) . removeHandler ( handler ) ; }	if ( getHandler ( ) instanceof HandlerCollection ) ( ( HandlerCollection ) getHandler ( ) ) . removeHandler ( handler ) ;
return RubyFixnum . newFixnum ( getRuntime ( ) , - 1 ) ; <CTX> public IRubyObject infinite_p ( ) { if ( getValue ( ) == Double . POSITIVE_INFINITY ) { return RubyFixnum . newFixnum ( getRuntime ( ) , 1 ) ; } else if ( getValue ( ) == Double . NEGATIVE_INFINITY ) { return RubyFixnum . newFixnum ( getRuntime ( ) , - 1 ) ; } else { return getRuntime ( ) . getNil ( ) ; } }	return getRuntime ( ) . newFixnum ( - 1 ) ;
if ( text == null || text . trim ( ) . length ( ) == 0 ) { return ; } if ( target instanceof TaskAdapter ) target = ( ( TaskAdapter ) target ) . getProxy ( ) ; IntrospectionHelper . getHelper ( target . getClass ( ) ) . addText ( project , target , text ) ; <CTX> public static void addText ( Project project , Object target , String text ) throws BuildException { if ( text == null || text . trim ( ) . length ( ) == 0 ) { return ; } if ( target instanceof TaskAdapter ) target = ( ( TaskAdapter ) target ) . getProxy ( ) ; IntrospectionHelper . getHelper ( target . getClass ( ) ) . addText ( project , target , text ) ; }	addText ( project , target , new String ( buf , start , end ) ) ;
return ( ( this == JType . BOOLEAN ) || ( this == JType . BYTE ) || ( this == JType . CHAR ) || ( this == JType . DOUBLE ) || ( this == JType . FLOAT ) || ( this == JType . INT ) || ( this == JType . LONG ) || ( this == JType . SHORT ) ) ; <CTX> public final boolean isPrimitive ( ) { return ( ( this == JType . BOOLEAN ) || ( this == JType . BYTE ) || ( this == JType . CHAR ) || ( this == JType . DOUBLE ) || ( this == JType . FLOAT ) || ( this == JType . INT ) || ( this == JType . LONG ) || ( this == JType . SHORT ) ) ; }	return (_wrapperName != null ) ;
void setReduceProgress ( float p ) { this . reduceProgress = p ; } <CTX> void setReduceProgress ( float p ) { this . reduceProgress = p ; }	void setReduceProgress ( float p ) { this . reduceProgress = ( float ) Math . min ( 1 . 0 , Math . max ( 0 . 0 , p ) ) ; }
if ( entity . isStuck ( ) ) { <CTX> public boolean accept ( Entity entity ) { if ( entity . isStuck ( ) ) { return true ; } return false ; }	if ( entity instanceof Tank && entity . mpUsed == 0 ) {
void comment ( char ch [ ] , int start , int length ) <CTX> void comment ( char ch [ ] , int start , int length ) throws SAXException { if ( lexicalHandler != base ) lexicalHandler . comment ( ch , start , length ) ; }	void comment ( char [ ] ch , int start , int length )
int hashCode ; <CTX> private static int installHashCode ( Object o ) throws VM_PragmaNoInline { int hashCode ; do { hashCodeGenerator += ( 1 << HASH_CODE_SHIFT ) ; hashCode = hashCodeGenerator & HASH_CODE_MASK ; } while ( hashCode == 0 ) ; while ( true ) { int statusWord = VM_Magic . prepareInt ( o , STATUS_OFFSET ) ; if ( ( statusWord & HASH_CODE_MASK ) != 0 ) / / some other thread installed a hashcode return ( statusWord & HASH_CODE_MASK ) >> HASH_CODE_SHIFT ; if ( VM_Magic . attemptInt ( o , STATUS_OFFSET , statusWord , statusWord | hashCode ) ) return hashCode >> HASH_CODE_SHIFT ; / / we installed the hash code } }	VM_Word hashCode ;
rulesTable . setFocusable ( false ) ; <CTX> public DBASTPanel ( Debugger debugger ) { super ( new BorderLayout ( ) ) ; this . debugger = debugger ; rulesTable = new XJTable ( new RulesTableModel ( ) ) ; rulesTable . setFocusable ( false ) ; rulesTable . setDelegate ( this ) ; rulesTable . setAllowEmptySelection ( false ) ; rulesTable . setRememberSelection ( true ) ; rootsTable = new XJTable ( new RootsTableModel ( ) ) ; rootsTable . setFocusable ( false ) ; rootsTable . setDelegate ( this ) ; rootsTable . setAllowEmptySelection ( false ) ; rootsTable . setRememberSelection ( true ) ; treePanel = new AWTreePanel ( new DefaultTreeModel ( null ) ) ; treePanel . setRootVisible ( true ) ; treePanel . setDelegate ( this ) ; tablesSplitPane = createSplitPane ( ) ; tableTreeSplitPane = createSplitPane ( ) ; JScrollPane rulesScrollPane = new JScrollPane ( rulesTable ) ; rulesScrollPane . setWheelScrollingEnabled ( true ) ; tablesSplitPane . setLeftComponent ( rulesScrollPane ) ; JScrollPane rootsScrollPane = new JScrollPane ( rootsTable ) ; rootsScrollPane . setWheelScrollingEnabled ( true ) ; tablesSplitPane . setRightComponent ( rootsScrollPane ) ; tableTreeSplitPane . setLeftComponent ( tablesSplitPane ) ; tableTreeSplitPane . setRightComponent ( treePanel ) ; add ( tableTreeSplitPane , BorderLayout . CENTER ) ; }	rulesTable . setFocusable ( true ) ;
state . setResult ( state . getThreadContext ( ) . mAssign ( state . getSelf ( ) , iVisited , ( RubyArray ) value , check ) ) ; <CTX> public Instruction visitMultipleAsgnNode ( MultipleAsgnNode iVisited ) { if ( ! ( value instanceof RubyArray ) ) { value = RubyArray . newArray ( state . runtime , value ) ; } state . setResult ( state . getThreadContext ( ) . mAssign ( state . getSelf ( ) , iVisited , ( RubyArray ) value , check ) ) ; return null ; }	result = runtime . getCurrentContext ( ) . mAssign ( self , iVisited , ( RubyArray ) value , check ) ;
RubyClass newClass = new RubyClass ( getRuntime ( ) , getRuntime ( ) . getClasses ( ) . getClassClass ( ) , this , parentModule , name ) ; <CTX> public RubyClass newSubClass ( String name , RubyModule parentModule ) { RubyClass newClass = new RubyClass ( getRuntime ( ) , getRuntime ( ) . getClasses ( ) . getClassClass ( ) , this , parentModule , name ) ; newClass . makeMetaClass ( getMetaClass ( ) ) ; newClass . inheritedBy ( this ) ; getRuntime ( ) . getClasses ( ) . putClass ( name , newClass ) ; return newClass ; }	Ruby runtime = getRuntime ( ) ; RubyClass newClass = new RubyClass ( runtime , runtime . getClasses ( ) . getClassClass ( ) , this , parentModule , name ) ;
if ( ret . hasAttributes ( OTriangle . OUTER ) ) <CTX> public final HalfEdge nextOriginLoop ( ) { HalfEdge ret = this ; if ( ret . hasAttributes ( OTriangle . OUTER ) ) { / / Loop clockwise to another boundary / / and start again from there . do { ret = ret . prevOrigin ( ) ; } while ( ! ret . hasAttributes ( OTriangle . OUTER ) ) ; } else ret = ret . nextOrigin ( ) ; return ret ; }	if ( ret . hasAttributes ( OTriangle . OUTER | OTriangle . BOUNDARY ) )
DocumentDomainObject [ ] documentDomainObjects = documentMapper . getDocumentIndex ( ) . search ( query . getQuery ( ) , securityChecker . getCurrentLoggedInUser ( ) ) ; <CTX> public Document [ ] search ( SearchQuery query ) throws SearchException { try { DocumentDomainObject [ ] documentDomainObjects = documentMapper . getDocumentIndex ( ) . search ( query . getQuery ( ) , securityChecker . getCurrentLoggedInUser ( ) ) ; Document [ ] documents = new Document [ documentDomainObjects . length ] ; for ( int i = 0 ; i < documentDomainObjects . length ; i ++ ) { DocumentDomainObject documentDomainObject = documentDomainObjects [ i ] ; documents [ i ] = wrapDocumentDomainObject ( documentDomainObject ) ; } return documents ; } catch ( IndexException e ) { throw new SearchException ( e ) ; } }	DocumentDomainObject [ ] documentDomainObjects = getDocumentMapper ( ) . getDocumentIndex ( ) . search ( query . getQuery ( ) , contentManagementSystem . getCurrentUser ( ) . getInternal ( ) ) ;
( ( ToggleButton ) button ) . setStateMargin ( null ) ; <CTX> public void apply ( AbstractButton button ) { if ( button instanceof ToggleButton ) { ( ( ToggleButton ) button ) . setStateMargin ( null ) ; } }	( ( ToggleButton ) button ) . setStateAlignment ( new Alignment ( Alignment . LEADING , Alignment . DEFAULT ) ) ;
UpdateFilter filter = new UpdateFilter ( securitySystem , localQuery ) ; <CTX> private < T > T doAction ( T graph , UpdateAction < T > action ) { T retVal ; UpdateFilter filter = new UpdateFilter ( securitySystem , localQuery ) ; Event currentEvent = securitySystem . getCurrentEvent ( ) ; try { beforeUpdate ( graph , filter ) ; retVal = action . run ( graph , filter ) ; afterUpdate ( currentEvent , filter ) ; } finally { / / Return the previous event . securitySystem . setCurrentEvent ( currentEvent ) ; } return retVal ; }	UpdateFilter filter = new UpdateFilter ( ) ;
if ( parent instanceof HTMLTableSectionElement ) <CTX> public void setRowIndex ( int rowIndex ) { Node parent ; parent = getParentNode ( ) ; if ( parent instanceof HTMLTableSectionElement ) parent = parent . getParentNode ( ) ; if ( parent instanceof HTMLTableElement ) ( ( HTMLTableElementImpl ) parent ) . insertRowX ( rowIndex , this ) ; }	if ( parent instanceof HTMLTableSectionElement ) {
if ( value != null ) { <CTX> public void setTerm ( C_Var term ) { var = term ; if ( value != null ) { value . setTerm ( term ) ; return ; } if ( fields != null ) for ( Iterator < Map . Entry < String , Promise >> it = fields . entrySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry < String , Promise > entry = it . next ( ) ; String key = entry . getKey ( ) ; Promise p = entry . getValue ( ) ; FieldInstance f = ( ( C_Field ) p . term ( ) ) . fieldInstance ( ) ; p . setTerm ( new C_Field_c ( f , term ) ) ; } }	/ * if ( value != null ) {
if ( this . sign > 0 ) return this . subtract ( val . negate ( ) ) ; } else { if ( this . sign < 0 ) return val . subtract ( this . negate ( ) ) ; <CTX> public BigInteger add ( BigInteger val ) throws ArithmeticException { if ( val . sign == 0 || val . magnitude . length == 0 ) return this ; if ( this . sign == 0 || this . magnitude . length == 0 ) return val ; if ( val . sign < 0 ) { if ( this . sign > 0 ) return this . subtract ( val . negate ( ) ) ; } else { if ( this . sign < 0 ) return val . subtract ( this . negate ( ) ) ; } / / both BigIntegers are either + ve or - ve ; set the sign later int [ ] mag , op ; if ( this . magnitude . length < val . magnitude . length ) { mag = new int [ val . magnitude . length + 1 ] ; System . arraycopy ( val . magnitude , 0 , mag , 1 , val . magnitude . length ) ; op = this . magnitude ; } else { mag = new int [ this . magnitude . length + 1 ] ; System . arraycopy ( this . magnitude , 0 , mag , 1 , this . magnitude . length ) ; op = val . magnitude ; } return new BigInteger ( this . sign , add ( mag , op ) ) ; }	m += ( ( ( long ) a [ tI ] ) & IMASK ) + ( ( ( long ) b [ vI -- ] ) & IMASK ) ; a [ tI -- ] = ( int ) m ; m >> >> >= 32 ;
if ( m_trigger != other . m_trigger ) <CTX> public boolean equals ( Object other_o ) { Constraint other = ( Constraint ) other_o ; if ( ( m_name == null && other . getName ( ) != null ) || ( m_name != null && other . getName ( ) == null ) ) { return false ; } if ( m_name != null && other . getName ( ) != null && ! m_name . equals ( other . getName ( ) ) ) { return false ; } if ( m_type != other . getType ( ) ) { return false ; } if ( ( m_column == null && other . getColumn ( ) != null ) || ( m_column != null && other . getColumn ( ) == null ) ) { return false ; } if ( m_column != null && other . getColumn ( ) != null && ! m_column . equals ( other . getColumn ( ) ) ) { return false ; } if ( ( m_ftable == null && other . getForeignTable ( ) != null ) || ( m_ftable != null && other . getForeignTable ( ) == null ) ) { return false ; } if ( m_ftable != null && other . getForeignTable ( ) != null && ! m_ftable . equals ( other . getForeignTable ( ) ) ) { return false ; } if ( ( m_fcolumn == null && other . getForeignColumn ( ) != null ) || ( m_fcolumn != null && other . getForeignColumn ( ) == null ) ) { return false ; } if ( m_fcolumn != null && other . getForeignColumn ( ) != null && ! m_fcolumn . equals ( other . getForeignColumn ( ) ) ) { return false ; } if ( m_trigger != other . m_trigger ) return false ; return true ; }	if ( ( m_fdeltype == null && other . getForeignDelType ( ) != null ) || ( m_fdeltype != null && other . getForeignDelType ( ) == null ) ) {
combo . deselectAll ( ) ; combo . clearSelection ( ) ; <CTX> protected void listDeselectAll ( ) { combo . deselectAll ( ) ; combo . clearSelection ( ) ; }	if ( combo == null ) { ccombo . deselectAll ( ) ; ccombo . clearSelection ( ) ; } else { combo . deselectAll ( ) ; combo . clearSelection ( ) ; }
synchronized protected int inAvailable ( ) throws IOException { <CTX> synchronized protected int inAvailable ( ) throws IOException { if ( in_eof ) return 0 ; checkConnected ( ) ; if ( in_buf == null ) return 0 ; int total = in_buf . length - in_bufpos ; ListIterator it = data . listIterator ( 0 ) ; while ( it . hasNext ( ) ) total += ( ( byte [ ] ) it . next ( ) ) . length ; return total ; }	synchronized private int inAvailable ( ) throws IOException {
clone . setFrozen ( false ) ; <CTX> public IRubyObject rbClone ( ) { IRubyObject clone = getMetaClass ( ) . getRealClass ( ) . allocate ( ) ; clone . setMetaClass ( getMetaClass ( ) . getSingletonClassClone ( ) ) ; clone . setFrozen ( false ) ; clone . initCopy ( this ) ; if ( isFrozen ( ) ) { clone . setFrozen ( true ) ; } return clone ; }	clone . setTaint ( this . isTaint ( ) ) ;
dispose ( ) ; <CTX> public void run ( ) { if ( ! force ) { if ( ! showConfirmation ( ) ) { saveAll ( ) ; return ; } } saveAll ( ) ; if ( ! canExit ( ) ) return ; dispose ( ) ; System . exit ( 0 ) ; }	disposeSelf ( ) ;
bufferMap . put ( offset , buffer ) ; <CTX> private RAStreamBuffer getBuffer ( long offset ) throws IOException { / / If we already have a buffer allocated for that offset , just / / return it . RAStreamBuffer buffer = ( RAStreamBuffer ) bufferMap . get ( offset ) ; if ( buffer != null ) return buffer ; / / If not , and MAX_NUMBER_OF_STREAM_BUFFER has not been reached , / / allocate a new buffer for it . if ( totalBuffer < IOUtil . MAX_NUMBER_OF_STREAM_BUFFER ) { buffer = new RAStreamBuffer ( this . randomFile ) ; buffer . resetBuffer ( offset ) ; totalBuffer ++ ; bufferList . add ( buffer ) ; bufferMap . put ( offset , buffer ) ; return buffer ; } / / If no buffer has been found , and MAX_NUMBER_OF_STREAM_BUFFER has / / been reached , reuse the buffer from the beginning of the list and / / put the buffer to the end of the list . buffer = ( RAStreamBuffer ) bufferList . get ( 0 ) ; buffer . flushBuffer ( ) ; bufferMap . remove ( buffer . getOffset ( ) ) ; buffer . resetBuffer ( offset ) ; bufferMap . put ( offset , buffer ) ; bufferList . remove ( 0 ) ; bufferList . add ( buffer ) ; return buffer ; }	bufferMap . put ( offsetKey , buffer ) ;
if ( isConstant ( lhs ) ) { <CTX> private static boolean isConstantMask ( PsiExpression expression ) { if ( expression == null ) { return false ; } if ( ! ( expression instanceof PsiBinaryExpression ) ) { return false ; } final PsiBinaryExpression binaryExpression = ( PsiBinaryExpression ) expression ; final PsiJavaToken sign = binaryExpression . getOperationSign ( ) ; if ( sign == null ) { return false ; } final IElementType tokenType = sign . getTokenType ( ) ; if ( ! tokenType . equals ( JavaTokenType . OR ) && ! tokenType . equals ( JavaTokenType . AND ) ) { return false ; } final PsiExpression rhs = binaryExpression . getROperand ( ) ; if ( isConstant ( rhs ) ) { return true ; } final PsiExpression lhs = binaryExpression . getLOperand ( ) ; if ( isConstant ( lhs ) ) { return true ; } return false ; }	if ( PsiUtil . isConstantExpression ( lhs ) ) {
catch ( NoSuchAlgorithmException ignore ) <CTX> public static final SSLContext getInstance ( String protocol ) throws NoSuchAlgorithmException { Provider [ ] provs = Security . getProviders ( ) ; for ( int i = 0 ; i < provs . length ; i ++ ) { try { return getInstance ( protocol , provs [ i ] ) ; } catch ( NoSuchAlgorithmException ignore ) { } } throw new NoSuchAlgorithmException ( protocol ) ; }	catch ( NoSuchAlgorithmException x )
int featureID , Class baseClass , NotificationChain msgs ) <CTX> public NotificationChain eInverseRemove ( InternalEObject otherEnd , int featureID , Class baseClass , NotificationChain msgs ) { if ( featureID >= 0 ) { switch ( eDerivedStructuralFeatureID ( featureID , baseClass ) ) { case LayoutPackage . LABEL_BLOCK__ CHILDREN : return ( ( InternalEList ) getChildren ( ) ) . basicRemove ( otherEnd , msgs ) ; case LayoutPackage . LABEL_BLOCK__ BOUNDS : return basicSetBounds ( null , msgs ) ; case LayoutPackage . LABEL_BLOCK__ INSETS : return basicSetInsets ( null , msgs ) ; case LayoutPackage . LABEL_BLOCK__ MIN_SIZE : return basicSetMinSize ( null , msgs ) ; case LayoutPackage . LABEL_BLOCK__ OUTLINE : return basicSetOutline ( null , msgs ) ; case LayoutPackage . LABEL_BLOCK__ BACKGROUND : return basicSetBackground ( null , msgs ) ; case LayoutPackage . LABEL_BLOCK__ TRIGGERS : return ( ( InternalEList ) getTriggers ( ) ) . basicRemove ( otherEnd , msgs ) ; case LayoutPackage . LABEL_BLOCK__ LABEL : return basicSetLabel ( null , msgs ) ; default : return eDynamicInverseRemove ( otherEnd , featureID , baseClass , msgs ) ; } } return eBasicSetContainer ( null , featureID , msgs ) ; }	int featureID , NotificationChain msgs )
results = null ; <CTX> public void close ( ) { try { results . close ( ) ; results = null ; } catch ( SQLException sqle ) { } }	if ( results != null ) results . close ( ) ; } catch ( SQLException sqle ) { } try { if ( statemt != null ) statemt . close ( ) ; statemt = null ;
kindActive . put ( ( IMarkupKind ) labels [ i ] . getData ( ) , new Boolean ( checkboxes [ i ] . getSelection ( ) ) ) ; <CTX> public void createPartControl ( Composite parent ) { reset ( ) ; scrollpane = new ScrolledComposite ( parent , SWT . H_SCROLL | SWT . V_SCROLL | SWT . BORDER ) ; canvas = new Composite ( scrollpane , SWT . NONE ) ; scrollpane . setContent ( canvas ) ; canvas . setLayout ( layout ) ; / / commented out because double clicking was giving NPEs from openAspectSource / / labelListener = new MouseListener ( ) { / / public void mouseUp ( MouseEvent e ) { / / } / / public void mouseDown ( MouseEvent e ) { / / } / / public void mouseDoubleClick ( MouseEvent e ) { / / for ( int i = 0 ; i < labels . length ; i ++ ) { / / if ( ( Label ) e . getSource ( ) == labels [ i ] ) { / / VisualiserPlugin . visualiser . openAspectSource ( i ) ; / / return ; / / } / / } / / } / / } ; / * * Listener for colour buttons - if clicked produces a ColorDialog * then redraws the square image with the chosen colour . * / selectionListener = new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { if ( e . getSource ( ) instanceof Button ) { Button button = ( Button ) e . getSource ( ) ; int location = 0 ; for ( int j = 0 ; j < buttons . length ; j ++ ) { if ( ( buttons [ j ] ) . equals ( button ) ) { location = j ; } } RGB rgb = colorDialogs [ location ] . open ( ) ; if ( rgb == null ) { return ; } colors [ location ] = new Color ( buttons [ location ] . getDisplay ( ) , rgb ) ; Image image = buttons [ location ] . getImage ( ) ; drawImage ( image , colors [ location ] ) ; buttons [ location ] . setImage ( image ) ; if ( ! ( VisualiserPlugin . visualiser == null ) ) { vmp . setColorFor ( ( IMarkupKind ) labels [ location ] . getData ( ) , colors [ location ] ) ; VisualiserPlugin . visualiser . draw ( ) ; } } } } ; / / Listener for checkboxes checkboxListener = new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { if ( ! ( VisualiserPlugin . visualiser == null ) ) { for ( int i = 0 ; i < colors . length ; i ++ ) { kindActive . put ( ( IMarkupKind ) labels [ i ] . getData ( ) , new Boolean ( checkboxes [ i ] . getSelection ( ) ) ) ; } VisualiserPlugin . visualiser . updateDisplay ( false ) ; } } } ; makePullDownActions ( ) ; contributeToActionBars ( ) ; VisualiserPlugin . getDefault ( ) . setMenu ( this ) ; }	kindActive . put ( labels [ i ] . getData ( ) , new Boolean ( checkboxes [ i ] . getSelection ( ) ) ) ;
stopCellEditing ( ) ; <CTX> protected Component createTextField ( ) { / / Populate the text field with the object s string value JTextField txtField = new JTextField ( mEditor . getAsText ( ) ) ; txtField . setBorder ( BorderFactory . createEmptyBorder ( 0 , 0 , 0 , 0 ) ) ; txtField . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { stopCellEditing ( ) ; } } ) ; txtField . addFocusListener ( new FocusAdapter ( ) { public void focusLost ( FocusEvent evt ) { stopCellEditing ( ) ; } } ) ; return txtField ; }	txtField . setBackground ( getParent ( ) . getBackground ( ) ) ; txtField . transferFocusUpCycle ( ) ;
node = addElement ( parent , name , dim . getClass ( ) . getName ( ) , false , false ) ; <CTX> public Element writeDimension ( Element parent , Object o , String name ) throws Exception { Element node ; Dimension dim ; / / for debugging only if ( DEBUG ) trace ( new Throwable ( ) , name ) ; dim = ( Dimension ) o ; node = addElement ( parent , name , dim . getClass ( ) . getName ( ) , false , false ) ; writeDoubleToXML ( node , dim . getWidth ( ) , VAL_WIDTH ) ; writeDoubleToXML ( node , dim . getHeight ( ) , VAL_HEIGHT ) ; return node ; }	node = addElement ( parent , name , dim . getClass ( ) . getName ( ) , false ) ;
boolean reuseEditor = WorkbenchPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( IPreferenceConstants . REUSE_EDITORS_BOOLEAN ) ; <CTX> public boolean shouldBeVisible ( ) { if ( editorPane == null ) { return false ; } boolean reuseEditor = WorkbenchPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( IPreferenceConstants . REUSE_EDITORS_BOOLEAN ) ; return reuseEditor ; }	IPreferenceStore store = WorkbenchPlugin . getDefault ( ) . getPreferenceStore ( ) ; boolean reuseEditor = store . getBoolean ( IPreferenceConstants . REUSE_EDITORS_BOOLEAN ) | store . getBoolean ( IPreferenceConstants . EDITOR_EXPERIMENTAL_TAB_BEHAVIOUR ) ;
myModel . setJavaTemplate (_entry . getValue ( ) ) ; <CTX> public void textValueChanged ( FormEntry_entry ) { myModel . setJavaTemplate (_entry . getValue ( ) ) ; getEditor ( ) . editorDirtyStateChanged ( ) ; }	myModel . setDestination (_entry . getValue ( ) ) ;
&& target . getProperty ( targetDesign , prop . getName ( ) ) == null ) <CTX> static void resolveStyle ( ReportDesign targetDesign , DesignElement target , DesignElement source ) { assert targetDesign != null && target != null && source != null ; assert target instanceof StyledElement ; assert source instanceof StyledElement ; Module sourceModule = source . getRoot ( ) ; assert sourceModule != null ; DesignElement style = ( ( StyledElement ) source ) . getStyle ( sourceModule ) ; / / handle only when the style is not local one but a library resource if ( style != null && style . getRoot ( ) != sourceModule ) { Module root = style . getRoot ( ) ; assert root != null ; / / copy all the local values in the style IElementDefn defn = style . getDefn ( ) ; Iterator iter = defn . getPropertyIterator ( ) ; while ( iter . hasNext ( ) ) { PropertyDefn prop = ( PropertyDefn ) iter . next ( ) ; Object value = style . getLocalProperty ( root , prop . getName ( ) ) ; if ( value != null ) { / / only handle values that not set in the target element if ( target . getPropertyDefn ( prop . getName ( ) ) != null && target . getProperty ( targetDesign , prop . getName ( ) ) == null ) target . setProperty ( prop . getName ( ) , value ) ; } } / / clear the style reference of the target element ( ( StyledElement ) target ) . setStyle ( null ) ; } }	&& target . getLocalProperty ( targetDesign , ( ElementPropertyDefn ) prop ) == null )
setStyleAttribute ( name , ( String ) newValue ) ; <CTX> public void put ( final String name , final Scriptable start , final Object newValue ) { / / Some calls to put will happen during the initialization of the / / superclass . / / At this point , we don t have enough information to do our own / / initialization / / so we have to just pass this call through to the superclass . if ( jsElement_== null || ! STYLE_ALLOWED_PROPERTIES . contains ( name ) ) { super . put ( name , start , newValue ) ; return ; } setStyleAttribute ( name , ( String ) newValue ) ; }	setStyleAttribute ( name , styleValue ) ;
MylarUiPlugin . getDefault ( ) . getPreferenceStore ( ) . setDefault ( ID , true ) ; update ( MylarUiPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( ID ) ) ; <CTX> public LinkActiveSearchWithEditorAction ( ) { super ( LABEL , IAction . AS_CHECK_BOX ) ; INSTANCE = this ; setId ( ID ) ; setImageDescriptor ( MylarImages . LINK_WITH_EDITOR ) ; setText ( LABEL ) ; setToolTipText ( LABEL ) ; MylarUiPlugin . getDefault ( ) . getPreferenceStore ( ) . setDefault ( ID , true ) ; update ( MylarUiPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( ID ) ) ; }	ContextUiPlugin . getDefault ( ) . getPreferenceStore ( ) . setDefault ( ID , true ) ; update ( ContextUiPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( ID ) ) ;
return background != null ? background : parent . getBackground ( ) ; <CTX> public Color getBackground ( ) { return background != null ? background : parent . getBackground ( ) ; }	return ( ( background != null ) ? background : parent . getBackground ( ) ) ;
if ( VM . VerifyAssertions ) VM . assert ( VM . NOT_REACHED ) ; <CTX> public static Object invokeMethodReturningObject ( INSTRUCTION [ ] code , int [ ] gprs , double [ ] fprs , int [ ] spills ) { if ( VM . VerifyAssertions ) VM . assert ( VM . NOT_REACHED ) ; / / call site should have been hijacked by magic in compiler return null ; }	if ( VM . VerifyAssertions ) VM ._assert ( VM . NOT_REACHED ) ;
if ( onlineProject ( currentUser , currentProject ) . equals ( currentProject ) ) { <CTX> public boolean accessCreate ( CmsUser currentUser , CmsProject currentProject , CmsResource resource ) throws CmsException { / / check , if this is the onlineproject if ( onlineProject ( currentUser , currentProject ) . equals ( currentProject ) ) { / / the online - project is not writeable ! return ( false ) ; } / / check the access to the project if ( ! accessProject ( currentUser , currentProject , currentProject . getId ( ) ) ) { / / no access to the project ! return ( false ) ; } / / check if the resource belongs to the current project if ( resource . getProjectId ( ) != currentProject . getId ( ) ) { return false ; } / / is the resource locked ? if ( resource . isLocked ( ) && ( resource . isLockedBy ( ) != currentUser . getId ( ) || ( resource . getLockedInProject ( ) != currentProject . getId ( ) && currentProject . getFlags ( ) != C_PROJECT_STATE_INVISIBLE ) ) ) { / / resource locked by anopther user , no creation allowed return ( false ) ; } / / check the rights for the current resource if ( ! ( accessOther ( resource , C_ACCESS_PUBLIC_WRITE ) || accessOwner ( currentUser , currentProject , resource , C_ACCESS_OWNER_WRITE ) || accessGroup ( currentUser , currentProject , resource , C_ACCESS_GROUP_WRITE ) ) ) { / / no write access to this resource ! return false ; } / / read the parent folder if ( resource . getParent ( ) != null ) { / / readFolder without checking access resource = m_dbAccess . readFolder ( resource . getProjectId ( ) , resource . getRootName ( ) + resource . getParent ( ) ) ; } else { / / no parent folder ! return true ; } / / check the rights and if the resource is not locked do { if ( accessOther ( resource , C_ACCESS_PUBLIC_READ ) || accessOwner ( currentUser , currentProject , resource , C_ACCESS_OWNER_READ ) || accessGroup ( currentUser , currentProject , resource , C_ACCESS_GROUP_READ ) ) { / / is the resource locked ? if ( resource . isLocked ( ) && resource . isLockedBy ( ) != currentUser . getId ( ) ) { / / resource locked by anopther user , no creation allowed return ( false ) ; } / / read next resource if ( resource . getParent ( ) != null ) { / / readFolder without checking access resource = m_dbAccess . readFolder ( resource . getProjectId ( ) , resource . getRootName ( ) + resource . getParent ( ) ) ; } } else { / / last check was negative return ( false ) ; } } while ( resource . getParent ( ) != null ) ; / / all checks are done positive return ( true ) ; }	if ( currentProject . isOnlineProject ( ) ) {
Boolean test = ( ( ScriptableObject ) y ) . equivalentValues ( x ) ; if ( test != null ) { return test . booleanValue ( ) ; <CTX> public static boolean eq ( Object x , Object y ) { if ( x == null || x == Undefined . instance ) { if ( y == null || y == Undefined . instance ) { return true ; } if ( y instanceof ScriptableObject ) { Boolean test = ( ( ScriptableObject ) y ) . equivalentValues ( x ) ; if ( test != null ) { return test . booleanValue ( ) ; } } return false ; } else if ( x instanceof Number ) { return eqNumber ( ( ( Number ) x ) . doubleValue ( ) , y ) ; } else if ( x instanceof String ) { return eqString ( ( String ) x , y ) ; } else if ( x instanceof Boolean ) { boolean b = ( ( Boolean ) x ) . booleanValue ( ) ; if ( y instanceof Boolean ) { return b == ( ( Boolean ) y ) . booleanValue ( ) ; } if ( y instanceof ScriptableObject ) { Boolean test = ( ( ScriptableObject ) y ) . equivalentValues ( x ) ; if ( test != null ) { return test . booleanValue ( ) ; } } return eqNumber ( b ? 1 . 0 : 0 . 0 , y ) ; } else if ( x instanceof Scriptable ) { if ( y instanceof Scriptable ) { / / Generic test also works for y == Undefined . instance if ( x == y ) { return true ; } if ( x instanceof ScriptableObject ) { Boolean test = ( ( ScriptableObject ) x ) . equivalentValues ( y ) ; if ( test != null ) { return test . booleanValue ( ) ; } } if ( y instanceof ScriptableObject ) { Boolean test = ( ( ScriptableObject ) y ) . equivalentValues ( x ) ; if ( test != null ) { return test . booleanValue ( ) ; } } if ( x instanceof Wrapper && y instanceof Wrapper ) { return ( ( Wrapper ) x ) . unwrap ( ) == ( ( Wrapper ) y ) . unwrap ( ) ; } return false ; } else if ( y instanceof Boolean ) { if ( x instanceof ScriptableObject ) { Boolean test = ( ( ScriptableObject ) x ) . equivalentValues ( y ) ; if ( test != null ) { return test . booleanValue ( ) ; } } double d = ( ( Boolean ) y ) . booleanValue ( ) ? 1 . 0 : 0 . 0 ; return eqNumber ( d , x ) ; } else if ( y instanceof Number ) { return eqNumber ( ( ( Number ) y ) . doubleValue ( ) , x ) ; } else if ( y instanceof String ) { return eqString ( ( String ) y , x ) ; } return false ; } else { warnAboutNonJSObject ( x ) ; return x == y ; } }	Object test = ( ( ScriptableObject ) y ) . equivalentValues ( x ) ; if ( test != Scriptable . NOT_FOUND ) { return ( ( Boolean ) test ) . booleanValue ( ) ;
return SoapUtils . getFilters ( SearchRequestFactory . getVisibleRequests ( user ) ) ; <CTX> public RemoteFilter [ ] getSavedFilters ( String token ) throws Exception { User user = tokenManager . retrieveUser ( token ) ; return SoapUtils . getFilters ( SearchRequestFactory . getVisibleRequests ( user ) ) ; }	return SoapUtils . getFilters ( searchRequestManager . getVisibleRequests ( user ) ) ;
OdaDataSet . PRIVATE_DRIVER_PROPERTIES_PROP , name ) ; <CTX> public String getPrivateDriverProperty ( String name ) { return ExtendedPropertyHelper . getExtendedProperty ( this , OdaDataSet . PRIVATE_DRIVER_PROPERTIES_PROP , name ) ; }	IOdaDataSetModel . PRIVATE_DRIVER_PROPERTIES_PROP , name ) ;
super ( conn , fields , tuples , status , updateCount , insertOID ) ; <CTX> public ResultSet ( Connection conn , Field [ ] fields , Vector tuples , String status , int updateCount , int insertOID ) { super ( conn , fields , tuples , status , updateCount , insertOID ) ; }	super ( conn , fields , tuples , status , updateCount , insertOID , binaryCursor ) ;
values ) ; <CTX> private JBlock doUnroll ( UnrollInfo info , JForStatement self ) { / / make a list of statements List statementList = new LinkedList ( ) ; statementList . add ( self . getInit ( ) ) ; / / get the initial value of the counter int counter = info . initVal ; / / simulate execution of the loop . . . while ( done ( counter , info ) ) { / / create new for statement , just to replace the variable JForStatement newSelf = ( JForStatement ) ObjectDeepCloner . deepCopy ( self ) ; / / get unroll info for < newSelf > UnrollInfo newInfo = getUnrollInfo ( newSelf . getInit ( ) , newSelf . getCondition ( ) , newSelf . getIncrement ( ) , newSelf . getBody ( ) , values ) ; / / replace induction variable with its value current value Hashtable newConstants = new Hashtable ( ) ; newConstants . put ( newInfo . var , new JIntLiteral ( counter ) ) ; / / do the replacement newSelf . getBody ( ) . accept ( new Propagator ( newConstants ) ) ; / / add to statement list statementList . add ( newSelf . getBody ( ) ) ; / / increment counter counter = incrementCounter ( counter , info ) ; } statementList . add ( new JExpressionStatement ( self . getTokenReference ( ) , new JAssignmentExpression ( self . getTokenReference ( ) , new JLocalVariableExpression ( self . getTokenReference ( ) , info . var ) , new JIntLiteral ( counter ) ) , null ) ) ; / / mark that we ve unrolled this . hasUnrolled = true ; / / return new block instead of the for loop constants . remove ( info . var ) ; return new JBlock ( null , ( JStatement [ ] ) statementList . toArray ( new JStatement [ 0 ] ) , null ) ; }	values , constants ) ;
listDoubleClicked ( event . getViewer ( ) . getSelection ( ) ) ; <CTX> public void doubleClick ( DoubleClickEvent event ) { listDoubleClicked ( event . getViewer ( ) . getSelection ( ) ) ; }	treeDoubleClicked ( event ) ;
return ( ( BundleSourceViewerConfiguration ) getSourceViewerConfiguration ( ) ) . affectsTextPresentation ( event ) || super . affectsTextPresentation ( event ) ; <CTX> protected boolean affectsTextPresentation ( PropertyChangeEvent event ) { return ( ( BundleSourceViewerConfiguration ) getSourceViewerConfiguration ( ) ) . affectsTextPresentation ( event ) || super . affectsTextPresentation ( event ) ; }	return fConfiguration . affectsTextPresentation ( event ) || super . affectsTextPresentation ( event ) ;
unconditionalDerefParamDatabase = analysisContext . getUnconditionalDerefParamDatabase ( ) ; nonNullParamDatabase = analysisContext . getNonNullParamDatabase ( ) ; checkForNullParamDatabase = analysisContext . getCheckForNullParamDatabase ( ) ; nullReturnValueAnnotationDatabase = analysisContext . getNullReturnValueAnnotationDatabase ( ) ; checkUnconditionalDeref = isDatabaseNonEmpty ( unconditionalDerefParamDatabase ) ; checkParamAnnotations = isDatabaseNonEmpty ( nonNullParamDatabase ) && isDatabaseNonEmpty ( checkForNullParamDatabase ) ; checkReturnValueAnnotations = isDatabaseNonEmpty ( nullReturnValueAnnotationDatabase ) ; checkCallSites = checkUnconditionalDeref || checkParamAnnotations ; checkCallSitesOrReturnInstructions = checkCallSites || checkReturnValueAnnotations ; <CTX> private void checkDatabases ( ) { AnalysisContext analysisContext = AnalysisContext . currentAnalysisContext ( ) ; unconditionalDerefParamDatabase = analysisContext . getUnconditionalDerefParamDatabase ( ) ; nonNullParamDatabase = analysisContext . getNonNullParamDatabase ( ) ; checkForNullParamDatabase = analysisContext . getCheckForNullParamDatabase ( ) ; nullReturnValueAnnotationDatabase = analysisContext . getNullReturnValueAnnotationDatabase ( ) ; checkUnconditionalDeref = isDatabaseNonEmpty ( unconditionalDerefParamDatabase ) ; checkParamAnnotations = isDatabaseNonEmpty ( nonNullParamDatabase ) && isDatabaseNonEmpty ( checkForNullParamDatabase ) ; checkReturnValueAnnotations = isDatabaseNonEmpty ( nullReturnValueAnnotationDatabase ) ; checkCallSites = checkUnconditionalDeref || checkParamAnnotations ; checkCallSitesOrReturnInstructions = checkCallSites || checkReturnValueAnnotations ; }	unconditionalDerefParamDatabase = analysisContext . getUnconditionalDerefParamDatabase ( ) ;
return getTextValue ( res ) ; <CTX> private String getString ( String key , String catalogueId , String defaultValue ) { final Node res = getNode ( catalogueId , key ) ; if ( res == null ) { return defaultValue ; } return getTextValue ( res ) ; }	return res . toString ( ) ;
return getBoolRepresentation ( getTaskMessageMembers ( ) ) ; <CTX> public String getTaskMessageMembersString ( ) { return getBoolRepresentation ( getTaskMessageMembers ( ) ) ; }	return String . valueOf ( getTaskMessageMembers ( ) ) ;
return pos + 1 ; <CTX> public long getPos ( ) { return pos + 1 ; }	return pos ;
if ( root == null ) <CTX> public RelationshipInfo [ ] computeRelation ( ) { ArrayList list = new ArrayList ( ) ; if ( root == null ) return new RelationshipInfo [ 0 ] ; RelationshipInfo r = new RelationshipInfo ( ) ; r . part = root . computeRelation ( list ) ; list . add ( 0 , r ) ; RelationshipInfo [ ] result = new RelationshipInfo [ list . size ( ) ] ; list . toArray ( result ) ; return result ; }	if ( treeRoot == null )
char token , String name , Annotation annotation <CTX> static public AtomicSymbol createSymbol ( char token , String name , Annotation annotation ) { AtomicSymbol as = new FundamentalAtomicSymbol ( name , token , annotation ) ; return as ; }	String name , Annotation annotation
int lo = Math . min ( index 0 , index 1 ) ; int hi = Math . max ( index 0 , index 1 ) ; <CTX> public void setSelectionInterval ( int index 0 , int index 1 ) { if ( index 0 == - 1 || index 1 == - 1 ) return ; BitSet oldSel = ( BitSet ) sel . clone ( ) ; sel . clear ( ) ; if ( selectionMode == SINGLE_SELECTION ) index 0 = index 1 ; int lo = Math . min ( index 0 , index 1 ) ; int hi = Math . max ( index 0 , index 1 ) ; sel . set ( lo , hi + 1 ) ; / / update the anchorSelectionIndex and leadSelectionIndex variables setAnchorSelectionIndex ( index 0 ) ; leadSelectionIndex = index 1 ; fireDifference ( sel , oldSel ) ; }	int lo = Math . min ( anchor , lead ) ; int hi = Math . max ( anchor , lead ) ;
return RubyFixnum . newFixnum ( runtime , microseconds ( ) ) ; <CTX> public RubyInteger usec ( ) { return RubyFixnum . newFixnum ( runtime , microseconds ( ) ) ; }	return getRuntime ( ) . newFixnum ( microseconds ( ) ) ;
getService ( ) . addResources ( companyId , groupId , userId , name , primKey , portletActions , addCommunityPermissions , addGuestPermissions ) ; <CTX> public void addResources ( java . lang . String companyId , java . lang . String groupId , java . lang . String userId , java . lang . String name , java . lang . String primKey , boolean portletActions , boolean addCommunityPermissions , boolean addGuestPermissions ) throws com . liferay . portal . PortalException , com . liferay . portal . SystemException { getService ( ) . addResources ( companyId , groupId , userId , name , primKey , portletActions , addCommunityPermissions , addGuestPermissions ) ; }	getService ( ) . addResources ( companyId , groupId , name , portletActions ) ;
modifiersSourceStart >= 0 ? modifiersSourceStart : scanner . startPosition ) ; <CTX> protected void consumeDefaultModifiers ( ) { checkComment ( ) ; / / might update modifiers with AccDeprecated pushOnIntStack ( modifiers ) ; / / modifiers pushOnIntStack ( modifiersSourceStart >= 0 ? modifiersSourceStart : scanner . startPosition ) ; resetModifiers ( ) ; }	this . modifiersSourceStart >= 0 ? this . modifiersSourceStart : this . scanner . startPosition ) ;
int b = instream . read ( ) ; if ( b == 1 ) { arg = new PingRsp ( ) ; arg . readFrom ( instream ) ; } <CTX> public void readFrom ( DataInputStream instream ) throws IOException , IllegalAccessException , InstantiationException { type = instream . readByte ( ) ; int b = instream . read ( ) ; if ( b == 1 ) { arg = new PingRsp ( ) ; arg . readFrom ( instream ) ; } }	arg = ( PingRsp ) Util . readStreamable ( PingRsp . class , instream ) ;
SearchConstraints getLeafChild ( ) { <CTX> SearchConstraints getLeafChild ( ) { for ( IConstraints n : mSubNodes ) if ( n . getNodeType ( ) == NodeType . LEAF ) return ( SearchConstraints ) n ; SearchConstraints c = new SearchConstraints ( ) ; mSubNodes . add ( c ) ; return c ; }	LeafNode getLeafChild ( ) {
UnderlyingData data = prepareCreate ( TYPE_DOCUMENT , id , folder , volumeId , filename , creator , type , contents , ( Document ) parent , null ) ; <CTX> static Document create ( int id , Folder folder , short volumeId , String filename , String creator , String type , byte [ ] contents , MailItem parent ) throws ServiceException { assert ( id != Mailbox . ID_AUTO_INCREMENT ) ; assert ( parent instanceof Document ) ; UnderlyingData data = prepareCreate ( TYPE_DOCUMENT , id , folder , volumeId , filename , creator , type , contents , ( Document ) parent , null ) ; if ( parent != null ) data . parentId = parent . getId ( ) ; Mailbox mbox = folder . getMailbox ( ) ; data . contentChanged ( mbox ) ; DbMailItem . create ( mbox , data ) ; Document doc = new Document ( mbox , data ) ; doc . finishCreation ( parent ) ; / / doc . reindex ( ) ; return doc ; }	UnderlyingData data = prepareCreate ( TYPE_DOCUMENT , id , folder , volumeId , filename , creator , type , pd , ( Document ) parent , null ) ;
if ( senior == null ) { final int curricularYear = registration . getCurricularYear ( ) ; if ( curricularYear == degree . getDegreeType ( ) . getYears ( ) ) { senior = new Senior ( registration ) ; } else { return null ; } } return senior ; <CTX> public Senior run ( Person person ) { Senior senior = null ; final Registration registration = person . getStudentByType ( DegreeType . DEGREE ) ; if ( registration == null ) { return null ; } final StudentCurricularPlan studentCurricularPlan = registration . getActiveStudentCurricularPlan ( ) ; if ( studentCurricularPlan == null ) { return null ; } final DegreeCurricularPlan degreeCurricularPlan = studentCurricularPlan . getDegreeCurricularPlan ( ) ; final Degree degree = degreeCurricularPlan . getDegree ( ) ; senior = registration . getSenior ( ) ; if ( senior == null ) { final int curricularYear = registration . getCurricularYear ( ) ; if ( curricularYear == degree . getDegreeType ( ) . getYears ( ) ) { senior = new Senior ( registration ) ; } else { return null ; } } return senior ; }	if ( senior == null ) { final int curricularYear = registration . getCurricularYear ( ) ; if ( curricularYear == degree . getDegreeType ( ) . getYears ( ) ) { senior = new Senior ( registration ) ; } else { return null ; }
return new FileChooserHomeFolderIcon ( ) ; <CTX> public static Icon getFileChooserHomeFolderIcon ( ) { return new FileChooserHomeFolderIcon ( ) ; }	if ( fileChooserHomeFolderIcon == null ) fileChooserHomeFolderIcon = new FileChooserHomeFolderIcon ( ) ; return fileChooserHomeFolderIcon ;
return equivalentValues ( obj ) . booleanValue ( ) ; <CTX> public boolean equals ( Object obj ) { if ( ! ( obj instanceof Namespace ) ) return false ; return equivalentValues ( obj ) . booleanValue ( ) ; }	return equals ( ( Namespace ) obj ) ;
temp [ temp . length - 1 ] = value 0 ; <CTX> public void addSelectionPath ( TreePath value 0 ) { if ( ! isPathSelected ( value 0 ) ) { if ( isSelectionEmpty ( ) ) setSelectionPath ( value 0 ) ; else { TreePath [ ] temp = new TreePath [ selection . length + 1 ] ; System . arraycopy ( selection , 0 , temp , 0 , selection . length ) ; temp [ temp . length - 1 ] = value 0 ; selection = new TreePath [ temp . length ] ; System . arraycopy ( temp , 0 , selection , 0 , temp . length ) ; } leadPath = value 0 ; fireValueChanged ( new TreeSelectionEvent ( this , value 0 , true , leadPath , value 0 ) ) ; } }	temp [ temp . length - 1 ] = path ;
return ( BioModule ) ( myProducer ) ; <CTX> public BioModule getInputModule ( ) { return ( BioModule ) ( myProducer ) ; }	return myProducer ;
if ( c == null || c . isDisposed ( ) ) return ; <CTX> public void run ( ) { ignoreEntries -- ; EditorSite site = ( EditorSite ) ( part . getEditorSite ( ) ) ; Control c = site . getPane ( ) . getControl ( ) ; if ( c == null || c . isDisposed ( ) ) return ; NavigationHistoryEntry e = getEntry ( activeEntry ) ; if ( e != null && part . getEditorInput ( ) != e . editorInfo . editorInput ) updateEntry ( e ) ; addEntry ( part , true ) ; }	if ( c == null || c . isDisposed ( ) ) { return ; }
java . lang . String companyId , java . lang . String name , java . lang . String typeId , java . lang . String scope , java . lang . String primKey ) <CTX> public com . liferay . portal . model . Resource getResource ( java . lang . String companyId , java . lang . String name , java . lang . String typeId , java . lang . String scope , java . lang . String primKey ) throws com . liferay . portal . PortalException , com . liferay . portal . SystemException ;	java . lang . String resourceId )
if ( feature . equals ( Constants . LOAD_DTD_GRAMMAR_FEATURE ) ) { <CTX> protected void checkFeature ( String featureId ) throws XMLConfigurationException { / / / / Xerces Features / / if ( featureId . startsWith ( Constants . XERCES_FEATURE_PREFIX ) ) { String feature = featureId . substring ( Constants . XERCES_FEATURE_PREFIX . length ( ) ) ; / / / / http : / / apache . org / xml / features / validation / dynamic / / Allows the parser to validate a document only when it / / contains a grammar . Validation is turned on / off based / / on each document instance , automatically . / / if ( feature . equals ( Constants . DYNAMIC_VALIDATION_FEATURE ) ) { return ; } / / / / http : / / apache . org / xml / features / validation / default - attribute - values / / if ( feature . equals ( Constants . DEFAULT_ATTRIBUTE_VALUES_FEATURE ) ) { / / REVISIT short type = XMLConfigurationException . NOT_SUPPORTED ; throw new XMLConfigurationException ( type , featureId ) ; } / / / / http : / / apache . org / xml / features / validation / default - attribute - values / / if ( feature . equals ( Constants . VALIDATE_CONTENT_MODELS_FEATURE ) ) { / / REVISIT short type = XMLConfigurationException . NOT_SUPPORTED ; throw new XMLConfigurationException ( type , featureId ) ; } / / / / http : / / apache . org / xml / features / validation / nonvalidating / load - dtd - grammar / / if ( feature . equals ( Constants . LOAD_DTD_GRAMMAR_FEATURE ) ) { return ; } / / / / http : / / apache . org / xml / features / validation / nonvalidating / load - external - dtd / / if ( feature . equals ( Constants . LOAD_EXTERNAL_DTD_FEATURE ) ) { return ; } / / / / http : / / apache . org / xml / features / validation / default - attribute - values / / if ( feature . equals ( Constants . VALIDATE_DATATYPES_FEATURE ) ) { short type = XMLConfigurationException . NOT_SUPPORTED ; throw new XMLConfigurationException ( type , featureId ) ; } } / / / / Not recognized / / super . checkFeature ( featureId ) ; } / / checkFeature ( String )	if ( featureId . regionMatches ( prefixLength , Constants . LOAD_DTD_GRAMMAR_FEATURE , 0 , Constants . LOAD_DTD_GRAMMAR_FEATURE . length ( ) ) ) {
if ( peers == 0 || conns == 0 || ( peers - conns ) > MAX_DISCONN_PEER_ALERT_THRESHOLD || conns > MAX_CONN_ALERT_THRESHOLD || peers > MAX_PEER_ALERT_THRESHOLD || ( n . bwlimitDelayAlertRelevant && bwlimitDelayTime > Node . MAX_BWLIMIT_DELAY_TIME_ALERT_THRESHOLD ) || ( n . nodeAveragePingAlertRelevant && nodeAveragePingTime > Node . MAX_NODE_AVERAGE_PING_TIME_ALERT_THRESHOLD ) ) <CTX> public short getPriorityClass ( ) { if ( peers == 0 || conns == 0 || ( peers - conns ) > MAX_DISCONN_PEER_ALERT_THRESHOLD || conns > MAX_CONN_ALERT_THRESHOLD || peers > MAX_PEER_ALERT_THRESHOLD || ( n . bwlimitDelayAlertRelevant && bwlimitDelayTime > Node . MAX_BWLIMIT_DELAY_TIME_ALERT_THRESHOLD ) || ( n . nodeAveragePingAlertRelevant && nodeAveragePingTime > Node . MAX_NODE_AVERAGE_PING_TIME_ALERT_THRESHOLD ) ) return UserAlert . CRITICAL_ERROR ; return UserAlert . ERROR ; }	if ( ( peers == 0 ) || ( conns == 0 ) || ( ( peers - conns ) > MAX_DISCONN_PEER_ALERT_THRESHOLD ) || ( conns > MAX_CONN_ALERT_THRESHOLD ) || ( peers > MAX_PEER_ALERT_THRESHOLD ) || ( n . bwlimitDelayAlertRelevant && ( bwlimitDelayTime > Node . MAX_BWLIMIT_DELAY_TIME_ALERT_THRESHOLD ) ) || ( n . nodeAveragePingAlertRelevant && ( nodeAveragePingTime > Node . MAX_NODE_AVERAGE_PING_TIME_ALERT_THRESHOLD ) ) )
mySshSettingsPanel = new SshConnectionSettingsPanel ( ) ; <CTX> public ExtConnectionDualPanel ( ) { myExtSettingsPanel = new ExtConnectionSettingsPanel ( ) ; mySshSettingsPanel = new SshConnectionSettingsPanel ( ) ; myDualPanel . add ( myExtSettingsPanel . getPanel ( ) , EXT ) ; myDualPanel . add ( mySshSettingsPanel . getPanel ( ) , SSH ) ; myPanel . add ( myUseInternalImplementationCheckBox , BorderLayout . NORTH ) ; myPanel . add ( myDualPanel , BorderLayout . CENTER ) ; myUseInternalImplementationCheckBox . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { updatePage ( ) ; } } ) ; }	mySshSettingsPanel = new SshConnectionSettingsPanel ( rootProvider ) ;
closure . call ( new Integer ( i ) ) ; <CTX> public static void times ( Number self , Closure closure ) { for ( int i = 0 , size = self . intValue ( ) ; i < size ; i ++ ) { closure . call ( new Integer ( i ) ) ; if ( closure . getDirective ( ) == Closure . DONE ) { break ; } } }	closure . callSpecial ( new Integer ( i ) ) ;
check ( DECLARATIONS , FieldDeclarationPattern . class , field ) ; <CTX> public void acceptField ( IASTField field ) { check ( DECLARATIONS , FieldDeclarationPattern . class , field ) ; }	check ( DECLARATIONS , field ) ;
if ( result != null && result . unscheduleFiringTrigger ( ) ) return INSTRUCTION_SET_TRIGGER_COMPLETE ; <CTX> public int executionComplete ( JobExecutionContext jobCtx , JobExecutionException result ) { if ( result != null && result . refireImmediately ( ) ) return INSTRUCTION_RE_EXECUTE_JOB ; if ( result != null && result . unscheduleFiringTrigger ( ) ) return INSTRUCTION_SET_TRIGGER_COMPLETE ; if ( result != null && result . unscheduleAllTriggers ( ) ) return INSTRUCTION_SET_ALL_JOB_TRIGGERS_COMPLETE ; if ( ! mayFireAgain ( ) ) return INSTRUCTION_DELETE_TRIGGER ; return INSTRUCTION_NOOP ; }	if ( result != null && result . unscheduleFiringTrigger ( ) ) { return INSTRUCTION_SET_TRIGGER_COMPLETE ; }
abstract public void removeNodeChangeListener ( NodeChangeListener listener ) ; <CTX> abstract public void removeNodeChangeListener ( NodeChangeListener listener ) ;	public abstract void removeNodeChangeListener ( NodeChangeListener listener ) ;
String [ ] terrains = { hexModel . getTerrain ( ) } ; new ShowAllRecruits ( masterFrame , terrains , lastPoint , hexModel . getLabel ( ) , scrollPane ) ; <CTX> public void actionPerformed ( ActionEvent e ) { GUIMasterHex hex = getHexContainingPoint ( lastPoint ) ; if ( hex != null ) { MasterHex hexModel = hex . getMasterHexModel ( ) ; String [ ] terrains = { hexModel . getTerrain ( ) } ; new ShowAllRecruits ( masterFrame , terrains , lastPoint , hexModel . getLabel ( ) , scrollPane ) ; } }	new ShowRecruits ( masterFrame , hexModel . getTerrain ( ) , lastPoint , hexModel . getLabel ( ) , scrollPane ) ;
int displacement = ( iCode [ pc ] << 8 ) + ( iCode [ pc + 1 ] & 0 xFF ) ; <CTX> private static int getTarget ( byte [ ] iCode , int pc ) { int displacement = ( iCode [ pc ] << 8 ) + ( iCode [ pc + 1 ] & 0 xFF ) ; return pc - 1 + displacement ; }	int displacement = getShort ( iCode , pc ) ;
if ( rootTagName != null ) { final DomFileDescription < T > description = ContainerUtil . find ( myDomManager . getFileDescriptions ( rootTagName ) , myCondition ) ; <CTX> private DomFileDescription < T > findFileDescription ( final String rootTagName , Module module ) { myCondition . module = module ; if ( rootTagName != null ) { final DomFileDescription < T > description = ContainerUtil . find ( myDomManager . getFileDescriptions ( rootTagName ) , myCondition ) ; if ( description != null ) { return description ; } } return ContainerUtil . find ( myDomManager . getAcceptingOtherRootTagNameDescriptions ( rootTagName ) , myCondition ) ; }	final CharSequence text = getFileStartText ( ) ; if ( text != null && containsRootTags ( text . toString ( ) ) || rootTagName . getValue ( ) != null ) { final DomFileDescription < T > description = ContainerUtil . find ( myDomManager . getFileDescriptions ( rootTagName . getValue ( ) ) , myCondition ) ;
makeForcedStrikes ( ) ; <CTX> public void actOnHex ( BattleHex hex ) { switch ( getPhase ( ) ) { case MOVE : if ( chitSelected ) { getCritter ( 0 ) . moveToHex ( hex ) ; chitSelected = false ; } highlightMovableChits ( ) ; break ; case FIGHT : case STRIKEBACK : if ( getCarryDamage ( ) > 0 ) { applyCarries ( hex . getCritter ( ) ) ; } else if ( chitSelected ) { getCritter ( 0 ) . strike ( hex . getCritter ( ) ) ; chitSelected = false ; } if ( getCarryDamage ( ) == 0 ) { if ( game != null ) { Player player = game . getActivePlayer ( ) ; if ( player . getOption ( Game . autoForcedStrike ) ) { makeForcedStrikes ( ) ; } } highlightChitsWithTargets ( ) ; } break ; default : break ; } }	makeForcedStrikes ( false ) ;
return accessModes . contains ( access ) ; <CTX> public boolean cachedIsAuthorized ( String objectName , String access , int policyUpdateCounter ) { if ( ! ALLOW_ACCESS_CACHING ) { return false ; } if ( policyUpdateCounter !=_policyUpdateCounter ) { flushAuthorizationCache ( ) ;_policyUpdateCounter = policyUpdateCounter ; return false ; } Set accessModes = ( Set )_descriptors . get ( objectName ) ; if ( accessModes == null ) { return false ; } else { return accessModes . contains ( access ) ; } }	for ( int i = 0 ; i < access . length ; i ++ ) { if ( ! accessModes . contains ( access [ i ] ) ) { return false ; } } return true ;
highPriorityButtonActionPerformed ( evt ) ; <CTX> public void actionPerformed ( java . awt . event . ActionEvent evt ) { highPriorityButtonActionPerformed ( evt ) ; }	fullDescriptionsItemActionPerformed ( evt ) ;
super . handleDrop ( ) ; <CTX> protected void handleDrop ( ) { final Object template = TemplateTransfer . getInstance ( ) . getTemplate ( ) ; Assert . isNotNull ( template ) ; Assert . isTrue ( handleValidateDrag ( template ) ) ; updateTargetRequest ( ) ; updateTargetEditPart ( ) ; AbstractToolHandleExtends preHandle = null ; String transName = null ; if ( template instanceof String ) { transName = TRANS_LABEL_CREATE_ELEMENT ; preHandle = BasePaletteFactory . getAbstractToolHandleExtendsFromPaletteName ( template ) ; } else if ( handleValidateInsert ( template ) ) { transName = InsertInLayoutAction . DISPLAY_TEXT ; Object objectType = getFactory ( template ) . getObjectType ( ) ; if ( objectType instanceof DataSetHandle ) { preHandle = new DataSetToolExtends ( ) ; } else if ( objectType instanceof DataSetItemModel ) { preHandle = new DataSetColumnToolExtends ( ) ; } else if ( objectType instanceof ScalarParameterHandle ) { preHandle = new ParameterToolExtends ( ) ; } } else if ( handleValidateLibrary ( template ) ) { preHandle = new LibraryElementsToolHandleExtends ( ( DesignElementHandle ) getSingleTransferData ( template ) ) ; } if ( preHandle != null ) { SessionHandleAdapter . getInstance ( ) . getReportDesignHandle ( ) . getCommandStack ( ) . startTrans ( transName ) ; preHandle . setRequest ( this . getCreateRequest ( ) ) ; preHandle . setTargetEditPart ( getTargetEditPart ( ) ) ; Command command = this . getCommand ( ) ; if ( command != null && command . canExecute ( ) ) { if ( ! ( preHandle . preHandleMouseUp ( ) ) ) { SessionHandleAdapter . getInstance ( ) . getReportDesignHandle ( ) . getCommandStack ( ) . rollback ( ) ; return ; } } super . handleDrop ( ) ; SessionHandleAdapter . getInstance ( ) . getReportDesignHandle ( ) . getCommandStack ( ) . commit ( ) ; selectAddedObject ( ) ; } }	boolean isTheme = false ; if ( preHandle instanceof LibraryElementsToolHandleExtends && template instanceof Object [ ] ) { Object [ ] objs = ( Object [ ] ) template ; if ( objs . length == 1 && objs [ 0 ] instanceof ThemeHandle ) { isTheme = true ; } } if ( isTheme == false ) { super . handleDrop ( ) ; }
if ( inputState . guessing == 0 ) { astFactory . addASTChild ( currentAST , returnAST ) ; } if ( inputState . guessing == 0 ) { type_AST = ( AST ) currentAST . root ; } <CTX> public final void type ( ) throws RecognitionException , TokenStreamException { returnAST = null ; ASTPair currentAST = new ASTPair ( ) ; AST type_AST = null ; switch ( LA ( 1 ) ) { case IDENT : { classOrInterfaceType ( false ) ; if ( inputState . guessing == 0 ) { astFactory . addASTChild ( currentAST , returnAST ) ; } if ( inputState . guessing == 0 ) { type_AST = ( AST ) currentAST . root ; } break ; } case LITERAL_void : case LITERAL_boolean : case LITERAL_byte : case LITERAL_char : case LITERAL_short : case LITERAL_int : case LITERAL_float : case LITERAL_long : case LITERAL_double : case LITERAL_any : { builtInType ( ) ; if ( inputState . guessing == 0 ) { astFactory . addASTChild ( currentAST , returnAST ) ; } if ( inputState . guessing == 0 ) { type_AST = ( AST ) currentAST . root ; } break ; } default : { throw new NoViableAltException ( LT ( 1 ) , getFilename ( ) ) ; } } returnAST = type_AST ; }	astFactory . addASTChild ( currentAST , returnAST ) ; type_AST = ( AST ) currentAST . root ;
Block getRootBlock ( ) ; <CTX> Block getRootBlock ( ) ;	@ NotNull Block getRootBlock ( ) ;
Type receiverType = typeFrame . getInstance ( invokeInstruction , cpg ) ; <CTX> public static Set < XMethod > resolveMethodCallTargets ( InvokeInstruction invokeInstruction , TypeFrame typeFrame , ConstantPoolGen cpg ) throws DataflowAnalysisException , ClassNotFoundException { if ( invokeInstruction . getOpcode ( ) == Constants . INVOKESTATIC ) { HashSet < XMethod > result = new HashSet < XMethod > ( ) ; result . add ( new StaticMethod ( invokeInstruction . getClassName ( cpg ) , invokeInstruction . getName ( cpg ) , invokeInstruction . getSignature ( cpg ) , Constants . ACC_STATIC | Constants . ACC_PUBLIC ) ) ; return result ; } if ( ! typeFrame . isValid ( ) ) { return new HashSet < XMethod > ( ) ; } Type receiverType = typeFrame . getInstance ( invokeInstruction , cpg ) ; if ( ! ( receiverType instanceof ReferenceType ) ) { return new HashSet < XMethod > ( ) ; } / / XXX : check whether or not type is exact return resolveMethodCallTargets ( ( ReferenceType ) receiverType , invokeInstruction , cpg , false ) ; }	int instanceSlot = typeFrame . getInstanceSlot ( invokeInstruction , cpg ) ; Type receiverType = typeFrame . getValue ( instanceSlot ) ;
new VOTableWriter ( DataFormat . BINARY , true ) . writeStarTable ( table , ostrm , null ) ; <CTX> public void run ( ) { try { new VOTableWriter ( DataFormat . BINARY , true ) . writeStarTable ( table , ostrm , null ) ; } catch ( IOException e ) { / / may well catch an exception if the reader stops reading } finally { try { ostrm . close ( ) ; } catch ( IOException e ) { / / no action } } }	outputter . transferTable ( table , ostrm ) ;
getFontMetrics ( Font font ) ; <CTX> getFontMetrics ( Font font ) ;	getFontMetrics ( ) { return ( getFontMetrics ( getFont ( ) ) ) ; }
else if ( location > jc . getSize ( ) . width ) <CTX> public void setDividerLocation ( JSplitPane jc , int location ) { location = validLocation ( location ) ; Container p = jc . getParent ( ) ; Dimension rightPrefSize = jc . getRightComponent ( ) . getPreferredSize ( ) ; if ( getOrientation ( ) == 0 && location > jc . getSize ( ) . height ) { location = jc . getSize ( ) . height ; while ( p != null ) { p . setSize ( p . getWidth ( ) , p . getHeight ( ) + rightPrefSize . height ) ; p = p . getParent ( ) ; } } else if ( location > jc . getSize ( ) . width ) { location = jc . getSize ( ) . width ; while ( p != null ) { p . setSize ( p . getWidth ( ) + rightPrefSize . width , p . getHeight ( ) ) ; p = p . getParent ( ) ; } } setLastDragLocation ( getDividerLocation ( splitPane ) ) ; splitPane . setLastDividerLocation ( getDividerLocation ( splitPane ) ) ; int [ ] tmpSizes = layoutManager . getSizes ( ) ; tmpSizes [ 0 ] = location - layoutManager . getInitialLocation ( splitPane . getInsets ( ) ) ; tmpSizes [ 1 ] = layoutManager . getAvailableSize ( splitPane . getSize ( ) , splitPane . getInsets ( ) ) - tmpSizes [ 0 ] ; layoutManager . setSizes ( tmpSizes ) ; splitPane . revalidate ( ) ; splitPane . repaint ( ) ; }	else if ( location > size . width )
if ( entry . isGetterEntry ) { list . add ( entry . field ) ; <CTX> private static IField [ ] getGetterFields ( Object [ ] result ) { Collection list = new ArrayList ( 0 ) ; Object each = null ; GetterSetterEntry entry = null ; for ( int i = 0 ; i < result . length ; i ++ ) { each = result [ i ] ; if ( ( each instanceof GetterSetterEntry ) ) { entry = ( GetterSetterEntry ) each ; if ( entry . isGetterEntry ) { list . add ( entry . field ) ; } } } return ( IField [ ] ) list . toArray ( new IField [ list . size ( ) ] ) ; }	if ( entry . fGetterEntry ) { list . add ( entry . fField ) ;
return js_NaN_date_str ; <CTX> private static String toLocale_helper ( double t , java . text . DateFormat formatter ) { if ( t != t ) return js_NaN_date_str ; java . util . Date tempdate = new Date ( ( long ) t ) ; return formatter . format ( tempdate ) ; }	return jsFunction_NaN_date_str ;
if ( ret != null ) <CTX> public region union ( region r ) { assert r != null ; assert r . rank == rank ; region ret = null ; if ( r instanceof MultiDimRegion ) { MultiDimRegion rc = ( MultiDimRegion ) r ; region [ ] d = new region [ rank ] ; for ( int i = 0 ; ret == null && i < d . length ; ++ i ) { d [ i ] = dims_[ i ] . union ( rc . dims_[ i ] ) ; if ( d [ i ] . size ( ) == 0 ) ret = new EmptyRegion ( rank ) ; } if ( ret != null ) ret = new MultiDimRegion ( d ) ; } else { ret = ArbitraryRegion . union ( this , r ) ; } return ret ; }	if ( ret == null )
return new ByteArrayInputStream ( sourceFile . getData ( ) ) ; <CTX> public InputStream openSource ( String packageName , String fileName ) throws IOException { SourceFile sourceFile = findSourceFile ( packageName , fileName ) ; return new ByteArrayInputStream ( sourceFile . getData ( ) ) ; }	return sourceFile . getInputStream ( ) ;
wcClient . doInfo ( myBaseFile , revision , recursive , this ) ; <CTX> public final void run ( final PrintStream out , PrintStream err ) throws SVNException { final boolean recursive = getCommandLine ( ) . hasArgument ( SVNArgument . RECURSIVE ) ; SVNRevision revision = SVNRevision . UNDEFINED ; if ( getCommandLine ( ) . hasArgument ( SVNArgument . RECURSIVE ) ) { revision = SVNRevision . parse ( ( String ) getCommandLine ( ) . getArgumentValue ( SVNArgument . REVISION ) ) ; } SVNWCClient wcClient = getClientManager ( ) . getWCClient ( ) ; myOut = out ; for ( int i = 0 ; i < getCommandLine ( ) . getPathCount ( ) ; i ++ ) { myBaseFile = new File ( getCommandLine ( ) . getPathAt ( i ) ) ; wcClient . doInfo ( myBaseFile , revision , recursive , this ) ; } myBaseFile = null ; for ( int i = 0 ; i < getCommandLine ( ) . getURLCount ( ) ; i ++ ) { String url = getCommandLine ( ) . getURL ( i ) ; SVNRevision peg = getCommandLine ( ) . getPegRevision ( i ) ; wcClient . doInfo ( SVNURL . parseURIEncoded ( url ) , peg , revision , recursive , this ) ; } }	SVNRevision peg = getCommandLine ( ) . getPathPegRevision ( i ) ; wcClient . doInfo ( myBaseFile , peg , revision , recursive , this ) ;
TasksUiPlugin . getSynchronizationManager ( ) . synchNow ( 0 , null ) ; <CTX> public void run ( IAction action ) { TasksUiPlugin . getSynchronizationManager ( ) . synchNow ( 0 , null ) ; }	TasksUiPlugin . getSynchronizationScheduler ( ) . synchNow ( 0 , null ) ;
getRequestingScheme ( ) { return ( scheme ) ; } <CTX> getRequestingScheme ( ) { return ( scheme ) ; }	protected final String getRequestingScheme ( ) { return scheme ; }
return new LocalQuickFix [ 0 ] ; <CTX> private LocalQuickFix [ ] createFixes ( PsiElement location ) { if ( ! onTheFly && inspection . buildQuickFixesOnlyForOnTheFlyErrors ( ) ) { return new LocalQuickFix [ 0 ] ; } final InspectionGadgetsFix [ ] fixes = inspection . buildFixes ( location ) ; if ( fixes != null ) { return fixes ; } final InspectionGadgetsFix fix = inspection . buildFix ( location ) ; if ( fix == null ) { return new LocalQuickFix [ 0 ] ; } return new InspectionGadgetsFix [ ] { fix } ; }	return null ;
IEditorPart editorPart = page . openEditor ( new ReportEditorInput ( file ) , <CTX> public void run ( ) { IWorkbench workbench = PlatformUI . getWorkbench ( ) ; IWorkbenchWindow window = workbench . getActiveWorkbenchWindow ( ) ; IWorkbenchPage page = window . getActivePage ( ) ; try { IEditorPart editorPart = page . openEditor ( new ReportEditorInput ( file ) , IReportEditorContants . LIBRARY_EDITOR_ID , true ) ; ModuleHandle model = SessionHandleAdapter . getInstance ( ) . getReportDesignHandle ( ) ; if ( ReportPlugin . getDefault ( ) . getEnableCommentPreference ( ) ) { model . setStringProperty ( ModuleHandle . COMMENTS_PROP , ReportPlugin . getDefault ( ) . getCommentPreference ( ) ) ; model . save ( ) ; editorPart . doSave ( null ) ; } } catch ( Exception e ) { ExceptionHandler . handle ( e ) ; } }	page . openEditor ( new ReportEditorInput ( file ) ,
getParent ( ) . insertChild ( this , getRole_( ) , this , true ) ; <CTX> public void addPrevSibling ( SNode newSibling ) { getParent ( ) . insertChild ( this , getRole_( ) , this , true ) ; }	getParent ( ) . insertChild ( this , getRole_( ) , newSibling , true ) ;
list . setContentProvider ( new PerspContentProvider ( filtering ) ) ; <CTX> private TableViewer createViewer ( Composite parent , boolean filtering ) { / / Add perspective list . TableViewer list = new TableViewer ( parent , SWT . H_SCROLL | SWT . V_SCROLL | SWT . BORDER ) ; list . getTable ( ) . setFont ( parent . getFont ( ) ) ; list . setLabelProvider ( new PerspectiveLabelProvider ( ) ) ; list . setContentProvider ( new PerspContentProvider ( filtering ) ) ; list . setSorter ( new ViewerSorter ( ) ) ; list . setInput ( perspReg ) ; list . addSelectionChangedListener ( this ) ; list . addDoubleClickListener ( new IDoubleClickListener ( ) { public void doubleClick ( DoubleClickEvent event ) { handleDoubleClickEvent ( ) ; } } ) ; return list ; }	list . setContentProvider ( new PerspContentProvider ( ) ) ;
( ( OptLocalVariable ) theVariables . get ( i ) ) . assignType ( TypeEvent . AnyType ) ; <CTX> void markAnyTypeVariables ( VariableTable theVariables ) { for ( int i = 0 ; i < theVariables . size ( ) ; i ++ ) if ( itsLiveOnEntrySet . test ( i ) ) ( ( OptLocalVariable ) theVariables . get ( i ) ) . assignType ( TypeEvent . AnyType ) ; }	( ( OptLocalVariable ) theVariables . getVariable ( i ) ) . assignType ( TypeEvent . AnyType ) ;
messageEventProducer . notifyListeners ( request , MessageEvent . REQUEST_RECEIVED , bodyID ) ; <CTX> protected void internalReceiveRequest ( Request request ) throws java . io . IOException { if ( messageEventProducer != null ) messageEventProducer . notifyListeners ( request , MessageEvent . REQUEST_RECEIVED , bodyID ) ; requestReceiver . receiveRequest ( request , this ) ; }	messageEventProducer . notifyListeners ( request , MessageEvent . REQUEST_RECEIVED , bodyID , getRequestQueue ( ) . size ( ) + 1 ) ;
EnterInterrupt ( Main main , StackFrame lastFrame , String threadTitle , <CTX> EnterInterrupt ( Main main , StackFrame lastFrame , String threadTitle , String alertMessage ) { this . main = main ; this . lastFrame = lastFrame ; this . threadTitle = threadTitle ; this . alertMessage = alertMessage ; }	EnterInterrupt ( DebugGui debugGui , StackFrame lastFrame , String threadTitle ,
if ( ! arrayAssigned ) super . visitElement ( element ) ; <CTX> public void visitElement ( PsiElement element ) { if ( ! arrayAssigned ) super . visitElement ( element ) ; }	if ( ! arrayAssigned ) { super . visitElement ( element ) ; }
String result = title ; if ( part != null ) result = part . getTitle ( ) ; return Util . safeString ( result ) ; <CTX> public String getTitle ( ) { String result = title ; if ( part != null ) result = part . getTitle ( ) ; return Util . safeString ( result ) ; }	return Util . safeString ( title ) ;
if ( markerSeverity == IMarker . SEVERITY_ERROR ) <CTX> private boolean selectBySeverity ( ProblemMarker item ) { if ( selectBySeverity ) { int markerSeverity = item . getSeverity ( ) ; if ( markerSeverity == IMarker . SEVERITY_ERROR ) return ( severity & SEVERITY_ERROR ) > 0 ; else if ( markerSeverity == IMarker . SEVERITY_WARNING ) return ( severity & SEVERITY_WARNING ) > 0 ; else if ( markerSeverity == IMarker . SEVERITY_INFO ) return ( severity & SEVERITY_INFO ) > 0 ; } return true ; }	if ( markerSeverity == IMarker . SEVERITY_ERROR ) {
List listenerList = ( List )_listenerClassModelEventsMap . get ( getKey ( modelClass , eventName ) ) ; <CTX> private void executeRemoveClassModelEventListener ( MElementListener listener , Class modelClass , String eventName ) { List listenerList = ( List )_listenerClassModelEventsMap . get ( getKey ( modelClass , eventName ) ) ; if ( listenerList == null ) return ; listenerList . remove ( listener ) ; if ( listenerList . isEmpty ( ) )_listenerClassModelEventsMap . remove ( getKey ( modelClass , eventName ) ) ; }	Set listenerList = ( Set )_listenerClassModelEventsMap . get ( getKey ( modelClass , eventName ) ) ;
notify ( ) ; <CTX> private void addChange ( Change changes ) { synchronized (_elements ) {_elements . add ( changes ) ; notify ( ) ; } }	_ elements . notify ( ) ;
ProcessorDefinition mainProcessorDefinition = InitUtils . getDefinitionFromMap ( new ServletInitMap ( this ) , ProcessorService . MAIN_PROCESSOR_PROPERTY_PREFIX , <CTX> public void init ( ) throws ServletException { try { / / Make sure the Web app context is initialized ServletContext servletContext = getServletContext ( ) ; webAppContext = WebAppContext . instance ( servletContext ) ; / / Try to obtain a local processor definition ProcessorDefinition mainProcessorDefinition = InitUtils . getDefinitionFromMap ( new ServletInitMap ( this ) , ProcessorService . MAIN_PROCESSOR_PROPERTY_PREFIX , ProcessorService . MAIN_PROCESSOR_INPUT_PROPERTY_PREFIX ) ; / / Try to obtain a processor definition from the properties if ( mainProcessorDefinition == null ) mainProcessorDefinition = InitUtils . getDefinitionFromProperties ( ProcessorService . MAIN_PROCESSOR_PROPERTY_PREFIX , ProcessorService . MAIN_PROCESSOR_INPUT_PROPERTY_PREFIX ) ; / / Try to obtain a processor definition from the context if ( mainProcessorDefinition == null ) mainProcessorDefinition = InitUtils . getDefinitionFromServletContext ( servletContext , ProcessorService . MAIN_PROCESSOR_PROPERTY_PREFIX , ProcessorService . MAIN_PROCESSOR_INPUT_PROPERTY_PREFIX ) ; / / Create and initialize service processorService = new ProcessorService ( ) ; processorService . init ( mainProcessorDefinition ) ; } catch ( Exception e ) { throw new ServletException ( OXFException . getRootThrowable ( e ) ) ; } }	ProcessorDefinition mainProcessorDefinition ; { mainProcessorDefinition = InitUtils . getDefinitionFromMap ( new ServletInitMap ( this ) , ProcessorService . MAIN_PROCESSOR_PROPERTY_PREFIX , ProcessorService . MAIN_PROCESSOR_INPUT_PROPERTY_PREFIX ) ; if ( mainProcessorDefinition == null ) mainProcessorDefinition = InitUtils . getDefinitionFromProperties ( ProcessorService . MAIN_PROCESSOR_PROPERTY_PREFIX ,
return RubyString . newString ( getRuntime ( ) , field . getName ( ) ) ; <CTX> public RubyString name ( ) { return RubyString . newString ( getRuntime ( ) , field . getName ( ) ) ; }	return getRuntime ( ) . newString ( field . getName ( ) ) ;
InputStream source = SVNFileUtil . DUMMY_IN ; <CTX> private byte [ ] getNextTextChunk ( int startIndex ) throws SVNException { ByteArrayOutputStream target = new ByteArrayOutputStream ( ) ; ByteArrayOutputStream data = new ByteArrayOutputStream ( ) ; InputStream source = SVNFileUtil . DUMMY_IN ; for ( ListIterator states = myRepStateList . listIterator ( startIndex + 1 ) ; states . hasPrevious ( ) ; ) { FSRepresentationState state = ( FSRepresentationState ) states . previous ( ) ; data . reset ( ) ; SVNDiffWindow window = null ; try { window = readWindow ( state , myChunkIndex , data ) ; } catch ( IOException ioe ) { SVNErrorMessage err = SVNErrorMessage . create ( SVNErrorCode . IO_ERROR , ioe . getLocalizedMessage ( ) ) ; SVNErrorManager . error ( err , ioe ) ; } SVNDiffWindowApplyBaton applyBaton = SVNDiffWindowApplyBaton . create ( source , target , null ) ; window . apply ( applyBaton , new ByteArrayInputStream ( data . toByteArray ( ) ) ) ; if ( states . hasPrevious ( ) ) { source = new ByteArrayInputStream ( target . toByteArray ( ) ) ; target . reset ( ) ; } } myChunkIndex ++ ; return target . toByteArray ( ) ; }	byte [ ] targetView = null ; byte [ ] sourceView = null ;
&& ! dialog . getShell ( ) . isDisposed ( ) ) parent = dialog . getShell ( ) ; <CTX> public void handleException ( Throwable t ) { try { exceptionCount ++ ; if ( exceptionCount > 1 ) { if ( closing ) { return ; } Shell parent = defaultParent ; if ( dialog != null && dialog . getShell ( ) != null && ! dialog . getShell ( ) . isDisposed ( ) ) parent = dialog . getShell ( ) ; MessageBox box = new MessageBox ( parent , SWT . ICON_ERROR | SWT . YES | SWT . NO | SWT . SYSTEM_MODAL ) ; box . setText ( MSG_FATAL_ERROR_RecursiveTitle ) ; box . setMessage ( MessageFormat . format ( MSG_FATAL_ERROR , new Object [ ] { MSG_FATAL_ERROR_Recursive } ) ) ; int result = box . open ( ) ; if ( result == SWT . YES ) { closeWorkbench ( ) ; } } else { if ( openQuestionDialog ( t ) ) { closeWorkbench ( ) ; } } } finally { exceptionCount -- ; } }	&& ! dialog . getShell ( ) . isDisposed ( ) ) { parent = dialog . getShell ( ) ; }
EMIT ( MIR_BinaryAcc . create ( IA 32_SUB , R ( lowlhsReg ) , R ( lowrhsReg ) ) ) ; EMIT ( MIR_BinaryAcc . mutate ( s , IA 32_SBB , R ( lhsReg ) , R ( rhsReg ) ) ) ; <CTX> protected final void LONG_SUB ( OPT_Instruction s , OPT_RegisterOperand result , OPT_Operand value ) { OPT_Register lhsReg = result . register ; OPT_Register lowlhsReg = regpool . getSecondReg ( lhsReg ) ; if ( value instanceof OPT_RegisterOperand ) { OPT_Register rhsReg = ( ( OPT_RegisterOperand ) value ) . register ; OPT_Register lowrhsReg = regpool . getSecondReg ( rhsReg ) ; EMIT ( MIR_BinaryAcc . create ( IA 32_SUB , R ( lowlhsReg ) , R ( lowrhsReg ) ) ) ; EMIT ( MIR_BinaryAcc . mutate ( s , IA 32_SBB , R ( lhsReg ) , R ( rhsReg ) ) ) ; } else { OPT_LongConstantOperand rhs = ( OPT_LongConstantOperand ) value ; int low = rhs . lower 32 ( ) ; int high = rhs . upper 32 ( ) ; if ( low == 0 ) { EMIT ( MIR_BinaryAcc . mutate ( s , IA 32_SUB , R ( lhsReg ) , IC ( high ) ) ) ; } else { EMIT ( MIR_BinaryAcc . create ( IA 32_SUB , R ( lowlhsReg ) , IC ( low ) ) ) ; EMIT ( MIR_BinaryAcc . mutate ( s , IA 32_SBB , R ( lhsReg ) , IC ( high ) ) ) ; } } }	EMIT ( MIR_BinaryAcc . create ( IA 32_SUB , new OPT_RegisterOperand ( lowlhsReg , VM_TypeReference . Int ) , new OPT_RegisterOperand ( lowrhsReg , VM_TypeReference . Int ) ) ) ; EMIT ( MIR_BinaryAcc . mutate ( s , IA 32_SBB , new OPT_RegisterOperand ( lhsReg , VM_TypeReference . Int ) , new OPT_RegisterOperand ( rhsReg , VM_TypeReference . Int ) ) ) ;
return ( Package [ ] ) this . pkgs . toArray ( new Package [ this . pkgs . size ( ) ] ) ; <CTX> public Package [ ] getPackages ( ) { return ( Package [ ] ) this . pkgs . toArray ( new Package [ this . pkgs . size ( ) ] ) ; }	return ( Package [ ] ) this . pkgs . values ( ) . toArray ( new Package [ this . pkgs . size ( ) ] ) ;
boolean forceUpdate = element instanceof IQueryHit ; <CTX> public void run ( ) { ISelection selection = viewer . getSelection ( ) ; Object element = ( ( IStructuredSelection ) selection ) . getFirstElement ( ) ; if ( element instanceof ITask || element instanceof IQueryHit ) { final ITask task ; if ( element instanceof IQueryHit ) { task = ( ( IQueryHit ) element ) . getOrCreateCorrespondingTask ( ) ; } else { task = ( ITask ) element ; } boolean forceUpdate = element instanceof IQueryHit ; final AbstractRepositoryClient client = MylarTaskListPlugin . getRepositoryManager ( ) . getRepositoryClient ( task . getRepositoryKind ( ) ) ; if ( ! task . isLocal ( ) && client != null ) { Job refreshJob = client . synchronize ( task , forceUpdate ) ; if ( refreshJob == null ) { TaskListUiUtil . openEditor ( task ) ; } else { refreshJob . addJobChangeListener ( new IJobChangeListener ( ) { public void done ( IJobChangeEvent event ) { TaskListUiUtil . openEditor ( task ) ; } public void aboutToRun ( IJobChangeEvent event ) { / / ignore } public void awake ( IJobChangeEvent event ) { / / ignore } public void running ( IJobChangeEvent event ) { / / ignore } public void scheduled ( IJobChangeEvent event ) { / / ignore } public void sleeping ( IJobChangeEvent event ) { / / ignore } } ) ; } } else { TaskListUiUtil . openEditor ( task ) ; } } else if ( element instanceof ITaskCategory ) { TaskListUiUtil . openEditor ( ( ITaskCategory ) element ) ; } else if ( element instanceof IRepositoryQuery ) { IRepositoryQuery query = ( IRepositoryQuery ) element ; AbstractRepositoryClient client = MylarTaskListPlugin . getRepositoryManager ( ) . getRepositoryClient ( query . getRepositoryKind ( ) ) ; client . openEditQueryDialog ( query ) ; } }	boolean forceUpdate = false ;
stepMeta . distributes = false ; <CTX> public void widgetSelected ( SelectionEvent e ) { stepMeta . distributes = false ; spoon . refreshGraph ( ) ; spoon . refreshTree ( ) ; }	stepMeta . distributes = true ;
return new ArrayList ( ( ( View ) model ) . getChildren ( ) ) ; <CTX> protected List getModelChildren ( ) { Object model = getModel ( ) ; if ( model != null && model instanceof View ) { return new ArrayList ( ( ( View ) model ) . getChildren ( ) ) ; } return Collections . EMPTY_LIST ; }	return ( ( View ) model ) . getChildren ( ) ;
return super . getProcessVersions ( ) ; } <CTX> public IProcessVersions getProcessVersions ( ) { return super . getProcessVersions ( ) ; }	return this . processVersions ; }
int getMonthOfYear ( long millis , int year ) { long monthZeroBased = ( millis - getYearMillis ( year ) ) / MILLIS_PER_MONTH ; return ( ( int ) monthZeroBased ) + 1 ; <CTX> int getMonthOfYear ( long millis , int year ) { long monthZeroBased = ( millis - getYearMillis ( year ) ) / MILLIS_PER_MONTH ; return ( ( int ) monthZeroBased ) + 1 ; }	int getMonthOfYear ( long millis ) { return ( getDayOfYear ( millis ) - 1 ) / MONTH_LENGTH + 1 ;
return EndianUtil . readSwappedUnsignedShort ( m_input ) ; <CTX> public int readUnsignedShort ( ) throws IOException , EOFException { return EndianUtil . readSwappedUnsignedShort ( m_input ) ; }	return EndianUtils . readSwappedUnsignedShort ( m_input ) ;
_ compilerErrorPanel . reset ( ) ; if ( inDebugMode ( ) ) {_model . getActiveDocument ( ) . checkIfClassFileInSync ( ) ;_updateDebugStatus ( ) ; } hourglassOff ( ) ; <CTX> public void run ( ) {_compilerErrorPanel . reset ( ) ; if ( inDebugMode ( ) ) {_model . getActiveDocument ( ) . checkIfClassFileInSync ( ) ;_updateDebugStatus ( ) ; } hourglassOff ( ) ; }	_ junitErrorPanel . getErrorListPane ( ) . testEnded ( name , wasSuccessful , causedError ) ;_junitErrorPanel . progressStep ( wasSuccessful ) ;
if ( ! changed && ( tab . x != x || tab . y != y ) ) changed = true ; <CTX> private boolean setItemLocation ( ) { if ( items . length == 0 ) return false ; Rectangle area = super . getClientArea ( ) ; int x = area . x ; int y = area . y + borderTop ; if ( onBottom ) y = Math . max ( 0 , area . y + area . height - borderBottom - tabHeight ) ; boolean changed = false ; for ( int i = topTabIndex - 1 ; i >= 0 ; i -- ) { / / if the first visible tab is not the first tab CTabItem tab = items [ i ] ; x -= tab . width ; if ( ! changed && ( tab . x != x || tab . y != y ) ) changed = true ; / / layout tab items from right to left thus making them invisible tab . x = x ; tab . y = y ; } x = area . x + borderLeft ; for ( int i = topTabIndex ; i < items . length ; i ++ ) { / / continue laying out remaining , visible items left to right CTabItem tab = items [ i ] ; tab . x = x ; tab . y = y ; x = x + tab . width ; } setButtonBounds ( ) ; return changed ; }	if ( ! changed && ( tab . x != x || tab . y != y ) ) { changed = true ; }
if ( childEntries != null ) for ( int i = 0 ; i < childEntries . length ; i ++ ) { <CTX> public void dispose ( ) { if ( editor != null ) { editor . dispose ( ) ; editor = null ; } / / recursive call to dispose children if ( childEntries != null ) for ( int i = 0 ; i < childEntries . length ; i ++ ) { / / an error in a property source may cause refreshChildEntries / / to fail . Since the Workbench handles such errors we / / can be left in a state where a child entry is null . if ( childEntries [ i ] != null ) childEntries [ i ] . dispose ( ) ; } }	PropertySheetEntry [ ] entriesToDispose = childEntries ; childEntries = null ; if ( entriesToDispose != null ) for ( int i = 0 ; i < entriesToDispose . length ; i ++ ) {
Iterator iter = getIfMap ( ) . values ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { IfInfo ifInfo = ( IfInfo ) iter . next ( ) ; if ( ! ifInfo . getOidList ( ) . isEmpty ( ) ) { return true ; } } return false ; <CTX> boolean hasDataToCollect ( ) { if ( ! getNodeInfo ( ) . getAttributeList ( ) . isEmpty ( ) ) return true ; Iterator iter = getIfMap ( ) . values ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { IfInfo ifInfo = ( IfInfo ) iter . next ( ) ; if ( ! ifInfo . getOidList ( ) . isEmpty ( ) ) { return true ; } } return false ; }	return hasInterfaceDataToollect ( ) ;
setRubyClass ( type ) ; <CTX> public RubyClass makeMetaClass ( RubyClass type ) { type = type . newSingletonClass ( ) ; setRubyClass ( type ) ; type . attachSingletonClass ( this ) ; return type ; }	setInternalClass ( type ) ;
Organizer rightOrganizer = ( Organizer ) getChild ( SplitPane . RIGHT_ORGANIZER ) ; <CTX> public void finalizz ( ) throws Exception { Organizer rightOrganizer = ( Organizer ) getChild ( SplitPane . RIGHT_ORGANIZER ) ; removeChild ( SplitPane . RIGHT_ORGANIZER ) ; destroyChild ( rightOrganizer ) ; Organizer leftOrganizer = ( Organizer ) getChild ( SplitPane . LEFT_ORGANIZER ) ; removeChild ( SplitPane . LEFT_ORGANIZER ) ; destroyChild ( leftOrganizer ) ; super . finalizz ( ) ; }	DisplayItem rightDisplayItem = ( DisplayItem ) getChild ( SplitPane . RIGHT_ORGANIZER ) ;
return getRuntime ( ) . newArray ( args ) ; <CTX> public IRubyObject create ( IRubyObject [ ] args ) { return getRuntime ( ) . newArray ( args ) ; }	RubyArray array = ( RubyArray ) allocateObject ( ) ; array . setMetaClass ( this ) ; if ( args . length > 1 ) { for ( int i = 0 ; i < args . length ; i ++ ) { array . add ( args [ i ] ) ; } } return array ;
jMenuItemAddFileToProjectActionPerformed ( evt ) ; <CTX> public void actionPerformed ( java . awt . event . ActionEvent evt ) { jMenuItemAddFileToProjectActionPerformed ( evt ) ; }	jMenuItemMakeResourceActionPerformed ( evt ) ;
getLevel ( ) ) ; <CTX> private void checkSwitchExpr ( ) { checkExpressionSubtree ( ( DetailAST ) getMainAst ( ) . findFirstToken ( TokenTypes . LPAREN ) . getNextSibling ( ) , getLevel ( ) ) ; }	getLevel ( ) , false , false ) ;
return_isNull ; <CTX> public boolean isNull ( ) { return_isNull ; }	return_data == null ;
viewer . update ( element , null ) ; <CTX> protected void setValue ( Object element , Object value ) { doSetValue ( element , value ) ; viewer . update ( element , null ) ; }	getViewer ( ) . update ( element , null ) ;
if ( ! ( lastArgument instanceof PsiArrayInitializerExpression ) ) { <CTX> private static void makeMethodCallsVarargs ( PsiElement element ) throws IncorrectOperationException { final PsiMethod method = ( PsiMethod ) element . getParent ( ) ; final Query < PsiReference > query = ReferencesSearch . search ( method , method . getUseScope ( ) , false ) ; for ( PsiReference reference : query ) { final PsiMethodCallExpression methodCallExpression = ( PsiMethodCallExpression ) reference . getElement ( ) ; final PsiExpressionList argumentList = methodCallExpression . getArgumentList ( ) ; final PsiExpression [ ] arguments = argumentList . getExpressions ( ) ; if ( arguments . length == 0 ) { continue ; } final PsiExpression lastArgument = arguments [ arguments . length - 1 ] ; if ( ! ( lastArgument instanceof PsiArrayInitializerExpression ) ) { continue ; } final PsiArrayInitializerExpression arrayInitializerExpression = ( PsiArrayInitializerExpression ) lastArgument ; final PsiExpression [ ] initializers = arrayInitializerExpression . getInitializers ( ) ; lastArgument . delete ( ) ; for ( PsiExpression initializer : initializers ) { argumentList . add ( initializer ) ; } } }	if ( ! ( lastArgument instanceof PsiNewExpression ) ) {
return new DF ( dirpath ) . getCapacity ( ) ; <CTX> public long getCapacity ( ) throws IOException { return new DF ( dirpath ) . getCapacity ( ) ; }	return diskUsage . getCapacity ( ) ;
textArea . grabFocus ( ) ; <CTX> public void run ( ) { textArea . grabFocus ( ) ; }	textArea . requestFocus ( ) ;
return readAncestor ( resourcename , CmsResourceFilter . requireType ( type ) ) ; <CTX> public CmsFolder readAncestor ( String resourcename , int type ) throws CmsException { return readAncestor ( resourcename , CmsResourceFilter . requireType ( type ) ) ; }	CmsResource resource = readResource ( resourcename , CmsResourceFilter . ALL ) ; return m_securityManager . readAncestor ( m_context , resource , filter ) ;
boolean isWritable ( int column ) throws SQLException ; <CTX> boolean isWritable ( int column ) throws SQLException ;	boolean isWritable ( int columnIndex ) throws SQLException ;
if ( inputState . guessing == 0 ) { in_AST = astFactory . create ( in ) ; astFactory . makeASTRoot ( currentAST , in_AST ) ; } <CTX> public final void postfixExpression ( ) throws RecognitionException , TokenStreamException { returnAST = null ; ASTPair currentAST = new ASTPair ( ) ; AST postfixExpression_AST = null ; Token in = null ; AST in_AST = null ; Token de = null ; AST de_AST = null ; boolean zz ; / * ignored * / { switch ( LA ( 1 ) ) { case IDENT : case LPAREN : case LITERAL_super : case LITERAL_this : case STRING_LITERAL : case DOLLAR : case STRING_CTOR_START : case LITERAL_new : case LITERAL_true : case LITERAL_false : case LITERAL_null : case NUM_INT : case NUM_FLOAT : case NUM_LONG : case NUM_DOUBLE : case NUM_BIG_INT : case NUM_BIG_DECIMAL : { zz = pathExpression ( ) ; if ( inputState . guessing == 0 ) { astFactory . addASTChild ( currentAST , returnAST ) ; } break ; } case LBRACK : case LCURLY : { pathExpressionFromBrackets ( ) ; if ( inputState . guessing == 0 ) { astFactory . addASTChild ( currentAST , returnAST ) ; } break ; } default : { throw new NoViableAltException ( LT ( 1 ) , getFilename ( ) ) ; } } } { switch ( LA ( 1 ) ) { case INC : { in = LT ( 1 ) ; if ( inputState . guessing == 0 ) { in_AST = astFactory . create ( in ) ; astFactory . makeASTRoot ( currentAST , in_AST ) ; } match ( INC ) ; if ( inputState . guessing == 0 ) { in_AST . setType ( POST_INC ) ; } break ; } case DEC : { de = LT ( 1 ) ; if ( inputState . guessing == 0 ) { de_AST = astFactory . create ( de ) ; astFactory . makeASTRoot ( currentAST , de_AST ) ; } match ( DEC ) ; if ( inputState . guessing == 0 ) { de_AST . setType ( POST_DEC ) ; } break ; } case EOF : case RBRACK : case QUESTION : case LT : case COMMA : case GT : case SR : case BSR : case STAR : case LITERAL_as : case RPAREN : case ASSIGN : case BAND : case RCURLY : case SEMI : case NLS : case LITERAL_default : case TRIPLE_DOT : case CLOSURE_OP : case LOR : case BOR : case COLON : case LITERAL_else : case LITERAL_in : case PLUS : case MINUS : case LITERAL_case : case PLUS_ASSIGN : case MINUS_ASSIGN : case STAR_ASSIGN : case DIV_ASSIGN : case MOD_ASSIGN : case SR_ASSIGN : case BSR_ASSIGN : case SL_ASSIGN : case BAND_ASSIGN : case BXOR_ASSIGN : case BOR_ASSIGN : case STAR_STAR_ASSIGN : case LAND : case BXOR : case REGEX_FIND : case REGEX_MATCH : case NOT_EQUAL : case EQUAL : case COMPARE_TO : case LE : case GE : case LITERAL_instanceof : case SL : case RANGE_INCLUSIVE : case DIV : case MOD : case STAR_STAR : { break ; } default : { throw new NoViableAltException ( LT ( 1 ) , getFilename ( ) ) ; } } } if ( inputState . guessing == 0 ) { postfixExpression_AST = ( AST ) currentAST . root ; } returnAST = postfixExpression_AST ; }	in_AST = astFactory . create ( in ) ; astFactory . makeASTRoot ( currentAST , in_AST ) ;
catch ( InterruptedException ex ) { <CTX> public void up ( Event evt ) { try { m_upQueue . put ( evt ) ; } catch ( InterruptedException ex ) { / / this is ok } }	catch ( QueueClosedException ex ) {
return sipHeader instanceof AlertInfo || sipHeader instanceof InReplyTo || sipHeader instanceof Authorization || sipHeader instanceof MaxForwards || sipHeader instanceof UserAgent || sipHeader instanceof Priority || sipHeader instanceof ProxyAuthorization || sipHeader instanceof ProxyRequire || sipHeader instanceof ProxyRequireList || sipHeader instanceof Route || sipHeader instanceof RouteList || sipHeader instanceof Subject ; <CTX> public static boolean isRequestHeader ( SIPHeader sipHeader ) { return sipHeader instanceof AlertInfo || sipHeader instanceof InReplyTo || sipHeader instanceof Authorization || sipHeader instanceof MaxForwards || sipHeader instanceof UserAgent || sipHeader instanceof Priority || sipHeader instanceof ProxyAuthorization || sipHeader instanceof ProxyRequire || sipHeader instanceof ProxyRequireList || sipHeader instanceof Route || sipHeader instanceof RouteList || sipHeader instanceof Subject ; }	return sipHeader instanceof AlertInfo || sipHeader instanceof InReplyTo || sipHeader instanceof Authorization || sipHeader instanceof MaxForwards || sipHeader instanceof UserAgent || sipHeader instanceof Priority || sipHeader instanceof ProxyAuthorization || sipHeader instanceof ProxyRequire || sipHeader instanceof ProxyRequireList || sipHeader instanceof Route || sipHeader instanceof RouteList || sipHeader instanceof Subject || sipHeader instanceof SIPIfMatch ;
if ( hi . from_entry . getName ( ) . equalsIgnoreCase ( name ) || hi . to_entry . getName ( ) . equalsIgnoreCase ( name ) ) { count ++ ; } <CTX> public JobHopMeta [ ] getAllJobHopsUsing ( String name ) { int count = 0 ; for ( int i = 0 ; i < nrJobHops ( ) ; i ++ ) { JobHopMeta hi = getJobHop ( i ) ; if ( hi . from_entry . getName ( ) . equalsIgnoreCase ( name ) || hi . to_entry . getName ( ) . equalsIgnoreCase ( name ) ) { count ++ ; } } JobHopMeta retval [ ] = new JobHopMeta [ count ] ; count = 0 ; for ( int i = 0 ; i < nrJobHops ( ) ; i ++ ) { JobHopMeta hi = getJobHop ( i ) ; if ( hi . from_entry . getName ( ) . equalsIgnoreCase ( name ) || hi . to_entry . getName ( ) . equalsIgnoreCase ( name ) ) { retval [ count ] = hi ; count ++ ; } } return retval ; }	if ( hi . from_entry != null && hi . to_entry != null ) { if ( hi . from_entry . getName ( ) . equalsIgnoreCase ( name ) || hi . to_entry . getName ( ) . equalsIgnoreCase ( name ) ) { hops . add ( hi ) ; } }
if ( object == null ) return ; object . setWaitingForRequest ( false ) ; <CTX> public void objectWaitingByNecessity ( UniqueID id , SpyEvent spyEvent ) { if ( ! controller . isMonitoring ( ) ) return ; ActiveObject object = findActiveObject ( id ) ; if ( object == null ) return ; object . setWaitingForRequest ( false ) ; communicationEventListener . objectWaitingByNecessity ( object , spyEvent ) ; }	if ( object == null ) { return ; } object . setServingStatus ( object . getServingStatus ( ) == ActiveObject . STATUS_SERVING_REQUEST ? ActiveObject . STATUS_WAITING_BY_NECESSITY_WHILE_SERVING : ActiveObject . STATUS_WAITING_BY_NECESSITY_WHILE_ACTIVE ) ;
if ( isSubtreeEnabled ( ) ) { deactivateAll ( getSourceDocument ( ) ) ; } else { deactivate ( getSourceDocument ( ) ) ; } <CTX> protected void doExecute ( ) throws Exception { super . doExecute ( ) ; if ( isSubtreeEnabled ( ) ) { deactivateAll ( getSourceDocument ( ) ) ; } else { deactivate ( getSourceDocument ( ) ) ; } }	deactivate ( getSourceDocument ( ) ) ;
return SelectiobObject ; <CTX> protected List getSelectionObject ( ) { return SelectiobObject ; }	return selectiobObject ;
Vector folders = cms . getSubFolders ( getConfigFile ( cms ) . getPicGalleryPath ( ) ) ; <CTX> public Vector getFiles ( CmsObject cms ) throws CmsException { Vector galleries = new Vector ( ) ; Vector folders = cms . getSubFolders ( getConfigFile ( cms ) . getPicGalleryPath ( ) ) ; int numFolders = folders . size ( ) ; for ( int i = 0 ; i < numFolders ; i ++ ) { CmsResource currFolder = ( CmsResource ) folders . elementAt ( i ) ; galleries . addElement ( currFolder ) ; } return galleries ; }	Vector folders = cms . getSubFolders ( getConfigFile ( cms ) . getHtmlGalleryPath ( ) ) ;
return node . getChild ( i ) ; <CTX> public SuffixNode getChild ( SuffixNode node , int i ) { if ( ! node . hasChild ( i ) ) { node . addChild ( this , i , new SimpleNode ( alphabet . size ( ) ) ) ; } return node . getChild ( i ) ; }	int index = indexForRes ( r ) ; return getChild ( node , index ) ;
if ( adaptable . equals ( IContextProvider . class ) ) <CTX> public Object getAdapter ( Class adaptable ) { if ( adaptable . equals ( IContextProvider . class ) ) return contextProvider ; if ( adaptable . equals ( IShowInSource . class ) ) { return new IShowInSource ( ) { public ShowInContext getShowInContext ( ) { ISelection selection = getViewer ( ) . getSelection ( ) ; if ( ! ( selection instanceof IStructuredSelection ) ) return null ; IStructuredSelection structured = ( IStructuredSelection ) selection ; Iterator markerIterator = structured . iterator ( ) ; List newSelection = new ArrayList ( ) ; while ( markerIterator . hasNext ( ) ) { ConcreteMarker element = ( ConcreteMarker ) markerIterator . next ( ) ; newSelection . add ( element . getResource ( ) ) ; } return new ShowInContext ( getViewer ( ) . getInput ( ) , new StructuredSelection ( newSelection ) ) ; } } ; } return super . getAdapter ( adaptable ) ; }	if ( adaptable . equals ( IContextProvider . class ) ) {
. getContentProvider ( ) ) ; <CTX> private ITreeContentProvider [ ] extractContentProviders ( Set theDescriptorInstances ) { if ( theDescriptorInstances . size ( ) == 0 ) return NO_CONTENT_PROVIDERS ; List resultProvidersList = new ArrayList ( ) ; for ( Iterator itr = theDescriptorInstances . iterator ( ) ; itr . hasNext ( ) ; ) resultProvidersList . add ( ( ( NavigatorContentExtension ) itr . next ( ) ) . getContentProvider ( ) ) ; return ( ITreeContentProvider [ ] ) resultProvidersList . toArray ( new ITreeContentProvider [ resultProvidersList . size ( ) ] ) ; }	. internalGetContentProvider ( ) ) ;
ungroupPrimitive ( pre , false ) ; <CTX> public void drawImage ( ImageRenderEvent pre ) throws ChartException { groupPrimitive ( pre , false ) ; super . drawImage ( pre ) ; ungroupPrimitive ( pre , false ) ; }	ivRenderer . ungroupPrimitive ( pre , false ) ;
Service service = ( Service ) services . get ( wsdlUrl ) ; if ( service != null ) { <CTX> protected synchronized Service getService ( UMOEvent event ) throws Exception { String wsdlUrl = getWsdlUrl ( event ) ; Service service = ( Service ) services . get ( wsdlUrl ) ; if ( service != null ) { services . put ( wsdlUrl , service ) ; } else { service = createService ( event ) ; } return service ; }	Service service = ( Service ) services . get ( wsdlUrl ) ; if ( service == null ) { service = createService ( event ) ;
return this . name ; <CTX> public String getName ( ) { return this . name ; }	return m_name ;
if ( sashes . left == null ) sashes . left = sash ; <CTX> void findSashes ( LayoutTree child , PartPane . Sashes sashes ) { Sash sash = ( Sash ) getSash ( ) . getControl ( ) ; boolean leftOrTop = children [ 0 ] == child ; if ( sash != null ) { LayoutPartSash partSash = getSash ( ) ; / / If the child is in the left , the sash / / is in the rigth and so on . if ( leftOrTop ) { if ( partSash . isVertical ( ) ) { if ( sashes . right == null ) sashes . right = sash ; } else { if ( sashes . bottom == null ) sashes . bottom = sash ; } } else { if ( partSash . isVertical ( ) ) { if ( sashes . left == null ) sashes . left = sash ; } else { if ( sashes . top == null ) sashes . top = sash ; } } } if ( getParent ( ) != null ) getParent ( ) . findSashes ( this , sashes ) ; }	if ( sashes . left == null ) { sashes . left = sash ; }
Calendar result = Calendar . getInstance ( ) ; result . setTime ( this . getStartTimeDate ( ) ) ; return result ; <CTX> public Calendar getStartTime ( ) { Calendar result = Calendar . getInstance ( ) ; result . setTime ( this . getStartTimeDate ( ) ) ; return result ; }	if ( this . getStartTimeDate ( ) != null ) { Calendar result = Calendar . getInstance ( ) ; result . setTime ( this . getStartTimeDate ( ) ) ; return result ; } return null ;
return RubyFixnum . newFixnum ( getRuby ( ) , end [ ( int ) index . getValue ( ) ] ) ; <CTX> public RubyObject end ( RubyFixnum index ) { if ( outOfBounds ( index ) ) { return getRuby ( ) . getNil ( ) ; } return RubyFixnum . newFixnum ( getRuby ( ) , end [ ( int ) index . getValue ( ) ] ) ; }	return RubyFixnum . newFixnum ( getRuby ( ) , end [ ( int ) index . getLongValue ( ) ] ) ;
switch ( f . methodId ) { <CTX> public Object execMethod ( IdFunction f , Context cx , Scriptable scope , Scriptable thisObj , Object [ ] args ) { if ( prototypeFlag ) { switch ( f . methodId ) { case Id_constructor : return jsConstructor ( cx , scope , args ) ; case Id_toString : { BaseFunction realf = realFunction ( thisObj , f ) ; int indent = ScriptRuntime . toInt 32 ( args , 0 ) ; return realf . decompile ( indent , 0 ) ; } case Id_toSource : { BaseFunction realf = realFunction ( thisObj , f ) ; int indent = 0 ; int flags = Decompiler . TO_SOURCE_FLAG ; if ( args . length != 0 ) { indent = ScriptRuntime . toInt 32 ( args [ 0 ] ) ; if ( indent >= 0 ) { flags = 0 ; } else { indent = 0 ; } } return realf . decompile ( indent , flags ) ; } case Id_apply : case Id_call : return applyOrCall ( f . methodId == Id_apply , cx , scope , thisObj , args ) ; } } return super . execMethod ( f , cx , scope , thisObj , args ) ; }	int methodId = f . methodId ( ) ; switch ( methodId ) {
event . getDNS ( ) . requestServiceInfo ( event . getType ( ) , event . getName ( ) , 0 ) ; <CTX> public void serviceAdded ( ServiceEvent event ) { event . getDNS ( ) . requestServiceInfo ( event . getType ( ) , event . getName ( ) , 0 ) ; }	synchronized ( infos ) { event . getDNS ( ) . requestServiceInfo ( event . getType ( ) , event . getName ( ) , 0 ) ; }
this ( s , null ) ; <CTX> public ClassNotFoundException ( String s ) { this ( s , null ) ; }	this ( null ) ;
contentQueue . clear ( ) ; } else { while ( ! contentQueue . isEmpty ( ) ) runOnce ( ( String ) contentQueue . remove ( 0 ) ) ; } <CTX> public void run ( ) { if ( shouldReset ) { runOnce ( null ) ; contentQueue . clear ( ) ; } else { while ( ! contentQueue . isEmpty ( ) ) runOnce ( ( String ) contentQueue . remove ( 0 ) ) ; } this . shouldReset = false ; this . shouldScroll = true ; this . isQueued = false ; }	while ( ! contentQueue . isEmpty ( ) ) runOnce ( ( String ) contentQueue . remove ( 0 ) ) ;
if ( block ) <CTX> public int open ( ) { if ( shell == null || shell . isDisposed ( ) ) { shell = null ; / / create the window create ( ) ; } / / limit the shell size to the display size constrainShellSize ( ) ; / / open the window shell . open ( ) ; / / run the event loop if specified if ( block ) runEventLoop ( shell ) ; return returnCode ; }	if ( block ) {
requires [ i ] . resolve ( ) ; <CTX> public final void resolve ( ) throws PluginException { if ( ! resolved ) { for ( int i = 0 ; i < extensions . length ; i ++ ) { extensions [ i ] . resolve ( ) ; } for ( int i = 0 ; i < extensionPoints . length ; i ++ ) { extensionPoints [ i ] . resolve ( ) ; } for ( int i = 0 ; i < requires . length ; i ++ ) { requires [ i ] . resolve ( ) ; } if ( runtime != null ) { runtime . resolve ( ) ; } resolved = true ; } }	requires [ i ] . resolve ( registry ) ;
tmfSpi . engineInit ( store ) ; <CTX> public final void init ( KeyStore store ) throws KeyStoreException { tmfSpi . engineInit ( store ) ; }	tmfSpi . engineInit ( params ) ;
descriptorHandle = new Integer ( nextHandle ( ) ) ; <CTX> private ObjectStreamClass readNewClassDesc ( boolean unshared ) throws ClassNotFoundException , IOException { / / So read . . . ( ) methods can be used by / / subclasses during readClassDescriptor ( ) primitiveData = input ; Integer oldHandle = descriptorHandle ; descriptorHandle = new Integer ( nextHandle ( ) ) ; ObjectStreamClass newClassDesc = readClassDescriptor ( ) ; if ( descriptorHandle != null ) { registerObjectRead ( newClassDesc , descriptorHandle , unshared ) ; } descriptorHandle = oldHandle ; primitiveData = emptyStream ; / / We need to map classDesc to class . try { newClassDesc . setClass ( resolveClass ( newClassDesc ) ) ; / / Check SUIDs verifySUID ( newClassDesc ) ; / / Check base name of the class verifyBaseName ( newClassDesc ) ; } catch ( ClassNotFoundException e ) { if ( mustResolve ) { throw e ; / / Just continue , the class may not be required } } / / Resolve the field signatures using the class loader of the / / resolved class ObjectStreamField [ ] fields = newClassDesc . getLoadFields ( ) ; fields = ( null == fields ? new ObjectStreamField [ ] { } : fields ) ; ClassLoader loader = newClassDesc . forClass ( ) == null ? callerClassLoader : newClassDesc . forClass ( ) . getClassLoader ( ) ; for ( ObjectStreamField element : fields ) { element . resolve ( loader ) ; } / / Consume unread class annotation data and TC_ENDBLOCKDATA discardData ( ) ; checkedSetSuperClassDesc ( newClassDesc , readClassDesc ( ) ) ; return newClassDesc ; }	descriptorHandle = Integer . valueOf ( nextHandle ( ) ) ;
if ( comparer == null ) <CTX> protected boolean equals ( Object elementA , Object elementB ) { if ( comparer == null ) return elementA == null ? elementB == null : elementA . equals ( elementB ) ; else return elementA == null ? elementB == null : comparer . equals ( elementA , elementB ) ; }	if ( comparer == null ) {
addByteCode ( ByteCode . DCMPG ) ; addByteCode ( ByteCode . IFLT , trueGOTO ) ; <CTX> private void genSimpleCompare ( int type , int trueGOTO , int falseGOTO ) { switch ( type ) { case Token . LE : addByteCode ( ByteCode . DCMPG ) ; addByteCode ( ByteCode . IFLE , trueGOTO ) ; break ; case Token . GE : addByteCode ( ByteCode . DCMPL ) ; addByteCode ( ByteCode . IFGE , trueGOTO ) ; break ; case Token . LT : addByteCode ( ByteCode . DCMPG ) ; addByteCode ( ByteCode . IFLT , trueGOTO ) ; break ; case Token . GT : addByteCode ( ByteCode . DCMPL ) ; addByteCode ( ByteCode . IFGT , trueGOTO ) ; break ; default : badTree ( ) ; } if ( falseGOTO != - 1 ) addByteCode ( ByteCode . GOTO , falseGOTO ) ; }	cfw . add ( ByteCode . DCMPG ) ; cfw . add ( ByteCode . IFLT , trueGOTO ) ;
IStyle areaStyle = root . getStyle ( ) ; setOffsetX ( getDimensionValue ( areaStyle . getProperty ( StyleConstants . STYLE_BORDER_LEFT_WIDTH ) ) + getDimensionValue ( areaStyle . getProperty ( StyleConstants . STYLE_PADDING_LEFT ) ) ) ; setOffsetY ( isFirst ? ( getDimensionValue ( areaStyle . getProperty ( StyleConstants . STYLE_BORDER_TOP_WIDTH ) ) + getDimensionValue ( areaStyle . getProperty ( StyleConstants . STYLE_PADDING_TOP ) ) ) : 0 ) ; <CTX> protected void newContext ( ) { createRoot ( ) ; / / validateBoxProperty ( root . getStyle ( ) ) ; if ( null != parent ) { / / support user defined width int max = parent . getMaxAvaWidth ( ) - parent . getCurrentIP ( ) ; if ( content != null ) { int specifiedWidth = getDimensionValue ( content . getWidth ( ) ) ; if ( specifiedWidth > 0 ) { max = Math . min ( max , specifiedWidth ) ; } } root . setAllocatedWidth ( max ) ; setMaxAvaWidth ( root . getContentWidth ( ) ) ; root . setAllocatedHeight ( parent . getMaxAvaHeight ( ) - parent . getCurrentBP ( ) ) ; setMaxAvaHeight ( root . getContentHeight ( ) ) ; } / / initialize offsetX and offsetY IStyle areaStyle = root . getStyle ( ) ; setOffsetX ( getDimensionValue ( areaStyle . getProperty ( StyleConstants . STYLE_BORDER_LEFT_WIDTH ) ) + getDimensionValue ( areaStyle . getProperty ( StyleConstants . STYLE_PADDING_LEFT ) ) ) ; setOffsetY ( isFirst ? ( getDimensionValue ( areaStyle . getProperty ( StyleConstants . STYLE_BORDER_TOP_WIDTH ) ) + getDimensionValue ( areaStyle . getProperty ( StyleConstants . STYLE_PADDING_TOP ) ) ) : 0 ) ; / / can be removed ? setCurrentBP ( 0 ) ; setCurrentIP ( 0 ) ; }	setOffsetX ( root . getContentX ( ) ) ; setOffsetY ( isFirst ? root . getContentY ( ) : 0 ) ;
switch ( eDerivedStructuralFeatureID ( eFeature ) ) <CTX> public void eUnset ( EStructuralFeature eFeature ) { switch ( eDerivedStructuralFeatureID ( eFeature ) ) { case TypePackage . STOCK_SERIES__ VISIBLE : unsetVisible ( ) ; return ; case TypePackage . STOCK_SERIES__ LABEL : setLabel ( ( Label ) null ) ; return ; case TypePackage . STOCK_SERIES__ DATA_DEFINITION : getDataDefinition ( ) . clear ( ) ; return ; case TypePackage . STOCK_SERIES__ SERIES_IDENTIFIER : setSeriesIdentifier ( SERIES_IDENTIFIER_EDEFAULT ) ; return ; case TypePackage . STOCK_SERIES__ DATA_POINT : setDataPoint ( ( DataPoint ) null ) ; return ; case TypePackage . STOCK_SERIES__ DATA_SETS : getDataSets ( ) . clear ( ) ; return ; case TypePackage . STOCK_SERIES__ LABEL_POSITION : unsetLabelPosition ( ) ; return ; case TypePackage . STOCK_SERIES__ STACKED : unsetStacked ( ) ; return ; case TypePackage . STOCK_SERIES__ TRIGGERS : getTriggers ( ) . clear ( ) ; return ; case TypePackage . STOCK_SERIES__ TRANSLUCENT : unsetTranslucent ( ) ; return ; case TypePackage . STOCK_SERIES__ CURVE_FITTING : setCurveFitting ( ( CurveFitting ) null ) ; return ; case TypePackage . STOCK_SERIES__ FILL : setFill ( ( Fill ) null ) ; return ; case TypePackage . STOCK_SERIES__ LINE_ATTRIBUTES : setLineAttributes ( ( LineAttributes ) null ) ; return ; } eDynamicUnset ( eFeature ) ; }	switch ( featureID )
newTypeIds . add ( ( ( IASTTypeId ) typeIds . get ( i ) ) . toString ( ) ) ; <CTX> public IASTExceptionSpecification createExceptionSpecification ( IASTScope scope , List typeIds ) throws ASTSemanticException { List newTypeIds = new ArrayList ( ) ; if ( typeIds != null ) { int size = typeIds . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) newTypeIds . add ( ( ( IASTTypeId ) typeIds . get ( i ) ) . toString ( ) ) ; } return new ASTExceptionSpecification ( newTypeIds ) ; }	newTypeIds . add ( typeIds . get ( i ) ) ;
iVisited . accept (_Payload ) ; <CTX> public void visitArgsNode ( ArgsNode iVisited ) { iVisited . accept (_Payload ) ; Node lOptNode = iVisited . getOptNode ( ) ; if ( lOptNode != null ) { lOptNode . accept ( this ) ; } }	_ Payload . visitArgsNode ( iVisited ) ;
return new DiscoverPropertiesRowset ( request , handler ) ; <CTX> public Rowset getRowset ( XmlaRequest request , XmlaHandler handler ) { return new DiscoverPropertiesRowset ( request , handler ) ; }	return new DiscoverSchemaRowsetsRowset ( request , handler ) ;
classNames = new ObjToIntMap ( ) ; <CTX> public IRFactory createIRFactory ( Context cx , TokenStream ts ) { if ( nameHelper == null ) { nameHelper = ( OptClassNameHelper ) ClassNameHelper . get ( cx ) ; classNames = new ObjToIntMap ( ) ; } return new IRFactory ( this , ts ) ; }	itsUseDynamicScope = cx . hasCompileFunctionsWithDynamicScope ( ) ; generateDebugInfo = ( ! cx . isGeneratingDebugChanged ( ) || cx . isGeneratingDebug ( ) ) ; languageVersion = cx . getLanguageVersion ( ) ;
boolean optimizedTransform = ( transformType & ( AffineTransform . TYPE_TRANSLATION | AffineTransform . TYPE_IDENTITY ) ) != 0 ; <CTX> private void updateOptimization ( ) { int transformType = transform . getType ( ) ; boolean optimizedTransform = ( transformType & ( AffineTransform . TYPE_TRANSLATION | AffineTransform . TYPE_IDENTITY ) ) != 0 ; isOptimized = clip instanceof Rectangle && optimizedTransform && paint instanceof Color && composite == AlphaComposite . SrcOver && stroke . equals ( new BasicStroke ( ) ) ; }	boolean optimizedTransform = false ; if ( transformType == AffineTransform . TYPE_IDENTITY || transformType == AffineTransform . TYPE_TRANSLATION ) optimizedTransform = true ;
if ( getNode ( ) . getNodeType ( ) == getNode ( ) . ELEMENT_NODE ) { <CTX> public boolean isElement ( ) { if ( this . node == null ) { return false ; } if ( getNode ( ) . getNodeType ( ) == getNode ( ) . ELEMENT_NODE ) { return true ; } return false ; }	if ( getNode ( ) . getNodeType ( ) == Node . ELEMENT_NODE ) {
iVisited . accept (_Payload ) ; <CTX> public void visitUntilNode ( UntilNode iVisited ) { iVisited . accept (_Payload ) ; }	_ Payload . visitUntilNode ( iVisited ) ;
} else if ( selectedObject instanceof IQueryHit ) { task = ( ( IQueryHit ) selectedObject ) . getOrCreateCorrespondingTask ( ) ; <CTX> public boolean performDrop ( Object data ) { IStructuredSelection selection = ( ( IStructuredSelection ) TaskListView . getDefault ( ) . getViewer ( ) . getSelection ( ) ) ; for ( Iterator iter = selection . iterator ( ) ; iter . hasNext ( ) ; ) { Object selectedObject = iter . next ( ) ; if ( selectedObject instanceof ITask ) { contentProvider . addTask ( ( ITask ) selectedObject ) ; updateLabels ( ) ; continue ; } else if ( selectedObject instanceof ITaskListElement ) { / / if ( MylarTaskListPlugin . getDefault ( ) . getHandlerForElement ( ( ITaskListElement ) selectedObject ) != null ) { ITask task = null ; if ( selectedObject instanceof ITask ) { task = ( ITask ) selectedObject ; } else if ( selectedObject instanceof IQueryHit ) { task = ( ( IQueryHit ) selectedObject ) . getOrCreateCorrespondingTask ( ) ; } if ( task != null ) { contentProvider . addTask ( task ) ; updateLabels ( ) ; continue ; } / / } } else { return false ; } } tableViewer . refresh ( ) ; return true ; }	} else if ( selectedObject instanceof AbstractQueryHit ) { task = ( ( AbstractQueryHit ) selectedObject ) . getOrCreateCorrespondingTask ( ) ;
NodeComponent node = ( NodeComponent ) iter . next ( ) ; ConsoleTreeObject cto = new ConsoleTreeObject ( node ) ; <CTX> private void addUnassignedNodesFromExperiment ( ) { Set unassignedNodes = new TreeSet ( baseComponentComparator ) ; HostComponent [ ] hosts = experiment . getHosts ( ) ; NodeComponent [ ] nodes = experiment . getNodes ( ) ; unassignedNodes . addAll ( Arrays . asList ( nodes ) ) ; for ( int i = 0 ; i < hosts . length ; i ++ ) unassignedNodes . removeAll ( Arrays . asList ( hosts [ i ] . getNodes ( ) ) ) ; DefaultMutableTreeNode root = ( DefaultMutableTreeNode ) nodeTree . getModel ( ) . getRoot ( ) ; DefaultTreeModel model = ( DefaultTreeModel ) nodeTree . getModel ( ) ; Iterator iter = unassignedNodes . iterator ( ) ; while ( iter . hasNext ( ) ) { NodeComponent node = ( NodeComponent ) iter . next ( ) ; ConsoleTreeObject cto = new ConsoleTreeObject ( node ) ; DefaultMutableTreeNode newNodeTreeNode = new DefaultMutableTreeNode ( cto , true ) ; model . insertNodeInto ( newNodeTreeNode , root , root . getChildCount ( ) ) ; AgentComponent [ ] agents = node . getAgents ( ) ; for ( int j = 0 ; j < agents . length ; j ++ ) { AgentComponent agentComponent = agents [ j ] ; cto = new ConsoleTreeObject ( agentComponent ) ; DefaultMutableTreeNode newAgentNode = new DefaultMutableTreeNode ( cto , false ) ; model . insertNodeInto ( newAgentNode , newNodeTreeNode , newNodeTreeNode . getChildCount ( ) ) ; } } }	NodeComponent nodeComponent = ( NodeComponent ) iter . next ( ) ; ConsoleTreeObject cto = new ConsoleTreeObject ( nodeComponent ) ;
Assert . assert ( - 1 != nativeRDFNode ) ; <CTX> public Enumeration children ( ) { Assert . assert ( - 1 != nativeRDFNode ) ; Enumeration enum = null ; enum = new RDFEnumeration ( nativeWebShell , this ) ; return enum ; }	Assert . assert_it ( - 1 != nativeRDFNode ) ;
this . element = element ; <CTX> public ToolsSettingsBlock ( BuildPropertyPage parent , Object element ) { super ( ManagedBuilderUIMessages . getResourceString ( SETTINGS_LABEL ) ) ; super . setContainer ( parent ) ; this . parent = parent ; configToPageListMap = new HashMap ( ) ; this . element = element ; settingsStore = new BuildToolSettingsPreferenceStore ( this ) ; }	this . propertyObject = element ;
|| ( aAST . getParent ( ) . getType ( ) != TokenTypes . TYPECAST ) ) <CTX> public void visitToken ( DetailAST aAST ) { / / Strange logic in this method to guard against checking RPAREN tokens / / that are associated with a TYPECAST token . if ( aAST . getType ( ) != TokenTypes . RPAREN ) { if ( ! isPreceedsEmptyForInit ( aAST ) ) { processLeft ( aAST ) ; } } else if ( ( aAST . getParent ( ) == null ) || ( aAST . getParent ( ) . getType ( ) != TokenTypes . TYPECAST ) ) { if ( ! isFollowsEmptyForIterator ( aAST ) ) { processRight ( aAST ) ; } } }	|| ( aAST . getParent ( ) . getType ( ) != TokenTypes . TYPECAST ) || ( aAST . getParent ( ) . findFirstToken ( TokenTypes . RPAREN ) != aAST ) )
if ( message == null ) <CTX> public static IStatus errorStatus ( Throwable exception ) { String message = exception . getLocalizedMessage ( ) ; if ( message == null ) message = EMPTY_STRING ; return new Status ( IStatus . ERROR , IDEWorkbenchPlugin . IDE_WORKBENCH , IStatus . ERROR , message , exception ) ; }	if ( message == null ) {
return getPropertyAsFloat ( PERCENTTHROUGHPUT ) ; <CTX> public float getPercentThroughput ( ) { return getPropertyAsFloat ( PERCENTTHROUGHPUT ) ; }	return getPropertyAsString ( PERCENTTHROUGHPUT ) ;
int offset ) <CTX> final public static Address alignAllocation ( Address region , int alignment , int offset ) throws InlinePragma { return alignAllocation ( region , alignment , offset , MIN_ALIGNMENT ) ; }	int offset , int knownAlignment )
if ( hasFailedOK ) <CTX> public void run ( ) { getButton ( IDialogConstants . OK_ID ) . setEnabled ( false ) ; errorOccurred = false ; boolean hasFailedOK = false ; try { / / Notify all the pages and give them a chance to abort Iterator nodes = preferenceManager . getElements ( PreferenceManager . PRE_ORDER ) . iterator ( ) ; while ( nodes . hasNext ( ) ) { IPreferenceNode node = ( IPreferenceNode ) nodes . next ( ) ; IPreferencePage page = node . getPage ( ) ; if ( page != null ) { if ( ! page . performOk ( ) ) { hasFailedOK = true ; return ; } } } } catch ( Exception e ) { handleException ( e ) ; } finally { / / Don t bother closing if the OK failed if ( hasFailedOK ) return ; if ( ! errorOccurred ) / / Give subclasses the choice to save the state of the / / preference pages . handleSave ( ) ; close ( ) ; } }	if ( hasFailedOK ) { setReturnCode ( FAILED ) ; getButton ( IDialogConstants . OK_ID ) . setEnabled ( true ) ;
. haveActiveContextsChanged ( ) , false , false , false , false , false , false , null , null , null ) ) ; <CTX> public final void contextManagerChanged ( final ContextManagerEvent event ) { fireCommandManagerChanged ( new CommandManagerEvent ( this , event . haveActiveContextsChanged ( ) , false , false , false , false , false , false , null , null , null ) ) ; }	. isActiveContextsChanged ( ) , false , false , false , false , false , false , null , null , null ) ) ;
if (_generatedSourceFolder == null ) {_generatedSourceFolder = getGeneratedSourceFolder ( ) ;_generatedSourceFolder . refreshLocal ( IResource . DEPTH_INFINITE , progressMonitor ) ; if ( !_generatedSourceFolder . exists ( ) )_generatedSourceFolder . create ( true , false , progressMonitor ) ; <CTX> private IFolder ensureGeneratedSourceFolder ( IJavaProject javaProject , IProgressMonitor progressMonitor ) throws CoreException { if (_generatedSourceFolder == null ) {_generatedSourceFolder = getGeneratedSourceFolder ( ) ;_generatedSourceFolder . refreshLocal ( IResource . DEPTH_INFINITE , progressMonitor ) ; if ( !_generatedSourceFolder . exists ( ) )_generatedSourceFolder . create ( true , false , progressMonitor ) ; / / / / make sure__ generated_src dir is on the cp if not already / / updateProjectClasspath ( javaProject ,_generatedSourceFolder , progressMonitor ) ; } return_generatedSourceFolder ; }	IFolder srcFolder = getGeneratedSourceFolder ( ) ; srcFolder . refreshLocal ( IResource . DEPTH_INFINITE , progressMonitor ) ; if ( ! srcFolder . exists ( ) ) srcFolder . create ( true , false , progressMonitor ) ;
LocalVcs vcs = LocalVcsComponent . getInstance ( myProject ) . getLocalVcs ( ) ; <CTX> private void initModel ( VirtualFile f ) { LocalVcs vcs = LocalVcsComponent . getInstance ( myProject ) . getLocalVcs ( ) ; myModel = createModelFor ( f , vcs ) ; }	LocalVcs vcs = LocalVcsComponent . getLocalVcsFor ( myProject ) ;
int value = read ( ) ; <CTX> public final byte readByte ( ) throws IOException { int value = read ( ) ; if ( value == - 1 ) { throw new EOFException ( ) ; } return ( ( byte ) value ) ; }	final int value = read ( ) ;
return Long . toString ( ( long ) r + o 1 ) ; <CTX> public Object getValueAt ( int row , int col ) { int r = row - 1 ; int c = col - 1 ; if ( r >= 0 && r < rows && c >= 0 && c < cols ) { long p 0 = o 0 + ( ( long ) c ) ; long p 1 = o 1 + ( ( long ) rows - 1 - r ) ; long [ ] pos = new long [ ] { p 0 , p 1 } ; int index = ( int ) shape . positionToOffset ( pos ) ; return cg . getValueAt ( index ) ; } else { if ( ( r < 0 || r >= rows ) && ( c >= 0 && c < cols ) ) { return Long . toString ( ( long ) c + o 0 ) ; } else if ( ( c < 0 || c >= cols ) && ( r >= 0 && r < rows ) ) { return Long . toString ( ( long ) r + o 1 ) ; } else { return null ; } } }	long p 1 = o 1 + ( ( long ) rows - 1 - r ) ; return Long . toString ( p 1 ) ;
rlog = runtimeLogger ; introspector = new Introspector ( rlog ) ; <CTX> public void setRuntimeLogger ( RuntimeLogger runtimeLogger ) { rlog = runtimeLogger ; introspector = new Introspector ( rlog ) ; }	setLog ( new RuntimeLoggerLog ( runtimeLogger ) ) ;
if ( context . isInFactory ( ) && ( expressionResults != null ) ) <CTX> protected void accessRow ( RowDesign row , IContentEmitter emitter , ExpressionResults expressionResults ) { if ( rowClosed ) { IRowContent rowContent = report . createRowContent ( ) ; rowContent . setRowID ( rowId ++ ) ; assert ( rowContent instanceof RowContent ) ; IContent parent = context . getContent ( ) ; context . pushContent ( rowContent ) ; initializeContent ( parent , row , rowContent ) ; processStyle ( row , rowContent ) ; processVisibility ( row , rowContent ) ; processBookmark ( row , rowContent ) ; processAction ( row , rowContent ) ; if ( needPageBreak ) { rowContent . getStyle ( ) . setProperty ( IStyle . STYLE_PAGE_BREAK_BEFORE , IStyle . SOFT_VALUE ) ; needPageBreak = false ; } if ( context . isInFactory ( ) && ( expressionResults != null ) ) { DetailRowScriptExecutor . handleOnCreate ( ( RowContent ) rowContent , expressionResults , context ) ; } if ( emitter != null ) { emitter . startRow ( rowContent ) ; } rowClosed = false ; } for ( int j = 0 ; j < row . getCellCount ( ) ; j ++ ) { CellDesign cell = row . getCell ( j ) ; if ( cell != null ) { ICellContent cellContent = report . createCellContent ( ) ; assert ( cellContent instanceof CellContent ) ; IContent parent = context . getContent ( ) ; context . pushContent ( cellContent ) ; initializeContent ( parent , cell , cellContent ) ; cellContent . setColumn ( cell . getColumn ( ) ) ; cellContent . setColSpan ( cell . getColSpan ( ) ) ; cellContent . setRowSpan ( cell . getRowSpan ( ) ) ; processStyle ( cell , cellContent ) ; processVisibility ( cell , cellContent ) ; processBookmark ( cell , cellContent ) ; processAction ( cell , cellContent ) ; if ( context . isInFactory ( ) ) { CellScriptExecutor . handleOnCreate ( ( CellContent ) cellContent , expressionResults , context ) ; } if ( emitter != null ) { emitter . startCell ( cellContent ) ; } for ( int m = 0 ; m < cell . getContentCount ( ) ; m ++ ) { ReportItemDesign item = cell . getContent ( m ) ; if ( item != null ) { if ( layoutEmitter != null ) { item . accept ( this . visitor , layoutEmitter . getCellEmitter ( ) ) ; } else { item . accept ( this . visitor , emitter ) ; } } } if ( emitter != null ) { emitter . endCell ( cellContent ) ; } context . popContent ( ) ; } } boolean closeRow = true ; if ( closeRow ) { emitter . endRow ( ( IRowContent ) context . getContent ( ) ) ; context . popContent ( ) ; rowClosed = true ; } }	if ( context . isInFactory ( ) )
AbstractBody . removeBodyEventListener ( bodyEventListener ) ; <CTX> void removeBodyEventListener ( ) { AbstractBody . removeBodyEventListener ( bodyEventListener ) ; }	LocalBodyStore . getInstance ( ) . removeBodyEventListener ( bodyEventListener ) ;
if ( iconName == null ) return null ; <CTX> public ImageDescriptor getImageDescriptor ( ) { if ( imageDescriptor == null ) { String iconName = configurationElement . getAttribute ( IWorkbenchRegistryConstants . ATT_ICON ) ; if ( iconName == null ) return null ; imageDescriptor = AbstractUIPlugin . imageDescriptorFromPlugin ( configurationElement . getNamespace ( ) , iconName ) ; } return imageDescriptor ; }	if ( iconName == null ) { return null ; }
setValueAt ( a_Object , li_row , 1 ) ; <CTX> public int addValue ( Object a_Object ) { int li_row = add ( ) ; setValueAt ( a_Object , li_row , 1 ) ; return li_row ; }	try { setValueAt ( a_Object , li_row , 1 ) ; } catch ( ComponentDataException l_ComponentDataException ) { delete ( li_row ) ; }
String resNav = IPageLayout . ID_RES_NAV ; String probView = IPageLayout . ID_PROBLEM_VIEW ; return new TestDropLocation [ ] { <CTX> private TestDropLocation [ ] getCommonDropTargets ( IWorkbenchWindowProvider dragSource ) { String resNav = IPageLayout . ID_RES_NAV ; String probView = IPageLayout . ID_PROBLEM_VIEW ; return new TestDropLocation [ ] { / / Test dragging to the edges of the workbench window new WindowDropTarget ( dragSource , SWT . TOP ) , new WindowDropTarget ( dragSource , SWT . BOTTOM ) , new WindowDropTarget ( dragSource , SWT . LEFT ) , new WindowDropTarget ( dragSource , SWT . RIGHT ) } ; }	TestDropLocation [ ] targets = {
} catch ( InstantiationException e ) { ex = e ; } catch ( IllegalAccessException e ) { ex = e ; <CTX> protected Delegator newInstance ( ) { Exception ex ; try { return ( Delegator ) this . getClass ( ) . newInstance ( ) ; } catch ( InstantiationException e ) { ex = e ; } catch ( IllegalAccessException e ) { ex = e ; } throw WrappedException . wrapException ( ex ) ; }	} catch ( Exception ex ) { throw ScriptRuntime . throwAsUncheckedException ( ex ) ;
RubyClass superClass = ( RubyClass ) loadClass ( javaClass . getSuperclass ( ) , null ) ; <CTX> private RubyClass createRubyClass ( Class javaClass , String rubyName ) { RubyClass superClass = ( RubyClass ) loadClass ( javaClass . getSuperclass ( ) , null ) ; RubyClass rubyClass = ruby . defineClass ( rubyName , superClass ) ; loadedJavaClasses . put ( javaClass , rubyClass ) ; defineWrapperMethods ( javaClass , rubyClass , true ) ; defineConstants ( javaClass , rubyClass ) ; defineFields ( javaClass , rubyClass ) ; addDefaultModules ( rubyClass ) ; return rubyClass ; }	Class javaSuperClass = javaClass . getSuperclass ( ) ; RubyClass superClass ; if ( javaSuperClass != null ) { superClass = ( RubyClass ) loadClass ( javaSuperClass , null ) ; } else { superClass = ruby . getClasses ( ) . getObjectClass ( ) ; }
return RubyBoolean . newBoolean ( getRuntime ( ) , threadLocalVariables . containsKey ( name ) ) ; <CTX> public RubyBoolean has_key ( IRubyObject key ) { String name = keyName ( key ) ; return RubyBoolean . newBoolean ( getRuntime ( ) , threadLocalVariables . containsKey ( name ) ) ; }	return getRuntime ( ) . newBoolean ( threadLocalVariables . containsKey ( name ) ) ;
Iterator it = components . iterator ( ) ; while ( it . hasNext ( ) ) { ( ( JComponent ) it . next ( ) ) . setEnabled ( enabled ) ; } <CTX> public void update ( boolean enabled ) { Iterator it = components . iterator ( ) ; while ( it . hasNext ( ) ) { ( ( JComponent ) it . next ( ) ) . setEnabled ( enabled ) ; } }	menuItem . setEnabled ( enabled ) ;
assertNotSame ( 0 , atf . getSize ( ) ) ; <CTX> public void testAtomTypeFactory ( ) { assertTrue ( atf != null ) ; assertNotSame ( 0 , atf . getSize ( ) ) ; }	assertNotSame ( new Integer ( 0 ) , new Integer ( atf . getSize ( ) ) ) ;
Object listeners = contextListeners ; <CTX> private void runListeners ( int reason ) { Object listeners = contextListeners ; for ( int i = 0 ; ; ++ i ) { ContextListener l ; l = ( ContextListener ) Kit . getListener ( listeners , i ) ; if ( l == null ) break ; switch ( reason ) { case CONTEXT_CREATED_EVENT : l . contextCreated ( this ) ; break ; case CONTEXT_ENTER_EVENT : l . contextEntered ( this ) ; break ; case CONTEXT_EXIT_EVENT : l . contextExited ( this ) ; break ; case CONTEXT_RELEASED_EVENT : l . contextReleased ( this ) ; break ; default : Kit . codeBug ( ) ; } } }	Object listeners = staticListeners ;
int topMarginHeight = PropertyUtil . getDimensionValue ( style . getProperty ( StyleConstants . STYLE_MARGIN_TOP ) ) ; int bottomMarginHeight = PropertyUtil . getDimensionValue ( style . getProperty ( StyleConstants . STYLE_MARGIN_BOTTOM ) ) ; int result = 0 ; if ( topMarginHeight >= 0 ) result = height + topMarginHeight ; if ( bottomMarginHeight >= 0 ) result = result + bottomMarginHeight ; return result ; <CTX> public int getAllocatedHeight ( ) { int topMarginHeight = PropertyUtil . getDimensionValue ( style . getProperty ( StyleConstants . STYLE_MARGIN_TOP ) ) ; int bottomMarginHeight = PropertyUtil . getDimensionValue ( style . getProperty ( StyleConstants . STYLE_MARGIN_BOTTOM ) ) ; int result = 0 ; if ( topMarginHeight >= 0 ) result = height + topMarginHeight ; if ( bottomMarginHeight >= 0 ) result = result + bottomMarginHeight ; return result ; }	return height + PropertyUtil . getDimensionValue ( style . getProperty ( StyleConstants . STYLE_MARGIN_TOP ) ) + PropertyUtil . getDimensionValue ( style . getProperty ( StyleConstants . STYLE_MARGIN_BOTTOM ) ) ;
switch ( eDerivedStructuralFeatureID ( eFeature ) ) <CTX> public boolean eIsSet ( EStructuralFeature eFeature ) { switch ( eDerivedStructuralFeatureID ( eFeature ) ) { case TypePackage . BAR_SERIES__ VISIBLE : return isSetVisible ( ) ; case TypePackage . BAR_SERIES__ LABEL : return label != null ; case TypePackage . BAR_SERIES__ DATA_DEFINITION : return dataDefinition != null && ! dataDefinition . isEmpty ( ) ; case TypePackage . BAR_SERIES__ SERIES_IDENTIFIER : return SERIES_IDENTIFIER_EDEFAULT == null ? seriesIdentifier != null : ! SERIES_IDENTIFIER_EDEFAULT . equals ( seriesIdentifier ) ; case TypePackage . BAR_SERIES__ DATA_POINT : return dataPoint != null ; case TypePackage . BAR_SERIES__ DATA_SETS : return dataSets != null && ! dataSets . isEmpty ( ) ; case TypePackage . BAR_SERIES__ LABEL_POSITION : return isSetLabelPosition ( ) ; case TypePackage . BAR_SERIES__ STACKED : return isSetStacked ( ) ; case TypePackage . BAR_SERIES__ TRIGGERS : return triggers != null && ! triggers . isEmpty ( ) ; case TypePackage . BAR_SERIES__ TRANSLUCENT : return isSetTranslucent ( ) ; case TypePackage . BAR_SERIES__ CURVE_FITTING : return curveFitting != null ; case TypePackage . BAR_SERIES__ RISER : return isSetRiser ( ) ; case TypePackage . BAR_SERIES__ RISER_OUTLINE : return riserOutline != null ; } return eDynamicIsSet ( eFeature ) ; }	switch ( featureID )
super ( configuration ) ; <CTX> public CmsSelectWidget ( List configuration ) { super ( configuration ) ; }	super ( ) ;
ruleArray [ i ] = WorkspaceUndoSupport . getWorkspaceRuleFactory ( ) <CTX> protected ISchedulingRule getUndoSchedulingRule ( ) { ISchedulingRule [ ] ruleArray = new ISchedulingRule [ resources . length ] ; for ( int i = 0 ; i < resources . length ; i ++ ) { ruleArray [ i ] = WorkspaceUndoSupport . getWorkspaceRuleFactory ( ) . deleteRule ( resources [ i ] ) ; } return MultiRule . combine ( ruleArray ) ; }	ruleArray [ i ] = WorkspaceUndoUtil . getWorkspaceRuleFactory ( )
viewBugDetailsItemActionPerformed ( evt ) ; <CTX> public void actionPerformed ( java . awt . event . ActionEvent evt ) { viewBugDetailsItemActionPerformed ( evt ) ; }	viewConsoleItemActionPerformed ( evt ) ;
Assert . assert ( - 1 != nativeWebShell ) ; <CTX> public void back ( ) { myFactory . throwExceptionIfNotInitialized ( ) ; Assert . assert ( - 1 != nativeWebShell ) ; synchronized ( myBrowserControl ) { nativeBack ( nativeWebShell ) ; }	Assert . assert_it ( - 1 != nativeWebShell ) ;
if ( methods [ i ] . getName ( ) . equals ( methodName ) ) { method = methods [ i ] ; break ; <CTX> public Method findOperation ( AxisOperation op , Class ImplClass ) { Method method = null ; String methodName = op . getName ( ) . getLocalPart ( ) ; Method [ ] methods = ImplClass . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { if ( methods [ i ] . getName ( ) . equals ( methodName ) ) { method = methods [ i ] ; break ; } } return method ; }	if ( methods [ i ] . getName ( ) . equals ( methodName ) && methods [ i ] . getParameterTypes ( ) . length == 1 && OMElement . class . getName ( ) . equals ( methods [ i ] . getParameterTypes ( ) [ 0 ] . getName ( ) ) ) { return methods [ i ] ;
mIds = new int [ 1 ] ; mIds [ 0 ] = id ; <CTX> public GetItemOperation ( Session session , OperationContext oc , Mailbox mbox , Requester req , int id , byte type ) throws ServiceException { super ( session , oc , mbox , req , LOAD ) ; mIds = new int [ 1 ] ; mIds [ 0 ] = id ; mType = type ; mPath = null ; }	mIds = new int [ ] { id } ;
File moduleFile = new File ( myDir , modulePath ) . getCanonicalFile ( ) ; moduleFiles . put ( moduleFile , modulePath ) ; } <CTX> public String getModulePathAdjustment ( MavenProject moduleProject ) throws IOException { File module = moduleProject . getFile ( ) ; if ( module == null ) { return null ; } module = module . getCanonicalFile ( ) ; if ( moduleFiles == null ) { moduleFiles = new HashMap ( ) ; List modules = getModules ( ) ; File myFile = getFile ( ) ; if ( myFile != null ) { File myDir = myFile . getCanonicalFile ( ) . getParentFile ( ) ; if ( modules != null ) { for ( Iterator it = modules . iterator ( ) ; it . hasNext ( ) ; ) { String modulePath = ( String ) it . next ( ) ; File moduleFile = new File ( myDir , modulePath ) . getCanonicalFile ( ) ; moduleFiles . put ( moduleFile , modulePath ) ; } } } } return ( String ) moduleFiles . get ( module ) ; }	moduleAdjustments . put ( moduleName , adjustment ) ;
return box ; <CTX> public DataBounds getDataBounds ( ) { DataBounds box = null ; ESRIBoundingBox bounds = new ESRIBoundingBox ( ) ; Iterator sii = spatialIndexes . iterator ( ) ; while ( sii . hasNext ( ) ) { SpatialIndex si = ( SpatialIndex ) sii . next ( ) ; if ( si != null ) { ESRIBoundingBox boundingBox = spatialIndex . getBounds ( ) ; if ( bounds != null ) { bounds . addBounds ( boundingBox ) ; } } } return box ; }	return new DataBounds ( bounds . min . x , bounds . min . y , bounds . max . x , bounds . max . y ) ;
( downloadSource ? branch . downloadSourceSize : branch . downloadSize ) ) ) ; <CTX> void install ( Roster roster , String installDirectory , boolean downloadSource ) { if ( installed != null ) roster . addOperation ( new Roster . Remove ( installed ) ) ; Branch branch = getCompatibleBranch ( ) ; if ( branch . obsolete ) return ; / / branch . satisfyDependencies ( roster , installDirectory , / / downloadSource ) ; if ( installed != null ) { installDirectory = MiscUtilities . getParentOfPath ( installed ) ; } roster . addOperation ( new Roster . Install ( ( downloadSource ? branch . downloadSource : branch . download ) , installDirectory , ( downloadSource ? branch . downloadSourceSize : branch . downloadSize ) ) ) ; }	( downloadSource ? branch . downloadSourceSize : branch . downloadSize ) ) ;
if ( part instanceof IEditorPart ) <CTX> public void partActivated ( IWorkbenchPart part ) { if ( part instanceof IEditorPart ) linkToEditor ( ( IEditorPart ) part ) ; }	if ( part instanceof IEditorPart ) {
super ( project , XML_FILE , getChameleonTypeByFile ( file ) , file ) ; <CTX> public XmlFileImpl ( Project project , VirtualFile file ) { super ( project , XML_FILE , getChameleonTypeByFile ( file ) , file ) ; }	super ( project , getElementType ( file . getFileType ( ) ) , getChameleonTypeByFile ( file ) , file ) ;
Node node = NodeUtils . getNextVariation ( m_currentNode ) ; <CTX> public void cbNextVariation ( ) { Node node = NodeUtils . getNextVariation ( m_currentNode ) ; if ( node != null ) cbGotoNode ( node ) ; }	Node node = NodeUtil . getNextVariation ( m_currentNode ) ;
this ( PORT_RECV , addr , port ) ; <CTX> public UDPCanSocket ( InetAddress addr , int port ) throws IOException { this ( PORT_RECV , addr , port ) ; }	this ( PORT_RECV ) ;
if ( getModel ( ) . isEnabled ( ) ) popupMenu . setVisible ( popup ) ; <CTX> public void setPopupMenuVisible ( boolean popup ) { if ( getModel ( ) . isEnabled ( ) ) popupMenu . setVisible ( popup ) ; }	if ( popup != isPopupMenuVisible ( ) && ( isEnabled ( ) || ! popup ) ) { if ( popup && isShowing ( ) ) { Point loc = menuLocation == null ? getPopupMenuOrigin ( ) : menuLocation ; getPopupMenu ( ) . show ( this , loc . x , loc . y ) ;
this ( hostname , port , secure , 0 , 0 ) ; <CTX> public HTTPConnection ( String hostname , int port , boolean secure ) { this ( hostname , port , secure , 0 , 0 ) ; }	this ( hostname , HTTP_PORT , false , 0 , 0 ) ;
return new LiteralConstraint ( field , extractor , evaluator ) ; <CTX> private FieldConstraint getLiteralConstraint ( final Column column , final String fieldName , final Object fieldValue , final Evaluator evaluator ) { final Class clazz = ( ( ClassObjectType ) column . getObjectType ( ) ) . getClassType ( ) ; final FieldExtractor extractor = new ClassFieldExtractor ( clazz , fieldName ) ; final FieldValue field = new MockField ( fieldValue ) ; return new LiteralConstraint ( field , extractor , evaluator ) ; }	return new LiteralConstraint ( extractor , evaluator , field ) ;
return p == null ? null : new File ( f , p ) ; <CTX> private static File getParentFile ( File f ) { String p = f . getParent ( ) ; return p == null ? null : new File ( f , p ) ; }	return p == null ? null : new File ( p ) ;
void visitBeanDefinition ( BeanDefinition beanDefinition ) throws BeansException ; <CTX> void visitBeanDefinition ( BeanDefinition beanDefinition ) throws BeansException ;	void visitBeanDefinition ( String beanName , BeanDefinition beanDefinition , Object data ) throws BeansException ;
columnDescr . addDescr ( boundVariableDescr ) ; <CTX> public Object end ( final String uri , final String localName ) throws SAXException { final Configuration config = this . xmlPackageReader . endConfiguration ( ) ; final BoundVariableDescr boundVariableDescr = ( BoundVariableDescr ) this . xmlPackageReader . getCurrent ( ) ; final LinkedList parents = this . xmlPackageReader . getParents ( ) ; final ListIterator it = parents . listIterator ( parents . size ( ) ) ; it . previous ( ) ; final ColumnDescr columnDescr = ( ColumnDescr ) it . previous ( ) ; columnDescr . addDescr ( boundVariableDescr ) ; return null ; }	columnDescr . addDescr ( variableDescr ) ;
try { s = lookupQualifiedName ( scopeToSymbol ( scope ) , duple , new ArrayList ( ) , false ) ; } catch ( ASTSemanticException e ) { <CTX> public IASTNode lookupSymbolInContext ( IASTScope scope , ITokenDuple duple ) throws ASTNotImplementedException { ISymbol s = null ; try { s = lookupQualifiedName ( scopeToSymbol ( scope ) , duple , new ArrayList ( ) , false ) ; } catch ( ASTSemanticException e ) { } if ( s == null ) return null ; return s . getASTExtension ( ) . getPrimaryDeclaration ( ) ; }	if ( reference == null ) { try { s = lookupQualifiedName ( scopeToSymbol ( scope ) , duple , new ArrayList ( ) , false ) ; } catch ( ASTSemanticException e ) { } } else { if ( reference instanceof ASTExpression ) { ASTExpression expression = ( ASTExpression ) reference ; if ( expression . getExpressionKind ( ) == IASTExpression . Kind . ID_EXPRESSION ) { try { s = lookupQualifiedName ( scopeToSymbol ( scope ) , duple , new ArrayList ( ) , false ) ; } catch ( ASTSemanticException e 1 ) { } } else { ASTExpression ownerExpression = expression . findOwnerExpressionForIDExpression ( duple ) ; if ( ownerExpression == null ) return null ; if ( ownerExpression . getExpressionKind ( ) . isPostfixMemberReference ( ) ) { try { s = lookupQualifiedName ( getSearchScope ( ownerExpression . getExpressionKind ( ) , ownerExpression . getLHSExpression ( ) , scopeToSymbol ( scope ) ) , duple , new ArrayList ( ) , false ) ; } catch ( ASTSemanticException e ) { return null ; } } else { try { s = lookupQualifiedName ( scopeToSymbol ( scope ) , duple , new ArrayList ( ) , false ) ; } catch ( ASTSemanticException e 1 ) { } } } }
nf . addChildToBack ( pn , function ( ts , false ) ) ; <CTX> private Object parseFunctionBody ( TokenStream ts ) throws IOException { int oldflags = ts . flags ; ts . flags &= ~ ( TokenStream . TSF_RETURN_EXPR | TokenStream . TSF_RETURN_VOID ) ; ts . flags |= TokenStream . TSF_FUNCTION ; Object pn = nf . createBlock ( ts . getLineno ( ) ) ; try { int tt ; while ( ( tt = ts . peekToken ( ) ) > ts . EOF && tt != ts . RC ) { if ( tt == TokenStream . FUNCTION ) { ts . getToken ( ) ; nf . addChildToBack ( pn , function ( ts , false ) ) ; } else { nf . addChildToBack ( pn , statement ( ts ) ) ; } } } catch ( JavaScriptException e ) { this . ok = false ; } finally { / / also in finally block : / / flushNewLines , clearPushback . ts . flags = oldflags ; } return pn ; }	n = function ( ts , FunctionNode . FUNCTION_STATEMENT ) ;
if ( subscription . getReceivePostsByEmail ( ) ) { if ( subscriber . getEmail ( ) == null ) { subscription . setReceivePostsByEmail ( false ) ; } else { <CTX> private void notifyEmailSubscribers ( ConversationMessage conversationMessage ) { Set < Person > readers = conversationMessage . getConversationThread ( ) . getForum ( ) . getReadersGroup ( ) . getElements ( ) ; Set < String > emailAddressesToSendMessage = new HashSet < String > ( ) ; Set < ForumSubscription > subscriptionsToRemove = new HashSet < ForumSubscription > ( ) ; for ( ForumSubscription subscription : conversationMessage . getConversationThread ( ) . getForum ( ) . getForumSubscriptions ( ) ) { Person subscriber = subscription . getPerson ( ) ; if ( ! readers . contains ( subscriber ) ) { subscriptionsToRemove . add ( subscription ) ; } if ( subscription . getReceivePostsByEmail ( ) ) { if ( subscriber . getEmail ( ) == null ) { subscription . setReceivePostsByEmail ( false ) ; } else { emailAddressesToSendMessage . add ( subscriber . getEmail ( ) ) ; } } } for ( ForumSubscription subscriptionToRemove : subscriptionsToRemove ) { conversationMessage . getConversationThread ( ) . getForum ( ) . removeForumSubscriptions ( subscriptionToRemove ) ; subscriptionToRemove . delete ( ) ; } if ( ! emailAddressesToSendMessage . isEmpty ( ) ) { String emailSubject = getEmailFormattedSubject ( conversationMessage . getConversationThread ( ) ) ; String emailBody = getEmailFormattedBody ( conversationMessage ) ; EmailSender . send ( getEmailFrom ( ) , getEmailFromAddress ( ) , new ArrayList < String > ( ) , new ArrayList < String > ( ) , emailAddressesToSendMessage , emailSubject , emailBody ) ; } }	emailAddressesToSendMessage . add ( subscriber . getEmail ( ) ) ; } } }
. findPostingRuleByEventTypeAndDate ( getEventType ( ) , whenRegistered ) ; <CTX> protected PostingRule getPostingRule ( DateTime whenRegistered ) { return getAdministrativeOffice ( ) . getServiceAgreementTemplate ( ) . findPostingRuleByEventTypeAndDate ( getEventType ( ) , whenRegistered ) ; }	. findPostingRuleByEventTypeAndDate ( getEventType ( ) , getWhenOccured ( ) ) ;
if ( Arrays . equals ( elementQualifiedName , finalDuple . toQualifiedName ( ) ) ) return contextNode ; <CTX> protected IASTNode lookupNode ( ITokenDuple finalDuple ) { if ( contextNode == null ) return null ; if ( contextNode instanceof IASTDeclaration ) { if ( contextNode instanceof IASTOffsetableNamedElement ) { if ( ( ( IASTOffsetableNamedElement ) contextNode ) . getName ( ) . equals ( finalDuple . toString ( ) ) ) return contextNode ; } if ( contextNode instanceof IASTQualifiedNameElement ) { String [ ] elementQualifiedName = ( ( IASTQualifiedNameElement ) contextNode ) . getFullyQualifiedName ( ) ; if ( Arrays . equals ( elementQualifiedName , finalDuple . toQualifiedName ( ) ) ) return contextNode ; } try { if ( ourKind == IASTCompletionNode . CompletionKind . NEW_TYPE_REFERENCE ) { if ( contextNode instanceof IASTVariable ) { IASTInitializerClause initializer = ( ( IASTVariable ) contextNode ) . getInitializerClause ( ) ; if ( initializer != null ) { IASTExpression ownerExpression = initializer . findExpressionForDuple ( finalDuple ) ; return astFactory . lookupSymbolInContext ( ourScope , finalDuple , ownerExpression ) ; } } } return astFactory . lookupSymbolInContext ( ourScope , finalDuple , null ) ; } catch ( ASTNotImplementedException e ) { return null ; } } else if ( contextNode instanceof IASTExpression ) { try { return astFactory . lookupSymbolInContext ( ourScope , finalDuple , contextNode ) ; } catch ( ASTNotImplementedException e ) { return null ; } } return null ; }	if ( Arrays . equals ( elementQualifiedName , finalDuple . toQualifiedName ( ) ) ) { IASTNode declNode = null ; if ( contextNode instanceof ISymbolOwner ) { ISymbolOwner owner = ( ISymbolOwner ) contextNode ; if ( owner . getSymbol ( ) != null && owner . getSymbol ( ) . getASTExtension ( ) != null ) { declNode = owner . getSymbol ( ) . getASTExtension ( ) . getPrimaryDeclaration ( ) ; } } return ( declNode != null ) ? declNode : contextNode ; }
obj . addAsPrototype ( cx , scope , sealed ) ; <CTX> public static void init ( Context cx , Scriptable scope , boolean sealed ) { NativeArray obj = new NativeArray ( ) ; obj . addAsPrototype ( cx , scope , sealed ) ; }	obj . prototypeFlag = true ; obj . addAsPrototype ( MAX_PROTOTYPE_ID , cx , scope , sealed ) ;
EventHandlingStrategy eventHandlingStrategy , IoFilterChainBuilder filterChainBuilder ) { super ( networkingOptions , filterChainBuilder ) ; <CTX> public InitiatorIoHandler ( Session quickfixSession , NetworkingOptions networkingOptions , EventHandlingStrategy eventHandlingStrategy , IoFilterChainBuilder filterChainBuilder ) { super ( networkingOptions , filterChainBuilder ) ; this . quickfixSession = quickfixSession ; this . eventHandlingStrategy = eventHandlingStrategy ; }	EventHandlingStrategy eventHandlingStrategy ) { super ( networkingOptions ) ;
int lastItem = size ( ) ; <CTX> public Object removeLRU ( ) { int lastItem = size ( ) ; Object key = bubbleList . remove ( lastItem ) ; ValuePositionPair pair = removePair ( key ) ; return key ; }	int lastItem = size ( ) - 1 ;
idMap . put ( name , elements [ j ] . getAttribute ( ATTR_ID ) ) ; <CTX> private void initializeFormatters ( ) { idMap = new HashMap ( ) ; idMap . put ( NONE , null ) ; IExtensionPoint point = Platform . getExtensionRegistry ( ) . getExtensionPoint ( CCorePlugin . PLUGIN_ID , CCorePlugin . FORMATTER_EXTPOINT_ID ) ; if ( point != null ) { IExtension [ ] exts = point . getExtensions ( ) ; for ( int i = 0 ; i < exts . length ; i ++ ) { IConfigurationElement [ ] elements = exts [ i ] . getConfigurationElements ( ) ; for ( int j = 0 ; j < elements . length ; ++ j ) { String name = elements [ j ] . getAttribute ( ATTR_NAME ) ; idMap . put ( name , elements [ j ] . getAttribute ( ATTR_ID ) ) ; } } } }	String id = elements [ j ] . getAttribute ( ATTR_ID ) ; idMap . put ( name , id ) ;
closeClientSocket ( ) ; <CTX> public void run ( ) { try { synchronized ( mutex ) { if ( client_sock == null ) return ; in = client_sock . getInputStream ( ) ; } while ( ( in . read ( ) ) != - 1 ) { } } catch ( IOException io_ex 1 ) { } finally { closeClientSocket ( ) ; synchronized ( clients ) { clients . remove ( this ) ; } } }	Socket sock = client_sock ; if ( sock != null && ! sock . isClosed ( ) ) closeClientSocket ( ) ;
return super . getRowCount ( ) - ntail_+ irow ; <CTX> private long translateRow ( long irow ) { return super . getRowCount ( ) - ntail_+ irow ; }	return super . getRowCount ( ) - getRowCount ( ) + irow ;
assertEquals ( iter . next ( ) , dest [ i ] , 0 f ) ; <CTX> public void testToJustBigEnoughByteArray ( ) { ByteList list = makeFullByteList ( ) ; byte [ ] dest = new byte [ list . size ( ) ] ; assertSame ( dest , list . toArray ( dest ) ) ; int i = 0 ; for ( ByteIterator iter = list . iterator ( ) ; iter . hasNext ( ) ; i ++ ) { assertEquals ( iter . next ( ) , dest [ i ] , 0 f ) ; } }	assertEquals ( iter . next ( ) , dest [ i ] ) ;
req . setRequest ( service . retrieveScheduledSIEvents ( SIService . FROM_CACHE_OR_STREAM , null , req , null , time , time ) ) ; <CTX> public javax . tv . service . SIRequest retrieveFutureProgramEvent ( java . util . Date time , javax . tv . service . SIRequestor requestor ) throws javax . tv . service . SIException { javax . tv . service . OrgDvbSiRequestAdapter req = new javax . tv . service . OrgDvbSiRequestAdapter ( requestor ) ; req . setRequest ( service . retrieveScheduledSIEvents ( SIService . FROM_CACHE_OR_STREAM , null , req , null , time , time ) ) ; return req ; }	try { req . setRequest ( service . retrieveScheduledSIEvents ( SIService . FROM_CACHE_OR_STREAM , null , req , null , time , time ) ) ; } catch ( org . dvb . si . SIIllegalArgumentException ex ) { ex . printStackTrace ( ) ; }
job . setProperty ( ProgressManager . PROPERTY_IN_DIALOG , new Boolean ( true ) ) ; return super . open ( ) ; <CTX> public int open ( ) { job . setProperty ( ProgressManager . PROPERTY_IN_DIALOG , new Boolean ( true ) ) ; return super . open ( ) ; }	if ( job . getState ( ) == Job . RUNNING ) { job . setProperty ( ProgressManager . PROPERTY_IN_DIALOG , new Boolean ( true ) ) ; return super . open ( ) ; } addListenerToOpen ( ) ; return CANCEL ;
if ( hasTargetBuilder ( project ) ) { <CTX> public boolean visit ( IResourceDelta delta ) { if ( delta == null ) { return false ; } IResource resource = delta . getResource ( ) ; if ( resource . getType ( ) == IResource . PROJECT ) { IProject project = ( IProject ) resource ; int flags = delta . getFlags ( ) ; int deltaKind = delta . getKind ( ) ; if ( deltaKind == IResourceDelta . ADDED ) { if ( hasTargetBuilder ( project ) ) { fProjects . add ( project ) ; notifyListeners ( new MakeTargetEvent ( MakeTargetManager . this , MakeTargetEvent . PROJECT_ADDED , project ) ) ; } } else if ( deltaKind == IResourceDelta . REMOVED ) { if ( fProjects . contains ( project ) ) { deleteTargets ( project ) ; fProjects . remove ( project ) ; notifyListeners ( new MakeTargetEvent ( MakeTargetManager . this , MakeTargetEvent . PROJECT_REMOVED , project ) ) ; } } else if ( deltaKind == IResourceDelta . CHANGED ) { if ( 0 != ( flags & IResourceDelta . DESCRIPTION ) ) { if ( fProjects . contains ( project ) && ! hasTargetBuilder ( project ) ) { fProjects . remove ( project ) ; projectMap . remove ( project ) ; notifyListeners ( new MakeTargetEvent ( MakeTargetManager . this , MakeTargetEvent . PROJECT_REMOVED , project ) ) ; } else if ( ! fProjects . contains ( project ) && hasTargetBuilder ( project ) ) { fProjects . add ( project ) ; notifyListeners ( new MakeTargetEvent ( MakeTargetManager . this , MakeTargetEvent . PROJECT_ADDED , project ) ) ; } } if ( 0 != ( flags & IResourceDelta . OPEN ) ) { if ( ! project . isOpen ( ) && fProjects . contains ( project ) ) { fProjects . remove ( project ) ; projectMap . remove ( project ) ; notifyListeners ( new MakeTargetEvent ( MakeTargetManager . this , MakeTargetEvent . PROJECT_REMOVED , project ) ) ; } else if ( project . isOpen ( ) && hasTargetBuilder ( project ) && ! fProjects . contains ( project ) ) { fProjects . add ( project ) ; notifyListeners ( new MakeTargetEvent ( MakeTargetManager . this , MakeTargetEvent . PROJECT_ADDED , project ) ) ; } } } return false ; } return resource instanceof IWorkspaceRoot ; }	if ( hasTargetBuilder ( project ) && ! fProjects . contains ( project ) ) {
return eDynamicGet ( eFeature , resolve ) ; <CTX> public Object eGet ( EStructuralFeature eFeature , boolean resolve ) { switch ( eDerivedStructuralFeatureID ( eFeature ) ) { case ComponentPackage . CURVE_FITTING__ LINE_ATTRIBUTES : return getLineAttributes ( ) ; case ComponentPackage . CURVE_FITTING__ LABEL : return getLabel ( ) ; case ComponentPackage . CURVE_FITTING__ LABEL_ANCHOR : return getLabelAnchor ( ) ; } return eDynamicGet ( eFeature , resolve ) ; }	return super . eGet ( featureID , resolve , coreType ) ;
m_driverManager . exportResources ( this , m_context , exportFile , exportPaths , includeSystem , excludeUnchanged ) ; <CTX> public void exportResources ( String exportFile , String [ ] exportPaths , boolean includeSystem , boolean excludeUnchanged ) throws CmsException { / / export the resources m_driverManager . exportResources ( this , m_context , exportFile , exportPaths , includeSystem , excludeUnchanged ) ; }	m_driverManager . exportResources ( this , m_context , exportFile , exportPaths ) ;
if ( ( method . getNoex ( ) & noex ) == 0 ) { <CTX> public int execute ( Object key , Object value , Object arg ) { / / cast args String id = ( String ) key ; ICallable method = ( ICallable ) value ; RubyArray ary = ( RubyArray ) arg ; if ( ( method . getNoex ( ) & noex ) == 0 ) { RubyString name = RubyString . newString ( getRuntime ( ) , id ) ; if ( ! ary . includes ( name ) ) { if ( method == null ) { ary . append ( getRuntime ( ) . getNil ( ) ) ; } ary . append ( name ) ; } } else if ( method instanceof EvaluateMethod && ( ( EvaluateMethod ) method ) . getNode ( ) instanceof ZSuperNode ) { ary . append ( getRuntime ( ) . getNil ( ) ) ; ary . append ( RubyString . newString ( getRuntime ( ) , id ) ) ; } return RubyMapMethod . CONTINUE ; }	if ( method . getVisibility ( ) == noex ) {
getModelAdaptHelper ( ) . markDirty ( true ) ; <CTX> public void insertRow ( int rowNumber , int parentRowNumber ) throws SemanticException { transStar ( TRANS_LABEL_INSERT_ROW ) ; Assert . isLegal ( rowNumber != 0 ) ; int realRowNumber = rowNumber > 0 ? parentRowNumber + rowNumber : parentRowNumber + rowNumber + 1 ; int shiftPos = rowNumber > 0 ? rowNumber : rowNumber + 1 ; RowHandle row = ( RowHandle ) getRow ( parentRowNumber ) ; RowHandleAdapter adapt = HandleAdapterFactory . getInstance ( ) . getRowHandleAdapter ( row ) ; RowHandle copy = ( RowHandle ) adapt . copy ( ) ; TableHandleAdapter . RowUIInfomation rowInfo = getRowInfo ( row ) ; List rowList = rowInfo . getAllChildren ( ) ; int rowSize = rowList . size ( ) ; for ( int i = 0 ; i < rowSize ; i ++ ) { CellHandle parentCell = ( CellHandle ) rowList . get ( i ) ; CellHandle cell = getCellHandleCopy ( parentCell ) ; copy . getSlot ( RowHandle . CONTENT_SLOT ) . add ( cell ) ; } SlotHandle parentHandle = row . getContainerSlotHandle ( ) ; parentHandle . add ( ( copy ) ) ; int pos = parentHandle . findPosn ( row ) ; parentHandle . shift ( copy , pos + shiftPos ) ; RowHandleAdapter copyAdapt = HandleAdapterFactory . getInstance ( ) . getRowHandleAdapter ( copy ) ; List copyChildren = copyAdapt . getChildren ( ) ; getModelAdaptHelper ( ) . markDirty ( true ) ; TableHandleAdapter . RowUIInfomation info = getRowInfo ( copy ) ; List list = info . getAllChildren ( ) ; List temp = new ArrayList ( ) ; int size = list . size ( ) ; List hasAdjust = new ArrayList ( ) ; for ( int i = 0 ; i < size ; i ++ ) { Object fillCell = list . get ( i ) ; CellHandleAdapter cellAdapt = HandleAdapterFactory . getInstance ( ) . getCellHandleAdapter ( fillCell ) ; if ( cellAdapt . getRowNumber ( ) != realRowNumber ) { if ( ! hasAdjust . contains ( fillCell ) ) { cellAdapt . setRowSpan ( cellAdapt . getRowSpan ( ) + 1 ) ; hasAdjust . add ( fillCell ) ; } temp . add ( new Integer ( i ) ) ; } } int copyRowSize = copyChildren . size ( ) ; for ( int i = 0 ; i < copyRowSize ; i ++ ) { if ( temp . contains ( new Integer ( i ) ) ) { ( ( CellHandle ) copyChildren . get ( i ) ) . drop ( ) ; } } transEnd ( ) ; }	if ( getModelAdaptHelper ( ) != null ) { getModelAdaptHelper ( ) . markDirty ( true ) ; }
} else if ( parent instanceof ITaskQuery ) { ITaskQuery t = ( ITaskQuery ) parent ; <CTX> public boolean hasChildren ( Object parent ) { if ( parent instanceof ITaskCategory ) { ITaskCategory cat = ( ITaskCategory ) parent ; return cat . getChildren ( ) != null && cat . getChildren ( ) . size ( ) > 0 ; } else if ( parent instanceof Task ) { Task t = ( Task ) parent ; return t . getChildren ( ) != null && t . getChildren ( ) . size ( ) > 0 ; } else if ( parent instanceof ITaskQuery ) { ITaskQuery t = ( ITaskQuery ) parent ; return t . getHits ( ) != null && t . getHits ( ) . size ( ) > 0 ; } return false ; }	} else if ( parent instanceof IRepositoryQuery ) { IRepositoryQuery t = ( IRepositoryQuery ) parent ;
if ( data instanceof IPropertySheetEntry ) entries . add ( data ) ; <CTX> public ISelection getSelection ( ) { if ( tree . getSelectionCount ( ) == 0 ) return StructuredSelection . EMPTY ; TreeItem [ ] sel = tree . getSelection ( ) ; List entries = new ArrayList ( sel . length ) ; for ( int i = 0 ; i < sel . length ; i ++ ) { TreeItem ti = sel [ i ] ; Object data = ti . getData ( ) ; if ( data instanceof IPropertySheetEntry ) entries . add ( data ) ; } return new StructuredSelection ( entries ) ; }	if ( data instanceof IPropertySheetEntry ) { entries . add ( data ) ; }
return bigNorm ( getRuntime ( ) , value . and ( ( ( RubyBignum ) other ) . value ) ) ; <CTX> public RubyNumeric op_and ( RubyNumeric other ) { if ( other instanceof RubyBignum ) { return bigNorm ( getRuntime ( ) , value . and ( ( ( RubyBignum ) other ) . value ) ) ; } return bigNorm ( getRuntime ( ) , getValue ( ) . and ( newBignum ( getRuntime ( ) , other . getLongValue ( ) ) . getValue ( ) ) ) ; }	return bigNorm ( getRuntime ( ) , value . and ( ( ( RubyBignum ) other ) . value ) ) ; } else if ( other instanceof RubyNumeric ) { return bigNorm ( getRuntime ( ) , getValue ( ) . and ( newBignum ( getRuntime ( ) , ( ( RubyNumeric ) other ) . getLongValue ( ) ) . getValue ( ) ) ) ;
File newFile = new File ( source . getParentFile ( ) , dialog . getValue ( ) ) ; <CTX> private WorkspaceModifyOperation saveNewFileOperation ( ) { return new WorkspaceModifyOperation ( ) { public void execute ( final IProgressMonitor monitor ) throws CoreException { InputDialog dialog = new InputDialog ( clientFrame . getShell ( ) , FILE_PROMPTER_TITLE , FILE_PROMPTER_MESSAGE , source . getName ( ) , null ) ; dialog . setBlockOnOpen ( true ) ; dialog . open ( ) ; if ( dialog . getReturnCode ( ) == dialog . OK ) { File newFile = new File ( source . getParentFile ( ) , dialog . getValue ( ) ) ; if ( saveFile ( newFile ) ) { IFile newResource = resource . getWorkspace ( ) . getRoot ( ) . getFileForLocation ( new Path ( newFile . getAbsolutePath ( ) ) ) ; if ( newResource != null ) { sourceChanged ( newResource ) ; newResource . refreshLocal ( IResource . DEPTH_ZERO , monitor ) ; } } else { displayErrorDialog ( SAVE_ERROR_TITLE , SAVE_ERROR_MESSAGE + newFile . getName ( ) ) ; return ; } } } } ; }	String projectName = newPath . segment ( 0 ) ; newPath = newPath . removeFirstSegments ( 1 ) ; IProject project = resource . getWorkspace ( ) . getRoot ( ) . getProject ( projectName ) ; newPath = project . getLocation ( ) . append ( newPath ) ; File newFile = newPath . toFile ( ) ;
getExtents ( ) . width - ( margin . left + border . left + padding . left ) - ( margin . right + border . right + padding . right ) , getExtents ( ) . height - ( margin . top + border . top + padding . top ) - ( margin . bottom + border . bottom + padding . bottom ) ) ; <CTX> public void shrinkExtents ( Box block ) { extents_stack . push ( getExtents ( ) ) ; Border border = block . border ; Border padding = block . padding ; Border margin = block . margin ; Rectangle rect = new Rectangle ( 0 , 0 , getExtents ( ) . width - ( margin . left + border . left + padding . left ) - ( margin . right + border . right + padding . right ) , getExtents ( ) . height - ( margin . top + border . top + padding . top ) - ( margin . bottom + border . bottom + padding . bottom ) ) ; setExtents ( rect ) ; }	getExtents ( ) . width - block . totalHorizontalPadding ( ) , getExtents ( ) . height - block . totalVerticalPadding ( ) ) ;
return RubyBoolean . newBoolean ( getRuntime ( ) , Modifier . isFinal ( field . getModifiers ( ) ) ) ; <CTX> public RubyBoolean final_p ( ) { return RubyBoolean . newBoolean ( getRuntime ( ) , Modifier . isFinal ( field . getModifiers ( ) ) ) ; }	return getRuntime ( ) . newBoolean ( Modifier . isFinal ( field . getModifiers ( ) ) ) ;
if ( ! problem . getRecovering ( ) && ! problem . getIllness ( ) . getRecoveryTreatment ( ) . getSelfAdminister ( ) ) { <CTX> public boolean hasWaitingPatients ( ) { if ( ! patients . isEmpty ( ) ) { Iterator iter = patients . iterator ( ) ; while ( iter . hasNext ( ) ) { HealthProblem problem = ( HealthProblem ) iter . next ( ) ; if ( ! problem . getRecovering ( ) && ! problem . getIllness ( ) . getRecoveryTreatment ( ) . getSelfAdminister ( ) ) { return true ; } } } return false ; }	if ( problem . getAwaitingTreatment ( ) ) {
List < BulkEntryAccountFeeActionView > bulkEntryCustomerFeeViews ) { <CTX> public static BulkEntryView buildBulkEntry ( List < CustomerBO > allCustomers , CustomerView parentCustomerView , Date transactionDate , List < BulkEntryInstallmentView > bulkEntryLoanViews , List < BulkEntryInstallmentView > bulkEntryCustomerViews , List < BulkEntryAccountFeeActionView > bulkEntryLoanFeeViews , List < BulkEntryAccountFeeActionView > bulkEntryCustomerFeeViews ) { CustomerBO parentCustomer = getCustomer ( parentCustomerView . getCustomerId ( ) , allCustomers ) ; return buildBulkEntry ( allCustomers , parentCustomer , parentCustomerView , transactionDate , bulkEntryLoanViews , bulkEntryCustomerViews , bulkEntryLoanFeeViews , bulkEntryCustomerFeeViews ) ; }	List < BulkEntryAccountFeeActionView > bulkEntryCustomerFeeViews , List < BulkEntryClientAttendanceView > bulkEntryClientAttendanceViews ) {
myModifiedPropertyNames = new HashSet ( ) ; <CTX> public RadComponent ( final Module module , final Class aClass , final String id ) { LOG . assertTrue ( module != null ) ; LOG . assertTrue ( aClass != null ) ; LOG . assertTrue ( id != null ) ; myModule = module ; myClass = aClass ; myId = id ; myChangeSupport = new PropertyChangeSupport ( this ) ; myConstraints = new GridConstraints ( ) ; myModifiedPropertyNames = new HashSet ( ) ; try { final Constructor constructor = myClass . getConstructor ( new Class [ 0 ] ) ; constructor . setAccessible ( true ) ; myDelegee = ( JComponent ) constructor . newInstance ( ArrayUtil . EMPTY_OBJECT_ARRAY ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } myDelegee . putClientProperty ( CLIENT_PROP_RAD_COMPONENT , this ) ; }	myModifiedPropertyNames = new HashSet < String > ( ) ;
return_cfb ; <CTX> public int getStackFrame ( ) { return_cfb ; }	return_currentFrameBottom ;
expandToDefaultLevel ( ) ; <CTX> public void handleSelectionChanged ( ISelection selection ) { if ( this . selection != null && this . selection . equals ( selection ) ) return ; this . selection = selection ; deRegisterListeners ( ) ; list = getModelList ( selection ) ; GroupElementHandle handle = DEUtil . getMultiSelectionHandle ( list ) ; if ( handle != null && ! handle . isSameType ( ) ) { viewer . setInput ( null ) ; return ; } viewer . setInput ( handle ) ; setTitleDisplayName ( handle ) ; registerListeners ( ) ; expandToDefaultLevel ( ) ; }	Object element = handle . getElements ( ) . get ( 0 ) ; if ( element instanceof DesignElementHandle ) { IMemento memento = viewerMemento . getChild ( PropertyMementoUtil . getElementType ( ( DesignElementHandle ) element ) ) ; if ( memento == null ) { expandToDefaultLevel ( ) ; if ( viewer . getTree ( ) . getItemCount ( ) > 0 ) { ViewsMemento elementMemento = ( ViewsMemento ) viewerMemento . createChild ( PropertyMementoUtil . getElementType ( ( DesignElementHandle ) element ) , MementoElement . Type_Element ) ; elementMemento . getMementoElement ( ) . setValue ( new Integer ( 0 ) ) ; } } else if ( memento instanceof ViewsMemento ) { expandToDefaultLevel ( ) ; expandTreeFromMemento ( ( ViewsMemento ) memento ) ; } }
return getLookAndFeelDefaults ( ) . getUI ( target ) ; <CTX> public static ComponentUI getUI ( JComponent target ) { return getLookAndFeelDefaults ( ) . getUI ( target ) ; }	ComponentUI ui = null ; if ( userUIDefaults != null && userUIDefaults . get ( target . getUIClassID ( ) ) != null ) ui = userUIDefaults . getUI ( target ) ; if ( ui == null ) ui = currentUIDefaults . getUI ( target ) ; return ui ;
RosterEntry ( String user , String name , XMPPConnection connection ) { <CTX> RosterEntry ( String user , String name , XMPPConnection connection ) { this . user = user ; this . name = name ; this . connection = connection ; }	RosterEntry ( String user , String name , RosterPacket . ItemType type , XMPPConnection connection ) {
return null ; <CTX> private String getColumnName ( String expression ) { for ( Iterator iter = columnList . iterator ( ) ; iter . hasNext ( ) ; ) { ResultSetColumnHandle cachedColumn = ( ResultSetColumnHandle ) iter . next ( ) ; if ( DEUtil . getExpression ( cachedColumn ) . equals ( expression ) ) { return cachedColumn . getColumnName ( ) ; } } return null ; }	return expression ;
if ( query != null ) { AbstractRepositoryConnector connector = TasksUiPlugin . getRepositoryManager ( ) . getRepositoryConnector ( query . getRepositoryKind ( ) ) ; if ( connector != null ) connector . synchronize ( query , new JobChangeAdapter ( ) { public void done ( IJobChangeEvent event ) { checkSyncResult ( event , query ) ; } } ) ; } else if ( TaskListView . getFromActivePerspective ( ) != null ) { <CTX> public void run ( IAction action ) { if ( query != null ) { AbstractRepositoryConnector connector = TasksUiPlugin . getRepositoryManager ( ) . getRepositoryConnector ( query . getRepositoryKind ( ) ) ; if ( connector != null ) connector . synchronize ( query , new JobChangeAdapter ( ) { public void done ( IJobChangeEvent event ) { checkSyncResult ( event , query ) ; } } ) ; } else if ( TaskListView . getFromActivePerspective ( ) != null ) { ISelection selection = TaskListView . getFromActivePerspective ( ) . getViewer ( ) . getSelection ( ) ; for ( Object obj : ( ( IStructuredSelection ) selection ) . toList ( ) ) { if ( obj instanceof AbstractRepositoryQuery ) { final AbstractRepositoryQuery repositoryQuery = ( AbstractRepositoryQuery ) obj ; AbstractRepositoryConnector client = TasksUiPlugin . getRepositoryManager ( ) . getRepositoryConnector ( repositoryQuery . getRepositoryKind ( ) ) ; if ( client != null ) client . synchronize ( repositoryQuery , new JobChangeAdapter ( ) { public void done ( IJobChangeEvent event ) { checkSyncResult ( event , repositoryQuery ) ; } } ) ; } else if ( obj instanceof TaskCategory ) { TaskCategory cat = ( TaskCategory ) obj ; for ( ITask task : cat . getChildren ( ) ) { if ( task instanceof AbstractRepositoryTask ) { AbstractRepositoryConnector client = TasksUiPlugin . getRepositoryManager ( ) . getRepositoryConnector ( ( ( AbstractRepositoryTask ) task ) . getRepositoryKind ( ) ) ; if ( client != null ) client . forceRefresh ( ( AbstractRepositoryTask ) task ) ; } } } else if ( obj instanceof AbstractRepositoryTask ) { AbstractRepositoryTask bugTask = ( AbstractRepositoryTask ) obj ; AbstractRepositoryConnector client = TasksUiPlugin . getRepositoryManager ( ) . getRepositoryConnector ( bugTask . getRepositoryKind ( ) ) ; if ( client != null ) client . forceRefresh ( bugTask ) ; } else if ( obj instanceof AbstractQueryHit ) { AbstractQueryHit hit = ( AbstractQueryHit ) obj ; if ( hit . getOrCreateCorrespondingTask ( ) != null ) { AbstractRepositoryConnector client = TasksUiPlugin . getRepositoryManager ( ) . getRepositoryConnector ( hit . getCorrespondingTask ( ) . getRepositoryKind ( ) ) ; if ( client != null ) client . forceRefresh ( hit . getCorrespondingTask ( ) ) ; } } } } if ( TaskListView . getFromActivePerspective ( ) != null ) { TaskListView . getFromActivePerspective ( ) . getViewer ( ) . refresh ( ) ; } }	if ( TaskListView . getFromActivePerspective ( ) != null ) {
stream . flush ( ) ; <CTX> public void flushBuffer ( ) throws IOException { stream . flush ( ) ; }	if ( stream != null ) { stream . flush ( ) ; }
Versioning versioning = new Versioning ( ) ; versioning . setSnapshot ( snapshot ) ; <CTX> public void transformForDeployment ( Artifact artifact , ArtifactRepository remoteRepository , ArtifactRepository localRepository ) throws ArtifactMetadataRetrievalException { if ( artifact . isSnapshot ( ) ) { Snapshot snapshot = resolveLatestSnapshotVersion ( artifact , localRepository , remoteRepository ) ; snapshot . setTimestamp ( getDeploymentTimestamp ( ) ) ; snapshot . setBuildNumber ( snapshot . getBuildNumber ( ) + 1 ) ; / / TODO : Better way to create this - should have to construct Versioning Versioning versioning = new Versioning ( ) ; versioning . setSnapshot ( snapshot ) ; ArtifactRepositoryMetadata metadata = new ArtifactRepositoryMetadata ( artifact , versioning ) ; artifact . setResolvedVersion ( constructVersion ( metadata ) ) ; artifact . addMetadata ( metadata ) ; } }	Snapshot snapshot = new Snapshot ( ) ; snapshot . setTimestamp ( getDeploymentTimestamp ( ) ) ; snapshot . setBuildNumber ( buildNumber + 1 ) ;
setDirty ( true ) ; <CTX> public Option ( ITool parent , String Id , String name , Option option ) { this . tool = parent ; superClass = option . superClass ; if ( superClass != null ) { superClassId = option . superClass . getId ( ) ; } setId ( Id ) ; setName ( name ) ; isExtensionOption = false ; / / Copy the remaining attributes if ( option . unusedChildren != null ) { unusedChildren = new String ( option . unusedChildren ) ; } if ( option . isAbstract != null ) { isAbstract = new Boolean ( option . isAbstract . booleanValue ( ) ) ; } if ( option . command != null ) { command = new String ( option . command ) ; } if ( option . commandFalse != null ) { commandFalse = new String ( option . commandFalse ) ; } if ( option . categoryId != null ) { categoryId = new String ( option . categoryId ) ; } if ( option . builtIns != null ) { builtIns = new ArrayList ( option . builtIns ) ; } if ( option . browseType != null ) { browseType = new Integer ( option . browseType . intValue ( ) ) ; } if ( option . resourceFilter != null ) { resourceFilter = new Integer ( option . resourceFilter . intValue ( ) ) ; } if ( option . enumList != null ) { enumList = new ArrayList ( option . enumList ) ; enumCommands = new HashMap ( option . enumCommands ) ; enumNames = new HashMap ( option . enumNames ) ; } if ( option . valueType != null ) { valueType = new Integer ( option . valueType . intValue ( ) ) ; switch ( valueType . intValue ( ) ) { case BOOLEAN : if ( option . value != null ) { value = new Boolean ( ( ( Boolean ) option . value ) . booleanValue ( ) ) ; } if ( option . defaultValue != null ) { defaultValue = new Boolean ( ( ( Boolean ) option . defaultValue ) . booleanValue ( ) ) ; } break ; case STRING : case ENUMERATED : if ( option . value != null ) { value = new String ( ( String ) option . value ) ; } if ( option . defaultValue != null ) { defaultValue = new String ( ( String ) option . defaultValue ) ; } break ; case STRING_LIST : case INCLUDE_PATH : case PREPROCESSOR_SYMBOLS : case LIBRARIES : case OBJECTS : if ( option . value != null ) { value = new ArrayList ( ( ArrayList ) option . value ) ; } if ( option . defaultValue != null ) { defaultValue = new ArrayList ( ( ArrayList ) option . defaultValue ) ; } break ; } } category = option . category ; setDirty ( true ) ; }	loadFromManifest ( element ) ; ManagedBuildManager . addExtensionOption ( this ) ;
w . hide ( ) ; <CTX> public void windowClosing ( WindowEvent winEvent ) { Window w = winEvent . getWindow ( ) ; w . hide ( ) ; try { w . dispose ( ) ; } catch ( IllegalStateException e ) { } if (_doExit ) { System . exit ( 0 ) ; } }	w . setVisible ( false ) ;
saveJButtonActionPerformed ( evt ) ; } <CTX> public void actionPerformed ( java . awt . event . ActionEvent evt ) { saveJButtonActionPerformed ( evt ) ; }	reloadJButtonActionPerformed ( evt ) ; }
FunctionSource ( SourceInfo sourceInfo , int firstLine , String name ) { <CTX> FunctionSource ( SourceInfo sourceInfo , int firstLine , String name ) { if ( name == null ) throw new IllegalArgumentException ( ) ; this . sourceInfo = sourceInfo ; this . firstLine = firstLine ; this . name = name ; }	private FunctionSource ( SourceInfo sourceInfo , int firstLine , String name ) {
ThreadContext context = runtime . getCurrentContext ( ) ; <CTX> public IRubyObject execute ( IRubyObject self , IRubyObject [ ] args ) { ThreadContext context = runtime . getCurrentContext ( ) ; Block block = context . getBlockStack ( ) . getCurrent ( ) ; Visibility savedVisibility = block . getVisibility ( ) ; block . setVisibility ( Visibility . PUBLIC ) ; try { IRubyObject valueInYield = args [ 0 ] ; IRubyObject selfInYield = args [ 0 ] ; return context . yield ( valueInYield , selfInYield , context . getRubyClass ( ) , false , false ) ; } catch ( BreakJump e ) { IRubyObject breakValue = e . getBreakValue ( ) ; return breakValue == null ? runtime . getNil ( ) : breakValue ; } finally { block . setVisibility ( savedVisibility ) ; } }	ThreadContext context = getRuntime ( ) . getCurrentContext ( ) ;
deselect ( getControl ( currentColumn , currentRow ) ) ; <CTX> private void deselectCurrentRowIfVisible ( ) { if ( currentRow >= 0 && currentRow < numRowsVisible ) { deselect ( getControl ( currentColumn , currentRow ) ) ; } }	Control control = getControl ( currentColumn , currentRow ) ; if ( control != null ) { deselect ( control ) ; }
State initState = new State ( factory . getMaxObligationTypes ( ) ) ; <CTX> public void initEntryFact ( ObligationFactory factory ) { this . isTop = this . isBottom = false ; this . stateMap . clear ( ) ; / / Add initial fact : empty obligations , empty path State initState = new State ( factory . getMaxObligationTypes ( ) ) ; this . stateMap . put ( initState . getObligationSet ( ) , initState ) ; }	State initState = new State ( factory . getMaxObligationTypes ( ) , factory ) ;
return buildIdMap ( os ) ; <CTX> public Map getIdMap ( ObjectStore os ) { return buildIdMap ( os ) ; }	if ( idMap == null ) { idMap = buildIdMap ( os ) ; } return idMap ;
throw postgresql . Driver . notImplemented ( ) ; <CTX> public boolean first ( ) throws SQLException { throw postgresql . Driver . notImplemented ( ) ; }	if ( rows . size ( ) <= 0 ) return false ; current_row = 0 ; this_row = ( byte [ ] [ ] ) rows . elementAt ( current_row ) ; return true ;
else if ( type == OrderType . STOP_LIMIT ) { <CTX> public quickfix . Message populateOrder ( Order order , quickfix . Message newOrderSingle ) { OrderType type = order . getType ( ) ; if ( type == OrderType . LIMIT ) newOrderSingle . setField ( new Price ( order . getLimit ( ) . doubleValue ( ) ) ) ; else if ( type == OrderType . STOP ) newOrderSingle . setField ( new StopPx ( order . getStop ( ) . doubleValue ( ) ) ) ; else if ( type == OrderType . STOP_LIMIT ) { newOrderSingle . setField ( new Price ( order . getLimit ( ) . doubleValue ( ) ) ) ; newOrderSingle . setField ( new StopPx ( order . getStop ( ) . doubleValue ( ) ) ) ; } newOrderSingle . setField ( tifToFIXTif ( order . getTIF ( ) ) ) ; return newOrderSingle ; }	} else if ( type == OrderType . STOP_LIMIT ) {
Class cl = ScriptRuntime . loadClassName ( INVOKER_MASTER_CLASS ) ; <CTX> private static Invoker newInvokerMaster ( ) { try { Class cl = ScriptRuntime . loadClassName ( INVOKER_MASTER_CLASS ) ; return ( Invoker ) cl . newInstance ( ) ; } catch ( ClassNotFoundException ex ) { } catch ( IllegalAccessException ex ) { } catch ( InstantiationException ex ) { } catch ( SecurityException ex ) { } return null ; }	Class cl = Class . forName ( INVOKER_MASTER_CLASS ) ;
if ( tooltip == null ) tooltip = new JToolTip ( tool_tip_text ) ; return tooltip ; <CTX> public JToolTip createToolTip ( ) { if ( tooltip == null ) tooltip = new JToolTip ( tool_tip_text ) ; return tooltip ; }	if ( toolTip == null ) toolTip = new JToolTip ( toolTipText ) ; return toolTip ;
if ( uri == - 1 || uri == children [ outIndex ] . uri ) { <CTX> public int validateContent ( QName children [ ] , int offset , int length ) throws Exception { / / must match order if ( fOrdered ) { int inIndex = 0 ; for ( int outIndex = 0 ; outIndex < length ; outIndex ++ ) { / / ignore mixed text final QName curChild = children [ offset + outIndex ] ; if ( curChild . localpart == - 1 ) { continue ; } / / element must match int type = fChildrenType [ inIndex ] ; if ( type == XMLContentSpec . CONTENTSPECNODE_LEAF ) { if ( fDTD ) { if ( fChildren [ inIndex ] . rawname != children [ offset + outIndex ] . rawname ) { return outIndex ; } } else { if ( fChildren [ inIndex ] . uri != children [ offset + outIndex ] . uri && fChildren [ inIndex ] . localpart != children [ offset + outIndex ] . localpart ) { return outIndex ; } } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY ) { int uri = fChildren [ inIndex ] . uri ; if ( uri != - 1 && uri != children [ outIndex ] . uri ) { return outIndex ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL ) { if ( children [ outIndex ] . uri != - 1 ) { return outIndex ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) { if ( fChildren [ inIndex ] . uri == children [ outIndex ] . uri ) { return outIndex ; } } / / advance index inIndex ++ ; } } / / can appear in any order else { for ( int outIndex = 0 ; outIndex < length ; outIndex ++ ) { / / Get the current child out of the source index final QName curChild = children [ offset + outIndex ] ; / / If its PCDATA , then we just accept that if ( curChild . localpart == - 1 ) continue ; / / And try to find it in our list int inIndex = 0 ; for ( ; inIndex < fCount ; inIndex ++ ) { int type = fChildrenType [ inIndex ] ; if ( type == XMLContentSpec . CONTENTSPECNODE_LEAF ) { if ( fDTD ) { if ( curChild . rawname == fChildren [ inIndex ] . rawname ) { break ; } } else { if ( curChild . uri == fChildren [ inIndex ] . uri && curChild . localpart == fChildren [ inIndex ] . localpart ) break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY ) { int uri = fChildren [ inIndex ] . uri ; if ( uri == - 1 || uri == children [ outIndex ] . uri ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL ) { if ( children [ outIndex ] . uri == - 1 ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) { if ( fChildren [ inIndex ] . uri != children [ outIndex ] . uri ) { break ; } } / / REVISIT : What about checking for multiple ANY matches ? / / The content model ambiguity * could * be checked / / by the caller before constructing the mixed / / content model . } / / We did not find this one , so the validation failed if ( inIndex == fCount ) return outIndex ; } } / / Everything seems to be in order , so return success return - 1 ; }	if ( uri == StringPool . EMPTY_STRING || uri == children [ outIndex ] . uri ) {
return new PsiPlainTextFileImpl ( project , name , fileType , text ) ; <CTX> public static PsiFile createFileFromText ( PsiManagerImpl manager , FileType fileType , String name , char [ ] chars , int startOffset , int endOffset ) { LOG . assertTrue ( ! fileType . isBinary ( ) ) ; final Project project = manager . getProject ( ) ; final CharArrayCharSequence text = new CharArrayCharSequence ( chars , startOffset , endOffset ) ; if ( fileType instanceof LanguageFileType ) { return ( ( LanguageFileType ) fileType ) . getLanguage ( ) . getParserDefinition ( ) . createFile ( project , name , text ) ; } return new PsiPlainTextFileImpl ( project , name , fileType , text ) ; }	return createFileFromText ( myManager , type , name , chars , startOffset , endOffset ) ;
if ( ! newValue . equals ( oldValue ) ) <CTX> public void putInt ( String key , int value ) { checkRemoved ( ) ; if ( key == null ) throw new NullPointerException ( ) ; String oldValue = null ; if ( temporarySettings . containsKey ( key ) ) oldValue = ( String ) temporarySettings . get ( key ) ; else oldValue = getOriginal ( ) . get ( key , null ) ; String newValue = Integer . toString ( value ) ; temporarySettings . put ( key , newValue ) ; if ( ! newValue . equals ( oldValue ) ) firePropertyChangeEvent ( key , oldValue , newValue ) ; }	if ( ! newValue . equals ( oldValue ) ) {
show ( ) ; <CTX> public boolean showDialog ( ) { show ( ) ; return ok ; }	setVisible ( true ) ;
return blockNames != null ? blockNames . contains ( name ) : false || ( next != null && next . isDefined ( name ) ) ; <CTX> public boolean isDefined ( String name ) { return blockNames != null ? blockNames . contains ( name ) : false || ( next != null && next . isDefined ( name ) ) ; }	return ( blockNames != null ? blockNames . contains ( name ) : false ) || ( next != null && next . isDefined ( name ) ) ;
} else if ( MylarTaskListPlugin . getTaskListManager ( ) . isReminderToday ( task ) ) { <CTX> public Color getForeground ( Object object ) { if ( object instanceof AbstractTaskContainer ) { for ( ITask child : ( ( AbstractTaskContainer ) object ) . getChildren ( ) ) { if ( child . isActive ( ) ) { return TaskListColorsAndFonts . COLOR_TASK_ACTIVE ; } else if ( child . isPastReminder ( ) && ! child . isCompleted ( ) ) { return themeManager . getCurrentTheme ( ) . getColorRegistry ( ) . get ( TaskListColorsAndFonts . THEME_COLOR_TASK_OVERDUE ) ; } } } else if ( object instanceof AbstractRepositoryQuery ) { for ( ITaskListElement child : ( ( AbstractRepositoryQuery ) object ) . getHits ( ) ) { if ( child instanceof AbstractQueryHit ) { ITask task = ( ( AbstractQueryHit ) child ) . getCorrespondingTask ( ) ; if ( task != null && task . isActive ( ) ) { return TaskListColorsAndFonts . COLOR_TASK_ACTIVE ; } } } } else if ( object instanceof AbstractQueryHit && ( ( AbstractQueryHit ) object ) . getCorrespondingTask ( ) == null ) { AbstractQueryHit hit = ( AbstractQueryHit ) object ; if ( ( hit . getCorrespondingTask ( ) != null && hit . getCorrespondingTask ( ) . isCompleted ( ) ) || hit . isCompleted ( ) ) { return TaskListColorsAndFonts . COLOR_TASK_COMPLETED ; } } else if ( object instanceof ITaskListElement ) { ITask task = getCorrespondingTask ( ( ITaskListElement ) object ) ; if ( task != null ) { if ( MylarTaskListPlugin . getTaskListManager ( ) . isCompletedToday ( task ) ) { return themeManager . getCurrentTheme ( ) . getColorRegistry ( ) . get ( TaskListColorsAndFonts . THEME_COLOR_TASK_TODAY_COMPLETED ) ; } else if ( task . isCompleted ( ) ) { return TaskListColorsAndFonts . COLOR_TASK_COMPLETED ; } else if ( task . isActive ( ) ) { return TaskListColorsAndFonts . COLOR_TASK_ACTIVE ; } else if ( task . isPastReminder ( ) ) { return themeManager . getCurrentTheme ( ) . getColorRegistry ( ) . get ( TaskListColorsAndFonts . THEME_COLOR_TASK_OVERDUE ) ; } else if ( MylarTaskListPlugin . getTaskListManager ( ) . isReminderToday ( task ) ) { return themeManager . getCurrentTheme ( ) . getColorRegistry ( ) . get ( TaskListColorsAndFonts . THEME_COLOR_TASK_TODAY_SCHEDULED ) ; } else if ( MylarTaskListPlugin . getTaskListManager ( ) . isReminderToday ( task ) ) { return themeManager . getCurrentTheme ( ) . getColorRegistry ( ) . get ( TaskListColorsAndFonts . THEME_COLOR_TASK_THISWEEK_SCHEDULED ) ; } } } return null ; }	} else if ( MylarTaskListPlugin . getTaskListManager ( ) . isActiveThisWeek ( task ) ) {
return isProcess ; <CTX> private boolean updateCurrentDeltaAndIndex ( IResourceDelta delta ) throws CModelException { ICElement element = null ; IResource resource = delta . getResource ( ) ; boolean isProcess = false ; switch ( delta . getKind ( ) ) { case IResourceDelta . ADDED : element = createElement ( resource ) ; if ( element != null ) { updateIndexAddResource ( element , delta ) ; elementAdded ( element , delta ) ; isProcess = true ; } break ; case IResourceDelta . REMOVED : element = createElement ( resource ) ; if ( element != null ) { updateIndexRemoveResource ( element , delta ) ; elementRemoved ( element , delta ) ; isProcess = true ; } break ; case IResourceDelta . CHANGED : int flags = delta . getFlags ( ) ; if ( ( flags & IResourceDelta . CONTENT ) != 0 ) { / / content has changed element = createElement ( resource ) ; if ( element != null ) { contentChanged ( element , delta ) ; updateIndexAddResource ( element , delta ) ; isProcess = true ; } } else if ( ( flags & IResourceDelta . OPEN ) != 0 ) { / / project has been opened or closed IProject res = ( IProject ) resource ; element = createElement ( resource ) ; if ( element != null ) { if ( res . isOpen ( ) ) { elementOpened ( element , delta ) ; updateIndexAddResource ( element , delta ) ; } else { elementClosed ( element , delta ) ; updateIndexRemoveResource ( element , delta ) ; } isProcess = true ; } } else if ( ( flags & IResourceDelta . DESCRIPTION ) != 0 ) { element = createElement ( resource ) ; if ( element != null ) { elementAdded ( element , delta ) ; isProcess = true ; } } break ; } return isProcess ; }	return element != null ;
return null ; <CTX> public Point computeMinimumSize ( ) { / / TODO Auto - generated method stub return null ; }	return tabFolder . computeMinimumSize ( ) ;
command = WorkbenchMessages . Workbench_redo ; <CTX> private IStatus reportAndInterpretStatus ( IStatus status , IAdaptable uiInfo , IUndoableOperation operation , boolean undoing ) { / / CANCEL status is assumed to be initiated by the user , so there / / is nothing to report . if ( status . getSeverity ( ) == IStatus . CANCEL ) return status ; / / Other status severities are reported with a message dialog . / / First obtain a shell and set up the dialog title . boolean createdShell = false ; IStatus reportedStatus = status ; Shell shell = getShell ( uiInfo ) ; if ( shell == null ) { createdShell = true ; shell = new Shell ( ) ; } / / Set up the dialog . For non - error statuses , we use a warning dialog / / that allows the user to proceed or to cancel out of the operation . if ( ! ( status . getSeverity ( ) == IStatus . ERROR ) ) { String command , title ; if ( undoing ) { command = WorkbenchMessages . Workbench_undo ; if ( status . getSeverity ( ) == IStatus . INFO ) title = WorkbenchMessages . Operations_undoInfo ; else title = WorkbenchMessages . Operations_undoWarning ; } else { command = WorkbenchMessages . Workbench_redo ; if ( status . getSeverity ( ) == IStatus . INFO ) title = WorkbenchMessages . Operations_redoInfo ; else title = WorkbenchMessages . Operations_redoWarning ; } String message = NLS . bind ( WorkbenchMessages . Operations_proceedWithNonOKStatus , new String [ ] { status . getMessage ( ) , command , operation . getLabel ( ) } ) ; String [ ] buttons = new String [ ] { IDialogConstants . YES_LABEL , IDialogConstants . NO_LABEL } ; MessageDialog dialog = new MessageDialog ( shell , title , null , message , MessageDialog . WARNING , buttons , 0 ) ; boolean proceed = ( dialog . open ( ) == 0 ) ; / / if the user chooses to proceed anyway , map the status to OK so / / that the operation is considered approved . Otherwise leave / / the status as is to stop the operation . if ( proceed ) reportedStatus = Status . OK_STATUS ; } else { String title , stopped ; if ( undoing ) { title = WorkbenchMessages . Operations_undoProblem ; stopped = WorkbenchMessages . Operations_stoppedOnUndoErrorStatus ; } else { title = WorkbenchMessages . Operations_redoProblem ; stopped = WorkbenchMessages . Operations_stoppedOnRedoErrorStatus ; } / / It is an error condition . The user has no choice to proceed , so / / we only report what has gone on . We use a warning icon instead of / / an error icon since there has not yet been a failure . String message = NLS . bind ( stopped , status . getMessage ( ) , operation . getLabel ( ) ) ; MessageDialog dialog = new MessageDialog ( shell , title , null , message , MessageDialog . WARNING , new String [ ] { IDialogConstants . OK_LABEL } , 0 ) ; / / ok dialog . open ( ) ; } if ( createdShell ) shell . dispose ( ) ; return reportedStatus ; }	warning = WorkbenchMessages . Operations_proceedWithNonOKUndoStatus ;
return localport ; <CTX> protected int getLocalPort ( ) { return localport ; }	return localPort ;
if ( newChildren != null && newChildren . size ( ) > 0 ) { <CTX> public List getNestedRepeatIds ( String repeatId ) { final Map repeatIdToRepeatControlInfo = getRepeatIdToRepeatControlInfo ( ) ; final RepeatControlInfo repeatControlInfo = ( RepeatControlInfo ) repeatIdToRepeatControlInfo . get ( repeatId ) ; final int index = ( ( Integer ) getRepeatIdToIndex ( ) . get ( repeatId ) ) . intValue ( ) ; final List newChildren = repeatControlInfo . getChildren ( ) ; if ( newChildren != null && newChildren . size ( ) > 0 ) { Map result = new HashMap ( ) ; visitRepeatHierarchy ( result , Collections . singletonList ( newChildren . get ( index - 1 ) ) ) ; return new ArrayList ( result . keySet ( ) ) ; } else { return null ; } }	if ( newChildren != null && newChildren . size ( ) > 0 && index > 0 ) {
manager . setActiveBrowser ( wrapper . getController ( ) ) ; <CTX> public void focusGained ( FocusEvent event ) { BrowserManager manager = env . getBrowserManager ( ) ; manager . setActiveBrowser ( wrapper . getController ( ) ) ; }	manager . setActiveBrowser ( wrapper ) ;
double d = stackDbl [ i ] ; <CTX> private static boolean stack_boolean ( Object [ ] stack , double [ ] stackDbl , int i ) { Object x = stack [ i ] ; if ( x == Boolean . TRUE ) { return true ; } else if ( x == Boolean . FALSE ) { return false ; } else if ( x == DBL_MRK ) { double d = stackDbl [ i ] ; return d == d && d != 0 . 0 ; } else if ( x == null || x == Undefined . instance ) { return false ; } else if ( x instanceof Number ) { double d = ( ( Number ) x ) . doubleValue ( ) ; return ( d == d && d != 0 . 0 ) ; } else if ( x instanceof Boolean ) { return ( ( Boolean ) x ) . booleanValue ( ) ; } else { return ScriptRuntime . toBoolean ( x ) ; } }	double d = state . sDbl [ i ] ;
new FilterCalculator ( populator , filterByRow ) . applyFilters ( ) ; <CTX> static void applyFilters ( ResultSetPopulator populator , FilterByRow filterByRow ) throws DataException { new FilterCalculator ( populator , filterByRow ) . applyFilters ( ) ; }	new FilterCalculator ( populator , filterByRow , session ) . applyFilters ( ) ;
if ( element instanceof SearchListSeparator ) { <CTX> public boolean select ( Viewer viewer , Object parentElement , Object element ) { if ( element instanceof SearchListSeparator ) { return true ; } else if ( element instanceof ResourceSearchItem ) { return resourceWorkingSetFilter . select ( viewer , parentElement , ( ( ResourceSearchItem ) element ) . getResource ( ) ) ; } return false ; }	if ( element instanceof ItemsListSeparator ) {
return SessionHandleAdapter . getInstance ( ) <CTX> protected boolean calculateEnabled ( ) { return SessionHandleAdapter . getInstance ( ) . getReportDesignHandle ( ) . getDataSets ( ) . getCount ( ) != 0 ; }	return ! SessionHandleAdapter . getInstance ( )
return true ; <CTX> public boolean doomedInVacuum ( ) { for ( Enumeration e = getEquipment ( ) ; e . hasMoreElements ( ) ; ) { Mounted m = ( Mounted ) e . nextElement ( ) ; if ( m . getType ( ) instanceof MiscType && m . getType ( ) . hasFlag ( MiscType . F_VACUUM_PROTECTION ) ) { return true ; } } return false ; }	return false ;
if ( ! evt . isConsumed ( ) ) super . processKeyEvent ( evt ) ; <CTX> public void processKeyEvent ( KeyEvent evt ) { view . processKeyEvent ( evt , true ) ; if ( ! evt . isConsumed ( ) ) super . processKeyEvent ( evt ) ; } / / } } }	/ * if ( ! evt . isConsumed ( ) ) super . processKeyEvent ( evt ) ; * /
if ( selected == null ) <CTX> public static IProject [ ] findSelectedProjects ( IWorkbenchWindow window ) { if ( window == null ) return new IProject [ 0 ] ; ISelection selection = window . getSelectionService ( ) . getSelection ( ) ; IProject [ ] selected = null ; if ( selection != null && ! selection . isEmpty ( ) && selection instanceof IStructuredSelection ) { selected = extractProjects ( ( ( IStructuredSelection ) selection ) . toArray ( ) ) ; } else { / / see if we can extract a selected project from the active editor IWorkbenchPart part = window . getPartService ( ) . getActivePart ( ) ; if ( part instanceof IEditorPart ) { IEditorPart editor = ( IEditorPart ) part ; IFile file = ResourceUtil . getFile ( editor . getEditorInput ( ) ) ; if ( file != null ) { selected = new IProject [ ] { file . getProject ( ) } ; } } } if ( selected == null ) selected = new IProject [ 0 ] ; return selected ; }	if ( selected == null ) {
void sortGroupBoundaryInfos ( ArrayList [ ] groupArray ) <CTX> void sortGroupBoundaryInfos ( ArrayList [ ] groupArray ) { for ( int i = 0 ; i < groupArray . length ; i ++ ) { Object [ ] toBeSorted = new Object [ groupArray [ i ] . size ( ) ] ; for ( int j = 0 ; j < toBeSorted . length ; j ++ ) { toBeSorted [ j ] = groupArray [ i ] . get ( j ) ; } Arrays . sort ( toBeSorted , new GroupBoundaryInfoComparator ( ) ) ; groupArray [ i ] . clear ( ) ; for ( int j = 0 ; j < toBeSorted . length ; j ++ ) { groupArray [ i ] . add ( toBeSorted [ j ] ) ; } } }	void sortGroupBoundaryInfos ( List [ ] groupArray )
growArraySize = atoms . length ; <CTX> protected void growAtomArray ( ) { growArraySize = atoms . length ; org . openscience . cdk . interfaces . Atom [ ] newatoms = new org . openscience . cdk . interfaces . Atom [ atoms . length + growArraySize ] ; System . arraycopy ( atoms , 0 , newatoms , 0 , atoms . length ) ; atoms = newatoms ; }	growArraySize = ( atoms . length < growArraySize ) ? growArraySize : atoms . length ;
if ( canEdit ( ) ) <CTX> public void replaceTile ( Tile find , Tile replace ) { if ( canEdit ( ) ) return ; for ( int y = bounds . y ; y < bounds . y + bounds . height ; y ++ ) { for ( int x = bounds . x ; x < bounds . x + bounds . width ; x ++ ) { if ( getTileAt ( x , y ) == find ) { setTileAt ( x , y , replace ) ; } } } }	if ( ! canEdit ( ) )
comboCommand . setItems ( ( String [ ] ) commandNames . toArray ( new String [ commandNames . size ( ) ] ) ) ; <CTX> private final void updateComboCommand ( ) { final String categoryId = getCategoryId ( ) ; final String commandId = getCommandId ( ) ; final Set commandIds = ( Set ) commandIdsByCategoryId . get ( categoryId ) ; final Map commandIdsByName ; if ( commandIds == null ) { commandIdsByName = new HashMap ( ) ; } else { commandIdsByName = new HashMap ( commandIdsByUniqueName ) ; commandIdsByName . values ( ) . retainAll ( commandIds ) ; } final List commandNames = new ArrayList ( commandIdsByName . keySet ( ) ) ; Collections . sort ( commandNames , Collator . getInstance ( ) ) ; comboCommand . setItems ( ( String [ ] ) commandNames . toArray ( new String [ commandNames . size ( ) ] ) ) ; setCommandId ( commandId ) ; if ( comboCommand . getSelectionIndex ( ) == - 1 && ! commandNames . isEmpty ( ) ) comboCommand . select ( 0 ) ; }	final String [ ] currentItems = comboCommand . getItems ( ) ; final String [ ] newItems = ( String [ ] ) commandNames . toArray ( new String [ commandNames . size ( ) ] ) ; if ( ! Arrays . equals ( currentItems , newItems ) ) { comboCommand . setItems ( newItems ) ; }
remove ( MenuComponent menu ) <CTX> remove ( MenuComponent menu ) { int index = menus . indexOf ( menu ) ; if ( index == - 1 ) return ; remove ( index ) ; }	remove ( int index )
if ( ! closing ) <CTX> private void closeAllPages ( ) { / / Deactivate active page . setActivePage ( null ) ; / / Clone and deref all so that calls to getPages ( ) returns / / empty list ( if call by pageClosed event handlers ) PageList oldList = pageList ; pageList = new PageList ( ) ; / / Close all . Iterator itr = oldList . iterator ( ) ; while ( itr . hasNext ( ) ) { WorkbenchPage page = ( WorkbenchPage ) itr . next ( ) ; firePageClosed ( page ) ; page . dispose ( ) ; } if ( ! closing ) showEmptyWindowContents ( ) ; }	if ( ! closing ) {
if ( isCurrentPage ( ) ) getContainer ( ) . updateTitleBar ( ) ; <CTX> public void setDescription ( String description ) { super . setDescription ( description ) ; if ( isCurrentPage ( ) ) getContainer ( ) . updateTitleBar ( ) ; }	if ( isCurrentPage ( ) ) { getContainer ( ) . updateTitleBar ( ) ; }
WizardActionGroup . TYPE_IMPORT ) ; <CTX> public void init ( ICommonActionExtensionSite aConfig ) { Assert . isTrue ( ! disposed ) ; if ( aConfig . getViewSite ( ) instanceof ICommonViewerWorkbenchSite ) { IWorkbenchWindow window = ( ( ICommonViewerWorkbenchSite ) aConfig . getViewSite ( ) ) . getWorkbenchWindow ( ) ; importAction = new ImportResourcesAction ( window ) ; exportAction = new ExportResourcesAction ( window ) ; importWizardActionGroup = new WizardActionGroup ( window , PlatformUI . getWorkbench ( ) . getImportWizardRegistry ( ) , WizardActionGroup . TYPE_IMPORT ) ; exportWizardActionGroup = new WizardActionGroup ( window , PlatformUI . getWorkbench ( ) . getExportWizardRegistry ( ) , WizardActionGroup . TYPE_EXPORT ) ; contribute = true ; } }	WizardActionGroup . TYPE_IMPORT , anExtensionSite . getContentService ( ) ) ;
if ( val . magnitude . length > i ) <CTX> public BigInteger xor ( BigInteger val ) { int [ ] result ; if ( magnitude . length > val . magnitude . length ) { result = new int [ magnitude . length ] ; } else { result = new int [ val . magnitude . length ] ; } for ( int i = 0 ; i < result . length ; i ++ ) { int index = result . length - i - 1 ; if ( magnitude . length > i ) { result [ index ] = magnitude [ magnitude . length - i - 1 ] ; } if ( val . magnitude . length > i ) { result [ index ] ^= val . magnitude [ val . magnitude . length - i - 1 ] ; } else { result [ index ] ^= 0 ; } } int resSign = 1 ; if ( sign < 0 || val . sign < 0 ) { resSign = - 1 ; } return new BigInteger ( resSign , result ) ; }	if ( val . sign < 0 )
if ( isByteArray ) byteArrayStreamEscapeSet . set ( streamConstruction . getPosition ( ) ) ; <CTX> public void addStreamConstruction ( InstructionHandle streamConstruction , boolean isByteArray ) { streamConstructionSet . set ( streamConstruction . getPosition ( ) ) ; if ( isByteArray ) byteArrayStreamEscapeSet . set ( streamConstruction . getPosition ( ) ) ; }	if ( isUninteresting ) uninterestingStreamEscapeSet . set ( streamConstruction . getPosition ( ) ) ;
Impact impact = ( Impact ) impacts . get ( i ) ; <CTX> private List getAgentsInImpacts ( ) { List agents = new ArrayList ( ) ; for ( int i = 0 ; i < impacts . size ( ) ; i ++ ) { Impact impact = ( Impact ) impacts . get ( i ) ; agents . addAll ( Arrays . asList ( impact . getAgents ( ) ) ) ; } return agents ; }	ImpactComponent impact = ( ImpactComponent ) impacts . get ( i ) ;
newInputButton . setEnabled ( true ) ; newListButton . setEnabled ( true ) ; <CTX> public void valueChanged ( TreeSelectionEvent event ) { if ( event . getPath ( ) . getLastPathComponent ( ) instanceof PanelTreeNode ) { PanelTreeNode node = ( PanelTreeNode ) event . getPath ( ) . getLastPathComponent ( ) ; splitter . setRightComponent ( node . getPanel ( ) ) ; if ( node instanceof InputsRootNode ) { loadInputsButton . setEnabled ( false ) ; newInputButton . setEnabled ( false ) ; newListButton . setEnabled ( false ) ; removeButton . setEnabled ( false ) ; } else if ( node instanceof InputPortNode ) { loadInputsButton . setEnabled ( true ) ; newInputButton . setEnabled ( true ) ; newListButton . setEnabled ( true ) ; removeButton . setEnabled ( false ) ; } else { loadInputsButton . setEnabled ( true ) ; newInputButton . setEnabled ( true ) ; newListButton . setEnabled ( true ) ; removeButton . setEnabled ( true ) ; } } else { if ( splitter . getRightComponent ( ) != null ) { splitter . remove ( splitter . getRightComponent ( ) ) ; } loadInputsButton . setEnabled ( false ) ; newInputButton . setEnabled ( false ) ; newListButton . setEnabled ( false ) ; removeButton . setEnabled ( false ) ; } splitter . validate ( ) ; }	newInputButton . setEnabled ( canAddInputs ( ( InputListNode ) node ) ) ; newListButton . setEnabled ( canAddLists ( ( InputListNode ) node ) ) ;
classFile . stopMethod ( ( short ) ( localsMax + 1 ) , vars ) ; <CTX> private void finishMethod ( Context cx , VariableTable vars ) { classFile . stopMethod ( ( short ) ( localsMax + 1 ) , vars ) ; contextLocal = - 1 ; }	OptLocalVariable [ ] array = OptLocalVariable . toArray ( vars ) ; classFile . stopMethod ( ( short ) ( localsMax + 1 ) , array ) ;
return MOVE_REDUCED ; <CTX> private static byte getTypeFromTib ( OPT_Instruction s ) { if ( CF_TIB ) { OPT_Operand tibOp = Unary . getVal ( s ) ; if ( tibOp . isTIBConstant ( ) ) { OPT_TIBConstantOperand tib = tibOp . asTIBConstant ( ) ; Move . mutate ( s , REF_MOVE , Unary . getClearResult ( s ) , new OPT_ObjectConstantOperand ( tib . value , Offset . zero ( ) ) ) ; return MOVE_REDUCED ; } } return UNCHANGED ; }	return DefUseEffect . MOVE_FOLDED ;
String retStr = NativeNormalizer . normalize ( str , normalizationMode , errCode ) ; if ( ErrorCode . isFailure ( errCode [ 0 ] ) ) { throw ErrorCode . getException ( errCode [ 0 ] ) ; <CTX> public static String normalize ( String str , int normalizationMode ) throws Exception { synchronized ( errCode ) { if ( ! check ( normalizationMode ) ) { throw ErrorCode . getException ( ErrorCode . U_ILLEGAL_ARGUMENT_ERROR ) ; } String retStr = NativeNormalizer . normalize ( str , normalizationMode , errCode ) ; if ( ErrorCode . isFailure ( errCode [ 0 ] ) ) { throw ErrorCode . getException ( errCode [ 0 ] ) ; } return retStr ; } }	int errorCode = NativeNormalizer . normalize ( str , normalizationMode , retStr ) ; if ( ErrorCode . isFailure ( errorCode ) ) { throw ErrorCode . getException ( errorCode ) ;
return getRuntime ( ) . newFixnum ( toString ( ) . hashCode ( ) ) ; <CTX> public RubyFixnum hash ( ) { return getRuntime ( ) . newFixnum ( toString ( ) . hashCode ( ) ) ; }	return getRuntime ( ) . newFixnum ( hashCode ( ) ) ;
return RubyBoolean . newBoolean ( getRuntime ( ) , Modifier . isFinal ( field . getModifiers ( ) ) ) ; <CTX> public RubyBoolean final_p ( ) { return RubyBoolean . newBoolean ( getRuntime ( ) , Modifier . isFinal ( field . getModifiers ( ) ) ) ; }	return getRuntime ( ) . newBoolean ( Modifier . isFinal ( field . getModifiers ( ) ) ) ;
return tracker . succeededBlocks ( ) . length ; <CTX> public int fetchedBlocks ( ) { return tracker . succeededBlocks ( ) . length ; }	return tracker . succeededBlocksLength ( ) ;
if ( baseVal != null ) { <CTX> public void attrAdded ( Attr node , String newv ) { if ( baseVal != null ) { baseVal . invalidate ( ) ; } }	if ( ! changing && baseVal != null ) {
if ( sp == null || sr == null || mCursors . size ( ) == 0 ) <CTX> private void doSearchPrevious ( String [ ] args ) throws ServiceException { ZSearchParams sp = mSearchParams ; ZSearchResult sr = mSearchResult ; if ( sp == null || sr == null || mCursors . size ( ) == 0 ) return ; mCursors . pop ( ) ; sp . setCursor ( mCursors . size ( ) > 0 ? mCursors . peek ( ) : null ) ; doSearch ( sp ) ; }	if ( sp == null || sr == null || mSearchCursors . size ( ) == 0 )
Map map = view . getAllAttributes ( ) ; Rectangle cellBounds = GraphConstants . getBounds ( map ) ; Rectangle editingBounds = editorComponent . getBounds ( ) ; GraphConstants . setBounds ( map , new Rectangle ( cellBounds . x , cellBounds . y , editingBounds . width , editingBounds . height ) ) ; <CTX> public boolean stopCellEditing ( ) { / / set the size of a vertex to that of an editor . CellView view = graph . getGraphLayoutCache ( ) . getMapping ( graph . getEditingCell ( ) , false ) ; Map map = view . getAllAttributes ( ) ; Rectangle cellBounds = GraphConstants . getBounds ( map ) ; Rectangle editingBounds = editorComponent . getBounds ( ) ; GraphConstants . setBounds ( map , new Rectangle ( cellBounds . x , cellBounds . y , editingBounds . width , editingBounds . height ) ) ; return super . stopCellEditing ( ) ; }	if ( view != null ) { Map map = view . getAllAttributes ( ) ; Rectangle cellBounds = GraphConstants . getBounds ( map ) ; Rectangle editingBounds = editorComponent . getBounds ( ) ; GraphConstants . setBounds ( map , new Rectangle ( cellBounds . x , cellBounds . y , editingBounds . width , editingBounds . height ) ) ; }
RubyModule rubyClass = ( RubyModule ) classStack . peek ( ) ; if ( rubyClass . isIncluded ( ) ) { return ( ( IncludedModuleWrapper ) rubyClass ) . getDelegate ( ) ; <CTX> public RubyModule getRubyClass ( ) { if ( classStack . empty ( ) ) { return null ; } RubyModule rubyClass = ( RubyModule ) classStack . peek ( ) ; if ( rubyClass . isIncluded ( ) ) { return ( ( IncludedModuleWrapper ) rubyClass ) . getDelegate ( ) ; } return rubyClass ; }	if ( parentModule . isIncluded ( ) ) { return ( ( IncludedModuleWrapper ) parentModule ) . getDelegate ( ) ;
return 32 ; <CTX> public int getMaxColumnNameLength ( ) throws SQLException { return 32 ; }	return NAME_SIZE ;
getHistory ( ) . dispose ( undoContext , true , false , false ) ; <CTX> void flush ( ) { getHistory ( ) . dispose ( undoContext , true , false , false ) ; }	getHistory ( ) . dispose ( getUndoContext ( ) , true , false , false ) ;
myDependanceContainsLF = formatter . containsLineFeeds ( myDependance ) ; <CTX> public void refresh ( FormatProcessor formatter ) { myDependanceContainsLF = formatter . containsLineFeeds ( myDependance ) ; }	myDependanceContainsLF = myLineFeedWasUsed || formatter . containsLineFeeds ( myDependance ) ;
log . error ( ex ) ; <CTX> public void sendClearPanelMsg ( ) { int tmp [ ] = new int [ 1 ] ; tmp [ 0 ] = 0 ; DrawCommand comm = new DrawCommand ( DrawCommand . CLEAR ) ; ObjectOutputStream os ; try { out . reset ( ) ; os = new ObjectOutputStream ( out ) ; os . writeObject ( comm ) ; os . flush ( ) ; data_channel . send ( new Message ( null , null , out . toByteArray ( ) ) ) ; } catch ( Exception ex ) { log . error ( ex ) ; } }	System . err . println ( ex ) ;
this ( ) ; this . entryNr = nr ; <CTX> public Result ( int nr ) { this ( ) ; this . entryNr = nr ; }	nrErrors = 0 L ; nrLinesInput = 0 L ; nrLinesOutput = 0 L ; nrLinesUpdated = 0 L ; nrLinesRead = 0 L ; nrLinesWritten = 0 L ; result = false ; exitStatus = 0 ; rows = null ; interestingFiles = new ArrayList ( ) ; stopped = false ; entryNr = 0 ;
node = addElement ( parent , name , saver . getClass ( ) . getName ( ) , false , false ) ; <CTX> public Element writeBeanSaver ( Element parent , Object o , String name ) throws Exception { Element node ; weka . gui . beans . Saver saver ; File file ; / / for debugging only if ( DEBUG ) trace ( new Throwable ( ) , name ) ; saver = ( weka . gui . beans . Saver ) o ; node = addElement ( parent , name , saver . getClass ( ) . getName ( ) , false , false ) ; invokeWriteToXML ( node , saver . getSaver ( ) , VAL_SAVER ) ; return node ; }	node = addElement ( parent , name , saver . getClass ( ) . getName ( ) , false ) ;
if ( IChemFile . class . isInstance ( classObject ) ) return true ; <CTX> public boolean accepts ( Class classObject ) { if ( IChemFile . class . isInstance ( classObject ) ) return true ; return false ; }	Class [ ] interfaces = classObject . getInterfaces ( ) ; for ( int i = 0 ; i < interfaces . length ; i ++ ) { if ( IChemFile . class . equals ( interfaces [ i ] ) ) return true ; }
getParameterPosition ( expList , wrappedExp ) ; <CTX> public void visitExpressionList ( PsiExpressionList expList ) { final JavaResolveResult result = findCalledMethod ( expList ) ; final PsiMethod method = ( PsiMethod ) result . getElement ( ) ; if ( method == null ) { expectedType = null ; } else { final int parameterPosition = getParameterPosition ( expList , wrappedExp ) ; expectedType = getTypeOfParameter ( result , parameterPosition ) ; } }	getParameterPosition ( expressionList , wrappedExpression ) ;
return this . mappedPort ; <CTX> public int getPort ( ) { return this . mappedPort ; }	return this . port ;
return ( Class ) cls ; <CTX> public Class findClass ( String name ) throws ClassNotFoundException { Object cls = classMap . get ( name ) ; if ( cls == null ) throw new ClassNotFoundException ( name ) ; return ( Class ) cls ; }	return cls ;
MylarUiPlugin . getDefault ( ) . setFilterInCompleteMode ( isChecked ( ) ) ; <CTX> public void run ( ) { MylarUiPlugin . getDefault ( ) . setFilterInCompleteMode ( isChecked ( ) ) ; if ( isChecked ( ) ) { viewer . addFilter ( inCompleteFilter ) ; filterCompleteTask . setChecked ( false ) ; viewer . removeFilter ( completeFilter ) ; } else { viewer . removeFilter ( inCompleteFilter ) ; } viewer . refresh ( ) ; }	MylarTasksPlugin . getDefault ( ) . setFilterInCompleteMode ( isChecked ( ) ) ;
this . endian = endian ; return this ; <CTX> public final ByteBuffer order ( ByteOrder endian ) { this . endian = endian ; return this ; }	return endian ;
if ( ! found ) return s ; <CTX> public static String removeWhiteSpaces ( String s ) { / / check for no whitespace ( common case ) boolean found = false ; int wsIndex = - 1 ; int size = s . length ( ) ; for ( int i = 0 ; i < size ; i ++ ) { found = Character . isWhitespace ( s . charAt ( i ) ) ; if ( found ) { wsIndex = i ; break ; } } if ( ! found ) return s ; StringBuffer result = new StringBuffer ( s . substring ( 0 , wsIndex ) ) ; for ( int i = wsIndex + 1 ; i < size ; i ++ ) { char ch = s . charAt ( i ) ; if ( ! Character . isWhitespace ( ch ) ) result . append ( ch ) ; } return result . toString ( ) ; }	if ( ! found ) { return s ; }
getRuntime ( ) . yield ( RubyString . newString ( getRuntime ( ) , contents [ i ] ) ) ; <CTX> public IRubyObject each ( ) { String [ ] contents = snapshot ; for ( int i = 0 ; i < contents . length ; i ++ ) { getRuntime ( ) . yield ( RubyString . newString ( getRuntime ( ) , contents [ i ] ) ) ; } return this ; }	getRuntime ( ) . yield ( getRuntime ( ) . newString ( contents [ i ] ) ) ;
return new Dimension ( width , height ) ; <CTX> public Dimension getSize ( ) { return new Dimension ( width , height ) ; }	return size ( ) ;
if ( db != null && ! db . hasTransactions ( ) ) <CTX> void releaseDbHandle ( isc_db_handle db , FBConnectionRequestInfo cri ) throws GDSException { synchronized ( db ) { if ( db != null && ! db . hasTransactions ( ) ) { gds . isc_detach_database ( db ) ; } } }	LinkedList freeDbHandles = null ; synchronized ( criToFreeDbHandlesMap )
/ intervalRange ) ) ; <CTX> public Object calculate ( Object value ) { if ( value == null ) { return new Double ( - 1 ) ; } if ( intervalStart == null ) { return new Double ( Math . floor ( DateTimeUtil . diffMonth ( defaultStart , ( Date ) value ) / intervalRange ) ) ; } else { if ( DateTimeUtil . diffMonth ( ( Date ) intervalStart , ( Date ) value ) < 0 ) { return new Double ( - 1 ) ; } else { return new Double ( Math . floor ( DateTimeUtil . diffMonth ( ( Date ) intervalStart , ( Date ) value ) / intervalRange ) ) ; } } }	/ getDateIntervalRange ( ) ) ) ;
x . setPath ( p ) ; <CTX> private static boolean mkdirs ( File x ) { if ( x . isDirectory ( ) ) return true ; String p = x . getPath ( ) ; String parent = x . getParent ( ) ; if ( parent != null ) { x . setPath ( parent ) ; if ( ! mkdirs ( x ) ) return false ; x . setPath ( p ) ; } return x . mkdir ( ) ; }	x . path = p ;
JLayeredPane layeredPane ; <CTX> private void cleanupUI ( ) { JLayeredPane layeredPane ; try { / / Return focus back to the previous focused component if we need to do it and / / previous focused componen is showing . if ( myPreviouslyFocusedComponent instanceof JComponent && myPreviouslyFocusedComponent . isShowing ( ) ) { final JComponent_component = ( JComponent ) myPreviouslyFocusedComponent ; LayoutFocusTraversalPolicyExt . setOverridenDefaultComponent (_component ) ; } if ( myPreviouslyFocusedComponent != null ) { myPreviouslyFocusedComponent . requestFocus ( ) ; } layeredPane = myTextFieldPanel . getRootPane ( ) . getLayeredPane ( ) ; layeredPane . remove ( myListScrollPane ) ; layeredPane . remove ( myTextFieldPanel ) ; } finally { LayoutFocusTraversalPolicyExt . setOverridenDefaultComponent ( null ) ; } layeredPane . validate ( ) ; layeredPane . repaint ( ) ; }	JLayeredPane layeredPane = null ;
InterpretedFunction result = new InterpretedFunction ( itsData , cx ) ; <CTX> generateFunctionICode ( Context cx , Scriptable scope , FunctionNode theFunction , Object securityDomain ) { itsFunctionList = ( Vector ) theFunction . getProp ( Node . FUNCTION_PROP ) ; if ( itsFunctionList != null ) generateNestedFunctions ( scope , cx , securityDomain ) ; Object [ ] regExpLiterals = null ; Vector regexps = ( Vector ) theFunction . getProp ( Node . REGEXP_PROP ) ; if ( regexps != null ) regExpLiterals = generateRegExpLiterals ( cx , scope , regexps ) ; VariableTable varTable = theFunction . getVariableTable ( ) ; boolean needsActivation = theFunction . requiresActivation ( ) || ( cx . isGeneratingDebugChanged ( ) && cx . isGeneratingDebug ( ) ) ; generateICodeFromTree ( theFunction . getLastChild ( ) , varTable , needsActivation , securityDomain ) ; itsData . itsName = theFunction . getFunctionName ( ) ; itsData . itsSourceFile = ( String ) theFunction . getProp ( Node . SOURCENAME_PROP ) ; itsData . itsSource = ( String ) theFunction . getProp ( Node . SOURCE_PROP ) ; itsData . itsNestedFunctions = itsNestedFunctions ; itsData . itsRegExpLiterals = regExpLiterals ; if ( printICode ) dumpICode ( itsData ) ; InterpretedFunction result = new InterpretedFunction ( itsData , cx ) ; if ( cx . debugger != null ) { cx . debugger . handleCompilationDone ( cx , result , debugSource ) ; } return result ; }	String [ ] argNames = itsVariableTable . getAllNames ( ) ; short argCount = ( short ) itsVariableTable . getParameterCount ( ) ; InterpretedFunction result = new InterpretedFunction ( cx , itsData , argNames , argCount ) ;
return eDynamicGet ( eFeature , resolve ) ; <CTX> public Object eGet ( EStructuralFeature eFeature , boolean resolve ) { switch ( eDerivedStructuralFeatureID ( eFeature ) ) { case AttributePackage . INSETS__ TOP : return new Double ( getTop ( ) ) ; case AttributePackage . INSETS__ LEFT : return new Double ( getLeft ( ) ) ; case AttributePackage . INSETS__ BOTTOM : return new Double ( getBottom ( ) ) ; case AttributePackage . INSETS__ RIGHT : return new Double ( getRight ( ) ) ; } return eDynamicGet ( eFeature , resolve ) ; }	return super . eGet ( featureID , resolve , coreType ) ;
return new BookmarkEntryImpl ( nativeNode , yourParent ) ; <CTX> protected RDFTreeNode newRDFTreeNode ( int nativeNode , RDFTreeNode yourParent ) { return new BookmarkEntryImpl ( nativeNode , yourParent ) ; }	return new BookmarkEntryImpl ( nativeWebShell , nativeNode , yourParent ) ;
return false ; <CTX> public boolean areFocusTraversalKeysSet ( int id ) { if ( id != KeyboardFocusManager . FORWARD_TRAVERSAL_KEYS && id != KeyboardFocusManager . BACKWARD_TRAVERSAL_KEYS && id != KeyboardFocusManager . UP_CYCLE_TRAVERSAL_KEYS && id != KeyboardFocusManager . DOWN_CYCLE_TRAVERSAL_KEYS ) throw new IllegalArgumentException ( ) ; return false ; }	return focusTraversalKeys != null && focusTraversalKeys [ id ] != null ;
this . code = code ; this . PC = code . length ; readPC = PC ; } <CTX> public void setCode ( byte [ ] code ) { this . code = code ; this . PC = code . length ; readPC = PC ; }	this . code = code ; this . PC = code . length ; }
if ( TaskListView . getDefault ( ) != null ) <CTX> public void propertyChange ( PropertyChangeEvent event ) { if ( event . getProperty ( ) . equals ( TaskListPreferenceConstants . MULTIPLE_ACTIVE_TASKS ) ) { TaskListView . getDefault ( ) . togglePreviousAction ( ! getPrefs ( ) . getBoolean ( TaskListPreferenceConstants . MULTIPLE_ACTIVE_TASKS ) ) ; TaskListView . getDefault ( ) . toggleNextAction ( ! getPrefs ( ) . getBoolean ( TaskListPreferenceConstants . MULTIPLE_ACTIVE_TASKS ) ) ; TaskListView . getDefault ( ) . clearTaskHistory ( ) ; } if ( event . getProperty ( ) . equals ( MylarPreferenceContstants . PREF_DATA_DIR ) ) { if ( event . getOldValue ( ) instanceof String ) { String newDirPath = MylarPlugin . getDefault ( ) . getDataDirectory ( ) ; String taskListFilePath = newDirPath + File . separator + DEFAULT_TASK_LIST_FILE ; getTaskListSaveManager ( ) . saveTaskListAndContexts ( ) ; getTaskListManager ( ) . setTaskListFile ( new File ( taskListFilePath ) ) ; getTaskListManager ( ) . resetTaskList ( ) ; getTaskListManager ( ) . readExistingOrCreateNewList ( ) ; if ( TaskListView . getDefault ( ) != null ) TaskListView . getDefault ( ) . clearTaskHistory ( ) ; } } }	if ( TaskListView . getDefault ( ) != null ) {
Object lhs = stack [ stackTop - 1 ] ; if ( lhs == DBL_MRK ) lhs = doubleWrap ( sDbl [ stackTop - 1 ] ) ; <CTX> private static int do_getElem ( Object [ ] stack , double [ ] sDbl , int stackTop , Context cx , Scriptable scope ) { Object lhs = stack [ stackTop - 1 ] ; if ( lhs == DBL_MRK ) lhs = doubleWrap ( sDbl [ stackTop - 1 ] ) ; Object result ; Object id = stack [ stackTop ] ; if ( id != DBL_MRK ) { result = ScriptRuntime . getObjectElem ( lhs , id , cx , scope ) ; } else { double val = sDbl [ stackTop ] ; if ( lhs == null || lhs == Undefined . instance ) { throw ScriptRuntime . undefReadError ( lhs , ScriptRuntime . toString ( val ) ) ; } Scriptable obj = ( lhs instanceof Scriptable ) ? ( Scriptable ) lhs : ScriptRuntime . toObject ( cx , scope , lhs ) ; int index = ( int ) val ; if ( index == val ) { result = ScriptRuntime . getObjectIndex ( obj , index , cx ) ; } else { String s = ScriptRuntime . toString ( val ) ; result = ScriptRuntime . getObjectProp ( obj , s , cx ) ; } } -- stackTop ; stack [ stackTop ] = result ; return stackTop ; }	Object lhs = state . stack [ i ] ; if ( lhs == DBL_MRK ) lhs = doubleWrap ( state . sDbl [ i ] ) ;
return value ; <CTX> public void saveArray ( IObject [ ] graph ) { doAction ( graph , new UpdateAction < IObject [ ] > ( ) { @ Override public IObject [ ] run ( IObject [ ] value , UpdateFilter filter ) { IObject [ ] copy = new IObject [ value . length ] ; for ( int i = 0 ; i < value . length ; i ++ ) { copy [ i ] = internalSave ( value [ i ] , filter ) ; } return value ; } } ) ; }	return copy ;
SourceInfo sourceInfo ( ) { <CTX> SourceInfo sourceInfo ( ) { return fsource . sourceInfo ( ) ; }	public SourceInfo sourceInfo ( ) {
re = new NativeRegExp ( scope , src , opt ) ; <CTX> private static Object matchOrReplace ( Context cx , Scriptable thisObj , Object [ ] args , Function funObj , GlobData data ) throws JavaScriptException { NativeRegExp re ; String str = ScriptRuntime . toString ( thisObj ) ; data . str = str ; RegExpImpl reImpl = RegExpImpl . getRegExpImpl ( cx ) ; if ( args [ 0 ] instanceof NativeRegExp ) { re = ( NativeRegExp ) args [ 0 ] ; } else { String src = ScriptRuntime . toString ( args [ 0 ] ) ; String opt ; if ( data . optarg < args . length ) { args [ 0 ] = src ; opt = ScriptRuntime . toString ( args [ data . optarg ] ) ; } else { opt = null ; } Scriptable scope = ScriptableObject . getTopLevelScope ( funObj ) ; re = new NativeRegExp ( scope , src , opt ) ; } data . regexp = re ; data . global = ( re . getFlags ( ) & NativeRegExp . GLOB ) != 0 ; int [ ] indexp = { 0 } ; Object result = null ; if ( data . mode == GlobData . GLOB_SEARCH ) { result = re . executeRegExp ( funObj , str , indexp , true ) ; if ( result != null && result . equals ( Boolean . TRUE ) ) result = new Integer ( reImpl . leftContext . length ) ; else result = new Integer ( - 1 ) ; } else if ( data . global ) { re . setLastIndex ( 0 ) ; for ( int count = 0 ; indexp [ 0 ] <= str . length ( ) ; count ++ ) { result = re . executeRegExp ( funObj , str , indexp , true ) ; if ( result == null || ! result . equals ( Boolean . TRUE ) ) break ; data . doGlobal ( funObj , count ) ; if ( reImpl . lastMatch . length == 0 ) { if ( indexp [ 0 ] == str . length ( ) ) break ; indexp [ 0 ] ++ ; } } } else { result = re . executeRegExp ( funObj , str , indexp , data . mode == GlobData . GLOB_REPLACE ) ; } return result ; }	re = new NativeRegExp ( cx , scope , src , opt ) ;
if ( EventUtil . isDramaticalChange ( events ) ) { projectPane . rebuildTree ( new Runnable ( ) { public void run ( ) { SModelEventVisitor visitor = new SModelEventVisitor ( ) { public void visitRootEvent ( SModelRootEvent event ) { SModelTreeNode . this . update ( ) ; } <CTX> public void modelChangedInCommand ( final List < SModelEvent > events , EditorContext editorContext ) { ProjectPane projectPane = getOperationContext ( ) . getComponent ( ProjectPane . class ) ; if ( EventUtil . isDramaticalChange ( events ) ) { projectPane . rebuildTree ( new Runnable ( ) { public void run ( ) { SModelEventVisitor visitor = new SModelEventVisitor ( ) { public void visitRootEvent ( SModelRootEvent event ) { SModelTreeNode . this . update ( ) ; } public void visitChildEvent ( SModelChildEvent event ) { updateTreeWithRoot ( event . getParent ( ) ) ; } public void visitPropertyEvent ( SModelPropertyEvent event ) { } public void visitReferenceEvent ( SModelReferenceEvent event ) { } } ; for ( SModelEvent event : events ) { event . accept ( visitor ) ; } / / ( ( DefaultTreeModel ) myTree . getModel ( ) ) . nodeStructureChanged ( SModelTreeNode . this . getParent ( ) ) ; } } ) ; } }	projectPane . rebuildTree ( new Runnable ( ) { public void run ( ) { SModelEventVisitor visitor = new SModelEventVisitor ( ) { public void visitRootEvent ( SModelRootEvent event ) { SModelTreeNode . this . update ( ) ; }
if ( rt . getState ( ) == ReducedModelStates . FREE && Character . isWhitespace ( text . charAt ( index + keyword . length ( ) ) ) ) { <CTX> private synchronized int_findKeywordAtToplevel ( String keyword , String text , int textOffset ) { int oldLocation = getCurrentLocation ( ) ; int index = 0 ; boolean done = false ; while ( ! done ) { index = text . indexOf ( keyword , index ) ; if ( index == - 1 ) { / / not found done = true ; break ; } else { / / found a match , check quality setCurrentLocation ( textOffset + index ) ; / / check that the keyword is not in a comment and is followed by whitespace ReducedToken rt =_reduced . currentToken ( ) ; if ( rt . getState ( ) == ReducedModelStates . FREE && Character . isWhitespace ( text . charAt ( index + keyword . length ( ) ) ) ) { / / if ( !_isCommentedOrSpace ( index , text ) ) { done = true ; if ( ! posNotInBlock ( index ) ) { / / in a paren phrase , gone too far index = - 1 ; } } else { index ++ ; / / move past so we can search again } } } setCurrentLocation ( oldLocation ) ; return index ; }	int indexPastKeyword = index + keyword . length ( ) ; if ( indexPastKeyword < text . length ( ) ) { if ( rt . getState ( ) == ReducedModelStates . FREE && Character . isWhitespace ( text . charAt ( indexPastKeyword ) ) ) { done = true ; if ( ! posNotInBlock ( index ) ) { index = - 1 ; } } else { index ++ ; } } else { index = - 1 ;
ArcRenderEvent are = new ArcRenderEvent ( source ) ; <CTX> public PrimitiveRenderEvent copy ( ) throws ChartException { ArcRenderEvent are = new ArcRenderEvent ( source ) ; if ( outline != null ) { are . setOutline ( LineAttributesImpl . copyInstance ( outline ) ) ; } if ( ifBackground != null ) { are . setBackground ( ( Fill ) EcoreUtil . copy ( ifBackground ) ) ; } if ( loTopLeft != null ) { are . setTopLeft ( LocationImpl . copyInstance ( loTopLeft ) ) ; } are . setStyle ( iStyle ) ; are . setWidth ( dWidth ) ; are . setHeight ( dHeight ) ; are . setStartAngle ( dStartInDegrees ) ; are . setEndAngle ( dExtentInDegrees ) ; are . setInnerRadius ( dInnerRadius ) ; are . setOuterRadius ( dOuterRadius ) ; return are ; }	ArcRenderEvent are = new ArcRenderEvent ( ( StructureSource ) source ) ;
Display . getCurrent ( ) . asyncExec ( new UpdateRequest ( ) ) ; <CTX> protected void queueWork ( ) { if ( ! updateQueued ) { Display . getCurrent ( ) . asyncExec ( new UpdateRequest ( ) ) ; updateQueued = true ; } }	Display display = Display . getCurrent ( ) == null ? Display . getDefault ( ) : Display . getCurrent ( ) ; display . asyncExec ( new UpdateRequest ( ) ) ;
delegate . setDisableMessageTimestamp ( disableMessageTimestamp ) ; <CTX> public void setDisableMessageTimestamp ( boolean disableMessageTimestamp ) throws JMSException { checkPreConditions ( ) ; delegate . setDisableMessageTimestamp ( disableMessageTimestamp ) ; }	_ delegate . setDisableMessageTimestamp ( disableMessageTimestamp ) ;
Set referencingRelationships = new PropertyListSet ( ) ; <CTX> public Set getReferencingRelationships ( ) { Set referencingRelationships = new PropertyListSet ( ) ; Iterator modelsIter = getModel ( ) . getModelGroup ( ) . getModels ( ) . iterator ( ) ; while ( modelsIter . hasNext ( ) ) { EOModel model = ( EOModel ) modelsIter . next ( ) ; Iterator entitiesIter = model . getEntities ( ) . iterator ( ) ; while ( entitiesIter . hasNext ( ) ) { EOEntity entity = ( EOEntity ) entitiesIter . next ( ) ; if ( ! entity . equals ( this ) ) { Iterator relationshipsIter = entity . getRelationships ( ) . iterator ( ) ; while ( relationshipsIter . hasNext ( ) ) { EORelationship relationship = ( EORelationship ) relationshipsIter . next ( ) ; if ( relationship . isRelatedTo ( this ) ) { referencingRelationships . add ( relationship ) ; } } } } } return referencingRelationships ; }	Set referencingRelationships = new HashSet ( ) ;
request . setAttribute ( DocumentComposer . REQUEST_ATTRIBUTE_OR_PARAMETER__ FLOW , flowSessionAttributeName ) ; <CTX> private void dispatchToPublisherUserBrowser ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { final String flowSessionAttributeName = HttpSessionUtils . getSessionAttributeNameFromRequest ( request , DocumentComposer . REQUEST_ATTRIBUTE_OR_PARAMETER__ FLOW ) ; dispatchToUserBrowser ( request , response , true , new UserFinder . SelectUserCommand ( ) { public void selectUser ( UserDomainObject selectedUser , HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { document . setPublisher ( selectedUser ) ; request . setAttribute ( DocumentComposer . REQUEST_ATTRIBUTE_OR_PARAMETER__ FLOW , flowSessionAttributeName ) ; dispatchToFirstPage ( request , response ) ; } } ) ; }	request . setAttribute ( REQUEST_ATTRIBUTE_OR_PARAMETER__ FLOW , flowSessionAttributeName ) ;
return ( int ) ( ( ( bytes [ 0 ] & 0 xff ) << 8 ) | ( 0 xff & bytes [ 1 ] ) ) ; <CTX> static public int toUnsignedShort ( byte [ ] bytes , boolean bigEndian ) { if ( bytes . length == 1 ) { return ( int ) ( 0 xff & bytes [ 0 ] ) ; } else if ( bigEndian ) { return ( int ) ( ( ( bytes [ 0 ] & 0 xff ) << 8 ) | ( 0 xff & bytes [ 1 ] ) ) ; } else { return ( int ) ( ( ( bytes [ 1 ] & 0 xff ) << 8 ) | ( 0 xff & bytes [ 0 ] ) ) ; } }	return ( ( bytes [ 0 ] & 0 xff ) << 8 ) | ( 0 xff & bytes [ 1 ] ) ;
unusableAdapters . add ( parameterTypes [ i ] ) ; <CTX> private List getAllSatisfiableConstructors ( List constructors , PicoContainer picoContainer ) throws PicoIntrospectionException , AssignabilityRegistrationException , NotConcreteRegistrationException { List satisfiableConstructors = new ArrayList ( ) ; Set unusableAdapters = new HashSet ( ) ; for ( Iterator iterator = constructors . iterator ( ) ; iterator . hasNext ( ) ; ) { boolean failedDependency = false ; Constructor constructor = ( Constructor ) iterator . next ( ) ; Class [ ] parameterTypes = constructor . getParameterTypes ( ) ; Parameter [ ] currentParameters = parameters != null ? parameters : createDefaultParameters ( parameterTypes , picoContainer ) ; for ( int i = 0 ; i < currentParameters . length ; i ++ ) { ComponentAdapter adapter = currentParameters [ i ] . resolveAdapter ( picoContainer ) ; if ( adapter == null ) { failedDependency = true ; unusableAdapters . add ( parameterTypes [ i ] ) ; } else { / / we can t depend on ourself if ( adapter . equals ( this ) ) { failedDependency = true ; unusableAdapters . add ( parameterTypes [ i ] ) ; } if ( getComponentKey ( ) . equals ( adapter . getComponentKey ( ) ) ) { failedDependency = true ; unusableAdapters . add ( parameterTypes [ i ] ) ; } } } if ( ! failedDependency ) { satisfiableConstructors . add ( constructor ) ; } } if ( satisfiableConstructors . isEmpty ( ) ) { throw new UnsatisfiableDependenciesException ( getComponentImplementation ( ) , unusableAdapters ) ; } return satisfiableConstructors ; }	unsatisfiableDependencyTypes . add ( parameterTypes [ i ] ) ;
if ( memberDefn . getTypeCode ( ) == PropertyType . NAME_TYPE ) <CTX> private List doCheckStructureList ( Module module , DesignElement element , IPropertyDefn propDefn , List list , IStructure toAdd ) { boolean checkList = toAdd == null ; List errorList = new ArrayList ( ) ; if ( list == null || list . size ( ) == 0 ) return errorList ; assert propDefn != null ; assert propDefn . getTypeCode ( ) == PropertyType . STRUCT_TYPE ; / / Get the unique member whose value should be unique in the / / structure list . / / The type of unique member is name property type . / / Note : The first unique member is considered . PropertyDefn uniqueMember = null ; Iterator iter = propDefn . getStructDefn ( ) . getPropertyIterator ( ) ; while ( iter . hasNext ( ) ) { PropertyDefn memberDefn = ( PropertyDefn ) iter . next ( ) ; if ( memberDefn . getTypeCode ( ) == PropertyType . NAME_TYPE ) { uniqueMember = memberDefn ; break ; } } HashSet values = new HashSet ( ) ; / / Check whether there two structure has the same value of / / the unique member . for ( int i = 0 ; i < list . size ( ) ; i ++ ) { Structure struct = ( Structure ) list . get ( i ) ; if ( checkList ) errorList . addAll ( struct . validate ( module , element ) ) ; if ( uniqueMember != null ) { String value = ( String ) struct . getProperty ( module , uniqueMember ) ; if ( values . contains ( value ) ) { if ( checkList ) errorList . add ( new PropertyValueException ( element , propDefn , value , PropertyValueException . DESIGN_EXCEPTION_VALUE_EXISTS ) ) ; } else { values . add ( value ) ; } } } / / If the toAdd structure is added the structure list , check whether / / there is a structure in the list has the same value of the unique / / member . if ( uniqueMember != null && toAdd != null ) { String value = ( String ) toAdd . getProperty ( module , uniqueMember ) ; if ( values . contains ( value ) ) { errorList . add ( new PropertyValueException ( element , propDefn . getName ( ) , value , PropertyValueException . DESIGN_EXCEPTION_VALUE_EXISTS ) ) ; } } return errorList ; }	Iterator iter = propDefn . getStructDefn ( ) . getPropertyIterator ( ) ; while ( iter . hasNext ( ) )
if ( mode . equalsIgnoreCase ( C_COPYMODE_SIBLING ) ) { <CTX> public void setDialogCopyFolderMode ( String mode ) { int copyMode = I_CmsConstants . C_COPY_AS_NEW ; if ( mode . equalsIgnoreCase ( C_COPYMODE_SIBLING ) ) { copyMode = I_CmsConstants . C_COPY_AS_SIBLING ; } else if ( mode . equalsIgnoreCase ( C_COPYMODE_PRESERVE ) ) { copyMode = I_CmsConstants . C_COPY_PRESERVE_SIBLING ; } setDialogCopyFolderMode ( copyMode ) ; }	if ( mode . equalsIgnoreCase ( COPYMODE_SIBLING ) ) {
if ( suggestReset ) <CTX> public void removeExtension ( IExtension extension , Object [ ] objects ) { boolean suggestReset = false ; for ( int i = 0 ; i < objects . length ; i ++ ) { if ( objects [ i ] instanceof DirtyPerspectiveMarker ) { String id = ( ( DirtyPerspectiveMarker ) objects [ i ] ) . perspectiveId ; if ( ! dirtyPerspectives . remove ( id ) ) / / if we are dirty , cancel the dirty state dirtyPerspectives . add ( id ) ; / / otherwise we will be dirty PerspectiveDescriptor persp = ( PerspectiveDescriptor ) getPerspective ( ) ; if ( persp == null || persp . hasCustomDefinition ( ) ) continue ; if ( persp . getId ( ) . equals ( id ) ) suggestReset = true ; } } if ( suggestReset ) suggestReset ( ) ; }	if ( suggestReset ) {
d = Math . ceil ( d ) ; break ; <CTX> public RealNum toInt ( int rounding_mode ) { double d = doubleValue ( ) ; switch ( rounding_mode ) { case FLOOR : d = Math . floor ( d ) ; break ; case CEILING : d = Math . ceil ( d ) ; break ; case TRUNCATE : d = d < 0 . 0 ? Math . ceil ( d ) : Math . floor ( d ) ; break ; case ROUND : d -= Math . IEEEremainder ( d , 1 . 0 ) ; break ; } return new DFloNum ( d ) ; }	return Math . ceil ( d ) ;
if ( ! adaptee . isInitialised ( ) ) { <CTX> public void engineNextBytes ( byte [ ] bytes ) { if ( ! adaptee . isInitialised ( ) ) { this . engineSetSeed ( new byte [ 0 ] ) ; } try { adaptee . nextBytes ( bytes , 0 , bytes . length ) ; } catch ( LimitReachedException ignored ) { } }	if ( ! adaptee . isInitialised ( ) )
return aci . current ( ) ; <CTX> public char previous ( ) { if ( getIndex ( ) > begin ) { return aci . previous ( ) ; } else { return aci . current ( ) ; } }	return CharacterIterator . DONE ;
if ( broughtToTop ) <CTX> public void bringToTop ( IWorkbenchPart part ) { / / Sanity check . Perspective persp = getActivePerspective ( ) ; if ( persp == null || ! certifyPart ( part ) ) return ; / / If zoomed then ignore . if ( isZoomed ( ) && partChangeAffectsZoom ( part ) ) return ; / / Move part . boolean broughtToTop = false ; if ( part instanceof IEditorPart ) { broughtToTop = getEditorManager ( ) . setVisibleEditor ( ( IEditorPart ) part , false ) ; if ( lastActiveEditor != null && broughtToTop ) { String newID = part . getSite ( ) . getId ( ) ; String oldID = lastActiveEditor . getSite ( ) . getId ( ) ; if ( newID != oldID ) { deactivateLastEditor ( ) ; lastActiveEditor = null ; updateActionBars ( ) ; } } } else if ( part instanceof IViewPart ) { broughtToTop = persp . bringToTop ( ( IViewPart ) part ) ; } if ( broughtToTop ) firePartBroughtToTop ( part ) ; }	if ( broughtToTop ) { activationList . setActive ( part ) ;
Object old ; if ( value != null ) old = super . put ( key , value ) ; else old = super . remove ( key ) ; <CTX> public Object put ( Object key , Object value ) { Object old ; if ( value != null ) old = super . put ( key , value ) ; else old = super . remove ( key ) ; if ( key instanceof String && old != value ) firePropertyChange ( ( String ) key , old , value ) ; return old ; }	Object old = checkAndPut ( key , value ) ;
mWasOnAir = ProgramUtilities . isOnAir ( this ) ; return mWasOnAir ; <CTX> public boolean isOnAir ( ) { mWasOnAir = ProgramUtilities . isOnAir ( this ) ; return mWasOnAir ; }	return ProgramUtilities . isOnAir ( this ) ;
queue . addLast ( token ) ; } <CTX> public void push ( Object token ) { queue . addLast ( token ) ; }	try { queue [ ++ rear ] = token ; items ++ ; } catch ( ArrayIndexOutOfBoundsException ex ) { Object [ ] holdQueue = new Object [ max + maxIncrement ] ; System . arraycopy ( queue , 0 , holdQueue , 0 , max ) ; queue = holdQueue ; max += maxIncrement ; queue [ rear ] = token ; items ++ ; } }
void translateFrom ( Series sourceSeries , Chart chart ) ; <CTX> void translateFrom ( Series sourceSeries , Chart chart ) ;	void translateFrom ( Series sourceSeries , int iSeriesDefinitionIndex , Chart chart ) ;
Elf . Symbol [ ] ret = ( Elf . Symbol [ ] ) v . toArray ( new Elf . Symbol [ 0 ] ) ; Arrays . sort ( ret , new SymbolSortCompare ( ) ) ; return ret ; } <CTX> public Elf . Symbol [ ] getExternalObjects ( ) throws IOException { Vector v = new Vector ( ) ; loadSymbols ( ) ; loadSections ( ) ; for ( int i = 0 ; i < dynsyms . length ; i ++ ) { if ( dynsyms [ i ] . st_bind ( ) == Elf . Symbol . STB_GLOBAL && dynsyms [ i ] . st_type ( ) == Elf . Symbol . STT_OBJECT ) { int idx = dynsyms [ i ] . st_shndx ; if ( idx < 0 ) continue ; if ( sections [ idx ] . sh_type == Elf . Section . SHT_NULL ) v . add ( dynsyms [ i ] ) ; } } Elf . Symbol [ ] ret = ( Elf . Symbol [ ] ) v . toArray ( new Elf . Symbol [ 0 ] ) ; Arrays . sort ( ret , new SymbolSortCompare ( ) ) ; return ret ; }	if ( sections [ idx ] . sh_type == Elf . Section . SHT_NULL ) v . add ( dynsyms [ i ] ) ; } } Elf . Symbol [ ] ret = ( Elf . Symbol [ ] ) v . toArray ( new Elf . Symbol [ 0 ] ) ; Arrays . sort ( ret , new SymbolSortCompare ( ) ) ; return ret ; }
Tree [ ] newClassParents = gen . mkParentConstrs ( classDef . pos , newParents , parentArgs ) ; <CTX> protected Tree makeClass ( ClassDef classDef ) { Symbol ifaceSym = classDef . symbol ( ) ; Symbol classSym = phase . getClassSymbol ( ifaceSym ) ; TreeList newClassBody = new TreeList ( ) ; Template classImpl = classDef . impl ; Tree [ ] classBody = classImpl . body ; Map classMemberMap = phase . getClassMemberMap ( classSym ) ; assert thisTypeSubst == null ; thisTypeSubst = new Type . SubstThisMap ( ifaceSym , classSym ) ; for ( int i = 0 ; i < classBody . length ; ++ i ) { Tree t = classBody [ i ] ; Symbol tSym = t . symbol ( ) ; if ( t . definesSymbol ( ) && ! ( classMemberMap . containsKey ( tSym ) || tSym . isConstructor ( ) ) ) continue ; Tree newT = transform ( t ) ; if ( t . definesSymbol ( ) && classMemberMap . containsKey ( tSym ) ) newT . setSymbol ( ( Symbol ) classMemberMap . get ( tSym ) ) ; newClassBody . append ( newT ) ; } thisTypeSubst = null ; Tree [ ] [ ] oldParentArgs = extractParentArgs ( classImpl . parents ) ; Tree [ ] [ ] parentArgs = new Tree [ oldParentArgs . length + 1 ] [ ] ; System . arraycopy ( oldParentArgs , 0 , parentArgs , 0 , oldParentArgs . length ) ; parentArgs [ oldParentArgs . length ] = Tree . EMPTY_ARRAY ; global . nextPhase ( ) ; Type [ ] newParents = classSym . parents ( ) ; global . prevPhase ( ) ; Tree [ ] newClassParents = gen . mkParentConstrs ( classDef . pos , newParents , parentArgs ) ; Symbol local = classDef . impl . symbol ( ) ; local . setOwner ( classSym ) ; return gen . ClassDef ( classSym , newClassParents , local , newClassBody . toArray ( ) ) ; }	newParents [ newParents . length - 1 ] = gen . mkParentConstr ( classDef . pos , ifaceType ) ;
image . setSourceAndClearSize ( new ImageDomainObject . FileDocumentImageSource ( documentMapper . getDocumentReference ( fileDocument . getId ( ) ) ) ) ; <CTX> private void goToImageAdder ( final DocumentMapper documentMapper , final TextDocumentDomainObject document , UserDomainObject user , final ImageDomainObject image , final int imageIndex , HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { FileDocumentDomainObject fileDocument = ( FileDocumentDomainObject ) documentMapper . createDocumentOfTypeFromParent ( DocumentDomainObject . DOCTYPE_FILE , document , user ) ; final EditFileDocumentPageFlow . ArrayMimeTypeRestriction mimeTypeRestriction = new EditFileDocumentPageFlow . ArrayMimeTypeRestriction ( IMAGE_MIME_TYPES , ERROR_MESSAGE___ONLY_ALLOWED_TO_UPLOAD_IMAGES ) ; DocumentPageFlow . SaveDocumentCommand saveNewImageFileDocument = new CreateDocumentPageFlow . SaveDocumentCommand ( ) { public void saveDocument ( DocumentDomainObject document , UserDomainObject user ) { FileDocumentDomainObject fileDocument = ( FileDocumentDomainObject ) document ; Map files = fileDocument . getFiles ( ) ; for ( Iterator iterator = files . values ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { FileDocumentDomainObject . FileDocumentFile file = ( FileDocumentDomainObject . FileDocumentFile ) iterator . next ( ) ; file . setCreatedAsImage ( true ) ; } FileDocumentDomainObject . FileDocumentFile file = ( FileDocumentDomainObject . FileDocumentFile ) files . values ( ) . iterator ( ) . next ( ) ; if ( null != file ) { fileDocument . setHeadline ( file . getFilename ( ) ) ; fileDocument . setStatus ( DocumentDomainObject . STATUS_PUBLICATION_APPROVED ) ; documentMapper . saveNewDocument ( document , user ) ; image . setSourceAndClearSize ( new ImageDomainObject . FileDocumentImageSource ( documentMapper . getDocumentReference ( fileDocument . getId ( ) ) ) ) ; } } } ; DispatchCommand returnToImageEditPageCommand = new DispatchCommand ( ) { public void dispatch ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { goToImageEditPage ( document , imageIndex , image , request , response ) ; } } ; DocumentPageFlow pageFlow = new EditFileDocumentPageFlow ( fileDocument , getServletContext ( ) , returnToImageEditPageCommand , saveNewImageFileDocument , mimeTypeRestriction ) ; pageFlow . dispatch ( request , response ) ; }	image . setSourceAndClearSize ( new ImageDomainObject . FileDocumentImageSource ( documentMapper . getDocumentReference ( fileDocument ) ) ) ;
OperationHistoryEvent . ABOUT_TO_UNDO , this , operation ) ; <CTX> protected void notifyAboutToUndo ( IUndoableOperation operation ) { OperationHistoryEvent event = new OperationHistoryEvent ( OperationHistoryEvent . ABOUT_TO_UNDO , this , operation ) ; for ( int i = 0 ; i < fListeners . size ( ) ; i ++ ) ( ( IOperationHistoryListener ) fListeners . get ( i ) ) . historyNotification ( event ) ; }	OperationHistoryEvent . ABOUT_TO_UNDO , this , op ) ; preNotifyOperation ( op , event ) ;
this . input = input ; return reset ( ) ; <CTX> public Matcher reset ( CharSequence input ) { this . input = input ; return reset ( ) ; }	position = 0 ; match = null ; return this ;
viewFormTopLeftProxy . setTarget ( null ) ; <CTX> public void setTopLeft ( Control topLeft ) { if ( topLeftCache . getControl ( ) == topLeft ) { return ; } removeDisposeListener ( topLeftCache . getControl ( ) ) ; topLeftCache . setControl ( topLeft ) ; / / The top - left control always goes directly in the ViewForm if ( topLeft != null ) { topLeft . addDisposeListener ( prematureDisposeListener ) ; viewFormTopLeftProxy . setTarget ( topLeftCache ) ; viewForm . setTopLeft ( viewFormTopLeftProxy . getControl ( ) ) ; } else { viewFormTopLeftProxy . setTarget ( null ) ; viewForm . setTopLeft ( null ) ; } }	viewFormTopLeftProxy . setTargetControl ( null ) ;
return new CachedResultSet ( this , resultMetadata , rs ) ; <CTX> public IResultIterator execute ( ) throws DataException { assert odaStatement != null ; this . setInputParameterBinding ( ) ; / / Execute the prepared statement if ( ! odaStatement . execute ( ) ) throw new DataException ( ResourceConstants . NO_RESULT_SET ) ; ResultSet rs = odaStatement . getResultSet ( ) ; / / If we did not get a result set metadata at prepare ( ) time , get it now if ( resultMetadata == null ) { resultMetadata = rs . getMetaData ( ) ; if ( resultMetadata == null ) throw new DataException ( ResourceConstants . METADATA_NOT_AVAILABLE ) ; } / / Initialize CachedResultSet using the ODA result set if ( DataSetCacheManager . getInstance ( ) . doesSaveToCache ( ) == false ) return new CachedResultSet ( this , resultMetadata , rs ) ; else return new CachedResultSet ( this , resultMetadata , new DataSetResultCache ( rs , resultMetadata ) ) ; }	return new CachedResultSet ( this , resultMetadata , rs , eventHandler ) ;
instance . add ( path , members ) ; <CTX> public static void add ( String text , String path ) { RubyMembers members = RubyParser . getMembers ( text , path , null , true ) ; instance . add ( path , members ) ; }	if ( ! members . containsErrors ( ) ) { instance . add ( path , members ) ; }
Collections . sort ( propList , new CompletitionProposalComparator ( ) ) ; <CTX> public void addTemplateProposals ( ITextViewer viewer , int documentOffset , List propList ) { ICompletionProposal [ ] templateProposals = computeCompletionProposals ( viewer , documentOffset ) ; for ( int j = 0 ; j < templateProposals . length ; j ++ ) { propList . add ( templateProposals [ j ] ) ; } Collections . sort ( propList , new CompletitionProposalComparator ( ) ) ; }	Collections . sort ( propList , new CompletionProposalComparator ( ) ) ;
return new BigDecimal ( ( ( Double ) obj ) . doubleValue ( ) ) . setScale ( 16 , BigDecimal . ROUND_DOWN ) ; <CTX> public Object convert ( Object obj , String param ) { return new BigDecimal ( ( ( Double ) obj ) . doubleValue ( ) ) . setScale ( 16 , BigDecimal . ROUND_DOWN ) ; }	return new BigDecimal ( ( ( Double ) obj ) . toString ( ) ) ;
if ( ! isListIndexExpression ( ref , collection ) ) { indexVariableUsedOnlyAsIndex = false ; } <CTX> public void visitReferenceExpression ( @ NotNull PsiReferenceExpression ref ) { if ( ! indexVariableUsedOnlyAsIndex ) { return ; } super . visitReferenceExpression ( ref ) ; final PsiElement element = ref . resolve ( ) ; if ( ! indexVariable . equals ( element ) ) { return ; } if ( ! isListIndexExpression ( ref , collection ) ) { indexVariableUsedOnlyAsIndex = false ; } }	if ( collection . equals ( element ) && ! isListReferenceInIndexExpression ( ref , collection ) ) { indexVariableUsedOnlyAsIndex = false ; }
_ interactionsPane . requestFocus ( ) ; <CTX> public void requestFocus ( ) {_interactionsPane . requestFocus ( ) ; }	_ consolePane . requestFocus ( ) ;
case Id_toString : return realThis ( thisObj , f ) . jsFunction_toString ( toBase ( args , 0 ) ) ; <CTX> public Object execMethod ( int methodId , IdFunction f , Context cx , Scriptable scope , Scriptable thisObj , Object [ ] args ) throws JavaScriptException { switch ( methodId ) { case Id_constructor : return jsConstructor ( args , thisObj == null ) ; case Id_toString : return realThis ( thisObj , f ) . jsFunction_toString ( toBase ( args , 0 ) ) ; case Id_valueOf : return wrap_double ( realThis ( thisObj , f ) . jsFunction_valueOf ( ) ) ; case Id_toLocaleString : return realThis ( thisObj , f ) . jsFunction_toLocaleString ( toBase ( args , 0 ) ) ; case Id_toFixed : return realThis ( thisObj , f ) . jsFunction_toFixed ( cx , args ) ; case Id_toExponential : return realThis ( thisObj , f ) . jsFunction_toExponential ( cx , args ) ; case Id_toPrecision : return realThis ( thisObj , f ) . jsFunction_toPrecision ( cx , args ) ; } return super . execMethod ( methodId , f , cx , scope , thisObj , args ) ; }	case Id_valueOf : return wrap_double ( realThis ( thisObj , f ) . jsFunction_valueOf ( ) ) ;
holder = holderFactory . createHolder ( official_type ) ; <CTX> public void from_any ( Any an_any ) throws TypeMismatch , InvalidValue { checkType ( official_type , an_any . type ( ) ) ; Streamable a_holder = an_any . extract_Streamable ( ) ; if ( a_holder == null ) { throw new InvalidValue ( ISNULL ) ; } else if ( a_holder instanceof universalHolder ) { holder = holderFactory . createHolder ( official_type ) ; if ( holder == null ) holder = holderFactory . createHolder ( final_type ) ; if ( holder == null ) holder = ( ( universalHolder ) a_holder ) . Clone ( ) ; else { InputStream in = an_any . create_input_stream ( ) ; holder ._read ( in ) ; try { in . close ( ) ; } catch ( IOException ex ) { throw new Unexpected ( ex ) ; } } } else { try { InputStream in = an_any . create_input_stream ( ) ; holder = ( Streamable ) a_holder . getClass ( ) . newInstance ( ) ; holder ._read ( in ) ; in . close ( ) ; } catch ( Exception ex ) { TypeMismatch t = new TypeMismatch ( ) ; t . initCause ( ex ) ; throw t ; } } valueChanged ( ) ; }	holder = HolderLocator . createHolder ( official_type ) ;
resolved = structure ; <CTX> public void resolve ( Structure structure ) { name = null ; resolved = structure ; }	resolved = ( Structure ) structure ;
return field_1_footer_len ; <CTX> public byte getFooterLength ( ) { return field_1_footer_len ; }	return ( short ) ( 0 xFF & field_1_footer_len ) ;
if ( jq . Bootstrapping ) return obj_trav . getInstanceFieldValue ( o , f ) ; <CTX> public static Object getfield ( Object o , jq_InstanceField f ) { if ( jq . Bootstrapping ) return obj_trav . getInstanceFieldValue ( o , f ) ; jq_Type t = f . getType ( ) ; if ( t . isReferenceType ( ) ) return getfield_A ( o , f ) ; if ( t == jq_Primitive . INT ) return new Integer ( getfield_I ( o , f ) ) ; if ( t == jq_Primitive . FLOAT ) return new Float ( getfield_F ( o , f ) ) ; if ( t == jq_Primitive . LONG ) return new Long ( getfield_L ( o , f ) ) ; if ( t == jq_Primitive . DOUBLE ) return new Double ( getfield_D ( o , f ) ) ; if ( t == jq_Primitive . BYTE ) return new Byte ( getfield_B ( o , f ) ) ; if ( t == jq_Primitive . CHAR ) return new Character ( getfield_C ( o , f ) ) ; if ( t == jq_Primitive . SHORT ) return new Short ( getfield_S ( o , f ) ) ; if ( t == jq_Primitive . BOOLEAN ) return new Boolean ( getfield_Z ( o , f ) ) ; jq . UNREACHABLE ( ) ; return null ; }	if ( ! jq . RunningNative ) return obj_trav . getInstanceFieldValue ( o , f ) ;
{ super ( ) ; extendedMetaData = ExtendedMetaData . INSTANCE ; } <CTX> public TypeResourceFactoryImpl ( ) { super ( ) ; extendedMetaData = ExtendedMetaData . INSTANCE ; }	{ super ( ) ; }
if ( ! modifiable ) <CTX> public String getPrivateKey ( ) { if ( ! modifiable ) return null ; return privateKey ; }	if ( ! this . modifiable )
ElementDefn obj = ( ( ElementDefn ) type ) . parent ; <CTX> public boolean isKindOf ( IElementDefn type ) { if ( type == this ) return true ; if ( type == null ) return false ; ElementDefn obj = ( ( ElementDefn ) type ) . parent ; while ( obj != null ) { if ( obj == this ) return true ; obj = obj . parent ; } return false ; }	ElementDefn obj = this . parent ;
sink . text ( caption ) ; <CTX> protected void tableCaption ( String caption ) { sink . tableCaption ( ) ; sink . text ( caption ) ; sink . tableCaption_( ) ; }	text ( caption ) ;
boolean stringIsCompilableUnit ( String str ) { <CTX> boolean stringIsCompilableUnit ( String str ) { DimIProxy action = new DimIProxy ( this , IPROXY_STRING_IS_COMPILABLE ) ; action . text = str ; action . withContext ( ) ; return action . booleanResult ; }	public boolean stringIsCompilableUnit ( String str ) {
return 0 ; <CTX> public int getSelectionMode ( ) { return 0 ; / / TODO }	return selectionMode ;
Iterator itr = listeners . iterator ( ) ; while ( itr . hasNext ( ) ) { ThreadListener listener = ( ThreadListener ) itr . next ( ) ; <CTX> synchronized void notifyRightGiven ( Scheduler scheduler ) { String id = scheduler . getName ( ) ; Iterator itr = listeners . iterator ( ) ; while ( itr . hasNext ( ) ) { ThreadListener listener = ( ThreadListener ) itr . next ( ) ; listener . rightGiven ( id ) ; } }	for ( int i = 0 , n = listeners . size ( ) ; i < n ; i ++ ) { ThreadListener listener = ( ThreadListener ) listeners . get ( i ) ;
return context . declaration . getExtractor ( ) . getDoubleValue ( left ) < ( ( DoubleVariableContextEntry ) context ) . right ; <CTX> public boolean evaluateCachedRight ( final VariableContextEntry context , final Object left ) { / / TODO : we are not handling delta right now . . . maybe we should return context . declaration . getExtractor ( ) . getDoubleValue ( left ) < ( ( DoubleVariableContextEntry ) context ) . right ; }	return context . getVariableDeclaration ( ) . getExtractor ( ) . getDoubleValue ( left ) < ( ( DoubleVariableContextEntry ) context ) . right ;
if ( OdaDataSource . PRIVATE_DRIVER_PROPERTIES_PROP <CTX> ExtendedPropertyState ( ModuleParserHandler theHandler , DesignElement element , PropertyDefn propDefn , ArrayList list ) { super ( theHandler , element , propDefn , list ) ; / / till now , there is structure ODAProperty can be written as / / ex - property . if ( OdaDataSource . PRIVATE_DRIVER_PROPERTIES_PROP . equalsIgnoreCase ( propDefn . getName ( ) ) ) struct = new ExtendedProperty ( ) ; else handler . getErrorHandler ( ) . semanticError ( new DesignParserException ( DesignParserException . DESIGN_EXCEPTION_WRONG_EXTENDED_PROPERTY_TYPE ) ) ; }	if ( IOdaDataSourceModel . PRIVATE_DRIVER_PROPERTIES_PROP
return ( pos < array . length ) ; <CTX> public boolean hasNext ( ) { return ( pos < array . length ) ; }	return ( pos < size ) ;
RubyNumeric other = numericValue ( num ) ; if ( other instanceof RubyFloat ) { return RubyFloat . newFloat ( getRuntime ( ) , getDoubleValue ( ) ) . op_mul ( other ) ; } return bigNorm ( getRuntime ( ) , getValue ( ) . multiply ( bigIntValue ( other ) ) ) ; <CTX> public RubyNumeric op_mul ( IRubyObject num ) { RubyNumeric other = numericValue ( num ) ; if ( other instanceof RubyFloat ) { return RubyFloat . newFloat ( getRuntime ( ) , getDoubleValue ( ) ) . op_mul ( other ) ; } return bigNorm ( getRuntime ( ) , getValue ( ) . multiply ( bigIntValue ( other ) ) ) ; }	return numericValue ( num ) . multiplyWith ( this ) ;
this ( new com . exedio . cope . AttributeValue [ ] { new com . exedio . cope . AttributeValue ( DeleteItem . name , name ) , } ) ; throwInitialMandatoryViolationException ( ) ; } / * * <CTX> * / public DeleteItem ( final java . lang . String name ) throws com . exedio . cope . MandatoryViolationException { this ( new com . exedio . cope . AttributeValue [ ] { new com . exedio . cope . AttributeValue ( DeleteItem . name , name ) , } ) ; throwInitialMandatoryViolationException ( ) ; } / * *	this ( ) ; this . name = name ; }
String fileName ) <CTX> GenericModuleParserHandler ( DesignSession theSession , URL systemID , String fileName ) { super ( theSession , fileName ) ; this . systemID = systemID ; this . fileName = fileName ; }	String fileName , ModuleOption options )
InterfacesScriptWriter ( NetworkSettings configuration ) <CTX> InterfacesScriptWriter ( NetworkSettings configuration ) { super ( ) ; this . configuration = configuration ; }	InterfacesScriptWriter ( NetworkSettings settings )
DataHandler annotateDataObjects ( TreeImageDisplay [ ] nodes ) <CTX> DataHandler annotateDataObjects ( TreeImageDisplay [ ] nodes ) { Object uo ; Set toAnnotate = new HashSet ( ) ; for ( int i = 0 ; i < nodes . length ; i ++ ) { uo = nodes [ i ] . getUserObject ( ) ; if ( uo instanceof DataObject ) toAnnotate . add ( uo ) ; } dataHandler = AnnotatorFactory . getAnnotator ( toAnnotate , TreeViewerAgent . getRegistry ( ) ) ; return dataHandler ; }	DataHandler annotateDataObjects ( JFrame owner , TreeImageDisplay [ ] nodes )
try { Thread . currentThread ( ) . setContextClassLoader ( PortalClassLoaderUtil . getClassLoader ( ) ) ;_servletContextListener . contextInitialized ( sce ) ; } finally { Thread . currentThread ( ) . setContextClassLoader ( contextClassLoader ) ; } <CTX> public void contextInitialized ( ServletContextEvent sce ) { ClassLoader contextClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; try { Thread . currentThread ( ) . setContextClassLoader ( PortalClassLoaderUtil . getClassLoader ( ) ) ;_servletContextListener . contextInitialized ( sce ) ; } finally { Thread . currentThread ( ) . setContextClassLoader ( contextClassLoader ) ; } }	PortalInitableUtil . init ( this ) ;
setTitleLabel ( ( ( IWorkingSet ) newValue ) . getLabel ( ) ) ; <CTX> public void propertyChange ( PropertyChangeEvent event ) { String property = event . getProperty ( ) ; if ( WorkingSetFilterActionGroup . CHANGE_WORKING_SET . equals ( property ) ) { Object newValue = event . getNewValue ( ) ; if ( newValue instanceof IWorkingSet ) { workingSetFilter . setWorkingSet ( ( IWorkingSet ) newValue ) ; setTitleLabel ( ( ( IWorkingSet ) newValue ) . getLabel ( ) ) ; } else if ( newValue == null ) { workingSetFilter . setWorkingSet ( null ) ; setTitleLabel ( null ) ; } scheduleRefresh ( ) ; } }	setSubtitle ( ( ( IWorkingSet ) newValue ) . getLabel ( ) ) ;
onInternalModelChanged ( ) ; <CTX> public final void modelChanged ( ) { / / Call user code onInternalModelChanged ( ) ; onModelChanged ( ) ; }	internalOnModelChanged ( ) ;
BaseOutputPlugin plugin ; <CTX> public BaseOutputPlugin getOutputPlugin ( final URI requestURI ) { BaseOutputPlugin plugin ; final String [ ] names = this . context . getBeanNamesForType ( plugin . getClass ( ) ) ; for ( int i = 0 ; i < names . length ; i = i + 1 ) { plugin = ( BaseOutputPlugin ) this . context . getBean ( names [ i ] ) ; if ( plugin . isMatch ( requestURI ) ) { break ; } else { plugin = null ; } } if ( plugin == null ) { plugin = new BaseOutputPlugin ( ) ; } return plugin ; }	BaseOutputPlugin plugin = null ;
String localName ) ; <CTX> public boolean hasAttributeNS ( String namespaceURI , String localName ) ;	String localName ) throws DOMException ;
boolean userHasRightToEdit ( IMCServiceInterface imcref , int metaId , <CTX> boolean userHasRightToEdit ( IMCServiceInterface imcref , int metaId , imcode . server . user . UserDomainObject user ) { DocumentMapper documentMapper = imcref . getDocumentMapper ( ) ; DocumentDomainObject document = documentMapper . getDocument ( metaId ) ; return documentMapper . userHasAtLeastDocumentReadPermission ( user , document ) && imcref . checkDocAdminRights ( metaId , user ) ; }	boolean userHasRightToEdit ( ImcmsServices imcref , int metaId ,
Member member = getMemberArg ( evaluator , args , 0 , true ) ; Member [ ] children = evaluator . getSchemaReader ( ) . getMemberChildren ( member ) ; return ( children . length == 0 ) ? member . getHierarchy ( ) . getNullMember ( ) : children [ 0 ] ; <CTX> public Object evaluate ( Evaluator evaluator , Exp [ ] args ) { Member member = getMemberArg ( evaluator , args , 0 , true ) ; Member [ ] children = evaluator . getSchemaReader ( ) . getMemberChildren ( member ) ; return ( children . length == 0 ) ? member . getHierarchy ( ) . getNullMember ( ) : children [ 0 ] ; }	Dimension dimension = getDimensionArg ( evaluator , args , 0 , true ) ; return evaluator . getContext ( dimension ) ;
Editor editor = Globals . curEditor ( ) ; JComponent c = editor . getJComponent ( ) ; <CTX> public void run ( ) { Editor editor = Globals . curEditor ( ) ; JComponent c = editor . getJComponent ( ) ; c . scrollRectToVisible ( r ) ; }	Editor theEditor = Globals . curEditor ( ) ; JComponent c = theEditor . getJComponent ( ) ;
channelContext , adminProperties , qosProperties , key ) ; <CTX> public SequenceProxyPullSupplierImpl ( AbstractAdmin myAdminServant , ChannelContext channelContext , PropertyManager adminProperties , PropertyManager qosProperties , Integer key ) throws UnsupportedQoS { super ( myAdminServant , channelContext , adminProperties , qosProperties , key ) ; setProxyType ( ProxyType . PULL_STRUCTURED ) ; }	channelContext ) ;
o . atoms = ( Atom [ ] ) o . atoms . clone ( ) ; <CTX> public Object clone ( ) { Bond o = null ; try { o = ( Bond ) super . clone ( ) ; } catch ( Exception e ) { e . printStackTrace ( System . err ) ; } o . atoms = ( Atom [ ] ) o . atoms . clone ( ) ; return o ; }	o . atoms = ( Atom [ ] ) atoms . clone ( ) ;
homeDir = MuleManager . getConfiguration ( ) . getWorkingDirectoy ( ) + DEFAULT_AXIS_HOME ; <CTX> public String getHomeDir ( ) { if ( homeDir == null ) { homeDir = MuleManager . getConfiguration ( ) . getWorkingDirectoy ( ) + DEFAULT_AXIS_HOME ; } return homeDir ; }	homeDir = MuleManager . getConfiguration ( ) . getWorkingDirectory ( ) + DEFAULT_AXIS_HOME ;
assert defn != null ; <CTX> public final boolean canContain ( Module module , int slotId , IElementDefn defn ) { assert defn != null ; boolean retValue = canContainInRom ( slotId , defn ) ; if ( ! retValue ) return false ; / / if the root of element is included by report / library . Do not allow / / drop . if ( isRootIncludedByModule ( ) ) return false ; if ( ! canContainTemplateElement ( module , slotId , defn ) ) return false ; / / Can not change structure of child element or a virtual element ( / / inside the child ) . if ( isVirtualElement ( ) || getExtendsName ( ) != null ) return false ; / / special cases check table header containment . DesignElement tmpContainer = this ; while ( tmpContainer != null ) { if ( tmpContainer instanceof ListingElement || tmpContainer instanceof MasterPage ) { List errors = tmpContainer . checkContent ( module , this , slotId , defn ) ; return errors . isEmpty ( ) ; } tmpContainer = tmpContainer . getContainer ( ) ; } return retValue ; }	boolean retValue = canContainInRom ( slotId , element . getDefn ( ) ) ; if ( ! retValue ) return false ;
} else { <CTX> private Indent getChildDefaultIndent ( ) { if ( myNode . getElementType ( ) == ElementType . HTML_DOCUMENT ) { return Formatter . getInstance ( ) . getNoneIndent ( ) ; } else { return null ; } }	} if ( myNode . getElementType ( ) == ElementType . DUMMY_HOLDER ) { return Formatter . getInstance ( ) . getNoneIndent ( ) ; } else {
ProviderFactory . createProvider ( slotHandle . getElementHandle ( ) ) . performRequest ( model , request ) ; return request ; <CTX> protected Request insertElement ( ) throws Exception { Request request = new Request ( IRequestConstants . REQUEST_TYPE_INSERT ) ; Map extendsData = new HashMap ( ) ; extendsData . put ( IRequestConstants . REQUEST_KEY_INSERT_SLOT , slotHandle ) ; extendsData . put ( IRequestConstants . REQUEST_KEY_INSERT_TYPE , insertType ) ; extendsData . put ( IRequestConstants . REQUEST_KEY_INSERT_POSITION , InsertAction . BELOW ) ; request . setExtendedData ( extendsData ) ; ProviderFactory . createProvider ( slotHandle . getElementHandle ( ) ) . performRequest ( model , request ) ; return request ; }	if ( ProviderFactory . createProvider ( slotHandle . getElementHandle ( ) ) . performRequest ( model , request ) ) { return request ; } return null ;
Model . getExtensionMechanismsHelper ( ) . setStereoType ( xtor , <CTX> XtorModeler ( String stereotypeName ) { / / FIXME : this will fail when we try to process definitions made / / outside of the class definition ! assert Model . getFacade ( ) . isAClass ( contextStack . peek ( ) ) ; xtor = buildOperation ( contextStack . peek ( ) , getVoid ( ) ) ; Model . getExtensionMechanismsHelper ( ) . setStereoType ( xtor , getStereotype ( xtor , stereotypeName ) ) ; contextStack . push ( xtor ) ; }	Model . getExtensionMechanismsHelper ( ) . addCopyStereotype ( xtor ,
super ( parent , context , true ) ; <CTX> public AxisTextSheet ( Composite parent , ChartWizardContext context , Axis axis , int axisType ) { super ( parent , context , true ) ; this . axis = axis ; this . axisType = axisType ; cmpTop = getComponent ( parent ) ; }	super ( title , context , true ) ;
if ( object instanceof StyleRange ) style = ( StyleRange ) object ; else return false ; if ( this . start != style . start ) return false ; if ( this . length != style . length ) return false ; return similarTo ( style ) ; <CTX> public boolean equals ( Object object ) { StyleRange style ; if ( object == this ) return true ; if ( object instanceof StyleRange ) style = ( StyleRange ) object ; else return false ; if ( this . start != style . start ) return false ; if ( this . length != style . length ) return false ; return similarTo ( style ) ; }	if ( object instanceof StyleRange ) { StyleRange style = ( StyleRange ) object ; if ( this . start != style . start ) return false ; if ( this . length != style . length ) return false ; return similarTo ( style ) ; } return false ;
return FileEditorManager . getInstance ( getProject ( ) ) . openTextEditor ( getDescriptor ( ) , focus ) ; <CTX> private Editor openTextEditor ( boolean focus ) { return FileEditorManager . getInstance ( getProject ( ) ) . openTextEditor ( getDescriptor ( ) , focus ) ; }	final OpenFileDescriptor descriptor = getDescriptor ( ) ; if ( descriptor != null ) { return FileEditorManager . getInstance ( getProject ( ) ) . openTextEditor ( descriptor , focus ) ; } return null ;
scaledImage = null ; <CTX> public void setImage ( BufferedImage img ) { origImage = img ; scaledImage = null ; repaint ( ) ; }	xformImage = null ;
initial_mbrs . notify ( ) ; <CTX> public boolean handleUpEvent ( Event evt ) { Vector tmp ; switch ( evt . getType ( ) ) { case Event . FIND_INITIAL_MBRS_OK : tmp = ( Vector ) evt . getArg ( ) ; synchronized ( initial_mbrs ) { if ( tmp != null && tmp . size ( ) > 0 ) for ( int i = 0 ; i < tmp . size ( ) ; i ++ ) initial_mbrs . addElement ( tmp . elementAt ( i ) ) ; initial_mbrs_received = true ; initial_mbrs . notify ( ) ; } return false ; / / don t pass up the stack } return true ; }	initial_mbrs . notifyAll ( ) ;
QName serviceName , String className , QName opName ) { return createSimpleService ( serviceName , new RawXMLINOutMessageRecevier ( ) , className , opName ) ; } <CTX> public static AxisService createSimpleService ( QName serviceName , String className , QName opName ) { return createSimpleService ( serviceName , new RawXMLINOutMessageRecevier ( ) , className , opName ) ; }	QName serviceName , MessageReceiver messageReceiver , String className , QName opName ) { AxisService service = new AxisService ( serviceName ) ; service . setClassLoader ( Thread . currentThread ( ) . getContextClassLoader ( ) ) ; service . addParameter ( new ParameterImpl ( AbstractMessageReceiver . SERVICE_CLASS , className ) ) ; AxisOperation axisOp = new AxisOperation ( opName ) ; axisOp . setMessageReciever ( messageReceiver ) ; service . addOperation ( axisOp ) ; return service ; }
return getRuntime ( ) . getTrue ( ) ; <CTX> public IRubyObject equal ( IRubyObject other ) { if ( other == this ) { return getRuntime ( ) . getTrue ( ) ; } if ( ! ( other instanceof RubyRegexp ) ) { return getRuntime ( ) . getFalse ( ) ; } RubyRegexp re = ( RubyRegexp ) other ; checkInitialized ( ) ; if ( ! re . source ( ) . getValue ( ) . equals ( pattern ) ) { return getRuntime ( ) . getFalse ( ) ; } if ( matcher . getCasefold ( ) ^ re . matcher . getCasefold ( ) ) { return getRuntime ( ) . getFalse ( ) ; } return getRuntime ( ) . getTrue ( ) ; }	return RubyBoolean . newBoolean ( getRuntime ( ) , ! ( matcher . getCasefold ( ) ^ re . matcher . getCasefold ( ) ) ) ;
Object [ ] tmp = table . values ( ) . toArray ( ) ; IRubyObject [ ] array = new IRubyObject [ tmp . length ] ; for ( int i = 0 ; i < tmp . length ; i ++ ) { array [ i ] = ( IRubyObject ) ( ( WeakSymbolEntry ) tmp [ i ] ) . get ( ) ; } <CTX> public IRubyObject [ ] all_symbols ( ) { Object [ ] tmp = table . values ( ) . toArray ( ) ; IRubyObject [ ] array = new IRubyObject [ tmp . length ] ; for ( int i = 0 ; i < tmp . length ; i ++ ) { array [ i ] = ( IRubyObject ) ( ( WeakSymbolEntry ) tmp [ i ] ) . get ( ) ; } return array ; }	int length = table . size ( ) ; IRubyObject [ ] array = new IRubyObject [ length ] ; System . arraycopy ( table . values ( ) . toArray ( ) , 0 , array , 0 , length ) ;
if ( MethodHelper . isPublicStatic ( method ) ) { <CTX> public void registerStaticMethods ( Class methodsClass ) { Method [ ] methods = methodsClass . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; if ( MethodHelper . isPublicStatic ( method ) ) { Class [ ] paramTypes = method . getParameterTypes ( ) ; if ( paramTypes . length > 0 ) { Class owner = paramTypes [ 0 ] ; getMetaClass ( owner ) . addNewStaticInstanceMethod ( method ) ; } } } }	if ( MethodHelper . isStatic ( method ) ) {
editor . menuRun . runInterpreter ( ) ; <CTX> public void handleMenuRun ( int itemTag ) { switch ( itemTag ) { case MI_RUN_INTERPRETER : editor . menuRun . runInterpreter ( ) ; break ; case MI_DEBUG : editor . menuRun . debug ( ) ; break ; case MI_BUILD_AND_DEBUG : editor . menuRun . buildAndDebug ( ) ; break ; case MI_DEBUG_REMOTE : editor . menuRun . debugRemote ( ) ; break ; case MI_DEBUG_SHOW_INFO_PANEL : editor . menuRun . toggleInformationPanel ( ) ; editor . refreshMainMenuBar ( ) ; break ; case MI_DEBUG_SHOW_OUTPUT_PANEL : editor . menuRun . toggleOutputPanel ( ) ; editor . refreshMainMenuBar ( ) ; break ; } }	editor . menuDebugger . runInterpreter ( ) ;
} catch ( BreakException bExcptn ) { <CTX> public RubyObject eval ( Ruby ruby , RubyObject self ) { while ( getConditionNode ( ) . eval ( ruby , self ) . isTrue ( ) ) { while ( true ) { try { getBodyNode ( ) . eval ( ruby , self ) ; break ; } catch ( RedoException rExcptn ) { } catch ( NextException nExcptn ) { break ; } catch ( BreakException bExcptn ) { return ruby . getNil ( ) ; } } } return ruby . getNil ( ) ; }	} catch ( BreakJump bExcptn ) {
this . activityScheduler , this . activity ) ) ; <CTX> public void next ( ) { this . activityScheduler . setActivityState ( new ActivityPresentationState ( this . activityScheduler , this . activity ) ) ; }	this . activityScheduler , this . activity , true ) ) ;
new ProgressMonitorDialog ( getShell ( ) ) . run ( fork , cancelable , runnable ) ; <CTX> public void run ( boolean fork , boolean cancelable , IRunnableWithProgress runnable ) throws InvocationTargetException , InterruptedException { new ProgressMonitorDialog ( getShell ( ) ) . run ( fork , cancelable , runnable ) ; }	new ProgressMonitorJobsDialog ( getShell ( ) ) . run ( fork , cancelable , runnable ) ;
if ( ! data . showOnFocus || control . isFocusControl ( ) ) <CTX> public void showDecoration ( FieldDecoration decoration ) { FieldDecorationData data = getDecorationData ( decoration ) ; if ( data == null ) return ; / / record the fact that client would like it to be visible data . visible = true ; / / even if it is supposed to be shown , if the field does not have focus , / / do not show it ( yet ) if ( ! data . showOnFocus || control . isFocusControl ( ) ) setVisible ( data , true ) ; }	if ( ! data . showOnFocus || control . isFocusControl ( ) ) {
String newResult = adaptedDecorators [ i ] . decorateText ( result , element ) ; <CTX> public String decorateText ( String text , Object element ) { DecoratorDefinition [ ] decorators = getDecoratorsFor ( element ) ; String result = text ; for ( int i = 0 ; i < decorators . length ; i ++ ) { String newResult = decorators [ i ] . decorateText ( result , element ) ; if ( newResult != null ) result = newResult ; } / / Get any adaptions to IResource Object adapted = getResourceAdapter ( element ) ; if ( adapted != null ) { DecoratorDefinition [ ] adaptedDecorators = getDecoratorsFor ( adapted ) ; for ( int i = 0 ; i < adaptedDecorators . length ; i ++ ) { if ( adaptedDecorators [ i ] . isAdaptable ( ) ) { String newResult = adaptedDecorators [ i ] . decorateText ( result , element ) ; if ( newResult != null ) result = newResult ; } } } return result ; }	String newResult = adaptedDecorators [ i ] . decorateText ( result , adapted ) ;
switch ( eDerivedStructuralFeatureID ( featureID , baseClass ) ) { case ComponentPackage . CURVE_FITTING__ LINE_ATTRIBUTES : return basicSetLineAttributes ( null , msgs ) ; case ComponentPackage . CURVE_FITTING__ LABEL : return basicSetLabel ( null , msgs ) ; default : return eDynamicInverseRemove ( otherEnd , featureID , baseClass , msgs ) ; } <CTX> public NotificationChain eInverseRemove ( InternalEObject otherEnd , int featureID , Class baseClass , NotificationChain msgs ) { if ( featureID >= 0 ) { switch ( eDerivedStructuralFeatureID ( featureID , baseClass ) ) { case ComponentPackage . CURVE_FITTING__ LINE_ATTRIBUTES : return basicSetLineAttributes ( null , msgs ) ; case ComponentPackage . CURVE_FITTING__ LABEL : return basicSetLabel ( null , msgs ) ; default : return eDynamicInverseRemove ( otherEnd , featureID , baseClass , msgs ) ; } } return eBasicSetContainer ( null , featureID , msgs ) ; }	case ComponentPackage . CURVE_FITTING__ LINE_ATTRIBUTES : return basicSetLineAttributes ( null , msgs ) ; case ComponentPackage . CURVE_FITTING__ LABEL : return basicSetLabel ( null , msgs ) ;
IRubyObject result = zstream . deflate ( str , new Long ( FINISH ) ) ; <CTX> public static IRubyObject s_deflate ( IRubyObject caller , String str , int level ) throws UnsupportedEncodingException , DataFormatException , IOException { ZlibDeflate zstream = new ZlibDeflate ( caller , level , MAX_WBITS , DEF_MEM_LEVEL , Deflater . DEFAULT_STRATEGY ) ; IRubyObject result = zstream . deflate ( str , new Long ( FINISH ) ) ; zstream . close ( ) ; return result ; }	IRubyObject result = zstream . deflate ( str , FINISH ) ;
switch ( getOnResource ( ) ) { case ON_ANY_RESOURCE : { unfiltered = findMarkers ( new IResource [ ] { ResourcesPlugin . getWorkspace ( ) . getRoot ( ) } , IResource . DEPTH_INFINITE , limit , mon , ignoreExceptions ) ; break ; } case ON_SELECTED_RESOURCE_ONLY : { unfiltered = findMarkers ( focusResource , IResource . DEPTH_ZERO , limit , mon , ignoreExceptions ) ; break ; } case ON_SELECTED_RESOURCE_AND_CHILDREN : { unfiltered = findMarkers ( focusResource , IResource . DEPTH_INFINITE , limit , mon , ignoreExceptions ) ; break ; } case ON_ANY_RESOURCE_OF_SAME_PROJECT : { unfiltered = findMarkers ( getProjects ( focusResource ) , IResource . DEPTH_INFINITE , limit , mon , ignoreExceptions ) ; break ; } case ON_WORKING_SET : { unfiltered = findMarkers ( getResourcesInWorkingSet ( ) , IResource . DEPTH_INFINITE , limit , mon , ignoreExceptions ) ; } <CTX> ConcreteMarker [ ] findMarkers ( IProgressMonitor mon , boolean ignoreExceptions ) throws CoreException { List unfiltered = Collections . EMPTY_LIST ; if ( ! isEnabled ( ) ) { unfiltered = findMarkers ( new IResource [ ] { ResourcesPlugin . getWorkspace ( ) . getRoot ( ) } , IResource . DEPTH_INFINITE , - 1 , mon , ignoreExceptions ) ; } else { / / int limit = getFilterOnMarkerLimit ( ) ? getMarkerLimit ( ) + 1 : - 1 ; int limit = - 1 ; switch ( getOnResource ( ) ) { case ON_ANY_RESOURCE : { unfiltered = findMarkers ( new IResource [ ] { ResourcesPlugin . getWorkspace ( ) . getRoot ( ) } , IResource . DEPTH_INFINITE , limit , mon , ignoreExceptions ) ; break ; } case ON_SELECTED_RESOURCE_ONLY : { unfiltered = findMarkers ( focusResource , IResource . DEPTH_ZERO , limit , mon , ignoreExceptions ) ; break ; } case ON_SELECTED_RESOURCE_AND_CHILDREN : { unfiltered = findMarkers ( focusResource , IResource . DEPTH_INFINITE , limit , mon , ignoreExceptions ) ; break ; } case ON_ANY_RESOURCE_OF_SAME_PROJECT : { unfiltered = findMarkers ( getProjects ( focusResource ) , IResource . DEPTH_INFINITE , limit , mon , ignoreExceptions ) ; break ; } case ON_WORKING_SET : { unfiltered = findMarkers ( getResourcesInWorkingSet ( ) , IResource . DEPTH_INFINITE , limit , mon , ignoreExceptions ) ; } } } if ( unfiltered == null ) { unfiltered = Collections . EMPTY_LIST ; } return ( ConcreteMarker [ ] ) unfiltered . toArray ( new ConcreteMarker [ unfiltered . size ( ) ] ) ; }	Collection subtypes = Arrays . asList ( type . getAllSubTypes ( ) ) ; if ( selectedTypes . containsAll ( subtypes ) ) { typesToSearch . removeAll ( subtypes ) ; includeAllSubtypes . add ( type ) ;
setButtonActionPerformed ( evt ) ; <CTX> public void actionPerformed ( java . awt . event . ActionEvent evt ) { setButtonActionPerformed ( evt ) ; }	portTextFieldActionPerformed ( evt ) ;
Iterator iter = getWSArtifactEditsIterator ( ) ; <CTX> public List getWorkspaceWSILFiles ( ) { List result = new ArrayList ( ) ; Iterator iter = getWSArtifactEditsIterator ( ) ; while ( iter . hasNext ( ) ) { WSDDArtifactEdit artifactEdit = ( WSDDArtifactEdit ) iter . next ( ) ; List files = artifactEdit . getWSILResources ( ) ; for ( int j = 0 ; j < files . size ( ) ; j ++ ) { IFile file = ( IFile ) files . get ( j ) ; if ( file != null && WSIL_EXT . equals ( file . getFileExtension ( ) ) ) result . add ( file ) ; } } return result ; }	Iterator iter = getWSArtifactEdits ( ) . iterator ( ) ;
InetWithPort [ ] inetps = new InetWithPort [ size ] ; <CTX> public static InetWithPort [ ] popArrayInetWithPort ( Message message ) { int size = message . popInt ( ) ; InetWithPort [ ] inetps = new InetWithPort [ size ] ; for ( int i = 0 ; i < inetps . length ; i ++ ) { inetps [ i ] = InetWithPort . pop ( message ) ; } return inetps ; }	InetSocketAddress [ ] inetps = new InetSocketAddress [ size ] ;
dispose ( ) ; <CTX> public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source instanceof JRadioButton ) updateEnabled ( ) ; if ( source == directoryChoose ) { File directory = new File ( directoryPath . getText ( ) ) ; JFileChooser chooser = new JFileChooser ( directory . getParent ( ) ) ; chooser . setFileSelectionMode ( JFileChooser . DIRECTORIES_ONLY ) ; chooser . setSelectedFile ( directory ) ; if ( chooser . showOpenDialog ( MultiFileSearchDialog . this ) == JFileChooser . APPROVE_OPTION ) directoryPath . setText ( chooser . getSelectedFile ( ) . getPath ( ) ) ; } else if ( source == ok ) { isOK = true ; dispose ( ) ; } else if ( source == cancel ) dispose ( ) ; }	cancel ( ) ;
int new_index = searchList . getSelectedIndex ( ) + e . getWheelRotation ( ) ; int list_size = searchList . getModel ( ) . getSize ( ) ; <CTX> public void mouseWheelMoved ( MouseWheelEvent e ) { int new_index = searchList . getSelectedIndex ( ) + e . getWheelRotation ( ) ; int list_size = searchList . getModel ( ) . getSize ( ) ; if ( new_index < list_size && new_index >= 0 ) { searchList . setSelectedIndex ( new_index ) ; searchList . ensureIndexIsVisible ( new_index ) ; } }	int new_index = browseList . getSelectedIndex ( ) + e . getWheelRotation ( ) ; int list_size = browseList . getModel ( ) . getSize ( ) ;
this . setRenderer ( AdventureResult . getEquipmentRenderer ( ) ) ; <CTX> public ChangeComboBox ( LockableListModel slot ) { super ( slot ) ; this . setRenderer ( AdventureResult . getEquipmentRenderer ( ) ) ; }	setRenderer ( AdventureResult . getEquipmentRenderer ( ) ) ; addActionListener ( new ChangeItemListener ( ) ) ;
PropertyGroupSchedule schedule = new PropertyGroupSchedule ( this ) ; schedule . lockPGs ( key ) ; return schedule ; <CTX> public PropertyGroupSchedule lock ( Object key ) { PropertyGroupSchedule schedule = new PropertyGroupSchedule ( this ) ; schedule . lockPGs ( key ) ; return schedule ; }	if (_locked == null ) {_locked = new_Locked ( key , this ) ; } return_locked ;
RosterEntry ( String user , String name , XMPPConnection connection ) { <CTX> RosterEntry ( String user , String name , XMPPConnection connection ) { this . user = user ; this . name = name ; this . connection = connection ; }	RosterEntry ( String user , String name , RosterPacket . ItemType type , XMPPConnection connection ) {
ex = ScriptRuntime . unwrapJavaScriptException ( ( JavaScriptException ) ex ) ; } else if ( ex instanceof EcmaError ) { <CTX> private static Object unwrapException ( Object ex ) { for ( ; ; ) { if ( ex instanceof JavaScriptException ) { ex = ScriptRuntime . unwrapJavaScriptException ( ( JavaScriptException ) ex ) ; } else if ( ex instanceof EcmaError ) { ex = ( ( EcmaError ) ex ) . getErrorObject ( ) ; } else if ( ex instanceof NativeJavaObject ) { ex = ( ( NativeJavaObject ) ex ) . unwrap ( ) ; break ; } else if ( ex instanceof WrappedException ) { Object w = ( ( WrappedException ) ex ) . unwrap ( ) ; if ( w instanceof Throwable ) { ex = w ; continue ; } break ; } else { break ; } } return ex ; }	ex = ( ( JavaScriptException ) ex ) . getValue ( ) ; } else if ( ex instanceof EcmaError ) {
throws PersistenceException , ObjectModifiedException { <CTX> public final void update ( final TransactionContext tx , final OID oid , final Object object , final AccessMode suggestedAccessMode , final Object field ) throws PersistenceException , ObjectModifiedException { ClassMolder fieldClassMolder =_fieldMolder . getFieldClassMolder ( ) ; LockEngine fieldEngine =_fieldMolder . getFieldLockEngine ( ) ; if (_fieldMolder . isDependent ( ) ) { if ( !_fieldMolder . isLazy ( ) ) { Iterator itor = ClassMolderHelper . getIterator (_fieldMolder . getValue ( object , tx . getClassLoader ( ) ) ) ; ArrayList v = ( ArrayList ) field ; ArrayList newSetOfIds = new ArrayList ( ) ; / / iterate the collection of this data object field while ( itor . hasNext ( ) ) { Object element = itor . next ( ) ; Object actualIdentity = fieldClassMolder . getActualIdentity ( tx , element ) ; newSetOfIds . add ( actualIdentity ) ; if ( v != null && v . contains ( actualIdentity ) ) { if ( ! tx . isRecorded ( element ) ) { tx . markUpdate ( fieldEngine , fieldClassMolder , element , oid ) ; } } else { / * * if ( ! tx . isRecorded ( element ) ) tx . markCreate ( * fieldEngine , fieldClassMolder , element , oid ) ; * / } } if ( v != null ) { for ( int j = 0 , l = v . size ( ) ; j < l ; j ++ ) { if ( ! newSetOfIds . contains ( v . get ( j ) ) ) { / / load all the dependent object in cache for / / modification / / check at commit time . ProposedObject proposedValue = new ProposedObject ( ) ; tx . load ( oid . getLockEngine ( ) , fieldClassMolder , v . get ( j ) , proposedValue , suggestedAccessMode ) ; } } } } else { / / ArrayList avlist = ( ArrayList ) fields [ i ] ; fieldClassMolder =_fieldMolder . getFieldClassMolder ( ) ; fieldEngine =_fieldMolder . getFieldLockEngine ( ) ; / / RelationCollection relcol = new RelationCollection ( tx , oid , / / fieldEngine , fieldClassMolder , accessMode , avlist ) ; } } else if ( tx . isAutoStore ( ) ) { Iterator itor = ClassMolderHelper . getIterator (_fieldMolder . getValue ( object , tx . getClassLoader ( ) ) ) ; ArrayList v = ( ArrayList ) field ; ArrayList newSetOfIds = new ArrayList ( ) ; / / iterate the collection of this data object field while ( itor . hasNext ( ) ) { Object element = itor . next ( ) ; Object actualIdentity = fieldClassMolder . getActualIdentity ( tx , element ) ; newSetOfIds . add ( actualIdentity ) ; if ( v != null && v . contains ( actualIdentity ) ) { if ( ! tx . isRecorded ( element ) ) { tx . markUpdate ( fieldEngine , fieldClassMolder , element , null ) ; } } else { if ( ! tx . isRecorded ( element ) ) { tx . markUpdate ( fieldEngine , fieldClassMolder , element , null ) ; } } } / / load all old objects for comparison in the preStore state if ( v != null ) { for ( int j = 0 , l = v . size ( ) ; j < l ; j ++ ) { if ( ! newSetOfIds . contains ( v . get ( j ) ) ) { / / load all the dependent object in cache for / / modification / / check at commit time . ProposedObject proposedValue = new ProposedObject ( ) ; tx . load ( oid . getLockEngine ( ) , fieldClassMolder , v . get ( j ) , proposedValue , suggestedAccessMode ) ; } } } } }	throws PersistenceException {
super ( position ) ; <CTX> public DefsNode ( ISourcePosition position , Node receiverNode , String name , Node argsNode , ScopeNode bodyNode ) { super ( position ) ; this . receiverNode = receiverNode ; this . name = name . intern ( ) ; this . argsNode = argsNode ; this . bodyNode = bodyNode ; }	super ( position , NodeTypes . DEFSNODE ) ;
hide ( ) ; <CTX> public void actionPerformed ( ActionEvent e ) { if ( e . getActionCommand ( ) . equals ( m_ok . getText ( ) ) || e . getActionCommand ( ) . equals ( m_cancel . getText ( ) ) ) { m_aborted = ! e . getActionCommand ( ) . equals ( m_ok . getText ( ) ) ; hide ( ) ; } else if ( e . getActionCommand ( ) . equals ( m_selAll . getText ( ) ) ) { for ( int i = 0 ; i < m_selections . length ; i ++ ) { m_selections [ i ] . setSelected ( true ) ; } } else if ( e . getActionCommand ( ) . equals ( m_selNone . getText ( ) ) ) { for ( int i = 0 ; i < m_selections . length ; i ++ ) { m_selections [ i ] . setSelected ( false ) ; } } }	setVisible ( false ) ;
myConnection . open ( this ) ; authenticate ( ) ; <CTX> private void openConnection ( ) throws SVNException { lock ( ) ; ISVNConnector connector = SVNRepositoryFactoryImpl . getConnectorFactory ( ) . createConnector ( this ) ; myConnection = new SVNConnection ( connector ) ; myConnection . open ( this ) ; authenticate ( ) ; }	try { myConnection . open ( this ) ; authenticate ( ) ; } finally { myRealm = myConnection . getRealm ( ) ; }
return 32 ; <CTX> public int getMaxCursorNameLength ( ) throws SQLException { return 32 ; }	return NAME_SIZE ;
if ( ! HAS_NEXT_METHOD . equals ( methodName ) ) { <CTX> private static boolean isHasNext ( PsiExpression condition , String iterator ) { if ( ! ( condition instanceof PsiMethodCallExpression ) ) { return false ; } final PsiMethodCallExpression call = ( PsiMethodCallExpression ) condition ; final PsiExpressionList argumentList = call . getArgumentList ( ) ; if ( argumentList == null ) { return false ; } final PsiExpression [ ] args = argumentList . getExpressions ( ) ; if ( args . length != 0 ) { return false ; } final PsiReferenceExpression methodExpression = call . getMethodExpression ( ) ; if ( methodExpression == null ) { return false ; } final String methodName = methodExpression . getReferenceName ( ) ; if ( ! HAS_NEXT_METHOD . equals ( methodName ) ) { return false ; } final PsiExpression qualifier = methodExpression . getQualifierExpression ( ) ; if ( qualifier == null ) { return true ; } final String target = qualifier . getText ( ) ; return iterator . equals ( target ) ; }	if ( ! HardcodedMethodConstants . HAS_NEXT . equals ( methodName ) ) {
if ( header . localSeqID != NULL_ID ) passUp ( new Event ( Event . MSG , msg ) ) ; <CTX> private void_deliverBcast ( ) { Message msg ; Header header ; synchronized ( upTbl ) { while ( ( msg = ( Message ) upTbl . remove ( new Long ( seqID + 1 ) ) ) != null ) { header = ( Header ) msg . removeHeader ( getName ( ) ) ; if ( header . localSeqID != NULL_ID ) passUp ( new Event ( Event . MSG , msg ) ) ; ++ seqID ; } } / / synchronized ( upTbl ) }	if ( header . localSequenceID != NULL_ID ) passUp ( new Event ( Event . MSG , msg ) ) ;
boolean exists = ( tuple . getLinkedTuples ( ) != null && ! tuple . getLinkedTuples ( ) . isEmpty ( ) ) ; <CTX> public void modifyTuple ( final ReteTuple tuple , final PropagationContext context , final ReteooWorkingMemory workingMemory ) { final LinkedList memory = ( LinkedList ) workingMemory . getNodeMemory ( this ) ; boolean exists = ( tuple . getLinkedTuples ( ) != null && ! tuple . getLinkedTuples ( ) . isEmpty ( ) ) ; if ( exists ) { / / Remove the tuple so it can be readded to the top of the list memory . remove ( tuple ) ; } final boolean allowed = this . condition . isAllowed ( tuple , workingMemory ) ; if ( allowed ) { memory . add ( tuple ) ; if ( ! exists ) { propagateAssertTuple ( tuple , context , workingMemory ) ; } else { propagateModifyTuple ( tuple , context , workingMemory ) ; } } else { propagateRetractTuple ( tuple , context , workingMemory ) ; } }	boolean exists = ( tuple . getChildEntries ( ) != null && ! tuple . getChildEntries ( ) . isEmpty ( ) ) ;
setLayer ( DefaultAnnotation . INFO_LAYER + 1 ) ; <CTX> public ProblemAnnotation ( IProblem problem , ICompilationUnit cu ) { fProblem = problem ; fCompilationUnit = cu ; if ( IProblem . Task == fProblem . getID ( ) ) { setType ( JavaMarkerAnnotation . TASK_ANNOTATION_TYPE ) ; setLayer ( DefaultAnnotation . TASK_LAYER + 1 ) ; } else if ( fProblem . isWarning ( ) ) { setType ( JavaMarkerAnnotation . WARNING_ANNOTATION_TYPE ) ; setLayer ( DefaultAnnotation . WARNING_LAYER + 1 ) ; } else if ( fProblem . isError ( ) ) { setType ( JavaMarkerAnnotation . ERROR_ANNOTATION_TYPE ) ; setLayer ( DefaultAnnotation . ERROR_LAYER + 1 ) ; } else { setType ( JavaMarkerAnnotation . INFO_ANNOTATION_TYPE ) ; setLayer ( DefaultAnnotation . INFO_LAYER + 1 ) ; } }	setLayer ( AnnotationLayerLookup . INFO_LAYER + 1 ) ;
m_targetInstance = targetInstance ; <CTX> public void setTargetInstance ( final Object targetInstance ) { m_targetInstance = targetInstance ; }	m_targetInstanceRef = new WeakReference ( targetInstance ) ;
if ( getSite ( ) . isCloseable ( part ) ) <CTX> private CTabItem createPartTab ( IPresentablePart part , int tabIndex ) { CTabItem tabItem ; int style = SWT . NONE ; if ( getSite ( ) . isCloseable ( part ) ) style |= SWT . CLOSE ; tabItem = paneFolder . createItem ( style , tabIndex ) ; tabItem . setData ( TAB_DATA , part ) ; part . addPropertyListener ( childPropertyChangeListener ) ; tabItem . addDisposeListener ( tabDisposeListener ) ; initTab ( tabItem , part ) ; return tabItem ; }	if ( getSite ( ) . isCloseable ( part ) ) {
return RubyString . newString ( getRuntime ( ) , method . getName ( ) ) ; <CTX> public RubyString name ( ) { return RubyString . newString ( getRuntime ( ) , method . getName ( ) ) ; }	return getRuntime ( ) . newString ( method . getName ( ) ) ;
Double percentage , AdviseType adviseType ) throws ExcepcaoPersistencia { <CTX> public void run ( Integer teacherID , Integer executionPeriodID , final Integer studentNumber , Double percentage , AdviseType adviseType ) throws ExcepcaoPersistencia { ISuportePersistente persistentSupport = PersistenceSupportFactory . getDefaultPersistenceSupport ( ) ; ITeacher teacher = ( ITeacher ) persistentSupport . getIPersistentTeacher ( ) . readByOID ( Teacher . class , teacherID ) ; IExecutionPeriod executionPeriod = ( IExecutionPeriod ) persistentSupport . getIPersistentExecutionPeriod ( ) . readByOID ( ExecutionPeriod . class , executionPeriodID ) ; List < IStudent > students = persistentSupport . getIPersistentStudent ( ) . readAll ( ) ; IStudent student = ( IStudent ) CollectionUtils . find ( students , new Predicate ( ) { public boolean evaluate ( Object arg 0 ) { IStudent tempStudent = ( IStudent ) arg 0 ; return tempStudent . getNumber ( ) . equals ( studentNumber ) ; } } ) ; ITeacherService teacherService = teacher . getTeacherServiceByExecutionPeriod ( executionPeriod ) ; if ( teacherService == null ) { teacherService = DomainFactory . makeTeacherService ( teacher , executionPeriod ) ; } List < IAdvise > advises = student . getAdvisesByTeacher ( teacher ) ; IAdvise advise = null ; if ( advises == null || advises . isEmpty ( ) ) { advise = DomainFactory . makeAdvise ( teacher , student , adviseType , executionPeriod , executionPeriod ) ; } else { advise = advises . iterator ( ) . next ( ) ; } ITeacherAdviseService teacherAdviseService = advise . getTeacherAdviseServiceByExecutionPeriod ( executionPeriod ) ; if ( teacherAdviseService == null ) { teacherAdviseService = DomainFactory . makeTeacherAdviseService ( teacherService , advise , percentage ) ; } else { teacherAdviseService . updatePercentage ( percentage ) ; } }	Double percentage , AdviseType adviseType ) throws ExcepcaoPersistencia , FenixServiceException {
Scriptable scope = cx . newObject ( parentScope ) ; scope . setParentScope ( parentScope ) ; scope . setPrototype ( parentScope ) ; <CTX> Scriptable newSubScope ( Scriptable parentScope ) { if ( parentScope == null ) parentScope = sharedScope ; Context cx = Context . enter ( ) ; try { Scriptable scope = cx . newObject ( parentScope ) ; scope . setParentScope ( parentScope ) ; scope . setPrototype ( parentScope ) ; return scope ; } finally { Context . exit ( ) ; } }	Scriptable scope = cx . newObject ( parentAndProtoScope ) ; scope . setParentScope ( parentAndProtoScope ) ; scope . setPrototype ( parentAndProtoScope ) ;
if ( ! isNonDisplayableJob ( info . getJob ( ) , listener . showsDebug ( ) ) ) listener . addJob ( info ) ; <CTX> public void addJobInfo ( JobInfo info ) { GroupInfo group = info . getGroupInfo ( ) ; if ( group != null ) refreshGroup ( group ) ; jobs . put ( info . getJob ( ) , info ) ; synchronized ( listenersKey ) { for ( int i = 0 ; i < listeners . length ; i ++ ) { IJobProgressManagerListener listener = listeners [ i ] ; if ( ! isNonDisplayableJob ( info . getJob ( ) , listener . showsDebug ( ) ) ) listener . addJob ( info ) ; } } }	if ( ! isNonDisplayableJob ( info . getJob ( ) , listener . showsDebug ( ) ) ) { listener . addJob ( info ) ; }
userSuppliedOptimizerOverrides , closeCleanup ) ; <CTX> public NestedLoopLeftOuterJoinResultSet ( NoPutResultSet leftResultSet , int leftNumCols , NoPutResultSet rightResultSet , int rightNumCols , Activation activation , GeneratedMethod restriction , int resultSetNumber , GeneratedMethod emptyRowFun , boolean wasRightOuterJoin , boolean oneRowRightSide , boolean notExistsRightSide , double optimizerEstimatedRowCount , double optimizerEstimatedCost , String userSuppliedOptimizerOverrides , GeneratedMethod closeCleanup ) { super ( leftResultSet , leftNumCols , rightResultSet , rightNumCols , activation , restriction , resultSetNumber , oneRowRightSide , notExistsRightSide , optimizerEstimatedRowCount , optimizerEstimatedCost , userSuppliedOptimizerOverrides , closeCleanup ) ; this . emptyRowFun = emptyRowFun ; this . wasRightOuterJoin = wasRightOuterJoin ; }	userSuppliedOptimizerOverrides ) ;
return flags ; <CTX> getFlags ( ) { return flags ; }	return byteArrayToString ( flags ) ;
this . resourceName = resourceName ; <CTX> public void setResourceName ( String resourceName ) { this . resourceName = resourceName ; }	m_resourceName = resourceName ;
Iterator iterator = fActivatedPlugins . keySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { String pluginId = ( String ) iterator . next ( ) ; Plugin object = ( Plugin ) fActivatedPlugins . get ( pluginId ) ; object . shutDown ( ) ; <CTX> private void shotDownActivatedPlugins ( ) throws PluginRuntimeException { Iterator iterator = fActivatedPlugins . keySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { String pluginId = ( String ) iterator . next ( ) ; Plugin object = ( Plugin ) fActivatedPlugins . get ( pluginId ) ; object . shutDown ( ) ; } }	Iterator iterator = fActivatedPlugins . keySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { String pluginId = ( String ) iterator . next ( ) ; Plugin object = ( Plugin ) fActivatedPlugins . get ( pluginId ) ; object . shutDown ( ) ; }
return PropertyUtil . getDimensionValue ( cellAreaStyle <CTX> public int resolveBottomBorder ( CellArea cell ) { IStyle tableStyle = tableContent . getComputedStyle ( ) ; IStyle rowStyle = ( lastRow == null ? null : lastRowArea . getContent ( ) . getComputedStyle ( ) ) ; IStyle columnStyle = getColumnStyle ( cell . getColumnID ( ) ) ; IStyle cellContentStyle = cell . getContent ( ) . getComputedStyle ( ) ; IStyle cellAreaStyle = cell . getStyle ( ) ; bcr . resolveTableBottomBorder ( tableStyle , rowStyle , columnStyle , cellContentStyle , cellAreaStyle ) ; return PropertyUtil . getDimensionValue ( cellAreaStyle . getProperty ( StyleConstants . STYLE_BORDER_BOTTOM_WIDTH ) ) ; }	return getDimensionValue ( cellAreaStyle
return RECOGNIZED_FEATURES ; <CTX> public String [ ] getRecognizedFeatures ( ) { return RECOGNIZED_FEATURES ; } / / getRecognizedFeatures ( ) : String [ ]	return ( String [ ] ) ( RECOGNIZED_FEATURES . clone ( ) ) ;
this . addChangeListener ( listener ) ; <CTX> public DataProxy ( DataContext context , DataProxyStateChangeListener listener ) { this . context = context ; this . addChangeListener ( listener ) ; }	if ( listener != null ) this . addChangeListener ( listener ) ;
if ( type instanceof TupleType ) { TupleType tupleType = ( TupleType ) type ; <CTX> private static void addTypes ( final Type type , List list ) { if ( type instanceof TupleType ) { TupleType tupleType = ( TupleType ) type ; for ( int i = 0 ; i < tupleType . elementTypes . length ; i ++ ) { addTypes ( tupleType . elementTypes [ i ] , list ) ; } } else { list . add ( type ) ; } }	if ( type instanceof SetType ) { SetType setType = ( SetType ) type ; addTypes ( setType . getElementType ( ) , list ) ; } else if ( type instanceof TupleType ) { TupleType tupleType = ( TupleType ) type ;
this . getCandidates ( ) . add ( candidateGene ) ; <CTX> public void addCandidate ( CandidateGene candidateGene ) { if ( this . getCandidates ( ) == null ) this . setCandidates ( new HashSet ( ) ) ; this . getCandidates ( ) . add ( candidateGene ) ; }	this . getCandidates ( ) . add ( cgNew ) ;
if ( WorkbenchActivityHelper . filterItem ( node ) ) <CTX> protected IPreferenceNode findNodeMatching ( String nodeId ) { IPreferenceNode node = super . findNodeMatching ( nodeId ) ; if ( WorkbenchActivityHelper . filterItem ( node ) ) return null ; return node ; }	if ( WorkbenchActivityHelper . filterItem ( node ) ) {
scoreCount += foodCount ( cell ) ; <CTX> private void updateObjects ( ) { scoreCount = 0 ; Cell cell ; java . awt . Point location = new java . awt . Point ( ) ; for ( location . x = 0 ; location . x < size ; ++ location . x ) { for ( location . y = 0 ; location . y < size ; ++ location . y ) { cell = getCell ( location ) ; cell . update ( this , location ) ; scoreCount += foodCount ( cell ) ; } } }	scoreCount += pointsCount ( cell ) ; foodCount += cell . getAllWithProperty ( Names . kPropertyEdible ) . size ( ) ;
DesignElementHandle dataItemHandle = InsertInLayoutUtil . performInsert ( columnList . get ( index ) , <CTX> protected void okPressed ( ) { try { inputGroup . setName ( nameEditor . getText ( ) ) ; String newToc = UIUtil . convertToModelString ( tocEditor . getText ( ) , true ) ; if ( newToc != inputGroup . getTocExpression ( ) ) { if ( newToc == null || ! newToc . equals ( inputGroup . getTocExpression ( ) ) ) { inputGroup . setTocExpression ( newToc ) ; } } int index = keyChooser . getSelectionIndex ( ) ; String oldKey = inputGroup . getKeyExpr ( ) ; String newKey = getKeyExpression ( ) ; inputGroup . setKeyExpr ( newKey ) ; if ( newKey != null && ! newKey . equals ( oldKey ) ) { SlotHandle slotHandle = null ; if ( inputGroup instanceof ListGroupHandle ) { slotHandle = inputGroup . getHeader ( ) ; } else if ( inputGroup instanceof TableGroupHandle ) { if ( inputGroup . getHeader ( ) . getCount ( ) != 0 ) { RowHandle rowHandle = ( ( RowHandle ) inputGroup . getHeader ( ) . get ( 0 ) ) ; CellHandle cellHandle = ( CellHandle ) rowHandle . getCells ( ) . get ( 0 ) ; slotHandle = cellHandle . getContent ( ) ; } } if ( slotHandle != null ) { DesignElementHandle dataItemHandle = InsertInLayoutUtil . performInsert ( columnList . get ( index ) , slotHandle , inputGroup . getContainer ( ) ) ; slotHandle . add ( dataItemHandle ) ; } } index = intervalType . getSelectionIndex ( ) ; inputGroup . setInterval ( intervalChoices [ index ] . getName ( ) ) ; if ( index != 0 ) { inputGroup . setIntervalRange ( intervalRange . getSelection ( ) ) ; } if ( inputGroup instanceof TableGroupHandle ) { if ( includeHeader . getSelection ( ) != inputGroup . hasHeader ( ) ) { / / the include header status changed if ( includeHeader . getSelection ( ) ) { / / from unchecked to checked inputGroup . getHeader ( ) . add ( createRow ( ) ) ; } else { / / from checked to unchecked , clear the slot inputGroup . clearContents ( GroupHandle . HEADER_SLOT ) ; } } if ( includeFooter . getSelection ( ) != inputGroup . hasFooter ( ) ) { / / the include footer status changed if ( includeFooter . getSelection ( ) ) { / / from unchecked to checked inputGroup . getFooter ( ) . add ( createRow ( ) ) ; } else { / / from checked to unchecked , clear the slot inputGroup . clearContents ( GroupHandle . FOOTER_SLOT ) ; } } } if ( ascending . getSelection ( ) ) { inputGroup . setSortDirection ( DesignChoiceConstants . SORT_DIRECTION_ASC ) ; } else { inputGroup . setSortDirection ( DesignChoiceConstants . SORT_DIRECTION_DESC ) ; } } catch ( SemanticException e ) { ExceptionHandler . handle ( e ) ; return ; } setResult ( inputGroup ) ; super . okPressed ( ) ; }	DesignElementHandle dataItemHandle = InsertInLayoutUtil . performInsert ( newKeyExpr . trim ( ) ,
super ( null , null , null , null , ENDPOINT_TYPE_SENDER_AND_RECEIVER , 0 , null , new HashMap ( ) ) ; <CTX> public MuleEndpoint ( ) { super ( null , null , null , null , ENDPOINT_TYPE_SENDER_AND_RECEIVER , 0 , null , new HashMap ( ) ) ; }	super ( null , null , null , null , ENDPOINT_TYPE_SENDER_AND_RECEIVER , 0 , null , null ) ;
x . setJavadoc ( ( Javadoc ) value ) ; <CTX> public void set ( ASTNode value ) { x . setJavadoc ( ( Javadoc ) value ) ; }	x . setBody ( ( Block ) value ) ;
Assert . assert ( - 1 != nativeRDFNode ) ; <CTX> public Enumeration children ( ) { Assert . assert ( - 1 != nativeRDFNode ) ; Enumeration enum = null ; enum = new RDFEnumeration ( nativeWebShell , this ) ; return enum ; }	Assert . assert_it ( - 1 != nativeRDFNode ) ;
saveProjectItemActionPerformed ( evt ) ; <CTX> public void actionPerformed ( java . awt . event . ActionEvent evt ) { saveProjectItemActionPerformed ( evt ) ; }	exitItemActionPerformed ( evt ) ;
userAgent . handleElement ( elt , data ) ; <CTX> public void run ( ) { userAgent . handleElement ( elt , data ) ; }	userAgent . registerExtension ( ext ) ;
textDocumentDomainObject . setArchivedDatetime ( new Date ( 0 ) ) ; assertFalse ( internalUser . canEdit ( textDocumentDomainObject ) ) ; assertTrue ( internalUser . canAccess ( textDocumentDomainObject ) ) ; <CTX> public void testMenuGetDocumentsIncludesArchived ( ) throws Exception { internalUser . addRole ( readRole ) ; textDocumentDomainObject . setArchivedDatetime ( new Date ( 0 ) ) ; assertFalse ( internalUser . canEdit ( textDocumentDomainObject ) ) ; assertTrue ( internalUser . canAccess ( textDocumentDomainObject ) ) ; assertTrue ( menu . getDocuments ( ) . length > 0 ) ; }	textDocument . setArchivedDatetime ( new Date ( 0 ) ) ; assertFalse ( internalUser . canEdit ( textDocument ) ) ; assertTrue ( internalUser . canAccess ( textDocument ) ) ;
if ( resourceType == IResource . ROOT ) res = root ; else if ( resourceType == IResource . PROJECT ) res = root . getProject ( fileName ) ; else if ( resourceType == IResource . FOLDER ) res = root . getFolder ( new Path ( fileName ) ) ; else if ( resourceType == IResource . FILE ) res = root . getFile ( new Path ( fileName ) ) ; <CTX> public IAdaptable createElement ( IMemento memento ) { / / Get the file name . String fileName = memento . getString ( TAG_PATH ) ; if ( fileName == null ) return null ; IWorkspaceRoot root = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) ; String type = memento . getString ( TAG_TYPE ) ; if ( type == null ) { / / Old format memento . Create an IResource using findMember . / / Will return null for resources in closed projects . res = root . findMember ( new Path ( fileName ) ) ; } else { int resourceType = Integer . parseInt ( type ) ; if ( resourceType == IResource . ROOT ) res = root ; else if ( resourceType == IResource . PROJECT ) res = root . getProject ( fileName ) ; else if ( resourceType == IResource . FOLDER ) res = root . getFolder ( new Path ( fileName ) ) ; else if ( resourceType == IResource . FILE ) res = root . getFile ( new Path ( fileName ) ) ; } return res ; }	if ( resourceType == IResource . ROOT ) { res = root ; } else if ( resourceType == IResource . PROJECT ) { res = root . getProject ( fileName ) ; } else if ( resourceType == IResource . FOLDER ) { res = root . getFolder ( new Path ( fileName ) ) ; } else if ( resourceType == IResource . FILE ) { res = root . getFile ( new Path ( fileName ) ) ; }
last . put ( self , new Integer ( nodes . size ( ) ) ) ; <CTX> private void buildNodesList ( ) { / / add dummy start node nodes . add ( new DummyNode ( ) ) ; / / add nodes in stream SIRIterator it = IterFactory . createIter ( str ) ; it . accept ( new EmptyStreamVisitor ( ) { public void preVisitStream ( SIRStream self , SIRIterator iter ) { first . put ( self , new Integer ( nodes . size ( ) ) ) ; } public void postVisitStream ( SIRStream self , SIRIterator iter ) { last . put ( self , new Integer ( nodes . size ( ) ) ) ; } public void visitFilter ( SIRFilter self , SIRFilterIter iter ) { nodes . add ( self ) ; } public void preVisitFeedbackLoop ( SIRFeedbackLoop self , SIRFeedbackLoopIter iter ) { super . preVisitFeedbackLoop ( self , iter ) ; nodes . add ( self . getJoiner ( ) ) ; } public void postVisitSplitJoin ( SIRSplitJoin self , SIRSplitJoinIter iter ) { nodes . add ( self . getJoiner ( ) ) ; super . postVisitSplitJoin ( self , iter ) ; } } ) ; / / add dummy end node nodes . add ( new DummyNode ( ) ) ; }	last . put ( self , new Integer ( nodes . size ( ) - 1 ) ) ;
if ( a [ i ] != b . charAt ( i ) ) { <CTX> public static boolean equals ( char [ ] a , String b ) { int len = a . length ; if ( len != b . length ( ) ) { return false ; } for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( a [ i ] != b . charAt ( i ) ) { return false ; } } return true ; }	if ( a [ i ] != b [ i ] ) {
getThreadReference ( ) . popFrames ( stackFrame . getStackFrame ( ) ) ; <CTX> public void popFrames ( StackFrameProxyImpl stackFrame ) throws EvaluateException { DebuggerManagerThreadImpl . assertIsManagerThread ( ) ; try { getThreadReference ( ) . popFrames ( stackFrame . getStackFrame ( ) ) ; } catch ( InternalException e ) { throw EvaluateExceptionUtil . createEvaluateException ( e ) ; } catch ( IncompatibleThreadStateException e ) { throw EvaluateExceptionUtil . createEvaluateException ( e ) ; } finally { clearCaches ( ) ; getVirtualMachineProxy ( ) . clearCaches ( ) ; } }	threadRef . popFrames ( stackFrame . getStackFrame ( ) ) ;
long count = 1 ; <CTX> public void apply ( CallContext ctx ) throws Throwable { Object values = ctx . getNextArg ( ) ; Procedure proc = ( Procedure ) ctx . getNextArg ( ) ; long count = 1 ; int index = 0 ; Consumer out = ctx . consumer ; for ( ; ; ) { int next = Values . nextIndex ( values , index ) ; if ( next < 0 ) break ; Object value = Values . nextValue ( values , index ) ; if ( matches ( proc . apply 1 ( value ) , count ) ) out . writeObject ( value ) ; count ++ ; index = next ; } }	long count = 0 ;
iArray [ i ] = getSample ( x , y , 0 , data ) ; <CTX> public int [ ] getPixel ( int x , int y , int [ ] iArray , DataBuffer data ) { if ( iArray == null ) iArray = new int [ numBands ] ; for ( int i = 0 ; i < numBands ; i ++ ) iArray [ i ] = getSample ( x , y , 0 , data ) ; return iArray ; }	iArray [ i ] = getSample ( x , y , i , data ) ;
else if ( offsetable instanceof Macro ) { createMacro ( translationUnit , ( Macro ) offsetable ) ; } else if ( offsetable instanceof Declaration ) { generateModelElements ( translationUnit , ( Declaration ) offsetable ) ; <CTX> protected void generateModelElements ( TranslationUnit tu ) { Iterator i = tu . iterateOffsetableElements ( ) ; while ( i . hasNext ( ) ) { IOffsetable offsetable = ( IOffsetable ) i . next ( ) ; if ( offsetable instanceof Inclusion ) { createInclusion ( translationUnit , ( Inclusion ) offsetable ) ; } else if ( offsetable instanceof Macro ) { createMacro ( translationUnit , ( Macro ) offsetable ) ; } else if ( offsetable instanceof Declaration ) { generateModelElements ( translationUnit , ( Declaration ) offsetable ) ; } } }	else if ( offsetable instanceof IASTMacro ) { createMacro ( translationUnit , ( IASTMacro ) offsetable ) ; } else if ( offsetable instanceof IASTDeclaration ) { try { generateModelElements ( translationUnit , ( IASTDeclaration ) offsetable ) ; } catch ( ASTNotImplementedException e ) { }
res = fSourceLocator . getSourceElement ( stackFrame ) ; <CTX> public Object getSourceElement ( IStackFrame stackFrame ) { Object res = cacheLookup ( stackFrame ) ; if ( res == null ) { res = fSourceLocator . getSourceElement ( stackFrame ) ; if ( res instanceof List ) { List list = ( List ) res ; if ( list . size ( ) != 0 ) { SourceSelectionDialog dialog = createSourceSelectionDialog ( list ) ; dialog . open ( ) ; Object [ ] objs = dialog . getResult ( ) ; res = ( objs != null && objs . length > 0 ) ? objs [ 0 ] : null ; if ( res != null ) cacheSourceElement ( stackFrame , res , dialog . alwaysMapToSelection ( ) ) ; } else res = null ; } } if ( res == null ) { IStackFrameInfo frameInfo = ( IStackFrameInfo ) stackFrame . getAdapter ( IStackFrameInfo . class ) ; if ( frameInfo != null && frameInfo . getFile ( ) != null && frameInfo . getFile ( ) . length ( ) > 0 ) { res = new FileNotFoundElement ( stackFrame ) ; } else / / don t show in editor { res = new NoSymbolOrSourceElement ( stackFrame ) ; } } return res ; }	res = getCSourceLocator ( ) . getSourceElement ( stackFrame ) ;
Vector newVect = new Vector ( ) ; <CTX> public Vector makeVector ( String [ ] stringArray ) { Vector newVect = new Vector ( ) ; int c = 0 ; try { for ( c = 0 ; c < stringArray . length ; c ++ ) { / / this should throw an expection when we hit the end stringArray [ c ] = stringArray [ c ] . trim ( ) ; newVect . add ( stringArray [ c ] ) ; } } catch ( ArrayIndexOutOfBoundsException e ) { / / we re done . . . return the vector return newVect ; } return newVect ; / / just to make sure ; - ? }	Vector < String > newVect = new Vector < String > ( ) ;
if ( ( arg . flags ( ) & ARG_OUT . value ) != 0 ) { arg . value ( ) . read_value ( input , arg . value ( ) . type ( ) ) ; } } catch ( Bounds ex ) { Unexpected . error ( ex ) ; } } <CTX> public void invoke ( ) { InvokeHandler handler = object . getHandler ( operation ( ) , cookie , false ) ; if ( handler instanceof dynImpHandler ) { DynamicImplementation dyn = ( ( dynImpHandler ) handler ) . servant ; if ( serverRequest == null ) serverRequest = new LocalServerRequest ( this ) ; try { poa . m_orb . currents . put ( Thread . currentThread ( ) , this ) ; dyn . invoke ( serverRequest ) ; } finally { poa . m_orb . currents . remove ( Thread . currentThread ( ) ) ; } } else { org . omg . CORBA . portable . InputStream input = v_invoke ( handler ) ; if ( ! exceptionReply ) { NamedValue arg ; / / Read return value , if set . if ( m_result != null ) { m_result . value ( ) . read_value ( input , m_result . value ( ) . type ( ) ) ; } / / Read returned parameters , if set . if ( m_args != null ) for ( int i = 0 ; i < m_args . count ( ) ; i ++ ) { try { arg = m_args . item ( i ) ; / / Both ARG_INOUT and ARG_OUT have this binary flag set . if ( ( arg . flags ( ) & ARG_OUT . value ) != 0 ) { arg . value ( ) . read_value ( input , arg . value ( ) . type ( ) ) ; } } catch ( Bounds ex ) { Unexpected . error ( ex ) ; } } } else / / User exception reply { / / Prepare an Any that will hold the exception . gnuAny exc = new gnuAny ( ) ; exc . insert_Streamable ( new streamReadyHolder ( input ) ) ; UnknownUserException unuex = new UnknownUserException ( exc ) ; m_environment . exception ( unuex ) ; } } }	if ( ( arg . flags ( ) & ARG_OUT . value ) != 0 ) { arg . value ( ) . read_value ( input , arg . value ( ) . type ( ) ) ; } } catch ( Bounds ex ) { Unexpected . error ( ex ) ; } } }
MylarTasksPlugin . getDefault ( ) . getContributor ( ) != null && MylarTasksPlugin . getDefault ( ) . getContributor ( ) . acceptsItem ( ( ITaskListElement ) selectedObject ) ) { MylarTasksPlugin . getDefault ( ) . getContributor ( ) . taskCompleted ( ( ITask ) selectedObject ) ; <CTX> public void run ( ) { / / MylarPlugin . getDefault ( ) . actionObserved ( this ) ; Object selectedObject = ( ( IStructuredSelection ) this . view . getViewer ( ) . getSelection ( ) ) . getFirstElement ( ) ; if ( selectedObject instanceof ITask && MylarTasksPlugin . getDefault ( ) . getContributor ( ) != null && MylarTasksPlugin . getDefault ( ) . getContributor ( ) . acceptsItem ( ( ITaskListElement ) selectedObject ) ) { MylarTasksPlugin . getDefault ( ) . getContributor ( ) . taskCompleted ( ( ITask ) selectedObject ) ; } else if ( selectedObject instanceof Task ) { ( ( Task ) selectedObject ) . setCompleted ( true ) ; } this . view . getViewer ( ) . refresh ( ) ; }	MylarTasksPlugin . getDefault ( ) . getContributorForElement ( ( ITask ) selectedObject ) != null ) { MylarTasksPlugin . getDefault ( ) . getContributorForElement ( ( ITask ) selectedObject ) . taskCompleted ( ( ITask ) selectedObject ) ;
return fileName ; <CTX> public String getFileName ( ) { return fileName ; }	return logFile . getName ( ) ;
result . append ( RubyArray . newArray ( getRuntime ( ) , key , value ) ) ; <CTX> public RubyArray to_a ( ) { RubyArray result = RubyArray . newArray ( getRuntime ( ) , length ( ) ) ; for ( Iterator iter = valueMap . entrySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) iter . next ( ) ; IRubyObject key = ( IRubyObject ) entry . getKey ( ) ; IRubyObject value = ( IRubyObject ) entry . getValue ( ) ; result . append ( RubyArray . newArray ( getRuntime ( ) , key , value ) ) ; } return result ; }	result . append ( getRuntime ( ) . newArray ( key , value ) ) ;
grid . setBorder ( StyleUtil . nextBorderStyle ( grid . getBorder ( ) ) ) ; <CTX> public void actionPerformed ( ActionEvent e ) { grid . setBorder ( StyleUtil . nextBorderStyle ( grid . getBorder ( ) ) ) ; }	grid . setBorder ( StyleUtil . nextBorderSize ( grid . getBorder ( ) ) ) ;
rsMeta ) ; <CTX> private static void populateOdiResultSet ( ResultSetPopulator populator , OdiResultSetWrapper rsWrapper , SortSpec sortSpec ) throws DataException { Object resultSource = rsWrapper . getWrappedOdiResultSet ( ) ; assert resultSource != null ; ResultSetCache smartCache = null ; BaseQuery query = populator . getQuery ( ) ; IResultClass rsMeta = populator . getResultSetMetadata ( ) ; if ( resultSource instanceof ResultSet ) { smartCache = new SmartCache ( new CacheRequest ( query . getMaxRows ( ) , query . getFetchEvents ( ) , sortSpec , populator . getEventHandler ( ) , query . getDistinctValueFlag ( ) ) , ( ResultSet ) resultSource , rsMeta ) ; } else if ( resultSource instanceof ICustomDataSet ) { smartCache = new SmartCache ( new CacheRequest ( query . getMaxRows ( ) , query . getFetchEvents ( ) , sortSpec , populator . getEventHandler ( ) , query . getDistinctValueFlag ( ) ) , new OdiAdapter ( ( ICustomDataSet ) resultSource ) , rsMeta ) ; } else if ( resultSource instanceof IDataSetPopulator ) { smartCache = new SmartCache ( new CacheRequest ( query . getMaxRows ( ) , query . getFetchEvents ( ) , sortSpec , populator . getEventHandler ( ) , query . getDistinctValueFlag ( ) ) , new OdiAdapter ( ( IDataSetPopulator ) resultSource ) , rsMeta ) ; } else if ( resultSource instanceof DataSetResultCache ) { smartCache = new SmartCache ( new CacheRequest ( query . getMaxRows ( ) , query . getFetchEvents ( ) , sortSpec , populator . getEventHandler ( ) , false ) , / / must be true new OdiAdapter ( ( DataSetResultCache ) resultSource ) , rsMeta ) ; } else if ( resultSource instanceof IResultIterator ) { smartCache = new SmartCache ( new CacheRequest ( query . getMaxRows ( ) , query . getFetchEvents ( ) , sortSpec , populator . getEventHandler ( ) , false ) , / / must be true new OdiAdapter ( ( IResultIterator ) resultSource ) , rsMeta ) ; } else if ( resultSource instanceof Object [ ] ) { Object [ ] obs = ( Object [ ] ) resultSource ; smartCache = new SmartCache ( new CacheRequest ( query . getMaxRows ( ) , query . getFetchEvents ( ) , sortSpec , populator . getEventHandler ( ) , false ) , / / must be true ( ResultSetCache ) obs [ 0 ] , ( ( int [ ] ) obs [ 1 ] ) [ 0 ] , ( ( int [ ] ) obs [ 1 ] ) [ 1 ] , rsMeta ) ; } populator . getGroupProcessorManager ( ) . getGroupCalculationUtil ( ) . setResultSetCache ( smartCache ) ; populator . setCache ( smartCache ) ; }	rsMeta , session ) ;
EOEnterpriseObject eo = ( EOEnterpriseObject ) displayGroup ( ) . allObjects ( ) . objectAtIndex ( 0 ) ; return eo . editingContext ( ) ; <CTX> public EOEditingContext editingContext ( ) { EOEnterpriseObject eo = ( EOEnterpriseObject ) displayGroup ( ) . allObjects ( ) . objectAtIndex ( 0 ) ; return eo . editingContext ( ) ; }	return displayGroup ( ) . dataSource ( ) . editingContext ( ) ;
PetName pn = user . getPetNameDB ( ) . getByName ( req . getParameter ( AddressesServlet . PARAM_NAME ) ) ; <CTX> private boolean handleAddressbook ( User user , HttpServletRequest req ) { if ( ( ! user . getAuthenticated ( ) ) || ( empty ( AddressesServlet . PARAM_ACTION ) ) ) { return false ; } String action = req . getParameter ( AddressesServlet . PARAM_ACTION ) ; if ( AddressesServlet . ACTION_ADD_TAG . equals ( action ) ) { String name = req . getParameter ( AddressesServlet . PARAM_NAME ) ; if ( ! user . getPetNameDB ( ) . containsName ( name ) ) { PetName pn = new PetName ( name , AddressesServlet . NET_SYNDIE , AddressesServlet . PROTO_TAG , name ) ; user . getPetNameDB ( ) . add ( pn ) ; BlogManager . instance ( ) . saveUser ( user ) ; } return false ; } else if ( ( AddressesServlet . ACTION_ADD_ARCHIVE . equals ( action ) ) || ( AddressesServlet . ACTION_ADD_BLOG . equals ( action ) ) || ( AddressesServlet . ACTION_ADD_EEPSITE . equals ( action ) ) || ( AddressesServlet . ACTION_ADD_OTHER . equals ( action ) ) || ( AddressesServlet . ACTION_ADD_PEER . equals ( action ) ) ) { PetName pn = buildNewAddress ( req ) ; if ( ( pn != null ) && ( pn . getName ( ) != null ) && ( pn . getLocation ( ) != null ) && ( ! user . getPetNameDB ( ) . containsName ( pn . getName ( ) ) ) ) { user . getPetNameDB ( ) . add ( pn ) ; BlogManager . instance ( ) . saveUser ( user ) ; updateSyndication ( user , pn . getLocation ( ) , ! empty ( req , AddressesServlet . PARAM_SYNDICATE ) ) ; if ( pn . isMember ( FilteredThreadIndex . GROUP_FAVORITE ) || pn . isMember ( FilteredThreadIndex . GROUP_IGNORE ) ) return true ; else return false ; } else { / / not valid , ignore return false ; } } else if ( ( AddressesServlet . ACTION_UPDATE_ARCHIVE . equals ( action ) ) || ( AddressesServlet . ACTION_UPDATE_BLOG . equals ( action ) ) || ( AddressesServlet . ACTION_UPDATE_EEPSITE . equals ( action ) ) || ( AddressesServlet . ACTION_UPDATE_OTHER . equals ( action ) ) || ( AddressesServlet . ACTION_UPDATE_PEER . equals ( action ) ) ) { return updateAddress ( user , req ) ; } else if ( ( AddressesServlet . ACTION_DELETE_ARCHIVE . equals ( action ) ) || ( AddressesServlet . ACTION_DELETE_BLOG . equals ( action ) ) || ( AddressesServlet . ACTION_DELETE_EEPSITE . equals ( action ) ) || ( AddressesServlet . ACTION_DELETE_OTHER . equals ( action ) ) || ( AddressesServlet . ACTION_DELETE_TAG . equals ( action ) ) || ( AddressesServlet . ACTION_DELETE_PEER . equals ( action ) ) ) { PetName pn = user . getPetNameDB ( ) . getByName ( req . getParameter ( AddressesServlet . PARAM_NAME ) ) ; if ( pn != null ) { user . getPetNameDB ( ) . remove ( pn ) ; BlogManager . instance ( ) . saveUser ( user ) ; updateSyndication ( user , pn . getLocation ( ) , false ) ; if ( pn . isMember ( FilteredThreadIndex . GROUP_FAVORITE ) || pn . isMember ( FilteredThreadIndex . GROUP_IGNORE ) ) return true ; else return false ; } else { return false ; } } else { / / not an addressbook op return false ; } }	String name = req . getParameter ( AddressesServlet . PARAM_NAME ) ; PetName pn = user . getPetNameDB ( ) . getByName ( name ) ;
Date date = TimeUtil . parseDate ( dateStr ) ; <CTX> public void handleDAVResponse ( DAVResponse child ) { String href = PathUtil . removeTrailingSlash ( child . getHref ( ) ) ; href = PathUtil . decode ( href ) ; String name = PathUtil . tail ( href ) ; / / build direntry SVNNodeKind kind = SVNNodeKind . FILE ; Object revisionStr = child . getPropertyValue ( DAVElement . VERSION_NAME ) ; long lastRevision = Long . parseLong ( revisionStr . toString ( ) ) ; String sizeStr = ( String ) child . getPropertyValue ( DAVElement . GET_CONTENT_LENGTH ) ; long size = sizeStr == null ? 0 : Long . parseLong ( sizeStr ) ; if ( child . getPropertyValue ( DAVElement . RESOURCE_TYPE ) == DAVElement . COLLECTION ) { kind = SVNNodeKind . DIR ; } String author = ( String ) child . getPropertyValue ( DAVElement . CREATOR_DISPLAY_NAME ) ; String dateStr = ( String ) child . getPropertyValue ( DAVElement . CREATION_DATE ) ; Date date = TimeUtil . parseDate ( dateStr ) ; boolean hasProperties = false ; for ( Iterator props = child . properties ( ) ; props . hasNext ( ) ; ) { DAVElement property = ( DAVElement ) props . next ( ) ; if ( DAVElement . SVN_CUSTOM_PROPERTY_NAMESPACE . equals ( property . getNamespace ( ) ) || DAVElement . SVN_SVN_PROPERTY_NAMESPACE . equals ( property ) ) { hasProperties = true ; break ; } } result [ 0 ] = new SVNDirEntry ( name , kind , size , hasProperties , lastRevision , date , author ) ; }	Date date = dateStr != null ? TimeUtil . parseDate ( dateStr ) : null ;
if ( ! treeIsDisposed ) { Object data = item . getData ( ) ; if ( usingElementMap ( ) && data != null ) { unmapElement ( data , item ) ; <CTX> public void widgetDisposed ( DisposeEvent e ) { if ( ! treeIsDisposed ) { Object data = item . getData ( ) ; if ( usingElementMap ( ) && data != null ) { unmapElement ( data , item ) ; } } }	if ( ! treeIsDisposed ) { Object data = item . getData ( ) ; if ( usingElementMap ( ) && data != null ) { unmapElement ( data , item ) ; }
static private void stopUpdateResetAndReport ( ) { <CTX> static private void stopUpdateResetAndReport ( ) { if ( VM . BuildForHPM && enabled ) { / / - # if RVM_WITH_HPM stopUpdateAndReset ( ) ; Report ( ) ; / / - # endif } }	static private void stopUpdateResetAndReport ( ) throws VM_PragmaUninterruptible {
return getFormattedZone ( zoneid , pattern , daylight , date ) ; <CTX> public String getFormattedZone ( String zoneid , String pattern , long date ) { TimeZone tz = TimeZone . getTimeZone ( zoneid ) ; long gmtOffset 1 = tz . getOffset ( date ) ; boolean daylight = tz . getRawOffset ( ) == gmtOffset 1 ; return getFormattedZone ( zoneid , pattern , daylight , date ) ; }	return getFormattedZone ( zoneid , pattern , daylight , gmtOffset 1 ) ;
if ( f . matchesDroppedConnection ( ) && f ._source == ctx ) { <CTX> public void onDisconnect ( PeerContext ctx ) { synchronized (_filters ) { ListIterator i =_filters . listIterator ( ) ; while ( i . hasNext ( ) ) { MessageFilter f = ( MessageFilter ) i . next ( ) ; if ( f . matchesDroppedConnection ( ) && f ._source == ctx ) { f . onDroppedConnection ( ctx ) ; if ( f . droppedConnection ( ) != null ) { synchronized ( f ) { f . notifyAll ( ) ; } } } } } }	if ( f . matchesDroppedConnection ( ) && ( f ._source == ctx ) ) {
myOperationContext = new GeneratorTreeNodeOperationContext ( generator , operationContext ) ; <CTX> public GeneratorTreeNode ( String text , Generator generator , IdeMain ide , MPSProject project , IOperationContext operationContext ) { super ( text ) ; myGenerator = generator ; myIDE = ide ; myProject = project ; myOperationContext = new GeneratorTreeNodeOperationContext ( generator , operationContext ) ; populate ( ) ; }	myOperationContext = GeneratorOperationContext . createContext ( generator , operationContext ) ;
int sproc_SectionAdd ( final Table_section sectionData ) { <CTX> int sproc_SectionAdd ( final Table_section sectionData ) { final SQLTransaction transaction = sqlProcessor . startTransaction ( ) ; transaction . executeAndCommit ( new TransactionContent ( ) { public void execute ( ) throws SQLException { Table_section textDocsToBeCopied = selectFrom_section ( transaction , new Integer ( sectionData . section_id ) ) ; if ( null == textDocsToBeCopied ) { insertInto_sections ( transaction , sectionData ) ; } else { update_sections ( transaction , sectionData ) ; } } } ) ; return transaction . getRowCount ( ) ; }	public int sproc_SectionAdd ( final Table_section sectionData ) {
NavigatorContentExtension [ ] resultInstances = findContentExtensionsByTriggerPoint ( anElement ) ; return extractContentProviders ( resultInstances ) ; <CTX> public ITreeContentProvider [ ] findParentContentProviders ( Object anElement ) { NavigatorContentExtension [ ] resultInstances = findContentExtensionsByTriggerPoint ( anElement ) ; return extractContentProviders ( resultInstances ) ; }	return extractContentProviders ( findContentExtensionsByTriggerPoint ( anElement ) ) ;
if ( result != null && result . unscheduleFiringTrigger ( ) ) return INSTRUCTION_SET_TRIGGER_COMPLETE ; <CTX> public int executionComplete ( JobExecutionContext context , JobExecutionException result ) { if ( result != null && result . refireImmediately ( ) ) return INSTRUCTION_RE_EXECUTE_JOB ; if ( result != null && result . unscheduleFiringTrigger ( ) ) return INSTRUCTION_SET_TRIGGER_COMPLETE ; if ( result != null && result . unscheduleAllTriggers ( ) ) return INSTRUCTION_SET_ALL_JOB_TRIGGERS_COMPLETE ; if ( ! mayFireAgain ( ) ) return INSTRUCTION_DELETE_TRIGGER ; return INSTRUCTION_NOOP ; }	if ( result != null && result . unscheduleFiringTrigger ( ) ) { return INSTRUCTION_SET_TRIGGER_COMPLETE ; }
super ( replacementString , replacementOffset , replacementLength , image , displayString , relevance ) ; this . localString = displayString ; <CTX> public AnnotationTagProposal ( String replacementString , int replacementOffset , int replacementLength , Image image , String displayString , int relevance ) { super ( replacementString , replacementOffset , replacementLength , image , displayString , relevance ) ; this . localString = displayString ; }	Assert . isNotNull ( replacementString ) ; Assert . isTrue ( replacementOffset >= 0 ) ; Assert . isTrue ( replacementLength >= 0 ) ; setReplacementString ( replacementString ) ; setReplacementOffset ( replacementOffset ) ; setReplacementLength ( replacementLength ) ; setImage ( image ) ; setDisplayString ( displayString == null ? replacementString : displayString ) ; setRelevance ( relevance ) ; setCursorPosition ( replacementString . length ( ) ) ; setSortString ( displayString == null ? replacementString : displayString ) ; this . localString = replacementString ;
return RubyArray . newArray ( runtime , runtime . getLoadService ( ) . getLoadedFeatures ( ) ) ; <CTX> public IRubyObject get ( ) { return RubyArray . newArray ( runtime , runtime . getLoadService ( ) . getLoadedFeatures ( ) ) ; }	return runtime . newArray ( runtime . getLoadService ( ) . getLoadedFeatures ( ) ) ;
return isSubclass ( aClass , ancestorName , new HashSet ( ) ) ; <CTX> public static boolean isSubclass ( PsiClass aClass , String ancestorName ) { return isSubclass ( aClass , ancestorName , new HashSet ( ) ) ; }	final PsiManager psiManager = aClass . getManager ( ) ; final Project project = psiManager . getProject ( ) ; final GlobalSearchScope scope = GlobalSearchScope . allScope ( project ) ; final PsiClass ancestorClass = psiManager . findClass ( ancestorName , scope ) ; return InheritanceUtil . isInheritorOrSelf ( aClass , ancestorClass , false ) ;
return false ; <CTX> private boolean findServlet ( ) { ArrayList componentData = new ArrayList ( ) ; ComponentData societyData = experiment . getSocietyComponentData ( ) ; ComponentData [ ] cdata = societyData . getChildren ( ) ; for ( int i = 0 ; i < cdata . length ; i ++ ) componentData . add ( cdata [ i ] ) ; for ( int i = 0 ; i < componentData . size ( ) ; i ++ ) { Object o = componentData . get ( i ) ; if ( o instanceof AgentComponentData ) { if ( hasServlet ( ( AgentComponentData ) o ) ) return true ; } else { ComponentData [ ] tmp = ( ( ComponentData ) o ) . getChildren ( ) ; for ( int j = 0 ; j < tmp . length ; j ++ ) componentData . add ( tmp [ j ] ) ; } } return false ; }	return null ;
if ( ! Util . equals ( this . image , part . getTitleImage ( ) ) ) { firePropertyChange ( IWorkbenchPartConstants . PROP_TITLE ) ; } <CTX> protected void refreshFromPart ( ) { deferEvents ( true ) ; setPartName ( computePartName ( ) ) ; setTitle ( computeTitle ( ) ) ; setContentDescription ( computeContentDescription ( ) ) ; setToolTip ( getRawToolTip ( ) ) ; if ( ! Util . equals ( this . image , part . getTitleImage ( ) ) ) { firePropertyChange ( IWorkbenchPartConstants . PROP_TITLE ) ; } deferEvents ( false ) ; }	setImageDescriptor ( computeImageDescriptor ( ) ) ;
byteBuf = new byte [ len ] ; oldPosition = buffer . position ( ) ; try { buffer . position ( offset ) ; buffer . get ( byteBuf ) ; try { return new String ( byteBuf , charsetName ) ; } catch ( UnsupportedEncodingException uex ) { } } finally { buffer . position ( oldPosition ) ; } return null ; <CTX> private static String decodeName ( int platform , int encoding , int language , ByteBuffer buffer , int offset , int len ) { byte [ ] byteBuf ; String charsetName ; int oldPosition ; charsetName = getCharsetName ( platform , language , encoding ) ; if ( charsetName == null ) return null ; byteBuf = new byte [ len ] ; oldPosition = buffer . position ( ) ; try { buffer . position ( offset ) ; buffer . get ( byteBuf ) ; try { return new String ( byteBuf , charsetName ) ; } catch ( UnsupportedEncodingException uex ) { } } finally { buffer . position ( oldPosition ) ; } return null ; }	return decodeName ( charsetName , buffer , offset , len ) ;
Index newindex = tn . createIndexPrivate ( col , name , unique ) ; <CTX> Index createIndex ( int col [ ] , HsqlName name , boolean unique ) throws SQLException { if ( table . isEmpty ( ) || table . isIndexingMutable ( ) ) { Index newindex = table . createIndex ( col , name , unique ) ; return newindex ; } else { Table tn = table . moveDefinition ( null , null , table . getColumnCount ( ) , 0 ) ; Index newindex = tn . createIndexPrivate ( col , name , unique ) ; tn . moveData ( table , table . getColumnCount ( ) , 0 ) ; tn . updateConstraints ( table , table . getColumnCount ( ) , 0 ) ; int index = table . dDatabase . getTableIndex ( table ) ; table . dDatabase . getTables ( ) . set ( index , tn ) ; table = tn ; return newindex ; } }	Index newindex = tn . createIndexStructure ( col , name , unique ) ;
if ( VM . VerifyAssertions && VM . runningVM ) VM . assert ( VM . NOT_REACHED ) ; <CTX> static public VM_Address max ( ) { if ( VM . VerifyAssertions && VM . runningVM ) VM . assert ( VM . NOT_REACHED ) ; / / call site should have been hijacked by magic in compiler return new VM_Address ( - 1 ) ; }	if ( VM . VerifyAssertions && VM . runningVM ) VM ._assert ( VM . NOT_REACHED ) ;
extensionImage = provider . get ( PDEPluginImages . DESC_EXTENSION_OBJ ) ; genericElementImage = provider <CTX> public void initializeImages ( ) { PDELabelProvider provider = PDEPlugin . getDefault ( ) . getLabelProvider ( ) ; extensionImage = provider . get ( PDEPluginImages . DESC_EXTENSION_OBJ ) ; genericElementImage = provider . get ( PDEPluginImages . DESC_GENERIC_XML_OBJ ) ; }	fExtensionImage = provider . get ( PDEPluginImages . DESC_EXTENSION_OBJ ) ; fGenericElementImage = provider
remove ( 0 ) ; <CTX> public void setView ( Component v ) { while ( getComponentCount ( ) > 0 ) remove ( 0 ) ; if ( v != null ) { add ( v ) ; fireStateChanged ( ) ; } }	{ if ( viewListener != null ) getView ( ) . removeComponentListener ( viewListener ) ; remove ( 0 ) ; }
setDegreeModule ( null ) ; setCourseGroup ( null ) ; setBeginExecutionPeriod ( null ) ; setEndExecutionPeriod ( null ) ; <CTX> public void delete ( ) { removeCurricularPeriod ( ) ; setDegreeModule ( null ) ; setCourseGroup ( null ) ; setBeginExecutionPeriod ( null ) ; setEndExecutionPeriod ( null ) ; super . deleteDomainObject ( ) ; }	removeDegreeModule ( ) ; removeCourseGroup ( ) ; removeBeginExecutionPeriod ( ) ; removeEndExecutionPeriod ( ) ;
cellHeight = list . getFixedCellHeight ( ) ; cellWidth = list . getFixedCellWidth ( ) ; <CTX> protected void updateLayoutState ( ) { int nrows = list . getModel ( ) . getSize ( ) ; cellHeight = - 1 ; cellWidth = - 1 ; if ( cellHeights == null || cellHeights . length != nrows ) cellHeights = new int [ nrows ] ; if ( list . getFixedCellHeight ( ) == - 1 || list . getFixedCellWidth ( ) == - 1 ) { ListCellRenderer rend = list . getCellRenderer ( ) ; for ( int i = 0 ; i < nrows ; ++ i ) { Component flyweight = rend . getListCellRendererComponent ( list , list . getModel ( ) . getElementAt ( i ) , 0 , false , false ) ; Dimension dim = flyweight . getPreferredSize ( ) ; cellHeights [ i ] = dim . height ; / / compute average cell height ( little hack here ) cellHeight = ( cellHeight * i + cellHeights [ i ] ) / ( i + 1 ) ; cellWidth = Math . max ( cellWidth , dim . width ) ; if ( list . getLayoutOrientation ( ) == JList . VERTICAL ) cellWidth = Math . max ( cellWidth , list . getSize ( ) . width ) ; } } else { cellHeight = list . getFixedCellHeight ( ) ; cellWidth = list . getFixedCellWidth ( ) ; } }	cellHeight = - 1 ; for ( int i = 0 ; i < nrows ; ++ i ) { Component flyweight = rend . getListCellRendererComponent ( list , list . getModel ( ) . getElementAt ( i ) , i , list . isSelectedIndex ( i ) , list . getSelectionModel ( ) . getAnchorSelectionIndex ( ) == i ) ; Dimension dim = flyweight . getPreferredSize ( ) ; cellHeights [ i ] = dim . height ; } } int fixedCellWidth = list . getFixedCellWidth ( ) ; if ( fixedCellWidth > 0 ) cellWidth = fixedCellWidth ; else { for ( int i = 0 ; i < nrows ; ++ i ) { Component flyweight = rend . getListCellRendererComponent ( list , list . getModel ( ) . getElementAt ( i ) , i , list . isSelectedIndex ( i ) , list . getSelectionModel ( ) . getAnchorSelectionIndex ( ) == i ) ; Dimension dim = flyweight . getPreferredSize ( ) ; cellWidth = Math . max ( cellWidth , dim . width ) ; } if ( list . getLayoutOrientation ( ) == JList . VERTICAL ) cellWidth = Math . max ( cellWidth , list . getSize ( ) . width ) ;
newTimeConfig . addTimeSyncListener ( this ) ; <CTX> public void setTimeConfig ( TimeRangeConfig newTimeConfig ) { timeConfig . removeTimeSyncListener ( this ) ; Iterator e = seismos . keySet ( ) . iterator ( ) ; timeFinder = newTimeConfig . getTimeFinder ( ) ; newTimeConfig . addTimeSyncListener ( this ) ; while ( e . hasNext ( ) ) { DataSetSeismogram current = ( DataSetSeismogram ) e . next ( ) ; timeConfig . removeSeismogram ( current ) ; this . addSeismogram ( current ) ; newTimeConfig . addSeismogram ( current , ( ( MicroSecondTimeRange ) seismos . get ( current ) ) . getBeginTime ( ) ) ; / / seismos . put ( current , newTimeConfig . getTimeRange ( current ) ) ; } seismos = newTimeConfig . getData ( ) ; timeConfig = newTimeConfig ; updateTimeSyncListeners ( ) ; }	/ * Iterator e = seismos . keySet ( ) . iterator ( ) ;
if ( resource instanceof IProject ) { activeProject = ( IProject ) resource ; projectName = activeProject . getProject ( ) . getName ( ) ; xDocPath = ( activeProject . getProject ( ) . getLocation ( ) <CTX> public void selectionChanged ( IWorkbenchPart part , ISelection selection ) { if ( selection instanceof IStructuredSelection ) { Object first = ( ( IStructuredSelection ) selection ) . getFirstElement ( ) ; IResource resource = ( IResource ) first ; if ( resource instanceof IProject ) { activeProject = ( IProject ) resource ; projectName = activeProject . getProject ( ) . getName ( ) ; xDocPath = ( activeProject . getProject ( ) . getLocation ( ) . toString ( ) + java . io . File . separator ) ; path = xDocPath + getFilename ( ) ; document = DOMUtilities . loadDOM ( path ) ; treeViewer . setInput ( document ) ; } } }	if ( resource != null ) { IProject newActiveProject = resource . getProject ( ) ; if ( newActiveProject != activeProject ) { activeProject = newActiveProject ; projectName = activeProject . getProject ( ) . getName ( ) ; xDocPath = ( activeProject . getProject ( ) . getLocation ( )
if ( fRange != null ) textEditor . selectAndReveal ( fRange . getOffset ( ) , fRange . getLength ( ) ) ; } <CTX> protected void reveal ( ITextEditor textEditor ) { if ( fRange != null ) textEditor . selectAndReveal ( fRange . getOffset ( ) , fRange . getLength ( ) ) ; }	if ( fRange != null ) { textEditor . selectAndReveal ( fRange . getOffset ( ) , fRange . getLength ( ) ) ; } }
if ( parent != null ) return parent . getForeground ( ) ; return null ; <CTX> public Color getForeground ( ) { if ( foreground != null ) return foreground ; if ( parent != null ) return parent . getForeground ( ) ; return null ; }	return parent == null ? null : parent . getForeground ( ) ;
ldmf . cloneInstance ( ( Asset ) relationship . getB ( ) ) : ldmf . cloneInstance ( ( Asset ) relationship . getA ( ) ) ; <CTX> protected void report ( Relationship relationship ) { Asset sendTo = ( ( ( Asset ) relationship . getA ( ) ) . getKey ( ) . equals ( myLocalAsset . getKey ( ) ) ) ? ldmf . cloneInstance ( ( Asset ) relationship . getB ( ) ) : ldmf . cloneInstance ( ( Asset ) relationship . getA ( ) ) ; Asset localClone = ldmf . cloneInstance ( myLocalAsset ) ; List roles = new ArrayList ( 1 ) ; Role role = ( ( ( Asset ) relationship . getA ( ) ) . getKey ( ) . equals ( myLocalAsset . getKey ( ) ) ) ? relationship . getRoleA ( ) : relationship . getRoleB ( ) ; roles . add ( role ) ; NewTask reportTask = createReportTask ( localClone , sendTo , roles , relationship . getStartTime ( ) , relationship . getEndTime ( ) ) ; publishAdd ( reportTask ) ; }	myPlanningFactory . cloneInstance ( ( Asset ) relationship . getB ( ) ) : myPlanningFactory . cloneInstance ( ( Asset ) relationship . getA ( ) ) ;
return x . getName ( ) ; <CTX> public ASTNode get ( ) { return x . getName ( ) ; }	return x . getQualifier ( ) ;
Object o = getItemDetails ( ( AbstractSearchItem ) element ) ; <CTX> private void refreshDetails ( ) { StructuredSelection selection = ( StructuredSelection ) list . getSelection ( ) ; if ( selection . size ( ) == 1 ) { Object element = selection . getFirstElement ( ) ; if ( element instanceof SearchListSeparator ) { detailsContentProvider . setElements ( new Object [ 0 ] ) ; details . getTable ( ) . setEnabled ( false ) ; } else { Object o = getItemDetails ( ( AbstractSearchItem ) element ) ; detailsContentProvider . setElements ( new Object [ ] { o } ) ; details . getTable ( ) . setEnabled ( true ) ; } } else { detailsContentProvider . setElements ( new Object [ 0 ] ) ; details . getTable ( ) . setEnabled ( false ) ; } details . refresh ( ) ; }	Object o = getItemDetails ( ( AbstractListItem ) element ) ;
Object result = ruby . evalScript ( ( String ) expr , Object . class ) ; <CTX> public Object eval ( String file , int line , int col , Object expr ) throws BSFException { String oldFile = ruby . getSourceFile ( ) ; int oldLine = ruby . getSourceLine ( ) ; ruby . setSourceFile ( file ) ; ruby . setSourceLine ( line ) ; Object result = ruby . evalScript ( ( String ) expr , Object . class ) ; ruby . setSourceFile ( oldFile ) ; ruby . setSourceLine ( oldLine ) ; return result ; }	try { Object result = ruby . evalScript ( ( String ) expr , Object . class ) ;
setVolume ( volumeScale . getSelection ( ) - VOLUME_OFFSET ) ; <CTX> public void widgetSelected ( SelectionEvent e ) { setVolume ( volumeScale . getSelection ( ) - VOLUME_OFFSET ) ; }	setVolume ( volumeScale . getSelection ( ) * VOLUME_RESOLUTION - VOLUME_OFFSET ) ;
if ( ( ( DbObject ) selection [ 0 ] . getData ( ) ) . getType ( ) == DbObject . PROCEDURE_TYPE ) <CTX> public void dragStart ( DragSourceEvent event ) { TreeItem [ ] selection = availableDbObjectsTree . getSelection ( ) ; if ( selection . length > 0 && selection [ 0 ] . getData ( ) instanceof DbObject ) { if ( ( ( DbObject ) selection [ 0 ] . getData ( ) ) . getType ( ) == DbObject . PROCEDURE_TYPE ) { event . doit = false ; return ; } ; } else if ( selection . length <= 0 || selection [ 0 ] . getData ( ) == null ) { event . doit = false ; return ; } }	if ( selection [ 0 ] . getData ( ) instanceof DbObject ) { if ( ( ( DbObject ) selection [ 0 ] . getData ( ) ) . getType ( ) == DbObject . PROCEDURE_TYPE ) { event . doit = false ; return ; } } else if ( selection [ 0 ] . getData ( ) instanceof ProcedureParameter )
return new RubyFixnum ( getRuby ( ) , pos ) ; <CTX> public RubyInteger tell ( ) { return new RubyFixnum ( getRuby ( ) , pos ) ; }	return RubyFixnum . newFixnum ( getRuby ( ) , pos ) ;
return system . hashCode ( ) ; <CTX> public int hashCode ( ) { return system . hashCode ( ) ; }	return uid . hashCode ( ) ;
sendRequest ( os , response_expected ) ; <CTX> public void sendRequest ( MessageOutputStream os , ReplyPlaceholder placeholder , int request_id , boolean response_expected ) { Integer key = new Integer ( request_id ) ; synchronized ( replies ) { replies . put ( key , placeholder ) ; } sendRequest ( os , response_expected ) ; }	try { sendRequest ( os , response_expected ) ; } catch ( org . omg . CORBA . SystemException e ) { synchronized ( replies ) { replies . remove ( key ) ; } throw e ; }
super ( ) ; tableTree = tree ; hookControl ( tree ) ; tableTreeEditor = new TableTreeEditor ( tableTree ) ; tableViewerImpl = new TableTreeViewerImpl ( this ) ; } <CTX> public TableTreeViewer ( TableTree tree ) { super ( ) ; tableTree = tree ; hookControl ( tree ) ; tableTreeEditor = new TableTreeEditor ( tableTree ) ; tableViewerImpl = new TableTreeViewerImpl ( this ) ; }	super ( ) ; tableTree = tree ; hookControl ( tree ) ; tableTreeEditor = new TableTreeEditor ( tableTree ) ; tableEditorImpl = new TableTreeEditorImpl ( this ) ; }
setList ( createList ( listId , listName ) ) ; <CTX> protected A_CmsListDialog ( CmsJspActionElement jsp , String listId , CmsMessageContainer listName , String sortedColId , String searchableColId ) { super ( jsp ) ; / / try to read the list from the session listRecovery ( listId ) ; / / initialization if ( getList ( ) == null ) { / / create the list setList ( createList ( listId , listName ) ) ; if ( searchableColId != null && getList ( ) . getMetadata ( ) . getColumnDefinition ( searchableColId ) != null ) { setSearchAction ( listId , getList ( ) . getMetadata ( ) . getColumnDefinition ( searchableColId ) ) ; } / / set the number of items per page from the user settings getList ( ) . setMaxItemsPerPage ( getSettings ( ) . getUserSettings ( ) . getExplorerFileEntries ( ) ) ; / / fill the content getList ( ) . addAllItems ( getListItems ( ) ) ; / / sort the list getList ( ) . setSortedColumn ( sortedColId , getLocale ( ) ) ; / / save the current state of the list listSave ( ) ; } }	setList ( new CmsHtmlList ( listId , listName , getMetadata ( listId ) ) ) ;
if ( resource == null ) return null ; else if ( resourceIsType ( ( IResource ) resource , resourceMask ) ) result . add ( resource ) ; } else return null ; <CTX> public static IStructuredSelection allResources ( IStructuredSelection selection , int resourceMask ) { Iterator adaptables = selection . iterator ( ) ; List result = new ArrayList ( ) ; while ( adaptables . hasNext ( ) ) { Object next = adaptables . next ( ) ; if ( next instanceof IAdaptable ) { Object resource = ( ( IAdaptable ) next ) . getAdapter ( IResource . class ) ; if ( resource == null ) return null ; else if ( resourceIsType ( ( IResource ) resource , resourceMask ) ) result . add ( resource ) ; } else return null ; } return new StructuredSelection ( result ) ; }	if ( resource == null ) { return null ; } else if ( resourceIsType ( ( IResource ) resource , resourceMask ) ) { result . add ( resource ) ; } } else { return null ; }
if ( handle instanceof Transition ) { return implementation . getUmlPackage ( ) . getStateMachines ( ) . getAStateInternalTransition ( ) . getState ( ( Transition ) handle ) ; <CTX> public Object getState ( Object handle ) { if ( handle instanceof Transition ) { return implementation . getUmlPackage ( ) . getStateMachines ( ) . getAStateInternalTransition ( ) . getState ( ( Transition ) handle ) ; } return illegalArgumentObject ( handle ) ; }	try { if ( handle instanceof Transition ) { return implementation . getUmlPackage ( ) . getStateMachines ( ) . getAStateInternalTransition ( ) . getState ( ( Transition ) handle ) ; } } catch ( InvalidObjectException e ) { throw new InvalidElementException ( e ) ;
Object row = getRow ( i + 1 ) ; TableHandleAdapter . RowUIInfomation info = getRowInfo ( row ) ; deleteCells . add ( info . getAllChildren ( ) . get ( columnNumber - 1 ) ) ; <CTX> public void deleteColumn ( int columnNumber ) throws SemanticException { transStar ( TRANS_LABEL_DELETE_COLUMN ) ; int rowCount = getRowCount ( ) ; ColumnHandle column = ( ColumnHandle ) getColumn ( columnNumber ) ; List deleteCells = new ArrayList ( ) ; for ( int i = 0 ; i < rowCount ; i ++ ) { Object row = getRow ( i + 1 ) ; TableHandleAdapter . RowUIInfomation info = getRowInfo ( row ) ; deleteCells . add ( info . getAllChildren ( ) . get ( columnNumber - 1 ) ) ; } List trueDeleteCells = new ArrayList ( ) ; int size = deleteCells . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { Object cell = deleteCells . get ( i ) ; CellHandleAdapter cellAdapt = HandleAdapterFactory . getInstance ( ) . getCellHandleAdapter ( cell ) ; if ( cellAdapt . getColumnNumber ( ) == columnNumber && cellAdapt . getColumnSpan ( ) == 1 && ! trueDeleteCells . contains ( cell ) ) { trueDeleteCells . add ( cell ) ; } } List temp = new ArrayList ( ) ; for ( int i = 0 ; i < size ; i ++ ) { Object cell = deleteCells . get ( i ) ; if ( ! trueDeleteCells . contains ( cell ) && ! temp . contains ( cell ) ) { CellHandleAdapter cellAdapt = HandleAdapterFactory . getInstance ( ) . getCellHandleAdapter ( cell ) ; cellAdapt . setColumnSpan ( cellAdapt . getColumnSpan ( ) - 1 ) ; temp . add ( cell ) ; } } size = trueDeleteCells . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { CellHandle cell = ( CellHandle ) trueDeleteCells . get ( i ) ; cell . drop ( ) ; } column . drop ( ) ; transEnd ( ) ; reload ( ) ; }	getTableHandle ( ) . drop ( ) ; return ;
} else if ( fValue > b . fValue ) { <CTX> public int compareTo ( Float b ) { if ( fValue < b . fValue ) { return - 1 ; } else if ( fValue > b . fValue ) { return 1 ; } else { return 0 ; } }	} else if ( value > b . value ) {
Goal g = internGoal ( new VisitorGoal ( job , new ReachChecker ( job , ts , nf ) ) { public Collection prerequisiteGoals ( Scheduler scheduler ) { List l = new ArrayList ( ) ; l . addAll ( super . prerequisiteGoals ( scheduler ) ) ; l . add ( TypeChecked ( job ) ) ; l . add ( ConstantsChecked ( job ) ) ; return l ; } } ) ; <CTX> public Goal ReachabilityChecked ( final Job job ) { TypeSystem ts = extInfo . typeSystem ( ) ; NodeFactory nf = extInfo . nodeFactory ( ) ; Goal g = internGoal ( new VisitorGoal ( job , new ReachChecker ( job , ts , nf ) ) { public Collection prerequisiteGoals ( Scheduler scheduler ) { List l = new ArrayList ( ) ; l . addAll ( super . prerequisiteGoals ( scheduler ) ) ; l . add ( TypeChecked ( job ) ) ; l . add ( ConstantsChecked ( job ) ) ; return l ; } } ) ; return g ; }	Goal g = ReachabilityChecked . create ( this , job , ts , nf ) ;
this . reportWarnings = reportWarnings ; <CTX> public ToolErrorReporter ( boolean reportWarnings ) { this . reportWarnings = reportWarnings ; }	this ( reportWarnings , System . err ) ;
makeTreeNodeId ( treeLevel , siblingNumber ) , makeTreeNodeName ( treeLevel , siblingNumber ) ) ; <CTX> private void createDescendantTreeNodes ( TreeNode parent , int treeLevel ) throws TreeNotFoundException { if ( treeLevel >= Constants . MAX_TREE_DEPTH ) { return ; } for ( int siblingNumber = 0 ; siblingNumber < Constants . MAX_TREE_WIDTH ; siblingNumber ++ ) { TreeNode node = signet . newTreeNode ( parent . getTree ( ) , makeTreeNodeId ( treeLevel , siblingNumber ) , makeTreeNodeName ( treeLevel , siblingNumber ) ) ; createDescendantTreeNodes ( node , treeLevel + 1 ) ; } }	makeTreeNodeId ( treeLevel , parent , siblingNumber ) , makeTreeNodeName ( treeLevel , parent , siblingNumber ) ) ; parent . addChild ( node ) ;
try { simpleDecl = callback . simpleDeclarationBegin ( container ) ; } catch ( Exception e ) { } <CTX> protected void simpleDeclaration ( Object container ) throws Backtrack { Object simpleDecl = null ; try { simpleDecl = callback . simpleDeclarationBegin ( container ) ; } catch ( Exception e ) { } declSpecifierSeq ( simpleDecl , false ) ; Object declarator = null ; if ( LT ( 1 ) != Token . tSEMI ) try { declarator = initDeclarator ( simpleDecl ) ; while ( LT ( 1 ) == Token . tCOMMA ) { consume ( ) ; try { initDeclarator ( simpleDecl ) ; } catch ( Backtrack b ) { throw b ; } } } catch ( Backtrack b ) { / / allowed to be empty } switch ( LT ( 1 ) ) { case Token . tSEMI : consume ( ) ; break ; case Token . tCOLON : ctorInitializer ( declarator ) ; / / Falling through on purpose case Token . tLBRACE : Object function = null ; try { function = callback . functionBodyBegin ( simpleDecl ) ; } catch ( Exception e ) { } if ( quickParse ) { / / speed up the parser by skiping the body / / simply look for matching brace and return consume ( Token . tLBRACE ) ; int depth = 1 ; while ( depth > 0 ) { switch ( consume ( ) . getType ( ) ) { case Token . tRBRACE : -- depth ; break ; case Token . tLBRACE : ++ depth ; break ; } } } else { functionBody ( ) ; } try { callback . functionBodyEnd ( function ) ; } catch ( Exception e ) { } break ; default : break ; } try { callback . simpleDeclarationEnd ( simpleDecl ) ; } catch ( Exception e ) { } }	Token lastToken = null ; try { simpleDecl = callback . simpleDeclarationBegin ( container , LA ( 1 ) ) ; } catch ( Exception e ) { }
return null ; <CTX> public java . sql . ResultSet getExportedKeys ( String catalog , String schema , String table ) throws SQLException { / / XXX - Not Implemented return null ; }	throw org . postgresql . Driver . notImplemented ( ) ;
void markUpdate ( Object obj , Operation op ) { markUpdate ( obj ) ; ArrayList ops = ( ArrayList ) m_operationMap . get ( key ( obj ) ) ; ops . add ( op ) ; <CTX> void markUpdate ( Object obj , Operation op ) { markUpdate ( obj ) ; ArrayList ops = ( ArrayList ) m_operationMap . get ( key ( obj ) ) ; ops . add ( op ) ; }	void markUpdate ( Object obj ) { if ( ! hasUpdates ( obj ) ) { m_operationMap . put ( key ( obj ) , new ArrayList ( ) ) ; }
PluginRepository . getInstance ( ) . getPluginInstance ( getDiscriptor ( ) ) ; <CTX> public Object getExtensionInstance ( ) throws PluginRuntimeException { / / Must synchronize here to make sure creation and initialization / / of a plugin instance and it extension instance are done by / / one and only one thread . / / The same is in PluginRepository . getPluginInstance ( ) . / / Suggested by Stefan Groschupf < sg @ media - style . com > synchronized ( getId ( ) ) { try { PluginClassLoader loader = fDescriptor . getClassLoader ( ) ; Class extensionClazz = loader . loadClass ( getClazz ( ) ) ; / / lazy loading of Plugin in case there is no instance of the plugin / / already . PluginRepository . getInstance ( ) . getPluginInstance ( getDiscriptor ( ) ) ; Object object = extensionClazz . newInstance ( ) ; return object ; } catch ( ClassNotFoundException e ) { throw new PluginRuntimeException ( e ) ; } catch ( InstantiationException e ) { throw new PluginRuntimeException ( e ) ; } catch ( IllegalAccessException e ) { throw new PluginRuntimeException ( e ) ; } } }	PluginRepository . getInstance ( ) . getPluginInstance ( getDescriptor ( ) ) ;
iDpiResolution =_d . getDPI ( ) . x ; <CTX> public final int getDpiResolution ( ) { if ( iDpiResolution == 0 ) { iDpiResolution =_d . getDPI ( ) . x ; } return iDpiResolution ; }	( ( Display )_d ) . syncExec ( new Runnable ( ) { public void run ( ) { iDpiResolution =_d . getDPI ( ) . x ; } } ) ;
context . swapBuffers ( ) ; <CTX> public void run ( ) { context . swapBuffers ( ) ; }	offscreenContext . swapBuffers ( ) ;
m_email = email ; <CTX> public void setEmail ( String email ) { m_email = email ; }	this . email = email ;
browser . endRequest ( ) ; <CTX> public void run ( ) { switch ( type ) { case LIST_DIRECTORY : listDirectory ( ) ; break ; case DELETE : delete ( ) ; break ; case RENAME : rename ( ) ; break ; case MKDIR : mkdir ( ) ; break ; } browser . endRequest ( ) ; } / / } } }	if ( type != LIST_DIRECTORY ) browser . endRequest ( ) ;
m_label = labelIdentifier . getText ( ) ; <CTX> private LabelFinder ( PsiLabeledStatement target ) { super ( ) ; final PsiIdentifier labelIdentifier = target . getLabelIdentifier ( ) ; m_label = labelIdentifier . getText ( ) ; }	label = labelIdentifier . getText ( ) ;
return fChoices ; <CTX> public ICompletionProposal [ ] getChoices ( ) { updateChoicePositions ( ) ; return fChoices ; }	return fProposals ;
inputHandle . setReportName ( locationEditor . getText ( ) . trim ( ) ) ; for ( Iterator iter = bindingList . iterator ( ) ; iter . hasNext ( ) ; ) <CTX> protected void okPressed ( ) { try { / / Remove original settings inputHandle . setURI ( null ) ; inputHandle . setTargetBookmark ( null ) ; inputHandle . setTargetWindow ( null ) ; inputHandle . setReportName ( null ) ; inputHandle . setFormatType ( null ) ; inputHandle . getMember ( Action . PARAM_BINDINGS_MEMBER ) . setValue ( null ) ; if ( DesignChoiceConstants . ACTION_LINK_TYPE_HYPERLINK . equals ( selectedType ) ) { inputHandle . setURI ( locationEditor . getText ( ) . trim ( ) ) ; inputHandle . setTargetWindow ( ChoiceSetFactory . getValueFromChoiceSet ( targetChooser . getText ( ) , CHOICESET_TARGET ) ) ; } else if ( DesignChoiceConstants . ACTION_LINK_TYPE_BOOKMARK_LINK . equals ( selectedType ) ) { inputHandle . setTargetBookmark ( bookmarkEditor . getText ( ) . trim ( ) ) ; } else if ( DesignChoiceConstants . ACTION_LINK_TYPE_DRILL_THROUGH . equals ( selectedType ) ) { inputHandle . setReportName ( locationEditor . getText ( ) . trim ( ) ) ; for ( Iterator iter = bindingList . iterator ( ) ; iter . hasNext ( ) ; ) { inputHandle . addParamBinding ( ( ParamBinding ) iter . next ( ) ) ; } if ( ! StringUtil . isBlank ( bookmarkEditor . getText ( ) ) ) { inputHandle . setTargetBookmark ( bookmarkEditor . getText ( ) . trim ( ) ) ; } inputHandle . setTargetWindow ( ChoiceSetFactory . getValueFromChoiceSet ( targetChooser . getText ( ) , CHOICESET_TARGET ) ) ; inputHandle . setFormatType ( ChoiceSetFactory . getValueFromChoiceSet ( formatChooser . getText ( ) , CHOICESET_FORMAT ) ) ; } inputHandle . setLinkType ( selectedType ) ; } catch ( SemanticException e ) { ExceptionHandler . handle ( e ) ; } setResult ( inputHandle ) ; super . okPressed ( ) ; }	if ( reportDesignButton . getSelection ( ) )
if ( value == null ) <CTX> public CSSValue getProperty ( int index ) { CSSValue value = ( CSSValue ) vs . get ( new Integer ( index ) ) ; if ( value == null ) { return parent . getProperty ( index ) ; } return value ; }	if ( value == null && parent != null )
this . annotation . resolve ( this . scope ) ; } else { if ( ( this . modifiers & AccPublic ) != 0 ) { this . scope . problemReporter ( ) . annotationMissing ( this . sourceStart , this . sourceEnd ) ; <CTX> public void resolve ( ) { if ( binding == null ) { ignoreFurtherInvestigation = true ; return ; } try { if ( ( this . bits & UndocumentedEmptyBlockMASK ) != 0 ) { this . scope . problemReporter ( ) . undocumentedEmptyBlock ( this . bodyStart - 1 , this . bodyEnd + 1 ) ; } / / check superclass & interfaces if ( binding . superclass != null ) / / watch out for Object ! ( and other roots ) if ( isTypeUseDeprecated ( binding . superclass , scope ) ) scope . problemReporter ( ) . deprecatedType ( binding . superclass , superclass ) ; if ( superInterfaces != null ) for ( int i = superInterfaces . length ; -- i >= 0 ; ) if ( superInterfaces [ i ] . resolvedType != null ) if ( isTypeUseDeprecated ( superInterfaces [ i ] . resolvedType , scope ) ) scope . problemReporter ( ) . deprecatedType ( superInterfaces [ i ] . resolvedType , superInterfaces [ i ] ) ; maxFieldCount = 0 ; int lastFieldID = - 1 ; if ( fields != null ) { for ( int i = 0 , count = fields . length ; i < count ; i ++ ) { FieldDeclaration field = fields [ i ] ; if ( field . isField ( ) ) { if ( field . binding == null ) { / / still discover secondary errors if ( field . initialization != null ) field . initialization . resolve ( field . isStatic ( ) ? staticInitializerScope : initializerScope ) ; ignoreFurtherInvestigation = true ; continue ; } maxFieldCount ++ ; lastFieldID = field . binding . id ; } else { / / initializer ( ( Initializer ) field ) . lastFieldID = lastFieldID + 1 ; } field . resolve ( field . isStatic ( ) ? staticInitializerScope : initializerScope ) ; } } if ( memberTypes != null ) { for ( int i = 0 , count = memberTypes . length ; i < count ; i ++ ) { memberTypes [ i ] . resolve ( scope ) ; } } int missingAbstractMethodslength = this . missingAbstractMethods == null ? 0 : this . missingAbstractMethods . length ; int methodsLength = this . methods == null ? 0 : methods . length ; if ( ( methodsLength + missingAbstractMethodslength ) > 0 xFFFF ) { scope . problemReporter ( ) . tooManyMethods ( this ) ; } if ( methods != null ) { for ( int i = 0 , count = methods . length ; i < count ; i ++ ) { methods [ i ] . resolve ( scope ) ; } } / / Resolve annotation if ( this . annotation != null ) { this . annotation . resolve ( this . scope ) ; } else { if ( ( this . modifiers & AccPublic ) != 0 ) { this . scope . problemReporter ( ) . annotationMissing ( this . sourceStart , this . sourceEnd ) ; } } } catch ( AbortType e ) { this . ignoreFurtherInvestigation = true ; return ; } }	if ( this . scope != null ) { this . annotation . resolve ( this . scope ) ;
root . setAllocatedWidth ( max ) ; <CTX> protected void newContext ( ) { createRoot ( ) ; / / validateBoxProperty ( root . getStyle ( ) ) ; if ( null != parent ) { / / support user defined width int max = parent . getMaxAvaWidth ( ) - parent . getCurrentIP ( ) ; if ( content != null ) { int specifiedWidth = getDimensionValue ( content . getWidth ( ) ) ; if ( specifiedWidth > 0 ) { max = Math . min ( max , specifiedWidth ) ; } } root . setAllocatedWidth ( max ) ; setMaxAvaWidth ( root . getContentWidth ( ) ) ; root . setAllocatedHeight ( parent . getMaxAvaHeight ( ) - parent . getCurrentBP ( ) ) ; setMaxAvaHeight ( root . getContentHeight ( ) ) ; } / / initialize offsetX and offsetY IStyle areaStyle = root . getStyle ( ) ; setOffsetX ( getDimensionValue ( areaStyle . getProperty ( StyleConstants . STYLE_BORDER_LEFT_WIDTH ) ) + getDimensionValue ( areaStyle . getProperty ( StyleConstants . STYLE_PADDING_LEFT ) ) ) ; setOffsetY ( isFirst ? ( getDimensionValue ( areaStyle . getProperty ( StyleConstants . STYLE_BORDER_TOP_WIDTH ) ) + getDimensionValue ( areaStyle . getProperty ( StyleConstants . STYLE_PADDING_TOP ) ) ) : 0 ) ; / / can be removed ? setCurrentBP ( 0 ) ; setCurrentIP ( 0 ) ; }	root . setAllocatedWidth ( maxW ) ;
href . parameters . putAll ( this . parameters ) ; <CTX> public Object clone ( ) { Href href = null ; try { href = ( Href ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { / / should never happen } href . parameters . putAll ( this . parameters ) ; return href ; }	href . parameters = new HashMap ( this . parameters ) ;
System . arraycopy (_heap , 0 , heapCopy , 0 ,_heap . length ) ; <CTX> public NodeIterator cloneIterator ( ) { final LookAheadIterator [ ] heapCopy = new LookAheadIterator [_heap . length ] ; try { final UnionIterator clone = ( UnionIterator ) super . clone ( ) ; System . arraycopy (_heap , 0 , heapCopy , 0 ,_heap . length ) ; clone . setRestartable ( false ) ; clone ._heap = heapCopy ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } }	for ( int i = 0 ; i <_free ; i ++ ) { heapCopy [ i ] =_heap [ i ] . cloneIterator ( ) ; }
super ( source , id ) ; this . changed = changed ; this . changedParent = changedParent ; this . changeFlags = changeFlags ; <CTX> public HierarchyEvent ( Component source , int id , Component changed , Container changedParent , long changeFlags ) { super ( source , id ) ; this . changed = changed ; this . changedParent = changedParent ; this . changeFlags = changeFlags ; }	this ( source , id , changed , changedParent , 0 ) ;
boolean placeBreakpoint ( int line ) { synchronized ( entries ) { if ( breakableLine ( line ) ) { breakpoints [ line ] = true ; return true ; } <CTX> boolean placeBreakpoint ( int line ) { synchronized ( entries ) { if ( breakableLine ( line ) ) { breakpoints [ line ] = true ; return true ; } } return false ; }	synchronized boolean placeBreakpoint ( int line ) { if ( breakableLine ( line ) ) { breakpoints [ line ] = true ; return true ;
String ret = fc . getDialogTitle ( ) ; if ( ret != null ) return ret ; switch ( fc . getDialogType ( ) ) { case JFileChooser . OPEN_DIALOG : ret = openButtonText ; break ; case JFileChooser . SAVE_DIALOG : ret = saveButtonText ; break ; default : ret = fc . getApproveButtonText ( ) ; break ; } if ( ret == null ) ret = openButtonText ; return ret ; <CTX> public String getDialogTitle ( JFileChooser fc ) { String ret = fc . getDialogTitle ( ) ; if ( ret != null ) return ret ; switch ( fc . getDialogType ( ) ) { case JFileChooser . OPEN_DIALOG : ret = openButtonText ; break ; case JFileChooser . SAVE_DIALOG : ret = saveButtonText ; break ; default : ret = fc . getApproveButtonText ( ) ; break ; } if ( ret == null ) ret = openButtonText ; return ret ; }	String result = fc . getDialogTitle ( ) ; if ( result == null ) result = getApproveButtonText ( fc ) ; return result ;
else if ( property . equals ( Constants . ENTITY_MANAGER_PROPERTY ) ) { <CTX> public void setProperty ( String propertyId , Object value ) throws XMLConfigurationException { / / Xerces properties if ( propertyId . startsWith ( Constants . XERCES_PROPERTY_PREFIX ) ) { String property = propertyId . substring ( Constants . XERCES_PROPERTY_PREFIX . length ( ) ) ; if ( property . equals ( Constants . SYMBOL_TABLE_PROPERTY ) ) { fSymbolTable = ( SymbolTable ) value ; } else if ( property . equals ( Constants . ERROR_REPORTER_PROPERTY ) ) { fErrorReporter = ( XMLErrorReporter ) value ; } else if ( property . equals ( Constants . ENTITY_MANAGER_PROPERTY ) ) { fEntityManager = ( XMLEntityManager ) value ; } } } / / setProperty ( String , Object )	else if ( propertyId . regionMatches ( prefixLength , Constants . ENTITY_MANAGER_PROPERTY , 0 , Constants . ENTITY_MANAGER_PROPERTY . length ( ) ) ) {
return ( BioModule ) ( myConsumer ) ; <CTX> public BioModule getInputModule ( ) { return ( BioModule ) ( myConsumer ) ; }	return myConsumer ;
return ReferenceScopeFactory . create ( element ) ; <CTX> IJavaSearchScope getScope ( IJavaElement element ) throws JavaModelException { return ReferenceScopeFactory . create ( element ) ; }	return ReferenceScopeFactory . createWorkspaceScope ( JavaSearchPage . getSearchJRE ( ) ) ;
return getSimpleSlot ( TableItem . FOOTER_SLOT ) ; <CTX> public LayoutSlot getFooter ( ) { return getSimpleSlot ( TableItem . FOOTER_SLOT ) ; }	return getSimpleSlot ( IListingElementModel . FOOTER_SLOT ) ;
return new AspectScoreRange ( AspectScorePoint . NEGATIVE_INFINITY , AspectScorePoint . POSITIVE_INFINITY ) ; <CTX> public AspectScoreRange getDefinedRange ( ) { return new AspectScoreRange ( AspectScorePoint . NEGATIVE_INFINITY , AspectScorePoint . POSITIVE_INFINITY ) ; }	return new AspectScoreRange ( AspectScorePoint . getNEGATIVE_INFINITY ( aspectType ) , AspectScorePoint . getPOSITIVE_INFINITY ( aspectType ) ) ;
ContainerSlot groups = table . getSlot ( TableItem . GROUP_SLOT ) ; <CTX> private void fillsEmptyCellsForTable ( ) { int columnCount = layoutTable . getColumnCount ( ) ; TableItem table = layoutTable . table ; fillsEmptyCellsForSlot ( table . getSlot ( TableItem . HEADER_SLOT ) , layoutTable . getHeader ( ) , columnCount ) ; ContainerSlot groups = table . getSlot ( TableItem . GROUP_SLOT ) ; int groupCount = groups . getCount ( ) ; for ( int i = 0 ; i < groupCount ; i ++ ) { TableGroup group = ( TableGroup ) groups . getContent ( i ) ; fillsEmptyCellsForSlot ( group . getSlot ( TableGroup . HEADER_SLOT ) , layoutTable . getGroupHeaders ( ) . getLayoutSlot ( i ) , columnCount ) ; } fillsEmptyCellsForSlot ( table . getSlot ( TableItem . DETAIL_SLOT ) , layoutTable . getDetail ( ) , columnCount ) ; / / the group level in the group is from 0 to groupCount - 1 ; / / the group level in the layout slot band is from groupCount - 1 to 0 . for ( int i = groupCount - 1 ; i >= 0 ; i -- ) { TableGroup group = ( TableGroup ) groups . getContent ( groupCount - i - 1 ) ; fillsEmptyCellsForSlot ( group . getSlot ( TableGroup . FOOTER_SLOT ) , layoutTable . getGroupFooters ( ) . getLayoutSlot ( i ) , columnCount ) ; } fillsEmptyCellsForSlot ( table . getSlot ( TableItem . FOOTER_SLOT ) , layoutTable . getFooter ( ) , columnCount ) ; }	ContainerSlot groups = table . getSlot ( IListingElementModel . GROUP_SLOT ) ;
SimpleComboBoxModel model = createEnemyComboBoxModel ( zeroBased ) ; <CTX> public static JComboBox createEnemyComboBox ( boolean zeroBased , final ActionListener al ) { SimpleComboBoxModel model = createEnemyComboBoxModel ( zeroBased ) ; final JComboBox out = new JComboBox ( model ) ; out . addActionListener ( al ) ; model . addListDataListener ( new ListDataListener ( ) { public void contentsChanged ( ListDataEvent lde ) { if ( out . getSelectedIndex ( ) == - 1 ) { out . removeActionListener ( al ) ; out . setSelectedIndex ( lde . getIndex 0 ( ) ) ; out . addActionListener ( al ) ; } } public void intervalAdded ( ListDataEvent arg 0 ) { } public void intervalRemoved ( ListDataEvent arg 0 ) { } } ) ; return out ; }	SimpleComboBoxModel model = createEnemyComboBoxModel ( ) ;
return propBinding . getValue ( ) ; <CTX> public String getPropertyBinding ( String propName ) { PropertyBinding propBinding = module . findPropertyBinding ( getElement ( ) , propName ) ; if ( propBinding == null ) return null ; return propBinding . getValue ( ) ; }	DesignElement element = getElement ( ) ; while ( element != null && element . getRoot ( ) != null ) { PropertyBinding propBinding = element . getRoot ( ) . findPropertyBinding ( element , propName ) ; if ( propBinding != null ) return propBinding . getValue ( ) ; if ( element . isVirtualElement ( ) ) { element = element . getVirtualParent ( ) ; } else { element = element . getExtendsElement ( ) ; } } return null ;
if ( fUpdateThread == null || fUpdateThread . fStop ) <CTX> public void setSelection ( int [ ] selection ) { if ( selection == null || selection . length == 0 ) fList . deselectAll ( ) ; else { / / If there is a current working update defer the setting if ( fUpdateThread == null || fUpdateThread . fStop ) fList . setSelection ( selection ) ; else fUpdateThread . selectIndices ( selection ) ; } }	if ( fUpdateThread == null || fUpdateThread . fStop ) {
if ( value instanceof ElementRefValue ) value = ( ( ElementRefValue ) value ) . getName ( ) ; if ( value instanceof StructRefValue ) value = ( ( StructRefValue ) value ) . getName ( ) ; <CTX> public Object getValue ( ) { Object value = getElement ( ) . getProperty ( getModule ( ) , propDefn ) ; if ( value instanceof ElementRefValue ) value = ( ( ElementRefValue ) value ) . getName ( ) ; if ( value instanceof StructRefValue ) value = ( ( StructRefValue ) value ) . getName ( ) ; return value ; }	if ( value instanceof ReferenceValue ) return ModelUtil . needTheNamespacePrefix ( ( ReferenceValue ) value , getElement ( ) . getRoot ( ) , getModule ( ) ) ;
if ( m_oldStatus != newStatus ) { <CTX> public void updateStatus ( PollStatus newStatus ) { if ( ! getContext ( ) . isServiceUnresponsiveEnabled ( ) ) { if ( newStatus == PollStatus . STATUS_UNRESPONSIVE ) newStatus = PollStatus . STATUS_UP ; } if ( getStatus ( ) != newStatus ) { m_oldStatus = getStatus ( ) ; setStatusChangeTime ( m_pollConfig . getCurrentTime ( ) ) ; } super . updateStatus ( newStatus ) ; if ( m_oldStatus != newStatus ) { getSchedule ( ) . adjustSchedule ( ) ; } }	if ( currentStatus != newStatus ) {
ViewedMessage node = ( ViewedMessage ) path . getTip ( ) ; <CTX> public void folderSelectionChanged ( ChangeEvent aEvent ) { TreePath path = null ; Enumeration selection = ( ( FolderPanel ) aEvent . getSource ( ) ) . getSelection ( ) ; if ( selection . hasMoreElements ( ) ) { path = ( TreePath ) selection . nextElement ( ) ; } if ( path != null && ! selection . hasMoreElements ( ) ) { / / not multiple selection ViewedMessage node = ( ViewedMessage ) path . getTip ( ) ; fMessage . setMessage ( node . getMessage ( ) ) ; } else { fMessage . setMessage ( null ) ; } }	ViewedMessage node = ( ViewedMessage ) path . getPath ( ) [ path . getPath ( ) . length - 1 ] ;
writeBarrier ( src . add ( offset ) , tgt , src ) ; <CTX> public final void putFieldWriteBarrier ( VM_Address src , int offset , VM_Address tgt ) throws VM_PragmaInline { writeBarrier ( src . add ( offset ) , tgt , src ) ; }	writeBarrier ( src . add ( offset ) , tgt ) ;
if ( PsiTreeUtil . getParentOfType ( reference . getElement ( ) , <CTX> private boolean isInSynchronizedContext ( PsiReference reference ) { if ( PsiTreeUtil . getParentOfType ( reference . getElement ( ) , PsiSynchronizedStatement . class ) != null ) { return true ; } return false ; }	final PsiElement element = reference . getElement ( ) ; if ( PsiTreeUtil . getParentOfType ( element ,
ioClass = RubyIO . createIOClass ( runtime ) ; <CTX> public RubyClass getIoClass ( ) { if ( ioClass == null ) { ioClass = RubyIO . createIOClass ( runtime ) ; } return ioClass ; }	ioClass = new IOMetaClass ( runtime ) ;
d ) ; <CTX> private static ImageIcon loadJavaInternal ( ImageIcon r , Dimension d ) { Image scaled = null ; Dimension newD = getSizeKeepRatio ( new Dimension ( r . getIconWidth ( ) , r . getIconHeight ( ) ) , d ) ; scaled = r . getImage ( ) . getScaledInstance ( newD . width , newD . height , Image . SCALE_FAST ) ; r . getImage ( ) . flush ( ) ; r . setImage ( scaled ) ; return r ; / * Iterator iter = ImageIO . getImageReaders ( iis ) ; if ( ! iter . hasNext ( ) ) { return null ; } ImageReader reader = ( ImageReader ) iter . next ( ) ; ImageReadParam param = reader . getDefaultReadParam ( ) ; reader . setInput ( iis , true , false ) ; IIOMetadata metadata = reader . getImageMetadata ( 0 ) ; String names [ ] = metadata . getMetadataFormatNames ( ) ; for ( int i = 0 ; i < names . length ; i ++ ) { displayMetadata ( metadata . getAsTree ( names [ i ] ) ) ; } param . setSourceRenderSize ( d ) ; BufferedImage image = ( BufferedImage ) reader . readAsRenderedImage ( 0 , param ) ; return new ImageIcon ( image ) ; * / }	d , noStretch ) ; if ( newD == null ) { return r ; }
} else if ( getDoubleValue ( ) < 0 . 0 ) { <CTX> public RubyInteger truncate ( ) { if ( getDoubleValue ( ) > 0 . 0 ) { return floor ( ) ; } else if ( getDoubleValue ( ) < 0 . 0 ) { return ceil ( ) ; } else { return RubyFixnum . zero ( getRuntime ( ) ) ; } }	} else if ( value < 0 . 0 ) {
super ( value , name ) ; <CTX> private LegendItemType ( int value , String name ) { super ( value , name ) ; }	super ( value , name , literal ) ;
return ( ( CellHandle ) source ) . getContent ( ) . getContents ( ) . size ( ) > 0 ; <CTX> protected boolean canDrop ( Object source ) { if ( source == null ) { return false ; } if ( source instanceof StructuredSelection ) { return canDrop ( ( ( StructuredSelection ) source ) . toArray ( ) ) ; } if ( source instanceof Object [ ] ) { Object [ ] array = ( Object [ ] ) source ; if ( array . length == 0 ) { return false ; } / / If the container can drop , the children will be skipped for ( int i = 0 ; i < array . length ; i ++ ) { if ( DNDUtil . checkContainerExists ( array [ i ] , array ) ) continue ; if ( canDrop ( array [ i ] ) ) return true ; } return false ; } source = DNDUtil . unwrapToModel ( source ) ; if ( source instanceof SlotHandle ) { SlotHandle slot = ( SlotHandle ) source ; DesignElementHandle handle = slot . getElementHandle ( ) ; return slot . getContents ( ) . size ( ) > 0 && ( handle instanceof ListHandle || handle instanceof ListGroupHandle ) ; } if ( source instanceof EmbeddedImageHandle ) { return true ; } if ( source instanceof CellHandle ) { / / CellHandle is subclass of ReportElementHandle return ( ( CellHandle ) source ) . getContent ( ) . getContents ( ) . size ( ) > 0 ; } if ( source instanceof MasterPageHandle ) { return false ; } else if ( source instanceof ReportElementHandle ) { if ( ( ( ReportElementHandle ) source ) . getRoot ( ) instanceof LibraryHandle && SessionHandleAdapter . getInstance ( ) . getReportDesignHandle ( ) instanceof ReportDesignHandle ) { return false ; } return true ; } else return false ; / / return ( source instanceof ReportElementHandle / / / / && ( SessionHandleAdapter . getInstance ( ) . getReportDesignHandle ( ) / / instanceof LibraryHandle ) / / && ! ( source instanceof MasterPageHandle ) ) ; }	return ( ( CellHandle ) source ) . getContent ( ) . getContents ( ) . size ( ) > 0 && ( ( CellHandle ) source ) . canDrop ( ) ;
UMOEncryptionStrategy s = ( UMOEncryptionStrategy ) digester . peek ( ) ; ( ( UMOSecurityManager ) digester . peek ( 1 ) ) . addEncryptionStrategy ( name , s ) ; <CTX> public void end ( String endpointName , String endpointName 1 ) throws Exception { UMOEncryptionStrategy s = ( UMOEncryptionStrategy ) digester . peek ( ) ; ( ( UMOSecurityManager ) digester . peek ( 1 ) ) . addEncryptionStrategy ( name , s ) ; }	UMOTransactionManagerFactory txFactory = ( UMOTransactionManagerFactory ) digester . pop ( ) ; digester . push ( txFactory . create ( ) ) ;
try { <CTX> public void updateOuterLanguageElements ( final Set < Language > reparsedRoots ) { for ( Map . Entry < Language , PsiFile > entry : myRoots . entrySet ( ) ) { final PsiFile psiFile = entry . getValue ( ) ; final Language updatedLanguage = entry . getKey ( ) ; if ( reparsedRoots . contains ( updatedLanguage ) ) continue ; final Set < WeakReference < OuterLanguageElement >> list = myOuterLanguageElements . get ( psiFile ) ; if ( list == null ) / / not parsed yet continue ; try { myRootsInUpdate . add ( psiFile ) ; final Iterator < WeakReference < OuterLanguageElement >> iterator = list . iterator ( ) ; XmlText prevText = null ; while ( iterator . hasNext ( ) ) { WeakReference < OuterLanguageElement > reference = iterator . next ( ) ; final OuterLanguageElement outerElement = reference . get ( ) ; if ( outerElement == null ) { iterator . remove ( ) ; continue ; } final FileElement file = TreeUtil . getFileElement ( outerElement ) ; if ( file == null || file . getPsi ( ) != psiFile ) { iterator . remove ( ) ; continue ; } final XmlText nextText = outerElement . getFollowingText ( ) ; final TextRange textRange = new TextRange ( prevText != null ? prevText . getTextRange ( ) . getEndOffset ( ) : 0 , nextText != null ? nextText . getTextRange ( ) . getStartOffset ( ) : getContents ( ) . length ( ) ) ; if ( ! textRange . equals ( outerElement . getTextRange ( ) ) ) { outerElement . setRange ( textRange ) ; } prevText = nextText ; } } finally { myRootsInUpdate . remove ( psiFile ) ; checkConsistensy ( psiFile ) ; } } }	} try {
if ( fastViewBarControl != null && ! fastViewBarControl . isDisposed ( ) ) <CTX> public void run ( boolean fork , boolean cancelable , IRunnableWithProgress runnable ) throws InvocationTargetException , InterruptedException { IWorkbenchContextSupport contextSupport = getWorkbench ( ) . getContextSupport ( ) ; final boolean keyFilterEnabled = contextSupport . isKeyFilterEnabled ( ) ; Control fastViewBarControl = getFastViewBar ( ) == null ? null : getFastViewBar ( ) . getControl ( ) ; boolean fastViewBarWasEnabled = fastViewBarControl == null ? false : fastViewBarControl . getEnabled ( ) ; Control perspectiveBarControl = getPerspectiveBar ( ) == null ? null : getPerspectiveBar ( ) . getControl ( ) ; boolean perspectiveBarWasEnabled = perspectiveBarControl == null ? false : perspectiveBarControl . getEnabled ( ) ; try { if ( fastViewBarControl != null && ! fastViewBarControl . isDisposed ( ) ) fastViewBarControl . setEnabled ( false ) ; if ( perspectiveBarControl != null && ! perspectiveBarControl . isDisposed ( ) ) perspectiveBarControl . setEnabled ( false ) ; if ( keyFilterEnabled ) contextSupport . setKeyFilterEnabled ( false ) ; super . run ( fork , cancelable , runnable ) ; } finally { if ( fastViewBarControl != null && ! fastViewBarControl . isDisposed ( ) ) fastViewBarControl . setEnabled ( fastViewBarWasEnabled ) ; if ( perspectiveBarControl != null && ! perspectiveBarControl . isDisposed ( ) ) perspectiveBarControl . setEnabled ( perspectiveBarWasEnabled ) ; if ( keyFilterEnabled ) contextSupport . setKeyFilterEnabled ( true ) ; } }	if ( fastViewBarControl != null && ! fastViewBarControl . isDisposed ( ) ) {
Shell parent = e . display . getActiveShell ( ) ; AdvancedDialog dialog = new AdvancedDialog ( parent ) ; <CTX> public void widgetSelected ( SelectionEvent e ) { Shell parent = e . display . getActiveShell ( ) ; AdvancedDialog dialog = new AdvancedDialog ( parent ) ; dialog . open ( ) ; / / logic for updating the working copy is in the dialog class . }	AdvancedDialog dialog = new AdvancedDialog ( parent . getShell ( ) ) ;
return copyOfOldMap . get ( key ) ; <CTX> public Object getOldValue ( Object key ) { return copyOfOldMap . get ( key ) ; }	return oldValue ;
if ( ! m_extracted . contains ( url ) ) { m_extracted . add ( url ) ; try { String normUrl = UrlUtil . normalizeUrl ( url ) ; if ( BaseCrawler . isSupportedUrlProtocol ( normUrl ) && m_crawlSpec . isIncluded ( normUrl ) ) { m_incls . add ( normUrl ) ; } else { m_excls . add ( normUrl ) ; } } catch ( MalformedURLException e ) { m_excls . add ( url ) ; <CTX> public void foundUrl ( String url ) { if ( ! m_extracted . contains ( url ) ) { m_extracted . add ( url ) ; try { String normUrl = UrlUtil . normalizeUrl ( url ) ; if ( BaseCrawler . isSupportedUrlProtocol ( normUrl ) && m_crawlSpec . isIncluded ( normUrl ) ) { m_incls . add ( normUrl ) ; } else { m_excls . add ( normUrl ) ; } } catch ( MalformedURLException e ) { m_excls . add ( url ) ; } } }	m_extracted . add ( url ) ; try { String normUrl = UrlUtil . normalizeUrl ( url ) ; if ( BaseCrawler . isSupportedUrlProtocol ( normUrl ) && m_crawlSpec . isIncluded ( normUrl ) ) { m_incls . add ( normUrl ) ;
int size =_critics . size ( ) ; for ( int i = 0 ; i < size ; ++ i ) { Critic c = ( Critic )_critics . elementAt ( i ) ; if ( c . containsKnowledgeType ( type ) ) return true ; <CTX> public boolean containsKnowledgeType ( String type ) { int size =_critics . size ( ) ; for ( int i = 0 ; i < size ; ++ i ) { Critic c = ( Critic )_critics . elementAt ( i ) ; if ( c . containsKnowledgeType ( type ) ) return true ; } return false ; }	int size =_critics . size ( ) ; for ( int i = 0 ; i < size ; ++ i ) { Critic c = ( Critic )_critics . elementAt ( i ) ; if ( c . containsKnowledgeType ( type ) ) return true ; } return false ;
try { initial_mbrs . wait ( ) ; } catch ( Exception e ) { <CTX> void findInitialMembers ( ) { PingRsp ping_rsp ; synchronized ( initial_mbrs ) { initial_mbrs . removeAllElements ( ) ; gms . passDown ( new Event ( Event . FIND_INITIAL_MBRS ) ) ; try { initial_mbrs . wait ( ) ; } catch ( Exception e ) { } for ( int i = 0 ; i < initial_mbrs . size ( ) ; i ++ ) { ping_rsp = ( PingRsp ) initial_mbrs . elementAt ( i ) ; if ( ping_rsp . own_addr != null && gms . local_addr != null && ping_rsp . own_addr . equals ( gms . local_addr ) ) { initial_mbrs . removeElementAt ( i ) ; break ; } } } }	if ( initial_mbrs_received == false ) { try { initial_mbrs . wait ( ) ; } catch ( Exception e ) { }
JLabel renderer = ( JLabel ) getCellRenderer ( row , col ) . getTableCellRendererComponent ( this , getModel ( ) . getValueAt ( row , col ) , false , false , row , col ) ; <CTX> public String getTextForCell ( int row , int col ) { / / note : this will only work because we know all the renderers are jlabels JLabel renderer = ( JLabel ) getCellRenderer ( row , col ) . getTableCellRendererComponent ( this , getModel ( ) . getValueAt ( row , col ) , false , false , row , col ) ; return renderer . getText ( ) ; }	JLabel renderer = ( JLabel ) getCellRenderer ( row , col ) . getTableCellRendererComponent ( this , getModel ( ) . getValueAt ( row , getColumnModel ( ) . getColumn ( col ) . getModelIndex ( ) ) , false , false , row , col ) ;
stateEstimationSubscription = ( IncrementalSubscription ) getBlackboardService ( ) . subscribe ( StateEstimation . pred ) ; <CTX> protected void setupSubscriptions ( ) { diagnosesWrapperSubscription = ( IncrementalSubscription ) getBlackboardService ( ) . subscribe ( new UnaryPredicate ( ) { public boolean execute ( Object o ) { if ( o instanceof DiagnosesWrapper ) { return true ; } return false ; } } ) ; actionsWrapperSubscription = ( IncrementalSubscription ) getBlackboardService ( ) . subscribe ( new UnaryPredicate ( ) { public boolean execute ( Object o ) { if ( o instanceof ActionsWrapper ) { return true ; } return false ; } } ) ; costBenefitEvaluationSubscription = ( IncrementalSubscription ) getBlackboardService ( ) . subscribe ( CostBenefitEvaluation . pred ) ; stateEstimationSubscription = ( IncrementalSubscription ) getBlackboardService ( ) . subscribe ( StateEstimation . pred ) ; }	stateEstimationSubscription = null ;
set . add ( getClassName ( ) ) ; <CTX> public void visit ( ConstantString s ) { String value = s . getBytes ( getConstantPool ( ) ) ; if ( value . length ( ) < SIZE_OF_HUGE_CONSTANT ) return ; String key = getStringKey ( value ) ; Set < String > set = map . get ( key ) ; if ( set == null ) { set = new HashSet < String > ( ) ; map . put ( key , set ) ; } set . add ( getClassName ( ) ) ; }	set . add ( getDottedClassName ( ) ) ;
if ( node == null ) <CTX> public IHyperlink [ ] detectHyperlinks ( ITextViewer textViewer , IRegion region , boolean canShowMultipleHyperlinks ) { if ( region == null || canShowMultipleHyperlinks ) return null ; IDocumentRange element = fSourcePage . getRangeElement ( region . getOffset ( ) ) ; if ( element == null ) return null ; if ( ! ( element instanceof IDocumentAttribute ) ) return null ; / / only highlight if we are hovering inside of the attribute value IDocumentAttribute attr = ( IDocumentAttribute ) element ; if ( attr . getValueOffset ( ) > region . getOffset ( ) || attr . getValueOffset ( ) + attr . getValueLength ( ) - 1 < region . getOffset ( ) ) return null ; / / consult schema to make sure attribute is of kind IMetaAttribute . JAVA IDocumentNode node = attr . getEnclosingElement ( ) ; while ( node != null && ! ( node instanceof IPluginExtension ) ) node = node . getParentNode ( ) ; if ( node == null ) return null ; ISchema schema = PDECore . getDefault ( ) . getSchemaRegistry ( ) . getSchema ( ( ( IPluginExtension ) node ) . getPoint ( ) ) ; if ( schema == null ) return null ; ISchemaElement sElement = schema . findElement ( attr . getEnclosingElement ( ) . getXMLTagName ( ) ) ; if ( sElement == null ) return null ; ISchemaAttribute sAttr = sElement . getAttribute ( attr . getAttributeName ( ) ) ; if ( sAttr == null ) return null ; if ( ( ( IPluginAttribute ) attr ) . getValue ( ) . length ( ) == 0 ) return null ; if ( sAttr . getKind ( ) == IMetaAttribute . JAVA ) { return new IHyperlink [ ] { new JavaHyperlink ( new Region ( attr . getValueOffset ( ) , attr . getValueLength ( ) ) , ( ( IPluginExtension ) node ) . getModel ( ) . getUnderlyingResource ( ) . getProject ( ) , ( ( IPluginAttribute ) attr ) . getValue ( ) ) } ; } else if ( sAttr . getKind ( ) == IMetaAttribute . RESOURCE ) { / / TODO select OR open resource in package explorer } return null ; }	if ( node == null || ! ( ( IPluginExtension ) node ) . getModel ( ) . isEditable ( ) )
if ( programs [ i ] . getName ( ) . equals ( programName ) ) return programs [ i ] ; <CTX> private static Program findProgram ( String programName ) { Program [ ] programs = Program . getPrograms ( ) ; for ( int i = 0 ; i < programs . length ; i ++ ) { if ( programs [ i ] . getName ( ) . equals ( programName ) ) return programs [ i ] ; } return null ; }	if ( programs [ i ] . getName ( ) . equals ( programName ) ) { return programs [ i ] ; }
return null ; <CTX> private static Class findClass ( ClassLoader loader , String className ) { try { if ( loader != null ) { return loader . loadClass ( className ) ; } else { return ScriptRuntime . loadClassName ( className ) ; } } catch ( ClassNotFoundException ex ) { } catch ( SecurityException ex ) { } return null ; }	return cl ;
superMethods [ i ] . getContainingClass ( ) ; <CTX> private boolean isOverrideOfLibraryMethod ( PsiMethod method ) { final PsiMethod [ ] superMethods = PsiSuperMethodUtil . findSuperMethods ( method ) ; for ( int i = 0 ; i < superMethods . length ; i ++ ) { final PsiClass containingClass = superMethods [ i ] . getContainingClass ( ) ; if ( containingClass != null && LibraryUtil . classIsInLibrary ( containingClass ) ) { return true ; } } return false ; }	superMethod . getContainingClass ( ) ;
Set theDescriptors ) { return extractDescriptorInstances ( theDescriptors , true ) ; <CTX> private NavigatorContentExtension [ ] extractDescriptorInstances ( Set theDescriptors ) { return extractDescriptorInstances ( theDescriptors , true ) ; }	Set theDescriptors , boolean toLoadAllIfNecessary ) { if ( theDescriptors . size ( ) == 0 ) return NO_CONTENT_EXTENSIONS ; Set resultInstances = new HashSet ( ) ; for ( Iterator descriptorIter = theDescriptors . iterator ( ) ; descriptorIter . hasNext ( ) ; ) { NavigatorContentExtension extension = getExtension ( ( NavigatorContentDescriptor ) descriptorIter . next ( ) , toLoadAllIfNecessary ) ; if ( extension != null ) { resultInstances . add ( extension ) ; } } NavigatorContentExtension [ ] extensions = ( NavigatorContentExtension [ ] ) resultInstances . toArray ( new NavigatorContentExtension [ resultInstances . size ( ) ] ) ; Arrays . sort ( extensions , EXTENSION_COMPARATOR ) ; return extensions ;
tree . expandPath ( new TreePath ( ( ( DefaultMutableTreeNode ) ( tree . getModel ( ) ) . getRoot ( ) ) . getPath ( ) ) ) ; <CTX> public void installUI ( JComponent c ) { super . installUI ( c ) ; installDefaults ( ( JTree ) c ) ; tree = ( JTree ) c ; setModel ( tree . getModel ( ) ) ; tree . setRootVisible ( true ) ; tree . expandPath ( new TreePath ( ( ( DefaultMutableTreeNode ) ( tree . getModel ( ) ) . getRoot ( ) ) . getPath ( ) ) ) ; treeSelectionModel = tree . getSelectionModel ( ) ; installListeners ( ) ; installKeyboardActions ( ) ; completeUIInstall ( ) ; }	tree . expandPath ( new TreePath ( tree . getModel ( ) . getRoot ( ) ) ) ;
int start = getLineStartOffset ( caretLine ) ; if ( caret == start ) <CTX> public void goToPrevLine ( boolean select ) { int magic = getMagicCaretPosition ( ) ; int prevLine = foldVisibilityManager . getPrevVisibleLine ( caretLine ) ; int newCaret ; if ( prevLine == - 1 ) { int start = getLineStartOffset ( caretLine ) ; if ( caret == start ) { getToolkit ( ) . beep ( ) ; return ; } else newCaret = start ; } else newCaret = getLineStartOffset ( prevLine ) + xToOffset ( prevLine , magic + 1 ) ; if ( select ) extendSelection ( caret , newCaret ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( newCaret ) ; setMagicCaretPosition ( magic ) ; } / / } } }	newCaret = buffer . getLineStartOffset ( caretLine ) + xToSubregionOffset ( lineInfos [ subregion - 1 ] , magic , true ) ; } else { int prevLine = foldVisibilityManager . getPrevVisibleLine ( caretLine ) ; if ( prevLine == - 1 )
Options go = parent . getGlobalOptions ( ) ; overrideForClass ( go , cd ) ; return go ; <CTX> public Options getOptionsFor ( ClassDoc cd ) { Options go = parent . getGlobalOptions ( ) ; overrideForClass ( go , cd ) ; return go ; }	if ( globalOptions . matchesHideExpression ( cd . toString ( ) ) || ! matcher . matches ( cd ) ) { return hideOptions ; } else if ( cd . equals ( this . cd ) ) { return centerOptions ; } else if ( cd . containingPackage ( ) . equals ( this . cd . containingPackage ( ) ) ) { return packageOptions ; } else { return globalOptions ; }
dest ._format . setOmitXMLDeclaration ( src ._format . getOmitXMLDeclaration ( ) ) ; dest . fNamespaces = src . fNamespaces ; dest . fDOMErrorHandler = src . fDOMErrorHandler ; <CTX> private void copySettings ( XMLSerializer src , XMLSerializer dest ) { dest ._format . setOmitXMLDeclaration ( src ._format . getOmitXMLDeclaration ( ) ) ; dest . fNamespaces = src . fNamespaces ; dest . fDOMErrorHandler = src . fDOMErrorHandler ; dest ._format . setEncoding ( src ._format . getEncoding ( ) ) ; dest ._format . setLineSeparator ( src ._format . getLineSeparator ( ) ) ; dest . fDOMFilter = src . fDOMFilter ; / / and copy over all the entries in fFeatures : Enumeration keys = src . fFeatures . keys ( ) ; while ( keys . hasMoreElements ( ) ) { Object key = keys . nextElement ( ) ; Object val = src . fFeatures . get ( key ) ; dest . fFeatures . put ( key , val ) ; } } / / copysettings	dest . fDOMErrorHandler = fErrorHandler ;
return RubyArray . newArray ( getRuntime ( ) , <CTX> public RubyArray coerce ( RubyNumeric other ) { if ( getMetaClass ( ) == other . getMetaClass ( ) ) { return RubyArray . newArray ( getRuntime ( ) , other , this ) ; } return RubyArray . newArray ( getRuntime ( ) , RubyFloat . newFloat ( getRuntime ( ) , other . getDoubleValue ( ) ) , RubyFloat . newFloat ( getRuntime ( ) , getDoubleValue ( ) ) ) ; }	return getRuntime ( ) . newArray (
this . label = original . getName ( ) ; this . id = original . getId ( ) ; this . categoryId = original . getCategoryId ( ) ; this . description = original . getDescription ( ) ; this . isEditable = original . isEditable ( ) ; this . pluginId = original . getPluginId ( ) ; this . parsedValue = value ; <CTX> public ColorDefinition ( ColorDefinition original , RGB value ) { this . label = original . getName ( ) ; this . id = original . getId ( ) ; this . categoryId = original . getCategoryId ( ) ; this . description = original . getDescription ( ) ; this . isEditable = original . isEditable ( ) ; this . pluginId = original . getPluginId ( ) ; this . parsedValue = value ; }	this . label = label ; this . id = id ; this . defaultsTo = defaultsTo ; this . rawValue = value ; this . categoryId = categoryId ; this . description = description ; this . isEditable = isEditable ; this . pluginId = pluginId ;
int ruleAction = SPAN | REGEXP | ( ( noLineBreak ) ? NO_LINE_BREAK : 0 ) | ( ( excludeMatch ) ? EXCLUDE_MATCH : 0 ) | ( ( noWordBreak ) ? NO_WORD_BREAK : 0 ) | ( ( noEscape ) ? NO_ESCAPE : 0 ) ; return new ParserRule ( ruleAction , hashChar , startPosMatch , null , Pattern . compile ( start , ( ignoreCase ? Pattern . CASE_INSENSITIVE : 0 ) ) , endPosMatch , end . toCharArray ( ) , delegate , id ) ; <CTX> public static final ParserRule createRegexpSpanRule ( char hashChar , int startPosMatch , String start , int endPosMatch , String end , ParserRuleSet delegate , byte id , boolean excludeMatch , boolean noLineBreak , boolean noWordBreak , boolean ignoreCase , boolean noEscape ) throws PatternSyntaxException { int ruleAction = SPAN | REGEXP | ( ( noLineBreak ) ? NO_LINE_BREAK : 0 ) | ( ( excludeMatch ) ? EXCLUDE_MATCH : 0 ) | ( ( noWordBreak ) ? NO_WORD_BREAK : 0 ) | ( ( noEscape ) ? NO_ESCAPE : 0 ) ; return new ParserRule ( ruleAction , hashChar , startPosMatch , null , Pattern . compile ( start , ( ignoreCase ? Pattern . CASE_INSENSITIVE : 0 ) ) , endPosMatch , end . toCharArray ( ) , delegate , id ) ; } / / } } }	return createRegexpSpanRule ( String . valueOf ( hashChar ) , startPosMatch , start , endPosMatch , end , delegate , id , excludeMatch , noLineBreak , noWordBreak , ignoreCase , noEscape ) ;
OutputFormat format = OutputFormat . createPrettyPrint ( ) ; XMLWriter writer = new XMLWriter ( resp . getOutputStream ( ) , format ) ; writer . write ( outMsg ) ; <CTX> protected void sendResponse ( DavContext ctxt , Document outMsg ) throws IOException { HttpServletResponse resp = ctxt . getResponse ( ) ; resp . setStatus ( ctxt . getStatus ( ) ) ; if ( outMsg != null ) { resp . setContentType ( DavProtocol . DAV_CONTENT_TYPE ) ; OutputFormat format = OutputFormat . createPrettyPrint ( ) ; XMLWriter writer = new XMLWriter ( resp . getOutputStream ( ) , format ) ; writer . write ( outMsg ) ; } ctxt . responseSent ( ) ; }	DavResponse respMsg = ctxt . getDavResponse ( ) ; respMsg . writeTo ( resp . getOutputStream ( ) ) ;
return situation . getState ( ) . equals ( new State ( State . ACTIVE ) ) ; <CTX> public ReimbursementGuideSituation getActiveReimbursementGuideSituation ( ) { return ( ReimbursementGuideSituation ) CollectionUtils . find ( getReimbursementGuideSituations ( ) , new Predicate ( ) { public boolean evaluate ( Object obj ) { ReimbursementGuideSituation situation = ( ReimbursementGuideSituation ) obj ; return situation . getState ( ) . equals ( new State ( State . ACTIVE ) ) ; } } ) ; }	return situation . getState ( ) . getState ( ) . equals ( State . ACTIVE ) ;
if ( name . toLowerCase ( ) . endsWith ( extension ) ) { <CTX> public boolean accept ( File dir , String name ) { if ( name . toLowerCase ( ) . endsWith ( extension ) ) { return true ; } return false ; }	String lowerCaseName = name . toLowerCase ( ) ; if ( lowerCaseName . endsWith ( SUFFIX_STRING_jar ) || lowerCaseName . endsWith ( SUFFIX_STRING_zip ) ) {
append ( text ) ; <CTX> public void appendText ( String text ) { append ( text ) ; }	TextAreaPeer peer = ( TextAreaPeer ) getPeer ( ) ; if ( peer == null ) return ; peer . insert ( str , peer . getText ( ) . length ( ) ) ;
Onion commands = type ( ) . commands ( state ) ; return ( Command ) commands . find ( Command . finder ( commandName ) ) ; <CTX> public Command command ( String commandName , State state ) { Onion commands = type ( ) . commands ( state ) ; return ( Command ) commands . find ( Command . finder ( commandName ) ) ; }	return command ( commandName , startState ( ) ) ;
Library lib = module . getVisibleLibraryWithNamespace ( libReference . getLibraryNamespace ( ) ) ; <CTX> public Object getProperty ( Module module , PropertyDefn propDefn ) { assert propDefn != null ; / / return local value first Object value = getLocalProperty ( module , propDefn ) ; if ( value != null ) return value ; / / first , read property values in local ; second , check the library / / reference and load the property values from it ; third , read default / / in ROM if ( libReference != null && module != null ) { ReferencableStructure refStruct = libReference . getTargetStructure ( ) ; if ( refStruct != null ) { Library lib = module . getVisibleLibraryWithNamespace ( libReference . getLibraryNamespace ( ) ) ; Module root = lib == null ? module : lib ; value = refStruct . getProperty ( root , propDefn ) ; if ( value != null ) return value ; } } if ( value == null ) return propDefn . getDefault ( ) ; return value ; }	Library lib = module . getLibraryWithNamespace ( libReference . getLibraryNamespace ( ) , IModuleNameSpace . ONE_LEVEL ) ;
return nativeIsLeaf ( nativeRDFNode ) ; <CTX> public boolean isLeaf ( ) { Assert . assert ( - 1 != nativeRDFNode ) ; return nativeIsLeaf ( nativeRDFNode ) ; }	return nativeIsLeaf ( nativeWebShell , nativeRDFNode ) ;
catchCond = new Node ( TokenStream . PRIMARY , new Integer ( TokenStream . TRUE ) ) ; <CTX> public Object createCatch ( String varName , Object catchCond , Object stmts , int lineno ) { if ( catchCond == null ) catchCond = new Node ( TokenStream . PRIMARY , new Integer ( TokenStream . TRUE ) ) ; Node result = new Node ( TokenStream . CATCH , ( Node ) createName ( varName ) , ( Node ) catchCond , ( Node ) stmts ) ; result . setDatum ( new Integer ( lineno ) ) ; return result ; }	catchCond = new Node ( TokenStream . PRIMARY , TokenStream . TRUE ) ;
if ( isZoomed ( ) ) zoomOut ( ) ; <CTX> public void savePerspectiveAs ( IPerspectiveDescriptor newDesc ) { Perspective persp = getActivePerspective ( ) ; if ( persp == null ) return ; IPerspectiveDescriptor oldDesc = persp . getDesc ( ) ; / / Always unzoom . if ( isZoomed ( ) ) zoomOut ( ) ; persp . saveDescAs ( newDesc ) ; window . firePerspectiveSavedAs ( this , oldDesc , newDesc ) ; }	if ( isZoomed ( ) ) { zoomOut ( ) ; }
if ( xsi_type != null ) return context . getTypeUnmarshaller ( xsi_type ) ; <CTX> public TypeUnmarshaller getTypeUnmarshaller ( UnmarshalContextImpl context ) { final QName xsi_type = context . getXsiType ( ) ; if ( xsi_type != null ) return context . getTypeUnmarshaller ( xsi_type ) ; if ( context . hasXsiNil ( ) ) return NullUnmarshaller . getInstance ( ) ; return unmarshaller ; }	if ( xsi_type != null ) { TypeUnmarshaller typed_um = context . getTypeUnmarshaller ( xsi_type ) ; if ( typed_um != null ) return typed_um ; }
Set allCols = new HashSet ( ) ; allCols . addAll ( this . columns . values ( ) ) ; <CTX> public void destroy ( ) { Set allCols = new HashSet ( ) ; allCols . addAll ( this . columns . values ( ) ) ; / / Remove each column we have . This will recursively cause / / keys etc . to be removed . for ( Iterator i = allCols . iterator ( ) ; i . hasNext ( ) ; ) { Column c = ( Column ) i . next ( ) ; this . removeColumn ( c ) ; } }	Set allCols = new HashSet ( this . columns . values ( ) ) ;
return ( getPreferredSize ( getColumns ( ) ) ) ; <CTX> preferredSize ( ) { return ( getPreferredSize ( getColumns ( ) ) ) ; }	return preferredSize ( getColumns ( ) ) ;
context . updateFromFactHandle ( handle ) ; <CTX> public void updateFromFactHandle ( final InternalFactHandle handle ) { for ( ContextEntry context = this . contexts ; context != null ; context = context . getNext ( ) ) { context . updateFromFactHandle ( handle ) ; } }	context . updateFromFactHandle ( workingMemory , handle ) ;
return delegate . getAvailableModels ( ) ; <CTX> public List getAvailableModels ( ) { return delegate . getAvailableModels ( ) ; }	List < RenderingModel > models = delegate . getAvailableModels ( ) ; List result = new ArrayList ( ) ; for ( RenderingModel model : models ) { result . add ( copyRenderingModel ( model ) ) ; } return result ;
List list = ( List )_headers . get ( name ) ; return list ; <CTX> private List getHeaderList ( String name ) { List list = ( List )_headers . get ( name ) ; return list ; }	return ( List )_headers . get ( name . toUpperCase ( ) ) ;
requestor . acceptFieldReference ( this ) ; <CTX> public void acceptElement ( ISourceElementRequestor requestor ) { requestor . acceptFieldReference ( this ) ; }	try { requestor . acceptFieldReference ( this ) ; } catch ( Exception e ) { / * do nothing * / }
void store ( Connection db ) throws SQLException { <CTX> void store ( Connection db ) throws SQLException { if ( m_changed != 0 || m_fromDb == false ) { if ( m_fromDb ) update ( db ) ; else insert ( db ) ; } }	void store ( ) throws SQLException {
try { position = buffer . createPosition ( pos ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } <CTX> void createPosition ( ) { try { position = buffer . createPosition ( pos ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } }	position = buffer . createPosition ( pos ) ;
result = ScriptRuntime . eqNumber ( sDbl [ stackTop + 1 ] , lhs ) ; <CTX> private static int do_eq ( Object [ ] stack , double [ ] sDbl , int stackTop , int op ) { -- stackTop ; boolean result ; Object rhs = stack [ stackTop + 1 ] ; Object lhs = stack [ stackTop ] ; if ( rhs == DBL_MRK ) { if ( lhs == DBL_MRK ) { result = ( sDbl [ stackTop ] == sDbl [ stackTop + 1 ] ) ; } else { result = ScriptRuntime . eqNumber ( sDbl [ stackTop + 1 ] , lhs ) ; } } else { if ( lhs == DBL_MRK ) { result = ScriptRuntime . eqNumber ( sDbl [ stackTop ] , rhs ) ; } else { result = ScriptRuntime . eq ( lhs , rhs ) ; } } result ^= ( op == Token . NE ) ; stack [ stackTop ] = ( result ) ? Boolean . TRUE : Boolean . FALSE ; return stackTop ; }	result = ScriptRuntime . eqNumber ( state . sDbl [ i + 1 ] , lhs ) ;
if ( buffer != null ) <CTX> private static final String escape ( final String rawText ) { / / defer initialization of a StringBuffer until we know we need one StringBuffer buffer = null ; for ( int i = 0 ; i < rawText . length ( ) ; i ++ ) { char c = rawText . charAt ( i ) ; switch ( c ) { case CommandManager . PARAMETER_START_CHAR : case CommandManager . PARAMETER_END_CHAR : case CommandManager . ID_VALUE_CHAR : case CommandManager . PARAMETER_SEPARATOR_CHAR : case CommandManager . ESCAPE_CHAR : if ( buffer == null ) buffer = new StringBuffer ( rawText . substring ( 0 , i ) ) ; buffer . append ( CommandManager . ESCAPE_CHAR ) ; buffer . append ( c ) ; break ; default : if ( buffer != null ) buffer . append ( c ) ; break ; } } if ( buffer == null ) return rawText ; return buffer . toString ( ) ; }	if ( buffer != null ) {
Person person = Person . readPersonByUsername ( username ) ; List < ProjectAccess > accesses = ProjectAccess . getAllByPersonUsername ( person ) ; <CTX> public List run ( String username , String costCenter , String userNumber ) throws ExcepcaoPersistencia { List < InfoRubric > infoCostCenterList = new ArrayList < InfoRubric > ( ) ; PersistentSuportOracle p = PersistentSuportOracle . getInstance ( ) ; List < IRubric > costCenterList = p . getIPersistentProjectUser ( ) . getInstitucionalProjectCoordId ( new Integer ( userNumber ) ) ; List < Integer > projectCodes = new ArrayList < Integer > ( ) ; Person person = Person . readPersonByUsername ( username ) ; List < ProjectAccess > accesses = ProjectAccess . getAllByPersonUsername ( person ) ; for ( ProjectAccess access : accesses ) { Integer keyCostCenter = access . getKeyProjectCoordinator ( ) ; if ( ! projectCodes . contains ( keyCostCenter ) ) { projectCodes . add ( keyCostCenter ) ; } } costCenterList . addAll ( p . getIPersistentProjectUser ( ) . getInstitucionalProjectByCCIDs ( projectCodes ) ) ; for ( IRubric cc : costCenterList ) { infoCostCenterList . add ( InfoRubric . newInfoFromDomain ( cc ) ) ; } return infoCostCenterList ; }	List < ProjectAccess > accesses = ProjectAccess . getAllByPerson ( person ) ;
ArrayList list = new ArrayList ( ) ; list . add ( content ) ; <CTX> public void add ( Element elem ) throws ServiceException , UnsupportedEncodingException { String emailAddress = elem . getAttribute ( MailService . A_ADDRESS ) ; String personalName = elem . getAttribute ( MailService . A_PERSONAL , null ) ; String addressType = elem . getAttribute ( MailService . A_ADDRESS_TYPE ) ; InternetAddress addr = new InternetAddress ( emailAddress , personalName ) ; if ( elem . getAttributeBool ( MailService . A_ADD_TO_AB , false ) ) newContacts . add ( addr ) ; Object content = addrs . get ( addressType ) ; if ( content == null ) addrs . put ( addressType , addr ) ; else if ( content instanceof List ) ( ( List ) content ) . add ( addr ) ; else { ArrayList list = new ArrayList ( ) ; list . add ( content ) ; list . add ( addr ) ; addrs . put ( addressType , list ) ; } }	ArrayList < InternetAddress > list = new ArrayList < InternetAddress > ( ) ; list . add ( ( InternetAddress ) content ) ;
double dbl = Double . valueOf ( txtScaleStep . getText ( ) ) <CTX> public void handleEvent ( Event event ) { if ( event . widget . equals ( txtScaleMin ) ) { if ( txtScaleMin . getText ( ) . length ( ) == 0 ) { getScale ( ) . eUnset ( ComponentPackage . eINSTANCE . getScale_Min ( ) ) ; } else { DataElement de = getTypedDataElement ( txtScaleMin . getText ( ) ) ; if ( de != null ) { getScale ( ) . setMin ( de ) ; } } } else if ( event . widget . equals ( txtScaleMax ) ) { if ( txtScaleMax . getText ( ) . length ( ) == 0 ) { getScale ( ) . eUnset ( ComponentPackage . eINSTANCE . getScale_Max ( ) ) ; } else { DataElement de = getTypedDataElement ( txtScaleMax . getText ( ) ) ; if ( de != null ) { getScale ( ) . setMax ( de ) ; } } } else if ( event . widget . equals ( txtScaleStep ) ) { try { if ( txtScaleStep . getText ( ) . length ( ) == 0 ) { getScale ( ) . eUnset ( ComponentPackage . eINSTANCE . getScale_Step ( ) ) ; } else { double dbl = Double . valueOf ( txtScaleStep . getText ( ) ) . doubleValue ( ) ; if ( dbl == 0 ) { getScale ( ) . eUnset ( ComponentPackage . eINSTANCE . getScale_Step ( ) ) ; } else { getScale ( ) . setStep ( dbl ) ; } } } catch ( NumberFormatException e 1 ) { txtScaleStep . setText ( String . valueOf ( getScale ( ) . getStep ( ) ) ) ; } } else if ( event . widget . equals ( cmbScaleUnit ) ) { getScale ( ) . setUnit ( ScaleUnitType . getByName ( LiteralHelper . scaleUnitTypeSet . getNameByDisplayName ( cmbScaleUnit . getText ( ) ) ) ) ; } }	double dbl = Double . valueOf ( txtStepSize . getText ( ) )
getGL ( ) . glViewport ( 0 , 0 , panelWidth , panelHeight ) ; drawableHelper . reshape ( GLJPanel . this , 0 , 0 , panelWidth , panelHeight ) ; } <CTX> public void run ( ) { getGL ( ) . glViewport ( 0 , 0 , panelWidth , panelHeight ) ; drawableHelper . reshape ( GLJPanel . this , 0 , 0 , panelWidth , panelHeight ) ; }	toplevel . setVisible ( false ) ; }
if ( categoryDefinitions == null ) throw new NullPointerException ( ) ; <CTX> static Map categoryDefinitionsById ( Collection categoryDefinitions , boolean allowNullIds ) { if ( categoryDefinitions == null ) throw new NullPointerException ( ) ; Map map = new HashMap ( ) ; Iterator iterator = categoryDefinitions . iterator ( ) ; while ( iterator . hasNext ( ) ) { Object object = iterator . next ( ) ; Util . assertInstance ( object , CategoryDefinition . class ) ; CategoryDefinition categoryDefinition = ( CategoryDefinition ) object ; String id = categoryDefinition . getId ( ) ; if ( allowNullIds || id != null ) map . put ( id , categoryDefinition ) ; } return map ; }	if ( categoryDefinitions == null ) { throw new NullPointerException ( ) ; }
newSrc = saveChars ( newJoin ,_offSrc ,_cchSrc , null , 0 , 0 ) ; <CTX> public Object insertChars ( int posInsert , Object src , int off , int cch , Object srcInsert , int offInsert , int cchInsert ) { assert isValid ( src , off , cch ) ; assert isValid ( srcInsert , offInsert , cchInsert ) ; assert posInsert >= 0 && posInsert <= cch ; / / TODO - at some point , instead of creating joins , I should / / normalize all the text into a single buffer to stop large / / tree s from being built when many modifications happen . . . / / TODO - actually , I should see if the size of the new char / / sequence is small enough to simply allocate a new contigous / / sequence , either in a common char [ ] managed by the master , / / or just create a new string . . . this goes for remove chars / / as well . if ( cchInsert == 0 ) {_cchSrc = cch ;_offSrc = off ; return src ; } if ( cch == 0 ) {_cchSrc = cchInsert ;_offSrc = offInsert ; return srcInsert ; }_cchSrc = cch + cchInsert ; Object newSrc ; if (_cchSrc <= MAX_COPY && canAllocate (_cchSrc ) ) { char [ ] chars = allocate (_cchSrc ) ; getChars ( chars ,_offSrc , src , off , posInsert ) ; getChars ( chars ,_offSrc + posInsert , srcInsert , offInsert , cchInsert ) ; getChars ( chars ,_offSrc + posInsert + cchInsert , src , off + posInsert , cch - posInsert ) ; newSrc = chars ; } else {_offSrc = 0 ; CharJoin newJoin ; if ( posInsert == 0 ) newJoin = new CharJoin ( srcInsert , offInsert , cchInsert , src , off , cch ) ; else if ( posInsert == cch ) newJoin = new CharJoin ( src , off , cch , srcInsert , offInsert , cchInsert ) ; else { newJoin = new CharJoin ( new CharJoin ( src , off , posInsert , srcInsert , offInsert , cchInsert ) , 0 , posInsert + cchInsert , src , off + posInsert , cch - posInsert ) ; } if ( newJoin ._depth > CharJoin . MAX_DEPTH ) newSrc = saveChars ( newJoin ,_offSrc ,_cchSrc , null , 0 , 0 ) ; else newSrc = newJoin ; } assert isValid ( newSrc ,_offSrc ,_cchSrc ) ; return newSrc ; }	newSrc = saveChars ( newJoin ,_offSrc ,_cchSrc ) ;
show ( ) ; <CTX> public int showDialog ( ) { pack ( ) ; show ( ) ; return returnCode ; }	setVisible ( true ) ;
return BIWithAlpha . getColorModel ( ) ; <CTX> public ColorModel getColorModel ( ) { return BIWithAlpha . getColorModel ( ) ; }	return BI_WITH_ALPHA . getColorModel ( ) ;
return ( value ) ; } <CTX> getHeaderFieldValueByIndex ( int index ) { String value = null ; try { value = ( String ) headerFieldValues . elementAt ( index ) ; } catch ( ArrayIndexOutOfBoundsException e ) { } return ( value ) ; }	return value ; }
updateObject ( columnIndex , new Boolean ( x ) ) ; <CTX> public void updateBoolean ( int columnIndex , boolean x ) throws SQLException { updateObject ( columnIndex , new Boolean ( x ) ) ; }	setColValue ( columnIndex , Types . BIT , new Boolean ( x ) , 0 ) ;
atts = rowAttributes ; } else { atts = ( HtmlAttributeMap ) this . htmlAttributes . clone ( ) ; atts . putAll ( cell . getPerRowAttributes ( ) ) ; <CTX> public String getOpenTag ( ) { HtmlAttributeMap rowAttributes = cell . getPerRowAttributes ( ) ; HtmlAttributeMap atts ; if ( htmlAttributes == null || rowAttributes == null ) { atts = rowAttributes ; } else { atts = ( HtmlAttributeMap ) this . htmlAttributes . clone ( ) ; atts . putAll ( cell . getPerRowAttributes ( ) ) ; } return HtmlTagUtil . createOpenTagString ( TagConstants . TAGNAME_COLUMN , atts ) ; }	atts = ( HtmlAttributeMap ) atts . clone ( ) ; atts . putAll ( rowAttributes ) ;
if ( methodId == CONSTRUCTOR_ID ) { <CTX> public int methodArity ( int methodId , IdFunction function ) { if ( methodId == CONSTRUCTOR_ID ) { return 1 ; } return 0 ; }	if ( methodId == Id_constructor ) {
align ( 0 , topControls . length , trimRegion ) ; <CTX> public void layout ( ) { cache . flush ( ) ; Rectangle trimRegion = getTitleTrimRegion ( ) ; Point trimSize = computeTrimSize ( ) ; Rectangle bounds = tabFolder . getBounds ( ) ; trimStart = bounds . width ; Rectangle clientBounds = calculatePageBounds ( tabFolder ) ; trimOnTop = trimSize . x <= trimRegion . width && trimSize . y <= trimRegion . height ; / / Check if we have room for all our topRight controls on the top border if ( trimOnTop ) { trimStart = trimRegion . x + trimRegion . width - trimSize . x - bounds . x ; align ( 0 , topControls . length , trimRegion ) ; centerArea = clientBounds ; return ; } / / Else we need to place the controls below the title Rectangle currentRect = new Rectangle ( clientBounds . x , clientBounds . y , clientBounds . width , 0 ) ; int idx = 0 ; while ( idx < topControls . length ) { int startOfRow = idx ; currentRect . height = 0 ; int rowWidth = 0 ; int rowCount = 0 ; while ( idx + rowCount < topControls . length ) { Point nextSize = cache . computeSize ( idx + rowCount , SWT . DEFAULT , SWT . DEFAULT ) ; rowWidth += nextSize . x ; if ( rowWidth > clientBounds . width ) { break ; } currentRect . height = Math . max ( currentRect . height , nextSize . y ) ; rowCount ++ ; } if ( rowCount > 0 ) { align ( idx , rowCount , currentRect ) ; idx += rowCount ; } else { Point size = cache . computeSize ( idx , clientBounds . width , SWT . DEFAULT ) ; currentRect . height = size . y ; topControls [ idx ] . setBounds ( currentRect ) ; idx ++ ; } currentRect . y += currentRect . height ; } centerArea = new Rectangle ( clientBounds . x , currentRect . y , clientBounds . width , clientBounds . height + clientBounds . y - currentRect . y ) ; }	trimStart = align ( 0 , topControls . length , trimRegion , true ) - bounds . x ;
initScriptFunction ( cx , scope , idata . languageVersion , idata . itsName , idata . argNames , idata . argCount ) ; <CTX> private void initInterpretedFunction ( Context cx , Scriptable scope ) { initScriptFunction ( cx , scope , idata . languageVersion , idata . itsName , idata . argNames , idata . argCount ) ; if ( idata . itsRegExpLiterals != null ) { functionRegExps = createRegExpWraps ( cx , scope ) ; } }	initScriptFunction ( cx , scope , idata . itsName ) ;
ScriptRuntime . setElem ( target , id , value , target ) ; <CTX> private static void setElem ( Scriptable target , long index , Object value ) { if ( index > Integer . MAX_VALUE ) { String id = Long . toString ( index ) ; ScriptRuntime . setElem ( target , id , value , target ) ; } else { ScriptRuntime . setElem ( target , ( int ) index , value ) ; } }	ScriptRuntime . setStrIdElem ( target , id , value , target ) ;
messageArea . updateText ( getShortenedString ( message ) , messageType ) ; <CTX> public void updateMessage ( ) { String message = null ; String errorMessage = null ; if ( currentPage != null ) { message = currentPage . getMessage ( ) ; errorMessage = currentPage . getErrorMessage ( ) ; } int messageType = IMessageProvider . NONE ; if ( message != null && currentPage instanceof IMessageProvider ) messageType = ( ( IMessageProvider ) currentPage ) . getMessageType ( ) ; if ( errorMessage != null ) { message = errorMessage ; messageType = IMessageProvider . ERROR ; if ( ! showingError ) { / / we were not previously showing an error showingError = true ; titleImage . setImage ( null ) ; titleImage . setBackground ( JFaceColors . getErrorBackground ( titleImage . getDisplay ( ) ) ) ; titleImage . setSize ( 0 , 0 ) ; titleImage . getParent ( ) . layout ( ) ; } } else { if ( showingError ) { / / we were previously showing an error showingError = false ; titleImage . setImage ( JFaceResources . getImage ( PREF_DLG_TITLE_IMG ) ) ; titleImage . computeSize ( SWT . NULL , SWT . NULL ) ; titleImage . getParent ( ) . layout ( ) ; } } messageArea . updateText ( getShortenedString ( message ) , messageType ) ; }	messageArea . updateText ( getShortenedString ( message , titleArea ) , messageType ) ;
write ( buf , 0 , buf . length ) ; <CTX> public synchronized void write ( byte [ ] buf ) throws IOException { write ( buf , 0 , buf . length ) ; }	super . write ( bval ) ; crc . update ( bval ) ;
if ( peers == 0 || conns == 0 || ( peers - conns ) > MAX_DISCONN_PEER_ALERT_THRESHOLD || conns > MAX_CONN_ALERT_THRESHOLD || peers > MAX_PEER_ALERT_THRESHOLD || ( n . bwlimitDelayAlertRelevant && bwlimitDelayTime > Node . MAX_BWLIMIT_DELAY_TIME_ALERT_THRESHOLD ) || ( n . nodeAveragePingAlertRelevant && nodeAveragePingTime > Node . MAX_NODE_AVERAGE_PING_TIME_ALERT_THRESHOLD ) ) <CTX> public short getPriorityClass ( ) { if ( peers == 0 || conns == 0 || ( peers - conns ) > MAX_DISCONN_PEER_ALERT_THRESHOLD || conns > MAX_CONN_ALERT_THRESHOLD || peers > MAX_PEER_ALERT_THRESHOLD || ( n . bwlimitDelayAlertRelevant && bwlimitDelayTime > Node . MAX_BWLIMIT_DELAY_TIME_ALERT_THRESHOLD ) || ( n . nodeAveragePingAlertRelevant && nodeAveragePingTime > Node . MAX_NODE_AVERAGE_PING_TIME_ALERT_THRESHOLD ) ) return UserAlert . CRITICAL_ERROR ; return UserAlert . ERROR ; }	if ( ( peers == 0 ) || ( conns == 0 ) || ( ( peers - conns ) > MAX_DISCONN_PEER_ALERT_THRESHOLD ) || ( conns > MAX_CONN_ALERT_THRESHOLD ) || ( peers > MAX_PEER_ALERT_THRESHOLD ) || ( n . bwlimitDelayAlertRelevant && ( bwlimitDelayTime > Node . MAX_BWLIMIT_DELAY_TIME_ALERT_THRESHOLD ) ) || ( n . nodeAveragePingAlertRelevant && ( nodeAveragePingTime > Node . MAX_NODE_AVERAGE_PING_TIME_ALERT_THRESHOLD ) ) )
index = i ; <CTX> public OPT_StringConstantOperand ( String v , int i ) { value = v ; index = i ; }	offset = i ;
return null ; <CTX> public PortletMode getPortletMode ( ) { return null ; / / TODO }	if ( nativeRequest != null ) return nativeRequest . getPortletMode ( ) ; else return null ;
= CSSUtilities . convertStrokeAndFill ( svgElement , ctx , cssDecl , uctx ) ; <CTX> public GraphicsNode createGraphicsNode ( BridgeContext ctx , Element element ) { SVGElement svgElement = ( SVGElement ) element ; CSSStyleDeclaration cssDecl = ctx . getViewCSS ( ) . getComputedStyle ( element , null ) ; UnitProcessor . Context uctx = new DefaultUnitProcessorContext ( ctx , cssDecl ) ; ShapeNode node = ctx . getGVTFactory ( ) . createShapeNode ( ) ; / / Initialize the shape of the ShapeNode node . setShape ( createShape ( ctx , svgElement , cssDecl , uctx ) ) ; / / Initialize the style properties ShapePainter painter = CSSUtilities . convertStrokeAndFill ( svgElement , ctx , cssDecl , uctx ) ; node . setShapePainter ( painter ) ; / / Initialize the transform AffineTransform at = AWTTransformProducer . createAffineTransform ( new StringReader ( element . getAttributeNS ( null , ATTR_TRANSFORM ) ) , ctx . getParserFactory ( ) ) ; node . setTransform ( at ) ; / / Set node composite CSSPrimitiveValue opacityVal = ( CSSPrimitiveValue ) cssDecl . getPropertyCSSValue ( ATTR_OPACITY ) ; Composite composite = CSSUtilities . convertOpacityToComposite ( opacityVal ) ; node . setComposite ( composite ) ; / / Set node filter Filter filter = CSSUtilities . convertFilter ( element , node , ctx ) ; node . setFilter ( filter ) ; Mask mask = CSSUtilities . convertMask ( element , node , ctx ) ; node . setMask ( mask ) ; Shape clip = CSSUtilities . convertClipPath ( element , node , ctx ) ; node . setClippingArea ( clip ) ; / / < ! > TODO only when binding is enabled BridgeEventSupport . addDOMListener ( ctx , element ) ; ctx . bind ( element , node ) ; return node ; }	= CSSUtilities . convertStrokeAndFill ( svgElement , node , ctx , cssDecl , uctx ) ;
if ( caret == s . start ) <CTX> public void goToNextCharacter ( boolean select ) { Selection s = getSelectionAtOffset ( caret ) ; if ( ! select && s instanceof Selection . Range ) { if ( multi ) { if ( caret != s . end ) { moveCaretPosition ( s . end ) ; return ; } } else { setCaretPosition ( s . end ) ; return ; } } int extraStartVirt , extraEndVirt ; if ( s instanceof Selection . Rect ) { extraStartVirt = ( ( Selection . Rect ) s ) . extraStartVirt ; extraEndVirt = ( ( Selection . Rect ) s ) . extraEndVirt ; } else { extraStartVirt = 0 ; extraEndVirt = 0 ; } int newCaret = caret ; if ( select && caret == buffer . getLength ( ) ) { if ( rectangularSelectionMode || s instanceof Selection . Rect ) { if ( caret == s . start ) extraStartVirt ++ ; else extraEndVirt ++ ; } else { getToolkit ( ) . beep ( ) ; return ; } } else if ( caret == getLineEndOffset ( caretLine ) - 1 ) { if ( rectangularSelectionMode || s instanceof Selection . Rect ) { if ( caret == s . start ) extraStartVirt ++ ; else extraEndVirt ++ ; } else { int line = displayManager . getNextVisibleLine ( caretLine ) ; if ( line == - 1 ) { getToolkit ( ) . beep ( ) ; return ; } else newCaret = getLineStartOffset ( line ) ; } } else newCaret = caret + 1 ; if ( select ) extendSelection ( caret , newCaret , extraStartVirt , extraEndVirt ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( newCaret ) ; } / / } } }	if ( s != null && caret == s . start )
ObservableTracker . getterCalled ( this ) ; <CTX> public Object remove ( Object key ) { ObservableTracker . getterCalled ( this ) ; Object result = wrappedMap . remove ( key ) ; if ( result != null ) { fireMapChange ( Diffs . createMapDiffSingleRemove ( key , result ) ) ; } return result ; }	checkRealm ( ) ;
repository = MylarTaskListPlugin . getRepositoryManager ( ) . getRepository ( BugzillaPlugin . REPOSITORY_KIND , bug . getServer ( ) ) ; <CTX> public ExistingBugEditorInput ( BugReport bug ) { this . bug = bug ; this . bugId = bug . getId ( ) ; repository = MylarTaskListPlugin . getRepositoryManager ( ) . getRepository ( BugzillaPlugin . REPOSITORY_KIND , bug . getServer ( ) ) ; }	repository = MylarTaskListPlugin . getRepositoryManager ( ) . getRepository ( BugzillaPlugin . REPOSITORY_KIND , bug . getRepository ( ) ) ;
Account acctTarget = Provisioning . getInstance ( ) . getAccountById ( mAccountId ) ; <CTX> public boolean isLocal ( ) throws ServiceException { if ( mAccountId == null ) return true ; Account acctTarget = Provisioning . getInstance ( ) . getAccountById ( mAccountId ) ; if ( acctTarget == null ) throw AccountServiceException . NO_SUCH_ACCOUNT ( mAccountId ) ; return DocumentHandler . LOCAL_HOST . equalsIgnoreCase ( acctTarget . getAttr ( Provisioning . A_zimbraMailHost ) ) ; }	Account acctTarget = Provisioning . getInstance ( ) . get ( AccountBy . ID , mAccountId ) ;
if ( style . hasProperty ( CSSName . RIGHT ) ) { <CTX> public static void setupFixed ( Context c , Box box ) { if ( c . getCurrentStyle ( ) . isIdent ( CSSName . POSITION , IdentValue . FIXED ) ) { box . fixed = true ; box . setChildrenExceedBounds ( true ) ; Rectangle rect = c . getFixedRectangle ( ) ; CalculatedStyle style = c . getCurrentStyle ( ) ; if ( style . hasProperty ( CSSName . TOP ) ) { box . top = ( int ) style . getFloatPropertyProportionalHeight ( CSSName . TOP , ( float ) ( rect . getHeight ( ) ) , c . getCtx ( ) ) ; box . top_set = true ; } if ( style . hasProperty ( CSSName . RIGHT ) ) { box . right = ( int ) style . getFloatPropertyProportionalWidth ( CSSName . RIGHT , ( float ) ( rect . getWidth ( ) ) , c . getCtx ( ) ) ; box . right_set = true ; } if ( style . hasProperty ( CSSName . BOTTOM ) ) { box . bottom = ( int ) style . getFloatPropertyProportionalHeight ( CSSName . BOTTOM , ( float ) ( rect . getHeight ( ) ) , c . getCtx ( ) ) ; box . bottom_set = true ; } if ( style . hasProperty ( CSSName . LEFT ) ) { box . left = ( int ) style . getFloatPropertyProportionalWidth ( CSSName . LEFT , ( float ) ( rect . getWidth ( ) ) , c . getCtx ( ) ) ; box . left_set = true ; } } }	if ( ! style . isIdent ( CSSName . RIGHT , IdentValue . AUTO ) ) {
if ( resourcePath . isPrefixOf ( elementPath ) ) return true ; if ( elementPath . isPrefixOf ( resourcePath ) ) return true ; <CTX> private boolean isEnclosedResource ( IResource element , IPath elementPath , IAdaptable workingSetElement ) { IResource workingSetResource = null ; if ( workingSetElement . equals ( element ) ) return true ; if ( workingSetElement instanceof IResource ) { workingSetResource = ( IResource ) workingSetElement ; } else { workingSetResource = ( IResource ) workingSetElement . getAdapter ( IResource . class ) ; } if ( workingSetResource != null ) { IPath resourcePath = workingSetResource . getFullPath ( ) ; if ( resourcePath . isPrefixOf ( elementPath ) ) return true ; if ( elementPath . isPrefixOf ( resourcePath ) ) return true ; } return false ; }	if ( resourcePath . isPrefixOf ( elementPath ) ) { return true ; } if ( elementPath . isPrefixOf ( resourcePath ) ) { return true ; }
Component [ ] list = getComponents ( ) ; if ( ( list != null ) && ( list . length > 0 ) ) { Dimension dim = list [ 0 ] . getPreferredSize ( ) ; Dimension vp = getViewportSize ( ) ; if ( dim . width < vp . width ) dim . width = vp . width ; if ( dim . height < vp . height ) dim . height = vp . height ; ScrollPanePeer peer = ( ScrollPanePeer ) getPeer ( ) ; if ( peer != null ) peer . childResized ( dim . width , dim . height ) ; list [ 0 ] . resize ( dim ) ; Point p = getScrollPosition ( ) ; if ( p . x > dim . width ) p . x = dim . width ; if ( p . y > dim . height ) p . y = dim . height ; setScrollPosition ( p ) ; } <CTX> doLayout ( ) { Component [ ] list = getComponents ( ) ; if ( ( list != null ) && ( list . length > 0 ) ) { Dimension dim = list [ 0 ] . getPreferredSize ( ) ; Dimension vp = getViewportSize ( ) ; if ( dim . width < vp . width ) dim . width = vp . width ; if ( dim . height < vp . height ) dim . height = vp . height ; ScrollPanePeer peer = ( ScrollPanePeer ) getPeer ( ) ; if ( peer != null ) peer . childResized ( dim . width , dim . height ) ; list [ 0 ] . resize ( dim ) ; Point p = getScrollPosition ( ) ; if ( p . x > dim . width ) p . x = dim . width ; if ( p . y > dim . height ) p . y = dim . height ; setScrollPosition ( p ) ; } }	layout ( ) ;
void addQuery ( ITaskQuery query ) { <CTX> void addQuery ( ITaskQuery query ) { queries . add ( query ) ; }	void addQuery ( IRepositoryQuery query ) {
Deap cacheParent = cachePath [ cacheIndex - 1 ] ; <CTX> private void insertParentToCache ( Deap deap ) { if ( isRoot ( deap ) ) return ; int cacheIndex = deap . getCacheIndex ( ) ; int parentIndex = parentIndex ( deap ) ; / / check , if parent of deap is in cachePath Deap cacheParent = cachePath [ cacheIndex - 1 ] ; / / parent is in cachePath -> ok ! / / else : write cacheParent to disk and insert parent into cachePath if ( cacheParent . getIndex ( ) != parentIndex ) { cacheParent . setCacheIndex ( - 1 ) ; file . write ( cacheParent ) ; Deap parent = file . read ( parentIndex ) ; cachePath [ cacheIndex - 1 ] = parent ; parent . setCacheIndex ( cacheIndex - 1 ) ; / / recursive method call for parent insertParentToCache ( parent ) ; } }	Deap < K , V > cacheParent = cachePath [ cacheIndex - 1 ] ;
void forward ( String callSessionID , String extension ) throws PhoneException ; <CTX> void forward ( String callSessionID , String extension ) throws PhoneException ;	void forward ( String callSessionID , String username , String extension ) throws PhoneException ;
return idReferences ; <CTX> public IDReferences getIDReferences ( ) { return idReferences ; }	return streamRenderer . getIDReferences ( ) ;
jarsToBeDeleted . put ( jarFile . getFileName ( ) , jarFile ) ; <CTX> private void deleteJar ( ) { jarChanged = true ; if ( jarViewer . getTable ( ) . getSelectionIndex ( ) >= 0 && jarViewer . getTable ( ) . getSelectionIndex ( ) < jarViewer . getTable ( ) . getItemCount ( ) ) { int idx = jarViewer . getTable ( ) . getSelectionIndex ( ) ; Map . Entry fn = ( Map . Entry ) jarViewer . getTable ( ) . getSelection ( ) [ 0 ] . getData ( ) ; JarFile jarFile = ( JarFile ) fn . getValue ( ) ; jarFile . setToBeDeleted ( true ) ; if ( jarsToBeCopied . containsKey ( jarFile . getFileName ( ) ) ) { jarsToBeCopied . remove ( jarFile . getFileName ( ) ) ; } else { jarsToBeDeleted . put ( jarFile . getFileName ( ) , jarFile ) ; } jarsToBeDeletedRuntime . put ( jarFile . getFileName ( ) , jarFile ) ; jarMap . remove ( fn . getKey ( ) ) ; jarViewer . getTable ( ) . remove ( idx ) ; jarViewer . refresh ( ) ; if ( idx >= jarViewer . getTable ( ) . getItemCount ( ) ) { idx -- ; } jarViewer . getTable ( ) . select ( idx ) ; refreshJarViewer ( ) ; updateJarButtons ( ) ; } }	if ( jarFile . getState ( ) != JarFile . ODA_FILE_NOT_EXIST_TOKEN ) jarsToBeDeleted . put ( jarFile . getFileName ( ) , jarFile ) ;
typeExpected = new java . lang . String ( u ) ; <CTX> public WrongType ( java . lang . String name , int n , java . lang . String u ) { procname = new java . lang . String ( name ) ; number = n ; typeExpected = new java . lang . String ( u ) ; }	typeExpected = u ;
handleStartElement ( element , attributes , false ) ; <CTX> public void startElement ( QName element , XMLAttributes attributes ) throws XNIException { handleStartElement ( element , attributes , false ) ; } / / startElement ( QName , XMLAttributes )	handleStartElement ( element , attributes ) ; if ( fDocumentHandler != null ) { fDocumentHandler . startElement ( element , attributes , augs ) ; }
if ( o == this ) return true ; <CTX> public boolean equals ( Object o ) { if ( ! ( o instanceof MarkerQueryResult ) ) return false ; if ( o == this ) return true ; MarkerQueryResult mqr = ( MarkerQueryResult ) o ; if ( values . length != mqr . values . length ) return false ; for ( int i = 0 ; i < values . length ; i ++ ) { if ( ! ( values [ i ] . equals ( mqr . values [ i ] ) ) ) return false ; } return true ; }	if ( o == this ) { return true ; }
if ( nextValuePair . endsWith ( P_TRUE ) ) enabledIds . add ( id ) ; else disabledIds . add ( id ) ; <CTX> public void applyDecoratorsPreference ( ) { String preferenceValue = WorkbenchPlugin . getDefault ( ) . getPreferenceStore ( ) . getString ( IPreferenceConstants . ENABLED_DECORATORS ) ; StringTokenizer tokenizer = new StringTokenizer ( preferenceValue , PREFERENCE_SEPARATOR ) ; Set enabledIds = new HashSet ( ) ; Set disabledIds = new HashSet ( ) ; while ( tokenizer . hasMoreTokens ( ) ) { String nextValuePair = tokenizer . nextToken ( ) ; / / Strip out the true or false to get the id String id = nextValuePair . substring ( 0 , nextValuePair . indexOf ( VALUE_SEPARATOR ) ) ; if ( nextValuePair . endsWith ( P_TRUE ) ) enabledIds . add ( id ) ; else disabledIds . add ( id ) ; } FullDecoratorDefinition [ ] full = getFullDefinitions ( ) ; for ( int i = 0 ; i < full . length ; i ++ ) { String id = full [ i ] . getId ( ) ; if ( enabledIds . contains ( id ) ) full [ i ] . setEnabled ( true ) ; else { if ( disabledIds . contains ( id ) ) full [ i ] . setEnabled ( false ) ; } } LightweightDecoratorDefinition [ ] lightweightDefinitions = getLightweightManager ( ) . getDefinitions ( ) ; for ( int i = 0 ; i < lightweightDefinitions . length ; i ++ ) { String id = lightweightDefinitions [ i ] . getId ( ) ; if ( enabledIds . contains ( id ) ) lightweightDefinitions [ i ] . setEnabled ( true ) ; else { if ( disabledIds . contains ( id ) ) lightweightDefinitions [ i ] . setEnabled ( false ) ; } } }	if ( nextValuePair . endsWith ( P_TRUE ) ) { enabledIds . add ( id ) ; } else { disabledIds . add ( id ) ; }
ContainerEvent ce = new ContainerEvent ( this , ContainerEvent . COMPONENT_REMOVED , r ) ; getToolkit ( ) . getSystemEventQueue ( ) . postEvent ( ce ) ; <CTX> public void remove ( int index ) { Component r = component [ index ] ; r . removeNotify ( ) ; System . arraycopy ( component , index + 1 , component , index , ncomponents - index - 1 ) ; component [ -- ncomponents ] = null ; invalidate ( ) ; if ( layoutMgr != null ) layoutMgr . removeLayoutComponent ( r ) ; / / Post event to notify of adding the container . ContainerEvent ce = new ContainerEvent ( this , ContainerEvent . COMPONENT_REMOVED , r ) ; getToolkit ( ) . getSystemEventQueue ( ) . postEvent ( ce ) ; }	ContainerEvent ce = new ContainerEvent ( this , ContainerEvent . COMPONENT_REMOVED , r ) ; getToolkit ( ) . getSystemEventQueue ( ) . postEvent ( ce ) ; }
IToolBarManager helpToolBar = new ToolBarManager ( coolBar . getStyle ( ) ) ; <CTX> protected void fillCoolBar ( ICoolBarManager coolBar ) { { / / Set up the context Menu IMenuManager popUpMenu = new MenuManager ( ) ; popUpMenu . add ( new ActionContributionItem ( lockToolBarAction ) ) ; popUpMenu . add ( new ActionContributionItem ( editActionSetAction ) ) ; coolBar . setContextMenuManager ( popUpMenu ) ; } coolBar . add ( new GroupMarker ( IIDEActionConstants . GROUP_FILE ) ) ; { / / File Group IToolBarManager fileToolBar = new ToolBarManager ( coolBar . getStyle ( ) ) ; fileToolBar . add ( new Separator ( IWorkbenchActionConstants . NEW_GROUP ) ) ; fileToolBar . add ( newWizardDropDownAction ) ; fileToolBar . add ( new GroupMarker ( IWorkbenchActionConstants . NEW_EXT ) ) ; fileToolBar . add ( new GroupMarker ( IWorkbenchActionConstants . SAVE_GROUP ) ) ; fileToolBar . add ( saveAction ) ; fileToolBar . add ( new GroupMarker ( IWorkbenchActionConstants . SAVE_EXT ) ) ; fileToolBar . add ( printAction ) ; fileToolBar . add ( new GroupMarker ( IWorkbenchActionConstants . PRINT_EXT ) ) ; fileToolBar . add ( new Separator ( IWorkbenchActionConstants . BUILD_GROUP ) ) ; fileToolBar . add ( new GroupMarker ( IWorkbenchActionConstants . BUILD_EXT ) ) ; fileToolBar . add ( new Separator ( IWorkbenchActionConstants . MB_ADDITIONS ) ) ; / / Add to the cool bar manager coolBar . add ( new ToolBarContributionItem ( fileToolBar , IWorkbenchActionConstants . TOOLBAR_FILE ) ) ; } coolBar . add ( new GroupMarker ( IWorkbenchActionConstants . MB_ADDITIONS ) ) ; coolBar . add ( new GroupMarker ( IIDEActionConstants . GROUP_NAV ) ) ; { / / Navigate group IToolBarManager navToolBar = new ToolBarManager ( coolBar . getStyle ( ) ) ; navToolBar . add ( new Separator ( IWorkbenchActionConstants . HISTORY_GROUP ) ) ; navToolBar . add ( new GroupMarker ( IWorkbenchActionConstants . GROUP_APP ) ) ; navToolBar . add ( backwardHistoryAction ) ; navToolBar . add ( forwardHistoryAction ) ; navToolBar . add ( new Separator ( IWorkbenchActionConstants . PIN_GROUP ) ) ; navToolBar . add ( pinEditorContributionItem ) ; / / Add to the cool bar manager coolBar . add ( new ToolBarContributionItem ( navToolBar , IWorkbenchActionConstants . TOOLBAR_NAVIGATE ) ) ; } coolBar . add ( new GroupMarker ( IWorkbenchActionConstants . GROUP_EDITOR ) ) ; coolBar . add ( new GroupMarker ( IWorkbenchActionConstants . GROUP_HELP ) ) ; { / / Help group IToolBarManager helpToolBar = new ToolBarManager ( coolBar . getStyle ( ) ) ; helpToolBar . add ( new Separator ( IWorkbenchActionConstants . GROUP_HELP ) ) ; / / helpToolBar . add ( searchComboItem ) ; / / Add the group for applications to contribute helpToolBar . add ( new GroupMarker ( IWorkbenchActionConstants . GROUP_APP ) ) ; / / Add to the cool bar manager coolBar . add ( new ToolBarContributionItem ( helpToolBar , IWorkbenchActionConstants . TOOLBAR_HELP ) ) ; } }	IToolBarManager helpToolBar = actionBarConfigurer . createToolBarManager ( ) ;
PsiJavaCodeReferenceElement ref = ( ( PsiNewExpression ) element ) . getClassReference ( ) ; if ( ref instanceof PsiReferenceExpression ) { qualifier = ( ( PsiReferenceExpression ) ref ) . getQualifierExpression ( ) ; } else if ( ref != null ) { PsiElement refElement = ref . resolve ( ) ; if ( refElement instanceof PsiClass ) psiClass = ( PsiClass ) refElement ; <CTX> protected PsiClass [ ] getTargetClasses ( PsiElement element ) { PsiClass psiClass = null ; PsiExpression qualifier = null ; if ( element instanceof PsiNewExpression ) { PsiJavaCodeReferenceElement ref = ( ( PsiNewExpression ) element ) . getClassReference ( ) ; if ( ref instanceof PsiReferenceExpression ) { qualifier = ( ( PsiReferenceExpression ) ref ) . getQualifierExpression ( ) ; } else if ( ref != null ) { PsiElement refElement = ref . resolve ( ) ; if ( refElement instanceof PsiClass ) psiClass = ( PsiClass ) refElement ; } } else if ( element instanceof PsiReferenceExpression ) { qualifier = ( ( PsiReferenceExpression ) element ) . getQualifierExpression ( ) ; } else if ( element instanceof PsiMethodCallExpression ) { qualifier = ( ( PsiMethodCallExpression ) element ) . getMethodExpression ( ) . getQualifierExpression ( ) ; } if ( qualifier != null ) { PsiType type = qualifier . getType ( ) ; if ( type instanceof PsiClassType ) { psiClass = PsiUtil . resolveClassInType ( type ) ; } else if ( qualifier instanceof PsiReferenceExpression ) { PsiElement refElement = ( ( PsiReferenceExpression ) qualifier ) . resolve ( ) ; if ( refElement instanceof PsiClass ) { psiClass = ( PsiClass ) refElement ; } } } else if ( psiClass == null ) { psiClass = PsiTreeUtil . getParentOfType ( element , PsiClass . class ) ; } if ( ! ( element instanceof PsiMethodCallExpression ) ) { while ( psiClass instanceof PsiAnonymousClass ) { psiClass = PsiTreeUtil . getParentOfType ( psiClass , PsiClass . class ) ; } } if ( psiClass instanceof PsiTypeParameter ) { PsiClass [ ] supers = psiClass . getSupers ( ) ; List < PsiClass > filtered = new ArrayList < PsiClass > ( ) ; for ( PsiClass aSuper : supers ) { if ( ! aSuper . getManager ( ) . isInProject ( aSuper ) ) continue ; if ( ! ( aSuper instanceof PsiTypeParameter ) ) filtered . add ( aSuper ) ; } return filtered . size ( ) > 0 ? filtered . toArray ( new PsiClass [ filtered . size ( ) ] ) : null ; } else { return psiClass != null && psiClass . getManager ( ) . isInProject ( psiClass ) ? new PsiClass [ ] { psiClass } : null ; } }	final PsiNewExpression newExpression = ( PsiNewExpression ) element ; qualifier = newExpression . getQualifier ( ) ; if ( qualifier == null ) { PsiJavaCodeReferenceElement ref = newExpression . getClassReference ( ) ; if ( ref != null ) { PsiElement refElement = ref . resolve ( ) ; if ( refElement instanceof PsiClass ) psiClass = ( PsiClass ) refElement ; }
throw new PartInitException ( NLS . bind ( WorkbenchMessages . EditorManager_unableToInitialize , desc . getId ( ) , e ) , e ) ; <CTX> private void createSite ( final IEditorReference ref , final IEditorPart part , final EditorDescriptor desc , final IEditorInput input ) throws PartInitException { EditorSite site = new EditorSite ( ref , part , page , desc ) ; if ( desc != null ) site . setActionBars ( createEditorActionBars ( desc ) ) ; else site . setActionBars ( createEmptyEditorActionBars ( ) ) ; final String label = part . getTitle ( ) ; / / debugging only try { try { UIStats . start ( UIStats . INIT_PART , label ) ; part . init ( site , input ) ; } finally { UIStats . end ( UIStats . INIT_PART , part , label ) ; } if ( part . getSite ( ) != site ) throw new PartInitException ( NLS . bind ( WorkbenchMessages . EditorManager_siteIncorrect , desc . getId ( ) ) ) ; } catch ( Exception e ) { disposeEditorActionBars ( ( EditorActionBars ) site . getActionBars ( ) ) ; site . dispose ( ) ; if ( e instanceof PartInitException ) throw ( PartInitException ) e ; throw new PartInitException ( NLS . bind ( WorkbenchMessages . EditorManager_unableToInitialize , desc . getId ( ) , e ) , e ) ; } }	throw new PartInitException ( WorkbenchMessages . EditorManager_errorInInit , e ) ;
MetaData meta = getSourceDocument ( ) . getMetaDataManager ( ) . getDublinCoreMetaData ( ) ; <CTX> protected void doExecute ( ) throws Exception { super . doExecute ( ) ; / / dc metadata MetaData meta = getSourceDocument ( ) . getMetaDataManager ( ) . getDublinCoreMetaData ( ) ; String [ ] keys = meta . getPossibleKeys ( ) ; for ( int i = 0 ; i < keys . length ; i ++ ) { String value = getParameterAsString ( DC_FORM_PREFIX + keys [ i ] ) ; if ( value != null ) { meta . setValue ( keys [ i ] , value ) ; } } / / custom metadata MetaData customMeta = getSourceDocument ( ) . getMetaDataManager ( ) . getCustomMetaData ( ) ; String [ ] parameterNames = getParameterNames ( ) ; for ( int i = 0 ; i < parameterNames . length ; i ++ ) { String id = parameterNames [ i ] ; if ( id . startsWith ( CUSTOM_FORM_PREFIX ) ) { String key = id . substring ( CUSTOM_FORM_PREFIX . length ( ) ) ; String value = getParameterAsString ( id ) ; if ( value != null ) { customMeta . setValue ( key , value ) ; } } } / / TODO set workflow situation to edit here . }	MetaData meta = getSourceDocument ( ) . getMetaData ( DublinCore . DC_NAMESPACE ) ;
new_value . compile ( comp , false ) ; <CTX> public void compile ( Compilation comp , boolean ignore_result ) { if ( binding != null ) { if ( binding . isSimple ( ) ) { new_value . compile ( comp , false ) ; comp . method . compile_store_value ( binding ) ; } else { ReferenceExp . compile_load ( binding . baseVariable , comp ) ; comp . method . compile_push_int ( binding . offset ) ; new_value . compile ( comp , false ) ; comp . method . compile_array_store ( Compilation . scmObjectType ) ; } } else { comp . compileConstant ( name ) ; new_value . compile ( comp , false ) ; comp . method . compile_invoke_static ( comp . defineGlobalMethod ) ; } if ( ! ignore_result ) comp . compileConstant ( Interpreter . voidObject ) ; }	new_value . compile ( comp , 0 ) ;
outputFactory = new WstxOutputFactory ( ) ; inputFactory = new WstxInputFactory ( ) ; <CTX> public XMarshaler ( ) { outputFactory = new WstxOutputFactory ( ) ; inputFactory = new WstxInputFactory ( ) ; }	outputFactory = XMLOutputFactory . newInstance ( ) ; inputFactory = XMLInputFactory . newInstance ( ) ;
return new SimpleExpansionToken ( signal , data . startOffset , data . endOffset - data . startOffset + 1 , <CTX> protected IToken newToken ( int signal ) { if ( bufferData [ bufferStackPos ] instanceof MacroData ) { int mostRelevant ; for ( mostRelevant = bufferStackPos ; mostRelevant >= 0 ; -- mostRelevant ) if ( bufferData [ mostRelevant ] instanceof InclusionData || bufferData [ mostRelevant ] instanceof CodeReader ) break ; MacroData data = ( MacroData ) bufferData [ mostRelevant + 1 ] ; return new SimpleExpansionToken ( signal , data . startOffset , data . endOffset - data . startOffset + 1 , getCurrentFilename ( ) , getLineNumber ( bufferPos [ mostRelevant ] + 1 ) ) ; } return new SimpleToken ( signal , bufferPos [ bufferStackPos ] + 1 , getCurrentFilename ( ) , getLineNumber ( bufferPos [ bufferStackPos ] + 1 ) ) ; }	return new SimpleExpansionToken ( signal , data . getStartOffset ( ) , data . getLength ( ) ,
return ( aProxy == aOther ? Boolean . TRUE : Boolean . FALSE ) ; <CTX> protected static Boolean proxyEquals ( Object aProxy , Object aOther ) { return ( aProxy == aOther ? Boolean . TRUE : Boolean . FALSE ) ; }	if ( aProxy == aOther ) { return Boolean . TRUE ; } else { if ( isXPCOMJavaProxy ( aOther ) && isSameXPCOMObject ( aProxy , aOther ) ) { return Boolean . TRUE ; } } return Boolean . FALSE ;
logui . tabbedPane . setTabPlacement ( JTabbedPane . TOP ) ; <CTX> public void actionPerformed ( ActionEvent e ) { logui . tabbedPane . setTabPlacement ( JTabbedPane . TOP ) ; }	levelDisplay = ChainsawConstants . LEVEL_DISPLAY_TEXT ; SettingsManager . getInstance ( ) . saveSettings ( ) ; SettingsManager . getInstance ( ) . loadSettings ( ) ;
Iterator iterator = viterbiLoserMap . keySet ( ) . iterator ( ) ; <CTX> public void purge ( ) { int max = maxEdges - 1 ; Iterator iterator = viterbiLoserMap . keySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Object key = iterator . next ( ) ; List list = ( List ) viterbiLoserMap . get ( key ) ; Collections . sort ( list , Token . COMPARATOR ) ; List newList = list . subList ( 0 , list . size ( ) > max ? max : list . size ( ) ) ; viterbiLoserMap . put ( key , newList ) ; } }	Iterator < Object > iterator = viterbiLoserMap . keySet ( ) . iterator ( ) ;
show ( ) ; <CTX> public void addPoint ( Coords c ) { if ( start == null ) { start = c ; } else if ( start . equals ( c ) ) { clear ( ) ; hide ( ) ; } else { end = c ; distance = start . distance ( end ) ; setText ( ) ; show ( ) ; } }	setVisible ( true ) ;
unigramIDMap . put ( words [ i ] . toLowerCase ( ) , ( new Integer ( i ) ) ) ; <CTX> private void buildUnigramIDMap ( ) { String [ ] words = loader . getWords ( ) ; for ( int i = 0 ; i < words . length ; i ++ ) { if ( words [ i ] . equals ( Dictionary . SENTENCE_START_SPELLING ) ) { this . startWordID = i ; } else if ( words [ i ] . equals ( Dictionary . SENTENCE_END_SPELLING ) ) { this . endWordID = i ; } unigramIDMap . put ( words [ i ] . toLowerCase ( ) , ( new Integer ( i ) ) ) ; } }	unigramIDMap . put ( words [ i ] , ( new Integer ( i ) ) ) ;
IType [ ] temp = new IType [ ] { ( IType ) pt . clone ( ) } ; int lastIdx = 0 ; while ( pt instanceof ITypeContainer ) { try { pt = ( ( ITypeContainer ) pt ) . getType ( ) ; } catch ( DOMException e 1 ) { pt = e 1 . getProblem ( ) ; } if ( pt instanceof ITypeContainer && ! ( pt instanceof ITypedef ) ) { IType t = ( IType ) pt . clone ( ) ; ( ( ITypeContainer ) temp [ lastIdx ] ) . setType ( t ) ; temp = ( IType [ ] ) ArrayUtil . append ( IType . class , temp , t ) ; lastIdx ++ ; } else { temp = ( IType [ ] ) ArrayUtil . append ( IType . class , temp , pt ) ; lastIdx ++ ; break ; } } if ( lastIdx > 0 && temp [ lastIdx - 1 ] instanceof IQualifierType ) { temp [ lastIdx - 1 ] = temp [ lastIdx -- ] ; if ( lastIdx > 0 ) { ITypeContainer cont = ( ITypeContainer ) temp [ lastIdx - 1 ] ; cont . setType ( temp [ lastIdx ] ) ; } } IType lastType = temp [ 0 ] ; if ( lastType instanceof IArrayType ) { try { lastType = new CPPPointerType ( ( ( IArrayType ) lastType ) . getType ( ) ) ; } catch ( DOMException e 1 ) { lastType = e 1 . getProblem ( ) ; } } else if ( lastType instanceof IFunctionType ) { lastType = new CPPPointerType ( lastType ) ; } pTypes [ i ] = lastType ; <CTX> public static IFunctionType createImplicitFunctionType ( IType returnType , IParameter [ ] parameters ) { IType [ ] pTypes = new IType [ parameters . length ] ; IType pt = null ; for ( int i = 0 ; i < parameters . length ; i ++ ) { try { pt = parameters [ i ] . getType ( ) ; } catch ( DOMException e ) { pt = e . getProblem ( ) ; } IType [ ] temp = new IType [ ] { ( IType ) pt . clone ( ) } ; int lastIdx = 0 ; while ( pt instanceof ITypeContainer ) { try { pt = ( ( ITypeContainer ) pt ) . getType ( ) ; } catch ( DOMException e 1 ) { pt = e 1 . getProblem ( ) ; } if ( pt instanceof ITypeContainer && ! ( pt instanceof ITypedef ) ) { IType t = ( IType ) pt . clone ( ) ; ( ( ITypeContainer ) temp [ lastIdx ] ) . setType ( t ) ; temp = ( IType [ ] ) ArrayUtil . append ( IType . class , temp , t ) ; lastIdx ++ ; } else { temp = ( IType [ ] ) ArrayUtil . append ( IType . class , temp , pt ) ; lastIdx ++ ; break ; } } if ( lastIdx > 0 && temp [ lastIdx - 1 ] instanceof IQualifierType ) { temp [ lastIdx - 1 ] = temp [ lastIdx -- ] ; if ( lastIdx > 0 ) { ITypeContainer cont = ( ITypeContainer ) temp [ lastIdx - 1 ] ; cont . setType ( temp [ lastIdx ] ) ; } } IType lastType = temp [ 0 ] ; if ( lastType instanceof IArrayType ) { try { lastType = new CPPPointerType ( ( ( IArrayType ) lastType ) . getType ( ) ) ; } catch ( DOMException e 1 ) { lastType = e 1 . getProblem ( ) ; } } else if ( lastType instanceof IFunctionType ) { lastType = new CPPPointerType ( lastType ) ; } pTypes [ i ] = lastType ; } return new CPPFunctionType ( returnType , pTypes ) ; }	pTypes [ i ] = pt ;
reply . status = e . get_errno ( ) ; <CTX> public void set_cachesize ( DbDispatcher server ,__ env_cachesize_msg args ,__ env_cachesize_reply reply ) { try { dbenv . set_cachesize ( args . gbytes , args . bytes , args . ncache ) ; reply . status = 0 ; } catch ( DbException e ) { e . printStackTrace ( DbServer . err ) ; reply . status = e . get_errno ( ) ; } }	reply . status = e . getErrno ( ) ;
drawing . refresh ( ) ; <CTX> public void update ( ) { panel . createPanel ( ) ; drawing . refresh ( ) ; }	return drawing . refresh ( ) ;
while ( ! shutdown ) <CTX> public void handle ( Socket socket , ConnectionContext connCtx ) throws IOException { while ( ! shutdown ) Thread . yield ( ) ; }	while ( state != RunningState . STOPPED )
validate ( ) ; <CTX> public void setStatus ( String message ) { if ( message != null ) { if ( statusLabel == null ) { statusLabel = new JLabel ( ) ; statusLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; statusLabel . setForeground ( Color . white ) ; add ( statusLabel , new TableConstraints ( TableConstraints . STATUS_LABEL ) ) ; } statusLabel . setText ( message ) ; } else if ( statusLabel != null ) { remove ( statusLabel ) ; } validate ( ) ; repaint ( ) ; }	revalidate ( ) ;
IASTDeclarator declarator = declarators [ i ] ; <CTX> public List getFields ( ) { if ( definition == null ) { ICASTCompositeTypeSpecifier temp = checkForDefinition ( declarations [ 0 ] ) ; if ( temp == null ) return null ; definition = temp ; } IASTDeclaration [ ] members = definition . getMembers ( ) ; int size = members . length ; List fields = new ArrayList ( size ) ; if ( size > 0 ) { for ( int i = 0 ; i < size ; i ++ ) { IASTNode node = members [ i ] ; if ( node instanceof IASTSimpleDeclaration ) { IASTDeclarator [ ] declarators = ( ( IASTSimpleDeclaration ) node ) . getDeclarators ( ) ; for ( int j = 0 ; j < declarators . length ; j ++ ) { IASTDeclarator declarator = declarators [ i ] ; IBinding binding = declarator . getName ( ) . resolveBinding ( ) ; if ( binding != null ) fields . add ( binding ) ; } } } } return fields ; }	IASTDeclarator declarator = declarators [ j ] ;
HashMap map = FileUtil . readPropertiesFile ( file , getDelimiter ( ) ) ; <CTX> public Variable [ ] loadVariables ( Environment environment , Project antProject ) { File file = getFile ( environment , antProject ) ; if ( ! file . exists ( ) ) { System . err . println ( getFileNotFoundWarning ( file ) ) ; return new Variable [ 0 ] ; } try { HashMap map = FileUtil . readPropertiesFile ( file , getDelimiter ( ) ) ; Object [ ] keys = map . keySet ( ) . toArray ( ) ; Variable [ ] variables = createArray ( keys . length ) ; for ( int i = 0 ; i < variables . length ; i ++ ) { String key = ( String ) keys [ i ] ; variables [ i ] = createVariable ( key , ( String ) map . get ( key ) ) ; } return variables ; } catch ( IOException e ) { e . printStackTrace ( ) ; throw new BuildException ( getFileIOError ( file , e ) , e ) ; } }	Preprocessor preprocessor = ( Preprocessor ) environment . get ( Preprocessor . ENVIRONMENT_KEY ) ; String [ ] lines = FileUtil . readTextFile ( file ) ; boolean removePreprocessingComments = true ; lines = preprocessor . preprocess ( file . getAbsolutePath ( ) , new StringList ( lines ) , removePreprocessingComments ) ; Map map = StringUtil . getProperties ( lines , getDelimiter ( ) ) ;
switch ( eDerivedStructuralFeatureID ( featureID , baseClass ) ) { case LayoutPackage . PLOT__ CHILDREN : return ( ( InternalEList ) getChildren ( ) ) . basicRemove ( otherEnd , msgs ) ; case LayoutPackage . PLOT__ BOUNDS : return basicSetBounds ( null , msgs ) ; case LayoutPackage . PLOT__ INSETS : return basicSetInsets ( null , msgs ) ; case LayoutPackage . PLOT__ MIN_SIZE : return basicSetMinSize ( null , msgs ) ; case LayoutPackage . PLOT__ OUTLINE : return basicSetOutline ( null , msgs ) ; case LayoutPackage . PLOT__ BACKGROUND : return basicSetBackground ( null , msgs ) ; case LayoutPackage . PLOT__ TRIGGERS : return ( ( InternalEList ) getTriggers ( ) ) . basicRemove ( otherEnd , msgs ) ; case LayoutPackage . PLOT__ CLIENT_AREA : return basicSetClientArea ( null , msgs ) ; default : return eDynamicInverseRemove ( otherEnd , featureID , baseClass , msgs ) ; } <CTX> public NotificationChain eInverseRemove ( InternalEObject otherEnd , int featureID , Class baseClass , NotificationChain msgs ) { if ( featureID >= 0 ) { switch ( eDerivedStructuralFeatureID ( featureID , baseClass ) ) { case LayoutPackage . PLOT__ CHILDREN : return ( ( InternalEList ) getChildren ( ) ) . basicRemove ( otherEnd , msgs ) ; case LayoutPackage . PLOT__ BOUNDS : return basicSetBounds ( null , msgs ) ; case LayoutPackage . PLOT__ INSETS : return basicSetInsets ( null , msgs ) ; case LayoutPackage . PLOT__ MIN_SIZE : return basicSetMinSize ( null , msgs ) ; case LayoutPackage . PLOT__ OUTLINE : return basicSetOutline ( null , msgs ) ; case LayoutPackage . PLOT__ BACKGROUND : return basicSetBackground ( null , msgs ) ; case LayoutPackage . PLOT__ TRIGGERS : return ( ( InternalEList ) getTriggers ( ) ) . basicRemove ( otherEnd , msgs ) ; case LayoutPackage . PLOT__ CLIENT_AREA : return basicSetClientArea ( null , msgs ) ; default : return eDynamicInverseRemove ( otherEnd , featureID , baseClass , msgs ) ; } } return eBasicSetContainer ( null , featureID , msgs ) ; }	case LayoutPackage . PLOT__ CLIENT_AREA : return basicSetClientArea ( null , msgs ) ;
if ( infiniteFlag != n . infiniteFlag ) return false ; if ( valueClass == INT ) return n . equals ( intValue , false ) ; else if ( valueClass == LONG ) return n . equals ( longValue , false ) ; <CTX> public boolean equals ( MesquiteNumber n ) { if ( unassignedFlag != n . unassignedFlag ) return false ; if ( infiniteFlag != n . infiniteFlag ) return false ; if ( valueClass == INT ) return n . equals ( intValue , false ) ; else if ( valueClass == LONG ) return n . equals ( longValue , false ) ; else if ( valueClass == DOUBLE ) return n . equals ( doubleValue , false ) ; return false ; }	else if ( valueClass == INT ) return ( intValue == value ) ; else if ( valueClass == LONG ) return ( longValue == MesquiteLong . toLong ( value ) ) ;
assertTrue ( rule . getPermissions ( ) . isEmpty ( ) ) ; <CTX> public void testAsDialingRulesListNoExceptions ( ) { EmergencyRouting routing = new EmergencyRouting ( ) ; routing . setDefaultGateway ( m_defaultGateway ) ; routing . setExternalNumber ( DEFAULT_EXTENSION ) ; List rules = routing . asDialingRulesList ( ) ; assertEquals ( 1 , rules . size ( ) ) ; IDialingRule rule = ( IDialingRule ) rules . get ( 0 ) ; List gateways = rule . getGateways ( ) ; assertEquals ( 1 , gateways . size ( ) ) ; assertEquals ( m_defaultGateway . getAddress ( ) , ( ( Gateway ) gateways . get ( 0 ) ) . getAddress ( ) ) ; assertTrue ( rule . getPermissions ( ) . isEmpty ( ) ) ; assertEquals ( 1 , rule . getPatterns ( ) . length ) ; assertEquals ( DEFAULT_EXTENSION , rule . getPatterns ( ) [ 0 ] ) ; }	assertTrue ( rule . getPermissionNames ( ) . isEmpty ( ) ) ;
if ( ! monitor . isCanceled ( ) ) this . contentProvider . rememberResult ( ) ; <CTX> protected void filterContent ( FilteringProgressMonitor monitor ) throws CoreException { this . contentProvider . addHistoryItems ( ) ; fillContentProvider ( this . contentProvider , monitor ) ; if ( ! monitor . isCanceled ( ) ) this . contentProvider . rememberResult ( ) ; }	if ( monitor != null && ! monitor . isCanceled ( ) ) { monitor . done ( ) ; this . contentProvider . rememberResult ( this . itemsFilter ) ; }
assertTrue ( history . canUndo ( c 1 ) ) ; status = history . undo ( c 1 , null , null ) ; <CTX> public void testWorkbenchOperationApproval ( ) throws ExecutionException { / / Enforcing of linear undo should be in effect for the workbench / / context . / / The first undo in c 1 should be fine IStatus status = history . undo ( c 1 , null , null ) ; assertTrue ( status . isOK ( ) ) ; / / the second undo in c 1 causes a linear violation on the workbench / / context assertTrue ( history . canUndo ( c 1 ) ) ; status = history . undo ( c 1 , null , null ) ; assertFalse ( status . isOK ( ) ) ; / / undo the newer context items status = history . undo ( context , null , null ) ; assertTrue ( status . isOK ( ) ) ; status = history . undo ( context , null , null ) ; assertTrue ( status . isOK ( ) ) ; / / now we should be ok to undo c 1 status = history . undo ( c 1 , null , null ) ; assertTrue ( status . isOK ( ) ) ; }	assertTrue ( history . canUndo ( contextA ) ) ; status = history . undo ( contextA , null , null ) ;
getListBlockFO ( ) . getCommonBorderPaddingBackground ( ) ) ; <CTX> public Area getParentArea ( Area childArea ) { if ( curBlockArea == null ) { curBlockArea = new Block ( ) ; / / Set up dimensions / / Must get dimensions from parent area / * Area parentArea = * / parentLM . getParentArea ( curBlockArea ) ; / / set traits TraitSetter . setProducerID ( curBlockArea , getListBlockFO ( ) . getId ( ) ) ; TraitSetter . addBorders ( curBlockArea , getListBlockFO ( ) . getCommonBorderPaddingBackground ( ) ) ; TraitSetter . addMargins ( curBlockArea , getListBlockFO ( ) . getCommonBorderPaddingBackground ( ) , getListBlockFO ( ) . getCommonMarginBlock ( ) ) ; TraitSetter . addBreaks ( curBlockArea , getListBlockFO ( ) . getBreakBefore ( ) , getListBlockFO ( ) . getBreakAfter ( ) ) ; int contentIPD = referenceIPD - getIPIndents ( ) ; curBlockArea . setIPD ( contentIPD ) ; TraitSetter . addBackground ( curBlockArea , getListBlockFO ( ) . getCommonBorderPaddingBackground ( ) ) ; setCurrentArea ( curBlockArea ) ; } return curBlockArea ; }	getListBlockFO ( ) . getCommonBorderPaddingBackground ( ) , this ) ;
return userObject != null ? userObject . toString ( ) : null ; <CTX> public String toString ( ) { return userObject != null ? userObject . toString ( ) : null ; }	return ApesGraphConstants . getValue ( attributes ) . toString ( ) ;
if ( isCreating || SessionHandleAdapter . getInstance ( ) . getReportDesignHandle ( ) instanceof LibraryHandle ) <CTX> protected boolean handleMove ( ) { if ( isCreating || SessionHandleAdapter . getInstance ( ) . getReportDesignHandle ( ) instanceof LibraryHandle ) { return true ; } boolean validateTrue = false ; updateTargetUnderMouse ( ) ; if ( getTargetEditPart ( ) != null ) { validateTrue = handleValidatePalette ( getFactory ( ) . getObjectType ( ) , getTargetEditPart ( ) ) ; } if ( validateTrue ) { updateTargetRequest ( ) ; setCurrentCommand ( getCommand ( ) ) ; showTargetFeedback ( ) ; } else { setCurrentCommand ( null ) ; } return validateTrue ; }	boolean validateTrue = false ; updateTargetUnderMouse ( ) ; if ( isCreating || getTargetEditPart ( ) . getModel ( ) instanceof LibraryHandle )
clause = new Clause ( Phrase . read ( in ) , field , required , prohibited , nutchConf ) ; <CTX> public static Clause read ( DataInput in , NutchConf nutchConf ) throws IOException { byte bits = in . readByte ( ) ; boolean required = ( ( bits & REQUIRED_BIT ) != 0 ) ; boolean prohibited = ( ( bits & PROHIBITED_BIT ) != 0 ) ; String field = in . readUTF ( ) ; float weight = in . readFloat ( ) ; Clause clause ; if ( ( bits & PHRASE_BIT ) == 0 ) { clause = new Clause ( Term . read ( in ) , field , required , prohibited , nutchConf ) ; } else { clause = new Clause ( Phrase . read ( in ) , field , required , prohibited , nutchConf ) ; } clause . weight = weight ; return clause ; }	clause = new Clause ( Phrase . read ( in ) , field , required , prohibited , conf ) ;
m_fconfig = config ; m_models [ 0 ] . clear ( ) ; m_models [ 1 ] . clear ( ) ; <CTX> public void refresh ( IFtpConfig config ) { m_fconfig = config ; m_models [ 0 ] . clear ( ) ; m_models [ 1 ] . clear ( ) ; }	fconfig = config ; models [ 0 ] . clear ( ) ; models [ 1 ] . clear ( ) ;
if ( boldFont != null ) boldFont . dispose ( ) ; if ( italicFont != null ) italicFont . dispose ( ) ; <CTX> void dispose ( ) { baseFont . dispose ( ) ; if ( boldFont != null ) boldFont . dispose ( ) ; if ( italicFont != null ) italicFont . dispose ( ) ; }	if ( boldFont != null ) { boldFont . dispose ( ) ; } if ( italicFont != null ) { italicFont . dispose ( ) ; }
return bankData [ bank ] ; <CTX> public short [ ] getData ( int bank ) { return bankData [ bank ] ; }	return data ;
if ( ! myIsDisposed && editor . getComponent ( ) . isShowing ( ) ) { <CTX> private void updateBraces ( final Editor editor ) { ApplicationManager . getApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { if ( ! myIsDisposed && editor . getComponent ( ) . isShowing ( ) ) { new BraceHighlightingHandler ( myProject , editor , myAlarm ) . updateBraces ( ) ; } } } , ModalityState . stateForComponent ( editor . getComponent ( ) ) ) ; }	if ( ! myIsDisposed && editor . getComponent ( ) . isShowing ( ) && ! editor . isViewer ( ) ) {
PsiClass psiClass = DebuggerUtilsEx . findClass ( myQualifiedName , myProject ) ; <CTX> public SourcePosition compute ( ) { PsiClass psiClass = DebuggerUtilsEx . findClass ( myQualifiedName , myProject ) ; return psiClass != null ? SourcePosition . createFromElement ( psiClass ) : null ; }	PsiClass psiClass = DebuggerUtilsEx . findClass ( myQualifiedName , myProject , debugProcess . getSession ( ) . getSearchScope ( ) ) ;
if ( ! myProject . isOpen ( ) ) return ; <CTX> public void run ( ) { if ( ! myProject . isOpen ( ) ) return ; updateStatus ( ) ; }	if ( myProject . isDisposed ( ) ) return ;
return getContainingScope ( parent ) ; <CTX> public static IScope getContainingScope ( IASTName name ) { IASTNode parent = name . getParent ( ) ; try { if ( parent instanceof ICPPASTTemplateId ) { name = ( IASTName ) parent ; parent = name . getParent ( ) ; } ICPPASTTemplateDeclaration decl = CPPTemplates . getTemplateDeclaration ( name ) ; if ( decl != null ) return decl . getScope ( ) ; if ( parent instanceof ICPPASTQualifiedName ) { IASTName [ ] names = ( ( ICPPASTQualifiedName ) parent ) . getNames ( ) ; int i = 0 ; for ( ; i < names . length ; i ++ ) { if ( names [ i ] == name ) break ; } if ( i > 0 ) { IBinding binding = names [ i - 1 ] . resolveBinding ( ) ; while ( binding instanceof ITypedef ) { IType t = ( ( ITypedef ) binding ) . getType ( ) ; if ( t instanceof IBinding ) binding = ( IBinding ) t ; else break ; } if ( binding instanceof ICPPClassType ) { return ( ( ICPPClassType ) binding ) . getCompositeScope ( ) ; } else if ( binding instanceof ICPPNamespace ) { return ( ( ICPPNamespace ) binding ) . getNamespaceScope ( ) ; } else if ( binding instanceof ICPPInternalUnknown ) { return ( ( ICPPInternalUnknown ) binding ) . getUnknownScope ( ) ; } else if ( binding instanceof IProblemBinding ) { if ( binding instanceof ICPPScope ) return ( IScope ) binding ; return new CPPScope . CPPScopeProblem ( names [ i - 1 ] , IProblemBinding . SEMANTIC_BAD_SCOPE , names [ i - 1 ] . toCharArray ( ) ) ; } } else if ( ( ( ICPPASTQualifiedName ) parent ) . isFullyQualified ( ) ) { return parent . getTranslationUnit ( ) . getScope ( ) ; } } else if ( parent instanceof ICPPASTFieldReference ) { IASTExpression owner = ( ( ICPPASTFieldReference ) parent ) . getFieldOwner ( ) ; IType type = getExpressionType ( owner ) ; if ( ( ( ICPPASTFieldReference ) parent ) . isPointerDereference ( ) ) { while ( type instanceof ITypedef ) type = ( ( ITypedef ) type ) . getType ( ) ; if ( type instanceof ICPPClassType ) { ICPPFunction op = CPPSemantics . findOperator ( ( IASTFieldReference ) parent , ( ICPPClassType ) type ) ; if ( op != null ) { type = op . getType ( ) . getReturnType ( ) ; } } } type = CPPSemantics . getUltimateType ( type , false ) ; if ( type instanceof ICPPClassType ) { return ( ( ICPPClassType ) type ) . getCompositeScope ( ) ; } } else if ( parent instanceof IASTGotoStatement || parent instanceof IASTLabelStatement ) { while ( ! ( parent instanceof IASTFunctionDefinition ) ) { parent = parent . getParent ( ) ; } IASTFunctionDefinition fdef = ( IASTFunctionDefinition ) parent ; return ( ( ICPPASTFunctionDeclarator ) fdef . getDeclarator ( ) ) . getFunctionScope ( ) ; } } catch ( DOMException e ) { IProblemBinding problem = e . getProblem ( ) ; if ( problem instanceof ICPPScope ) return problem ; return new CPPScope . CPPScopeProblem ( problem . getASTNode ( ) , problem . getID ( ) , problem . getNameCharArray ( ) ) ; } return getContainingScope ( parent ) ; }	return null ;
this . argsCount = argsCount ; this . optArgs = optArgs ; this . restArg = restArg ; <CTX> public ArgsNode ( ISourcePosition position , int argsCount , ListNode optArgs , int restArg , BlockArgNode blockArgNode ) { super ( position ) ; this . argsCount = argsCount ; this . optArgs = optArgs ; this . restArg = restArg ; this . blockArgNode = blockArgNode ; }	this . arguments = arguments ; this . optArgs = optionalArguments ; this . restArg = restArguments ;
return getValue ( obj ) ; <CTX> public String getCategoryValue ( Object obj ) { return getValue ( obj ) ; }	if ( obj == null || ! ( obj instanceof ConcreteMarker ) ) { return Util . EMPTY_STRING ; } ConcreteMarker marker = ( ConcreteMarker ) obj ; return marker . getShortFolder ( ) ;
return Collections . EMPTY_LIST ; <CTX> public List childNodes ( ) { return Collections . EMPTY_LIST ; }	return EMPTY_LIST ;
String [ ] childrenNames = node . childrenNames ( ) ; for ( int i = 0 ; childrenNames != null && i < childrenNames . length ; i ++ ) { if ( childrenNames [ i ] . equals ( DefaultScope . SCOPE ) ) continue ; Preferences preferences = node . node ( childrenNames [ i ] ) ; result . add ( preferences ) ; <CTX> public Object [ ] getChildren ( Object parent ) { ArrayList result = new ArrayList ( ) ; if ( parent instanceof IEclipsePreferences ) { IEclipsePreferences node = ( IEclipsePreferences ) parent ; try { String [ ] childrenNames = node . childrenNames ( ) ; for ( int i = 0 ; childrenNames != null && i < childrenNames . length ; i ++ ) { if ( childrenNames [ i ] . equals ( DefaultScope . SCOPE ) ) continue ; Preferences preferences = node . node ( childrenNames [ i ] ) ; result . add ( preferences ) ; / / } } } catch ( BackingStoreException e ) { e . printStackTrace ( ) ; } } return result . toArray ( new Object [ result . size ( ) ] ) ; }	if ( node . parent ( ) == null ) { String [ ] childrenNames = node . childrenNames ( ) ; for ( int i = 0 ; childrenNames != null && i < childrenNames . length ; i ++ ) { String child = childrenNames [ i ] ; if ( ! scopes . contains ( child ) ) continue ; Preferences preferences = node . node ( child ) ; if ( hasKeys ( preferences ) ) result . add ( preferences ) ; } } else if ( node . parent ( ) . parent ( ) == null ) { String [ ] childrenNames = node . childrenNames ( ) ; for ( int i = 0 ; childrenNames != null && i < childrenNames . length ; i ++ ) { String child = childrenNames [ i ] ; Preferences preferences = node . node ( child ) ; if ( hasKeys ( preferences ) ) result . add ( preferences ) ; }
else if ( IDialogConstants . CANCEL_ID == buttonId ) <CTX> protected void buttonPressed ( int buttonId ) { if ( IDialogConstants . OK_ID == buttonId ) okPressed ( ) ; else if ( IDialogConstants . CANCEL_ID == buttonId ) cancelPressed ( ) ; }	} else if ( IDialogConstants . CANCEL_ID == buttonId ) {
super ( position ) ; <CTX> public ClassVarNode ( ISourcePosition position , String name ) { super ( position ) ; this . name = name . intern ( ) ; }	super ( position , NodeTypes . CLASSVARNODE ) ;
month = new Month ( calendar , date , firstDay ) ; <CTX> public Month getMonth ( ) { if ( month == null ) month = new Month ( calendar , date , firstDay ) ; return month ; }	month = new Month ( calendar , date , firstDay , timeZone ) ;
if ( ! ( position . getFile ( ) . getFileType ( ) . equals ( StdFileTypes . JSP ) ) ) { <CTX> public ClassPrepareRequest createPrepareRequest ( final ClassPrepareRequestor requestor , final SourcePosition position ) throws NoDataException { if ( ! ( position . getFile ( ) . getFileType ( ) . equals ( StdFileTypes . JSP ) ) ) { throw new NoDataException ( ) ; } return myDebugProcess . getRequestsManager ( ) . createClassPrepareRequest ( new ClassPrepareRequestor ( ) { public void processClassPrepare ( DebugProcess debuggerProcess , ReferenceType referenceType ) { try { if ( locationsOfClassAt ( referenceType , position ) != null ) { requestor . processClassPrepare ( debuggerProcess , referenceType ) ; } } catch ( NoDataException e ) { } } } , JSP_PATTERN ) ; }	final FileType fileType = position . getFile ( ) . getFileType ( ) ; if ( fileType != StdFileTypes . JSP && fileType != StdFileTypes . JSPX ) {
viewer = CheatSheetViewerFactory . createCheatSheetView ( ) ; <CTX> public void createControl ( Composite parent , FormToolkit toolkit ) { viewer = CheatSheetViewerFactory . createCheatSheetView ( ) ; viewer . createPartControl ( parent ) ; }	viewer = ( CheatSheetViewer ) CheatSheetViewerFactory . createCheatSheetView ( ) ;
if ( sphinxProperties == null ) { this . name = name ; this . context = context ; this . timer = Timer . getTimer ( context , name ) ; this . sphinxProperties = SphinxProperties . getSphinxProperties ( context ) ; } <CTX> public void initialize ( String name , String context ) { if ( sphinxProperties == null ) { this . name = name ; this . context = context ; this . timer = Timer . getTimer ( context , name ) ; this . sphinxProperties = SphinxProperties . getSphinxProperties ( context ) ; } }	this . name = name ; this . context = context ; this . timer = Timer . getTimer ( context , name ) ; this . sphinxProperties = SphinxProperties . getSphinxProperties ( context ) ;
iVisited . accept (_Payload ) ; <CTX> public void visitAndNode ( AndNode iVisited ) { iVisited . getFirstNode ( ) . accept ( this ) ; iVisited . accept (_Payload ) ; iVisited . getSecondNode ( ) . accept ( this ) ; }	_ Payload . visitAndNode ( iVisited ) ;
isAdminHolder . set ( Boolean . valueOf ( isAdmin ) ) ; <CTX> public static void setAdmin ( boolean isAdmin ) { isAdminHolder . set ( Boolean . valueOf ( isAdmin ) ) ; }	data . get ( ) . isAdmin = isAdmin ;
WeaponType wtype = ( WeaponType ) mounted . getType ( ) ; for ( Enumeration i = getAmmo ( ) ; i . hasMoreElements ( ) ; ) { Mounted mountedAmmo = ( Mounted ) i . nextElement ( ) ; <CTX> public void loadWeapon ( Mounted mounted ) { WeaponType wtype = ( WeaponType ) mounted . getType ( ) ; for ( Enumeration i = getAmmo ( ) ; i . hasMoreElements ( ) ; ) { Mounted mountedAmmo = ( Mounted ) i . nextElement ( ) ; if ( loadWeapon ( mounted , mountedAmmo ) ) break ; } }	for ( Mounted mountedAmmo : getAmmo ( ) ) {
while ( elements . hasNext ( ) ) { element = ( DTDLocation ) elements . next ( ) ; <CTX> private DTDLocation findMatchingDTD ( String publicId ) { Iterator elements = getElements ( ) . iterator ( ) ; DTDLocation element = null ; while ( elements . hasNext ( ) ) { element = ( DTDLocation ) elements . next ( ) ; if ( element . getPublicId ( ) . equals ( publicId ) ) { return element ; } } return null ; }	while ( elements . hasMoreElements ( ) ) { element = ( DTDLocation ) elements . nextElement ( ) ;
ConnectException ( String message ) <CTX> ConnectException ( String message ) { super ( message ) ; }	ConnectException ( )
SQLExceptionHandler . throwSQLException ( e ) ; throw e ; <CTX> public int getMaxUserNameLength ( ) throws SQLException { try { return m_metaData . getMaxUserNameLength ( ) ; } catch ( SQLException e ) { SQLExceptionHandler . throwSQLException ( e ) ; throw e ; / / code should never get here , but just in case } }	throw m_conn . wrap ( e ) ;
instanceMap . put ( project , new ResultsFrame ( ) ) ; <CTX> public static ResultsFrame getInstance ( BProject project ) { if ( ! instanceMap . containsKey ( project ) ) instanceMap . put ( project , new ResultsFrame ( ) ) ; return instanceMap . get ( project ) ; }	{ if ( createIfNeeded ) instanceMap . put ( project , new ResultsFrame ( ) ) ; else return null ; }
array [ i ] = new InterpretedFunction ( cx , jsi . itsData ) ; <CTX> private void generateNestedFunctions ( Context cx , Scriptable scope , Node tree ) { ObjArray functionList = ( ObjArray ) tree . getProp ( Node . FUNCTION_PROP ) ; if ( functionList == null ) return ; int N = functionList . size ( ) ; InterpretedFunction [ ] array = new InterpretedFunction [ N ] ; for ( int i = 0 ; i != N ; i ++ ) { FunctionNode def = ( FunctionNode ) functionList . get ( i ) ; Interpreter jsi = new Interpreter ( ) ; jsi . itsSourceFile = itsSourceFile ; jsi . itsData = new InterpreterData ( cx , itsData . securityDomain ) ; jsi . itsData . itsCheckThis = def . getCheckThis ( ) ; jsi . itsData . itsFunctionType = def . getFunctionType ( ) ; jsi . itsInFunctionFlag = true ; jsi . debugSource = debugSource ; jsi . generateFunctionICode ( cx , scope , def ) ; array [ i ] = new InterpretedFunction ( cx , jsi . itsData ) ; def . putIntProp ( Node . FUNCTION_PROP , i ) ; } itsData . itsNestedFunctions = array ; }	array [ i ] = jsi . itsData ;
super ( handler , handler . getModule ( ) , Module . DATA_SET_SLOT ) ; <CTX> public TemplateDataSetState ( ModuleParserHandler handler ) { super ( handler , handler . getModule ( ) , Module . DATA_SET_SLOT ) ; }	super ( handler , handler . getModule ( ) , IModuleModel . DATA_SET_SLOT ) ;
Statement statement = statement ( node . getNextSibling ( ) ) ; <CTX> protected CaseStatement caseStatement ( AST node ) { Expression expression = expression ( node . getFirstChild ( ) ) ; Statement statement = statement ( node . getNextSibling ( ) ) ; CaseStatement answer = new CaseStatement ( expression , statement ) ; configureAST ( answer , node ) ; return answer ; }	AST nextSibling = node . getNextSibling ( ) ; Statement statement = EmptyStatement . INSTANCE ; if ( ! isType ( LITERAL_default , nextSibling ) ) { statement = statement ( nextSibling ) ; }
if ( ! restore || editorMemento == null ) <CTX> public IEditorPart getEditor ( boolean restore ) { if ( part != null ) return ( IEditorPart ) part ; if ( ! restore || editorMemento == null ) return null ; IStatus status = restoreEditor ( this ) ; Workbench workbench = ( Workbench ) window . getWorkbench ( ) ; if ( status . getSeverity ( ) == IStatus . ERROR ) { editorMemento = null ; page . closeEditor ( this , false ) ; if ( closingEditorStatus != null ) { closingEditorStatus . add ( status ) ; } else if ( ! workbench . isStarting ( ) ) { ErrorDialog . openError ( window . getShell ( ) , WorkbenchMessages . EditorManager_unableToRestoreEditorTitle , NLS . bind ( WorkbenchMessages . EditorManager_unableToRestoreEditorMessage , getName ( ) ) , status , IStatus . WARNING | IStatus . ERROR ) ; } } setPane ( getPane ( ) ) ; releaseReferences ( ) ; return ( IEditorPart ) part ; }	if ( ! restore )
} else { <CTX> private void writeElement ( XmlSchemaElement xsElt ) throws SchemaCompilationException { if ( this . processedElementMap . containsKey ( xsElt . getQName ( ) ) ) { return ; } XmlSchemaType schemaType = xsElt . getSchemaType ( ) ; if ( schemaType != null ) { BeanWriterMetaInfoHolder metainf = new BeanWriterMetaInfoHolder ( ) ; if ( schemaType . getName ( ) != null ) { / / this is a named type QName qName = schemaType . getQName ( ) ; / / find the class name String className = findClassName ( qName , isArray ( xsElt ) ) ; / / this means the schema type actually returns a different QName if ( changedTypeMap . containsKey ( qName ) ) { metainf . registerMapping ( xsElt . getQName ( ) , ( QName ) changedTypeMap . get ( qName ) , className ) ; } else { metainf . registerMapping ( xsElt . getQName ( ) , qName , className ) ; } } else { / / we are going to special case the anonymous complex type . Our algorithm for dealing / / with it is to generate a single object that has the complex content inside . Really the / / intent of the user when he declares the complexType anonymously is to use it privately / / First copy the schema types content into the metainf holder metainf = ( BeanWriterMetaInfoHolder ) this . processedAnonymousComplexTypesMap . get ( xsElt ) ; metainf . setAnonymous ( true ) ; } String writtenClassName = writer . write ( xsElt , processedTypemap , metainf ) ; processedElementMap . put ( xsElt . getQName ( ) , writtenClassName ) ; } }	} else if ( xsElt . getRefName ( ) != null ) { } else {
return set . evaluate ( ( IBaseExpression ) map . get ( expression ) ) ; <CTX> public Object evaluate ( String expression ) { return set . evaluate ( ( IBaseExpression ) map . get ( expression ) ) ; }	IBaseExpression ibe = ( IBaseExpression ) map . get ( expression ) ; if ( ibe == null ) { return null ; } return set . evaluate ( ibe ) ;
BucketTools . copyTo ( decodedData , os , truncateLength ) ; <CTX> public long writeDecodedDataTo ( OutputStream os , long truncateLength ) throws IOException { long len = decodedData . size ( ) ; if ( truncateLength >= 0 && truncateLength < len ) len = truncateLength ; BucketTools . copyTo ( decodedData , os , truncateLength ) ; return len ; }	BucketTools . copyTo ( decodedData , os , Math . min ( truncateLength , decodedData . size ( ) ) ) ;
super ( message , cause ) ; <CTX> public DigestException ( String message , Throwable cause ) { super ( message , cause ) ; }	super ( message ) ;
return getModelPresentation ( ) . getImage ( element ) ; <CTX> public Image getImage ( Object element ) { return getModelPresentation ( ) . getImage ( element ) ; }	Image image = getModelPresentation ( ) . getImage ( element ) ; if ( image == null ) { if ( element instanceof IAdaptable ) { IWorkbenchAdapter de = ( IWorkbenchAdapter ) ( ( IAdaptable ) element ) . getAdapter ( IWorkbenchAdapter . class ) ; if ( de != null ) { ImageDescriptor descriptor = de . getImageDescriptor ( element ) ; if ( descriptor != null ) { image = descriptor . createImage ( ) ; } } } } return image ;
/ * package * / Rectangle getFastViewBounds ( IViewPart part ) { <CTX> / * package * / Rectangle getFastViewBounds ( IViewPart part ) { / / Copy the bounds of the page composite Rectangle bounds = page . getClientComposite ( ) . getBounds ( ) ; ViewPane pane = ( ViewPane ) ( ( ViewSite ) part . getSite ( ) ) . getPane ( ) ; / / get the width ratio of the fast view float ratio = getFastViewWidthRatio ( pane . getID ( ) ) ; / / Compute the actual width of the fast view . bounds . width = ( int ) ( ratio * ( float ) getClientComposite ( ) . getSize ( ) . x ) ; return bounds ; }	/ * package * / Rectangle getFastViewBounds ( IViewReference ref ) {
return BugzillaReportElement . valueOf ( key ) . isHidden ( ) ; <CTX> public boolean getIsHidden ( String key ) { try { return BugzillaReportElement . valueOf ( key ) . isHidden ( ) ; } catch ( IllegalArgumentException e ) { return false ; } }	return BugzillaReportElement . valueOf ( key . trim ( ) . toUpperCase ( ) ) . isHidden ( ) ;
contentProvider . worked ( 1 ) ; <CTX> public boolean visit ( IResourceProxy proxy ) { if ( contentProvider . isDeactivated ( ) ) return false ; IResource res = proxy . requestResource ( ) ; ResourceSearchItem searchItem = new ResourceSearchItem ( res ) ; if ( this . projects . remove ( ( res . getProject ( ) ) ) || this . projects . remove ( ( res ) ) ) { contentProvider . worked ( 1 ) ; } contentProvider . addSearchItem ( searchItem ) ; if ( res . getType ( ) == IResource . FILE ) { return false ; } return true ; }	progressMonitor . worked ( 1 ) ;
return MylarImages . RELATIONSHIPS_REFS_JUNIT ; <CTX> public ImageDescriptor getIconForRelationship ( String relationshipHandle ) { if ( relationshipHandle . equals ( JavaReferencesProvider . ID ) ) { return MylarImages . RELATIONSHIPS_REFS_JAVA ; } else if ( relationshipHandle . equals ( JavaImplementorsProvider . ID ) ) { return MylarImages . RELATIONSHIPS_INHERITANCE_JAVA ; } else if ( relationshipHandle . equals ( JUnitReferencesProvider . ID ) ) { return MylarImages . RELATIONSHIPS_REFS_JUNIT ; } else if ( relationshipHandle . equals ( JavaWriteAccessProvider . ID ) ) { return MylarImages . RELATIONSHIPS_WRITE_JAVA ; } else if ( relationshipHandle . equals ( JavaReadAccessProvider . ID ) ) { return MylarImages . RELATIONSHIPS_READ_JAVA ; } else { return null ; } }	return MylarImages . EDGE_REF_JUNIT ;
if ( root ) { if ( INC_DEC_ROOT ) { RCBaseHeader . incRC ( object ) ; VM_Interface . getPlan ( ) . addToRootSet ( object ) ; } else if ( RCBaseHeader . setRoot ( object ) ) { VM_Interface . getPlan ( ) . addToRootSet ( object ) ; } } else RCBaseHeader . incRC ( object ) ; <CTX> public final VM_Address traceObject ( VM_Address object , boolean root ) throws VM_PragmaInline { if ( root ) { if ( INC_DEC_ROOT ) { RCBaseHeader . incRC ( object ) ; VM_Interface . getPlan ( ) . addToRootSet ( object ) ; } else if ( RCBaseHeader . setRoot ( object ) ) { VM_Interface . getPlan ( ) . addToRootSet ( object ) ; } } else RCBaseHeader . incRC ( object ) ; return object ; }	if ( INC_DEC_ROOT ) { RCBaseHeader . incRC ( object ) ; VM_Interface . getPlan ( ) . addToRootSet ( object ) ; } else if ( RCBaseHeader . setRoot ( object ) ) { VM_Interface . getPlan ( ) . addToRootSet ( object ) ; }
if ( listener != null ) { return ( listener . createDefaultHttpContext ( bundle ) ) ; <CTX> public HttpContext createDefaultHttpContext ( ) { HttpListener listener = this . listener ; if ( listener != null ) { return ( listener . createDefaultHttpContext ( bundle ) ) ; } return ( null ) ; }	if ( tempListener != null ) { return ( tempListener . createDefaultHttpContext ( bundle ) ) ;
if ( array == null ) return null ; int length = array . length ; if ( length == 0 ) return array ; char [ ] result = null ; int count = 0 ; for ( int i = 0 ; i < length ; i ++ ) { char c = array [ i ] ; if ( c == toBeRemoved ) { if ( result == null ) { result = new char [ length ] ; System . arraycopy ( array , 0 , result , 0 , i ) ; count = i ; <CTX> public static final char [ ] remove ( char [ ] array , char toBeRemoved ) { if ( array == null ) return null ; int length = array . length ; if ( length == 0 ) return array ; char [ ] result = null ; int count = 0 ; for ( int i = 0 ; i < length ; i ++ ) { char c = array [ i ] ; if ( c == toBeRemoved ) { if ( result == null ) { result = new char [ length ] ; System . arraycopy ( array , 0 , result , 0 , i ) ; count = i ; } } else if ( result != null ) { result [ count ++ ] = c ; } } if ( result == null ) return array ; System . arraycopy ( result , 0 , result = new char [ count ] , 0 , count ) ; return result ; }	if ( array == null ) return null ; int length = array . length ; if ( length == 0 ) return array ; char [ ] result = null ; int count = 0 ; for ( int i = 0 ; i < length ; i ++ ) { char c = array [ i ] ; if ( c == toBeRemoved ) { if ( result == null ) { result = new char [ length ] ; System . arraycopy ( array , 0 , result , 0 , i ) ; count = i ; } } else if ( result != null ) { result [ count ++ ] = c ;
msg . set ( NODE_TO_NODE_MESSAGE_DATA , data ) ; <CTX> public static final Message createNodeToNodeMessage ( int type , String data ) { Message msg = new Message ( nodeToNodeTextMessage ) ; msg . set ( NODE_TO_NODE_MESSAGE_TYPE , type ) ; msg . set ( NODE_TO_NODE_MESSAGE_DATA , data ) ; return msg ; }	msg . set ( NODE_TO_NODE_MESSAGE_DATA , new ShortBuffer ( data ) ) ;
int prot , int flags , int fd , long offset ) { <CTX> public static Address mmap ( Address address , int size , int prot , int flags , int fd , long offset ) { if ( VM . VerifyAssertions ) VM ._assert ( isPageAligned ( address ) && isPageMultiple ( size ) && isPageMultiple ( offset ) ) ; return VM_SysCall . sysMMapErrno ( address , Extent . fromIntSignExtend ( size ) , prot , flags , fd , offset ) ; }	int prot , int flags , int fd , Offset offset ) {
void suspend ( ) { running = false ; <CTX> void suspend ( ) { running = false ; m_upLatch . lock ( ) ; if ( m_upProcessingThread != null ) { m_upProcessingThread . interrupt ( ) ; m_upProcessingThread = null ; } }	synchronized void suspend ( ) {
ExtendedRequestImpl snickersMessage = new ExtendedRequestImpl ( messageId ) ; ExtendedRequest extendedRequest = twixMessage . getExtendedRequest ( ) ; <CTX> private Message transformExtendedRequest ( LdapMessage twixMessage , int messageId ) { ExtendedRequestImpl snickersMessage = new ExtendedRequestImpl ( messageId ) ; ExtendedRequest extendedRequest = twixMessage . getExtendedRequest ( ) ; / / Twix : OID requestName -> Snickers : String oid snickersMessage . setOid ( extendedRequest . getRequestName ( ) ) ; / / Twix : OctetString requestValue -> Snickers : byte [ ] payload snickersMessage . setPayload ( extendedRequest . getRequestValue ( ) ) ; return snickersMessage ; }	ExtendedRequest extendedRequest = twixMessage . getExtendedRequest ( ) ; ExtendedRequestImpl snickersMessage = null ; if ( extendedRequest . getRequestName ( ) . equals ( GracefulShutdownRequest . EXTENSION_OID ) ) { snickersMessage = new GracefulShutdownRequest ( messageId ) ; } else { snickersMessage = new ExtendedRequestImpl ( messageId ) ; }
if ( newPart == activePart ) return ; <CTX> public void setActivePart ( IWorkbenchPart newPart ) { / / Optimize . if ( newPart == activePart ) return ; ISelectionProvider selectionProvider = null ; if ( newPart != null ) { selectionProvider = newPart . getSite ( ) . getSelectionProvider ( ) ; if ( selectionProvider == null ) { newPart = null ; } } if ( newPart == activePart ) return ; if ( activePart != null ) { if ( activeProvider != null ) { activeProvider . removeSelectionChangedListener ( selListener ) ; if ( activeProvider instanceof IPostSelectionProvider ) ( ( IPostSelectionProvider ) activeProvider ) . removePostSelectionChangedListener ( postSelListener ) ; else activeProvider . removeSelectionChangedListener ( postSelListener ) ; activeProvider = null ; } activePart = null ; } activePart = newPart ; if ( newPart != null ) { activeProvider = selectionProvider ; / / Fire an event if there s an active provider activeProvider . addSelectionChangedListener ( selListener ) ; ISelection sel = activeProvider . getSelection ( ) ; fireSelection ( newPart , sel ) ; if ( activeProvider instanceof IPostSelectionProvider ) ( ( IPostSelectionProvider ) activeProvider ) . addPostSelectionChangedListener ( postSelListener ) ; else activeProvider . addSelectionChangedListener ( postSelListener ) ; firePostSelection ( newPart , sel ) ; } else { fireSelection ( null , null ) ; firePostSelection ( null , null ) ; } }	if ( newPart == activePart ) { return ; }
mailbox . addInvite ( getOperationContext ( ) , mFolderId , mInvite , mForce , null ) ; <CTX> public void redo ( ) throws Exception { int mboxId = getMailboxId ( ) ; Mailbox mailbox = Mailbox . getMailboxById ( mboxId ) ; mailbox . addInvite ( getOperationContext ( ) , mFolderId , mInvite , mForce , null ) ; }	mailbox . addInvite ( getOperationContext ( ) , mInvite , mFolderId , mForce , null ) ;
this . observer = observer ; observer . setProtocol ( this ) ; if ( up_handler != null ) up_handler . setObserver ( observer ) ; if ( down_handler != null ) down_handler . setObserver ( observer ) ; } <CTX> public void setObserver ( ProtocolObserver observer ) { this . observer = observer ; observer . setProtocol ( this ) ; if ( up_handler != null ) up_handler . setObserver ( observer ) ; if ( down_handler != null ) down_handler . setObserver ( observer ) ; }	this . observer = observer ; observer . setProtocol ( this ) ; if ( up_handler != null ) { up_handler . setObserver ( observer ) ; } if ( down_handler != null ) { down_handler . setObserver ( observer ) ; } }
Point pt = c . modelToView ( offs + 1 ) . getLocation ( ) ; <CTX> public static final int getPositionBelow ( JTextComponent c , int offset , int x ) throws BadLocationException { int offs = getRowEnd ( c , offset ) ; if ( offs == - 1 ) return - 1 ; / / Effectively calculates the y value of the previous line . Point pt = c . modelToView ( offs + 1 ) . getLocation ( ) ; pt . x = x ; / / Calculate a simple fitting offset . offs = c . viewToModel ( pt ) ; if ( offs == c . getDocument ( ) . getLength ( ) ) return offs ; / / Find out the real x positions of the calculated character and its / / neighbour . int offsX = c . modelToView ( offs ) . getLocation ( ) . x ; int offsXNext = c . modelToView ( offs + 1 ) . getLocation ( ) . x ; / / Chose the one which is nearer to us and return its offset . if ( Math . abs ( offsX - x ) <= Math . abs ( offsXNext - x ) ) return offs ; else return offs + 1 ; }	Point pt = null ; try { pt = c . modelToView ( offs + 1 ) . getLocation ( ) ; } catch ( BadLocationException ble ) { return offset ; }
int relevance = R_DEFAULT ; <CTX> private void findMemberTypes ( char [ ] typeName , ReferenceBinding [ ] memberTypes , ObjectVector typesFound , ReferenceBinding receiverType , SourceTypeBinding invocationType ) { / / Inherited member types which are hidden by subclasses are filtered out / / No visibility checks can be performed without the scope & invocationSite int typeLength = typeName . length ; next : for ( int m = memberTypes . length ; -- m >= 0 ; ) { ReferenceBinding memberType = memberTypes [ m ] ; / / if ( ! wantClasses && memberType . isClass ( ) ) continue next ; / / if ( ! wantInterfaces && memberType . isInterface ( ) ) continue next ; if ( typeLength > memberType . sourceName . length ) continue next ; if ( ! CharOperation . prefixEquals ( typeName , memberType . sourceName , false / * ignore case * / ) ) continue next ; if ( options . checkVisibility && ! memberType . canBeSeenBy ( receiverType , invocationType ) ) continue next ; for ( int i = typesFound . size ; -- i >= 0 ; ) { ReferenceBinding otherType = ( ReferenceBinding ) typesFound . elementAt ( i ) ; if ( memberType == otherType ) continue next ; if ( CharOperation . equals ( memberType . sourceName , otherType . sourceName , true ) ) { if ( memberType . enclosingType ( ) . isSuperclassOf ( otherType . enclosingType ( ) ) ) continue next ; if ( otherType . enclosingType ( ) . isInterface ( ) ) if ( memberType . enclosingType ( ) . implementsInterface ( otherType . enclosingType ( ) , true ) ) continue next ; if ( memberType . enclosingType ( ) . isInterface ( ) ) if ( otherType . enclosingType ( ) . implementsInterface ( memberType . enclosingType ( ) , true ) ) continue next ; } } typesFound . add ( memberType ) ; int relevance = R_DEFAULT ; relevance += computeRelevanceForCaseMatching ( typeName , memberType . sourceName ) ; relevance += computeRelevanceForExpectingType ( memberType ) ; if ( memberType . isClass ( ) ) { relevance += computeRelevanceForClass ( ) ; requestor . acceptClass ( memberType . qualifiedPackageName ( ) , memberType . qualifiedSourceName ( ) , memberType . sourceName ( ) , memberType . modifiers , startPosition - offset , endPosition - offset , relevance ) ; } else { relevance += computeRelevanceForInterface ( ) ; requestor . acceptInterface ( memberType . qualifiedPackageName ( ) , memberType . qualifiedSourceName ( ) , memberType . sourceName ( ) , memberType . modifiers , startPosition - offset , endPosition - offset , relevance ) ; } } }	int relevance = computeBaseRelevance ( ) ; relevance += computeRelevanceForInterestingProposal ( ) ;
if ( ! ( value instanceof Namespace ) ) return null ; Namespace n = ( Namespace ) value ; return uri ( ) . equals ( n . uri ( ) ) ? Boolean . TRUE : Boolean . FALSE ; <CTX> public Boolean equivalentValues ( Object value ) { if ( ! ( value instanceof Namespace ) ) return null ; Namespace n = ( Namespace ) value ; return uri ( ) . equals ( n . uri ( ) ) ? Boolean . TRUE : Boolean . FALSE ; }	if ( ! ( value instanceof Namespace ) ) return Scriptable . NOT_FOUND ; boolean result = equals ( ( Namespace ) value ) ; return result ? Boolean . TRUE : Boolean . FALSE ;
if ( first instanceof MarkerNode ) return ( ( MarkerNode ) first ) . isConcrete ( ) ; <CTX> static boolean isSingleConcreteSelection ( IStructuredSelection selection ) { if ( selection != null && selection . size ( ) == 1 ) { Object first = selection . getFirstElement ( ) ; if ( first instanceof MarkerNode ) return ( ( MarkerNode ) first ) . isConcrete ( ) ; } return false ; }	if ( first instanceof MarkerNode ) { return ( ( MarkerNode ) first ) . isConcrete ( ) ; }
JFacePreferences . getPreferenceStore ( ) . removePropertyChangeListener ( this . colorListener ) ; <CTX> public void dispose ( ) { super . dispose ( ) ; if ( busyCursor != null ) busyCursor . dispose ( ) ; if ( handCursor != null ) handCursor . dispose ( ) ; JFacePreferences . getPreferenceStore ( ) . removePropertyChangeListener ( this . colorListener ) ; }	if ( this . colorListener != null ) { JFacePreferences . getPreferenceStore ( ) . removePropertyChangeListener ( this . colorListener ) ; }
else if ( datum == BEGIN_GROUP_LONG || datum == BEGIN_ATTRIBUTE_LONG ) <CTX> protected int getNextTypeIndex ( int ipos , Object xpos ) { int index = ipos >> >> 1 ; if ( index >= gapStart ) index += gapEnd - gapStart ; if ( index == data . length ) return Sequence . EOF_VALUE ; char datum = data [ index ] ; if ( datum >= BEGIN_GROUP_SHORT && datum <= BEGIN_GROUP_SHORT + BEGIN_GROUP_SHORT_INDEX_MAX ) return datum - BEGIN_GROUP_SHORT ; else if ( datum == BEGIN_GROUP_LONG || datum == BEGIN_ATTRIBUTE_LONG ) return getIntN ( index + 1 ) ; return - 1 ; }	else if ( datum == BEGIN_GROUP_LONG ) { int j = getIntN ( index + 1 ) ; j += j < 0 ? data . length : index ; return getIntN ( j + 1 ) ; } else if ( datum == BEGIN_ATTRIBUTE_LONG )
getViewer ( ) . refresh ( ) ; <CTX> public void runWithEvent ( Event event ) { if ( isChecked ( ) ) { IDEWorkbenchPlugin . getDefault ( ) . getPluginPreferences ( ) . setValue ( IDEInternalPreferences . PROBLEMS_HIERARCHAL_MODE , true ) ; regenerateLayout ( ) ; getViewer ( ) . setSorter ( buildSorter ( ) ) ; getViewer ( ) . refresh ( ) ; } }	( ( MarkerAdapter ) getViewerInput ( ) ) . scheduleMarkerCalculation ( ) ;
if ( linkEnabled ) <CTX> private void setLinkEnable ( boolean enable ) { if ( enable != linkEnabled ) { linkEnabled = enable ; if ( linkEnabled ) setCursor ( handCursor ) ; redraw ( ) ; } }	if ( isLinkEnabled ( ) )
groupingUsed ? groupingSize + 1 : 0 ) ; <CTX> private final String computePattern ( DecimalFormatSymbols syms ) { StringBuffer mainPattern = new StringBuffer ( ) ; / / We have to at least emit a zero for the minimum number of / / digits . Past that we need hash marks up to the grouping / / separator ( and one beyond ) . int total_digits = Math . max ( minimumIntegerDigits , groupingUsed ? groupingSize + 1 : 0 ) ; for ( int i = 0 ; i < total_digits - minimumIntegerDigits ; ++ i ) mainPattern . append ( syms . getDigit ( ) ) ; for ( int i = total_digits - minimumIntegerDigits ; i < total_digits ; ++ i ) mainPattern . append ( syms . getZeroDigit ( ) ) ; / / Inserting the gropuing operator afterwards is easier . if ( groupingUsed ) mainPattern . insert ( mainPattern . length ( ) - groupingSize , syms . getGroupingSeparator ( ) ) ; / / See if we need decimal info . if ( minimumFractionDigits > 0 || maximumFractionDigits > 0 || decimalSeparatorAlwaysShown ) mainPattern . append ( syms . getDecimalSeparator ( ) ) ; for ( int i = 0 ; i < minimumFractionDigits ; ++ i ) mainPattern . append ( syms . getZeroDigit ( ) ) ; for ( int i = minimumFractionDigits ; i < maximumFractionDigits ; ++ i ) mainPattern . append ( syms . getDigit ( ) ) ; if ( useExponentialNotation ) { mainPattern . append ( syms . getExponential ( ) ) ; for ( int i = 0 ; i < minExponentDigits ; ++ i ) mainPattern . append ( syms . getZeroDigit ( ) ) ; if ( minExponentDigits == 0 ) mainPattern . append ( syms . getDigit ( ) ) ; } String main = mainPattern . toString ( ) ; String patChars = patternChars ( syms ) ; mainPattern . setLength ( 0 ) ; quoteFix ( mainPattern , positivePrefix , patChars ) ; mainPattern . append ( main ) ; quoteFix ( mainPattern , positiveSuffix , patChars ) ; if ( negativePrefix != null ) { quoteFix ( mainPattern , negativePrefix , patChars ) ; mainPattern . append ( main ) ; quoteFix ( mainPattern , negativeSuffix , patChars ) ; } return mainPattern . toString ( ) ; }	groupingUsed ? groupingSize + 1 : groupingSize ) ;
if ( name . equals ( getName ( i ) ) ) return i ; <CTX> public int findVarIndex ( String name ) { for ( int i = 0 ; i < getRowCount ( ) ; i ++ ) if ( name . equals ( getStdName ( i ) ) ) return i ; for ( int i = 0 ; i < getRowCount ( ) ; i ++ ) if ( name . equals ( getName ( i ) ) ) return i ; return - 1 ; }	if ( name . equals ( getLabel ( i ) ) ) return i ;
_ block . iter = ruby_iter . iter ; <CTX> private BLOCK PUSH_BLOCK ( NODE v , NODE b , VALUE self ) { BLOCK_block = new BLOCK ( ) ; / /_block . tag = new_blktag ( ) ;_block . var = v ;_block . body = b ;_block . self = self ;_block . frame = rubyFrame ;_block . klass = ruby_class ; / /_block . frame . file = ruby_sourcefile ; / /_block . frame . line = ruby_sourceline ;_block . scope = getRuby ( ) . rubyScope ;_block . prev = ruby_block ;_block . iter = ruby_iter . iter ;_block . vmode = scope_vmode ;_block . flags = BLOCK_D_SCOPE ;_block . dyna_vars = getDynamicVars ( ) ; ruby_block =_block ; return_block ; }	_ block . iter = rubyIter . getIter ( ) ;
VM_Word n = node . toWord ( ) ; return ( n . toInt ( ) / granularity * granularity ) == n . toInt ( ) ; <CTX> public final boolean isNode ( VM_Address node ) { VM_Word n = node . toWord ( ) ; return ( n . toInt ( ) / granularity * granularity ) == n . toInt ( ) ; }	if ( BITS_IN_ADDRESS == 64 ) return ( node . toLong ( ) / granularity * granularity ) == node . toLong ( ) ; else return ( node . toInt ( ) / granularity * granularity ) == node . toInt ( ) ;
return outputExtension ; <CTX> public String getOutputExtension ( String inputExtension ) { / / Examine the list of input extensions ListIterator iter = getInputExtensions ( ) . listIterator ( ) ; while ( iter . hasNext ( ) ) { if ( ( ( String ) iter . next ( ) ) . equals ( inputExtension ) ) { return outputExtension ; } } return null ; }	return outputExtensions ;
if ( first [ i ] != second [ i ] ) <CTX> public static final boolean equals ( char [ ] first , char [ ] second ) { if ( first == second ) return true ; if ( first == null || second == null ) return false ; if ( first . length != second . length ) return false ; for ( int i = first . length ; -- i >= 0 ; ) if ( first [ i ] != second [ i ] ) return false ; return true ; }	if ( ! equals ( first [ i ] , second [ i ] ) )
Object executeQuery ( String sqlQuery , String [ ] parameters , <CTX> Object executeQuery ( String sqlQuery , String [ ] parameters , ResultSetHandler resultSetHandler ) throws DatabaseException ;	Object executeQuery ( String sqlQuery , Object [ ] parameters ,
_ model = new DefaultGlobalModel ( ) ; <CTX> protected void createModel ( ) { / /_model = new DefaultGlobalModel (_originalModel ) ;_model = new DefaultGlobalModel ( ) ; / / Wait until it has connected_model ._interpreterControl . ensureInterpreterConnected ( ) ; }	_ model = new DefaultSingleDisplayModel ( ) ;
assert_pos == 0 && that ._pos == 0 ; <CTX> boolean isAtEndOf ( Cur that ) { assert isNormal ( ) && that . isNormal ( ) ; assert_pos == 0 && that ._pos == 0 ; return_xobj == that ._xobj &&_pos == that ._xobj . posEnd ( ) ; }	assert that ._pos == 0 ;
return getStringProperty ( TextDataItem . VALUE_EXPR_PROP ) ; <CTX> public String getValueExpr ( ) { return getStringProperty ( TextDataItem . VALUE_EXPR_PROP ) ; }	return getStringProperty ( ITextDataItemModel . VALUE_EXPR_PROP ) ;
checkValidationForPreview ( errors , request ) ; <CTX> private void checkValidationForManagePreview ( ActionErrors errors , HttpServletRequest request ) throws ApplicationException { checkValidationForPreview ( errors , request ) ; validateCustomFields ( request , errors ) ; }	if ( getState ( ) . equals ( AccountState . LOANACC_PARTIALAPPLICATION ) || getState ( ) . equals ( AccountState . LOANACC_PENDINGAPPROVAL ) ) checkValidationForPreview ( errors , request ) ;
generateRegExpLiterals ( cx , scope ) ; <CTX> private void generateICodeFromTree ( Context cx , Scriptable scope , Node tree ) { generateNestedFunctions ( cx , scope ) ; generateRegExpLiterals ( cx , scope ) ; int theICodeTop = 0 ; theICodeTop = generateICode ( tree , theICodeTop ) ; itsLabels . fixLabelGotos ( itsData . itsICode ) ; / / add Icode_END only to scripts as function always ends with RETURN if ( itsData . itsFunctionType == 0 ) { theICodeTop = addIcode ( Icode_END , theICodeTop ) ; } / / Add special CATCH to simplify Interpreter . interpret logic / / and workaround lack of goto in Java theICodeTop = addIcode ( Icode_CATCH , theICodeTop ) ; itsData . itsICodeTop = theICodeTop ; if ( itsData . itsICode . length != theICodeTop ) { / / Make itsData . itsICode length exactly theICodeTop to save memory / / and catch bugs with jumps beyound icode as early as possible byte [ ] tmp = new byte [ theICodeTop ] ; System . arraycopy ( itsData . itsICode , 0 , tmp , 0 , theICodeTop ) ; itsData . itsICode = tmp ; } if ( itsStrings . size ( ) == 0 ) { itsData . itsStringTable = null ; } else { itsData . itsStringTable = new String [ itsStrings . size ( ) ] ; ObjToIntMap . Iterator iter = itsStrings . newIterator ( ) ; for ( iter . start ( ) ; ! iter . done ( ) ; iter . next ( ) ) { String str = ( String ) iter . getKey ( ) ; int index = iter . getValue ( ) ; if ( itsData . itsStringTable [ index ] != null ) Context . codeBug ( ) ; itsData . itsStringTable [ index ] = str ; } } if ( itsDoubleTableTop == 0 ) { itsData . itsDoubleTable = null ; } else if ( itsData . itsDoubleTable . length != itsDoubleTableTop ) { double [ ] tmp = new double [ itsDoubleTableTop ] ; System . arraycopy ( itsData . itsDoubleTable , 0 , tmp , 0 , itsDoubleTableTop ) ; itsData . itsDoubleTable = tmp ; } if ( itsExceptionTableTop != 0 && itsData . itsExceptionTable . length != itsExceptionTableTop ) { int [ ] tmp = new int [ itsExceptionTableTop ] ; System . arraycopy ( itsData . itsExceptionTable , 0 , tmp , 0 , itsExceptionTableTop ) ; itsData . itsExceptionTable = tmp ; } itsData . itsMaxVars = scriptOrFn . getParamAndVarCount ( ) ; / / itsMaxFrameArray : interpret method needs this amount for its / / stack and sDbl arrays itsData . itsMaxFrameArray = itsData . itsMaxVars + itsData . itsMaxLocals + itsData . itsMaxStack ; itsData . argNames = scriptOrFn . getParamAndVarNames ( ) ; itsData . argCount = scriptOrFn . getParamCount ( ) ; itsData . encodedSourceStart = scriptOrFn . getEncodedSourceStart ( ) ; itsData . encodedSourceEnd = scriptOrFn . getEncodedSourceEnd ( ) ; if ( Token . printICode ) dumpICode ( itsData ) ; }	generateRegExpLiterals ( cx ) ;
super ( createTables ( stream , null ) ) ; <CTX> public FlatXmlDataSet ( InputStream stream ) throws IOException , DataSetException { super ( createTables ( stream , null ) ) ; }	try { Document document = new Document ( new FileInputStream ( xmlFile ) ) ; IDataSet metaDataSet = null ; String dtdUri = getDocTypeUri ( document ) ; if ( dtdUri != null ) { File dtdFile = new File ( dtdUri ) ; if ( ! dtdFile . isAbsolute ( ) ) { dtdFile = new File ( xmlFile . getParent ( ) , dtdUri ) ; } metaDataSet = new FlatXmlDocType ( new FileInputStream ( dtdFile ) ) ; }_tables = getTables ( document , metaDataSet ) ; } catch ( ParseException e ) { throw new DataSetException ( e ) ; }
this . listeners . clear ( ) ; <CTX> private void shutdown ( ) { this . listeners . clear ( ) ; Platform . getJobManager ( ) . setProgressProvider ( null ) ; Platform . getJobManager ( ) . removeJobChangeListener ( this . changeListener ) ; }	synchronized ( listenersKey ) { this . listeners = new IJobProgressManagerListener [ 0 ] ; }
return new PhysicalRegisterEnumeration ( FIRST_CONDITION + THREAD_SWITCH_REGISTER , FIRST_CONDITION + THREAD_SWITCH_REGISTER ) ; <CTX> Enumeration enumerateNonvolatileConditionRegisters ( ) { return new PhysicalRegisterEnumeration ( FIRST_CONDITION + THREAD_SWITCH_REGISTER , FIRST_CONDITION + THREAD_SWITCH_REGISTER ) ; }	return new PhysicalRegisterEnumeration ( 0 , - 1 ) ;
synchronized ( UpdateManager . this ) { running = false ; scriptingEnvironment . interrupt ( ) ; updateRunnableQueue . getThread ( ) . interrupt ( ) ; } <CTX> public synchronized void interrupt ( ) { if ( updateRunnableQueue . getThread ( ) != null ) { / / Preempt to cancel the pending tasks updateRunnableQueue . preemptLater ( new Runnable ( ) { public void run ( ) { if ( started ) { dispatchSVGUnLoadEvent ( ) ; } else { synchronized ( UpdateManager . this ) { running = false ; scriptingEnvironment . interrupt ( ) ; updateRunnableQueue . getThread ( ) . interrupt ( ) ; } } } } ) ; resume ( ) ; } }	running = false ; scriptingEnvironment . interrupt ( ) ; updateRunnableQueue . getThread ( ) . interrupt ( ) ;
boolean extractNamespaceFromParent ) throws SOAPProcessingException { super ( parent , localName , extractNamespaceFromParent ) ; <CTX> public SOAPFaultRoleImpl ( SOAPFault parent , String localName , boolean extractNamespaceFromParent ) throws SOAPProcessingException { super ( parent , localName , extractNamespaceFromParent ) ; }	boolean extractNamespaceFromParent , SOAPFactory factory ) throws SOAPProcessingException { super ( parent , localName , extractNamespaceFromParent , factory ) ;
Atom a = new Atom ( ) ; <CTX> public void testAtom ( ) { Atom a = new Atom ( ) ; assertNotNull ( a ) ; }	Atom a = builder . newAtom ( ) ;
synchronized ( listenerKey ) { Iterator iterator = listeners . iterator ( ) ; while ( iterator . hasNext ( ) ) { IJobProgressManagerListener listener = ( IJobProgressManagerListener ) iterator . next ( ) ; listener . removeGroup ( group ) ; } <CTX> public void removeGroup ( GroupInfo group ) { synchronized ( listenerKey ) { Iterator iterator = listeners . iterator ( ) ; while ( iterator . hasNext ( ) ) { IJobProgressManagerListener listener = ( IJobProgressManagerListener ) iterator . next ( ) ; listener . removeGroup ( group ) ; } } }	Object [ ] listenerArray = listeners . toArray ( ) ; for ( int i = 0 ; i < listenerArray . length ; i ++ ) { IJobProgressManagerListener listener = ( IJobProgressManagerListener ) listenerArray [ i ] ; listener . removeGroup ( group ) ;
return 0 ; <CTX> public int getPreferredHeight ( ) throws NotImplementedException { return 0 ; / / TODO }	int height = 0 ; int n = getRowCount ( ) ; Rectangle r = new Rectangle ( ) ; for ( int i = 0 ; i < n ; i ++ ) { TreePath path = getPathForRow ( i ) ; height += getBounds ( path , r ) . height ; } return height ;
Iterator i = clientsByName . values ( ) . iterator ( ) ; for ( ; i . hasNext ( ) ; ) { FCPClient client = ( FCPClient ) i . next ( ) ; client . finishStart ( ) ; <CTX> public void finishStart ( ) { this . globalClient . finishStart ( ) ; Iterator i = clientsByName . values ( ) . iterator ( ) ; for ( ; i . hasNext ( ) ; ) { FCPClient client = ( FCPClient ) i . next ( ) ; client . finishStart ( ) ; } if ( enablePersistentDownloads ) startPersister ( ) ; canStartPersister = true ; }	FCPClient [ ] clients ; synchronized ( this ) { clients = ( FCPClient [ ] ) clientsByName . values ( ) . toArray ( new FCPClient [ clientsByName . size ( ) ] ) ; } for ( int i = 0 ; i < clients . length ; i ++ ) { clients [ i ] . finishStart ( ) ;
return defineModuleUnder ( name , getClasses ( ) . getObjectClass ( ) ) ; <CTX> public RubyModule defineModule ( String name ) { return defineModuleUnder ( name , getClasses ( ) . getObjectClass ( ) ) ; }	return defineModuleUnder ( name , objectClass ) ;
Address firstFreePtr = null ; <CTX> protected final void defragment ( ) throws UninterruptiblePragma { final Word size = Word . fromIntZeroExtend ( getSize ( ) ) ; final Word headerSize = Word . fromIntZeroExtend ( this . headerSize ) ; Word offset = headerSize ; final Offset sizeOffset = this . sizeOffset ; final Offset tibOffset = this . tibOffset ; lock ( ) ; try { Address firstFreePtr = null ; while ( offset . LT ( size ) ) { final Address ptr = start . add ( offset ) ; final Word objSize = ptr . loadWord ( sizeOffset ) ; final Word nextOffset = offset . add ( objSize ) . add ( headerSize ) ; final Object vmt = ptr . loadObjectReference ( tibOffset ) ; if ( ( firstFreePtr == null ) && ( vmt == FREE ) ) { firstFreePtr = ptr ; } if ( ( vmt == FREE ) && ( nextOffset . LT ( size ) ) ) { final Object nextVmt ; final Address nextObjectPtr = start . add ( nextOffset ) ; nextVmt = nextObjectPtr . loadObjectReference ( tibOffset ) ; if ( nextVmt == FREE ) { / / Combine two free spaces Word nextObjSize = nextObjectPtr . loadWord ( sizeOffset ) ; Word newObjSize = objSize . add ( headerSize ) . add ( nextObjSize ) ; ptr . store ( newObjSize , sizeOffset ) ; / / Do not increment offset here , because there may be / / another next free object , which we will combine / / in the next loop . } else { offset = nextOffset ; } } else { offset = nextOffset ; } } / / Set the address of the next free block , to the first free block this . nextFreePtr = firstFreePtr ; } finally { unlock ( ) ; } }	Address firstFreePtr = Address . zero ( ) ;
ulocs_= ulocCol == null ? null : getUniqueParts ( locations ) ; <CTX> CatMapping ( String seqCol , String locCol , String ulocCol , String [ ] locations ) { seqCol_= seqCol ; locCol_= locCol ; ulocCol_= ulocCol ; locations_= locations ; ulocs_= ulocCol == null ? null : getUniqueParts ( locations ) ; }	trimmer_= ulocCol == null ? null : new Trimmer ( locations ) ;
if ( validationStatus == IMessageProvider . ERROR ) return false ; <CTX> private boolean validateVariableName ( ) { boolean allowFinish = false ; / / if the current validationStatus is ERROR , no additional validation applies if ( validationStatus == IMessageProvider . ERROR ) return false ; / / assumes everything will be ok String message = standardMessage ; int newValidationStatus = IMessageProvider . NONE ; if ( variableName . length ( ) == 0 ) { / / the variable name is empty if ( nameEntered ) { / / a name was entered before and is now empty newValidationStatus = IMessageProvider . ERROR ; message = IDEWorkbenchMessages . PathVariableDialog_variableNameEmptyMessage ; } } else { IStatus status = pathVariableManager . validateName ( variableName ) ; if ( ! status . isOK ( ) ) { / / the variable name is not valid newValidationStatus = IMessageProvider . ERROR ; message = status . getMessage ( ) ; } else if ( namesInUse . contains ( variableName ) && ! variableName . equals ( originalName ) ) { / / the variable name is already in use message = IDEWorkbenchMessages . PathVariableDialog_variableAlreadyExistsMessage ; newValidationStatus = IMessageProvider . ERROR ; } else { allowFinish = true ; } } / / overwrite the current validation status / message only if everything is ok ( clearing them ) / / or if we have a more serious problem than the current one if ( validationStatus == IMessageProvider . NONE || newValidationStatus == IMessageProvider . ERROR ) { validationStatus = newValidationStatus ; validationMessage = message ; } / / only set the message here if it is not going to be set in / / validateVariableValue to avoid flashing . if ( allowFinish == false ) setMessage ( validationMessage , validationStatus ) ; return allowFinish ; }	if ( validationStatus == IMessageProvider . ERROR ) { return false ; }
replaceRange ( text , start , end ) ; <CTX> public void replaceText ( String text , int start , int end ) { replaceRange ( text , start , end ) ; }	TextAreaPeer peer = ( TextAreaPeer ) getPeer ( ) ; if ( peer == null ) return ; peer . replaceRange ( str , start , end ) ;
sourceVertex . equals ( e . getSource ( ) ) && targetVertex . equals ( e . getTarget ( ) ) ; <CTX> public Set < E > getAllEdges ( V sourceVertex , V targetVertex ) { Set < E > edges = null ; if ( containsVertex ( sourceVertex ) && containsVertex ( targetVertex ) ) { edges = new ArrayUnenforcedSet < E > ( ) ; Iterator < E > iter = getEdgeContainer ( sourceVertex ) . m_vertexEdges . iterator ( ) ; while ( iter . hasNext ( ) ) { E e = iter . next ( ) ; boolean equalStraight = sourceVertex . equals ( e . getSource ( ) ) && targetVertex . equals ( e . getTarget ( ) ) ; boolean equalInverted = sourceVertex . equals ( e . getTarget ( ) ) && targetVertex . equals ( e . getSource ( ) ) ; if ( equalStraight || equalInverted ) { edges . add ( e ) ; } } } return edges ; }	sourceVertex . equals ( getEdgeSource ( e ) ) && targetVertex . equals ( getEdgeTarget ( e ) ) ;
if ( tail == head ) return null ; <CTX> public synchronized Semaphore remove ( ) { if ( tail == head ) return null ; Semaphore result = elements [ head ] ; elements [ head ] = null ; head = increment ( head ) ; / / reset the queue if it is empty and it has grown if ( tail == head && elements . length > BASE_SIZE ) { elements = new Semaphore [ BASE_SIZE ] ; tail = head = 0 ; } return result ; }	if ( tail == head ) { return null ; }
saveProjectItemActionPerformed ( evt ) ; } <CTX> public void actionPerformed ( java . awt . event . ActionEvent evt ) { saveProjectItemActionPerformed ( evt ) ; }	classpathDownButtonActionPerformed ( evt ) ; }
resourceKey ( obj , Module . TITLE_ID_PROP , Module . TITLE_PROP ) ; property ( obj , Module . COMMENTS_PROP ) ; <CTX> public void visitModule ( Module obj ) { if ( markLineNumber ) obj . initLineNoMap ( ) ; writer . attribute ( DesignSchemaConstants . XMLNS_ATTRIB , DEFAULT_NAME_SPACE ) ; writer . attribute ( DesignSchemaConstants . VERSION_ATTRIB , DesignSchemaConstants . REPORT_VERSION ) ; writer . attribute ( DesignSchemaConstants . ID_ATTRIB , new Long ( obj . getID ( ) ) . toString ( ) ) ; property ( obj , Module . AUTHOR_PROP ) ; property ( obj , Module . HELP_GUIDE_PROP ) ; property ( obj , Module . CREATED_BY_PROP ) ; property ( obj , Module . UNITS_PROP ) ; property ( obj , Module . BASE_PROP ) ; property ( obj , Module . INCLUDE_RESOURCE_PROP ) ; resourceKey ( obj , Module . TITLE_ID_PROP , Module . TITLE_PROP ) ; property ( obj , Module . COMMENTS_PROP ) ; resourceKey ( obj , Module . DESCRIPTION_ID_PROP , Module . DESCRIPTION_PROP ) ; writeUserPropertyDefns ( obj ) ; writeUserPropertyValues ( obj ) ; / / write property bindings writeStructureList ( obj , Module . PROPERTY_BINDINGS_PROP ) ; / / write script libs writeStructureList ( obj , Module . SCRIPTLIBS_PROP ) ; }	resourceKey ( obj , IModuleModel . TITLE_ID_PROP , IModuleModel . TITLE_PROP ) ; property ( obj , IDesignElementModel . COMMENTS_PROP ) ;
Class [ ] dependencyTypes = getDependencies ( mutablePicoContainer ) ; ComponentAdapter [ ] adapterDependencies = new ComponentAdapter [ dependencyTypes . length ] ; <CTX> public Object getComponentInstance ( MutablePicoContainer mutablePicoContainer ) throws PicoInitializationException , PicoIntrospectionException , AssignabilityRegistrationException , NotConcreteRegistrationException { if ( componentInstance == null ) { Class [ ] dependencyTypes = getDependencies ( mutablePicoContainer ) ; ComponentAdapter [ ] adapterDependencies = new ComponentAdapter [ dependencyTypes . length ] ; Parameter [ ] componentParameters = getParameters ( mutablePicoContainer ) ; for ( int i = 0 ; i < adapterDependencies . length ; i ++ ) { adapterDependencies [ i ] = componentParameters [ i ] . resolveAdapter ( mutablePicoContainer ) ; } componentInstance = createComponent ( adapterDependencies , mutablePicoContainer ) ; mutablePicoContainer . addOrderedComponentAdapter ( this ) ; } return componentInstance ; }	final Class [ ] dependencyTypes = getDependencies ( mutablePicoContainer ) ; final ComponentAdapter [ ] adapterDependencies = new ComponentAdapter [ dependencyTypes . length ] ;
Vector < OptionListener < T >> v = listeners . get ( c ) ; if ( v == null ) return ; if ( v . removeElement ( l ) && v . size ( ) == 0 ) { listeners . remove ( c ) ; } <CTX> void removeListener ( Configuration c , OptionListener < T > l ) { Vector < OptionListener < T >> v = listeners . get ( c ) ; if ( v == null ) return ; if ( v . removeElement ( l ) && v . size ( ) == 0 ) { listeners . remove ( c ) ; } }	Vector < OptionListener < T >> v = listeners . get ( c ) ; if ( v == null ) return ; if ( v . removeElement ( l ) && v . size ( ) == 0 ) { listeners . remove ( c ) ;
menuItemParentageChanged . setVisible ( false ) ; <CTX> public void show ( Component comp , int x , int y , DeployTreePanel parent ) { tempComp = comp ; tempX = x ; tempY = y ; if ( getNode ( ) instanceof Prim ) { menuItemDetach . setVisible ( true ) ; menuItemTerminateNormal . setVisible ( true ) ; menuItemTerminateAbnormal . setVisible ( true ) ; menuItemDTerminate . setVisible ( true ) ; menuItemDumpContext . setVisible ( true ) ; menuItemParentageChanged . setVisible ( true ) ; } else if ( getNode ( ) instanceof ComponentDescription ) { menuItemDetach . setVisible ( false ) ; menuItemTerminateNormal . setVisible ( false ) ; menuItemTerminateAbnormal . setVisible ( false ) ; menuItemDTerminate . setVisible ( false ) ; menuItemDumpContext . setVisible ( true ) ; menuItemParentageChanged . setVisible ( false ) ; } popupTree . show ( comp , x , y ) ; this . parent = parent ; }	menuItemParentageChanged . setVisible ( true ) ;
Context cx = Context . getCurrentContext ( ) ; if ( cx == null ) { cx = new Context ( ) ; cx . enter ( ) ; try { return ( object . hasProperty ( methodId ) ? object . callMethod ( methodId , args ) : Context . getUndefinedValue ( ) ) ; } finally { cx . exit ( ) ; } } else { return ( object . hasProperty ( methodId ) ? object . callMethod ( methodId , args ) : Context . getUndefinedValue ( ) ) ; } <CTX> public static Object callMethod ( FlattenedObject object , Object methodId , Object [ ] args ) { try { / / old way , bind a Context dynamically , unbind if it wasn t there before . Context cx = Context . getCurrentContext ( ) ; if ( cx == null ) { cx = new Context ( ) ; cx . enter ( ) ; try { return ( object . hasProperty ( methodId ) ? object . callMethod ( methodId , args ) : Context . getUndefinedValue ( ) ) ; } finally { cx . exit ( ) ; } } else { return ( object . hasProperty ( methodId ) ? object . callMethod ( methodId , args ) : Context . getUndefinedValue ( ) ) ; } } catch ( Exception ex ) { ex . printStackTrace ( System . err ) ; throw new Error ( ex . getMessage ( ) ) ; } }	return ( object . hasProperty ( methodId ) ? object . callMethod ( methodId , args ) : Context . getUndefinedValue ( ) ) ;
if ( condition != null ) { this . hasCondition = true ; this . condition = condition ; } else if ( rto != null ) { this . hasRelatedTo = true ; this . rto = rto ; } <CTX> public SelectExpression ( int multiplicity , metamodel . Class theClass , Expression condition , RelatedToOperation rto ) { super ( ) ; this . theClass = theClass ; this . multiplicity = multiplicity ; if ( condition != null ) { this . hasCondition = true ; this . condition = condition ; } else if ( rto != null ) { this . hasRelatedTo = true ; this . rto = rto ; } }	this . condition = condition ;
XmlSchema thisSchema = schemaColl . read ( el ) ; xmlSchemaTypeVector . add ( thisSchema ) ; <CTX> public void engage ( ) { / / test the databinding type . If not just fall through if ( configuration . getDatabindingType ( ) != XSLTConstants . DataBindingTypes . ADB ) { return ; } try { WSDLTypes typesList = configuration . getWom ( ) . getTypes ( ) ; if ( typesList == null ) { / / there are no types to be code generated / / However if the type mapper is left empty it will be a problem for the other / / processes . Hence the default type mapper is set to the configuration this . configuration . setTypeMapper ( new DefaultTypeMapper ( ) ) ; return ; } List typesArray = typesList . getExtensibilityElements ( ) ; WSDLExtensibilityElement extensiblityElt = null ; Vector xmlSchemaTypeVector = new Vector ( ) ; for ( int i = 0 ; i < typesArray . size ( ) ; i ++ ) { extensiblityElt = ( WSDLExtensibilityElement ) typesArray . get ( i ) ; XmlSchemaCollection schemaColl = new XmlSchemaCollection ( ) ; / / add the namespace map here . it is absolutely needed Map nsMap = configuration . getWom ( ) . getNamespaces ( ) ; Iterator keys = nsMap . keySet ( ) . iterator ( ) ; String key ; while ( keys . hasNext ( ) ) { key = ( String ) keys . next ( ) ; schemaColl . mapNamespace ( key , ( String ) nsMap . get ( key ) ) ; } Schema schema ; if ( ExtensionConstants . SCHEMA . equals ( extensiblityElt . getType ( ) ) ) { schema = ( Schema ) extensiblityElt ; Stack importedSchemaStack = schema . getImportedSchemaStack ( ) ; / / compile these schemas while ( ! importedSchemaStack . isEmpty ( ) ) { Element el = ( Element ) importedSchemaStack . pop ( ) ; XmlSchema thisSchema = schemaColl . read ( el ) ; xmlSchemaTypeVector . add ( thisSchema ) ; } } } / / call the schema compiler CompilerOptions options = new CompilerOptions ( ) . setOutputLocation ( configuration . getOutputLocation ( ) ) ; SchemaCompiler schemaCompiler = new SchemaCompiler ( options ) ; schemaCompiler . compile ( xmlSchemaTypeVector ) ; / / create the type mapper JavaTypeMapper mapper = new JavaTypeMapper ( ) ; / / get the processed element map and transfer it to the type mapper Map processedMap = schemaCompiler . getProcessedElementMap ( ) ; Iterator processedkeys = processedMap . keySet ( ) . iterator ( ) ; QName qNameKey ; while ( processedkeys . hasNext ( ) ) { qNameKey = ( QName ) processedkeys . next ( ) ; mapper . addTypeMapping ( qNameKey , processedMap . get ( qNameKey ) ) ; } / / set the type mapper to the config configuration . setTypeMapper ( mapper ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }	if ( el != null ) { XmlSchema thisSchema = schemaColl . read ( el ) ; xmlSchemaTypeVector . add ( thisSchema ) ; }
getCDITarget ( ) . setLocationBreakpoint ( ICDIBreakpoint . TEMPORARY , location , null , null , false ) ; <CTX> public void setInternalTemporaryBreakpoint ( ICDILocation location ) throws DebugException { try { getCDITarget ( ) . setLocationBreakpoint ( ICDIBreakpoint . TEMPORARY , location , null , null , false ) ; } catch ( CDIException e ) { targetRequestFailed ( e . getMessage ( ) , null ) ; } }	getCDITarget ( ) . setLocationBreakpoint ( ICDIBreakpoint . TEMPORARY , location , null , false ) ;
if ( first_freeblock == OUT_OF_BLOCKS ) return 0 ; <CTX> freeBlocks ( ) { sysLockBlock . lock ( ) ; if ( first_freeblock == OUT_OF_BLOCKS ) return 0 ; VM_BlockControl the_block = VM_Magic . addressAsBlockControl ( blocks [ first_freeblock ] ) ; int i = 1 ; int next = the_block . nextblock ; while ( next != OUT_OF_BLOCKS ) { the_block = VM_Magic . addressAsBlockControl ( blocks [ next ] ) ; i ++ ; next = the_block . nextblock ; } sysLockBlock . unlock ( ) ; return i ; }	if ( first_freeblock == OUT_OF_BLOCKS ) { sysLockBlock . unlock ( ) ; return 0 ; }
if ( ! ( newSelection instanceof IStructuredSelection ) ) return ; <CTX> public void setSelection ( ISelection newSelection , boolean dispatch ) { if ( ! ( newSelection instanceof IStructuredSelection ) ) return ; List editparts = ( ( IStructuredSelection ) newSelection ) . toList ( ) ; List selection = primGetSelectedEditParts ( ) ; setFocus ( null ) ; for ( int i = 0 ; i < selection . size ( ) ; i ++ ) ( ( EditPart ) selection . get ( i ) ) . setSelected ( EditPart . SELECTED_NONE ) ; selection . clear ( ) ; editparts = flitterEditpart ( editparts ) ; / / for create handle selection . addAll ( editparts ) ; for ( int i = 0 ; i < editparts . size ( ) ; i ++ ) { EditPart part = ( EditPart ) editparts . get ( i ) ; if ( i == editparts . size ( ) - 1 ) part . setSelected ( EditPart . SELECTED_PRIMARY ) ; else part . setSelected ( EditPart . SELECTED ) ; } if ( dispatch ) { fireSelectionChanged ( ) ; } }	setSelection ( newSelection , true ) ;
rowData , context ) ; <CTX> protected void accessRow ( RowDesign row , IContentEmitter emitter , IResultIterator rsIterator ) { IRowData rowData = null ; if ( context . isInFactory ( ) ) { rowData = new RowData ( rsIterator , getValueExpressions ( row ) ) ; } if ( rowClosed ) { IRowContent rowContent = report . createRowContent ( ) ; rowContent . setRowID ( rowId ++ ) ; assert ( rowContent instanceof RowContent ) ; IContent parent = context . getContent ( ) ; context . pushContent ( rowContent ) ; initializeContent ( parent , row , rowContent ) ; processStyle ( row , rowContent ) ; processVisibility ( row , rowContent ) ; processBookmark ( row , rowContent ) ; processAction ( row , rowContent ) ; processRowType ( row , rowContent ) ; if ( needPageBreak ) { rowContent . getStyle ( ) . setProperty ( IStyle . STYLE_PAGE_BREAK_BEFORE , IStyle . SOFT_VALUE ) ; needPageBreak = false ; } if ( context . isInFactory ( ) ) { RowScriptExecutor . handleOnCreate ( ( RowContent ) rowContent , rowData , context ) ; } startTOCEntry ( rowContent ) ; if ( emitter != null ) { emitter . startRow ( rowContent ) ; } rowClosed = false ; } for ( int j = 0 ; j < row . getCellCount ( ) ; j ++ ) { CellDesign cell = row . getCell ( j ) ; if ( cell != null ) { ICellContent cellContent = report . createCellContent ( ) ; assert ( cellContent instanceof CellContent ) ; IContent parent = context . getContent ( ) ; context . pushContent ( cellContent ) ; initializeContent ( parent , cell , cellContent ) ; cellContent . setColumn ( cell . getColumn ( ) ) ; cellContent . setColSpan ( cell . getColSpan ( ) ) ; cellContent . setRowSpan ( cell . getRowSpan ( ) ) ; processStyle ( cell , cellContent ) ; processVisibility ( cell , cellContent ) ; processBookmark ( cell , cellContent ) ; processAction ( cell , cellContent ) ; if ( context . isInFactory ( ) ) { CellScriptExecutor . handleOnCreate ( ( CellContent ) cellContent , rowData , context , false ) ; } startTOCEntry ( cellContent ) ; if ( emitter != null ) { emitter . startCell ( cellContent ) ; } for ( int m = 0 ; m < cell . getContentCount ( ) ; m ++ ) { ReportItemDesign item = cell . getContent ( m ) ; if ( item != null ) { if ( layoutEmitter != null ) { item . accept ( this . visitor , layoutEmitter . getCellEmitter ( ) ) ; } else { item . accept ( this . visitor , emitter ) ; } } } if ( emitter != null ) { emitter . endCell ( cellContent ) ; } finishTOCEntry ( ) ; context . popContent ( ) ; } } boolean closeRow = true ; if ( closeRow ) { emitter . endRow ( ( IRowContent ) context . getContent ( ) ) ; finishTOCEntry ( ) ; context . popContent ( ) ; rowClosed = true ; } }	context ) ;
isSchemaSupported = metaDataProvider . isSchemaSupported ( ) ; <CTX> protected void resetJdbcInfo ( OdaDataSourceHandle curDataSourceHandle ) { if ( metaDataProvider != null ) { metaDataProvider . closeConnection ( ) ; metaDataProvider = new JdbcMetaDataProvider ( null ) ; connectMetadataProvider ( metaDataProvider , curDataSourceHandle ) ; / / Clear the Table list and the schema List tableList = null ; schemaList = null ; } try { isSchemaSupported = metaDataProvider . isSchemaSupported ( ) ; } catch ( Exception e ) { ExceptionHandler . handle ( e ) ; } }	if ( jdbcConnection != null ) { isSchemaSupported = metaDataProvider . isSchemaSupported ( ) ; }
getSelectionMapper ( ) . lock ( ) ; <CTX> public void contentsChanged ( ListDataEvent e ) { getSelectionMapper ( ) . lock ( ) ; fireContentsChanged ( this , - 1 , - 1 ) ; updateSelection ( e ) ; getFilters ( ) . flush ( ) ; }	boolean wasEnabled = getSelectionMapper ( ) . isEnabled ( ) ; getSelectionMapper ( ) . setEnabled ( false ) ; try {
return declarator . getName ( ) . toString ( ) ; <CTX> public String getName ( ) { return declarator . getName ( ) . toString ( ) ; }	if ( declarations != null ) { return declarations [ 0 ] . toString ( ) ; } IASTName name = definition ; if ( name instanceof ICPPASTQualifiedName ) { IASTName [ ] ns = ( ( ICPPASTQualifiedName ) name ) . getNames ( ) ; name = ns [ ns . length - 1 ] ; } return name . toString ( ) ;
externalAnnotator . annotate ( myFile , myAnnotationHolder ) ; <CTX> public void doCollectInformation ( ProgressIndicator progress ) { if ( ! HighlightUtil . isRootInspected ( myFile ) ) return ; final ExternalAnnotator externalAnnotator = myFile . getLanguage ( ) . getExternalAnnotator ( ) ; if ( externalAnnotator != null ) { final HighlightInfo [ ] errors = DaemonCodeAnalyzerImpl . getHighlights ( myDocument , HighlightSeverity . ERROR , myProject ) ; if ( errors . length > 0 ) { return ; } externalAnnotator . annotate ( myFile , myAnnotationHolder ) ; } }	for ( ExternalAnnotator externalAnnotator : externalAnnotators ) { externalAnnotator . annotate ( myFile , myAnnotationHolder ) ; }
if ( forceView || frustrumIntersects != Camera . OUTSIDE_FRUSTUM ) { <CTX> public void onDraw ( Renderer r ) { if ( forceCull ) { return ; } Camera camera = r . getCamera ( ) ; int state = camera . getPlaneState ( ) ; / / check to see if we can cull this node frustrumIntersects = ( parent != null ? parent . frustrumIntersects : Camera . INTERSECTS_FRUSTUM ) ; if ( ! forceView && frustrumIntersects == Camera . INTERSECTS_FRUSTUM ) { frustrumIntersects = camera . contains ( worldBound ) ; } if ( forceView || frustrumIntersects != Camera . OUTSIDE_FRUSTUM ) { draw ( r ) ; } camera . setPlaneState ( state ) ; }	if ( cullMode == CULL_NEVER || frustrumIntersects != Camera . OUTSIDE_FRUSTUM ) {
if ( methodId == Id_constructor ) return 1 ; if ( methodId == Id_toString ) return 0 ; <CTX> public int methodArity ( int methodId ) { if ( methodId == Id_constructor ) return 1 ; if ( methodId == Id_toString ) return 0 ; return super . methodArity ( methodId ) ; }	if ( prototypeFlag ) { if ( methodId == Id_constructor ) return 1 ; if ( methodId == Id_toString ) return 0 ; }
/ * package * / IViewPart getPreviousActiveFastView ( ) { <CTX> / * package * / IViewPart getPreviousActiveFastView ( ) { return previousActiveFastView ; }	/ * package * / IViewReference getPreviousActiveFastView ( ) {
info . getFillColor ( ) , info . getOutlineColor ( ) , info . shouldMaintainAspectRatio ( ) , true ) ; <CTX> public RenderedImage drawRenderedImage ( RenderedImage srcImage , int x , int y , int width , int height ) { int nNewWidth = ( int ) Math . round ( width * getPrintScale ( ) ) ; int nNewHeight = ( int ) Math . round ( height * getPrintScale ( ) ) ; RenderInfo info = srcImage . getRenderInfo ( ) ; info . setValues ( nNewWidth , nNewHeight , info . getFillColor ( ) , info . getOutlineColor ( ) , info . shouldMaintainAspectRatio ( ) , true ) ; RenderedImage img = srcImage . getNewRenderedImage ( info ) ; Image swtImg = img . getSWTImage ( ) ; drawImage ( swtImg , x , y + height - swtImg . getBounds ( ) . height ) ; return img ; }	info . shouldMaintainAspectRatio ( ) , true , info . getBackgroundColor ( ) , info . getForegroundColor ( ) ) ;
int rep = id . getReputation ( ) ; <CTX> public void testCheckVote ( ) { Poll p = testpolls [ 0 ] ; LcapMessage msg = p . getMessage ( ) ; LcapIdentity id = msg . getOriginID ( ) ; int rep = id . getReputation ( ) ; / / good vote check try { p . checkVote ( msg . getHashed ( ) , new Vote ( msg , false ) ) ; } catch ( IllegalStateException ex ) { / / unitialized comm } assertEquals ( 1 , p . m_tally . numAgree ) ; assertEquals ( rep , p . m_tally . wtAgree ) ; assertTrue ( rep <= id . getReputation ( ) ) ; rep = id . getReputation ( ) ; / / bad vote check try { p . checkVote ( pollmanager . generateRandomBytes ( ) , new Vote ( msg , false ) ) ; } catch ( IllegalStateException ex ) { / / unitialized comm } assertEquals ( 1 , p . m_tally . numDisagree ) ; assertEquals ( rep , p . m_tally . wtDisagree ) ; assertTrue ( rep >= id . getReputation ( ) ) ; }	int rep = p . m_tally . wtAgree + id . getReputation ( ) ;
else return super . addType ( parent , type ) ; <CTX> public PDOMNode addType ( PDOMNode parent , IType type ) throws CoreException { if ( type instanceof ICPPBasicType ) return new PDOMCPPBasicType ( pdom , parent , ( ICPPBasicType ) type ) ; else return super . addType ( parent , type ) ; }	} else if ( type instanceof ICPPClassType ) { FindEquivalentBinding feb = new FindEquivalentBinding ( this , ( ICPPClassType ) type ) ; getIndex ( ) . accept ( feb ) ; if ( feb . getResult ( ) != null ) { return feb . getResult ( ) ; } } return super . addType ( parent , type ) ;
FunctionImpl ( Signet signet , Category category , String id , String name , String helpText , Status status ) <CTX> FunctionImpl ( Signet signet , Category category , String id , String name , String helpText , Status status ) { super ( signet , id , name , status ) ; this . subsystem = category . getSubsystem ( ) ; this . subsystemId = this . subsystem . getId ( ) ; this . category = category ; this . helpText = helpText ; this . permissions = new HashSet ( ) ; }	public FunctionImpl ( )
RepositoryAttachment attachment , Proxy proxySettings , String destinationPath ) throws CoreException { <CTX> public final boolean retrieveContext ( TaskRepository repository , AbstractRepositoryTask task , RepositoryAttachment attachment , Proxy proxySettings , String destinationPath ) throws CoreException { IAttachmentHandler attachmentHandler = getAttachmentHandler ( ) ; if ( attachmentHandler == null ) { return false ; } File destinationContextFile = ContextCorePlugin . getContextManager ( ) . getFileForContext ( task . getHandleIdentifier ( ) ) ; / / TODO : add functionality for not overwriting previous context if ( destinationContextFile . exists ( ) ) { if ( ! destinationContextFile . delete ( ) ) { return false ; } } attachmentHandler . downloadAttachment ( repository , AbstractRepositoryTask . getTaskId ( task . getHandleIdentifier ( ) ) , attachment , destinationContextFile ) ; return true ; }	RepositoryAttachment attachment , String destinationPath ) throws CoreException {
if ( delta == null ) return ; <CTX> public void resourceChanged ( final IResourceChangeEvent event ) { / / gather all marker changes from the delta . / / be sure to do this in the calling thread , / / as the delta is destroyed when this method returns final List additions = new ArrayList ( ) ; final List removals = new ArrayList ( ) ; final List changes = new ArrayList ( ) ; IResourceDelta delta = event . getDelta ( ) ; if ( delta == null ) return ; getMarkerDeltas ( delta , additions , removals , changes ) ; / / update the viewer based on the marker changes , in the UI thread if ( additions . size ( ) + removals . size ( ) + changes . size ( ) > 0 ) { viewer . getControl ( ) . getDisplay ( ) . asyncExec ( new Runnable ( ) { public void run ( ) { / / This method runs inside an asyncExec . The widget may have been destroyed / / by the time this is run . Check for this and do nothing if so . Control ctrl = viewer . getControl ( ) ; if ( ctrl == null || ctrl . isDisposed ( ) ) return ; viewer . refresh ( ) ; } } ) ; } }	if ( delta == null ) { return ; }
case PropertyType . STRING_TYPE : case PropertyType . BOOLEAN_TYPE : case PropertyType . DATE_TIME_TYPE : case PropertyType . FLOAT_TYPE : case PropertyType . INTEGER_TYPE : case PropertyType . EXPRESSION_TYPE : case PropertyType . ELEMENT_REF_TYPE : <CTX> public static final List getSupportedSubTypes ( ) { if ( supportedSubTypes != null && ! supportedSubTypes . isEmpty ( ) ) return supportedSubTypes ; supportedSubTypes = new ArrayList ( ) ; Iterator iter = MetaDataDictionary . getInstance ( ) . getPropertyTypes ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { PropertyType propType = ( PropertyType ) iter . next ( ) ; int type = propType . getTypeCode ( ) ; switch ( type ) { case PropertyType . STRING_TYPE : case PropertyType . BOOLEAN_TYPE : case PropertyType . DATE_TIME_TYPE : case PropertyType . FLOAT_TYPE : case PropertyType . INTEGER_TYPE : case PropertyType . EXPRESSION_TYPE : case PropertyType . ELEMENT_REF_TYPE : supportedSubTypes . add ( propType ) ; break ; default : break ; } } return supportedSubTypes ; }	case IPropertyType . STRING_TYPE : case IPropertyType . BOOLEAN_TYPE : case IPropertyType . DATE_TIME_TYPE : case IPropertyType . FLOAT_TYPE : case IPropertyType . INTEGER_TYPE : case IPropertyType . EXPRESSION_TYPE : case IPropertyType . ELEMENT_REF_TYPE :
return new File ( workingDir , f . getPath ( ) ) ; <CTX> private File makeAbsolute ( File f ) { if ( isAbsolute ( f ) ) { return f ; } else { return new File ( workingDir , f . getPath ( ) ) ; } }	return new Path ( workingDir , f ) ;
return super . isValid ( ) && fileContentDescription != null && fileContentDescription . exists ( ) ; <CTX> public boolean isValid ( ) { return super . isValid ( ) && fileContentDescription != null && fileContentDescription . exists ( ) ; }	if ( location != null ) { return super . isValid ( ) ; } return super . isValid ( ) && fileContentDescription != null && fileContentDescription . exists ( ) ;
return m_store . getInt 32 ( STP_MAX_AGE ) ; <CTX> public int getStpMaxAge ( ) { return m_store . getInt 32 ( STP_MAX_AGE ) ; }	Integer stpMaxAge = m_store . getInt 32 ( STP_MAX_AGE ) ; if ( stpMaxAge == null ) return - 1 ; return stpMaxAge ;
if ( item . getId ( ) . equals ( startId ) ) <CTX> private IContributionItem findAlphabeticalOrder ( String startId , String itemId , IContributionManager mgr ) { IContributionItem [ ] items = mgr . getItems ( ) ; int insertIndex = 0 ; / / look for starting point while ( insertIndex < items . length ) { IContributionItem item = items [ insertIndex ] ; if ( item . getId ( ) . equals ( startId ) ) break ; ++ insertIndex ; } / / Find the index that this item should be inserted in for ( int i = insertIndex + 1 ; i < items . length ; i ++ ) { IContributionItem item = items [ i ] ; if ( item . isGroupMarker ( ) ) break ; String testId ; if ( item instanceof PluginActionCoolBarContributionItem ) { testId = ( ( PluginActionCoolBarContributionItem ) item ) . getActionSetId ( ) ; } else { testId = item . getId ( ) ; } if ( itemId != null ) { if ( itemId . compareTo ( testId ) < 1 ) break ; } insertIndex = i ; } if ( insertIndex >= items . length ) { return null ; } return items [ insertIndex ] ; }	if ( startId != null && startId . equals ( item . getId ( ) ) )
Object source = pce . getSource ( ) ; <CTX> public void propertyChange ( PropertyChangeEvent pce ) { if ( ! pce . getPropertyName ( ) . equals ( BEAN_CONTEXT ) ) { return ; } Object source = pce . getSource ( ) ; if ( source instanceof BCSChild ) { BCSChild ch = ( BCSChild ) source ; Object newValue = pce . getNewValue ( ) ; if ( ! newValue . equals ( this . getBeanContextPeer ( ) ) ) { remove ( ch . getChild ( ) , false ) ; } } }	source = pce . getSource ( ) ;
FileUtils . deleteDirectory ( checkoutDirectory ) ; <CTX> public void checkout ( ) throws ScmException , IOException { ScmRepository repository = getScmRepository ( ) ; checkoutDirectory = new File ( workingDirectory ) ; if ( checkoutDirectory . exists ( ) ) { / / TODO : sanity check that it is not . or . . or lower FileUtils . deleteDirectory ( checkoutDirectory ) ; } checkoutDirectory . mkdirs ( ) ; CheckOutScmResult result = getScmManager ( ) . checkOut ( repository , new ScmFileSet ( checkoutDirectory ) , tag ) ; checkResult ( result ) ; }	FileUtils . deleteDirectory ( workingDirectory ) ; FileUtils . mkdir ( workingDirectory ) ;
return constructRuby ( self , pref , node ) ; <CTX> public Object call ( final Constructor self , final String pref , final Node node ) { return constructRuby ( self , pref , node ) ; }	return constructRubyMap ( self , pref , node ) ;
getOwner ( ) . getViewer ( ) . setSelection ( new StructuredSelection ( list ) ) ; <CTX> public void run ( ) { if ( getOwner ( ) . getViewer ( ) . getControl ( ) . isVisible ( ) ) { getOwner ( ) . getViewer ( ) . setSelection ( new StructuredSelection ( list ) ) ; } }	if ( getOwner ( ) . getViewer ( ) instanceof DeferredGraphicalViewer ) ( ( DeferredGraphicalViewer ) getOwner ( ) . getViewer ( ) ) . setSelection ( new StructuredSelection ( list ) , false ) ;
static final Map classAssertionStatus ( ) { return null ; <CTX> static final Map classAssertionStatus ( ) { return null ; }	static final Map classAssertionStatus ( ) { return new HashMap ( ) ;
HotSwapUI . getInstance ( project ) . reloadChangedClasses ( session , session . isCompileBeforeRunning ( ) ) ; <CTX> public void actionPerformed ( AnActionEvent e ) { DataContext dataContext = e . getDataContext ( ) ; Project project = ( Project ) dataContext . getData ( DataConstants . PROJECT ) ; if ( project == null ) { return ; } DebuggerManagerEx debuggerManager = DebuggerManagerEx . getInstanceEx ( project ) ; DebuggerSession session = debuggerManager . getContext ( ) . getDebuggerSession ( ) ; if ( session != null && session . isAttached ( ) ) { HotSwapUI . getInstance ( project ) . reloadChangedClasses ( session , session . isCompileBeforeRunning ( ) ) ; } }	HotSwapUI . getInstance ( project ) . reloadChangedClasses ( session , DebuggerSettings . getInstance ( ) . COMPILE_BEFORE_HOTSWAP ) ;
if ( instance != null ) <CTX> public ViewerFilter [ ] getVisibleFilters ( boolean toReturnOnlyActiveFilters ) { CommonFilterDescriptor [ ] descriptors = CommonFilterDescriptorManager . getInstance ( ) . findVisibleFilters ( contentService ) ; List filters = new ArrayList ( ) ; ViewerFilter instance ; for ( int i = 0 ; i < descriptors . length ; i ++ ) if ( ! toReturnOnlyActiveFilters || isActive ( descriptors [ i ] . getId ( ) ) ) { instance = getViewerFilter ( descriptors [ i ] ) ; if ( instance != null ) filters . add ( instance ) ; } / * return the enforced viewer filters always * / filters . addAll ( enforcedViewerFilters ) ; if ( filters . size ( ) == 0 ) return NO_FILTERS ; return ( ViewerFilter [ ] ) filters . toArray ( new ViewerFilter [ filters . size ( ) ] ) ; }	if ( instance != null ) {
checkReadable ( ) ; try { int c = inStream . read ( ) ; if ( c == - 1 ) { return runtime . getTrue ( ) ; } inStream . unread ( c ) ; return runtime . getFalse ( ) ; } catch ( IOException e ) { throw IOError . fromException ( runtime , e ) ; } <CTX> public RubyBoolean eof ( ) { checkReadable ( ) ; try { int c = inStream . read ( ) ; if ( c == - 1 ) { return runtime . getTrue ( ) ; } inStream . unread ( c ) ; return runtime . getFalse ( ) ; } catch ( IOException e ) { throw IOError . fromException ( runtime , e ) ; } }	boolean isEOF = handler . isEOF ( ) ; return isEOF ? getRuntime ( ) . getTrue ( ) : getRuntime ( ) . getFalse ( ) ;
return this . sid ; <CTX> public short getSid ( ) { return this . sid ; }	return sid ;
newStr . infectObject ( this ) ; <CTX> public IRubyObject tr_s ( IRubyObject [ ] args ) { RubyString newStr = newString ( tr ( args , true ) ) ; newStr . infectObject ( this ) ; return newStr ; }	newStr . infectBy ( this ) ;
this . fileName = compilationUnit . getFileName ( ) ; this . compilationUnit = compilationUnit ; <CTX> public CompilationResult ( ICompilationUnit compilationUnit , int unitIndex , int totalUnitsKnown , int maxProblemPerUnit ) { this . fileName = compilationUnit . getFileName ( ) ; this . compilationUnit = compilationUnit ; this . unitIndex = unitIndex ; this . totalUnitsKnown = totalUnitsKnown ; this . maxProblemPerUnit = maxProblemPerUnit ; }	this . fileName = fileName ;
TypeFactory getFactory ( String role ) <CTX> TypeFactory getFactory ( String role ) throws TypeException ;	TypeFactory getFactory ( Class roleType )
ruby . getInterpreter ( ) . setDynamicVars ( ( RubyVarmap ) oldMap . get ( ruby ) ) ; <CTX> public static void pop ( Ruby ruby ) { ruby . getInterpreter ( ) . setDynamicVars ( ( RubyVarmap ) oldMap . get ( ruby ) ) ; }	ruby . getInterpreter ( ) . setDynamicVars ( ( RubyVarmap ) ( ( RubyStack ) oldMap . get ( ruby ) ) . pop ( ) ) ;
ctors = cl . getConstructors ( ) ; int N = ctors . length ; ctorTypes = new Class [ N ] [ ] ; <CTX> private void reflectCtors ( ) { ctors = cl . getConstructors ( ) ; int N = ctors . length ; ctorTypes = new Class [ N ] [ ] ; for ( int i = 0 ; i != N ; ++ i ) { ctorTypes [ i ] = ctors [ i ] . getParameterTypes ( ) ; } }	Constructor [ ] constructors = cl . getConstructors ( ) ; int N = constructors . length ; ctors = new MemberBox [ N ] ;
{ this . parseConfigVars ( request ) ; } <CTX> protected void__ initParameters ( HttpServletRequest request ) throws Exception { this . reportDesignHandle = getDesignHandle ( request ) ; InputOptions options = new InputOptions ( ) ; options . setOption ( InputOptions . OPT_REQUEST , request ) ; options . setOption ( InputOptions . OPT_LOCALE , locale ) ; options . setOption ( InputOptions . OPT_RTL , new Boolean ( rtl ) ) ; this . parameterList = this . getReportService ( ) . getParameterDefinitions ( reportDesignHandle , options , false ) ; / / when in preview model , parse paramenters from config file if ( isDesigner ) { this . parseConfigVars ( request ) ; } / / Change parameters to be Map , not HashMap this . parameters = ( HashMap ) getParsedParameters ( reportDesignHandle , parameterList , request , options ) ; this . missingParameter = validateParameters ( parameterList , this . parameters ) ; }	parseConfigVars ( request ) ;
dietInt -- ; <CTX> protected void consumeRestoreDiet ( ) { / / RestoreDiet :: = $ empty dietInt -- ; }	this . dietInt -- ;
RubyArray args = ( RubyArray ) state . begin ( iVisited . getArgsNode ( ) ) ; <CTX> public Instruction visitCallNode ( CallNode iVisited ) { IRubyObject receiver = state . begin ( iVisited . getReceiverNode ( ) ) ; if ( iVisited . getArgsNode ( ) == null ) { / / attribute set . receiver . callMethod ( iVisited . getName ( ) , new IRubyObject [ ] { value } , CallType . NORMAL ) ; } else { / / element set RubyArray args = ( RubyArray ) state . begin ( iVisited . getArgsNode ( ) ) ; args . append ( value ) ; receiver . callMethod ( iVisited . getName ( ) , args . toJavaArray ( ) , CallType . NORMAL ) ; } return null ; }	RubyArray args = ( RubyArray ) EvaluationState . eval ( runtime . getCurrentContext ( ) , iVisited . getArgsNode ( ) , runtime . getCurrentContext ( ) . getFrameSelf ( ) ) ;
if ( v . getType ( ) . equals (_var . getType ( ) ) ) { <CTX> public boolean equals ( Object other ) { boolean rc = false ; if ( this == other ) { rc = true ; } else if ( other instanceof JCatchStatement ) { JCatchStatement cs = ( JCatchStatement ) other ; if ( cs ._var . getType ( ) . equals (_var . getType ( ) ) ) { rc = true ; } } else if ( other instanceof JVariable ) { JVariable v = ( JVariable ) other ; if ( v . getType ( ) . equals (_var . getType ( ) ) ) { rc = true ; } } return rc ; }	if ( v . getType ( ) . equals ( var . getType ( ) ) ) {
Date reminder = task . getReminderDate ( ) ; if ( reminder != null ) { Date now = new Date ( ) ; return ( reminder . compareTo ( now ) == 1 && reminder . compareTo ( activityThisWeek . getEnd ( ) . getTime ( ) ) == - 1 ) ; } else { return false ; <CTX> public boolean isReminderThisWeek ( ITask task ) { Date reminder = task . getReminderDate ( ) ; if ( reminder != null ) { Date now = new Date ( ) ; return ( reminder . compareTo ( now ) == 1 && reminder . compareTo ( activityThisWeek . getEnd ( ) . getTime ( ) ) == - 1 ) ; } else { return false ; } }	if ( task != null ) { Date reminder = task . getReminderDate ( ) ; if ( reminder != null ) { Date now = new Date ( ) ; return ( reminder . compareTo ( now ) == 1 && reminder . compareTo ( activityThisWeek . getEnd ( ) . getTime ( ) ) == - 1 ) ; }
if ( userID == annotation . getModuleExecution ( ) . getExperimenter ( ) . getID ( ) ) map . put ( new Integer ( annotation . getDataset ( ) . getID ( ) ) , <CTX> public static Map reverseListDatasetAnnotations ( List annotations , int userID ) { Map map = new HashMap ( ) ; Iterator i = annotations . iterator ( ) ; DatasetAnnotation annotation ; while ( i . hasNext ( ) ) { annotation = ( DatasetAnnotation ) i . next ( ) ; if ( userID == annotation . getModuleExecution ( ) . getExperimenter ( ) . getID ( ) ) map . put ( new Integer ( annotation . getDataset ( ) . getID ( ) ) , annotation ) ; } return map ; }	map . put ( new Integer ( annotation . getDataset ( ) . getID ( ) ) ,
return ( short ) fValue ; <CTX> public short shortValue ( ) { return ( short ) fValue ; }	return ( short ) value ;
if ( startTime . getDay ( ) != - 1 ) { startCal . set ( Calendar . DAY_OF_WEEK , startTime . getDay ( ) ) ; <CTX> private TimeInterval theMostRecentIntervalBefore ( Calendar t ) { TimeInterval timeInterval = getIntervalFromPool ( ) ; Calendar startCal = timeInterval . getStart ( ) ; startCal . setTimeInMillis ( t . getTimeInMillis ( ) ) ; startCal . set ( Calendar . MILLISECOND , 0 ) ; if ( startTime . getDay ( ) != - 1 ) { startCal . set ( Calendar . DAY_OF_WEEK , startTime . getDay ( ) ) ; } if ( startTime . getDay ( ) == - 1 && t . get ( Calendar . HOUR_OF_DAY ) < startTime . getHour ( ) ) { startCal . add ( Calendar . DATE , - 1 ) ; } if ( startTime . getDay ( ) != - 1 && ( t . get ( Calendar . DAY_OF_WEEK ) < startTime . getDay ( ) || ( t . get ( Calendar . DAY_OF_WEEK ) == startTime . getDay ( ) && t . get ( Calendar . HOUR_OF_DAY ) < startTime . getHour ( ) ) ) ) { startCal . add ( Calendar . WEEK_OF_YEAR , - 1 ) ; } startCal . set ( Calendar . HOUR_OF_DAY , startTime . getHour ( ) ) ; startCal . set ( Calendar . MINUTE , startTime . getMinute ( ) ) ; startCal . set ( Calendar . SECOND , startTime . getSecond ( ) ) ; Calendar endCal = timeInterval . getEnd ( ) ; endCal . setTimeInMillis ( startCal . getTimeInMillis ( ) ) ; if ( endTime . getDay ( ) != - 1 ) { endCal . set ( Calendar . DAY_OF_WEEK , endTime . getDay ( ) ) ; } if ( endTime . getDay ( ) == - 1 && startTime . getHour ( ) >= endTime . getHour ( ) ) { endCal . add ( Calendar . DATE , 1 ) ; } if ( endTime . getDay ( ) != - 1 && ( startTime . getDay ( ) > endTime . getDay ( ) || ( startTime . getDay ( ) == endTime . getDay ( ) && startTime . getHour ( ) >= endTime . getHour ( ) ) ) ) { endCal . add ( Calendar . WEEK_OF_YEAR , 1 ) ; } endCal . set ( Calendar . HOUR_OF_DAY , endTime . getHour ( ) ) ; endCal . set ( Calendar . MINUTE , endTime . getMinute ( ) ) ; endCal . set ( Calendar . SECOND , endTime . getSecond ( ) ) ; return timeInterval ; }	int scheduleStartDay = startTime . getDay ( ) ; int scheduleStartHour = startTime . getHour ( ) ; int day = t . get ( Calendar . DAY_OF_WEEK ) ; if ( isSet ( scheduleStartDay ) ) { startCal . set ( Calendar . DAY_OF_WEEK , scheduleStartDay ) ; if ( day < scheduleStartDay || ( isSameDay ( day , scheduleStartDay ) && isTimeBefore ( t , startTime ) ) ) { startCal . add ( Calendar . WEEK_OF_YEAR , - 1 ) ; } } else { if ( isTimeBefore ( t , startTime ) ) { startCal . add ( Calendar . DATE , - 1 ) ; }
if ( contentFamily . manager == DeferredTreeContentManager . this ) return isParent ( contentFamily , parent ) ; <CTX> protected void startFetchingDeferredChildren ( final Object parent , final IDeferredWorkbenchAdapter adapter , final PendingUpdateAdapter placeholder ) { final IElementCollector collector = createElementCollector ( parent , placeholder ) ; / / Cancel any jobs currently fetching children for the same parent / / instance . cancel ( parent ) ; String jobName = getFetchJobName ( parent , adapter ) ; Job job = new Job ( jobName ) { / * ( non - Javadoc ) * @ see org . eclipse . core . jobs . Job # run ( org . eclipse . core . runtime . IProgressMonitor ) * / public IStatus run ( IProgressMonitor monitor ) { adapter . fetchDeferredChildren ( parent , collector , monitor ) ; if ( monitor . isCanceled ( ) ) return Status . CANCEL_STATUS ; return Status . OK_STATUS ; } / * ( non - Javadoc ) * @ see org . eclipse . core . jobs . Job # belongsTo ( java . lang . Object ) * / public boolean belongsTo ( Object family ) { if ( family instanceof DeferredContentFamily ) { DeferredContentFamily contentFamily = ( DeferredContentFamily ) family ; if ( contentFamily . manager == DeferredTreeContentManager . this ) return isParent ( contentFamily , parent ) ; } return false ; } / * * * Check if the parent of element is equal to the parent used in * this job . * * @ param family * The DeferredContentFamily that defines a potential * ancestor of the current parent in a particualr manager . * @ param child * The object to check against . * @ return boolean < code > true < / code > if the child or one of its * parents are the same as the element of the family . * / private boolean isParent ( DeferredContentFamily family , Object child ) { if ( family . element . equals ( child ) ) return true ; IWorkbenchAdapter workbenchAdapter = getWorkbenchAdapter ( child ) ; if ( workbenchAdapter == null ) return false ; Object elementParent = workbenchAdapter . getParent ( child ) ; if ( elementParent == null ) return false ; return isParent ( family , elementParent ) ; } / * * * Get the workbench adapter for the element . * * @ param element * The object we are adapting to . * / private IWorkbenchAdapter getWorkbenchAdapter ( Object element ) { if ( element instanceof IWorkbenchAdapter ) return ( IWorkbenchAdapter ) element ; if ( ! ( element instanceof IAdaptable ) ) return null ; Object workbenchAdapter = ( ( IAdaptable ) element ) . getAdapter ( IWorkbenchAdapter . class ) ; if ( workbenchAdapter == null ) return null ; return ( IWorkbenchAdapter ) workbenchAdapter ; } } ; job . addJobChangeListener ( new JobChangeAdapter ( ) { / * * ( non - Javadoc ) * * @ see org . eclipse . core . runtime . jobs . JobChangeAdapter # done ( org . eclipse . core . runtime . jobs . IJobChangeEvent ) * / public void done ( IJobChangeEvent event ) { runClearPlaceholderJob ( placeholder ) ; } } ) ; job . setRule ( adapter . getRule ( parent ) ) ; if ( progressService == null ) job . schedule ( ) ; else progressService . schedule ( job ) ; }	if ( contentFamily . manager == DeferredTreeContentManager . this ) { return isParent ( contentFamily , parent ) ; }
if ( oobs [ i ] instanceof MIAsyncRecord ) { int id = ( ( MIAsyncRecord ) oobs [ i ] ) . getToken ( ) ; Command cmd = rxQueue . removeCommand ( id ) ; if ( cmd != null ) { cmd . setMIOutput ( response ) ; cmd . notifyAll ( ) ; } } processMIOOBRecord ( oobs [ i ] ) ; <CTX> void processMIOutput ( String buffer ) { MIOutput response = session . parse ( buffer ) ; if ( response != null ) { Queue rxQueue = session . getRxQueue ( ) ; / / Notify any command waiting for a ResultRecord . MIResultRecord rr = response . getMIResultRecord ( ) ; if ( rr != null ) { int id = rr . geToken ( ) ; Command cmd = rxQueue . removeCommand ( id ) ; if ( cmd != null ) { synchronized ( cmd ) { cmd . setMIOutput ( response ) ; cmd . notifyAll ( ) ; } } } / / A command may wait on a specific oob , like breakpointhit MIOOBRecord [ ] oobs = response . getMIOOBRecords ( ) ; for ( int i = 0 ; i < oobs . length ; i ++ ) { if ( oobs [ i ] instanceof MIAsyncRecord ) { int id = ( ( MIAsyncRecord ) oobs [ i ] ) . getToken ( ) ; Command cmd = rxQueue . removeCommand ( id ) ; if ( cmd != null ) { cmd . setMIOutput ( response ) ; cmd . notifyAll ( ) ; } } processMIOOBRecord ( oobs [ i ] ) ; } } }	processMIOOBRecord ( oobs [ i ] , list ) ; } MIEvent [ ] events = ( MIEvent [ ] ) list . toArray ( new MIEvent [ list . size ( ) ] ) ; if ( events . length > 0 ) { Thread eventTread = new EventThread ( session , events ) ; eventTread . start ( ) ;
this . reportWarnings = reportWarnings ; <CTX> public ToolErrorReporter ( boolean reportWarnings ) { this . reportWarnings = reportWarnings ; }	this ( reportWarnings , System . err ) ;
new Object [ ] { themeString } ) ; <CTX> private void refreshThemeCombo ( ) { themeCombo . removeAll ( ) ; ITheme currentTheme = PlatformUI . getWorkbench ( ) . getThemeManager ( ) . getCurrentTheme ( ) ; IThemeDescriptor [ ] descs = WorkbenchPlugin . getDefault ( ) . getThemeRegistry ( ) . getThemes ( ) ; int selection = 0 ; String themeString = PlatformUI . getWorkbench ( ) . getThemeManager ( ) . getTheme ( IThemeManager . DEFAULT_THEME ) . getLabel ( ) ; if ( currentTheme . getId ( ) . equals ( IThemeManager . DEFAULT_THEME ) ) { themeString = MessageFormat . format ( WorkbenchMessages . ViewsPreference_currentThemeFormat , new Object [ ] { themeString } ) ; } themeCombo . add ( themeString ) ; for ( int i = 0 ; i < descs . length ; i ++ ) { themeString = descs [ i ] . getName ( ) ; if ( descs [ i ] . getId ( ) . equals ( currentTheme . getId ( ) ) ) { themeString = MessageFormat . format ( WorkbenchMessages . ViewsPreference_currentThemeFormat , new Object [ ] { themeString } ) ; selection = i + 1 ; } themeCombo . add ( themeString ) ; } themeCombo . select ( selection ) ; }	new Object [ ] { defaultThemeString } ) ;
if ( checkInterfaceHierarchy ( superInterfaces [ i ] ) ) <CTX> private boolean checkInterfaceHierarchy ( Class interfaceToCheck ) { if ( interfaceToCheck . getName ( ) . equals ( className ) ) return true ; Class [ ] superInterfaces = interfaceToCheck . getInterfaces ( ) ; for ( int i = 0 ; i < superInterfaces . length ; i ++ ) { if ( checkInterfaceHierarchy ( superInterfaces [ i ] ) ) return true ; } return false ; }	if ( checkInterfaceHierarchy ( superInterfaces [ i ] ) ) {
if ( ! referenced . contains ( projects [ i ] ) ) referenced . add ( projects [ i ] ) ; <CTX> public Object [ ] getChildren ( Object o ) { if ( ! ( o instanceof IWorkspace ) ) { return new Object [ 0 ] ; } / / Collect all the projects in the workspace except the given project IProject [ ] projects = ( ( IWorkspace ) o ) . getRoot ( ) . getProjects ( ) ; ArrayList referenced = new ArrayList ( projects . length ) ; boolean found = false ; for ( int i = 0 ; i < projects . length ; i ++ ) { if ( ! found && projects [ i ] . equals ( project ) ) { found = true ; continue ; } referenced . add ( projects [ i ] ) ; } / / Add any referenced that do not exist in the workspace currently try { projects = project . getDescription ( ) . getReferencedProjects ( ) ; for ( int i = 0 ; i < projects . length ; i ++ ) { if ( ! referenced . contains ( projects [ i ] ) ) referenced . add ( projects [ i ] ) ; } } catch ( CoreException e ) { / / Ignore core exceptions } return referenced . toArray ( ) ; }	if ( ! referenced . contains ( projects [ i ] ) ) { referenced . add ( projects [ i ] ) ; }
Document document = XMLHandler . loadXMLFile ( new File ( filename ) ) ; Node sharedObjectsNode = XMLHandler . getSubNode ( document , XML_TAG ) ; if ( sharedObjectsNode != null ) <CTX> public SharedObjects ( String sharedObjectsFile , ArrayList databases , Hashtable counters ) throws KettleXMLException { this . filename = createFilename ( sharedObjectsFile ) ; this . databases = databases ; this . counters = counters ; this . objectsMap = new Hashtable ( ) ; / / Extra information Document document = XMLHandler . loadXMLFile ( new File ( filename ) ) ; Node sharedObjectsNode = XMLHandler . getSubNode ( document , XML_TAG ) ; if ( sharedObjectsNode != null ) { NodeList childNodes = sharedObjectsNode . getChildNodes ( ) ; for ( int i = 0 ; i < childNodes . getLength ( ) ; i ++ ) { Node node = childNodes . item ( i ) ; String nodeName = node . getNodeName ( ) ; SharedObjectInterface isShared = null ; if ( nodeName . equals ( DatabaseMeta . XML_TAG ) ) isShared = new DatabaseMeta ( node ) ; else if ( nodeName . equals ( StepMeta . XML_TAG ) ) { StepMeta stepMeta = new StepMeta ( node , databases , counters ) ; stepMeta . setDraw ( false ) ; / / don t draw it , keep it in the tree . isShared = stepMeta ; } else if ( nodeName . equals ( PartitionSchema . XML_TAG ) ) isShared = new PartitionSchema ( node ) ; else if ( nodeName . equals ( ClusterSchema . XML_TAG ) ) isShared = new ClusterSchema ( node ) ; if ( isShared != null ) { isShared . setShared ( true ) ; storeObject ( isShared ) ; } } } }	File file = new File ( filename ) ; if ( file . exists ( ) )
if ( activeState != StackPresentation . AS_INACTIVE ) { <CTX> public void setActive ( int activeState ) { if ( activeState != StackPresentation . AS_INACTIVE ) { if ( presentationSite . getState ( ) == IStackPresentationSite . STATE_MINIMIZED ) { setState ( IStackPresentationSite . STATE_RESTORED ) ; } } presentationSite . setActive ( activeState ) ; }	if ( activeState == StackPresentation . AS_ACTIVE_FOCUS ) {
synchronized ( m_tracks ) <CTX> public boolean deleteTrack ( Track track ) { synchronized ( m_tracks ) { return m_tracks . remove ( track ) ; } }	synchronized ( tracks )
selectedColumns , query . getRowExpressions ( ) ) ; <CTX> public IExtractionResults extract ( ) throws EngineException { if ( instanceId == null ) return null ; if ( currentResult != null ) return currentResult ; assert executionContext . getDataEngine ( ) != null ; DataEngine dataEngine = executionContext . getDataEngine ( ) . getDataEngine ( ) ; ReportItemDesign rptItem = ( ReportItemDesign ) report . getReportItemByID ( instanceId . getComponentID ( ) ) ; assert rptItem != null ; IBaseQueryDefinition query = rptItem . getQuery ( ) ; validateSelectedColumns ( query ) ; DataID dataId = instanceId . getDataID ( ) ; InstanceID instId = instanceId ; while ( instId != null && dataId == null ) { instId = instId . getParentID ( ) ; if ( instId != null ) { dataId = instId . getDataID ( ) ; } } if ( dataId == null ) return null ; DataSetID dataSetId = dataId . getDataSetID ( ) ; assert dataSetId != null ; String queryResultName = dataSetId . getDataSetName ( ) ; if ( resultMetaList == null ) { resultMetaList = new ArrayList ( ) ; } else { resultMetaList . clear ( ) ; } if ( queryResultName != null ) { try { IQueryResults queryResults = dataEngine . getQueryResults ( queryResultName ) ; assert queryResults . getResultIterator ( ) != null ; currentResult = new ExtractionResults ( queryResults . getResultIterator ( ) , selectedColumns , query . getRowExpressions ( ) ) ; resultMetaList . add ( currentResult . getResultMetaData ( ) ) ; return currentResult ; } catch ( BirtException e ) { e . printStackTrace ( ) ; } } else { DataSetID parentId = dataSetId . getParentID ( ) ; assert parentId != null ; try { queryResultName = parentId . getDataSetName ( ) ; DataSetID parId = parentId ; while ( queryResultName == null && parId != null ) { parId = parId . getParentID ( ) ; if ( parId != null ) queryResultName = parId . getDataSetName ( ) ; } assert queryResultName != null ; IQueryResults parentQueryResult = dataEngine . getQueryResults ( queryResultName ) ; assert parentQueryResult != null ; IResultIterator iter = parentQueryResult . getResultIterator ( ) ; long rowid = dataSetId . getRowID ( ) ; int i = 0 ; while ( iter . next ( ) && i ++ < rowid ) ; IResultIterator subIter = iter . getSecondaryIterator ( dataSetId . getQueryName ( ) , executionContext . getScope ( ) ) ; currentResult = new ExtractionResults ( subIter , selectedColumns , query . getRowExpressions ( ) ) ; resultMetaList . add ( currentResult . getResultMetaData ( ) ) ; return currentResult ; } catch ( BirtException be ) { be . printStackTrace ( ) ; } } return null ; }	selectedColumns , getScriptExpressions ( query . getRowExpressions ( ) ) ) ;
EMIT ( MIR_CondMove . mutate ( s , IA 32_CMOV , result . copy ( ) , <CTX> protected final void CMOV_MOV ( OPT_Instruction s , OPT_RegisterOperand result , OPT_ConditionOperand cond , OPT_Operand trueValue , OPT_Operand falseValue ) { if ( result . similar ( trueValue ) ) { / / in this case , only need a conditional move for the false branch . EMIT ( MIR_CondMove . mutate ( s , IA 32_CMOV , result , asReg ( s , IA 32_MOV , falseValue ) , COND ( cond . flipCode ( ) ) ) ) ; } else if ( result . similar ( falseValue ) ) { / / in this case , only need a conditional move for the true branch . EMIT ( MIR_CondMove . mutate ( s , IA 32_CMOV , result , asReg ( s , IA 32_MOV , trueValue ) , COND ( cond ) ) ) ; } else { / / need to handle both possible assignments . Unconditionally / / assign one value then conditionally assign the other . if ( falseValue . isRegister ( ) ) { EMIT ( CPOS ( s , MIR_Move . create ( IA 32_MOV , result , trueValue ) ) ) ; EMIT ( MIR_CondMove . mutate ( s , IA 32_CMOV , result . copy ( ) , falseValue , COND ( cond . flipCode ( ) ) ) ) ; } else { EMIT ( CPOS ( s , MIR_Move . create ( IA 32_MOV , result , falseValue ) ) ) ; EMIT ( MIR_CondMove . mutate ( s , IA 32_CMOV , result . copy ( ) , asReg ( s , IA 32_MOV , trueValue ) , COND ( cond ) ) ) ; } } }	EMIT ( MIR_CondMove . mutate ( s , IA 32_CMOV , result . copyRO ( ) ,
out . write ( NORMAL_TEMINATION ) ; <CTX> void stopThread ( ) { synchronized ( mutex ) { if ( client_sock != null ) { try { OutputStream out = client_sock . getOutputStream ( ) ; out . write ( NORMAL_TEMINATION ) ; } catch ( Throwable t ) { } } } closeClientSocket ( ) ; }	out . write ( NORMAL_TERMINATION ) ;
if ( coolBarMgr != null ) <CTX> protected void setActive ( boolean value ) { super . setActive ( value ) ; if ( coolBarMgr != null ) coolBarMgr . setVisible ( value ) ; }	if ( coolBarMgr != null ) {
organizer . startBuilder ( ) ; <CTX> public void actionPerformed ( ActionEvent e ) { organizer . startBuilder ( ) ; }	organizer . startExperimentBuilder ( ) ;
break ; <CTX> public void filesActivated ( VFSBrowser browser , VFS . DirectoryEntry [ ] files ) { if ( files . length == 0 ) return ; filenameField . selectAll ( ) ; if ( browser . getMode ( ) == VFSBrowser . BROWSER_DIALOG ) { for ( int i = 0 ; i < files . length ; i ++ ) { if ( files [ i ] . type == VFS . DirectoryEntry . FILE ) { dispose ( ) ; break ; } } } else ok ( ) ; } / / } } }	return ;
aci . setIndex ( currentChar ) ; int glyphCharIndex = ( ( Integer ) aci . getAttribute ( GVTAttributedCharacterIterator . TextAttribute . CHAR_INDEX ) ) . intValue ( ) ; if ( charIndex == glyphCharIndex ) { return i ; <CTX> public int getGlyphIndex ( int charIndex ) { int currentChar = aci . getBeginIndex ( ) ; int numGlyphs = getGlyphCount ( ) ; for ( int i = 0 ; i < numGlyphs ; i ++ ) { aci . setIndex ( currentChar ) ; int glyphCharIndex = ( ( Integer ) aci . getAttribute ( GVTAttributedCharacterIterator . TextAttribute . CHAR_INDEX ) ) . intValue ( ) ; if ( charIndex == glyphCharIndex ) { return i ; } currentChar += getCharacterCount ( i , i ) ; } return - 1 ; }	int count = getCharacterCount ( i , i ) ; for ( int n = 0 ; n < count ; n ++ ) { int glyphCharIndex = ( ( Integer ) aci . getAttribute ( GVTAttributedCharacterIterator . TextAttribute . CHAR_INDEX ) ) . intValue ( ) ; if ( charIndex == glyphCharIndex ) return i ; if ( aci . next ( ) == AttributedCharacterIterator . DONE ) return - 1 ;
if ( transactionCandidate . equals ( Protocol . TRANSACTIONS_UP_TO_DATE ) ) { notify (_subscriberUpToDateMonitor ) ; return ; } if ( transactionCandidate . equals ( Protocol . REMOTE_TRANSACTION ) ) { <CTX> private void receiveTransactionFromServer ( ) throws IOException , ClassNotFoundException { Object transactionCandidate =_fromServer . readObject ( ) ; if ( transactionCandidate . equals ( Protocol . TRANSACTIONS_UP_TO_DATE ) ) { notify (_subscriberUpToDateMonitor ) ; return ; } if ( transactionCandidate . equals ( Protocol . REMOTE_TRANSACTION ) ) { synchronized (_myTransactionMonitor ) {_subscriber . receive (_myTransaction ) ; notify (_myTransactionMonitor ) ; } return ; }_subscriber . receive ( ( Transaction ) transactionCandidate ) ; }	if ( transactionCandidate . equals ( RemoteConnection . REMOTE_TRANSACTION ) ) {
imageEmitter = new HTMLImageEmitter ( this ) ; pageSetupEmitter = new HTMLPageSetupEmitter ( this ) ; tableEmitter = new HTMLTableEmitter ( this ) ; textEmitter = new HTMLTextEmitter ( this ) ; containerEmitter = new HTMLContainerEmitter ( this ) ; <CTX> public void initialize ( IEmitterServices services ) { this . services = services ; IRepository repository = services . getRepository ( ) ; saveImgFile = ( services . getEngineMode ( ) == IEmitterServices . ENGINE_STANDALONE_MODE ) ; writer = new HTMLWriter ( ) ; resourceManager = new ResourceManager ( repository ) ; if ( services . getEngineMode ( ) == IEmitterServices . ENGINE_EMBEDDED_MODE ) hyperlinkProcessor = new EmbeddedHyperlinkProcessor ( services . getBaseURL ( ) ) ; else if ( services . getEngineMode ( ) == IEmitterServices . ENGINE_STANDALONE_MODE ) hyperlinkProcessor = new DefaultHyperlinkProcessor ( ) ; imageEmitter = new HTMLImageEmitter ( this ) ; pageSetupEmitter = new HTMLPageSetupEmitter ( this ) ; tableEmitter = new HTMLTableEmitter ( this ) ; textEmitter = new HTMLTextEmitter ( this ) ; containerEmitter = new HTMLContainerEmitter ( this ) ; }	imageEmitter = new HTMLImageEmitter ( this , isEmbeddable ) ; pageSetupEmitter = new HTMLPageSetupEmitter ( this , isEmbeddable ) ; tableEmitter = new HTMLTableEmitter ( this , isEmbeddable ) ; textEmitter = new HTMLTextEmitter ( this , isEmbeddable ) ; containerEmitter = new HTMLContainerEmitter ( this , isEmbeddable ) ;
{ BoundedRangeModel hmod = hsb . getModel ( ) ; if ( hmod != null ) xpos = hmod . getValue ( ) ; <CTX> ChangeListener createScrollListener ( ) { return new ChangeListener ( ) { public void stateChanged ( ChangeEvent event ) { int xpos = 0 ; int ypos = 0 ; JScrollBar vsb = JScrollPane . this . getVerticalScrollBar ( ) ; JScrollBar hsb = JScrollPane . this . getHorizontalScrollBar ( ) ; if ( vsb != null ) { BoundedRangeModel vmod = vsb . getModel ( ) ; if ( vmod != null ) ypos = vmod . getValue ( ) ; } if ( hsb != null ) { BoundedRangeModel hmod = hsb . getModel ( ) ; if ( hmod != null ) xpos = hmod . getValue ( ) ; } if ( JScrollPane . this . viewport != null ) JScrollPane . this . viewport . setViewPosition ( new Point ( xpos , ypos ) ) ; } } ; }	xpos = hsb . getValue ( ) ; Point pt = new Point ( xpos , ypos ) ; if ( vp != null && vp . getViewPosition ( ) != pt ) vp . setViewPosition ( pt ) ;
result = serializer . deserialize ( new StringReader ( writer . toString ( ) ) ) ; <CTX> public void doRoundTrip ( ObjectSerializer serializer , ObjectSerializer deserializer ) throws Exception { StringWriter writer = new StringWriter ( ) ; serializer . serialize ( writer , original ) ; result = serializer . deserialize ( new StringReader ( writer . toString ( ) ) ) ; }	result = deserializer . deserialize ( new StringReader ( writer . toString ( ) ) ) ;
Assert . assert ( c . getTag ( ) . equals ( Tag . get ( 0 ) ) ) ; <CTX> public ASN 1 Value decode ( InputStream istream ) throws InvalidBERException , IOException { CHOICE c = ( CHOICE ) choicet . decode ( istream ) ; if ( c . getTag ( ) == SEQUENCE . TAG ) { return createIssuerAndSerialNumber ( ( IssuerAndSerialNumber ) c . getValue ( ) ) ; } else { Assert . assert ( c . getTag ( ) . equals ( Tag . get ( 0 ) ) ) ; / / EXPLICIT e = ( EXPLICIT ) c . getValue ( ) ; / / ASN 1 Value dski = e . getContent ( ) ; / / OCTET_STRING ski = ( OCTET_STRING ) e . getContent ( ) ; OCTET_STRING ski = ( OCTET_STRING ) c . getValue ( ) ; return createSubjectKeyIdentifier ( ski ) ; } }	Assert ._assert ( c . getTag ( ) . equals ( Tag . get ( 0 ) ) ) ;
return Utilities . drawTabbedText ( segment , x , y , g , this , 0 ) ; <CTX> protected int drawSelectedText ( Graphics g , int x , int y , int p 0 , int p 1 ) throws BadLocationException { g . setColor ( selectedColor ) ; Segment segment = getLineBuffer ( ) ; getDocument ( ) . getText ( p 0 , p 1 - p 0 , segment ) ; return Utilities . drawTabbedText ( segment , x , y , g , this , 0 ) ; }	return Utilities . drawTabbedText ( segment , x , y , g , this , segment . offset ) ;
concedes = Concede . concede ( masterFrame , attacker , defender ) ; <CTX> private void doFight ( String hexLabel , Player player ) { if ( summonAngel != null ) { Legion donor = getFirstFriendlyLegion ( hexLabel , player ) ; if ( donor != null ) { player . setDonor ( donor ) ; summonAngel . updateChits ( ) ; summonAngel . repaint ( ) ; donor . getMarker ( ) . repaint ( ) ; } return ; } / / Do not allow clicking on engagements if one is / / already being resolved . if ( isEngagement ( hexLabel ) && ! engagementInProgress ) { engagementInProgress = true ; Legion attacker = getFirstFriendlyLegion ( hexLabel , player ) ; Legion defender = getFirstEnemyLegion ( hexLabel , player ) ; attacker . sortCritters ( ) ; defender . sortCritters ( ) ; if ( defender . canFlee ( ) ) { / / Fleeing gives half points and denies the / / attacker the chance to summon an angel . boolean flees ; if ( defender . getPlayer ( ) . getOption ( Options . autoFlee ) ) { flees = defender . getPlayer ( ) . aiFlee ( defender , attacker ) ; } else { flees = Concede . flee ( masterFrame , defender , attacker ) ; } if ( flees ) { handleConcession ( defender , attacker , true ) ; return ; } } / / The attacker may concede now without / / allowing the defender a reinforcement . boolean concedes ; if ( attacker . getPlayer ( ) . getOption ( Options . autoFlee ) ) { concedes = attacker . getPlayer ( ) . aiConcede ( attacker , defender ) ; } else { concedes = Concede . concede ( masterFrame , attacker , defender ) ; } if ( concedes ) { handleConcession ( attacker , defender , false ) ; return ; } / / The players may agree to a negotiated settlement . NegotiationResults results = Negotiate . negotiate ( masterFrame , attacker , defender ) ; if ( results . isSettled ( ) ) { handleNegotiation ( results , attacker , defender ) ; return ; } else { / / Battle / / Reveal both legions to all players . attacker . revealAllCreatures ( ) ; defender . revealAllCreatures ( ) ; battle = new Battle ( this , attacker . getMarkerId ( ) , defender . getMarkerId ( ) , Battle . DEFENDER , hexLabel , 1 , Battle . MOVE ) ; battle . init ( ) ; } } }	concedes = Concede . concede ( frame , attacker , defender ) ;
MylarContext taskscape = activeContext . getTaskscapeMap ( ) . get ( taskId ) ; <CTX> public void saveTaskscape ( String taskId , String path ) { MylarContext taskscape = activeContext . getTaskscapeMap ( ) . get ( taskId ) ; if ( taskscape == null ) { return ; } else { taskscape . collapse ( ) ; externalizer . writeXMLTaskscapeToFile ( taskscape , getFileForTaskscape ( path ) ) ; } }	MylarContext taskscape = activeContext . getContextMap ( ) . get ( taskId ) ;
setFileGroupingState (_makeProjectFileGroupingState ( buildDir , projectFile , srcFiles ) ) ; <CTX> public File [ ] openProject ( File projectFile ) throws IOException { final ProjectFileIR ir ; final File [ ] srcFiles ; / / File projectRoot = projectFile . getParentFile ( ) ; ir = ProjectFileParser . ONLY . parse ( projectFile ) ; srcFiles = ir . getSourceFiles ( ) ; IAWTContainerNavigatorActor newNav = AWTContainerNavigatorFactory . Singleton . makeTreeNavigator ( projectFile . getName ( ) , getDocumentNavigator ( ) ) ; setDocumentNavigator ( newNav ) ; File buildDir = ( ir . getBuildDirectory ( ) . length > 0 ) ? ir . getBuildDirectory ( ) [ 0 ] : null ; setFileGroupingState (_makeProjectFileGroupingState ( buildDir , projectFile , srcFiles ) ) ; String projfilepath = projectFile . getCanonicalPath ( ) ; String tlp = projfilepath . substring ( 0 , projfilepath . lastIndexOf ( File . separator ) ) ; newNav . setTopLevelPath ( tlp ) ; File [ ] projectclasspaths = ir . getClasspath ( ) ; Vector < File > currentclasspaths = DrJava . getConfig ( ) . getSetting ( OptionConstants . EXTRA_CLASSPATH ) ; for ( int i = 0 ; i < projectclasspaths . length ; i ++ ) { currentclasspaths . add ( projectclasspaths [ i ] . getAbsoluteFile ( ) ) ; } DrJava . getConfig ( ) . setSetting ( OptionConstants . EXTRA_CLASSPATH , currentclasspaths ) ; return srcFiles ; }	File mainClass ; try { mainClass = ir . getJarMainClass ( ) ; if ( mainClass != null ) { mainClass = new File ( projectFile . getParentFile ( ) . getPath ( ) , mainClass . getPath ( ) ) . getCanonicalFile ( ) ; } } catch ( IOException e ) { mainClass = null ; } setFileGroupingState (_makeProjectFileGroupingState ( mainClass , buildDir , projectFile , srcFiles ) ) ;
item . setEnabled ( true ) ; item . setIcon ( null ) ; <CTX> public void pluginStopped ( PluginEvent e ) { Plugin plugin = e . getPlugin ( ) ; synchronized ( serviceInfoToReceiveMap ) { for ( Iterator iter = serviceInfoToReceiveMap . entrySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) iter . next ( ) ; if ( entry . getValue ( ) == plugin ) { serviceInfoToReceiveMap . remove ( entry . getKey ( ) ) ; } } } / / need to make sure that the menu item tracking this item has it s icon and enabled state updade JMenuItem item = locateMatchingMenuItem ( plugin . getName ( ) ) ; item . setEnabled ( true ) ; item . setIcon ( null ) ; discoveredDevices . fireContentsChanged ( ) ; } } ) ;	if ( item != null ) { item . setEnabled ( true ) ; item . setIcon ( null ) ; }
return newString ( getValue ( ) . toLowerCase ( ) ) ; <CTX> public RubyString downcase ( ) { return newString ( getValue ( ) . toLowerCase ( ) ) ; }	return newString ( toString ( ) . toLowerCase ( ) ) ;
if ( listChangeListeners == listener ) { listChangeListeners = null ; if ( ! hasListeners ( ) ) { lastListenerRemoved ( ) ; } return ; } if ( listChangeListeners instanceof Collection ) { Collection listenerList = ( Collection ) listChangeListeners ; listenerList . remove ( listener ) ; if ( listenerList . isEmpty ( ) ) { listChangeListeners = null ; if ( ! hasListeners ( ) ) { lastListenerRemoved ( ) ; } } } <CTX> public synchronized void removeListChangeListener ( IListChangeListener listener ) { if ( listChangeListeners == listener ) { listChangeListeners = null ; if ( ! hasListeners ( ) ) { lastListenerRemoved ( ) ; } return ; } if ( listChangeListeners instanceof Collection ) { Collection listenerList = ( Collection ) listChangeListeners ; listenerList . remove ( listener ) ; if ( listenerList . isEmpty ( ) ) { listChangeListeners = null ; if ( ! hasListeners ( ) ) { lastListenerRemoved ( ) ; } } } }	removeListener ( ListChangeEvent . TYPE , listener ) ;
switchParamterType ( ) ; <CTX> public void widgetSelected ( SelectionEvent e ) { switchParamterType ( ) ; }	changeControlType ( ) ;
, selectedColumns , query . getRowExpressions ( ) ) ; <CTX> public IExtractionResults extract ( ) throws EngineException { if ( instanceId == null ) return null ; if ( currentResult != null ) return currentResult ; assert executionContext . getDataEngine ( ) != null ; DataEngine dataEngine = executionContext . getDataEngine ( ) . getDataEngine ( ) ; ReportItemDesign rptItem = ( ReportItemDesign ) report . getReportItemByID ( instanceId . getComponentID ( ) ) ; assert rptItem != null ; IBaseQueryDefinition query = rptItem . getQuery ( ) ; validateSelectedColumns ( query ) ; DataID dataId = instanceId . getDataID ( ) ; InstanceID instId = instanceId ; while ( instId != null && dataId == null ) { instId = instId . getParentID ( ) ; if ( instId != null ) { dataId = instId . getDataID ( ) ; } } if ( dataId == null ) return null ; DataSetID dataSetId = dataId . getDataSetID ( ) ; assert dataSetId != null ; String queryResultName = dataSetId . getDataSetName ( ) ; if ( resultMetaList == null ) { resultMetaList = new ArrayList ( ) ; } else { resultMetaList . clear ( ) ; } if ( queryResultName != null ) { try { IQueryResults queryResults = dataEngine . getQueryResults ( queryResultName ) ; assert queryResults . getResultIterator ( ) != null ; currentResult = new ExtractionResults ( queryResults . getResultIterator ( ) , selectedColumns , query . getRowExpressions ( ) ) ; resultMetaList . add ( currentResult . getResultMetaData ( ) ) ; return currentResult ; } catch ( BirtException e ) { e . printStackTrace ( ) ; } } else { DataSetID parentId = dataSetId . getParentID ( ) ; assert parentId != null ; try { queryResultName = parentId . getDataSetName ( ) ; DataSetID parId = parentId ; while ( queryResultName == null && parId != null ) { parId = parId . getParentID ( ) ; if ( parId != null ) queryResultName = parId . getDataSetName ( ) ; } assert queryResultName != null ; IQueryResults parentQueryResult = dataEngine . getQueryResults ( queryResultName ) ; assert parentQueryResult != null ; IResultIterator iter = parentQueryResult . getResultIterator ( ) ; long rowid = dataSetId . getRowID ( ) ; int i = 0 ; while ( iter . next ( ) && i ++ < rowid ) ; IResultIterator subIter = iter . getSecondaryIterator ( dataSetId . getQueryName ( ) , executionContext . getScope ( ) ) ; currentResult = new ExtractionResults ( subIter , selectedColumns , query . getRowExpressions ( ) ) ; resultMetaList . add ( currentResult . getResultMetaData ( ) ) ; return currentResult ; } catch ( BirtException be ) { be . printStackTrace ( ) ; } } return null ; }	, selectedColumns , getScriptExpressions ( query . getRowExpressions ( ) ) ) ;
new GlobalBuildAction ( CUIPlugin . getDefault ( ) . getActiveWorkbenchWindow ( ) , IncrementalProjectBuilder . INCREMENTAL_BUILD ) . run ( ) ; <CTX> public void triggerBuild ( ) { if ( fFilesSaved && ResourcesPlugin . getWorkspace ( ) . getDescription ( ) . isAutoBuilding ( ) ) { new GlobalBuildAction ( CUIPlugin . getDefault ( ) . getActiveWorkbenchWindow ( ) , IncrementalProjectBuilder . INCREMENTAL_BUILD ) . run ( ) ; } }	new GlobalBuildAction ( CUIPlugin . getActiveWorkbenchWindow ( ) , IncrementalProjectBuilder . INCREMENTAL_BUILD ) . run ( ) ;
execFile . getProject ( ) , <CTX> private ICWatchpoint createWatchpoint ( ICDIWatchpoint cdiWatchpoint ) throws CDIException , CoreException { IFile execFile = getExecFile ( ) ; String sourceHandle = execFile . getFullPath ( ) . toOSString ( ) ; ICWatchpoint watchpoint = CDIDebugModel . createWatchpoint ( sourceHandle , execFile . getProject ( ) , cdiWatchpoint . isWriteType ( ) , cdiWatchpoint . isReadType ( ) , cdiWatchpoint . getWatchExpression ( ) , cdiWatchpoint . isEnabled ( ) , cdiWatchpoint . getCondition ( ) . getIgnoreCount ( ) , cdiWatchpoint . getCondition ( ) . getExpression ( ) , false ) ; getBreakpointMap ( ) . put ( watchpoint , cdiWatchpoint ) ; ( ( CBreakpoint ) watchpoint ) . register ( true ) ; return watchpoint ; }	getProject ( ) ,
java . util . Iterator iter = itemsToRemove . iterator ( ) ; <CTX> private void revokeActionSetFromMenu ( IMenuManager menuMgr , String actionsetId ) { IContributionItem [ ] items = menuMgr . getItems ( ) ; ArrayList itemsToRemove = new ArrayList ( ) ; String id ; for ( int i = 0 ; i < items . length ; i ++ ) if ( items [ i ] instanceof IMenuManager ) { revokeActionSetFromMenu ( ( IMenuManager ) items [ i ] , actionsetId ) ; } else if ( items [ i ] instanceof ActionSetContributionItem ) { id = ( ( ActionSetContributionItem ) items [ i ] ) . getActionSetId ( ) ; if ( id . equals ( actionsetId ) ) itemsToRemove . add ( items [ i ] ) ; } else if ( items [ i ] instanceof Separator ) { id = ( ( Separator ) items [ i ] ) . getId ( ) ; if ( id . equals ( actionsetId ) ) itemsToRemove . add ( items [ i ] ) ; } else if ( items [ i ] instanceof GroupMarker ) { id = ( ( GroupMarker ) items [ i ] ) . getId ( ) ; if ( id . equals ( actionsetId ) ) itemsToRemove . add ( items [ i ] ) ; } java . util . Iterator iter = itemsToRemove . iterator ( ) ; while ( iter . hasNext ( ) ) { IContributionItem item = ( IContributionItem ) iter . next ( ) ; menuMgr . remove ( item ) ; } menuMgr . update ( true ) ; }	Iterator iter = itemsToRemove . iterator ( ) ;
return new PartOfTable_users ( rs ) ; <CTX> public Object mapOneRow ( ResultSet rs ) throws SQLException { return new PartOfTable_users ( rs ) ; }	return new PartOfTable_roles ( rs ) ;
IViewPart test = findView ( id ) ; return ( view == test ) ; <CTX> public boolean containsView ( IViewPart view ) { String id = view . getSite ( ) . getId ( ) ; IViewPart test = findView ( id ) ; return ( view == test ) ; }	IViewReference ref = findView ( id ) ; return ( view == ref . getPart ( false ) ) ;
Object result = all_acks_received . getResultWithTimeout ( timeout ) ; <CTX> public boolean waitForAllAcks ( long timeout ) throws TimeoutException { if ( missing_acks . size ( ) == 0 ) return true ; Object result = all_acks_received . getResultWithTimeout ( timeout ) ; return result != null && result instanceof Boolean && ( ( Boolean ) result ) . booleanValue ( ) ; }	Object result = all_acks_received . getResult ( ) ;
Query query = createQuery ( buildCountHql ( ) ) ; <CTX> public int getListSize ( Object parent , ListParams params ) { Query query = createQuery ( buildCountHql ( ) ) ; if ( params . getFilter ( ) != null ) { query . setProperties ( params . getFilter ( ) ) ; } Number size = ( Number ) query . uniqueResult ( ) ; if ( size == null ) { return 0 ; } return size . intValue ( ) ; }	Query query = createQuery ( buildCountHql ( params ) ) ;
totalRunTime . put ( inspectionID , new Long ( runTime ) ) ; <CTX> public void reportRun ( String inspectionID , long runTime ) { synchronized ( lock ) { final Integer count = ( Integer ) totalRunCount . get ( inspectionID ) ; if ( count == null ) { totalRunCount . put ( inspectionID , new Integer ( 1 ) ) ; } else { totalRunCount . put ( inspectionID , new Integer ( count . intValue ( ) + 1 ) ) ; } final Long runTimeSoFar = ( Long ) totalRunTime . get ( inspectionID ) ; if ( runTimeSoFar == null ) { totalRunTime . put ( inspectionID , new Long ( runTime ) ) ; } else { totalRunTime . put ( inspectionID , new Long ( runTimeSoFar . longValue ( ) + runTime ) ) ; } } }	totalRunTime . put ( inspectionID , runTime ) ;
Node . Target switchBreakTarget = new Node . Target ( ) ; <CTX> void closeSwitch ( Node switchBlock ) { if ( switchBlock . getType ( ) != Token . BLOCK ) throw Kit . codeBug ( ) ; Node . Jump switchNode = ( Node . Jump ) switchBlock . getFirstChild ( ) ; if ( switchNode . getType ( ) != Token . SWITCH ) throw Kit . codeBug ( ) ; Node . Target switchBreakTarget = new Node . Target ( ) ; / / switchNode . target is only used by NodeTransformer / / to detect switch end switchNode . target = switchBreakTarget ; Node . Target defaultTarget = switchNode . getDefault ( ) ; if ( defaultTarget == null ) { defaultTarget = switchBreakTarget ; } switchBlock . addChildAfter ( makeJump ( Token . GOTO , defaultTarget ) , switchNode ) ; switchBlock . addChildToBack ( switchBreakTarget ) ; }	Node switchBreakTarget = Node . newTarget ( ) ;
names = new String [ itsData . itsVariableTable . size ( ) + 1 ] ; names [ 0 ] = itsData . itsName ; for ( int i = 0 ; i < itsData . itsVariableTable . size ( ) ; i ++ ) names [ i + 1 ] = itsData . itsVariableTable . getName ( i ) ; <CTX> void init ( Context cx ) { / / probably too much copying going on from theData to the InterpretedFunction object / / should pass them as parameters - unless we need them in the data block anyway ? names = new String [ itsData . itsVariableTable . size ( ) + 1 ] ; names [ 0 ] = itsData . itsName ; for ( int i = 0 ; i < itsData . itsVariableTable . size ( ) ; i ++ ) names [ i + 1 ] = itsData . itsVariableTable . getName ( i ) ; argCount = ( short ) itsData . itsVariableTable . getParameterCount ( ) ; source = itsData . itsSource ; nestedFunctions = itsData . itsNestedFunctions ; if ( cx != null ) version = ( short ) cx . getLanguageVersion ( ) ; }	functionName = itsData . itsName ; int N = itsData . itsVariableTable . size ( ) ; if ( N != 0 ) { argNames = new String [ N ] ; for ( int i = 0 ; i != N ; i ++ ) { argNames [ i ] = itsData . itsVariableTable . getName ( i ) ; } }
equals &= Util . equals ( activePartId , castedObject . activePartId ) ; equals &= Util . equals ( activePerspectiveId , castedObject . activePerspectiveId ) ; <CTX> public boolean equals ( Object object ) { if ( ! ( object instanceof EnabledSubmission ) ) return false ; EnabledSubmission castedObject = ( EnabledSubmission ) object ; boolean equals = true ; equals &= Util . equals ( activePartId , castedObject . activePartId ) ; equals &= Util . equals ( activePerspectiveId , castedObject . activePerspectiveId ) ; equals &= Util . equals ( contextId , castedObject . contextId ) ; return equals ; }	equals &= Util . equals ( activePerspectiveDescriptor , castedObject . activePerspectiveDescriptor ) ; equals &= Util . equals ( activeWorkbenchSite , castedObject . activeWorkbenchSite ) ;
return same ? ff : DataSampling . resample ( ff , res , null ) ; <CTX> protected Data getImageData ( int [ ] pos ) { Data d = super . getImageData ( pos ) ; if ( ! ( d instanceof FlatField ) ) return d ; FlatField ff = ( FlatField ) d ; GriddedSet set = ( GriddedSet ) ff . getDomainSet ( ) ; int [ ] len = set . getLengths ( ) ; int [ ] res = new int [ len . length ] ; boolean same = true ; int [ ] maxRes = handler . getWindow ( ) . getManager ( ) . getStackResolution ( ) ; for ( int i = 0 ; i < len . length ; i ++ ) { if ( len [ i ] > maxRes [ i ] ) { same = false ; res [ i ] = maxRes [ i ] ; } else res [ i ] = len [ i ] ; } return same ? ff : DataSampling . resample ( ff , res , null ) ; }	try { return VisUtil . resample ( ff , res , null ) ; } catch ( VisADException exc ) { exc . printStackTrace ( ) ; } catch ( RemoteException exc ) { exc . printStackTrace ( ) ; } return null ;
boolean eof = false ; while ( buffer . hasRemaining ( ) ) { int bytesRead = ( ( ReadableByteChannel ) channel ) . read ( buffer ) ; if ( bytesRead < 0 ) { eof = true ; break ; <CTX> public String sysread ( int length ) throws EOFException , BadDescriptorException , IOException { checkReadable ( ) ; checkBuffered ( ) ; ByteBuffer buffer = ByteBuffer . allocate ( length ) ; boolean eof = false ; while ( buffer . hasRemaining ( ) ) { int bytesRead = ( ( ReadableByteChannel ) channel ) . read ( buffer ) ; if ( bytesRead < 0 ) { eof = true ; break ; } if ( bytesRead == 0 ) { / / only should happen for nonblocking IO . . . break and allow the next call to try again break ; } } if ( buffer . position ( ) == 0 && eof == true ) { throw new EOFException ( ) ; } byte [ ] ret ; if ( buffer . hasRemaining ( ) ) { buffer . flip ( ) ; ret = new byte [ buffer . remaining ( ) ] ; buffer . get ( ret ) ; } else { ret = buffer . array ( ) ; } return RubyString . bytesToString ( ret ) ; }	int bytes_read = 0 ; do { bytes_read = ( ( ReadableByteChannel ) channel ) . read ( buffer ) ; if ( bytes_read < 0 ) { throw new EOFException ( ) ;
if ( elems . length > 1 ) { <CTX> public ICElement getCElement ( ) { ITypeReference ref = getResolvedReference ( ) ; if ( ref != null ) { ICElement [ ] elems = ref . getCElements ( ) ; if ( elems . length > 1 ) { for ( int i = 0 ; i < elems . length ; ++ i ) { ICElement elem = elems [ i ] ; if ( elem . getElementType ( ) == fElementType && elem . getElementName ( ) . equals ( getName ( ) ) ) { / / TODO should check fully qualified name return elem ; } } } else if ( elems . length == 1 ) { return elems [ 0 ] ; } } return null ; }	if ( elems != null && elems . length > 0 ) { if ( elems . length == 1 ) return elems [ 0 ] ;
if ( productName != null ) newShell . setText ( NLS . bind ( WorkbenchMessages . AboutFeaturesDialog_shellTitle , productName ) ) ; <CTX> protected void configureShell ( Shell newShell ) { super . configureShell ( newShell ) ; if ( productName != null ) newShell . setText ( NLS . bind ( WorkbenchMessages . AboutFeaturesDialog_shellTitle , productName ) ) ; PlatformUI . getWorkbench ( ) . getHelpSystem ( ) . setHelp ( newShell , IWorkbenchHelpContextIds . ABOUT_FEATURES_DIALOG ) ; }	if ( productName != null ) { newShell . setText ( NLS . bind ( WorkbenchMessages . AboutFeaturesDialog_shellTitle , productName ) ) ; }
Node createDoWhile ( Node body , Node cond , int lineno ) <CTX> Node createDoWhile ( Node body , Node cond , int lineno ) { return createLoop ( LOOP_DO_WHILE , body , cond , null , null , lineno ) ; }	Node createDoWhile ( Node loop , Node body , Node cond )
return eDynamicGet ( eFeature , resolve ) ; <CTX> public Object eGet ( EStructuralFeature eFeature , boolean resolve ) { switch ( eDerivedStructuralFeatureID ( eFeature ) ) { case ComponentPackage . AXIS__ TYPE : return getType ( ) ; case ComponentPackage . AXIS__ TITLE : return getTitle ( ) ; case ComponentPackage . AXIS__ SUB_TITLE : return getSubTitle ( ) ; case ComponentPackage . AXIS__ TITLE_POSITION : return getTitlePosition ( ) ; case ComponentPackage . AXIS__ ASSOCIATED_AXES : return getAssociatedAxes ( ) ; case ComponentPackage . AXIS__ ANCILLARY_AXES : return getAncillaryAxes ( ) ; case ComponentPackage . AXIS__ SERIES_DEFINITIONS : return getSeriesDefinitions ( ) ; case ComponentPackage . AXIS__ GAP_WIDTH : return new Double ( getGapWidth ( ) ) ; case ComponentPackage . AXIS__ ORIENTATION : return getOrientation ( ) ; case ComponentPackage . AXIS__ LINE_ATTRIBUTES : return getLineAttributes ( ) ; case ComponentPackage . AXIS__ LABEL : return getLabel ( ) ; case ComponentPackage . AXIS__ FORMAT_SPECIFIER : return getFormatSpecifier ( ) ; case ComponentPackage . AXIS__ LABEL_POSITION : return getLabelPosition ( ) ; case ComponentPackage . AXIS__ STAGGERED : return isStaggered ( ) ? Boolean . TRUE : Boolean . FALSE ; case ComponentPackage . AXIS__ MARKER_LINES : return getMarkerLines ( ) ; case ComponentPackage . AXIS__ MARKER_RANGES : return getMarkerRanges ( ) ; case ComponentPackage . AXIS__ MAJOR_GRID : return getMajorGrid ( ) ; case ComponentPackage . AXIS__ MINOR_GRID : return getMinorGrid ( ) ; case ComponentPackage . AXIS__ SCALE : return getScale ( ) ; case ComponentPackage . AXIS__ ORIGIN : return getOrigin ( ) ; case ComponentPackage . AXIS__ PRIMARY_AXIS : return isPrimaryAxis ( ) ? Boolean . TRUE : Boolean . FALSE ; case ComponentPackage . AXIS__ CATEGORY_AXIS : return isCategoryAxis ( ) ? Boolean . TRUE : Boolean . FALSE ; case ComponentPackage . AXIS__ PERCENT : return isPercent ( ) ? Boolean . TRUE : Boolean . FALSE ; } return eDynamicGet ( eFeature , resolve ) ; }	return super . eGet ( featureID , resolve , coreType ) ;
NodeIterator iterator = new TypedDescendantIterator ( type ) ; iterator . setStartNode ( 1 ) ; <CTX> public NodeIterator getTypedDescendantIterator ( int type ) { NodeIterator iterator = new TypedDescendantIterator ( type ) ; iterator . setStartNode ( 1 ) ; return ( iterator ) ; }	NodeIterator iterator ; if ( type == ELEMENT ) iterator = new FilterIterator ( new DescendantIterator ( ) , getElementFilter ( ) ) ; else iterator = new TypedDescendantIterator ( type ) ;
return runtime . getFalse ( ) ; <CTX> public IRubyObject equal ( IRubyObject other ) { if ( this == other ) { return runtime . getTrue ( ) ; } else if ( ! ( other instanceof RubyStruct ) ) { return runtime . getFalse ( ) ; } else if ( getMetaClass ( ) != other . getMetaClass ( ) ) { return runtime . getFalse ( ) ; } else { for ( int i = 0 ; i < values . length ; i ++ ) { if ( ! values [ i ] . equals ( ( ( RubyStruct ) other ) . values [ i ] ) ) { return runtime . getFalse ( ) ; } } return runtime . getTrue ( ) ; } }	return getRuntime ( ) . getFalse ( ) ;
model . addRow ( new Object [ ] { factory . getFullName ( ) , factory . getSpeed ( ) , Boolean . valueOf ( factory . isEnabled ( ) ) } ) ; <CTX> private void populateTable ( ) { Iterator < DetectorFactory > i = DetectorFactoryCollection . instance ( ) . factoryIterator ( ) ; while ( i . hasNext ( ) ) { DetectorFactory factory = i . next ( ) ; DefaultTableModel model = ( DefaultTableModel ) detectorTable . getModel ( ) ; model . addRow ( new Object [ ] { factory . getFullName ( ) , factory . getSpeed ( ) , Boolean . valueOf ( factory . isEnabled ( ) ) } ) ; factoryList . add ( factory ) ; } }	model . addRow ( new Object [ ] { factory . getShortName ( ) , factory . getSpeed ( ) , Boolean . valueOf ( factory . isEnabled ( ) ) } ) ;
case TypePackage . AREA_SERIES__ DATA_SET : return basicSetDataSet ( null , msgs ) ; <CTX> public NotificationChain eInverseRemove ( InternalEObject otherEnd , int featureID , Class baseClass , NotificationChain msgs ) { if ( featureID >= 0 ) { switch ( eDerivedStructuralFeatureID ( featureID , baseClass ) ) { case TypePackage . AREA_SERIES__ LABEL : return basicSetLabel ( null , msgs ) ; case TypePackage . AREA_SERIES__ DATA_DEFINITION : return ( ( InternalEList ) getDataDefinition ( ) ) . basicRemove ( otherEnd , msgs ) ; case TypePackage . AREA_SERIES__ DATA_POINT : return basicSetDataPoint ( null , msgs ) ; case TypePackage . AREA_SERIES__ DATA_SET : return basicSetDataSet ( null , msgs ) ; case TypePackage . AREA_SERIES__ TRIGGERS : return ( ( InternalEList ) getTriggers ( ) ) . basicRemove ( otherEnd , msgs ) ; case TypePackage . AREA_SERIES__ CURVE_FITTING : return basicSetCurveFitting ( null , msgs ) ; case TypePackage . AREA_SERIES__ MARKER : return basicSetMarker ( null , msgs ) ; case TypePackage . AREA_SERIES__ LINE_ATTRIBUTES : return basicSetLineAttributes ( null , msgs ) ; case TypePackage . AREA_SERIES__ SHADOW_COLOR : return basicSetShadowColor ( null , msgs ) ; default : return eDynamicInverseRemove ( otherEnd , featureID , baseClass , msgs ) ; } } return eBasicSetContainer ( null , featureID , msgs ) ; }	case TypePackage . AREA_SERIES__ DATA_SETS : return ( ( InternalEList ) getDataSets ( ) ) . basicRemove ( otherEnd , msgs ) ;
if ( cur . getRating ( ) > 0 ) { <CTX> public void redoRatings ( ) { try { Vector result = pedfile . check ( ) ; for ( int i = 0 ; i < table . getRowCount ( ) ; i ++ ) { MarkerResult cur = ( MarkerResult ) result . get ( i ) ; if ( cur . getRating ( ) > 0 ) { table . setValueAt ( new Boolean ( true ) , i , STATUS_COL ) ; } else { table . setValueAt ( new Boolean ( false ) , i , STATUS_COL ) ; } } changed = true ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }	int curRating = cur . getRating ( ) ; if ( curRating > 0 ) {
jCheckBoxToggleFullscreenActionPerformed ( evt ) ; <CTX> public void actionPerformed ( java . awt . event . ActionEvent evt ) { jCheckBoxToggleFullscreenActionPerformed ( evt ) ; }	jMenuItemCloseProjectActionPerformed ( evt ) ;
Picture buf = mAlbum . getPicture ( sel ) ; mAlbum . setPicture ( sel , mAlbum . getPicture ( sel - 1 ) ) ; mAlbum . setPicture ( sel - 1 , buf ) ; picturesList . setSelectedIndex ( sel - 1 ) ; <CTX> public void movePictureUp ( ) { int sel = picturesList . getSelectedIndex ( ) ; if ( sel > 0 ) { Picture buf = mAlbum . getPicture ( sel ) ; mAlbum . setPicture ( sel , mAlbum . getPicture ( sel - 1 ) ) ; mAlbum . setPicture ( sel - 1 , buf ) ; picturesList . setSelectedIndex ( sel - 1 ) ; } }	Picture buf = getCurrentAlbum ( ) . getPicture ( sel ) ; getCurrentAlbum ( ) . setPicture ( sel , getCurrentAlbum ( ) . getPicture ( sel - 1 ) ) ; getCurrentAlbum ( ) . setPicture ( sel - 1 , buf ) ; jPicturesList . setSelectedIndex ( sel - 1 ) ;
IPath sourcePath = new Path ( provider . getFullPath ( source ) ) ; IPath destContainerPath = pathname . removeLastSegments ( 1 ) ; IPath relativePath = destContainerPath . removeFirstSegments ( sourcePath . segmentCount ( ) ) . setDevice ( null ) ; return createContainersFor ( relativePath ) ; } <CTX> IContainer getDestinationContainerFor ( Object fileSystemObject ) throws CoreException { IPath pathname = new Path ( provider . getFullPath ( fileSystemObject ) ) ; if ( createContainerStructure ) return createContainersFor ( pathname . removeLastSegments ( 1 ) ) ; else { if ( source == fileSystemObject ) return null ; IPath sourcePath = new Path ( provider . getFullPath ( source ) ) ; IPath destContainerPath = pathname . removeLastSegments ( 1 ) ; IPath relativePath = destContainerPath . removeFirstSegments ( sourcePath . segmentCount ( ) ) . setDevice ( null ) ; return createContainersFor ( relativePath ) ; } }	IPath sourcePath = new Path ( provider . getFullPath ( source ) ) ; IPath destContainerPath = pathname . removeLastSegments ( 1 ) ; IPath relativePath = destContainerPath . removeFirstSegments ( sourcePath . segmentCount ( ) ) . setDevice ( null ) ; return createContainersFor ( relativePath ) ;
db . set_re_delim ( args . delim ) ; <CTX> public void set_re_delim ( DbDispatcher server ,__ db_re_delim_msg args ,__ db_re_delim_reply reply ) { try { db . set_re_delim ( args . delim ) ; reply . status = 0 ; } catch ( DbException e ) { e . printStackTrace ( DbServer . err ) ; reply . status = e . get_errno ( ) ; } }	db . setRecordDelimiter ( args . delim ) ;
return new GridInstance ( ( TableContent ) element ) ; <CTX> public static IReportElementInstance getInstance ( IElement element ) { if ( element == null ) return null ; if ( element instanceof CellContent ) return new CellInstance ( ( CellContent ) element ) ; if ( element instanceof DataContent ) return new DataItemInstance ( ( DataContent ) element ) ; if ( element instanceof ImageContent ) return new ImageInstance ( ( ImageContent ) element ) ; if ( element instanceof LabelContent ) return new LabelInstance ( ( LabelContent ) element ) ; if ( element instanceof ContainerContent ) return new ListInstance ( ( ContainerContent ) element ) ; if ( element instanceof RowContent ) return new RowInstance ( ( RowContent ) element ) ; if ( element instanceof TableContent ) { Object genBy = ( ( TableContent ) element ) . getGenerateBy ( ) ; if ( genBy instanceof TableItemDesign ) return new TableInstance ( ( TableContent ) element ) ; else if ( genBy instanceof GridItemDesign ) return new GridInstance ( ( TableContent ) element ) ; } if ( element instanceof TextContent ) return new TextItemInstance ( ( TextContent ) element ) ; if ( element instanceof ForeignContent ) { ForeignContent fc = ( ForeignContent ) element ; if ( IForeignContent . HTML_TYPE . equals ( fc . getRawType ( ) ) || IForeignContent . TEXT_TYPE . equals ( fc . getRawType ( ) ) || IForeignContent . TEMPLATE_TYPE . equals ( fc . getRawType ( ) ) ) return new TextItemInstance ( fc ) ; } return null ; }	return new GridInstance ( ( TableContent ) element , context ) ;
currentOffset += current . getTextLength ( ) ; <CTX> private int getNodeOffset ( ASTNode child ) { LOG . assertTrue ( child . getTreeParent ( ) == myParent ) ; ASTNode current = myParent . getFirstChildNode ( ) ; final Iterator < Pair < ASTNode , Integer >> iterator = myOffsets . iterator ( ) ; Pair < ASTNode , Integer > currentChange = iterator . hasNext ( ) ? iterator . next ( ) : null ; int currentOffset = 0 ; do { boolean counted = false ; while ( currentChange != null && currentOffset == currentChange . getSecond ( ) . intValue ( ) && child . getTreeNext ( ) != currentChange . getFirst ( ) ) { if ( current == currentChange . getFirst ( ) ) { counted = true ; current = current . getTreeNext ( ) ; } final ChangeInfo changeInfo = myChanges . get ( currentChange . getFirst ( ) ) ; currentOffset += changeInfo . getOldLength ( ) ; currentChange = iterator . hasNext ( ) ? iterator . next ( ) : null ; } if ( current == child ) break ; if ( current == null ) break ; if ( ! counted ) { currentOffset += current . getTextLength ( ) ; current = current . getTreeNext ( ) ; } } while ( true ) ; return currentOffset ; }	currentOldOffset += current . getTextLength ( ) ;
if ( changed . size ( ) > 0 ) { <CTX> public void send ( ) { Vector changed = new Vector ( ) ; for ( Enumeration i = optionComps . elements ( ) ; i . hasMoreElements ( ) ; ) { DialogOptionComponent comp = ( DialogOptionComponent ) i . nextElement ( ) ; if ( comp . hasChanged ( ) ) { changed . addElement ( comp . changedOption ( ) ) ; } } if ( changed . size ( ) > 0 ) { client . sendGameOptions ( texPass . getText ( ) , changed ) ; } }	if ( client != null && changed . size ( ) > 0 ) {
( ( DoubleValue ) getLeft ( ) . eval ( context , docs , contextSequence ) . convertTo ( Type . DECIMAL ) ) . getDouble ( ) ; <CTX> public Sequence eval ( StaticContext context , DocumentSet docs , Sequence contextSequence , Item contextItem ) throws XPathException { if ( contextItem != null ) contextSequence = contextItem . toSequence ( ) ; double lvalue = ( ( DoubleValue ) getLeft ( ) . eval ( context , docs , contextSequence ) . convertTo ( Type . DECIMAL ) ) . getDouble ( ) ; double rvalue = ( ( DoubleValue ) getRight ( ) . eval ( context , docs , contextSequence ) . convertTo ( Type . DECIMAL ) ) . getDouble ( ) ; double result = applyOperator ( lvalue , rvalue ) ; return new DoubleValue ( result ) ; }	( ( DoubleValue ) getLeft ( ) . eval ( docs , contextSequence ) . convertTo ( Type . DECIMAL ) ) . getDouble ( ) ;
return getAnimatedNumberAttribute ( null , SVG_POINTS_AT_Y_ATTRIBUTE , 0 f ) ; <CTX> public SVGAnimatedNumber getPointsAtY ( ) { return getAnimatedNumberAttribute ( null , SVG_POINTS_AT_Y_ATTRIBUTE , 0 f ) ; }	return pointsAtY ;
if ( model . getTreeView ( ) != null ) model . getTreeView ( ) . repaint ( ) ; <CTX> public void onDataObjectSave ( List nodes ) { switch ( model . getState ( ) ) { case DISCARDED : case NEW : case LOADING_THUMBNAILS : return ; default : break ; } if ( nodes == null ) { model . onDataObjectSave ( ) ; fireStateChange ( ) ; return ; } view . setCursor ( Cursor . getPredefinedCursor ( Cursor . WAIT_CURSOR ) ) ; DataSaveVisitor visitor = new DataSaveVisitor ( this , nodes ) ; Browser browser = model . getBrowser ( ) ; browser . accept ( visitor ) ; browser . getUI ( ) . repaint ( ) ; browser . setSelectedDisplay ( browser . getLastSelectedDisplay ( ) ) ; if ( model . getTreeView ( ) != null ) model . getTreeView ( ) . repaint ( ) ; model . onDataObjectSave ( ) ; view . setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; fireStateChange ( ) ; }	TreeView tv = model . getTreeView ( ) ; if ( tv != null ) tv . repaint ( ) ;
super . await ( ) ; <CTX> public void lock ( ) { try { super . await ( ) ; } catch ( InterruptedException ex ) { / / ignore } }	while ( super . getCount ( ) > 0 ) { try { super . await ( ) ; } catch ( InterruptedException ex ) { interrupted = true ; } }
checkIfReadOnly ( ) ; checkForOverflow ( ) ; <CTX> public ByteBuffer put ( byte value ) { checkIfReadOnly ( ) ; checkForOverflow ( ) ; int pos = position ( ) ; backing_buffer [ pos + array_offset ] = value ; position ( pos + 1 ) ; return this ; }	if ( ( limit - pos ) < length ) throw new BufferOverflowException ( ) ; checkArraySize ( src . length , offset , length ) ;
return Status . OK_STATUS ; } <CTX> public IStatus execute ( IProgressMonitor monitor , IAdaptable info ) throws ExecutionException { if ( isGeronimoRuntimeTarget ( ) ) { IVirtualComponent comp = ComponentCore . createComponent ( getProject ( ) , getComponentName ( ) ) ; if ( comp . getComponentTypeId ( ) . equals ( IModuleConstants . JST_WEB_MODULE ) ) { createGeronimoWebDeploymentPlan ( GeronimoUtils . getWebDeploymentPlanFile ( comp ) ) ; } else if ( comp . getComponentTypeId ( ) . equals ( IModuleConstants . JST_EJB_MODULE ) ) { createOpenEjbDeploymentPlan ( GeronimoUtils . getOpenEjbDeploymentPlanFile ( comp ) ) ; } else if ( comp . getComponentTypeId ( ) . equals ( IModuleConstants . JST_EAR_MODULE ) ) { createGeronimoApplicationDeploymentPlan ( GeronimoUtils . getApplicationDeploymentPlanFile ( comp ) ) ; } else if ( comp . getComponentTypeId ( ) . equals ( IModuleConstants . JST_CONNECTOR_MODULE ) ) { createConnectorDeploymentPlan ( GeronimoUtils . getConnectorDeploymentPlanFile ( comp ) ) ; } } return Status . OK_STATUS ; }	if ( IModuleConstants . JST_WEB_MODULE . equals ( type ) ) { createGeronimoWebDeploymentPlan ( GeronimoUtils . getWebDeploymentPlanFile ( comp ) ) ; } else if ( IModuleConstants . JST_EJB_MODULE . equals ( type ) ) { createOpenEjbDeploymentPlan ( GeronimoUtils . getOpenEjbDeploymentPlanFile ( comp ) ) ; } else if ( IModuleConstants . JST_EAR_MODULE . equals ( type ) ) { createGeronimoApplicationDeploymentPlan ( GeronimoUtils . getApplicationDeploymentPlanFile ( comp ) ) ; } else if ( IModuleConstants . JST_CONNECTOR_MODULE . equals ( type ) ) { createConnectorDeploymentPlan ( GeronimoUtils . getConnectorDeploymentPlanFile ( comp ) ) ; } } return Status . OK_STATUS ; }
super ( position ) ; <CTX> public NotNode ( ISourcePosition position , Node conditionNode ) { super ( position ) ; this . conditionNode = conditionNode ; }	super ( position , NodeTypes . NOTNODE ) ;
InitFuser initFuser = new InitFuser ( filterInfo ) ; <CTX> JMethodDeclaration makeInitFunction ( List filterInfo , JMethodDeclaration initWork ) { / / get init function of parent JMethodDeclaration parentInit = ( ( FilterInfo ) filterInfo . get ( 0 ) ) . filter . getParent ( ) . getInit ( ) ; / / make an init function builder out of < filterList > InitFuser initFuser = new InitFuser ( filterInfo ) ; / / traverse < parentInit > with initFuser parentInit . accept ( initFuser ) ; / / make the actual function return initFuser . getInitFunction ( ) ; }	InitFuser initFuser = new InitFuser ( filterInfo , result ) ;
void setLastPoll ( Date time ) <CTX> void setLastPoll ( Date time ) { m_lastPoll = new Timestamp ( time . getTime ( ) ) ; m_changed |= CHANGED_POLLTIME ; }	void setLastPoll ( String time ) throws ParseException
return new Integer ( Integer . parseInt ( s ) ) ; <CTX> public static Integer integerWithString ( String s ) { try { return new Integer ( Integer . parseInt ( s ) ) ; } catch ( Exception e ) { } return null ; }	return ERXConstant . integerForString ( s ) ;
swtGraphics . dispose ( ) ; <CTX> public void dispose ( ) { super . dispose ( ) ; if ( currentColor != null ) currentColor . dispose ( ) ; currentColor = null ; if ( currentFont != null ) currentFont . dispose ( ) ; currentFont = null ; if ( currentTransform != null ) currentTransform . dispose ( ) ; currentTransform = null ; swtGraphics . dispose ( ) ; swtGraphics = null ; }	if ( swtGraphics != null ) swtGraphics . dispose ( ) ;
{ if ( renderer == null ) throw new IllegalStateException ( NULL_RENDERER ) ; <CTX> public double [ ] getChannelStats ( int w ) { double [ ] result ; rwl . readLock ( ) . lock ( ) ; { if ( renderer == null ) throw new IllegalStateException ( NULL_RENDERER ) ; ChannelBinding [ ] cb = renderer . getChannelBindings ( ) ; / / FIXME / / double [ ] stats = cb [ w ] . getStats ( ) , copy = new double [ stats . length ] ; / / System . arraycopy ( stats , 0 , copy , 0 , stats . length ) ; } rwl . readLock ( ) . unlock ( ) ; return null ; / / FIXME copy ; / / NOTE : These stats are supposed to be read - only ; however we make a / / copy to be on the safe side . }	try { errorIfInvalidState ( ) ;
return false ; <CTX> public boolean performDrop ( Object data ) { Object selectedObject = ( ( IStructuredSelection ) TaskListView . getDefault ( ) . getViewer ( ) . getSelection ( ) ) . getFirstElement ( ) ; if ( selectedObject instanceof ITask ) { contentProvider . addTask ( ( ITask ) selectedObject ) ; updateEstimatedHours ( contentProvider ) ; tableViewer . refresh ( ) ; return true ; } else if ( selectedObject instanceof ITaskListElement ) { if ( MylarTaskListPlugin . getDefault ( ) . getHandlerForElement ( ( ITaskListElement ) selectedObject ) != null ) { ITask task = null ; if ( selectedObject instanceof ITask ) { task = ( ITask ) selectedObject ; } else if ( selectedObject instanceof IQueryHit ) { task = ( ( IQueryHit ) selectedObject ) . getOrCreateCorrespondingTask ( ) ; / / task = MylarTaskListPlugin . getDefault ( ) . getHandlerForElement ( / / ( ITaskListElement ) selectedObject ) . getCorrespondingTask ( ( IQueryHit ) selectedObject ) ; } if ( task != null ) { contentProvider . addTask ( task ) ; updateEstimatedHours ( contentProvider ) ; tableViewer . refresh ( ) ; return true ; } } return false ; } return false ; }	tableViewer . refresh ( ) ; return true ;
return getOffsetBefore ( myCurrentBlock ) + myCurrentBlock . getTextRange ( ) . getLength ( ) > mySettings . RIGHT_MARGIN ; <CTX> private boolean lineOver ( ) { if ( myCurrentBlock . containsLineFeeds ( ) ) return false ; return getOffsetBefore ( myCurrentBlock ) + myCurrentBlock . getTextRange ( ) . getLength ( ) > mySettings . RIGHT_MARGIN ; }	return getOffsetBefore ( myCurrentBlock . getBlock ( ) ) + myCurrentBlock . getTextRange ( ) . getLength ( ) > mySettings . RIGHT_MARGIN ;
martSchemas = new ArrayList ( this . schemaToDiagram . keySet ( ) ) ; for ( Iterator i = martSchemas . iterator ( ) ; i . hasNext ( ) ; ) { <CTX> public void synchroniseTabs ( ) { / / Add all table providers that we don t have yet . List martSchemas = new ArrayList ( this . datasetTabSet . getMart ( ) . getSchemas ( ) ) ; for ( Iterator i = martSchemas . iterator ( ) ; i . hasNext ( ) ; ) { Schema schema = ( Schema ) i . next ( ) ; if ( ! this . schemaToDiagram . containsKey ( schema ) ) this . addSchemaTab ( schema ) ; } / / Remove all our table providers that are not in the schema . martSchemas = new ArrayList ( this . schemaToDiagram . keySet ( ) ) ; for ( Iterator i = martSchemas . iterator ( ) ; i . hasNext ( ) ; ) { Schema schema = ( Schema ) i . next ( ) ; if ( ! martSchemas . contains ( schema ) ) this . removeSchemaTab ( schema ) ; } / / Synchronise our overview tab . this . allSchemasDiagram . synchroniseDiagram ( ) ; / / Synchronise our tab view contents . for ( int i = 1 ; i < this . getTabCount ( ) ; i ++ ) { JScrollPane scroller = ( JScrollPane ) this . getComponentAt ( i ) ; SchemaDiagram tableDiagram = ( SchemaDiagram ) scroller . getViewport ( ) . getView ( ) ; tableDiagram . synchroniseDiagram ( ) ; } / / Redraw . this . validate ( ) ; }	List ourSchemas = new ArrayList ( this . schemaToDiagram . keySet ( ) ) ; for ( Iterator i = ourSchemas . iterator ( ) ; i . hasNext ( ) ; ) {
if ( isClosing ) <CTX> public void run ( ) { / / Collect dirtyEditors ArrayList dirtyEditors = new ArrayList ( ) ; ArrayList dirtyEditorsInput = new ArrayList ( ) ; IWorkbenchWindow windows [ ] = getWorkbenchWindows ( ) ; for ( int i = 0 ; i < windows . length ; i ++ ) { IWorkbenchPage pages [ ] = windows [ i ] . getPages ( ) ; for ( int j = 0 ; j < pages . length ; j ++ ) { IEditorPart editors [ ] = pages [ j ] . getEditors ( ) ; for ( int k = 0 ; k < editors . length ; k ++ ) { IEditorPart editor = editors [ k ] ; if ( editor . isDirty ( ) ) { if ( ! dirtyEditorsInput . contains ( editor . getEditorInput ( ) ) ) { dirtyEditors . add ( editor ) ; dirtyEditorsInput . add ( editor . getEditorInput ( ) ) ; } } } } } if ( dirtyEditors . size ( ) > 0 ) { IWorkbenchWindow w = getActiveWorkbenchWindow ( ) ; if ( w == null ) w = windows [ 0 ] ; isClosing = EditorManager . saveAll ( dirtyEditors , true , w ) ; } if ( isClosing ) isClosing = windowManager . close ( ) ; }	if ( isClosing || force )
if ( target instanceof TaskAdapter ) { this . target = ( ( TaskAdapter ) target ) . getProxy ( ) ; <CTX> public NestedElementHandler ( DocumentHandler parentHandler , Object target , RuntimeConfigurable parentWrapper ) { super ( parentHandler ) ; if ( target instanceof TaskAdapter ) { this . target = ( ( TaskAdapter ) target ) . getProxy ( ) ; } else { this . target = target ; } this . parentWrapper = parentWrapper ; }	if ( parent instanceof TaskAdapter ) { this . parent = ( ( TaskAdapter ) parent ) . getProxy ( ) ;
return readers [ index ] . getImageCount ( id ) ; <CTX> public int getImageCount ( String id ) throws FormatException , IOException { if ( ! id . equals ( currentId ) ) initFile ( id ) ; return readers [ index ] . getImageCount ( id ) ; }	return readers [ current ] . getImageCount ( id ) ;
setDynaBean ( new WrapDynaBean ( dataType ) ) ; <CTX> public void setDataType ( Object dataType ) { this . dataType = dataType ; setDynaBean ( new WrapDynaBean ( dataType ) ) ; }	setDynaBean ( new ConvertingWrapDynaBean ( dataType ) ) ;
return MapFileOutputFormat . getReaders ( nfs , new File ( segmentDir , subDir ) ) ; <CTX> private MapFile . Reader [ ] getReaders ( String subDir ) throws IOException { return MapFileOutputFormat . getReaders ( nfs , new File ( segmentDir , subDir ) ) ; }	return MapFileOutputFormat . getReaders ( nfs , new File ( segmentDir , subDir ) , this . nutchConf ) ;
this . wrappedExp = wrappedExp ; <CTX> ExpectedTypeVisitor ( PsiExpression wrappedExp , boolean calculateTypeForComplexReferences ) { super ( ) ; this . wrappedExp = wrappedExp ; this . calculateTypeForComplexReferences = calculateTypeForComplexReferences ; }	this . wrappedExpression = wrappedExpression ;
addObjectActions ( ) ; addStaticActions ( ) ; <CTX> public void menuAboutToShow ( IMenuManager mgr ) { testForAdditions ( ) ; addObjectActions ( ) ; addStaticActions ( ) ; }	if ( menuWrapper != null ) { mgr = menuWrapper ; menuWrapper . removeAll ( ) ; } addObjectActions ( mgr ) ; addStaticActions ( mgr ) ;
t = OPT_ClassLoaderProxy . proxy . includesType ( exceptionTypes [ i ] . type , cand ) ; <CTX> public byte mustCatchException ( VM_Type cand ) { boolean seenMaybe = false ; byte t ; for ( int i = 0 ; i < exceptionTypes . length ; i ++ ) { t = OPT_ClassLoaderProxy . proxy . includesType ( exceptionTypes [ i ] . type , cand ) ; if ( t == YES ) return YES ; seenMaybe |= ( t == MAYBE ) ; } if ( seenMaybe ) return MAYBE ; else return NO ; }	t = OPT_ClassLoaderProxy . includesType ( exceptionTypes [ i ] . type , cand ) ;
AttributeSet e = createSmallAttributeSet ( null ) ; if ( sharedAttributeSets . containsKey ( e ) ) e = ( AttributeSet ) sharedAttributeSets . get ( e ) ; else sharedAttributeSets . put ( e , e ) ; return e ; <CTX> public AttributeSet getEmptySet ( ) { AttributeSet e = createSmallAttributeSet ( null ) ; if ( sharedAttributeSets . containsKey ( e ) ) e = ( AttributeSet ) sharedAttributeSets . get ( e ) ; else sharedAttributeSets . put ( e , e ) ; return e ; }	return SimpleAttributeSet . EMPTY ;
return null ; <CTX> public VirtualFile getParent ( ) { return null ; }	return myResourceBundle . getBaseDirectory ( ) ;
if ( active ) { parentActivation = parent . activateHandler ( localActivation ) ; parentActivations . add ( parentActivation ) ; } else { parentActivation = null ; } <CTX> private final IHandlerActivation doActivation ( final IHandlerActivation localActivation ) { final IHandlerActivation parentActivation ; if ( active ) { parentActivation = parent . activateHandler ( localActivation ) ; parentActivations . add ( parentActivation ) ; } else { parentActivation = null ; } localActivationsToParentActivations . put ( localActivation , parentActivation ) ; return localActivation ; }	parentActivation = parent . activateHandler ( localActivation ) ; parentActivations . add ( parentActivation ) ;
if ( ! realClauseSet ) initRealClause ( ) ; <CTX> public Constraint realClause ( ) { if ( ! realClauseSet ) initRealClause ( ) ; return realClause ; }	if ( ! realClauseSet ) { if ( isRootType ( ) ) { initRealClause ( ) ; } else { Constraint result = rootType ( ) . realClause ( ) ; result = result == null ? new Constraint_c ( ) : result . copy ( ) ; if ( depClause != null ) { result . addIn ( depClause ) ; } realClause = result ; } }
m_explorerTypeSettings = new ArrayList ( ) ; m_explorerTypeSettingsMap = new HashMap ( ) ; <CTX> public CmsWorkplaceManager ( ) { if ( CmsLog . LOG . isInfoEnabled ( ) ) { CmsLog . LOG . info ( Messages . get ( ) . key ( Messages . INIT_WORKPLACE_INITIALIZE_START_0 ) ) ; } m_locales = new ArrayList ( ) ; m_labelSiteFolders = new ArrayList ( ) ; m_localizedFolders = new ArrayList ( ) ; m_autoLockResources = true ; m_showUserGroupIcon = true ; m_dialogHandler = new HashMap ( ) ; m_views = new ArrayList ( ) ; m_exportPoints = new HashSet ( ) ; m_editorHandler = new CmsEditorHandler ( ) ; m_fileMaxUploadSize = - 1 ; m_explorerTypeSettings = new ArrayList ( ) ; m_explorerTypeSettingsMap = new HashMap ( ) ; m_defaultPropertiesOnStructure = true ; m_enableAdvancedPropertyTabs = true ; m_defaultUserSettings = new CmsDefaultUserSettings ( ) ; m_defaultAccess = new CmsExplorerTypeAccess ( ) ; m_galleries = new HashMap ( ) ; m_messages = new HashMap ( ) ; }	m_explorerTypeSettingsFromXml = new ArrayList ( ) ; m_explorerTypeSettingsFromModules = new ArrayList ( ) ;
if ( scanner . currentPosition == scanner . startPosition ) { scanner . currentPosition ++ ; <CTX> protected boolean moveRecoveryCheckpoint ( ) { int pos = lastCheckPoint ; / * reset scanner , and move checkpoint by one token * / scanner . startPosition = pos ; scanner . currentPosition = pos ; scanner . diet = false ; / / quit jumping over method bodies / * if about to restart , then no need to shift token * / if ( restartRecovery ) { lastIgnoredToken = - 1 ; scanner . currentLine = null ; return true ; } / * protect against shifting on an invalid token * / lastIgnoredToken = nextIgnoredToken ; nextIgnoredToken = - 1 ; do { try { nextIgnoredToken = scanner . getNextToken ( ) ; if ( scanner . currentPosition == scanner . startPosition ) { scanner . currentPosition ++ ; / / on fake completion identifier nextIgnoredToken = - 1 ; } } catch ( InvalidInputException e ) { pos = scanner . currentPosition ; } } while ( nextIgnoredToken < 0 ) ; if ( nextIgnoredToken == TokenNameEOF ) { / / no more recovery after this point if ( currentToken == TokenNameEOF ) { / / already tried one iteration on EOF scanner . currentLine = null ; return false ; } } lastCheckPoint = scanner . currentPosition ; / * reset scanner again to previous checkpoint location * / scanner . startPosition = pos ; scanner . currentPosition = pos ; scanner . commentPtr = - 1 ; scanner . foundTaskCount = 0 ; scanner . currentLine = null ; return true ; / * The following implementation moves the checkpoint location by one line : int pos = lastCheckPoint ; / / reset scanner , and move checkpoint by one token scanner . startPosition = pos ; scanner . currentPosition = pos ; scanner . diet = false ; / / quit jumping over method bodies / / if about to restart , then no need to shift token if ( restartRecovery ) { lastIgnoredToken = - 1 ; return true ; } / / protect against shifting on an invalid token lastIgnoredToken = nextIgnoredToken ; nextIgnoredToken = - 1 ; boolean wasTokenizingWhiteSpace = scanner . tokenizeWhiteSpace ; scanner . tokenizeWhiteSpace = true ; checkpointMove : do { try { nextIgnoredToken = scanner . getNextToken ( ) ; switch ( nextIgnoredToken ) { case Scanner . TokenNameWHITESPACE : if ( scanner . getLineNumber ( scanner . startPosition ) == scanner . getLineNumber ( scanner . currentPosition ) ) { nextIgnoredToken = - 1 ; } break ; case TokenNameSEMICOLON : case TokenNameLBRACE : case TokenNameRBRACE : break ; case TokenNameIdentifier : if ( scanner . currentPosition == scanner . startPosition ) { scanner . currentPosition ++ ; / / on fake completion identifier } default : nextIgnoredToken = - 1 ; break ; case TokenNameEOF : break checkpointMove ; } } catch ( InvalidInputException e ) { pos = scanner . currentPosition ; } } while ( nextIgnoredToken < 0 ) ; scanner . tokenizeWhiteSpace = wasTokenizingWhiteSpace ; if ( nextIgnoredToken == TokenNameEOF ) { / / no more recovery after this point if ( currentToken == TokenNameEOF ) { / / already tried one iteration on EOF return false ; } } lastCheckPoint = scanner . currentPosition ; / / reset scanner again to previous checkpoint location scanner . startPosition = pos ; scanner . currentPosition = pos ; scanner . commentPtr = - 1 ; return true ; * / }	if ( this . scanner . currentPosition == this . scanner . startPosition ) { this . scanner . currentPosition ++ ;
autoResize ( index + position ) ; <CTX> public Object get ( int index ) { autoResize ( index + position ) ; return delegate . get ( index + position ) ; }	autoResize ( index + position + 1 ) ;
if ( passwordStore != null ) { <CTX> protected void savePassword ( ) { if ( passwordStore != null ) { passwordStore . set ( getUserName ( ) , getLoginService ( ) . getServer ( ) , getPassword ( ) ) ; } }	if ( saveCB . isSelected ( ) && ( saveMode == SaveMode . BOTH || saveMode == SaveMode . PASSWORD ) && passwordStore != null ) {
return ( String ) rule . getProperty ( null , <CTX> public String getBackGroudnColor ( ) { return ( String ) rule . getProperty ( null , HighlightRule . BACKGROUND_COLOR_MEMBER ) ; }	Object obj = rule . getProperty ( null ,
super . addAttribute ( key . toString ( ) . toLowerCase ( ) , value ) ; <CTX> public void addAttribute ( Object key , Object value ) { super . addAttribute ( key . toString ( ) . toLowerCase ( ) , value ) ; }	if ( key instanceof String ) super . addAttribute ( ( ( String ) key ) . toLowerCase ( ) , value ) ; else super . addAttribute ( key , value ) ;
if ( previous == null ) <CTX> private void addSubNodes ( ) { IPreferenceNode [ ] subnodes = node . getSubNodes ( ) ; PreferenceEntry previous = null ; for ( int i = 0 ; i < subnodes . length ; i ++ ) { PreferenceEntry entry = createEntry ( subnodes [ i ] , subnodes [ i ] . getLabelText ( ) , offset + 1 ) ; if ( previous == null ) entry . composite . moveBelow ( this . composite ) ; else entry . composite . moveBelow ( previous . composite ) ; previous = entry ; } }	if ( previous == null ) {
return getProcess ( this . name ) ; <CTX> protected Process getProcess ( ) throws Exception { return getProcess ( this . name ) ; }	return this . process ;
manifest = getManifest ( ) ; <CTX> public Object nextElement ( ) { ZipEntry zip = ( ZipEntry ) entries . nextElement ( ) ; JarEntry jar = new JarEntry ( zip ) ; Manifest manifest ; try { manifest = getManifest ( ) ; } catch ( IOException ioe ) { manifest = null ; } if ( manifest != null ) { jar . attr = manifest . getAttributes ( jar . getName ( ) ) ; } / / XXX jar . certs return jar ; }	manifest = jarfile . getManifest ( ) ;
line = locator . getLineNumber ( ) ; column = locator . getColumnNumber ( ) ; systemId = locator . getSystemId ( ) ; <CTX> public void setLocation ( Locator locator ) { line = locator . getLineNumber ( ) ; column = locator . getColumnNumber ( ) ; systemId = locator . getSystemId ( ) ; }	if ( locator != null ) { line = locator . getLineNumber ( ) ; column = locator . getColumnNumber ( ) ; systemId = locator . getSystemId ( ) ; }
super ( parent , context , true ) ; cmpTop = getComponent ( parent ) ; <CTX> public BlockPropertiesSheet ( Composite parent , ChartWizardContext context ) { super ( parent , context , true ) ; cmpTop = getComponent ( parent ) ; }	super ( title , context , true ) ;
queueForDecoration ( element , adaptedElement ) ; <CTX> public String decorateWithText ( String text , Object element , Object adaptedElement ) { / / We do not support decoration of null if ( element == null ) return text ; DecorationResult decoration = ( DecorationResult ) resultCache . get ( element ) ; if ( decoration == null ) { queueForDecoration ( element , adaptedElement ) ; return text ; } else return decoration . decorateWithText ( text ) ; }	queueForDecoration ( element , adaptedElement , false ) ;
while ( count > 0 ) <CTX> private void writeChars ( char [ ] buf , int offset , int count ) throws IOException { while ( count > 0 ) { converter . setOutput ( work_bytes , 0 ) ; int converted = converter . write ( buf , offset , count ) ; offset += converted ; count -= converted ; out . write ( work_bytes , 0 , converter . count ) ; } }	while ( count > 0 || converter . havePendingBytes ( ) )
ArcRenderEvent are = new ArcRenderEvent ( ( StructureSource ) source ) ; <CTX> public PrimitiveRenderEvent copy ( ) throws ChartException { ArcRenderEvent are = new ArcRenderEvent ( ( StructureSource ) source ) ; if ( outline != null ) { are . setOutline ( LineAttributesImpl . copyInstance ( outline ) ) ; } if ( ifBackground != null ) { are . setBackground ( ( Fill ) EcoreUtil . copy ( ifBackground ) ) ; } if ( loTopLeft != null ) { are . setTopLeft ( LocationImpl . copyInstance ( loTopLeft ) ) ; } are . setStyle ( iStyle ) ; are . setWidth ( dWidth ) ; are . setHeight ( dHeight ) ; are . setStartAngle ( dStartInDegrees ) ; are . setEndAngle ( dExtentInDegrees ) ; are . setInnerRadius ( dInnerRadius ) ; are . setOuterRadius ( dOuterRadius ) ; return are ; }	ArcRenderEvent are = new ArcRenderEvent ( source ) ;
SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; SAXParser parser = factory . newSAXParser ( ) ; ExpressionInfoParser eiParser = new ExpressionInfoParser ( ) ; <CTX> private static Map parseExpressionDocumentation ( InputStream docStream ) throws IOException , ParserConfigurationException , SAXException { SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; SAXParser parser = factory . newSAXParser ( ) ; ExpressionInfoParser eiParser = new ExpressionInfoParser ( ) ; InputSource is = new InputSource ( docStream ) ; parser . parse ( new InputSource ( docStream ) , eiParser ) ; return eiParser . getExpressionInfoMappings ( ) ; }	Reader reader = new BufferedReader ( new InputStreamReader ( docStream ) ) ;
if ( OperatingSystem . isMacOS ( ) ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { jEdit . getActiveView ( ) . getInputHandler ( ) . invokeAction ( action ) ; } } ) ; } else jEdit . getActiveView ( ) . getInputHandler ( ) . invokeAction ( action ) ; <CTX> public void actionPerformed ( ActionEvent evt ) { / / Let input handler do recording , repeating , etc / / XXX - fixes problem if menu bar is at the top of the screen if ( OperatingSystem . isMacOS ( ) ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { jEdit . getActiveView ( ) . getInputHandler ( ) . invokeAction ( action ) ; } } ) ; } else jEdit . getActiveView ( ) . getInputHandler ( ) . invokeAction ( action ) ; }	jEdit . getActiveView ( ) . getInputHandler ( ) . invokeAction ( action ) ;
if ( currentInfo . updateAll ) viewer . refresh ( true ) ; else { Object [ ] updateItems = currentInfo . refreshes . toArray ( ) ; for ( int i = 0 ; i < updateItems . length ; i ++ ) { viewer . refresh ( updateItems [ i ] , true ) ; <CTX> public IStatus runInUIThread ( IProgressMonitor monitor ) { if ( viewer . getControl ( ) . isDisposed ( ) ) return Status . CANCEL_STATUS ; if ( currentInfo . updateAll ) viewer . refresh ( true ) ; else { Object [ ] updateItems = currentInfo . refreshes . toArray ( ) ; for ( int i = 0 ; i < updateItems . length ; i ++ ) { viewer . refresh ( updateItems [ i ] , true ) ; } viewer . add ( viewer . getInput ( ) , currentInfo . additions . toArray ( ) ) ; viewer . remove ( currentInfo . deletions . toArray ( ) ) ; } currentInfo . reset ( ) ; return Status . OK_STATUS ; }	viewer . remove ( currentInfo . deletions . toArray ( ) ) ;
/ * package * / NavigationHistoryEntry [ ] getBackwardEntries ( ) { <CTX> / * package * / NavigationHistoryEntry [ ] getBackwardEntries ( ) { int length = activeEntry ; NavigationHistoryEntry [ ] entries = new NavigationHistoryEntry [ length ] ; for ( int i = 0 ; i < activeEntry ; i ++ ) { entries [ activeEntry - 1 - i ] = getEntry ( i ) ; } return entries ; }	NavigationHistoryEntry [ ] getBackwardEntries ( ) {
if ( ! WorkbenchActivityHelper . isFiltering ( ) ) return null ; <CTX> private IIdentifier getIdentifier ( ) { if ( ! WorkbenchActivityHelper . isFiltering ( ) ) return null ; if ( identifier == null ) { IWorkbenchActivitySupport workbenchActivitySupport = PlatformUI . getWorkbench ( ) . getActivitySupport ( ) ; IPluginContribution contribution = ( IPluginContribution ) getAction ( ) ; / / no need to check if contribution . getPluginId ( ) == null - plugin / / actions are always from plugins . identifier = workbenchActivitySupport . getActivityManager ( ) . getIdentifier ( WorkbenchActivityHelper . createUnifiedId ( contribution ) ) ; } return identifier ; }	if ( ! WorkbenchActivityHelper . isFiltering ( ) ) { return null ; }
IWorkbenchPart part = ref . getPart ( Boolean . TRUE . equals ( event . getNewValue ( ) ) ) ; if ( ref == null || part == null ) <CTX> public void propertyChange ( PropertyChangeEvent event ) { String property = event . getProperty ( ) ; if ( IWorkingSetManager . CHANGE_WORKING_SET_REMOVE . equals ( property ) && event . getOldValue ( ) . equals ( workingSet ) ) { setWorkingSet ( null ) ; } else if ( LayoutPart . PROP_VISIBILITY . equals ( property ) ) { WorkbenchPartReference ref = ( WorkbenchPartReference ) ( ( PartPane ) event . getSource ( ) ) . getPartReference ( ) ; IWorkbenchPart part = ref . getPart ( Boolean . TRUE . equals ( event . getNewValue ( ) ) ) ; if ( ref == null || part == null ) return ; if ( Boolean . TRUE . equals ( event . getNewValue ( ) ) ) partListeners . firePartVisible ( part ) ; else partListeners . firePartHidden ( part ) ; } }	ref . getPart ( Boolean . TRUE . equals ( event . getNewValue ( ) ) ) ; if ( ref == null )
RubyString . newString ( getRuntime ( ) , getValue ( ) . toLowerCase ( ) ) ; <CTX> public RubyFixnum casecmp ( IRubyObject other ) { RubyString thisLCString = RubyString . newString ( getRuntime ( ) , getValue ( ) . toLowerCase ( ) ) ; RubyString lcString = RubyString . newString ( getRuntime ( ) , stringValue ( other ) . getValue ( ) . toLowerCase ( ) ) ; return thisLCString . op_cmp ( lcString ) ; }	getRuntime ( ) . newString ( getValue ( ) . toLowerCase ( ) ) ;
void writeEJBObject ( EJBObject ejbObject , ObjectOutputStream objectOutputStream ) throws IOException ; <CTX> void writeEJBObject ( EJBObject ejbObject , ObjectOutputStream objectOutputStream ) throws IOException ;	void writeEJBObject ( EJBObject ejbObject , ObjectOutputStream ostream ) throws IOException ;
Object adaptedElement ) { <CTX> public Image decorateWithOverlays ( Image image , Object element , Object adaptedElement ) { DecorationResult decoration = getResult ( element , adaptedElement ) ; if ( decoration == null ) return image ; return decoration . decorateWithOverlays ( image , decoratorManager . getLightweightManager ( ) . getOverlayCache ( ) ) ; }	Object adaptedElement , IDecorationContext context ) {
if ( inactiveBounds . contains ( event . x , event . y ) ) return ; <CTX> private void onMouseExit ( Event event ) { Rectangle inactiveBounds = inactiveCloseBar . getBounds ( ) ; if ( inactiveBounds . contains ( event . x , event . y ) ) return ; inactiveCloseBar . setVisible ( false ) ; inactiveItem = null ; showToolTip = false ; toolTipItem = null ; if ( tip != null && ! tip . isDisposed ( ) && tip . isVisible ( ) ) tip . setVisible ( false ) ; }	if ( inactiveBounds . contains ( event . x , event . y ) ) { return ; }
void readExternal ( ObjectInput in ) throws IOException , ClassNotFoundException ; <CTX> void readExternal ( ObjectInput in ) throws IOException , ClassNotFoundException ;	public abstract void readExternal ( ObjectInput in ) throws ClassNotFoundException , IOException ;
cx . debugger . handleCompilationDone ( cx , result , debugSource ) ; <CTX> private InterpretedFunction generateFunctionICode ( Context cx , Scriptable scope , FunctionNode theFunction ) { / / check if function has own source , which is the case / / with Function ( . . . ) String savedSource = debugSource ; debugSource = ( String ) theFunction . getProp ( Node . DEBUGSOURCE_PROP ) ; if ( debugSource == null ) { debugSource = savedSource ; } generateNestedFunctions ( cx , scope , theFunction ) ; generateRegExpLiterals ( cx , scope , theFunction ) ; itsData . itsNeedsActivation = theFunction . requiresActivation ( ) ; itsVariableTable = theFunction . getVariableTable ( ) ; generateICodeFromTree ( theFunction . getLastChild ( ) ) ; itsData . itsName = theFunction . getFunctionName ( ) ; itsData . itsSourceFile = ( String ) theFunction . getProp ( Node . SOURCENAME_PROP ) ; itsData . itsSource = ( String ) theFunction . getProp ( Node . SOURCE_PROP ) ; if ( Context . printICode ) dumpICode ( itsData ) ; InterpretedFunction result = new InterpretedFunction ( cx , itsData ) ; setArgNames ( result ) ; if ( cx . debugger != null ) { cx . debugger . handleCompilationDone ( cx , result , debugSource ) ; } debugSource = savedSource ; return result ; }	cx . debugger . handleCompilationDone ( cx , itsData , debugSource ) ;
Pair < MimeMessage , Integer > apptMsgData = calItem . getSubpartMessageData ( context . itemId . getSubpartId ( ) ) ; addXZimbraHeaders ( context , calItem , apptMsgData . getSecond ( ) ) ; apptMsgData . getFirst ( ) . writeTo ( context . resp . getOutputStream ( ) ) ; <CTX> private void handleCalendarItem ( Context context , CalendarItem calItem ) throws IOException , ServiceException , MessagingException { context . resp . setContentType ( Mime . CT_TEXT_PLAIN ) ; if ( context . itemId . hasSubpart ( ) ) { / / unfortunately , MimeMessage won t give you the length including headers . . . Pair < MimeMessage , Integer > apptMsgData = calItem . getSubpartMessageData ( context . itemId . getSubpartId ( ) ) ; addXZimbraHeaders ( context , calItem , apptMsgData . getSecond ( ) ) ; apptMsgData . getFirst ( ) . writeTo ( context . resp . getOutputStream ( ) ) ; } else { InputStream is = calItem . getRawMessage ( ) ; addXZimbraHeaders ( context , calItem , calItem . getSize ( ) ) ; ByteUtil . copy ( is , true , context . resp . getOutputStream ( ) , false ) ; } }	Pair < MimeMessage , Integer > calItemMsgData = calItem . getSubpartMessageData ( context . itemId . getSubpartId ( ) ) ; addXZimbraHeaders ( context , calItem , calItemMsgData . getSecond ( ) ) ; calItemMsgData . getFirst ( ) . writeTo ( context . resp . getOutputStream ( ) ) ;
if ( input != null ) { OutputStream os = leaf . getNewOutputStream ( ) ; StreamUtil . copy ( input , os ) ; os . close ( ) ; input . close ( ) ; } if ( headers != null ) { leaf . setNewProperties ( headers ) ; } <CTX> protected void storeContent ( InputStream input , Properties headers ) throws IOException { RepositoryNode leaf = repository . createNewNode ( url ) ; leaf . makeNewVersion ( ) ; if ( input != null ) { OutputStream os = leaf . getNewOutputStream ( ) ; StreamUtil . copy ( input , os ) ; os . close ( ) ; input . close ( ) ; } if ( headers != null ) { leaf . setNewProperties ( headers ) ; } leaf . sealNewVersion ( ) ; }	OutputStream os = leaf . getNewOutputStream ( ) ; StreamUtil . copy ( input , os ) ; os . close ( ) ; input . close ( ) ; leaf . setNewProperties ( headers ) ;
return RubyArray . newArray ( getRuntime ( ) , JavaUtil . convertJavaArrayToRuby ( getRuntime ( ) , snapshot ) ) ; <CTX> public RubyArray entries ( ) { return RubyArray . newArray ( getRuntime ( ) , JavaUtil . convertJavaArrayToRuby ( getRuntime ( ) , snapshot ) ) ; }	return getRuntime ( ) . newArray ( JavaUtil . convertJavaArrayToRuby ( getRuntime ( ) , snapshot ) ) ;
ruby . setPosition ( position ) ; <CTX> public static IRubyObject [ ] setupArgs ( Ruby ruby , EvaluateVisitor visitor , INode node ) { if ( node == null ) { return new IRubyObject [ 0 ] ; } final ISourcePosition position = ruby . getPosition ( ) ; if ( node instanceof ArrayNode ) { final int size = ( ( ArrayNode ) node ) . size ( ) ; final ArrayList list = new ArrayList ( size ) ; final Iterator iterator = ( ( ArrayNode ) node ) . iterator ( ) ; for ( int i = 0 ; i < size ; i ++ ) { final INode next = ( INode ) iterator . next ( ) ; if ( next instanceof ExpandArrayNode ) { list . addAll ( ( ( RubyArray ) visitor . eval ( next ) ) . getList ( ) ) ; } else { list . add ( visitor . eval ( next ) ) ; } } ruby . setPosition ( position ) ; return ( IRubyObject [ ] ) list . toArray ( new IRubyObject [ list . size ( ) ] ) ; } IRubyObject args = visitor . eval ( node ) ; ruby . setPosition ( position ) ; if ( args instanceof RubyArray ) { return ( ( RubyArray ) args ) . toJavaArray ( ) ; } else { return new IRubyObject [ ] { args } ; } }	runtime . setPosition ( position ) ;
return AttributeFactory . eINSTANCE . convertToString ( AttributePackage . eINSTANCE . getIntersectionType ( ) , <CTX> public String convertIntersectionTypeObjectToString ( EDataType eDataType , Object instanceValue ) { return AttributeFactory . eINSTANCE . convertToString ( AttributePackage . eINSTANCE . getIntersectionType ( ) , instanceValue ) ; }	return convertIntersectionTypeToString ( AttributePackage . Literals . INTERSECTION_TYPE ,
return ordinalToNameMap [ ordinal - min ] ; <CTX> public final String getName ( int ordinal ) { Util . assertPrecondition ( isImmutable ( ) ) ; return ordinalToNameMap [ ordinal - min ] ; }	final Value value = ordinalToValueMap [ ordinal - min ] ; if ( value == null ) { return null ; } else { return value . getName ( ) ; }
stringTypeCode p = new stringTypeCode ( TCKind . tk_wstring ) ; <CTX> public TypeCode create_wstring_tc ( int bound ) { stringTypeCode p = new stringTypeCode ( TCKind . tk_wstring ) ; p . setLength ( bound ) ; return p ; }	StringTypeCode p = new StringTypeCode ( TCKind . tk_wstring ) ;
Set columns , Set filters , InputOptions options , OutputStream out ) <CTX> public void extractResultSet ( String docName , String resultSetId , Set columns , Set filters , InputOptions options , OutputStream out ) throws ReportServiceException { IReportDocument doc = ReportEngineService . getInstance ( ) . openReportDocument ( getReportDesignName ( options ) , docName ) ; Locale locale = ( Locale ) options . getOption ( InputOptions . OPT_LOCALE ) ; / / TODO : Filters are not used . . . try { ReportEngineService . getInstance ( ) . extractData ( doc , resultSetId , columns , locale , out ) ; doc . close ( ) ; } catch ( RemoteException e ) { throw new ReportServiceException ( e . getLocalizedMessage ( ) ) ; } }	Collection columns , Set filters , InputOptions options , OutputStream out )
hide ( ) ; <CTX> public void dispose ( ) { hide ( ) ; JDesktopPane pane = getDesktopPane ( ) ; if ( pane != null ) pane . setSelectedFrame ( null ) ; else { try { setSelected ( false ) ; } catch ( PropertyVetoException e ) { / / Do nothing if they don t want to be unselected . } } isClosed = true ; fireInternalFrameEvent ( InternalFrameEvent . INTERNAL_FRAME_CLOSED ) ; removeNotify ( ) ; }	setVisible ( false ) ;
switch ( eDerivedStructuralFeatureID ( eFeature ) ) <CTX> public Object eGet ( EStructuralFeature eFeature , boolean resolve ) { switch ( eDerivedStructuralFeatureID ( eFeature ) ) { case DataPackage . ACTION__ TYPE : return getType ( ) ; case DataPackage . ACTION__ VALUE : return getValue ( ) ; } return eDynamicGet ( eFeature , resolve ) ; }	switch ( featureID )
String name , Constraint constraint ) { <CTX> public TypeReference ( FileLocation location , MibContext context , String name , Constraint constraint ) { this ( location , context , name ) ; this . constraint = constraint ; }	String name ) {
String pluginId = ext . getDeclaringPluginDescriptor ( ) . getUniqueIdentifier ( ) ; <CTX> public void add ( IExtensionDelta delta ) { IExtensionPoint extPt = delta . getExtensionPoint ( ) ; IExtension ext = delta . getExtension ( ) ; / / Get the name of the plugin that is adding this extension . The / / name of the plugin that adds the extension point is us . String pluginId = ext . getDeclaringPluginDescriptor ( ) . getUniqueIdentifier ( ) ; add ( buildNewCacheObject ( delta ) , pluginId ) ; }	String pluginId = ext . getNamespace ( ) ;
this ( relationship , parent , null ) ; <CTX> public ContainsPredicate ( String relationship , String parent ) { this ( relationship , parent , null ) ; }	super ( relationship , null , relationship ) ; this . parent = parent ;
return ( ElementChange ) changes . get ( elem ) ; <CTX> public ElementChange getChange ( Element elem ) { return ( ElementChange ) changes . get ( elem ) ; }	return ( DocumentEvent . ElementChange ) changes . get ( elem ) ;
if ( textArea . getDisplayManager ( ) == this ) <CTX> private void_notifyScreenLineChanges ( ) { / / when the text area switches to us , it will do / / a reset anyway if ( textArea . getDisplayManager ( ) == this ) { if ( firstLine . callReset ) firstLine . reset ( ) ; else if ( firstLine . callChanged ) firstLine . changed ( ) ; if ( scrollLineCount . callReset ) scrollLineCount . reset ( ) ; else if ( scrollLineCount . callChanged ) scrollLineCount . changed ( ) ; } firstLine . callReset = firstLine . callChanged = false ; scrollLineCount . callReset = scrollLineCount . callChanged = false ; } / / } } }	Iterator iter = ( ( List ) bufferMap . get ( buffer ) ) . iterator ( ) ; while ( iter . hasNext ( ) )
joinScheduler ( ) ; <CTX> public void resume ( ) { joinScheduler ( ) ; }	tm . resume ( ) ;
set ( parameterIndex , ( new Integer ( x ) ) . toString ( ) ) ; <CTX> public void setInt ( int parameterIndex , int x ) throws SQLException { set ( parameterIndex , ( new Integer ( x ) ) . toString ( ) ) ; }	set ( parameterIndex , Integer . toString ( x ) ) ;
return JFaceResources . getImageRegistry ( ) . get ( Dialog . DLG_IMG_INFO ) ; <CTX> protected Image getImage ( ) { return JFaceResources . getImageRegistry ( ) . get ( Dialog . DLG_IMG_INFO ) ; }	return getShell ( ) . getDisplay ( ) . getSystemImage ( SWT . ICON_INFORMATION ) ;
sb . append ( menuParser ( originalInput , patMat , menus , implicitMenus , menumode , tags ) ) ; <CTX> public void appendSubstitution ( StringBuffer sb , MatchResult matres , int sc , String originalInput , PatternMatcher patMat , Pattern pat ) { sb . append ( menuParser ( originalInput , patMat , menus , implicitMenus , menumode , tags ) ) ; }	MatchResult menuMatres = patMat . getMatch ( ) ; int menuId = 0 ; try { menuId = Integer . parseInt ( menuMatres . group ( 1 ) ) ; } catch ( NumberFormatException ex ) { menuId = implicitMenus [ 0 ] ++ ; } sb . append ( nodeMenuParser ( menuId , patMat ) ) ;
Iterator < Collection < Value >> lists = myBaseMap . values ( ) . iterator ( ) ; while ( lists . hasNext ( ) ) { result . addAll ( lists . next ( ) ) ; <CTX> public Collection < Value > values ( ) { Set < Value > result = new HashSet < Value > ( ) ; Iterator < Collection < Value >> lists = myBaseMap . values ( ) . iterator ( ) ; while ( lists . hasNext ( ) ) { result . addAll ( lists . next ( ) ) ; } return result ; }	for ( final Collection < Value > values : myBaseMap . values ( ) ) { result . addAll ( values ) ;
throws UnexpectedException ; <CTX> public int getPermissionsInConference ( long conferenceId ) throws UnexpectedException ;	throws UnexpectedException , ObjectNotFoundException ;
search = search . subExpressions [ 0 ] ; <CTX> public Expression tryToCombine ( Expression e ) { if ( e . operator instanceof StoreInstruction ) { StoreInstruction store = ( StoreInstruction ) e . operator ; Expression search = this ; while ( search . subExpressions . length > 0 ) { if ( store . matches ( search . operator ) ) { int i ; for ( i = 0 ; i < e . subExpressions . length - 1 ; i ++ ) { if ( ! e . subExpressions [ i ] . equals ( search . subExpressions [ i ] ) ) break ; } if ( i == e . subExpressions . length - 1 ) { search . operator = new AssignOperator ( store . getOperator ( ) , store ) ; search . subExpressions = e . subExpressions ; return this ; } } search = search . subExpressions [ 0 ] ; } } return null ; }	if ( search . subExpressions . length == 0 ) break ; if ( search . getOperator ( ) instanceof AssignOperator ) search = search . subExpressions [ subExpressions . length - 1 ] ; else if ( search . getOperator ( ) instanceof StringAddOperator && search . subExpressions [ 1 ] == emptyString ) search = search . subExpressions [ 1 ] ; else search = search . subExpressions [ 0 ] ;
throw Kit . badTypeJS ( y ) ; <CTX> static boolean eqNumber ( double x , Object y ) { for ( ; ; ) { if ( y == null ) { return false ; } else if ( y instanceof Number ) { return x == ( ( Number ) y ) . doubleValue ( ) ; } else if ( y instanceof String ) { return x == toNumber ( y ) ; } else if ( y instanceof Boolean ) { return x == ( ( ( Boolean ) y ) . booleanValue ( ) ? 1 . 0 : + 0 . 0 ) ; } else if ( y instanceof Scriptable ) { if ( y == Undefined . instance ) { return false ; } if ( y instanceof ScriptableObject ) { Object xval = new Double ( x ) ; Boolean test = ( ( ScriptableObject ) y ) . equivalentValues ( xval ) ; if ( test != null ) { return test . booleanValue ( ) ; } } y = toPrimitive ( y ) ; } else { throw Kit . badTypeJS ( y ) ; } } }	warnAboutNonJSObject ( y ) ; return false ;
if ( this == object ) <CTX> public boolean equals ( Object object ) { if ( this == object ) return true ; if ( this . getClass ( ) == object . getClass ( ) ) { TabDescriptor descriptor = ( TabDescriptor ) object ; if ( this . getCategory ( ) . equals ( descriptor . getCategory ( ) ) && this . getId ( ) . equals ( descriptor . getId ( ) ) && this . getSectionDescriptors ( ) . size ( ) == descriptor . getSectionDescriptors ( ) . size ( ) ) { Iterator i = this . getSectionDescriptors ( ) . iterator ( ) ; Iterator j = descriptor . getSectionDescriptors ( ) . iterator ( ) ; / / the order is importent here - so as long as the sizes of the / / lists are the same and id of the section at the same / / positions are the same - the lists are the same while ( i . hasNext ( ) ) { ISectionDescriptor source = ( ISectionDescriptor ) i . next ( ) ; ISectionDescriptor target = ( ISectionDescriptor ) j . next ( ) ; if ( ! source . getId ( ) . equals ( target . getId ( ) ) ) return false ; } return true ; } } return false ; }	if ( this == object ) {
Table table = mappings . addTable ( mappings . getSchemaName ( ) , mappings . getCatalogName ( ) , namingStrategy . classToTableName ( referencedClassName ) , null , false ) ; collection . setCollectionTable ( table ) ; <CTX> private static void bindCollection ( GrailsDomainClassProperty property , Collection collection , PersistentClass owner , Mappings mappings ) { / / set role collection . setRole ( StringHelper . qualify ( property . getDomainClass ( ) . getFullName ( ) , property . getName ( ) ) ) ; / / configure eager fetching if ( property . getFetchMode ( ) == GrailsDomainClassProperty . FETCH_EAGER ) { collection . setFetchMode ( FetchMode . JOIN ) ; } else { collection . setFetchMode ( FetchMode . DEFAULT ) ; } / / if its a one - to - many mapping if ( property . isOneToMany ( ) || property . isManyToMany ( ) ) { OneToMany oneToMany = new OneToMany ( collection . getOwner ( ) ) ; collection . setElement ( oneToMany ) ; / * if ( property . isBidirectional ( ) ) { collection . setReferencedPropertyName ( property . getOtherSide ( ) . getName ( ) ) ; } * / bindOneToMany ( property , oneToMany , mappings ) ; } else { String referencedClassName = property . getReferencedDomainClass ( ) . getFullName ( ) ; Table table = mappings . addTable ( mappings . getSchemaName ( ) , mappings . getCatalogName ( ) , namingStrategy . classToTableName ( referencedClassName ) , null , false ) ; collection . setCollectionTable ( table ) ; } / / setup second pass mappings . addSecondPass ( new GrailsCollectionSecondPass ( property , mappings , collection ) ) ; }	if ( ! property . isOwningSide ( ) ) { collection . setInverse ( true ) ; }
this . mipmapData = ( Buffer [ ] ) mipmapData . clone ( ) ; <CTX> public TextureData ( int internalFormat , int width , int height , int border , int pixelFormat , int pixelType , boolean dataIsCompressed , boolean mustFlipVertically , Buffer [ ] mipmapData , Flusher flusher ) throws IllegalArgumentException { this . width = width ; this . height = height ; this . border = border ; this . pixelFormat = pixelFormat ; this . pixelType = pixelType ; this . internalFormat = internalFormat ; this . dataIsCompressed = dataIsCompressed ; this . mustFlipVertically = mustFlipVertically ; this . mipmapData = ( Buffer [ ] ) mipmapData . clone ( ) ; this . flusher = flusher ; alignment = 1 ; / / FIXME : is this correct enough in all situations ? }	this . buffer = buffer ;
INode addNode ( String target , Block blks [ ] ) { if ( getNode ( target ) != null ) { return null ; } else { String parentName = DFSFile . getDFSParent ( target ) ; if ( parentName == null ) { return null ; } INode parentNode = getNode ( parentName ) ; if ( parentNode == null ) { return null ; } else { String targetName = new File ( target ) . getName ( ) ; INode newItem = new INode ( targetName , parentNode , blks ) ; parentNode . children . put ( targetName , newItem ) ; return newItem ; } } <CTX> INode addNode ( String target , Block blks [ ] ) { if ( getNode ( target ) != null ) { return null ; } else { String parentName = DFSFile . getDFSParent ( target ) ; if ( parentName == null ) { return null ; } INode parentNode = getNode ( parentName ) ; if ( parentNode == null ) { return null ; } else { String targetName = new File ( target ) . getName ( ) ; INode newItem = new INode ( targetName , parentNode , blks ) ; parentNode . children . put ( targetName , newItem ) ; return newItem ; } } }	INode addNode ( String path , INode newNode ) { File target = new File ( path ) ; String parentName = DFSFile . getDFSParent ( path ) ; if ( parentName == null ) return null ; INode parentNode = getNode ( parentName ) ; if ( parentNode == null ) return null ; String name = newNode . name = target . getName ( ) ; if ( parentNode . getChild ( name ) != null ) return null ; parentNode . children . put ( name , newNode ) ; newNode . parent = parentNode ; return newNode ;
Fetcher f = new Fetcher ( uri , context ) ; return f . run ( ) ; <CTX> public FetchResult fetch ( FreenetURI uri ) throws FetchException { if ( uri == null ) throw new NullPointerException ( ) ; FetcherContext context = getFetcherContext ( ) ; Fetcher f = new Fetcher ( uri , context ) ; return f . run ( ) ; }	FetchWaiter fw = new FetchWaiter ( ) ; ClientGetter get = new ClientGetter ( fw , node . fetchScheduler , uri , context , priorityClass ) ; get . start ( ) ; return fw . waitForCompletion ( ) ;
add ( new ContainerVersionUserCell ( this , teamMember ) ) ; <CTX> private void addUserCells ( final List < TeamMember > team ) { for ( final TeamMember teamMember : team ) { add ( new ContainerVersionUserCell ( this , teamMember ) ) ; } }	add ( new ContainerTeamMemberCell ( this , teamMember ) ) ;
descriptor = CCorePlugin . getDefault ( ) . getCProjectDescription ( project ) ; <CTX> private ICDescriptor getProjectDescriptor ( IProject project ) throws CoreException { ICDescriptor descriptor = null ; descriptor = CCorePlugin . getDefault ( ) . getCProjectDescription ( project ) ; return descriptor ; }	descriptor = CCorePlugin . getDefault ( ) . getCProjectDescription ( project , false ) ;
} catch ( XMLStreamException xse ) { <CTX> public QName getQName ( ) throws MessageException { / / If the QName is not known , find it try { if ( qName == null ) { if ( omElement == null ) { XMLStreamReader newReader =_getReaderFromBO ( busObject , busContext ) ; busObject = null ; StAXOMBuilder builder = new StAXOMBuilder ( newReader ) ; omElement = builder . getDocumentElement ( ) ; } qName = omElement . getQName ( ) ; } return qName ; } catch ( XMLStreamException xse ) { throw ExceptionFactory . makeMessageException ( xse ) ; } }	} catch ( Exception xse ) { setConsumed ( true ) ;
driver . enableLogging ( log ) ; driver . setRenderer ( renderer ) ; driver . render ( input . getParser ( ) , input . getInputSource ( ) ) ; <CTX> public void renderXML ( XSLTInputHandler input , HttpServletResponse response ) throws ServletException { try { Driver driver = new Driver ( ) ; PrinterJob pj = PrinterJob . getPrinterJob ( ) ; PrintRenderer renderer = new PrintRenderer ( pj ) ; pj . setCopies ( 1 ) ; driver . enableLogging ( log ) ; driver . setRenderer ( renderer ) ; driver . render ( input . getParser ( ) , input . getInputSource ( ) ) ; reportOK ( response ) ; } catch ( Exception ex ) { throw new ServletException ( ex ) ; } }	session . enableLogging ( log ) ; session . setRenderer ( renderer ) ; session . render ( input . getParser ( ) , input . getInputSource ( ) ) ;
dataEngine . getSharedScope ( ) ) ; <CTX> public static DataSourceRuntime newInstance ( IBaseDataSourceDesign dataSource , DataEngineImpl dataEngine ) throws DataException { if ( dataSource instanceof IOdaDataSourceDesign ) { return new OdaDataSourceRuntime ( ( IOdaDataSourceDesign ) dataSource , dataEngine . getSharedScope ( ) ) ; } else if ( dataSource instanceof IScriptDataSourceDesign ) { return new ScriptDataSourceRuntime ( ( IScriptDataSourceDesign ) dataSource , dataEngine . getSharedScope ( ) ) ; } else { throw new DataException ( ResourceConstants . UNSUPPORTED_DATASOURCE_TYPE , dataSource . getName ( ) ) ; } }	dataEngine . getSession ( ) . getSharedScope ( ) ) ;
addGISTypes ( ( PGConnection ) result ) ; <CTX> public java . sql . Connection connect ( String url , Properties info ) throws SQLException { url = mangleURL ( url ) ; Connection result = super . connect ( url , info ) ; addGISTypes ( ( PGConnection ) result ) ; return result ; }	typesAdder . addGT ( result ) ;
int positionZ = this . getZ ( this . indexOf ( o ) ) ; <CTX> public Object ahead ( Object o ) { int positionZ = this . getZ ( this . indexOf ( o ) ) ; if ( positionZ != 0 ) { return this . get ( positionZ - ( this . getWidth ( ) * this . getHeight ( ) ) ) ; } else { return null ; } }	int position = this . indexOf ( o ) ; int positionZ = this . getZ ( position ) ;
Table table = database . findTable ( getChangedTable ( ) . getName ( ) ) ; Column column = table . findColumn (_column . getName ( ) ) ; <CTX> public void apply ( Database database ) { Table table = database . findTable ( getChangedTable ( ) . getName ( ) ) ; Column column = table . findColumn (_column . getName ( ) ) ; column . setRequired ( !_column . isRequired ( ) ) ; }	Table table = database . findTable ( getChangedTable ( ) . getName ( ) , caseSensitive ) ; Column column = table . findColumn (_column . getName ( ) , caseSensitive ) ;
if ( child . isLeaf ( ) ) { <CTX> private void recurseLeafFetch ( InternalNode node , TreeSet set ) { Iterator children = node . listNodes ( null ) ; while ( children . hasNext ( ) ) { RepositoryNode child = ( RepositoryNode ) children . next ( ) ; if ( child . isLeaf ( ) ) { CachedUrl newUrl = ( ( BaseArchivalUnit ) au ) . cachedUrlFactory ( this , child . getNodeUrl ( ) ) ; set . add ( newUrl ) ; } else { recurseLeafFetch ( ( InternalNode ) child , set ) ; } } }	if ( child . hasContent ( ) ) {
movePaneAction . update ( ) ; <CTX> protected void update ( boolean force , boolean recursive ) { movePaneAction . update ( ) ; moveFolderAction . update ( ) ; super . update ( force , recursive ) ; }	if ( assumeActivePart ) { setTarget ( stackPresentationSite . getSelectedPart ( ) ) ; }
if ( keyFilterEnabled ) <CTX> public void run ( boolean fork , boolean cancelable , IRunnableWithProgress runnable ) throws InvocationTargetException , InterruptedException { IWorkbenchContextSupport contextSupport = getWorkbench ( ) . getContextSupport ( ) ; final boolean keyFilterEnabled = contextSupport . isKeyFilterEnabled ( ) ; Control fastViewBarControl = getFastViewBar ( ) == null ? null : getFastViewBar ( ) . getControl ( ) ; boolean fastViewBarWasEnabled = fastViewBarControl == null ? false : fastViewBarControl . getEnabled ( ) ; Control perspectiveBarControl = getPerspectiveBar ( ) == null ? null : getPerspectiveBar ( ) . getControl ( ) ; boolean perspectiveBarWasEnabled = perspectiveBarControl == null ? false : perspectiveBarControl . getEnabled ( ) ; try { if ( fastViewBarControl != null && ! fastViewBarControl . isDisposed ( ) ) fastViewBarControl . setEnabled ( false ) ; if ( perspectiveBarControl != null && ! perspectiveBarControl . isDisposed ( ) ) perspectiveBarControl . setEnabled ( false ) ; if ( keyFilterEnabled ) contextSupport . setKeyFilterEnabled ( false ) ; super . run ( fork , cancelable , runnable ) ; } finally { if ( fastViewBarControl != null && ! fastViewBarControl . isDisposed ( ) ) fastViewBarControl . setEnabled ( fastViewBarWasEnabled ) ; if ( perspectiveBarControl != null && ! perspectiveBarControl . isDisposed ( ) ) perspectiveBarControl . setEnabled ( perspectiveBarWasEnabled ) ; if ( keyFilterEnabled ) contextSupport . setKeyFilterEnabled ( true ) ; } }	if ( keyFilterEnabled ) {
addBranch ( address , true ) ; <CTX> public void visit_ifne ( int address ) { addBranch ( address , true ) ; }	addBranch ( address , CONDITIONAL_BRANCH ) ;
this , listen ) ; <CTX> public void sendMessage ( Connection conn , LDAPMessage msg , int timeOut , LDAPListener listen ) throws IOException { / / creating a messageInfo causes the message to be sent / / and a timer to be started if needed . Message message = new Message ( msg , timeOut , conn , this , listen ) ; messages . addElement ( message ) ; return ; }	this , listen , bindProps ) ;
: gen . mkApply__ ( gen . mkRef ( pos , primitives . BOX_UVALUE ) ) ; <CTX> private Tree transformUnit ( int pos , Type pt ) { Tree unit = pt . isSameAs ( UNBOXED_UNIT ) ? gen . mkUnitLit ( pos ) : gen . mkApply__ ( gen . mkRef ( pos , primitives . BOX_UVALUE ) ) ; return coerce ( unit , pt ) ; }	: gen . mkApply__ ( gen . mkGlobalRef ( pos , primitives . BOX_UVALUE ) ) ;
registerContainer ( toprocess , toprocess ) ; <CTX> public void processComponent ( UIComponent toprocesso ) { if ( toprocesso instanceof UIForm ) { UIForm toprocess = ( UIForm ) toprocesso ; registerContainer ( toprocess , toprocess ) ; } }	if ( toprocess . submittingcontrols . size ( ) == 0 ) { registerContainer ( toprocess , toprocess ) ; }
if ( broadcast && jobTreeElement instanceof JobInfo ) FinishedJobs . getInstance ( ) . remove ( NewProgressViewer . this , ( JobInfo ) jobTreeElement ) ; <CTX> public boolean kill ( boolean refresh , boolean broadcast ) { if ( jobTerminated ) { if ( broadcast && jobTreeElement instanceof JobInfo ) FinishedJobs . getInstance ( ) . remove ( NewProgressViewer . this , ( JobInfo ) jobTreeElement ) ; dispose ( ) ; relayout ( refresh , refresh ) ; return true ; } return false ; }	if ( broadcast ) FinishedJobs . getInstance ( ) . remove ( NewProgressViewer . this , jobTreeElement ) ;
bugReporter . setErrorVerbosity ( BugReporter . SILENT ) ; <CTX> public FindBugs createEngine ( ) throws IOException , FilterException { TextUIBugReporter bugReporter = null ; switch ( bugReporterType ) { case PRINTING_REPORTER : bugReporter = new PrintingBugReporter ( ) ; break ; case SORTING_REPORTER : bugReporter = new SortingBugReporter ( ) ; break ; case XML_REPORTER : bugReporter = new XMLBugReporter ( project ) ; break ; case EMACS_REPORTER : bugReporter = new EmacsBugReporter ( ) ; break ; case HTML_REPORTER : bugReporter = new HTMLBugReporter ( project , stylesheet ) ; break ; case XDOCS_REPORTER : bugReporter = new XDocsBugReporter ( project ) ; break ; default : throw new IllegalStateException ( ) ; } if ( quiet ) bugReporter . setErrorVerbosity ( BugReporter . SILENT ) ; bugReporter . setPriorityThreshold ( priorityThreshold ) ; if ( outputStream != null ) bugReporter . setOutputStream ( outputStream ) ; FindBugs findBugs = new FindBugs ( bugReporter , project ) ; if ( filterFile != null ) findBugs . setFilter ( filterFile , include ) ; findBugs . setClassScreener ( classScreener ) ; return findBugs ; }	textuiBugReporter . setErrorVerbosity ( BugReporter . SILENT ) ;
return new OPT_StringConstantOperand ( value ) ; <CTX> OPT_Operand copy ( ) { return new OPT_StringConstantOperand ( value ) ; }	return new OPT_StringConstantOperand ( value , index ) ;
ExistingBugEditorInput bi = ( ExistingBugEditorInput ) ei ; <CTX> public boolean isShownInEditor ( Match match , IEditorPart editor ) { if ( result == null ) return false ; IEditorInput ei = editor . getEditorInput ( ) ; if ( ei instanceof ExistingBugEditorInput ) { ExistingBugEditorInput bi = ( ExistingBugEditorInput ) ei ; return match . getElement ( ) . equals ( bi . getRepositoryTaskData ( ) ) ; } return false ; }	AbstractBugEditorInput bi = ( AbstractBugEditorInput ) ei ;
RubyFixnum . newFixnum ( getRuntime ( ) , c ) ; <CTX> public IRubyObject getc ( ) { checkReadable ( ) ; int c = handler . getc ( ) ; return c == - 1 ? getRuntime ( ) . getNil ( ) : / / EOF RubyFixnum . newFixnum ( getRuntime ( ) , c ) ; }	getRuntime ( ) . newFixnum ( c ) ;
} else { return SortOrder . ASCENDING ; } <CTX> public SortOrder flip ( ) { if ( this == SortOrder . ASCENDING ) { return SortOrder . DESCENDING ; } else { return SortOrder . ASCENDING ; } }	return SortOrder . ASCENDING ;
return checkVersion ( new BufferedInputStream ( new FileInputStream ( fileName ) ) ) ; <CTX> public static int checkVersion ( String fileName ) throws DesignFileException , FileNotFoundException { return checkVersion ( new BufferedInputStream ( new FileInputStream ( fileName ) ) ) ; }	List rtnList = new ArrayList ( ) ; VersionParserHandler handler = new VersionParserHandler ( ) ; InputStream inputStreamToParse = streamData ; if ( ! inputStreamToParse . markSupported ( ) ) inputStreamToParse = new BufferedInputStream ( streamData ) ; parse ( handler , inputStreamToParse ) ; if ( StringUtil . compareVersion ( handler . version , VersionInfo . COLUMN_BINDING_FROM_VERSION ) < 1 && StringUtil . compareVersion ( DesignSchemaConstants . REPORT_VERSION , VersionInfo . COLUMN_BINDING_FROM_VERSION ) > 0 ) rtnList . add ( new VersionInfo ( handler . version , VersionInfo . CONVERT_FOR_COLUMN_BINDING ) ) ; return rtnList ;
return ( PrivateData ) privateDataProviders . get ( key ) ; <CTX> public static PrivateData getPrivateDataProvider ( String elementName , String namespace ) { String key = getProviderKey ( elementName , namespace ) ; return ( PrivateData ) privateDataProviders . get ( key ) ; }	return ( PrivateDataProvider ) privateDataProviders . get ( key ) ;
if ( descendingButtons [ index ] . getSelection ( ) ) oldSelectionDirection = TableSorter . DESCENDING ; <CTX> public void widgetSelected ( SelectionEvent e ) { int oldSelectionDirection = TableSorter . ASCENDING ; if ( descendingButtons [ index ] . getSelection ( ) ) oldSelectionDirection = TableSorter . DESCENDING ; ArrayList oldSelectionList = new ArrayList ( Arrays . asList ( priorityCombos [ index ] . getItems ( ) ) ) ; oldSelectionList . removeAll ( Arrays . asList ( priorityCombos [ index + 1 ] . getItems ( ) ) ) ; if ( oldSelectionList . size ( ) != 1 ) return ; String oldSelection = ( String ) oldSelectionList . get ( 0 ) ; String newSelection = priorityCombos [ index ] . getItem ( priorityCombos [ index ] . getSelectionIndex ( ) ) ; if ( oldSelection . equals ( newSelection ) ) { return ; } for ( int j = index + 1 ; j < priorityCombos . length ; j ++ ) { int newSelectionIndex = priorityCombos [ j ] . indexOf ( newSelection ) ; / / this combo s current selection is equal to newSelection if ( priorityCombos [ j ] . getSelectionIndex ( ) == newSelectionIndex ) { priorityCombos [ j ] . remove ( newSelection ) ; int insertionPoint = - 1 - Arrays . binarySearch ( priorityCombos [ j ] . getItems ( ) , oldSelection , columnComparator ) ; if ( insertionPoint >= 0 && insertionPoint <= priorityCombos [ j ] . getItemCount ( ) ) priorityCombos [ j ] . add ( oldSelection , insertionPoint ) ; else priorityCombos [ j ] . add ( oldSelection ) ; priorityCombos [ j ] . select ( priorityCombos [ j ] . indexOf ( oldSelection ) ) ; ascendingButtons [ index ] . setSelection ( ascendingButtons [ j ] . getSelection ( ) ) ; descendingButtons [ index ] . setSelection ( descendingButtons [ j ] . getSelection ( ) ) ; ascendingButtons [ j ] . setSelection ( oldSelectionDirection == TableSorter . ASCENDING ) ; descendingButtons [ j ] . setSelection ( oldSelectionDirection == TableSorter . DESCENDING ) ; } / / this combo contains newSelection else if ( newSelectionIndex >= 0 ) { priorityCombos [ j ] . remove ( newSelection ) ; int insertionPoint = - 1 - Arrays . binarySearch ( priorityCombos [ j ] . getItems ( ) , oldSelection , columnComparator ) ; if ( insertionPoint >= 0 && insertionPoint <= priorityCombos [ j ] . getItemCount ( ) ) priorityCombos [ j ] . add ( oldSelection , insertionPoint ) ; else priorityCombos [ j ] . add ( oldSelection ) ; } } markDirty ( ) ; }	if ( descendingButtons [ index ] . getSelection ( ) ) { oldSelectionDirection = TableSorter . DESCENDING ; }
if ( DATE_ORDER == ASCENDING ) { DATE_ORDER = DESCENDING ; } else { DATE_ORDER = ASCENDING ; } <CTX> public void widgetSelected ( SelectionEvent e ) { if ( DATE_ORDER == ASCENDING ) { DATE_ORDER = DESCENDING ; } else { DATE_ORDER = ASCENDING ; } ViewerSorter sorter = getViewerSorter ( DATE ) ; fTreeViewer . setSorter ( sorter ) ; collator = sorter . getCollator ( ) ; setComparator ( DATE ) ; ( ( EventDetailsDialogAction ) fPropertiesAction ) . setComparator ( comparator ) ; fMemento . putInteger ( P_ORDER_VALUE , DATE_ORDER ) ; fMemento . putInteger ( P_ORDER_TYPE , DATE ) ; }	DATE_ORDER *= - 1 ;
InstructionIterator dup = new InstructionIterator ( ) ; dup . index = this . index ; return dup ; } <CTX> public InstructionIterator duplicate ( ) { InstructionIterator dup = new InstructionIterator ( ) ; dup . index = this . index ; return dup ; }	return new InstructionIterator ( next , last ) ; }
_ model . setActiveNextDocument ( ) ; <CTX> public void actionPerformed ( ActionEvent ae ) {_model . setActiveNextDocument ( ) ; }	if (_helpFrame == null ) {_helpFrame = new HelpFrame ( ) ; }_helpFrame . setVisible ( true ) ;
dag . addEdge ( id , extensionId ) ; <CTX> private void addEdgeWithParentCheck ( Map projectMap , String extensionId , MavenProject project , String id ) throws CycleDetectedException { MavenProject extProject = ( MavenProject ) projectMap . get ( extensionId ) ; project . addProjectReference ( extProject ) ; MavenProject extParent = extProject . getParent ( ) ; if ( extParent != null ) { String parentId = ArtifactUtils . versionlessKey ( extParent . getGroupId ( ) , extParent . getArtifactId ( ) ) ; / / Don t add edge from parent to extension if a reverse edge already exists if ( ! dag . hasEdge ( extensionId , id ) || ! parentId . equals ( id ) ) { dag . addEdge ( id , extensionId ) ; } } }	dag . addEdge ( id , projectRefId ) ;
Platform . getJobManager ( ) . cancel ( parent ) ; <CTX> public void cancel ( Object parent ) { Platform . getJobManager ( ) . cancel ( parent ) ; }	Platform . getJobManager ( ) . cancel ( new DeferredContentFamily ( this , parent ) ) ;
if ( ast != null && ast . getType ( ) == TokenTypes . METHOD_CALL ) { aParent = createMethodCallHandler ( aIndentCheck , ast , aParent ) ; <CTX> ExpressionHandler createMethodCallHandler ( IndentationCheck aIndentCheck , DetailAST aAst , ExpressionHandler aParent ) { ExpressionHandler handler = ( ExpressionHandler ) mCreatedHandlers . get ( aAst ) ; if ( handler != null ) { return handler ; } DetailAST ast = ( DetailAST ) aAst . getFirstChild ( ) ; while ( ast != null && ast . getType ( ) == TokenTypes . DOT ) { ast = ( DetailAST ) ast . getFirstChild ( ) ; } if ( ast != null && ast . getType ( ) == TokenTypes . METHOD_CALL ) { aParent = createMethodCallHandler ( aIndentCheck , ast , aParent ) ; mCreatedHandlers . put ( ast , aParent ) ; } return new MethodCallHandler ( aIndentCheck , aAst , aParent ) ; }	if ( ast != null && isHandledType ( ast . getType ( ) ) ) { aParent = getHandler ( aIndentCheck , ast , aParent ) ;
String localRepositoryPath ( Artifact artifact , ArtifactRepository localRepository ) ; <CTX> String localRepositoryPath ( Artifact artifact , ArtifactRepository localRepository ) ;	String localRepositoryPath ( Artifact artifact , ArtifactRepository localRepository ) throws ArtifactHandlerNotFoundException ;
_ logFactory = logFactory ; <CTX> public static void setLogFactory ( LogFactory logFactory ) {_logFactory = logFactory ; }	_ logFactory . setLogFactory ( logFactory ) ;
return getNamespace ( packageDecl . getQualifiedName ( ) ) ; <CTX> protected String getNamespace ( PackageDeclaration packageDecl ) { return getNamespace ( packageDecl . getQualifiedName ( ) ) ; }	return RuntimeModeler . getNamespace ( packageDecl . getQualifiedName ( ) ) ;
returnExpr = expr ; <CTX> public void setReturnExpression ( Expression expr ) { returnExpr = expr ; }	this . returnExpr = expr ;
throwSQLException ( e ) ; throw e ; <CTX> public void setMaxFieldSize ( int max ) throws SQLException { try { m_stmt . setMaxFieldSize ( max ) ; } catch ( SQLException e ) { throwSQLException ( e ) ; throw e ; / / code should never get here , but just in case } }	throw m_conn . wrap ( e ) ;
source . removeConsumer ( this ) ; <CTX> imageComplete ( int status ) { if ( status == ImageConsumer . STATICIMAGEDONE && isCacheable ) isLoaded = true ; if ( status == ImageConsumer . SINGLEFRAMEDONE ) isCacheable = false ; source . removeConsumer ( this ) ; }	if ( observer != null ) { if ( status == ImageConsumer . IMAGEERROR ) observer . imageUpdate ( null , ImageObserver . ERROR , - 1 , - 1 , - 1 , - 1 ) ; else observer . imageUpdate ( null , ImageObserver . ALLBITS , - 1 , - 1 , - 1 , - 1 ) ; } if ( source != null ) source . removeConsumer ( this ) ;
Object rval = execSub ( cx , thisObj , args , funObj , true , funObj ) ; <CTX> public static Object test ( Context cx , Scriptable thisObj , Object [ ] args , Function funObj ) { Object rval = execSub ( cx , thisObj , args , funObj , true , funObj ) ; if ( rval == null || ! rval . equals ( Boolean . TRUE ) ) rval = Boolean . FALSE ; return rval ; }	Object rval = execSub ( cx , thisObj , args , funObj , TEST , funObj ) ;
iVisited . accept (_Payload ) ; <CTX> public void visitYieldNode ( YieldNode iVisited ) { iVisited . accept (_Payload ) ; }	_ Payload . visitYieldNode ( iVisited ) ;
if ( RegexpUtil . hasFlag ( options , MATCH_SINGLELINE ) ) <CTX> protected int getCompilerOptions ( int options ) { int cOptions = RE . MATCH_NORMAL ; if ( RegexpUtil . hasFlag ( options , MATCH_CASE_INSENSITIVE ) ) cOptions |= RE . MATCH_CASEINDEPENDENT ; if ( RegexpUtil . hasFlag ( options , MATCH_MULTILINE ) ) cOptions |= RE . MATCH_MULTILINE ; if ( RegexpUtil . hasFlag ( options , MATCH_SINGLELINE ) ) cOptions |= RE . MATCH_SINGLELINE ; return cOptions ; }	} if ( RegexpUtil . hasFlag ( options , MATCH_SINGLELINE ) ) {
writeStructureList ( obj , DesignElement . PROPERTY_MASKS_PROP ) ; <CTX> public void visitDesignElement ( DesignElement obj ) { super . visitDesignElement ( obj ) ; if ( markLineNumber ) { Module module = getModule ( ) ; if ( module != null ) module . addElementLineNo ( obj . getID ( ) , writer . getLineCounter ( ) ) ; } / / The element name , id and extends should be written in the tag . attribute ( obj , DesignSchemaConstants . NAME_ATTRIB , DesignElement . NAME_PROP ) ; writer . attribute ( DesignSchemaConstants . ID_ATTRIB , new Long ( obj . getID ( ) ) . toString ( ) ) ; attribute ( obj , DesignSchemaConstants . EXTENDS_ATTRIB , DesignElement . EXTENDS_PROP ) ; attribute ( obj , DesignSchemaConstants . VIEW_ACTION_ATTRIB , DesignElement . VIEW_ACTION_PROP ) ; property ( obj , DesignElement . COMMENTS_PROP ) ; propertyCDATA ( obj , DesignElement . CUSTOM_XML_PROP ) ; resourceKey ( obj , DesignElement . DISPLAY_NAME_ID_PROP , DesignElement . DISPLAY_NAME_PROP ) ; property ( obj , DesignElement . EVENT_HANDLER_CLASS_PROP ) ; writeUserPropertyDefns ( obj ) ; writeUserPropertyValues ( obj ) ; writeStructureList ( obj , DesignElement . PROPERTY_MASKS_PROP ) ; }	writeStructureList ( obj , IDesignElementModel . PROPERTY_MASKS_PROP ) ;
internalBringToTop ( getReference ( part ) ) ; <CTX> public void activate ( IWorkbenchPart part ) { / / Sanity check . if ( ! certifyPart ( part ) ) return ; if ( window . isClosing ( ) ) return ; / / If zoomed , unzoom . zoomOutIfNecessary ( part ) ; if ( part instanceof MultiEditor ) { part = ( ( MultiEditor ) part ) . getActiveEditor ( ) ; } / / Activate part . / / if ( window . getActivePage ( ) == this ) { internalBringToTop ( getReference ( part ) ) ; setActivePart ( part ) ; }	IWorkbenchPartReference ref = getReference ( part ) ; internalBringToTop ( ref ) ;
( DomCharacterData ) getHtmlElementOrDie ( ) ; <CTX> public void jsSet_data ( final String newValue ) { final DomCharacterData domCharacterData = ( DomCharacterData ) getHtmlElementOrDie ( ) ; domCharacterData . setData ( newValue ) ; }	( DomCharacterData ) getDomNodeOrDie ( ) ;
return getStringProperty ( SimpleDataSet . ON_FETCH_METHOD ) ; <CTX> public String getOnFetch ( ) { return getStringProperty ( SimpleDataSet . ON_FETCH_METHOD ) ; }	return getStringProperty ( ISimpleDataSetModel . ON_FETCH_METHOD ) ;
ibalance ( bh ) ; <CTX> public synchronized Position createPosition ( int offset ) { PosBottomHalf bh ; if ( root == null ) root = bh = new PosBottomHalf ( offset ) ; else { bh = root . find ( offset ) ; if ( bh == null ) { bh = new PosBottomHalf ( offset ) ; bh . red = true ; root . insert ( bh ) ; ibalance ( bh ) ; } else bh . ref ++ ; } if ( Debug . POSITION_DEBUG ) root . dump ( 0 ) ; return new PosTopHalf ( bh ) ; } / / } } }	if ( ! Debug . DISABLE_POSITION_BALANCE ) ibalance ( bh ) ;
log . log ( Level . WARNING , e . getMessage ( ) , e ) ; <CTX> public static void handleOnPrepare ( ListGroupHandle groupHandle , ExecutionContext context ) { try { IListGroup group = new ListGroup ( groupHandle ) ; if ( handleJS ( group , groupHandle . getOnPrepare ( ) , context ) . didRun ( ) ) return ; IListGroupEventHandler eh = ( IListGroupEventHandler ) getInstance ( groupHandle ) ; if ( eh != null ) eh . onPrepare ( group , context . getReportContext ( ) ) ; } catch ( Exception e ) { log . log ( Level . WARNING , e . getMessage ( ) , e ) ; } }	addException ( context , e ) ;
int index = indexFromString ( s ) ; if ( index != NO_INDEX || ( s . length ( ) == 1 && s . charAt ( 0 ) == NO_INDEX_CHAR ) ) { return null ; } <CTX> static String getStringId ( Object id ) { if ( id instanceof Number ) { double d = ( ( Number ) id ) . doubleValue ( ) ; int index = ( int ) d ; if ( ( ( double ) index ) == d ) return null ; return toString ( id ) ; } String s = toString ( id ) ; int index = indexFromString ( s ) ; if ( index != NO_INDEX || ( s . length ( ) == 1 && s . charAt ( 0 ) == NO_INDEX_CHAR ) ) { return null ; } return s ; }	long indexTest = indexFromString ( s ) ; if ( indexTest >= 0 ) return null ;
Double o 0 = getDoubleArg ( evaluator , args , 0 ) , o 1 = getDoubleArg ( evaluator , args , 1 ) ; return toBoolean ( o 0 . compareTo ( o 1 ) <= 0 ) ; <CTX> public Object evaluate ( Evaluator evaluator , Exp [ ] args ) { Double o 0 = getDoubleArg ( evaluator , args , 0 ) , o 1 = getDoubleArg ( evaluator , args , 1 ) ; return toBoolean ( o 0 . compareTo ( o 1 ) <= 0 ) ; }	String o 0 = getStringArg ( evaluator , args , 0 , null ) , o 1 = getStringArg ( evaluator , args , 1 , null ) ; return toBoolean ( ! o 0 . equals ( o 1 ) ) ;
if ( currentChild . getId ( ) . equals ( id ) ) return currentChild ; <CTX> protected WizardCollectionElement getChildWithID ( WizardCollectionElement parent , String id ) { Object [ ] children = parent . getChildren ( null ) ; for ( int i = 0 ; i < children . length ; ++ i ) { WizardCollectionElement currentChild = ( WizardCollectionElement ) children [ i ] ; if ( currentChild . getId ( ) . equals ( id ) ) return currentChild ; } return null ; }	if ( currentChild . getId ( ) . equals ( id ) ) { return currentChild ; }
return getSlot ( TableRow . CONTENT_SLOT ) ; <CTX> public SlotHandle getCells ( ) { return getSlot ( TableRow . CONTENT_SLOT ) ; }	return getSlot ( ITableRowModel . CONTENT_SLOT ) ;
( ( WorkbenchWindow ) window ) . addToTrim ( this , SWT . LEFT ) ; <CTX> private void showPerspectiveBar ( ) { switch ( currentLocation ) { case TOP_LEFT : topBar . setRight ( null ) ; topBar . setBottom ( perspectiveCoolBarWrapper . getControl ( ) ) ; break ; case TOP_RIGHT : topBar . setBottom ( null ) ; topBar . setRight ( perspectiveCoolBarWrapper . getControl ( ) ) ; topBar . setRightWidth ( DEFAULT_RIGHT_X ) ; break ; case LEFT : topBar . setBottom ( null ) ; topBar . setRight ( null ) ; LayoutUtil . resize ( topBar ) ; ( ( WorkbenchWindow ) window ) . addToTrim ( this , SWT . LEFT ) ; break ; default : return ; } LayoutUtil . resize ( perspectiveBar . getControl ( ) ) ; }	window . getTrimManager ( ) . addTrim ( SWT . LEFT , this ) ;
HWND = WGL . CreateDummyWindow ( rectangle . x , rectangle . y , rectangle . width , rectangle . height ) ; <CTX> public void run ( ) { / / Create a native window and device context HWND = WGL . CreateDummyWindow ( rectangle . x , rectangle . y , rectangle . width , rectangle . height ) ; HDC = WGL . GetDC ( HWND ) ; / / Start the message pump at shutdown WGL . NativeEventLoop ( ) ; }	synchronized ( WindowsGLContextFactory . class ) { HWND = WGL . CreateDummyWindow ( rectangle . x , rectangle . y , rectangle . width , rectangle . height ) ; }
void modifyingCharacterData ( NodeImpl node ) { <CTX> void modifyingCharacterData ( NodeImpl node ) { if ( mutationEvents ) { saveEnclosingAttr ( node ) ; } }	void modifyingCharacterData ( NodeImpl node , boolean replace ) {
handleProblem ( e . createProblemID ( ) , nameArray ) ; <CTX> public IASTTypedefDeclaration createTypedef ( IASTScope scope , String name , IASTAbstractDeclaration mapping , int startingOffset , int startingLine , int nameOffset , int nameEndOffset , int nameLine , char [ ] fn ) throws ASTSemanticException { char [ ] nameArray = name . toCharArray ( ) ; IContainerSymbol containerSymbol = scopeToSymbol ( scope ) ; ISymbol typeSymbol = cloneSimpleTypeSymbol ( nameArray , mapping , null ) ; if ( typeSymbol == null ) handleProblem ( scope , IProblem . SEMANTICS_RELATED , nameArray , nameOffset , nameEndOffset , nameLine , true ) ; setPointerOperators ( typeSymbol , mapping . getPointerOperators ( ) , mapping . getArrayModifiers ( ) ) ; if ( typeSymbol . getType ( ) != ITypeInfo . t_type ) { ISymbol newSymbol = pst . newSymbol ( nameArray , ITypeInfo . t_type ) ; newSymbol . getTypeInfo ( ) . setBit ( true , ITypeInfo . isTypedef ) ; newSymbol . setTypeSymbol ( typeSymbol ) ; typeSymbol = newSymbol ; } else { typeSymbol . getTypeInfo ( ) . setBit ( true , ITypeInfo . isTypedef ) ; } List references = new ArrayList ( ) ; if ( mapping . getTypeSpecifier ( ) instanceof ASTSimpleTypeSpecifier ) { List mappingReferences = ( ( ASTSimpleTypeSpecifier ) mapping . getTypeSpecifier ( ) ) . getReferences ( ) ; if ( mappingReferences != null && ! mappingReferences . isEmpty ( ) ) { for ( int i = 0 ; i < mappingReferences . size ( ) ; ++ i ) { IASTReference r = ( IASTReference ) mappingReferences . get ( i ) ; references . add ( cache . getReference ( r . getOffset ( ) , r . getReferencedElement ( ) ) ) ; } } } try { containerSymbol . addSymbol ( typeSymbol ) ; } catch ( ParserSymbolTableException e ) { handleProblem ( e . createProblemID ( ) , nameArray ) ; } ASTTypedef d = new ASTTypedef ( typeSymbol , mapping , startingOffset , startingLine , nameOffset , nameEndOffset , nameLine , references , filename ) ; attachSymbolExtension ( typeSymbol , d , true ) ; return d ; }	handleProblem ( e . createProblemID ( ) , name ) ;
add ( myLabel , myLabelConstrains ) ; <CTX> private void insertLabel ( ) { remove ( myLabel ) ; add ( myLabel , myLabelConstrains ) ; }	add ( myLabel , myLabelConstraints ) ;
RefCountHolder refCountHolder ) { <CTX> public static HighlightInfo checkClassDoesNotCallSuperConstructorOrHandleExceptions ( PsiClass aClass , RefCountHolder refCountHolder ) { if ( aClass . isEnum ( ) ) return null ; / / check only no - ctr classes . Problem with specific constructor will be highlighted inside it if ( aClass . getConstructors ( ) . length != 0 ) return null ; / / find no - args base class ctr TextRange textRange = ClassUtil . getClassDeclarationTextRange ( aClass ) ; return checkBaseClassDefaultConstructorProblem ( aClass , refCountHolder , textRange , PsiClassType . EMPTY_ARRAY ) ; }	RefCountHolder refCountHolder , final PsiResolveHelper resolveHelper ) {
BorderUIResource . LineBorderUIResource lineBorder = new BorderUIResource . LineBorderUIResource ( Color . LIGHT_GRAY , 1 ) ; <CTX> public static Border getInternalFrameBorder ( ) { BevelBorder bevelBorder = new BevelBorder ( 0 , highlight , lightHighlight , darkShadow , shadow ) ; BorderUIResource . LineBorderUIResource lineBorder = new BorderUIResource . LineBorderUIResource ( Color . LIGHT_GRAY , 1 ) ; return new BorderUIResource . CompoundBorderUIResource ( bevelBorder , lineBorder ) ; }	BorderUIResource . LineBorderUIResource lineBorder = new BorderUIResource . LineBorderUIResource ( borderColor , 1 ) ;
return myCanProcessJsp ; <CTX> public boolean processJsp ( ) { return myCanProcessJsp ; }	return true ;
try { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream ( ) ; ObjectOutputStream objectOutputStream = new ObjectOutputStream ( byteArrayOutputStream ) ; objectOutputStream . writeObject ( effectiveArguments ) ; objectOutputStream . flush ( ) ; objectOutputStream . close ( ) ; byteArrayOutputStream . close ( ) ; serializedEffectiveArguments = byteArrayOutputStream . toByteArray ( ) ; <CTX> public void transformEffectiveArgumentsIntoByteArray ( ) { try { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream ( ) ; ObjectOutputStream objectOutputStream = new ObjectOutputStream ( byteArrayOutputStream ) ; objectOutputStream . writeObject ( effectiveArguments ) ; objectOutputStream . flush ( ) ; objectOutputStream . close ( ) ; byteArrayOutputStream . close ( ) ; serializedEffectiveArguments = byteArrayOutputStream . toByteArray ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } effectiveArguments = null ; }	if ( ( serializedEffectiveArguments == null ) && ( effectiveArguments != null ) ) { try { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream ( ) ; ObjectOutputStream objectOutputStream = new ObjectOutputStream ( byteArrayOutputStream ) ; objectOutputStream . writeObject ( effectiveArguments ) ; objectOutputStream . flush ( ) ; objectOutputStream . close ( ) ; byteArrayOutputStream . close ( ) ; serializedEffectiveArguments = byteArrayOutputStream . toByteArray ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } effectiveArguments = null ;
if ( ! EditorManager . saveAll ( intersect , true , getWorkbenchWindow ( ) ) ) return false ; <CTX> public boolean closeEditors ( IEditorReference [ ] editorRefs , boolean save ) { if ( editorRefs . length == 0 ) { return true ; } if ( save ) { / / Intersect the dirty editors with the editors that are closing IEditorPart [ ] dirty = getDirtyEditors ( ) ; List intersect = new ArrayList ( ) ; for ( int i = 0 ; i < editorRefs . length ; i ++ ) { IEditorReference reference = editorRefs [ i ] ; IEditorPart refPart = reference . getEditor ( false ) ; if ( refPart != null ) { for ( int j = 0 ; j < dirty . length ; j ++ ) { if ( refPart . equals ( dirty [ j ] ) && refPart . isSaveOnCloseNeeded ( ) ) { intersect . add ( refPart ) ; break ; } } } } / / Save parts , exit the method if cancel is pressed . if ( intersect . size ( ) > 0 ) { if ( ! EditorManager . saveAll ( intersect , true , getWorkbenchWindow ( ) ) ) return false ; } } / / If the user has not cancelled a possible save request / / and if part is added or removed always unzoom . if ( isZoomed ( ) ) zoomOut ( ) ; / / Deactivate part if the active part is being closed . boolean deactivated = false ; for ( int i = 0 ; i < editorRefs . length ; i ++ ) { IWorkbenchPart part = editorRefs [ i ] . getPart ( false ) ; if ( part == activePart ) { deactivated = true ; setActivePart ( null ) ; } if ( lastActiveEditor == part ) { lastActiveEditor = null ; actionSwitcher . updateTopEditor ( null ) ; } } editorPresentation . getLayoutPart ( ) . deferUpdates ( true ) ; try { / / Close all editors . for ( int i = 0 ; i < editorRefs . length ; i ++ ) { IEditorReference ref = editorRefs [ i ] ; / / Notify interested listeners before the close window . firePerspectiveChanged ( this , getPerspective ( ) , ref , CHANGE_EDITOR_CLOSE ) ; / / Close the editor . getEditorManager ( ) . closeEditor ( ref ) ; activationList . remove ( ref ) ; firePartClosed ( ref ) ; disposePart ( ref ) ; } if ( ! window . isClosing ( ) && deactivated ) { activate ( activationList . getActive ( ) ) ; } } finally { editorPresentation . getLayoutPart ( ) . deferUpdates ( false ) ; } / / Notify interested listeners after the close window . firePerspectiveChanged ( this , getPerspective ( ) , CHANGE_EDITOR_CLOSE ) ; / / Return true on success . return true ; }	if ( intersect . size ( ) == 1 ) { if ( ! getEditorManager ( ) . saveEditor ( ( IEditorPart ) ( intersect . get ( 0 ) ) , true ) ) { return false ; } } else { if ( ! EditorManager . saveAll ( intersect , true , getWorkbenchWindow ( ) ) ) return false ; }
return_body ; <CTX> public String getBody ( ) { return_body ; }	return body ;
synchronized ( dataSpace ) { synchronized ( nameSpace ) { dataSpace . putAll ( updateMap ) ; nameSpace . putAll ( newNames ) ; for ( Long id : deleteSet ) { dataSpace . remove ( id ) ; } } <CTX> public void atomicUpdate ( boolean clear , Map < String , Long > newNames , Set < Long > deleteSet , Map < Long , byte [ ] > updateMap , Set < Long > insertSet ) { / / insert set is ignored in this case as its uneeded detail synchronized ( dataSpace ) { synchronized ( nameSpace ) { dataSpace . putAll ( updateMap ) ; nameSpace . putAll ( newNames ) ; for ( Long id : deleteSet ) { dataSpace . remove ( id ) ; } } } }	synchronized ( dataSpace ) { dataSpace . putAll ( updateMap ) ;
return fTextTools . getStringScanner ( ) ; <CTX> protected RuleBasedScanner getStringScanner ( ) { return fTextTools . getStringScanner ( ) ; }	return fStringScanner ;
abstract public void close ( ) throws IOException ; <CTX> abstract public void close ( ) throws IOException ;	public abstract void close ( ) throws IOException ;
renamedClass , aClass ) ) ; <CTX> public void addClassCollisions ( PsiElement referenceElement , String newName , List < UsageInfo > results ) { final PsiClass renamedClass = myRenamedClass ; final PsiResolveHelper resolveHelper = referenceElement . getManager ( ) . getResolveHelper ( ) ; final PsiSearchHelper searchHelper = referenceElement . getManager ( ) . getSearchHelper ( ) ; final PsiClass aClass = resolveHelper . resolveReferencedClass ( newName , referenceElement ) ; if ( aClass == null ) return ; final PsiFile containingFile = referenceElement . getContainingFile ( ) ; final String text = referenceElement . getText ( ) ; if ( Comparing . equal ( myRenamedClassQualifiedName , removeSpaces ( text ) ) ) return ; if ( myProcessedFiles . contains ( containingFile ) ) return ; final PsiReference [ ] references = searchHelper . findReferences ( aClass , new LocalSearchScope ( containingFile ) , false ) ; for ( PsiReference reference : references ) { final PsiElement collisionReferenceElement = reference . getElement ( ) ; if ( collisionReferenceElement instanceof PsiJavaCodeReferenceElement ) { final PsiElement parent = collisionReferenceElement . getParent ( ) ; if ( ! ( parent instanceof PsiImportStatement ) ) { if ( aClass . getQualifiedName ( ) != null ) { results . add ( new ClassHidesImportedClassUsageInfo ( ( PsiJavaCodeReferenceElement ) collisionReferenceElement , renamedClass , aClass ) ) ; } else { results . add ( new ClassHidesUnqualifiableClassUsageInfo ( ( PsiJavaCodeReferenceElement ) collisionReferenceElement , renamedClass , aClass ) ) ; } } else { results . add ( new CollidingClassImportUsageInfo ( ( PsiImportStatement ) parent , renamedClass ) ) ; } } } myProcessedFiles . add ( containingFile ) ; }	myRenamedClass , aClass ) ) ;
generateOutputDRAMCommands ( output , init , primepump , filter , items ) ; <CTX> private static void outputDRAMCommands ( OutputTraceNode output , boolean init , boolean primepump ) { FilterTraceNode filter = ( FilterTraceNode ) output . getPrevious ( ) ; / / don t do anything for a redundant buffer if ( output . oneOutput ( ) && InterTraceBuffer . getBuffer ( output . getSingleEdge ( ) ) . redundant ( ) ) return ; FilterInfo filterInfo = FilterInfo . getFilterInfo ( filter ) ; / / calculate the number of items sent int items = filterInfo . totalItemsSent ( init , primepump ) ; if ( primepump ) items -= filterInfo . primePumpItemsNotConsumed ( ) ; generateOutputDRAMCommands ( output , init , primepump , filter , items ) ; / / take care of the primepump items not consumed in the primepump stage / / place them in the steady buffer . if ( primepump ) generateOutputDRAMCommands ( output , init , primepump , filter , filterInfo . primePumpItemsNotConsumed ( ) ) ; }	generateOutputDRAMCommands ( output , init , primepump , filter , items , stage ) ;
return INPUT ; <CTX> public String input ( ) throws ContinuumException { if ( executor == null ) { if ( projectId != 0 ) { executor = getContinuum ( ) . getProject ( projectId ) . getExecutorId ( ) ; } else { List projects = getContinuum ( ) . getProjectGroup ( projectGroupId ) . getProjects ( ) ; if ( projects . size ( ) > 0 ) { Project project = ( Project ) projects . get ( 0 ) ; executor = project . getExecutorId ( ) ; } } } if ( buildDefinitionId != 0 ) { BuildDefinition buildDefinition = getContinuum ( ) . getBuildDefinition ( buildDefinitionId ) ; goals = buildDefinition . getGoals ( ) ; arguments = buildDefinition . getArguments ( ) ; buildFile = buildDefinition . getBuildFile ( ) ; buildFresh = buildDefinition . isBuildFresh ( ) ; scheduleId = buildDefinition . getSchedule ( ) . getId ( ) ; defaultBuildDefinition = buildDefinition . isDefaultForProject ( ) ; } return INPUT ; }	return SUCCESS ;
Iterator it = badOverrideMap . values ( ) . iterator ( ) ; <CTX> public void visitAfter ( JavaClass obj ) { Iterator it = badOverrideMap . values ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { BugInstance bi = ( BugInstance ) it . next ( ) ; if ( bi != null ) bugReporter . reportBug ( bi ) ; } }	Iterator < BugInstance > it = badOverrideMap . values ( ) . iterator ( ) ;
String result = getValue ( ) . toLowerCase ( ) ; if ( result . equals ( getValue ( ) ) ) { <CTX> public IRubyObject downcase_bang ( ) { String result = getValue ( ) . toLowerCase ( ) ; if ( result . equals ( getValue ( ) ) ) { return getRuntime ( ) . getNil ( ) ; } setValue ( result ) ; return this ; }	String result = toString ( ) . toLowerCase ( ) ; if ( sameAs ( result ) ) {
this . m_entryLruCache = null ; this . m_resourceMap = null ; <CTX> protected void finalize ( ) throws Throwable { this . clear ( ) ; this . m_entryLruCache = null ; this . m_resourceMap = null ; super . finalize ( ) ; }	this . m_variationCache = null ; this . m_keyCache = null ;
if ( ref == getActiveEditor ( ) ) { <CTX> private void makeActiveEditor ( IEditorReference ref ) { if ( ref == getActiveEditor ( ) ) { return ; } IEditorPart part = ( ref == null ) ? null : ref . getEditor ( true ) ; if ( part != null ) { editorMgr . setVisibleEditor ( ref , false ) ; navigationHistory . markEditor ( part ) ; } actionSwitcher . updateTopEditor ( part ) ; if ( ref != null ) { activationList . bringToTop ( ref ) ; } partList . setActiveEditor ( ref ) ; }	if ( ref == getActiveEditorReference ( ) ) {
super ( stmt ) ; <CTX> GenericStorablePreparedStatement ( Statement stmt ) { super ( stmt ) ; }	super ( ) ;
String modelName = EOModelGroup . defaultGroup ( ) . entityNamed ( entityName ) . model ( ) . name ( ) ; <CTX> private static synchronized EODatabaseContext databaseContextForEntityNamed ( String entityName , ObjectStoreCoordinator osc ) { String modelName = EOModelGroup . defaultGroup ( ) . entityNamed ( entityName ) . model ( ) . name ( ) ; Hashtable h = osc . databaseContextsForModels ( ) ; EODatabaseContext dbc = ( EODatabaseContext ) h . get ( modelName ) ; return dbc ; }	String modelName = EOModelGroup . modelGroupForObjectStoreCoordinator ( osc ) . entityNamed ( entityName ) . model ( ) . name ( ) ;
Iterator < Integer > iterator = ourJavaKeycodesMap . keySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Integer keyCode = iterator . next ( ) ; <CTX> public static List < String > getVirtualKeycodes ( ) { if ( ourVirtualKeycodes == null ) { ourVirtualKeycodes = new LinkedList < String > ( ) ; Iterator < Integer > iterator = ourJavaKeycodesMap . keySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Integer keyCode = iterator . next ( ) ; ourVirtualKeycodes . add ( ourJavaKeycodesMap . get ( keyCode ) ) ; } } return ourVirtualKeycodes ; }	for ( Integer keyCode : ourJavaKeycodesMap . keySet ( ) ) {
TreeMap incompleteReduceTasks = job . getIncompleteReduceTasks ( ) ; for ( Iterator it = incompleteReduceTasks . keySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { String taskid = ( String ) it . next ( ) ; reports . add ( generateSingleReport ( taskid , job . getTaskStatus ( taskid ) , job . getTaskDiagnosticInfo ( taskid ) , job . getTaskStateString ( taskid ) ) ) ; <CTX> public synchronized Vector [ ] getReduceTaskReport ( String jobid ) { JobInProgress job = ( JobInProgress ) jobs . get ( jobid ) ; if ( job == null ) { return new Vector [ 0 ] ; } else { Vector reports = new Vector ( ) ; TreeMap completeReduceTasks = job . getCompleteReduceTasks ( ) ; for ( Iterator it = completeReduceTasks . keySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { String taskid = ( String ) it . next ( ) ; reports . add ( generateSingleReport ( taskid , job . getTaskStatus ( taskid ) , job . getTaskDiagnosticInfo ( taskid ) , job . getTaskStateString ( taskid ) ) ) ; } TreeMap incompleteReduceTasks = job . getIncompleteReduceTasks ( ) ; for ( Iterator it = incompleteReduceTasks . keySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { String taskid = ( String ) it . next ( ) ; reports . add ( generateSingleReport ( taskid , job . getTaskStatus ( taskid ) , job . getTaskDiagnosticInfo ( taskid ) , job . getTaskStateString ( taskid ) ) ) ; } return ( Vector [ ] ) reports . toArray ( new Vector [ reports . size ( ) ] ) ; } }	Vector incompleteReduceTasks = job . reportTasksInProgress ( false , false ) ; for ( Iterator it = incompleteReduceTasks . iterator ( ) ; it . hasNext ( ) ; ) { TaskInProgress tip = ( TaskInProgress ) it . next ( ) ; reports . add ( tip . generateSingleReport ( ) ) ;
if ( element instanceof ThemeElementCategory ) return 0 ; <CTX> public int category ( Object element ) { if ( element instanceof ThemeElementCategory ) return 0 ; return 1 ; }	if ( element instanceof ThemeElementCategory ) { return 0 ; }
File destinationZipFile = new File ( destinationContextFile . getPath ( ) + ZIPFILE_EXTENSION ) ; Proxy proxySettings = TasksUiPlugin . getDefault ( ) . getProxySettings ( ) ; IAttachmentHandler attachmentHandler = getAttachmentHandler ( ) ; if ( attachmentHandler != null ) { <CTX> public final void retrieveContext ( TaskRepository repository , AbstractRepositoryTask task , RepositoryAttachment attachment ) throws CoreException , IOException { boolean wasActive = false ; if ( task . isActive ( ) ) { wasActive = true ; TasksUiPlugin . getTaskListManager ( ) . deactivateTask ( task ) ; } File destinationContextFile = ContextCorePlugin . getContextManager ( ) . getFileForContext ( task . getHandleIdentifier ( ) ) ; File destinationZipFile = new File ( destinationContextFile . getPath ( ) + ZIPFILE_EXTENSION ) ; Proxy proxySettings = TasksUiPlugin . getDefault ( ) . getProxySettings ( ) ; IAttachmentHandler attachmentHandler = getAttachmentHandler ( ) ; if ( attachmentHandler != null ) { attachmentHandler . downloadAttachment ( repository , task , attachment , destinationZipFile , proxySettings ) ; ZipFileUtil . unzipFiles ( destinationZipFile , TasksUiPlugin . getDefault ( ) . getDataDirectory ( ) ) ; if ( destinationContextFile . exists ( ) ) { TasksUiPlugin . getTaskListManager ( ) . getTaskList ( ) . notifyLocalInfoChanged ( task ) ; if ( wasActive ) { TasksUiPlugin . getTaskListManager ( ) . activateTask ( task ) ; } } } else { MessageDialog . openInformation ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , TasksUiPlugin . TITLE_DIALOG , MESSAGE_ATTACHMENTS_NOT_SUPPORTED + getLabel ( ) ) ; } }	Proxy proxySettings = TasksUiPlugin . getDefault ( ) . getProxySettings ( ) ;
CSTNode statement = rootNode ( Token . KEYWORD_SYNCHRONIZED ) ; <CTX> protected CSTNode synchronizedStatement ( ) throws ReadException , SyntaxException , ExceptionCollector { CSTNode statement = rootNode ( Token . KEYWORD_SYNCHRONIZED ) ; consume ( Token . LEFT_PARENTHESIS ) ; statement . addChild ( expression ( ) ) ; consume ( Token . RIGHT_PARENTHESIS ) ; statement . addChild ( statementBody ( true ) ) ; return statement ; }	consume ( Types . LEFT_PARENTHESIS ) ; statement . add ( expression ( ) ) ; consume ( Types . RIGHT_PARENTHESIS ) ;
super ( ) ; <CTX> public BugzillaSearchPage ( ) { super ( ) ; }	super ( TITLE_BUGZILLA_QUERY ) ; setTitle ( TITLE ) ; setDescription ( DESCRIPTION ) ; setPageComplete ( false ) ;
return m_file . getName ( ) ; <CTX> public String getShortName ( ) { return m_file . getName ( ) ; }	return file . getName ( ) ;
if ( gotoAction != null ) <CTX> void setAction ( IAction action ) { if ( action == gotoAction ) return ; if ( gotoAction != null ) gotoAction . removePropertyChangeListener ( this ) ; gotoAction = action ; if ( gotoAction != null ) gotoAction . addPropertyChangeListener ( this ) ; setLinkEnable ( action != null && action . isEnabled ( ) ) ; }	if ( gotoAction != null ) {
( Subscriber ) iterator . next ( ) ; <CTX> private void dispatch ( Notification e ) { Iterator iterator = subscribers . iterator ( ) ; boolean absorbed = false ; while ( iterator . hasNext ( ) && ! absorbed ) { Subscriber thisSubscriber = ( Subscriber ) iterator . next ( ) ; if ( thisSubscriber . acceptsNotification ( e ) ) { absorbed = thisSubscriber . n . notify ( e ) ; } } }	( Subscriber ) iterator . nextElement ( ) ;
if ( element instanceof JspToken && ( ( JspToken ) element ) . getTokenType ( ) == JspToken . JSP_DIRECTIVE_WHITE_SPACE ) continue ; <CTX> public static PsiElement searchNonSpaceNonCommentBack ( PsiElement element ) { if ( element == null ) return null ; while ( true ) { int offset = element . getTextRange ( ) . getStartOffset ( ) - 1 ; if ( offset < 0 ) return null ; element = element . getContainingFile ( ) . findElementAt ( offset ) ; if ( element == null ) return null ; if ( element instanceof JspToken && ( ( JspToken ) element ) . getTokenType ( ) == JspToken . JSP_DIRECTIVE_WHITE_SPACE ) continue ; if ( ! ( element instanceof PsiWhiteSpace ) && ! ( element instanceof PsiComment ) ) return element ; } }	if ( element instanceof JspToken && ( ( JspToken ) element ) . getTokenType ( ) == JspTokenType . JSP_DIRECTIVE_WHITE_SPACE ) continue ;
return ( ( LongVariableContextEntry ) context ) . left > context . extractor . getLongValue ( right ) ; <CTX> public boolean evaluateCachedLeft ( final VariableContextEntry context , final Object right ) { return ( ( LongVariableContextEntry ) context ) . left > context . extractor . getLongValue ( right ) ; }	return ( ( LongVariableContextEntry ) context ) . left > context . getFieldExtractor ( ) . getLongValue ( right ) ;
boolean held = Thread . currentThread ( ) . holdsLock ( lock ) ; System . out . println ( held ) ; <CTX> public void check ( ) { boolean held = Thread . currentThread ( ) . holdsLock ( lock ) ; System . out . println ( held ) ; }	Thread this_thread = Thread . currentThread ( ) ; System . out . println ( this_thread . holdsLock ( lock ) ) ;
this . defferedSyntaxAllowedAsLitteral = defferedSyntaxAllowedAsLitteral ; <CTX> public JspProperty ( String isXml , String elIgnored , String scriptingInvalid , String pageEncoding , Vector includePrelude , Vector includeCoda , String defferedSyntaxAllowedAsLitteral , String trimDirectiveWhitespaces ) { this . isXml = isXml ; this . elIgnored = elIgnored ; this . scriptingInvalid = scriptingInvalid ; this . pageEncoding = pageEncoding ; this . includePrelude = includePrelude ; this . includeCoda = includeCoda ; this . defferedSyntaxAllowedAsLitteral = defferedSyntaxAllowedAsLitteral ; this . trimDirectiveWhitespaces = trimDirectiveWhitespaces ; }	this . deferedSyntaxAllowedAsLitteral = deferedSyntaxAllowedAsLitteral ;
if ( result != null ) <CTX> protected String fireBindingEvent ( BindingEvent event ) { String result = null ; for ( Iterator bindingEventIter = bindingEventListeners . iterator ( ) ; bindingEventIter . hasNext ( ) ; ) { IBindingListener listener = ( IBindingListener ) bindingEventIter . next ( ) ; result = listener . bindingEvent ( event ) ; if ( result != null ) break ; } if ( result == null ) result = context . fireBindingEvent ( event ) ; return result ; }	if ( result != null ) {
location . sourceStart , location . sourceEnd ) ; <CTX> public void abortDueToInternalError ( String errorMessage , ASTNode location ) { String [ ] arguments = new String [ ] { errorMessage } ; this . handle ( IProblem . Unclassified , arguments , arguments , Error | Abort , location . sourceStart , location . sourceEnd ) ; }	0 , 0 ) ;
klass = ruby . getInterpreter ( ) . getRuby_class ( ) ; <CTX> public void push ( NODE v , NODE b , RubyObject newSelf ) { RubyBlock oldBlock = new RubyBlock ( var , body , self , frame , scope , klass , iter , vmode , flags , dynamicVars , origThread , prev , ruby ) ; var = v ; body = b ; self = newSelf ; frame = ruby . getInterpreter ( ) . getRubyFrame ( ) ; klass = ruby . getInterpreter ( ) . getRuby_class ( ) ; / /_block . frame . file = ruby_sourcefile ; / /_block . frame . line = ruby_sourceline ; scope = ruby . rubyScope ; prev = oldBlock ; iter = ruby . getInterpreter ( ) . getRubyIter ( ) . getIter ( ) ; vmode = ruby . getInterpreter ( ) . getActMethodScope ( ) ; flags = BLOCK_D_SCOPE ; dynamicVars = ruby . getInterpreter ( ) . getDynamicVars ( ) ; }	klass = ruby . getInterpreter ( ) . getRubyClass ( ) ;
return ( SIPHeader ) hlist . getLast ( ) ; <CTX> public SIPHeader getLast ( ) { if ( hlist == null || hlist . isEmpty ( ) ) return null ; return ( SIPHeader ) hlist . getLast ( ) ; }	return ( SIPHeader ) hlist . get ( hlist . size ( ) - 1 ) ;
getContext ( ) . enqueueMethodUsagesProcessor ( refMethod , new GlobalInspectionContextImpl . UsagesProcessor ( ) { <CTX> public boolean queryExternalUsagesRequests ( final InspectionManager manager ) { getRefManager ( ) . iterate ( new RefVisitor ( ) { public void visitElement ( RefEntity refEntity ) { if ( refEntity instanceof RefElement && getDescriptions ( refEntity ) != null ) { refEntity . accept ( new RefVisitor ( ) { public void visitMethod ( final RefMethod refMethod ) { getContext ( ) . enqueueMethodUsagesProcessor ( refMethod , new GlobalInspectionContextImpl . UsagesProcessor ( ) { public boolean process ( PsiReference psiReference ) { ignoreElement ( refMethod ) ; return false ; } } ) ; } } ) ; } } } ) ; return false ; }	globalContext . enqueueMethodUsagesProcessor ( refMethod , new GlobalInspectionContextImpl . UsagesProcessor ( ) {
System . out . println ( result ) ; <CTX> public void doExecute ( AdminCommandsServiceMBean acs ) throws Exception { String result = acs . listComponents ( true , false , true , getState ( ) , getSharedLibraryName ( ) , getServiceAssemblyName ( ) ) ; System . out . println ( result ) ; }	log ( result , Project . MSG_WARN ) ;
MailItem item = getCachedItem ( new Integer ( data . id ) , data . type ) ; <CTX> MailItem getItem ( MailItem . UnderlyingData data ) throws ServiceException { if ( data == null ) return null ; MailItem item = getCachedItem ( new Integer ( data . id ) , data . type ) ; / / XXX : should we sanity - check the cached version to make sure all the data matches ? if ( item != null ) return item ; return MailItem . constructItem ( this , data ) ; }	MailItem item = getCachedItem ( data . id , data . type ) ;
( ( BarSeries ) series ) . setRiserOutline ( ( ColorDefinition ) event . data ) ; <CTX> public void handleEvent ( Event event ) { if ( event . widget . equals ( fccRiserOutline ) ) { ( ( BarSeries ) series ) . setRiserOutline ( ( ColorDefinition ) event . data ) ; } }	if ( event . type == FillChooserComposite . FILL_CHANGED_EVENT ) { ( ( BarSeries ) series ) . setRiserOutline ( ( ColorDefinition ) event . data ) ; }
node . setNextNode ( cond 0 ( node . getNextNode ( ) / * , logop * / ) ) ; <CTX> public Node cond ( Node node ) { / / return cond 1 ( node , 0 ) ; if ( node == null ) { return null ; } if ( node . getType ( ) == Constants . NODE_NEWLINE ) { node . setNextNode ( cond 0 ( node . getNextNode ( ) / * , logop * / ) ) ; return node ; } return cond 0 ( node / * , logop * / ) ; }	node . setNextNode ( cond 0 ( node . getNextNode ( ) ) ) ;
if ( ! WellFormednessUtils . isWellFormed ( binaryRhs ) ) { <CTX> public void visitAssignmentExpression ( @ NotNull PsiAssignmentExpression assignment ) { super . visitAssignmentExpression ( assignment ) ; if ( ! WellFormednessUtils . isWellFormed ( assignment ) ) { return ; } final PsiJavaToken sign = assignment . getOperationSign ( ) ; final IElementType assignmentTokenType = sign . getTokenType ( ) ; if ( ! assignmentTokenType . equals ( JavaTokenType . EQ ) ) { return ; } final PsiExpression lhs = assignment . getLExpression ( ) ; final PsiExpression rhs = assignment . getRExpression ( ) ; if ( ! ( rhs instanceof PsiBinaryExpression ) ) { return ; } final PsiBinaryExpression binaryRhs = ( PsiBinaryExpression ) rhs ; if ( ! WellFormednessUtils . isWellFormed ( binaryRhs ) ) { return ; } final PsiExpression lOperand = binaryRhs . getLOperand ( ) ; if ( SideEffectChecker . mayHaveSideEffects ( lhs ) ) { return ; } if ( ! EquivalenceChecker . expressionsAreEquivalent ( lhs , lOperand ) ) { return ; } registerError ( assignment ) ; }	if ( ! ( binaryRhs . getROperand ( ) != null ) ) {
if ( su instanceof MainFrame ) { prefsIndex = ( ( MainFrame ) su ) . galleries . getSize ( ) ; <CTX> public Gallery ( StatusUpdate su ) { this . su = su ; if ( su instanceof MainFrame ) { prefsIndex = ( ( MainFrame ) su ) . galleries . getSize ( ) ; } }	if ( GalleryRemote . getInstance ( ) . mainFrame != null ) { prefsIndex = GalleryRemote . getInstance ( ) . mainFrame . galleries . getSize ( ) ;
existingOption . setValue ( optionsInfo . getValue ( ) ) ; <CTX> public void readStream ( MessageBuffer messageBuffer ) { / * * List of ( String , String ) The list of options with their current value * * / short listElem = messageBuffer . readInt 16 ( ) ; for ( int i = 0 ; i < ( listElem ) ; i ++ ) { OptionsInfo optionsInfo = new OptionsInfo ( this . parent ) ; optionsInfo . readStream ( messageBuffer ) ; / * now we must take care , wether the option already exists , so that we don t * overwrite this option * / if ( ! this . infoMap . contains ( optionsInfo . getKey ( ) ) ) this . infoMap . put ( optionsInfo . getKey ( ) , optionsInfo ) ; else { / * get the already existing option and change the values : * / OptionsInfo existingOption = ( OptionsInfo ) this . infoMap . get ( optionsInfo . getKey ( ) ) ; existingOption . setValue ( optionsInfo . getValue ( ) ) ; } } this . setChanged ( ) ; this . notifyObservers ( this ) ; }	existingOption . value = optionsInfo . getValue ( ) ;
if ( definition . getValue ( ) != null ) defaultColor = definition . getValue ( ) ; else defaultColor = registry . getRGB ( definition . getDefaultsTo ( ) ) ; <CTX> private static void installColor ( ColorDefinition definition , ITheme theme , IPreferenceStore store , boolean setInRegistry ) { ColorRegistry registry = theme . getColorRegistry ( ) ; String id = definition . getId ( ) ; String key = createPreferenceKey ( theme , id ) ; RGB prefColor = store != null ? PreferenceConverter . getColor ( store , key ) : null ; RGB defaultColor = null ; if ( definition . getValue ( ) != null ) defaultColor = definition . getValue ( ) ; else defaultColor = registry . getRGB ( definition . getDefaultsTo ( ) ) ; if ( setInRegistry ) { if ( prefColor == null || prefColor == PreferenceConverter . COLOR_DEFAULT_DEFAULT ) { prefColor = defaultColor ; } if ( prefColor != null ) { registry . put ( id , prefColor ) ; } } if ( defaultColor != null && store != null ) { PreferenceConverter . setDefault ( store , key , defaultColor ) ; } }	if ( definition . getValue ( ) != null ) { defaultColor = definition . getValue ( ) ; } else { defaultColor = registry . getRGB ( definition . getDefaultsTo ( ) ) ; }
return ( PdfIndirectReference ) imageDictionary . get ( pdfImage . name ( ) ) ; <CTX> public PdfIndirectReference add ( PdfImage pdfImage ) throws PdfException { if ( ! imageDictionary . contains ( pdfImage ) ) { PdfIndirectObject object = body . add ( pdfImage ) ; try { object . writeTo ( os ) ; } catch ( IOException ioe ) { System . err . println ( ioe . getMessage ( ) ) ; } imageDictionary . put ( pdfImage . name ( ) , object . getIndirectReference ( ) ) ; return object . getIndirectReference ( ) ; } return ( PdfIndirectReference ) imageDictionary . get ( pdfImage . name ( ) ) ; }	PdfIndirectObject object = body . add ( contents ) ; try { object . writeTo ( os ) ; os . flush ( ) ; } catch ( IOException ioe ) { System . err . println ( ioe . getMessage ( ) ) ; } page . add ( object . getIndirectReference ( ) ) ; page . setParent ( ROOTREFERENCE ) ; PdfIndirectObject pageObject = body . add ( page ) ; try { pageObject . writeTo ( os ) ; os . flush ( ) ; } catch ( IOException ioe ) { System . err . println ( ioe . getMessage ( ) ) ; } root . add ( pageObject . getIndirectReference ( ) ) ; return pageObject . getIndirectReference ( ) ;
result = cb [ w ] . getNoiseReduction ( ) . booleanValue ( ) ; <CTX> public boolean getChannelNoiseReduction ( int w ) { boolean result ; rwl . readLock ( ) . lock ( ) ; { if ( renderer == null ) throw new IllegalStateException ( NULL_RENDERER ) ; ChannelBinding [ ] cb = renderer . getChannelBindings ( ) ; result = cb [ w ] . getNoiseReduction ( ) . booleanValue ( ) ; } rwl . readLock ( ) . unlock ( ) ; return result ; }	return cb [ w ] . getNoiseReduction ( ) . booleanValue ( ) ; } finally { rwl . readLock ( ) . unlock ( ) ;
if ( setChangeListeners == null ) { boolean hadListeners = hasListeners ( ) ; setChangeListeners = listener ; if ( ! hadListeners ) { firstListenerAdded ( ) ; } return ; } Collection listenerList ; if ( setChangeListeners instanceof Collection ) { listenerList = ( Collection ) setChangeListeners ; } else { ISetChangeListener l = ( ISetChangeListener ) setChangeListeners ; listenerList = new ArrayList ( ) ; listenerList . add ( l ) ; setChangeListeners = listenerList ; } if ( listenerList . size ( ) > 16 ) { HashSet listenerSet = new HashSet ( ) ; listenerSet . addAll ( listenerList ) ; setChangeListeners = listenerList ; } listenerList . add ( listener ) ; <CTX> public void addSetChangeListener ( ISetChangeListener listener ) { if ( setChangeListeners == null ) { boolean hadListeners = hasListeners ( ) ; setChangeListeners = listener ; if ( ! hadListeners ) { firstListenerAdded ( ) ; } return ; } Collection listenerList ; if ( setChangeListeners instanceof Collection ) { listenerList = ( Collection ) setChangeListeners ; } else { ISetChangeListener l = ( ISetChangeListener ) setChangeListeners ; listenerList = new ArrayList ( ) ; listenerList . add ( l ) ; setChangeListeners = listenerList ; } if ( listenerList . size ( ) > 16 ) { HashSet listenerSet = new HashSet ( ) ; listenerSet . addAll ( listenerList ) ; setChangeListeners = listenerList ; } listenerList . add ( listener ) ; }	changeSupport . addListener ( SetChangeEvent . TYPE , listener ) ;
if ( getStyle ( ) . isHidden ( ) ) { <CTX> public void paintBorder ( RenderingContext c ) { if ( getStyle ( ) . isHidden ( ) ) { return ; } Rectangle borderBounds = getPaintingBorderEdge ( c ) ; if ( getState ( ) != Box . DONE ) { borderBounds . height += c . getCanvas ( ) . getHeight ( ) ; } BorderPainter . paint ( borderBounds , getBorderSides ( ) , getStyle ( ) . getCalculatedStyle ( ) , c . getGraphics ( ) , c , 0 ) ; }	if ( ! getStyle ( ) . isVisible ( ) ) {
return LegacyActionTools . removeMnemonics ( action . getText ( ) ) + separator + action . getToolTipText ( ) ; <CTX> public String getLabel ( ) { IAction action = item . getAction ( ) ; if ( action . getToolTipText ( ) != null && action . getToolTipText ( ) . length ( ) != 0 ) { return LegacyActionTools . removeMnemonics ( action . getText ( ) ) + separator + action . getToolTipText ( ) ; } return LegacyActionTools . removeMnemonics ( action . getText ( ) ) ; }	return LegacyActionTools . removeMnemonics ( action . getText ( ) + separator + action . getToolTipText ( ) ) ;
if ( lhs == DBL_MRK ) { <CTX> private static void do_eq ( CallFrame frame , int i , int op ) { boolean result ; Object rhs = frame . stack [ i + 1 ] ; Object lhs = frame . stack [ i ] ; if ( rhs == DBL_MRK ) { if ( lhs == DBL_MRK ) { result = ( frame . sDbl [ i ] == frame . sDbl [ i + 1 ] ) ; } else { result = ScriptRuntime . eqNumber ( frame . sDbl [ i + 1 ] , lhs ) ; } } else { if ( lhs == DBL_MRK ) { result = ScriptRuntime . eqNumber ( frame . sDbl [ i ] , rhs ) ; } else { result = ScriptRuntime . eq ( lhs , rhs ) ; } } result ^= ( op == Token . NE ) ; frame . stack [ i ] = ScriptRuntime . wrapBoolean ( result ) ; }	if ( lhs == UniqueTag . DOUBLE_MARK ) {
return connection . getWarnings ( ) ; <CTX> public SQLWarning getWarnings ( ) throws SQLException { return connection . getWarnings ( ) ; }	return getConnection ( ) . getWarnings ( ) ;
return floatToIntBits ( value ) == floatToIntBits ( f . floatValue ( ) ) ; <CTX> public boolean equals ( Object obj ) { if ( ! ( obj instanceof Float ) ) return false ; Float f = ( Float ) obj ; return floatToIntBits ( value ) == floatToIntBits ( f . floatValue ( ) ) ; }	return floatToIntBits ( value ) == floatToIntBits ( f ) ;
rebuildState = rebuild ; <CTX> public void setRebuildState ( boolean rebuild ) { if ( isExtensionResourceConfiguration ( ) && rebuild ) return ; rebuildState = rebuild ; if ( ! rebuildState ) { ITool tools [ ] = getToolsToInvoke ( ) ; for ( int i = 0 ; i < tools . length ; i ++ ) { tools [ i ] . setRebuildState ( false ) ; } } }	if ( rebuildState != rebuild ) { rebuildState = rebuild ; saveRebuildState ( ) ; }
void setSelectedTypes ( List selectedTypes ) { <CTX> void setSelectedTypes ( List selectedTypes ) { this . selectedTypes = selectedTypes ; }	public void setSelectedTypes ( List selectedTypes ) {
IPreferenceConstants . CURRENT_THEME_ID ) . equals ( id ) ) { <CTX> public void setCurrentTheme ( String id ) { ITheme oldTheme = currentTheme ; if ( WorkbenchThemeManager . getInstance ( ) . doSetCurrentTheme ( id ) ) { firePropertyChange ( CHANGE_CURRENT_THEME , oldTheme , getCurrentTheme ( ) ) ; if ( oldTheme != null ) oldTheme . removePropertyChangeListener ( currentThemeListener ) ; currentTheme . addPropertyChangeListener ( currentThemeListener ) ; / / update the preference if required . if ( ! WorkbenchPlugin . getDefault ( ) . getPreferenceStore ( ) . getString ( IPreferenceConstants . CURRENT_THEME_ID ) . equals ( id ) ) { WorkbenchPlugin . getDefault ( ) . getPreferenceStore ( ) . setValue ( IPreferenceConstants . CURRENT_THEME_ID , id ) ; / / $ NON - NLS - 1 $ WorkbenchPlugin . getDefault ( ) . savePluginPreferences ( ) ; } / / update the jface registries { ColorRegistry jfaceColors = JFaceResources . getColorRegistry ( ) ; ColorRegistry themeColors = currentTheme . getColorRegistry ( ) ; for ( Iterator i = themeColors . getKeySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String key = ( String ) i . next ( ) ; jfaceColors . put ( key , themeColors . getRGB ( key ) ) ; } } { FontRegistry jfaceFonts = JFaceResources . getFontRegistry ( ) ; FontRegistry themeFonts = currentTheme . getFontRegistry ( ) ; for ( Iterator i = themeFonts . getKeySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String key = ( String ) i . next ( ) ; jfaceFonts . put ( key , themeFonts . getFontData ( key ) ) ; } } } }	IWorkbenchPreferenceConstants . CURRENT_THEME_ID ) . equals ( id ) ) {
saveAllResources ( ) ; <CTX> public void run ( ) { / / Save all resources prior to doing build saveAllResources ( ) ; runInBackground ( ResourcesPlugin . getWorkspace ( ) . getRuleFactory ( ) . buildRule ( ) , ResourcesPlugin . FAMILY_MANUAL_BUILD ) ; }	List projects = getProjectsToBuild ( ) ; if ( projects == null || projects . isEmpty ( ) ) return ;
return genotypes [ i ] ; <CTX> public byte elementAt ( int i ) { return genotypes [ i ] ; }	return genotypes [ realIndex [ i ] ] ;
ServiceBroker sb = ( ( AgentChildBinder ) getBindingSite ( ) ) . getServiceBroker ( ) ; <CTX> private CommunityService loadCommunityService ( MessageAddress agentId ) { ServiceBroker sb = ( ( AgentChildBinder ) getBindingSite ( ) ) . getServiceBroker ( ) ; CommunityServiceProvider csp = new CommunityServiceProvider ( sb , agentId , useCache ) ; sb . addService ( CommunityService . class , csp ) ; return ( CommunityService ) sb . getService ( this , CommunityService . class , new ServiceRevokedListener ( ) { public void serviceRevoked ( ServiceRevokedEvent re ) { } } ) ; }	ServiceBroker sb = getBindingSite ( ) . getServiceBroker ( ) ;
log ( urgency , null , str ) ; <CTX> private static PrintStream createPrintStream ( final int urgency ) { return new PrintStream ( new OutputStream ( ) { public void write ( int b ) { byte [ ] barray = { ( byte ) b } ; write ( barray , 0 , 1 ) ; } public void write ( byte [ ] b , int off , int len ) { String str = new String ( b , off , len ) ; log ( urgency , null , str ) ; } } ) ; }	log ( urgency , source , str ) ;
static private Declaration ResolveAmbiguities ( LookupData data , LinkedList items ) throws ParserSymbolTableException { Declaration decl = null ; <CTX> static private Declaration ResolveAmbiguities ( LookupData data , LinkedList items ) throws ParserSymbolTableException { Declaration decl = null ; int size = items . size ( ) ; if ( size == 0 ) { return null ; } else if ( size == 1 ) { return ( Declaration ) items . getFirst ( ) ; } else { Declaration first = ( Declaration ) items . removeFirst ( ) ; / / if first one is a class - name , the next ones hide it if ( first . getType ( ) >= Declaration . t_class && first . getType ( ) <= Declaration . t_enumeration ) { return ResolveAmbiguities ( data , items ) ; } / / else , if the first is an object ( ie not a function ) , the rest must be the same / / declaration . otherwise ( ie it is a function ) , the rest must be functions . boolean needSame = ( first . getType ( ) != Declaration . t_function ) ; Iterator iter = items . iterator ( ) ; for ( int i = ( size - 1 ) ; i > 0 ; i -- ) { decl = ( Declaration ) iter . next ( ) ; if ( needSame ) { if ( decl != first ) { throw new ParserSymbolTableException ( ParserSymbolTableException . r_AmbiguousName ) ; } } else { if ( decl . getType ( ) != Declaration . t_function ) { throw new ParserSymbolTableException ( ParserSymbolTableException . r_AmbiguousName ) ; } } } if ( needSame ) { return first ; } else { items . addFirst ( first ) ; return ResolveFunction ( data , items ) ; } } }	static private Declaration ResolveAmbiguities ( LookupData data , HashSet items ) throws ParserSymbolTableException {
if ( ! evt . isShiftDown ( ) ) <CTX> public void keyPressed ( KeyEvent evt ) { int lead = BasicListUI . this . list . getLeadSelectionIndex ( ) ; int max = BasicListUI . this . list . getModel ( ) . getSize ( ) - 1 ; / / Do nothing if list is empty if ( max == - 1 ) return ; / / Process the key event . Bindings can be found in / / javax . swing . plaf . basic . BasicLookAndFeel . java if ( ( evt . getKeyCode ( ) == KeyEvent . VK_DOWN ) || ( evt . getKeyCode ( ) == KeyEvent . VK_KP_DOWN ) ) { if ( ! evt . isShiftDown ( ) ) { BasicListUI . this . list . clearSelection ( ) ; BasicListUI . this . list . setSelectedIndex ( Math . min ( lead + 1 , max ) ) ; } else { BasicListUI . this . list . getSelectionModel ( ) . setLeadSelectionIndex ( Math . min ( lead + 1 , max ) ) ; } } else if ( ( evt . getKeyCode ( ) == KeyEvent . VK_UP ) || ( evt . getKeyCode ( ) == KeyEvent . VK_KP_UP ) ) { if ( ! evt . isShiftDown ( ) ) { BasicListUI . this . list . clearSelection ( ) ; BasicListUI . this . list . setSelectedIndex ( Math . max ( lead - 1 , 0 ) ) ; } else { BasicListUI . this . list . getSelectionModel ( ) . setLeadSelectionIndex ( Math . max ( lead - 1 , 0 ) ) ; } } else if ( evt . getKeyCode ( ) == KeyEvent . VK_PAGE_UP ) { / / FIXME : implement , need JList . ensureIndexIsVisible to work } else if ( evt . getKeyCode ( ) == KeyEvent . VK_PAGE_DOWN ) { / / FIXME : implement , need JList . ensureIndexIsVisible to work } else if ( evt . getKeyCode ( ) == KeyEvent . VK_BACK_SLASH && evt . isControlDown ( ) ) { BasicListUI . this . list . clearSelection ( ) ; } else if ( ( evt . getKeyCode ( ) == KeyEvent . VK_HOME ) || evt . getKeyCode ( ) == KeyEvent . VK_END ) { / / index is either 0 for HOME , or last cell for END int index = ( evt . getKeyCode ( ) == KeyEvent . VK_HOME ) ? 0 : max ; if ( ! evt . isShiftDown ( ) || ( BasicListUI . this . list . getSelectionMode ( ) == ListSelectionModel . SINGLE_SELECTION ) ) BasicListUI . this . list . setSelectedIndex ( index ) ; else if ( BasicListUI . this . list . getSelectionMode ( ) == ListSelectionModel . SINGLE_INTERVAL_SELECTION ) BasicListUI . this . list . setSelectionInterval ( BasicListUI . this . list . getAnchorSelectionIndex ( ) , index ) ; else BasicListUI . this . list . getSelectionModel ( ) . setLeadSelectionIndex ( index ) ; } else if ( ( evt . getKeyCode ( ) == KeyEvent . VK_A || evt . getKeyCode ( ) == KeyEvent . VK_SLASH ) && evt . isControlDown ( ) ) { BasicListUI . this . list . setSelectionInterval ( 0 , max ) ; / / this next line is to restore the lead selection index to the old / / position , because select - all should not change the lead index BasicListUI . this . list . addSelectionInterval ( lead , lead ) ; } else if ( evt . getKeyCode ( ) == KeyEvent . VK_SPACE && evt . isControlDown ( ) ) { BasicListUI . this . list . getSelectionModel ( ) . setLeadSelectionIndex ( Math . min ( lead + 1 , max ) ) ; } }	if ( evt . getModifiers ( ) == 0 )
. setSelection ( onResource == MarkerFilter . ON_ANY_RESOURCE_OF_SAME_PROJECT ) ; <CTX> protected void resetPressed ( ) { typesViewer . setAllChecked ( true ) ; int onResource = MarkerFilter . DEFAULT_ON_RESOURCE ; anyResourceButton . setSelection ( onResource == MarkerFilter . ON_ANY_RESOURCE ) ; anyResourceInSameProjectButton . setSelection ( onResource == MarkerFilter . ON_ANY_RESOURCE_OF_SAME_PROJECT ) ; selectedResourceButton . setSelection ( onResource == MarkerFilter . ON_SELECTED_RESOURCE_ONLY ) ; selectedResourceAndChildrenButton . setSelection ( onResource == MarkerFilter . ON_SELECTED_RESOURCE_AND_CHILDREN ) ; workingSetGroup . setSelection ( onResource == MarkerFilter . ON_WORKING_SET ) ; updateEnabledState ( true ) ; }	. setSelection ( onResource == MarkerFilter . ON_ANY_IN_SAME_CONTAINER ) ;
AttributeGroup ag = ( AttributeGroup ) attributeGroups . get ( ( Integer ) iter . next ( ) ) ; <CTX> public List getAllUIAttributeDescriptions ( ) { List atts = new ArrayList ( ) ; for ( Iterator iter = attributeGroups . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { AttributeGroup ag = ( AttributeGroup ) attributeGroups . get ( ( Integer ) iter . next ( ) ) ; atts . addAll ( ag . getAllUIAttributeDescriptions ( ) ) ; } return atts ; }	Object ag = attributeGroups . get ( ( Integer ) iter . next ( ) ) ;
myCurrentFile = createFileInfo ( myCurrentDirectory , path , false ) ; <CTX> public void openFile ( String path , long revision ) throws SVNException { String name = SVNPathUtil . tail ( path ) ; myCurrentFile = createFileInfo ( myCurrentDirectory , path , false ) ; myCurrentDirectory . myComparedEntries . add ( name ) ; }	myCurrentFile = createFileInfo ( path , false ) ;
resolvedVersion = new CLDRFile ( new ResolvingSource ( dataSource ) ) ; <CTX> public CLDRFile getResolved ( ) { if ( dataSource instanceof ResolvingSource ) return this ; if ( resolvedVersion == null ) { resolvedVersion = new CLDRFile ( new ResolvingSource ( dataSource ) ) ; } return resolvedVersion ; }	resolvedVersion = new CLDRFile ( dataSource , true ) ;
if ( feature . equals ( Constants . SCHEMA_FULL_CHECKING ) ) { <CTX> protected void checkFeature ( String featureId ) throws XMLConfigurationException { / / / / Xerces Features / / if ( featureId . startsWith ( Constants . XERCES_FEATURE_PREFIX ) ) { String feature = featureId . substring ( Constants . XERCES_FEATURE_PREFIX . length ( ) ) ; / / / / http : / / apache . org / xml / features / validation / schema / / Lets the user turn Schema validation support on / off . / / if ( feature . equals ( Constants . SCHEMA_VALIDATION_FEATURE ) ) { return ; } / / activate full schema checking if ( feature . equals ( Constants . SCHEMA_FULL_CHECKING ) ) { return ; } / / Feature identifier : expose schema normalized value / / http : / / apache . org / xml / features / validation / schema / normalized - value if ( feature . equals ( Constants . SCHEMA_NORMALIZED_VALUE ) ) { return ; } / / Feature identifier : send element default value via characters ( ) / / http : / / apache . org / xml / features / validation / schema / element - default if ( feature . equals ( Constants . SCHEMA_ELEMENT_DEFAULT ) ) { return ; } } / / / / Not recognized / / super . checkFeature ( featureId ) ; } / / checkFeature ( String )	if ( featureId . regionMatches ( prefixLength , Constants . SCHEMA_FULL_CHECKING , 0 , Constants . SCHEMA_FULL_CHECKING . length ( ) ) ) {
oldGroupingUnit , groupingUnit ) ) ; <CTX> public void setGroupingUnit ( String newGroupingUnit ) { String oldGroupingUnit = groupingUnit ; groupingUnit = newGroupingUnit ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , DataPackage . SERIES_GROUPING__ GROUPING_UNIT , oldGroupingUnit , groupingUnit ) ) ; }	oldGroupingUnit , groupingUnit , ! oldGroupingUnitESet ) ) ;
Workbench . getInstance ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) . addShellListener ( SHELL_LISTENER ) ; MylarPlugin . getDefault ( ) . getPluginPreferences ( ) . addPropertyChangeListener ( PREFERENCE_LISTENER ) ; taskListManager . readTaskList ( ) ; if ( taskListManager . getTaskList ( ) == null ) taskListManager . createNewTaskList ( ) ; } <CTX> public void run ( ) { Workbench . getInstance ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) . addShellListener ( SHELL_LISTENER ) ; MylarPlugin . getDefault ( ) . getPluginPreferences ( ) . addPropertyChangeListener ( PREFERENCE_LISTENER ) ; taskListManager . readTaskList ( ) ; if ( taskListManager . getTaskList ( ) == null ) taskListManager . createNewTaskList ( ) ; }	TasksReminderDialog dialog = new TasksReminderDialog ( Workbench . getInstance ( ) . getDisplay ( ) . getActiveShell ( ) , parser . getTasks ( ) ) ; dialog . setBlockOnOpen ( false ) ; dialog . open ( ) ; }
runExec ( prepareExec ( ) ) ; <CTX> public void execute ( ) throws BuildException { checkConfiguration ( ) ; if ( isValidOs ( ) ) { runExec ( prepareExec ( ) ) ; } }	try { runExec ( prepareExec ( ) ) ; } finally { dir = savedDir ; }
if ( m_resource != null ) <CTX> public void execute ( ) throws TaskException { validate ( ) ; if ( ( m_name != null ) && ( m_value != null ) ) { setProperty ( m_name , m_value ) ; } if ( m_resource != null ) loadResource ( m_resource ) ; }	if ( m_resource != null ) {
quickRedraw = LayerUtils . booleanFromProperties ( properties , prefix <CTX> public void setProperties ( String prefix , java . util . Properties properties ) { super . setProperties ( prefix , properties ) ; props = properties ; ( ( CRFPClient ) frameProvider ) . setProperties ( prefix , properties ) ; quickRedraw = LayerUtils . booleanFromProperties ( properties , prefix + QuickRedrawProperty , false ) ; }	quickRedraw = PropUtils . booleanFromProperties ( properties , prefix
return ( PropertyAccessor ) accessors . get ( propertyName ) ; <CTX> public IPropertyAccessor getAccessor ( Object instance , String propertyName ) { if ( accessors == null ) buildPropertyAccessors ( ) ; synchronized ( accessors ) { return ( PropertyAccessor ) accessors . get ( propertyName ) ; } }	return ( IPropertyAccessor ) accessors . get ( propertyName ) ;
if ( isActive ( ) ) <CTX> public void stackChanged ( ActivityStackEvent event ) { if ( isActive ( ) ) { reloadEditorInput ( ) ; } }	if ( isActive ( ) && event . getAction ( ) != ActivityStackEvent . ROLL_BACK )
if ( getParent ( ) instanceof MenuManager ) ( ( MenuManager ) getParent ( ) ) . addMenuListener ( menuListener ) ; <CTX> public void fill ( Menu menu , int index ) { if ( getParent ( ) instanceof MenuManager ) ( ( MenuManager ) getParent ( ) ) . addMenuListener ( menuListener ) ; if ( ! dirty ) return ; MenuManager manager = new MenuManager ( ) ; fillMenu ( manager ) ; IContributionItem [ ] items = manager . getItems ( ) ; if ( items . length == 0 ) { MenuItem item = new MenuItem ( menu , SWT . NONE , index ++ ) ; item . setText ( NO_TARGETS_MSG ) ; item . setEnabled ( false ) ; } else { for ( int i = 0 ; i < items . length ; i ++ ) { items [ i ] . fill ( menu , index ++ ) ; } } dirty = false ; }	if ( getParent ( ) instanceof MenuManager ) { ( ( MenuManager ) getParent ( ) ) . addMenuListener ( menuListener ) ; }
if ( value instanceof NativeJavaObject ) { <CTX> public boolean hasInstance ( Scriptable value ) { if ( value instanceof NativeJavaObject ) { Object instance = ( ( NativeJavaObject ) value ) . unwrap ( ) ; return getClassObject ( ) . isInstance ( instance ) ; } / / value wasn t something we understand return false ; }	if ( value instanceof NativeJavaObject && ! ( value instanceof NativeJavaClass ) ) {
IStructuredSelection currentSelection , AdaptableList elements ) { <CTX> public WorkbenchWizardSelectionPage ( String name , IWorkbench aWorkbench , IStructuredSelection currentSelection , AdaptableList elements ) { super ( name ) ; this . wizardElements = elements ; this . currentResourceSelection = currentSelection ; this . workbench = aWorkbench ; setTitle ( WorkbenchMessages . Select ) ; }	IStructuredSelection currentSelection , AdaptableList elements , String triggerPointId ) {
out . write ( 1 ) ; <CTX> public static void writeStreamable ( Streamable obj , DataOutputStream out ) throws IOException { if ( obj == null ) { out . write ( 0 ) ; return ; } out . write ( 1 ) ; obj . writeTo ( out ) ; }	out . writeBoolean ( true ) ;
} else { if ( ! ( result instanceof NativeJavaClass ) ) { while ( result instanceof Wrapper ) { result = ( ( Wrapper ) result ) . unwrap ( ) ; } <CTX> public Object next ( ) { Context . enter ( ) ; try { Object result = ScriptableObject . getProperty ( scope , ids [ index ++ ] . toString ( ) ) ; if ( result == Undefined . instance || result == Scriptable . NOT_FOUND ) { result = null ; } else { if ( ! ( result instanceof NativeJavaClass ) ) { while ( result instanceof Wrapper ) { result = ( ( Wrapper ) result ) . unwrap ( ) ; } } } return result ; } finally { Context . exit ( ) ; } }	} else if ( ! ( result instanceof NativeJavaClass ) ) { while ( result instanceof Wrapper ) { result = ( ( Wrapper ) result ) . unwrap ( ) ;
return new primitiveArrayTypeCode ( TCKind . tk_long ) ; <CTX> public static TypeCode type ( ) { return new primitiveArrayTypeCode ( TCKind . tk_long ) ; }	return new primitiveArrayTypeCode ( TCKind . tk_ulong ) ;
Cur c = d . locale ( ) . permCur ( ) ; c . moveToDom ( d ) ; <CTX> public static void test ( Node n ) { Dom d = ( Dom ) n ; Cur c = d . locale ( ) . permCur ( ) ; c . moveToDom ( d ) ; c . dump ( ) ; c . next ( ) ; c . next ( ) ; c . nextWithAttrs ( ) ; / / c . setType ( XmlObject . type ) ; / / TypeStore store = c . getTypeStore ( ) ; / / store . invalidate_text ( ) ; c . dump ( ) ; c . release ( ) ; }	CharUtil . dumpChars ( System . out , src , cu ._offSrc , cu ._cchSrc ) ;
return getStringProperty ( Style . DISPLAY_PROP ) ; <CTX> public String getDisplay ( ) { return getStringProperty ( Style . DISPLAY_PROP ) ; }	return getStringProperty ( IStyleModel . DISPLAY_PROP ) ;
return ( Icon ) getLookAndFeelDefaults ( ) . get ( key ) ; <CTX> public static Icon getIcon ( Object key ) { return ( Icon ) getLookAndFeelDefaults ( ) . get ( key ) ; }	return ( Icon ) get ( key ) ;
callback . writeToStream ( str . toCharArray ( ) ) ; <CTX> public void writeChars ( String str ) throws IOException { callback . writeToStream ( str . toCharArray ( ) ) ; }	peekCallback ( ) . writeToStream ( str . toCharArray ( ) ) ;
currentElement = bindingElement . getParent ( ) ; <CTX> public void setBinding ( PipelineContext pipelineContext , Element bindingElement ) { / / Reinitialize context stack initialize ( ) ; / / Create ancestors - or - self list final List ancestorsOrSelf = new ArrayList ( ) ; Element currentElement = bindingElement ; while ( currentElement != null ) { ancestorsOrSelf . add ( currentElement ) ; currentElement = bindingElement . getParent ( ) ; } / / Bind up to the specified element Collections . reverse ( ancestorsOrSelf ) ; for ( Iterator i = ancestorsOrSelf . iterator ( ) ; i . hasNext ( ) ; ) { pushBinding ( pipelineContext , ( Element ) i . next ( ) ) ; } }	currentElement = currentElement . getParent ( ) ;
handlers . add ( handler ) ; <CTX> private void insertHandler ( HandlerDescription handler ) throws PhaseException { int type = getBeforeAfter ( handler . getHandler ( ) ) ; validateafter ( handler . getHandler ( ) ) ; validatebefore ( handler . getHandler ( ) ) ; switch ( type ) { case BOTH_BEFORE_AFTER : { insertBeforeandAfter ( handler . getHandler ( ) ) ; } case BEFORE : { insertBefore ( handler . getHandler ( ) ) ; } case AFTER : { insertAfter ( handler . getHandler ( ) ) ; } case ANYWHERE : { handlers . add ( handler ) ; } } }	handlers . add ( handler . getHandler ( ) ) ;
dim . breakOnReturn = value ; debugGui . menubar . breakOnReturn . setSelected ( value ) ; <CTX> public void setBreakOnReturn ( boolean value ) { dim . breakOnReturn = value ; debugGui . menubar . breakOnReturn . setSelected ( value ) ; }	dim . setBreakOnReturn ( value ) ; debugGui . getMenubar ( ) . getBreakOnReturn ( ) . setSelected ( value ) ;
loadSchema ( fXSDDescription , xis , locationPairs ) ; <CTX> private void processJAXPSchemaSource ( Hashtable locationPairs ) throws IOException { if ( fJAXPSource == null ) { return ; } Class componentType = fJAXPSource . getClass ( ) . getComponentType ( ) ; XMLInputSource xis = null ; String sid = null ; if ( componentType == null ) { / / Not an array xis = xsdToXMLInputSource ( fJAXPSource ) ; sid = xis . getSystemId ( ) ; fXSDDescription . fContextType = XSDDescription . CONTEXT_PREPARSE ; if ( sid != null ) { fXSDDescription . setLiteralSystemId ( sid ) ; fXSDDescription . setExpandedSystemId ( sid ) ; fXSDDescription . fLocationHints = new String [ ] { sid } ; } loadSchema ( fXSDDescription , xis , locationPairs ) ; return ; } else if ( componentType != Object . class ) { / / Not an Object [ ] throw new XMLConfigurationException ( XMLConfigurationException . NOT_SUPPORTED , JAXP_SCHEMA_SOURCE ) ; } Object [ ] objArr = ( Object [ ] ) fJAXPSource ; for ( int i = 0 ; i < objArr . length ; i ++ ) { xis = xsdToXMLInputSource ( objArr [ i ] ) ; sid = xis . getSystemId ( ) ; fXSDDescription . reset ( ) ; fXSDDescription . fContextType = XSDDescription . CONTEXT_PREPARSE ; if ( sid != null ) { fXSDDescription . setLiteralSystemId ( sid ) ; fXSDDescription . setExpandedSystemId ( sid ) ; fXSDDescription . fLocationHints = new String [ ] { sid } ; } loadSchema ( fXSDDescription , xis , locationPairs ) ; } }	fGrammarBucket . putGrammar ( loadSchema ( fXSDDescription , xis , locationPairs ) ) ;
return doCall ( cx , finalScope , thisObj , f , args , argsToWrap ) ; <CTX> public Object run ( Context cx ) { return doCall ( cx , finalScope , thisObj , f , args , argsToWrap ) ; }	return doCall ( cx , scope , thisObj , f , args , argsToWrap ) ;
OutputStream setAsciiStream ( long pos ) throws SQLException ; <CTX> OutputStream setAsciiStream ( long pos ) throws SQLException ;	OutputStream setAsciiStream ( long start ) throws SQLException ;
getterCalled ( ) ; <CTX> public boolean add ( Object element ) { getterCalled ( ) ; boolean added = wrappedList . add ( element ) ; if ( added ) { fireListChange ( Diffs . createListDiff ( Diffs . createListDiffEntry ( wrappedList . size ( ) - 1 , true , element ) ) ) ; } return added ; }	checkRealm ( ) ;
void setObject ( int parameterIndex , Object x , int targetSqlType , int scale ) throws SQLException ; <CTX> void setObject ( int parameterIndex , Object x , int targetSqlType , int scale ) throws SQLException ;	void setObject ( int index , Object value , int sqlType , int scale ) throws SQLException ;
String description = null ; try { description = seq . getAnnotation ( ) . getProperty ( PROPERTY_DESCRIPTIONLINE ) . toString ( ) ; } catch ( NoSuchElementException ex ) { description = seq . getName ( ) ; } return description ; <CTX> protected String describeSequence ( Sequence seq ) { String description = null ; try { description = seq . getAnnotation ( ) . getProperty ( PROPERTY_DESCRIPTIONLINE ) . toString ( ) ; } catch ( NoSuchElementException ex ) { description = seq . getName ( ) ; } return description ; }	String description = null ; try { description = seq . getAnnotation ( ) . getProperty ( PROPERTY_DESCRIPTIONLINE ) . toString ( ) ; } catch ( NoSuchElementException ex ) { description = seq . getName ( ) ;
if ( workingCopyGetterFields != null && workingCopySetterFields != null ) run ( workingCopyGetterFields , workingCopySetterFields , editor ) ; <CTX> private void generate ( IField [ ] getterFields , IField [ ] setterFields ) throws CoreException { if ( getterFields . length == 0 && setterFields . length == 0 ) return ; ICompilationUnit cu = null ; if ( getterFields . length != 0 ) cu = getterFields [ 0 ] . getCompilationUnit ( ) ; else cu = setterFields [ 0 ] . getCompilationUnit ( ) ; / / open the editor , forces the creation of a working copy IEditorPart editor = EditorUtility . openInEditor ( cu ) ; IField [ ] workingCopyGetterFields = getWorkingCopyFields ( getterFields ) ; IField [ ] workingCopySetterFields = getWorkingCopyFields ( setterFields ) ; if ( workingCopyGetterFields != null && workingCopySetterFields != null ) run ( workingCopyGetterFields , workingCopySetterFields , editor ) ; }	IField [ ] workingCopyGetterSetterFields = getWorkingCopyFields ( getterSetterFields ) ; IJavaElement workingCopyElementPosition = getWorkingCopy ( elementPosition ) ; if ( workingCopyGetterFields != null && workingCopySetterFields != null && workingCopyGetterSetterFields != null ) run ( workingCopyGetterFields , workingCopySetterFields , workingCopyGetterSetterFields , editor , workingCopyElementPosition ) ;
return getOrCreateNavigatorViewerDescriptor ( viewerId ) ; <CTX> public NavigatorViewerDescriptor getNavigatorViewerDescriptor ( String viewerId ) { return getOrCreateNavigatorViewerDescriptor ( viewerId ) ; }	return getViewerDescriptor ( viewerId ) ;
&& ! ( list . get ( 0 ) instanceof EmptyEditPart ) ) <CTX> protected void createEditPolicies ( ) { installEditPolicy ( EditPolicy . LAYOUT_ROLE , new ReportFlowLayoutEditPolicy ( ) { protected org . eclipse . gef . commands . Command getCreateCommand ( CreateRequest request ) { List list = getHost ( ) . getChildren ( ) ; if ( list . size ( ) != 0 && ! ( list . get ( 0 ) instanceof EmptyEditPart ) ) { return UnexecutableCommand . INSTANCE ; } / / EditPart after = getInsertionReference ( request ) ; / / final DesignElementHandle newObject = ( DesignElementHandle ) request . getExtendedData ( ) / / . get ( DesignerConstants . KEY_NEWOBJECT ) ; CreateCommand command = new CreateCommand ( request . getExtendedData ( ) ) { public void execute ( ) { super . execute ( ) ; Display . getCurrent ( ) . asyncExec ( new Runnable ( ) { public void run ( ) { SetCurrentEditModelCommand c = new SetCurrentEditModelCommand ( getNewObject ( ) ) ; c . execute ( ) ; } } ) ; } } ; Object model = this . getHost ( ) . getModel ( ) ; if ( model instanceof ReportElementModel ) { command . setParent ( ( ( ReportElementModel ) model ) . getSlotHandle ( ) ) ; } else if ( model instanceof ListBandProxy ) { command . setParent ( ( ( ListBandProxy ) model ) . getSlotHandle ( ) ) ; } else { command . setParent ( model ) ; } / / No previous edit part / / if ( after != null ) / / { / / command . setAfter ( after . getModel ( ) ) ; / / } return command ; } } ) ; installEditPolicy ( EditPolicy . CONTAINER_ROLE , new ReportContainerEditPolicy ( ) ) ; }	&& ! ( list . get ( 0 ) instanceof EmptyEditPart ) && ( direct == null || ! direct . booleanValue ( ) ) )
int size , boolean isScalar , <CTX> public static VM_Word getBootTimeAvailableBits ( int ref , Object [ ] tib , int size , boolean isScalar , VM_Word status ) throws VM_PragmaUninterruptible , VM_PragmaInline { if ( Plan . WITH_COALESCING_RC ) status = status . or ( UNLOGGED ) ; return status ; }	int size ,
{ return 1 ; } <CTX> public int getDriverMajorVersion ( ) { return 1 ; }	{ return connection . this_driver . getMajorVersion ( ) ; }
return fHistory . isEmpty ( ) ; <CTX> public synchronized boolean isEmpty ( ) { return fHistory . isEmpty ( ) ; }	return history . isEmpty ( ) ;
this . chain = cloneAndLink ( chain ) ; <CTX> public TransformerChain ( ClassTransformer [ ] chain ) { this . chain = cloneAndLink ( chain ) ; }	this . chain = clone ( chain ) ;
ApplicationManager . getApplication ( ) . invokeAndWait ( new Runnable ( ) { public void run ( ) { ApplicationManager . getApplication ( ) . runWriteAction ( new Runnable ( ) { public void run ( ) { final PsiDocumentManager manager = PsiDocumentManager . getInstance ( project ) ; manager . commitDocument ( manager . getDocument ( psiFile ) ) ; } } ) ; } } , ModalityState . defaultModalityState ( ) ) ; <CTX> public void run ( ) { final PsiFile psiFile = file . getContainingFile ( ) ; if ( psiFile != null ) { ApplicationManager . getApplication ( ) . invokeAndWait ( new Runnable ( ) { public void run ( ) { ApplicationManager . getApplication ( ) . runWriteAction ( new Runnable ( ) { public void run ( ) { final PsiDocumentManager manager = PsiDocumentManager . getInstance ( project ) ; manager . commitDocument ( manager . getDocument ( psiFile ) ) ; } } ) ; } } , ModalityState . defaultModalityState ( ) ) ; } if ( file instanceof PsiFile ) { matchContext . getSink ( ) . processFile ( ( PsiFile ) file ) ; } if ( progress != null ) { progress . setFraction ( ( double ) scannedFilesCount / totalFilesToScan ) ; } ++ scannedFilesCount ; if ( file instanceof PsiIdentifier ) { / / Searching in previous results file = file . getParent ( ) ; } ApplicationManager . getApplication ( ) . runReadAction ( new Runnable ( ) { public void run ( ) { match ( file ) ; } } ) ; file = null ; }	final Runnable action = new Runnable ( ) { public void run ( ) { ApplicationManager . getApplication ( ) . runWriteAction ( new Runnable ( ) { public void run ( ) { final PsiDocumentManager manager = PsiDocumentManager . getInstance ( project ) ; manager . commitDocument ( manager . getDocument ( psiFile ) ) ; } } ) ; } } ;
String [ ] oldFilters = this . filters ; <CTX> public void setFilterText ( String [ ] filterStrings ) { String [ ] oldFilters = this . filters ; this . filters = TextMatcher . normalizeFilters ( filterStrings ) ; / / fire the event only as necessary if ( ! TextMatcher . isFilterEqual ( oldFilters , filters ) ) { / / classify the change in filter and apply the new filter to this list if ( filters . length == 0 ) { fireMatchAll ( ) ; } else if ( TextMatcher . isFilterRelaxed ( oldFilters , filters ) ) { fireRelaxed ( new TextMatcher < E > ( filters , filterator ) ) ; } else if ( TextMatcher . isFilterConstrained ( oldFilters , filters ) ) { fireConstrained ( new TextMatcher < E > ( filters , filterator ) ) ; } else { fireChanged ( new TextMatcher < E > ( filters , filterator ) ) ; } } }	final String [ ] oldFilters = this . filters ;
categoryStatusService . setCategoryDao ( categoryDao ) ; <CTX> protected void setUp ( ) throws Exception { super . setUp ( ) ; viewDisplayDao = createMock ( ViewDisplayDao . class ) ; categoryDao = createMock ( CategoryConfigDao . class ) ; outageDao = createMock ( OutageDao . class ) ; categoryStatusService = new DefaultCategoryStatusService ( ) ; categoryStatusService . setViewDisplayDao ( viewDisplayDao ) ; categoryStatusService . setCategoryDao ( categoryDao ) ; categoryStatusService . setOutageDao ( outageDao ) ; }	categoryStatusService . setCategoryConfigDao ( categoryDao ) ;
this . weapon = weapon ; this . offhand = offhand ; this . hat = hat ; this . shirt = shirt ; this . pants = pants ; this . accessory = accessory ; this . familiar = familiar ; <CTX> public EquipmentCellRenderer ( boolean weapon , boolean offhand , boolean hat , boolean shirt , boolean pants , boolean accessory , boolean familiar ) { setOpaque ( true ) ; this . weapon = weapon ; this . offhand = offhand ; this . hat = hat ; this . shirt = shirt ; this . pants = pants ; this . accessory = accessory ; this . familiar = familiar ; }	this . filterType = filterType ;
tree . setShowsRootHandles ( newValue ) ; <CTX> protected void setShowsRootHandles ( boolean newValue ) { tree . setShowsRootHandles ( newValue ) ; }	completeEditing ( ) ; updateDepthOffset ( ) ; if ( treeState != null ) { treeState . invalidateSizes ( ) ; updateSize ( ) ; }
if ( tree . equals ( e . getSource ( ) ) ) { Object o = tree . getItem ( new Point ( e . x , e . y ) ) ; final TreeItem selection = tree . getSelection ( ) [ 0 ] ; if ( selection . equals ( o ) ) { CElement selectedElement = ( CElement ) selection . getData ( ) ; fEditor . setSelection ( selectedElement ) ; dispose ( ) ; } if ( fComposite != null && ! fComposite . isDisposed ( ) ) { fBounds = fComposite . getBounds ( ) ; } } } <CTX> public void mouseUp ( MouseEvent e ) { final Tree tree = fTreeViewer . getTree ( ) ; if ( tree . getSelectionCount ( ) < 1 ) { return ; } if ( e . button != 1 ) { return ; } if ( tree . equals ( e . getSource ( ) ) ) { Object o = tree . getItem ( new Point ( e . x , e . y ) ) ; final TreeItem selection = tree . getSelection ( ) [ 0 ] ; if ( selection . equals ( o ) ) { CElement selectedElement = ( CElement ) selection . getData ( ) ; fEditor . setSelection ( selectedElement ) ; dispose ( ) ; } if ( fComposite != null && ! fComposite . isDisposed ( ) ) { fBounds = fComposite . getBounds ( ) ; } } }	if ( tree . getSelectionCount ( ) < 1 ) return ; if ( e . button != 1 ) return ; if ( tree . equals ( e . getSource ( ) ) ) { Object o = tree . getItem ( new Point ( e . x , e . y ) ) ; TreeItem selection = tree . getSelection ( ) [ 0 ] ; if ( selection . equals ( o ) ) gotoSelectedElement ( ) ; } }
this . in = new SequenceFile . Reader ( fs , split . getFile ( ) . toString ( ) ) ; <CTX> public SequenceFileRecordReader ( NutchFileSystem fs , FileSplit split ) throws IOException { this . in = new SequenceFile . Reader ( fs , split . getFile ( ) . toString ( ) ) ; this . end = split . getStart ( ) + split . getLength ( ) ; if ( split . getStart ( ) > in . getPosition ( ) ) in . sync ( split . getStart ( ) ) ; / / sync to start more = in . getPosition ( ) < end ; }	NutchFileSystem fs = NutchFileSystem . get ( nutchConf ) ; this . in = new SequenceFile . Reader ( fs , split . getFile ( ) . toString ( ) , nutchConf ) ;
IASTDeclaration d = simpleDeclaration ( SimpleDeclarationStrategy . TRY_FUNCTION , false ) ; throwAwayMarksForInitializerClause ( ) ; return d ; <CTX> protected IASTDeclaration simpleDeclarationStrategyUnion ( ) throws EndOfFileException , BacktrackException { simpleDeclarationMark = mark ( ) ; try { IASTDeclaration d = simpleDeclaration ( SimpleDeclarationStrategy . TRY_FUNCTION , false ) ; throwAwayMarksForInitializerClause ( ) ; return d ; } catch ( BacktrackException bt ) { if ( simpleDeclarationMark == null ) throwBacktrack ( bt ) ; / / did not work backup ( simpleDeclarationMark ) ; IASTDeclaration d = simpleDeclaration ( SimpleDeclarationStrategy . TRY_VARIABLE , false ) ; throwAwayMarksForInitializerClause ( ) ; return d ; } }	d 1 = simpleDeclaration ( SimpleDeclarationStrategy . TRY_FUNCTION , false ) ; try { after = LA ( 1 ) ; } catch ( EndOfFileException eof ) { after = null ; }
this . contentProvider = new ContentProvider ( this . history ) ; if ( list != null ) list . setContentProvider ( contentProvider ) ; <CTX> protected void applyFilter ( ) { stopCurrentFilterJob ( ) ; this . filter = createFilter ( ) ; this . contentProvider = new ContentProvider ( this . history ) ; if ( list != null ) list . setContentProvider ( contentProvider ) ; if ( this . filter != null ) { if ( this . filter . getPattern ( ) . length ( ) == 0 ) { filter = null ; } else { scheduleFilterJob ( ) ; } } }	this . contentProvider . reset ( ) ;
( ( Taxa ) taxonSets . get ( rowIndex ) ) . setId ( aValue . toString ( ) ) ; <CTX> public void setValueAt ( Object aValue , int rowIndex , int columnIndex ) { ( ( Taxa ) taxonSets . get ( rowIndex ) ) . setId ( aValue . toString ( ) ) ; setTaxonSetTitle ( ) ; }	( ( Taxa ) options . taxonSets . get ( rowIndex ) ) . setId ( aValue . toString ( ) ) ;
if ( stateModel == null ) <CTX> public IExtensionStateModel getStateModel ( ) { if ( stateModel == null ) stateModel = new ExtensionStateModel ( descriptor . getId ( ) , viewerId ) ; return stateModel ; }	if ( stateModel == null ) {
return interpolate ( project , context , true ) ; <CTX> public Model interpolate ( Model project , Map context ) throws ModelInterpolationException { return interpolate ( project , context , true ) ; }	return interpolate ( model , context , true ) ;
PsiCall copy = ( PsiCall ) myCall . copy ( ) ; PsiExpression [ ] expressions = myCall . getArgumentList ( ) . getExpressions ( ) ; PsiExpression [ ] copyExpressions = copy . getArgumentList ( ) . getExpressions ( ) ; for ( int i = 0 ; i < myPermutation . length ; i ++ ) { int j = myPermutation [ i ] ; if ( i != j ) { copyExpressions [ j ] . replace ( expressions [ i ] ) ; } } myCall . getArgumentList ( ) . replace ( copy . getArgumentList ( ) ) ; <CTX> public void invoke ( Project project , Editor editor , PsiFile file ) throws IncorrectOperationException { PsiCall copy = ( PsiCall ) myCall . copy ( ) ; PsiExpression [ ] expressions = myCall . getArgumentList ( ) . getExpressions ( ) ; PsiExpression [ ] copyExpressions = copy . getArgumentList ( ) . getExpressions ( ) ; for ( int i = 0 ; i < myPermutation . length ; i ++ ) { int j = myPermutation [ i ] ; if ( i != j ) { copyExpressions [ j ] . replace ( expressions [ i ] ) ; } } myCall . getArgumentList ( ) . replace ( copy . getArgumentList ( ) ) ; }	myCall . getArgumentList ( ) . replace ( myPermutation . getArgumentList ( ) ) ;
return new JavaClass ( runtime , superclass . getName ( ) ) ; <CTX> public IRubyObject superclass ( ) { Class superclass = javaClass . getSuperclass ( ) ; if ( superclass == null ) { return runtime . getNil ( ) ; } return new JavaClass ( runtime , superclass . getName ( ) ) ; }	return new JavaClass ( getRuntime ( ) , superclass . getName ( ) ) ;
return ( int ) ( dataLength - ptr ) ; <CTX> public final int available ( ) { return ( int ) ( dataLength - ptr ) ; }	int x = ( int ) ( dataLength - ptr ) ; return ( x < 0 ) ? 0 : x ;
void projectFinished ( ) ; <CTX> void projectFinished ( ) ;	void projectFinished ( ProjectEvent event ) ;
return RubyBoolean . newBoolean ( runtime , javaClass . isInterface ( ) ) ; <CTX> public RubyBoolean interface_p ( ) { return RubyBoolean . newBoolean ( runtime , javaClass . isInterface ( ) ) ; }	return getRuntime ( ) . newBoolean ( javaClass . isInterface ( ) ) ;
setFloatValue ( Float . parseFloat ( data . toString ( ) ) ) ; <CTX> public void endElement ( String nsURI , String localName , String qName , StAXContentHandler handler ) throws SAXException { level -- ; if ( level == 0 ) { try { setFloatValue ( Float . parseFloat ( data . toString ( ) ) ) ; } catch ( NumberFormatException nfe ) { throw new SAXException ( nfe ) ; } } }	setFloatValue ( Float . parseFloat ( ( data . toString ( ) ) . trim ( ) ) ) ;
FontMetrics fm = lab . getToolkit ( ) . getFontMetrics ( lab . getFont ( ) ) ; <CTX> public Dimension getPreferredSize ( JComponent c ) { JLabel lab = ( JLabel ) c ; Rectangle vr = new Rectangle ( ) ; Rectangle ir = new Rectangle ( ) ; Rectangle tr = new Rectangle ( ) ; Insets insets = lab . getInsets ( ) ; FontMetrics fm = lab . getToolkit ( ) . getFontMetrics ( lab . getFont ( ) ) ; layoutCL ( lab , fm , lab . getText ( ) , lab . getIcon ( ) , vr , ir , tr ) ; Rectangle cr = tr . union ( ir ) ; return new Dimension ( insets . left + cr . width + insets . right , insets . top + cr . height + insets . bottom ) ; }	FontMetrics fm = lab . getFontMetrics ( lab . getFont ( ) ) ;
if ( widget == null ) <CTX> protected void internalRefresh ( Object element ) { if ( element == null ) return ; if ( element . equals ( getRoot ( ) ) ) refreshAll ( ) ; Widget widget = findItem ( element ) ; if ( widget == null ) return ; ( ( ProgressInfoItem ) widget ) . refresh ( ) ; Point size = control . computeSize ( SWT . DEFAULT , SWT . DEFAULT ) ; control . setSize ( size ) ; scrolled . setMinSize ( size ) ; }	if ( widget == null ) { add ( new Object [ ] { element } ) ;
removeContent ( ( ContentUI ) content ) ; <CTX> public void unistall ( ) { contentValueAdjusting = true ; for ( Content content : contentManager . getContents ( ) ) { removeContent ( ( ContentUI ) content ) ; } contentValueAdjusting = false ; }	removeContent ( ( BackContentUI ) content ) ;
if ( obj instanceof Connection ) { <CTX> public boolean equals ( Object obj ) { if ( obj != null ) { if ( obj instanceof Connection ) { return connection . hashCode ( ) == obj . hashCode ( ) ; } else { return super . equals ( obj ) ; } } else { return false ; } }	if ( obj instanceof ProxyConnection ) { return connection . hashCode ( ) == ( ( ProxyConnection ) obj ) . getConnection ( ) . hashCode ( ) ; } else if ( obj instanceof Connection ) {
doEnableItem ( w , menuname , label , enable ) ; <CTX> public void action ( JapeWindow w ) { doEnableItem ( w , menuname , label , enable ) ; }	if ( ( w . getBarKind ( ) & barKinds ) != 0 ) doEnableItem ( w , menuname , label , enable ) ;
addConstantClassInfo ( classFD ) , addConstantNameAndTypeInfo ( methodName , methodMD ) <CTX> public short addConstantMethodrefInfo ( String classFD , String methodName , String methodMD ) { return this . addToConstantPool ( new ConstantMethodrefInfo ( addConstantClassInfo ( classFD ) , addConstantNameAndTypeInfo ( methodName , methodMD ) ) ) ; }	this . addConstantClassInfo ( classFD ) , this . addConstantNameAndTypeInfo ( methodName , methodMD )
s . checkRead ( p ) ; return p ; <CTX> private final String checkRead ( ) { SecurityManager s = System . getSecurityManager ( ) ; String p = safeCanonicalPath ( ) ; if ( p == null ) return null ; if ( s != null ) s . checkRead ( p ) ; return p ; }	s . checkRead ( path ) ;
return null ; <CTX> public String getDescription ( ) { / / TODO implement this function return null ; }	return_description ;
IdFunction f = newIdFunction ( id ) ; f . setParentScope ( getParentScope ( ) ) ; <CTX> protected void addIdFunctionProperty ( Scriptable obj , int id , boolean sealed ) { IdFunction f = newIdFunction ( id ) ; f . setParentScope ( getParentScope ( ) ) ; if ( sealed ) { f . sealObject ( ) ; } defineProperty ( obj , getIdName ( id ) , f , DONTENUM ) ; }	IdFunction f = newIdFunction ( id , getParentScope ( ) ) ;
result [ counter ] = key . fd ; <CTX> private final int [ ] getFDsAsArray ( int ops ) { int [ ] result ; int counter = 0 ; Iterator it = keys . iterator ( ) ; / / Count the number of file descriptors needed while ( it . hasNext ( ) ) { SelectionKeyImpl key = ( SelectionKeyImpl ) it . next ( ) ; if ( ( key . interestOps ( ) & ops ) != 0 ) { counter ++ ; } } result = new int [ counter ] ; counter = 0 ; it = keys . iterator ( ) ; / / Fill the array with the file descriptors while ( it . hasNext ( ) ) { SelectionKeyImpl key = ( SelectionKeyImpl ) it . next ( ) ; if ( ( key . interestOps ( ) & ops ) != 0 ) { result [ counter ] = key . fd ; counter ++ ; } } return result ; }	result [ counter ] = key . getNativeFD ( ) ;
state . getThreadContext ( ) . getCurrentDynamicVars ( ) . set ( iVisited . getName ( ) , value ) ; <CTX> public Instruction visitDAsgnNode ( DAsgnNode iVisited ) { state . getThreadContext ( ) . getCurrentDynamicVars ( ) . set ( iVisited . getName ( ) , value ) ; return null ; }	runtime . getCurrentContext ( ) . getCurrentDynamicVars ( ) . set ( iVisited . getName ( ) , value ) ;
case Lexer . CHAR_NONCAP_GROUP : { <CTX> private AbstractSet processExpression ( int ch , int new_flags , AbstractSet last ) { ArrayList children = new ArrayList ( ) ; AbstractSet child ; int safe_flags = flags ; FSet fSet ; if ( new_flags != flags ) { flags = new_flags ; lexemes . setFlags ( flags ) ; } switch ( ch ) { case Lexer . CHAR_NONCAP_GROUP : { fSet = new NonCapFSet ( ++ consCount ) ; break ; } case Lexer . CHAR_POS_LOOKAHEAD : case Lexer . CHAR_NEG_LOOKAHEAD : { fSet = new AheadFSet ( ) ; break ; } case Lexer . CHAR_POS_LOOKBEHIND : case Lexer . CHAR_NEG_LOOKBEHIND : { fSet = new BehindFSet ( ++ consCount ) ; break ; } case Lexer . CHAR_ATOMIC_GROUP : { fSet = new AtomicFSet ( ++ consCount ) ; break ; } default : { globalGroupIndex ++ ; if ( last == null ) { fSet = new FinalSet ( ) ; / / expr = new StartSet ( ) ; } else { fSet = new FSet ( globalGroupIndex ) ; / / expr = new JointSet ( globalGroupIndex ) ; } } } do { if ( lexemes . isLetter ( ) && lexemes . lookAhead ( ) == Lexer . CHAR_VERTICAL_BAR ) { child = processAlternations ( fSet ) ; } else { child = processSubExpression ( fSet ) ; if ( lexemes . peek ( ) == Lexer . CHAR_VERTICAL_BAR ) lexemes . next ( ) ; } if ( child != null ) children . add ( child ) ; / / expr . addChild ( child ) ; } while ( ! ( lexemes . isEmpty ( ) || lexemes . peek ( ) == Lexer . CHAR_RIGHT_PARENTHESIS ) ) ; if ( flags != safe_flags ) { flags = safe_flags ; lexemes . setFlags ( flags ) ; } switch ( ch ) { case Lexer . CHAR_NONCAP_GROUP : { return new NonCapJointSet ( children , fSet ) ; } case Lexer . CHAR_POS_LOOKAHEAD : { return new PositiveLookAhead ( children , fSet ) ; } case Lexer . CHAR_NEG_LOOKAHEAD : { return new NegativeLookAhead ( children , fSet ) ; } case Lexer . CHAR_POS_LOOKBEHIND : { return new PositiveLookBehind ( children , fSet ) ; } case Lexer . CHAR_NEG_LOOKBEHIND : { return new NegativeLookBehind ( children , fSet ) ; } case Lexer . CHAR_ATOMIC_GROUP : { return new AtomicJointSet ( children , fSet ) ; } default : { switch ( children . size ( ) ) { case 0 : return new EmptySet ( fSet ) ; case 1 : return new SingleSet ( ( AbstractSet ) children . get ( 0 ) , fSet ) ; default : return new JointSet ( children , fSet ) ; } } } }	case Lexer . CHAR_NONCAP_GROUP :
if ( close != null ) { close . setEnabled ( enabled ) ; } <CTX> public void enableClose ( boolean enabled ) { if ( close != null ) { close . setEnabled ( enabled ) ; } }	close . setVisible ( enabled ) ; toolbarManager . update ( false ) ;
List children = new ArrayList ( ) ; IProject project = ( IProject ) parent . getAdapter ( IPROJECT_CLASS ) ; Object [ ] rootObjects = ( rootObjectProvider != null ) ? rootObjectProvider . getModels ( project ) : null ; if ( rootObjects != null ) { for ( int x = 0 ; x < rootObjects . length ; ++ x ) { children . add ( rootObjects [ x ] ) ; } } updateUIJob . setComplete ( true ) ; new ClearPlaceHolderJob ( viewer , placeHolder , parent , children . toArray ( ) ) . schedule ( ) ; <CTX> protected IStatus run ( IProgressMonitor monitor ) { LoadingDDUIJob updateUIJob = new LoadingDDUIJob ( viewer , placeHolder ) ; updateUIJob . schedule ( ) ; List children = new ArrayList ( ) ; IProject project = ( IProject ) parent . getAdapter ( IPROJECT_CLASS ) ; Object [ ] rootObjects = ( rootObjectProvider != null ) ? rootObjectProvider . getModels ( project ) : null ; if ( rootObjects != null ) { for ( int x = 0 ; x < rootObjects . length ; ++ x ) { children . add ( rootObjects [ x ] ) ; } } updateUIJob . setComplete ( true ) ; new ClearPlaceHolderJob ( viewer , placeHolder , parent , children . toArray ( ) ) . schedule ( ) ; return Status . OK_STATUS ; }	try { IProject project = ( IProject ) parent . getAdapter ( IPROJECT_CLASS ) ; Object [ ] rootObjects = ( rootObjectProvider != null ) ? rootObjectProvider . getModels ( project ) : null ; if ( rootObjects != null ) { for ( int x = 0 ; x < rootObjects . length ; ++ x ) { children . add ( rootObjects [ x ] ) ; } } } finally { / * dispose of the place holder , causes the termination of the animation job * / placeHolder . dispose ( ) ; new ClearPlaceHolderJob ( viewer , placeHolder , parent , children . toArray ( ) ) . schedule ( ) ; }
if ( ( style & SWT . CHECK ) != 0 ) setCheckboxImageList ( ) ; <CTX> LRESULT WM_SYSCOLORCHANGE ( int wParam , int lParam ) { LRESULT result = super . WM_SYSCOLORCHANGE ( wParam , lParam ) ; if ( result != null ) return result ; if ( ( style & SWT . CHECK ) != 0 ) setCheckboxImageList ( ) ; return result ; }	if ( ( style & SWT . CHECK ) != 0 ) setCheckboxImageList ( true ) ;
FontData oldFont = chosenFont ; <CTX> protected Button getChangeControl ( Composite parent ) { if ( changeFontButton == null ) { changeFontButton = new Button ( parent , SWT . PUSH ) ; if ( changeButtonText != null ) changeFontButton . setText ( changeButtonText ) ; changeFontButton . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent event ) { FontDialog fontDialog = new FontDialog ( changeFontButton . getShell ( ) ) ; fontDialog . setFontData ( chosenFont ) ; FontData font = fontDialog . open ( ) ; if ( font != null ) { FontData oldFont = chosenFont ; setPresentsDefaultValue ( false ) ; FontData [ ] newData = new FontData [ 1 ] ; newData [ 0 ] = font ; updateFont ( newData ) ; fireValueChanged ( VALUE , oldFont , font ) ; } } } ) ; changeFontButton . addDisposeListener ( new DisposeListener ( ) { public void widgetDisposed ( DisposeEvent event ) { changeFontButton = null ; } } ) ; changeFontButton . setFont ( parent . getFont ( ) ) ; setButtonLayoutData ( changeFontButton ) ; } else { checkParent ( changeFontButton , parent ) ; } return changeFontButton ; }	FontData [ ] oldFont = chosenFont ;
return null ; <CTX> public String getDescription ( ) { return null ; }	return desc ;
if ( offset >= 0 && offset < myPsiFile . getTextLength ( ) ) { <CTX> public Object getSelectorInFile ( ) { final int offset = myEditor . getEditor ( ) . getCaretModel ( ) . getOffset ( ) ; if ( offset >= 0 && offset < myPsiFile . getTextLength ( ) ) { return myPsiFile . findElementAt ( offset ) ; } else { return super . getSelectorInFile ( ) ; } }	if ( myPsiFile instanceof PsiJavaFile && ! ( myPsiFile instanceof JspFile ) && offset >= 0 && offset < myPsiFile . getTextLength ( ) ) {
return ( ( y / zoom_factor ) + scroll_y ) ; <CTX> public int WorldYtoScreen ( int y ) { return ( ( y / zoom_factor ) + scroll_y ) ; }	return ( ( y - scroll_y ) * zoom_factor ) ;
if ( currentResource . getLocation ( ) == null ) { <CTX> protected boolean updateSelection ( IStructuredSelection selection ) { if ( ! super . updateSelection ( selection ) ) return false ; if ( getSelectedNonResources ( ) . size ( ) > 0 ) return false ; List selectedResources = getSelectedResources ( ) ; if ( selectedResources . size ( ) == 0 ) return false ; boolean projSelected = selectionIsOfType ( IResource . PROJECT ) ; boolean fileFoldersSelected = selectionIsOfType ( IResource . FILE | IResource . FOLDER ) ; if ( ! projSelected && ! fileFoldersSelected ) return false ; / / selection must be homogeneous if ( projSelected && fileFoldersSelected ) return false ; / / must have a common parent IContainer firstParent = ( ( IResource ) selectedResources . get ( 0 ) ) . getParent ( ) ; if ( firstParent == null ) return false ; Iterator resourcesEnum = selectedResources . iterator ( ) ; while ( resourcesEnum . hasNext ( ) ) { IResource currentResource = ( IResource ) resourcesEnum . next ( ) ; if ( ! currentResource . getParent ( ) . equals ( firstParent ) ) { return false ; } / / resource location must exist if ( currentResource . getLocation ( ) == null ) { return false ; } } return true ; }	if ( currentResource . getLocation ( ) == null )
if ( children == null ) <CTX> public List getChildren ( Object element ) { if ( children == null ) initialize ( ) ; return ( ( List ) children . get ( element ) ) ; }	if ( children == null ) {
assert ( this . context != null ) ; return this . scope . get ( name , this . scope ) ; <CTX> public Object lookupBean ( String name ) { assert ( this . context != null ) ; return this . scope . get ( name , this . scope ) ; }	assert ( context != null ) ; return scope . get ( name , scope ) ;
if (_matchLast == - 1 ) {_source . reset ( ) ; int i = 1 , node ; while ( ( node =_source . next ( ) ) != END ) { ++ i ; }_matchLast = i - 1 ; } <CTX> public int getLast ( ) { if (_matchLast == - 1 ) {_source . reset ( ) ; int i = 1 , node ; while ( ( node =_source . next ( ) ) != END ) { ++ i ; }_matchLast = i - 1 ; } return_matchLast ; }	if (_matchLast == - 1 )_matchLast =_source . getLast ( ) ;
switch ( id - idBase ) { <CTX> protected void setInstanceIdValue ( int id , Object value ) { switch ( id - idBase ) { case Id_multiline : case Id_STAR : getImpl ( ) . multiline = ScriptRuntime . toBoolean ( value ) ; return ; case Id_input : case Id_UNDERSCORE : getImpl ( ) . input = ScriptRuntime . toString ( value ) ; return ; } super . setInstanceIdValue ( id , value ) ; }	int shifted = id - super . getMaxInstanceId ( ) ; switch ( shifted ) {
getWizardContext ( ) . getDataServiceProvider ( ) . setDataSet ( datasetName ) ; <CTX> private void switchDataSet ( String datasetName ) throws ChartException { try { getWizardContext ( ) . getDataServiceProvider ( ) . setDataSet ( datasetName ) ; tablePreview . clearContents ( ) ; / / Try to get report data set if ( datasetName == null ) { datasetName = getWizardContext ( ) . getDataServiceProvider ( ) . getReportDataSet ( ) ; } if ( datasetName != null ) { switchDataTable ( datasetName ) ; } else { tablePreview . createDummyTable ( ) ; } tablePreview . layout ( ) ; } catch ( Throwable t ) { throw new ChartException ( ChartEnginePlugin . ID , ChartException . DATA_BINDING , t ) ; } DataDefinitionTextManager . getInstance ( ) . refreshAll ( ) ; doLivePreview ( ) ; }	getDataServiceProvider ( ) . setDataSet ( datasetName ) ;
return access ( checkRead ( ) , EXISTS ) ; <CTX> public boolean exists ( ) { return access ( checkRead ( ) , EXISTS ) ; }	checkRead ( ) ; return access ( EXISTS ) ;
ColorDefinition definition = copyOfDefinitions [ i ] ; installColor ( definition , theme , store , true ) ; <CTX> public static void populateRegistry ( ITheme theme , ColorDefinition [ ] definitions , IPreferenceStore store ) { / / sort the definitions by dependant ordering so that we process / / ancestors before children . ColorDefinition [ ] copyOfDefinitions = null ; / / the colors to set a default value for , but not a registry value ColorDefinition [ ] defaults = null ; if ( ! theme . getId ( ) . equals ( IThemeManager . DEFAULT_THEME ) ) { definitions = addDefaulted ( definitions ) ; / / compute defaults only if we re setting preferences if ( store != null ) { defaults = getDefaults ( definitions ) ; } } copyOfDefinitions = new ColorDefinition [ definitions . length ] ; System . arraycopy ( definitions , 0 , copyOfDefinitions , 0 , definitions . length ) ; Arrays . sort ( copyOfDefinitions , new IThemeRegistry . HierarchyComparator ( definitions ) ) ; for ( int i = 0 ; i < copyOfDefinitions . length ; i ++ ) { ColorDefinition definition = copyOfDefinitions [ i ] ; installColor ( definition , theme , store , true ) ; } if ( defaults != null ) { for ( int i = 0 ; i < defaults . length ; i ++ ) { installColor ( defaults [ i ] , theme , store , false ) ; } } }	FontDefinition definition = copyOfDefinitions [ i ] ; installFont ( definition , theme , store , true ) ;
if ( lockRes != WindowsOnscreenGLDrawable . LOCK_SURFACE_NOT_READY ) { drawable . unlockSurface ( ) ; <CTX> protected int makeCurrentImpl ( ) throws GLException { int lockRes = 0 ; try { lockRes = drawable . lockSurface ( ) ; if ( lockRes == WindowsOnscreenGLDrawable . LOCK_SURFACE_NOT_READY ) { return CONTEXT_NOT_CURRENT ; } if ( lockRes == WindowsOnscreenGLDrawable . LOCK_SURFACE_CHANGED ) { destroyImpl ( ) ; } int ret = super . makeCurrentImpl ( ) ; return ret ; } finally { if ( lockRes != WindowsOnscreenGLDrawable . LOCK_SURFACE_NOT_READY ) { drawable . unlockSurface ( ) ; } } }	if ( isOptimizable ( ) ) { if ( lockRes != WindowsOnscreenGLDrawable . LOCK_SURFACE_NOT_READY ) { drawable . unlockSurface ( ) ; }
messageSend . receiver . traverse ( this , scope ) ; return false ; <CTX> public boolean visit ( MessageSend messageSend , BlockScope scope ) { if ( messageSend . receiver instanceof MessageSend ) { this . fragmentsList . add ( 0 , messageSend ) ; messageSend . receiver . traverse ( this , scope ) ; return false ; } this . fragmentsList . add ( 0 , messageSend ) ; this . fragmentsList . add ( 1 , messageSend ) ; return false ; }	this . fragmentsList . add ( 1 , messageSend ) ; } else { this . fragmentsList . add ( 0 , messageSend ) ; this . fragmentsList . add ( 1 , messageSend ) ;
NativeWith ( Scriptable parent , Scriptable prototype ) { this . parent = parent ; this . prototype = prototype ; <CTX> NativeWith ( Scriptable parent , Scriptable prototype ) { this . parent = parent ; this . prototype = prototype ; }	private NativeWith ( ) {
LiteralConstraint constraint = ( LiteralConstraint ) this . node . getConstraint ( ) ; ClassFieldExtractor extractor = ( ClassFieldExtractor ) constraint . getFieldExtractor ( ) ; return extractor . getFieldName ( ) ; <CTX> public String getFieldName ( ) { LiteralConstraint constraint = ( LiteralConstraint ) this . node . getConstraint ( ) ; ClassFieldExtractor extractor = ( ClassFieldExtractor ) constraint . getFieldExtractor ( ) ; return extractor . getFieldName ( ) ; }	AlphaNodeFieldConstraint constraint = this . node . getConstraint ( ) ; if ( constraint instanceof LiteralConstraint ) { LiteralConstraint literalConstraint = ( LiteralConstraint ) constraint ; FieldExtractor extractor = literalConstraint . getFieldExtractor ( ) ; if ( extractor instanceof ClassFieldExtractor ) { return ( ( ClassFieldExtractor ) extractor ) . getFieldName ( ) ; } } return null ;
return e . setValue ( value ) ; <CTX> public Object put ( Object key , Object value ) { int idx = hash ( key ) ; HashEntry e = buckets [ idx ] ; while ( e != null ) { if ( equals ( key , e . key ) ) / / Must use this method for necessary bookkeeping in LinkedHashMap . return e . setValue ( value ) ; else e = e . next ; } / / At this point , we know we need to add a new entry . modCount ++ ; if ( ++ size > threshold ) { rehash ( ) ; / / Need a new hash value to suit the bigger table . idx = hash ( key ) ; } / / LinkedHashMap cannot override put ( ) , hence this call . addEntry ( key , value , idx , true ) ; return null ; }	{ e . access ( ) ; Object r = e . value ; e . value = value ; return r ; }
getComponent ( ) . setOutputMarkupId ( true ) ; <CTX> protected void onBind ( ) { getComponent ( ) . setOutputMarkupId ( true ) ; }	super . onBind ( ) ;
BindingEvent . EVENT_COPY_TO_TARGET , BindingEvent . PIPELINE_AFTER_GET ) ; <CTX> public void updateTargetFromModel ( ) { updating = true ; try { int sizeToSetOnTarget = modelList . size ( ) ; BindingEvent e = new BindingEvent ( modelList , targetList , null , BindingEvent . EVENT_COPY_TO_TARGET , BindingEvent . PIPELINE_AFTER_GET ) ; e . originalValue = new Integer ( sizeToSetOnTarget ) ; if ( failure ( errMsg ( fireBindingEvent ( e ) ) ) ) { return ; } targetList . setSize ( sizeToSetOnTarget ) ; e . pipelinePosition = BindingEvent . PIPELINE_AFTER_CHANGE ; if ( failure ( errMsg ( fireBindingEvent ( e ) ) ) ) { return ; } } finally { updating = false ; } }	org . eclipse . jface . databinding . BindingEvent . EVENT_COPY_TO_TARGET , org . eclipse . jface . databinding . BindingEvent . PIPELINE_AFTER_GET ) ;
return n . foldConstants ( ts ) ; <CTX> public Node leave ( Node old , Node n , NodeVisitor v ) { return n . foldConstants ( ts ) ; }	return n . foldConstants ( ef ) ;
return eDynamicIsSet ( eFeature ) ; <CTX> public boolean eIsSet ( EStructuralFeature eFeature ) { switch ( eDerivedStructuralFeatureID ( eFeature ) ) { case AttributePackage . URL_VALUE__ BASE_URL : return BASE_URL_EDEFAULT == null ? baseUrl != null : ! BASE_URL_EDEFAULT . equals ( baseUrl ) ; case AttributePackage . URL_VALUE__ TARGET : return TARGET_EDEFAULT == null ? target != null : ! TARGET_EDEFAULT . equals ( target ) ; case AttributePackage . URL_VALUE__ BASE_PARAMETER_NAME : return BASE_PARAMETER_NAME_EDEFAULT == null ? baseParameterName != null : ! BASE_PARAMETER_NAME_EDEFAULT . equals ( baseParameterName ) ; case AttributePackage . URL_VALUE__ VALUE_PARAMETER_NAME : return VALUE_PARAMETER_NAME_EDEFAULT == null ? valueParameterName != null : ! VALUE_PARAMETER_NAME_EDEFAULT . equals ( valueParameterName ) ; case AttributePackage . URL_VALUE__ SERIES_PARAMETER_NAME : return SERIES_PARAMETER_NAME_EDEFAULT == null ? seriesParameterName != null : ! SERIES_PARAMETER_NAME_EDEFAULT . equals ( seriesParameterName ) ; } return eDynamicIsSet ( eFeature ) ; }	return super . eIsSet ( featureID ) ;
return typer . getParameterTypes ( ( MethodInfo ) value ) [ j ] . getClassName ( ) ; <CTX> private static void member_helper_type ( final CodeEmitter e , List members , final ObjectSwitchCallback callback , final ParameterTyper typer , final Label def , final Label end , final BitSet checked ) throws Exception { if ( members . size ( ) == 1 ) { MethodInfo member = ( MethodInfo ) members . get ( 0 ) ; Type [ ] types = typer . getParameterTypes ( member ) ; / / need to check classes that have not already been checked via switches for ( int i = 0 ; i < types . length ; i ++ ) { if ( checked == null || ! checked . get ( i ) ) { e . dup ( ) ; e . aaload ( i ) ; e . invoke_virtual ( Constants . TYPE_CLASS , GET_NAME ) ; e . push ( types [ i ] . getClassName ( ) ) ; e . invoke_virtual ( Constants . TYPE_OBJECT , EQUALS ) ; e . if_jump ( e . EQ , def ) ; } } e . pop ( ) ; callback . processCase ( member , end ) ; } else { / / choose the index that has the best chance of uniquely identifying member Type [ ] example = typer . getParameterTypes ( ( MethodInfo ) members . get ( 0 ) ) ; Map buckets = null ; int index = - 1 ; for ( int i = 0 ; i < example . length ; i ++ ) { final int j = i ; Map test = CollectionUtils . bucket ( members , new Transformer ( ) { public Object transform ( Object value ) { return typer . getParameterTypes ( ( MethodInfo ) value ) [ j ] . getClassName ( ) ; } } ) ; if ( buckets == null || test . size ( ) > buckets . size ( ) ) { buckets = test ; index = i ; } } if ( buckets == null ) { / / TODO : switch by returnType / / must have two methods with same name , types , and different return types e . goTo ( def ) ; } else { checked . set ( index ) ; e . dup ( ) ; e . aaload ( index ) ; e . invoke_virtual ( Constants . TYPE_CLASS , GET_NAME ) ; final Map fbuckets = buckets ; String [ ] names = ( String [ ] ) buckets . keySet ( ) . toArray ( new String [ buckets . size ( ) ] ) ; EmitUtils . string_switch ( e , names , Constants . SWITCH_STYLE_HASH , new ObjectSwitchCallback ( ) { public void processCase ( Object key , Label dontUseEnd ) throws Exception { member_helper_type ( e , ( List ) fbuckets . get ( key ) , callback , typer , def , end , checked ) ; } public void processDefault ( ) throws Exception { e . goTo ( def ) ; } } ) ; } } }	return TypeUtils . emulateClassGetName ( typer . getParameterTypes ( ( MethodInfo ) value ) [ j ] ) ;
setRowColumn ( index , column , true ) ; <CTX> void keyDown ( Event event ) { if ( table . getItemCount ( ) == 0 ) return ; switch ( event . character ) { case SWT . CR : notifyListeners ( SWT . DefaultSelection , new Event ( ) ) ; return ; } switch ( event . keyCode ) { case SWT . ARROW_UP : setRowColumn ( Math . max ( 0 , row - 1 ) , column , true ) ; break ; case SWT . ARROW_DOWN : setRowColumn ( Math . min ( row + 1 , table . getItemCount ( ) - 1 ) , column , true ) ; break ; case SWT . ARROW_LEFT : case SWT . ARROW_RIGHT : { int leadKey = ( getStyle ( ) & SWT . RIGHT_TO_LEFT ) != 0 ? SWT . ARROW_RIGHT : SWT . ARROW_LEFT ; if ( event . keyCode == leadKey ) { setRowColumn ( row , Math . max ( 0 , column - 1 ) , true ) ; } else { setRowColumn ( row , Math . min ( table . getColumnCount ( ) - 1 , column + 1 ) , true ) ; } break ; } case SWT . HOME : setRowColumn ( 0 , column , true ) ; break ; case SWT . END : { int i = table . getItemCount ( ) - 1 ; setRowColumn ( i , column , true ) ; break ; } case SWT . PAGE_UP : { int index = table . getTopIndex ( ) ; if ( index == row ) { Rectangle rect = table . getClientArea ( ) ; TableItem item = table . getItem ( index ) ; Rectangle itemRect = item . getBounds ( 0 ) ; rect . height -= itemRect . y ; int height = table . getItemHeight ( ) ; int page = Math . max ( 1 , rect . height / height ) ; index = Math . max ( 0 , index - page + 1 ) ; } setRowColumn ( index , column , true ) ; break ; } case SWT . PAGE_DOWN : { int index = table . getTopIndex ( ) ; Rectangle rect = table . getClientArea ( ) ; TableItem item = table . getItem ( index ) ; Rectangle itemRect = item . getBounds ( 0 ) ; rect . height -= itemRect . y ; int height = table . getItemHeight ( ) ; int page = Math . max ( 1 , rect . height / height ) ; int end = table . getItemCount ( ) - 1 ; index = Math . min ( end , index + page - 1 ) ; if ( index == row ) { index = Math . min ( end , index + page - 1 ) ; } setRowColumn ( index , column , true ) ; break ; } } }	setRowColumn ( index , columnIndex , true ) ;
ContextExpression expression ; expression = new ContextExpression ( contextId , expressionInfo ) ; <CTX> private void createHandlerActivation ( String contextId , String handlerId , String [ ] expressionInfo ) { ContextExpression expression ; expression = new ContextExpression ( contextId , expressionInfo ) ; makeHandler ( handlerId , contextId , expression ) ; }	ActiveContextExpression expression ; expression = new ActiveContextExpression ( contextId , expressionInfo ) ;
int lastLineLength ) { <CTX> public HereDocNode ( ISourcePosition position , String value , int func , int lastLineLength ) { this . value = value ; this . func = func ; this . lastLineLength = lastLineLength ; }	String lastLine ) { super ( position ) ;
} ; <CTX> public void processPacket ( Packet packet ) { / / Get the MUC User extension MUCUser mucUser = getMUCUserExtension ( packet ) ; / / Check if the MUCUser informs that the invitee has declined the invitation if ( mucUser . getDecline ( ) != null ) { / / Fire event for invitation rejection listeners fireInvitationRejectionListeners ( mucUser . getDecline ( ) . getFrom ( ) , mucUser . getDecline ( ) . getReason ( ) ) ; } } ;	else if ( presence . getType ( ) == Presence . Type . UNAVAILABLE ) { synchronized ( participantsMap ) { participantsMap . remove ( from ) ; } } }
bootImage = new byte [ BOOT_IMAGE_SIZE . toInt ( ) ] ; <CTX> BootImage ( boolean ltlEndian , boolean t ) { bootImage = new byte [ BOOT_IMAGE_SIZE . toInt ( ) ] ; littleEndian = ltlEndian ; trace = t ; }	bootImage = new byte [ BOOT_IMAGE_SIZE ] ;
WordCompletionData . AllWordsGetter getter = new WordCompletionData . AllWordsGetter ( ) ; <CTX> private static Object [ ] getAllWordsFromDocument ( PsiElement context , CompletionContext completionContext ) { WordCompletionData . AllWordsGetter getter = new WordCompletionData . AllWordsGetter ( ) ; return getter . get ( context , completionContext ) ; }	AllWordsGetter getter = new AllWordsGetter ( ) ;
statDisplayText . put ( new Integer ( statValue ) , statText ) ; <CTX> public void addStatDisplayText ( final int statValue , final String statText ) { if ( statDisplayText == null ) { / / Sort NUMERICALLY , not alphabetically ! statDisplayText = new TreeMap ( new ComparableComparator ( ) ) ; } statDisplayText . put ( new Integer ( statValue ) , statText ) ; }	statDisplayText . put ( statValue , statText ) ;
iVisited . accept (_Payload ) ; <CTX> public void visitArgsNode ( ArgsNode iVisited ) { iVisited . accept (_Payload ) ; Node lOptNode = iVisited . getOptNode ( ) ; if ( lOptNode != null ) { lOptNode . accept ( this ) ; } }	_ Payload . visitArgsNode ( iVisited ) ;
this . lastModifiedTime = lastModifiedTime ; <CTX> public void setLastModifiedTime ( long lastModifiedTime ) { this . lastModifiedTime = lastModifiedTime ; }	if ( lastModifiedTime > 0 ) { this . lastModifiedTime = lastModifiedTime ; }
WeakishReference ref = ( WeakishReference ) taskEnum . nextElement ( ) ; <CTX> private void invalidateCreatedTasks ( String type ) { synchronized ( createdTasks ) { Vector v = ( Vector ) createdTasks . get ( type ) ; if ( v != null ) { Enumeration taskEnum = v . elements ( ) ; while ( taskEnum . hasMoreElements ( ) ) { WeakishReference ref = ( WeakishReference ) taskEnum . nextElement ( ) ; Task t = ( Task ) ref . get ( ) ; / / being a weak ref , it may be null by this point if ( t != null ) { t . markInvalid ( ) ; } } v . removeAllElements ( ) ; createdTasks . remove ( type ) ; } } }	WeakReference ref = ( WeakReference ) taskEnum . nextElement ( ) ;
createPreviewDialog ( ) ; <CTX> public void setUserAgent ( FOUserAgent foUserAgent ) { super . setUserAgent ( foUserAgent ) ; if ( dialogDisplay ) { createPreviewDialog ( ) ; } }	setStatusListener ( PreviewDialog . createPreviewDialog ( userAgent , this . renderable ) ) ;
return_pkg ; <CTX> public JPackage getPackage ( ) { if (_parent != null ) { return_parent . getPackage ( ) ; } else { return_pkg ; } }	return pkg ;
theComponentPackage . initializePackageContents ( ) ; <CTX> public static TypePackage init ( ) { if ( isInited ) return ( TypePackage ) EPackage . Registry . INSTANCE . getEPackage ( TypePackage . eNS_URI ) ; / / Obtain or create and register package TypePackageImpl theTypePackage = ( TypePackageImpl ) ( EPackage . Registry . INSTANCE . getEPackage ( eNS_URI ) instanceof TypePackageImpl ? EPackage . Registry . INSTANCE . getEPackage ( eNS_URI ) : new TypePackageImpl ( ) ) ; isInited = true ; / / Initialize simple dependencies XMLTypePackageImpl . init ( ) ; / / Obtain or create and register interdependencies AttributePackageImpl theAttributePackage = ( AttributePackageImpl ) ( EPackage . Registry . INSTANCE . getEPackage ( AttributePackage . eNS_URI ) instanceof AttributePackageImpl ? EPackage . Registry . INSTANCE . getEPackage ( AttributePackage . eNS_URI ) : AttributePackageImpl . eINSTANCE ) ; ComponentPackageImpl theComponentPackage = ( ComponentPackageImpl ) ( EPackage . Registry . INSTANCE . getEPackage ( ComponentPackage . eNS_URI ) instanceof ComponentPackageImpl ? EPackage . Registry . INSTANCE . getEPackage ( ComponentPackage . eNS_URI ) : ComponentPackageImpl . eINSTANCE ) ; LayoutPackageImpl theLayoutPackage = ( LayoutPackageImpl ) ( EPackage . Registry . INSTANCE . getEPackage ( LayoutPackage . eNS_URI ) instanceof LayoutPackageImpl ? EPackage . Registry . INSTANCE . getEPackage ( LayoutPackage . eNS_URI ) : LayoutPackageImpl . eINSTANCE ) ; DataPackageImpl theDataPackage = ( DataPackageImpl ) ( EPackage . Registry . INSTANCE . getEPackage ( DataPackage . eNS_URI ) instanceof DataPackageImpl ? EPackage . Registry . INSTANCE . getEPackage ( DataPackage . eNS_URI ) : DataPackageImpl . eINSTANCE ) ; ModelPackageImpl theModelPackage = ( ModelPackageImpl ) ( EPackage . Registry . INSTANCE . getEPackage ( ModelPackage . eNS_URI ) instanceof ModelPackageImpl ? EPackage . Registry . INSTANCE . getEPackage ( ModelPackage . eNS_URI ) : ModelPackageImpl . eINSTANCE ) ; / / Create package meta - data objects theTypePackage . createPackageContents ( ) ; theAttributePackage . createPackageContents ( ) ; theComponentPackage . createPackageContents ( ) ; theLayoutPackage . createPackageContents ( ) ; theDataPackage . createPackageContents ( ) ; theModelPackage . createPackageContents ( ) ; / / Initialize created meta - data theTypePackage . initializePackageContents ( ) ; theAttributePackage . initializePackageContents ( ) ; theComponentPackage . initializePackageContents ( ) ; theLayoutPackage . initializePackageContents ( ) ; theDataPackage . initializePackageContents ( ) ; theModelPackage . initializePackageContents ( ) ; / / Mark meta - data to indicate it can t be changed theTypePackage . freeze ( ) ; return theTypePackage ; }	theDataPackage . initializePackageContents ( ) ;
b . setHorizontalAlignment ( SRadioButton . CENTER ) ; b . setVerticalAlignment ( SRadioButton . CENTER ) ; <CTX> void decorateButton ( SRadioButton b ) { b . setIcon ( nsel ) ; b . setSelectedIcon ( sel ) ; b . setRolloverIcon ( rollnsel ) ; b . setRolloverSelectedIcon ( rollsel ) ; b . setPressedIcon ( pressed ) ; b . setHorizontalAlignment ( SRadioButton . CENTER ) ; b . setVerticalAlignment ( SRadioButton . CENTER ) ; }	b . setHorizontalAlignment ( SConstants . CENTER ) ; b . setVerticalAlignment ( SConstants . CENTER ) ;
gotoItem . setEnabled ( linkList != null && ! ( linkList instanceof Index ) ) ; <CTX> protected void updateRightClickMenu ( Vector selectedLinks ) { LinkManagementHelper . LinkAction action ; for ( Iterator it = rightClickActions . iterator ( ) ; it . hasNext ( ) ; ) { action = ( LinkManagementHelper . LinkAction ) it . next ( ) ; action . setTarget ( selectedLinks ) ; } gotoItem . setEnabled ( linkList != null && ! ( linkList instanceof Index ) ) ; }	gotoItem . setEnabled ( ( linkList != null ) && ! ( linkList instanceof Index ) ) ;
} else if ( adapter == INavigatorContentService . class ) { <CTX> public Object getAdapter ( Class adapter ) { if ( adapter == CommonViewer . class ) { return getCommonViewer ( ) ; } else if ( adapter == INavigatorContentService . class ) { return getCommonViewer ( ) . getNavigatorContentService ( ) ; } return super . getAdapter ( adapter ) ; }	} else if ( adapter == INAVIGATOR_CONTENT_SERVICE ) {
item . setEnabled ( currentPart != null && site . isMovable ( currentPart ) ) ; <CTX> private void addMoveItems ( Menu moveMenu , String movePane , String moveSite ) { final Display display = moveMenu . getDisplay ( ) ; / / Add move view only menu item MenuItem item = new MenuItem ( moveMenu , SWT . NONE ) ; item . setText ( movePane ) ; / / $ NON - NLS - 1 $ item . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { site . dragStart ( currentPart , display . getCursorLocation ( ) , true ) ; } } ) ; item . setEnabled ( currentPart != null && site . isMovable ( currentPart ) ) ; / / Add move view s tab folder menu item item = new MenuItem ( moveMenu , SWT . NONE ) ; item . setText ( moveSite ) ; / / $ NON - NLS - 1 $ item . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { site . dragStart ( display . getCursorLocation ( ) , true ) ; } } ) ; item . setEnabled ( true ) ; }	item . setEnabled ( currentPart != null && site . isMoveable ( currentPart ) ) ;
assembleWar ( monitor ) ; break ; <CTX> public void assemble ( IProgressMonitor monitor ) throws CoreException { switch ( assembleType ) { case WAR : assembleWar ( monitor ) ; break ; case EAR : assembleEar ( monitor ) ; break ; case OTHER : assembleOther ( monitor ) ; break ; } }	return assembleWar ( monitor ) ;
super ( position ) ; <CTX> public VAliasNode ( ISourcePosition position , String newName , String oldName ) { super ( position ) ; this . oldName = oldName . intern ( ) ; this . newName = newName . intern ( ) ; }	super ( position , NodeTypes . VALIASNODE ) ;
return image ; <CTX> public Image getDescriptionImage ( ) { return image ; }	return null ;
experimentCopy . saveToDb ( saveToDbConflictHandler ) ; GUIUtils . timeConsumingTaskEnd ( organizer ) ; } <CTX> public void run ( ) { experimentCopy . saveToDb ( saveToDbConflictHandler ) ; GUIUtils . timeConsumingTaskEnd ( organizer ) ; }	societyCopy . saveToDatabase ( ) ; GUIUtils . timeConsumingTaskEnd ( organizer ) ; }
return Collections . EMPTY_SET ; <CTX> public Set getVariableNamesAsUnmodifiableSet ( ) { if ( domain != null ) { return domain . getVariableNamesAsUnmodifiableSet ( ) ; } return Collections . EMPTY_SET ; }	return Collections . emptySet ( ) ;
PartialTimestamp pt = new PartialTimestamp ( ) ; <CTX> public Object clone ( ) { PartialTimestamp pt = new PartialTimestamp ( ) ; for ( int field = CENTURY ; field < FIELD_COUNT ; field ++ ) { pt . modifiers [ field ] = this . modifiers [ field ] ; pt . fields [ field ] = this . fields [ field ] ; / * Make sure set fields are marked as set . * / if ( this . isSet ( field ) ) { pt . set ( field , pt . internalGet ( field ) ) ; } } pt . lastHourSet = this . lastHourSet ; pt . fieldsModified = this . fieldsModified ; pt . dayOfMonthSet = this . dayOfMonthSet ; pt . dayOfWeekInMonthSet = this . dayOfWeekInMonthSet ; pt . dayOfYearSet = this . dayOfYearSet ; pt . weekOfMonthSet = this . weekOfMonthSet ; pt . weekOfYearSet = this . weekOfYearSet ; pt . monthSet = this . monthSet ; pt . dayStamp = this . dayStamp ; return pt ; }	PartialTimestamp pt = ( PartialTimestamp ) super . clone ( ) ; pt . modifiers = new int [ FIELD_COUNT ] ;
boolean replacePreviousBinding ) throws ProActiveException { <CTX> public void registerVirtualNode ( String virtualNodeName , boolean replacePreviousBinding ) throws ProActiveException { try { proActiveRuntime . registerVirtualNode ( urid , virtualNodeName , replacePreviousBinding ) ; } catch ( IOException e ) { throw new ProActiveException ( e ) ; } }	boolean replacePreviousBinding ) throws ProActiveException , AlreadyBoundException {
endBB ( ) ; nextIsSuccessor = false ; <CTX> public void visit_return ( ) { endBB ( ) ; nextIsSuccessor = false ; }	endBB ( false ) ;
if ( ( oldValue & GC_FORWARDING_MASK ) == GC_FORWARDED ) return oldValue ; } while ( ! VM_Interface . attemptAvailableBits ( base , oldValue , oldValue | GC_BEING_FORWARDED ) ) ; <CTX> static int attemptToForward ( VM_Address base ) throws VM_PragmaInline , VM_PragmaUninterruptible { int oldValue ; do { oldValue = VM_Interface . prepareAvailableBits ( base ) ; if ( ( oldValue & GC_FORWARDING_MASK ) == GC_FORWARDED ) return oldValue ; } while ( ! VM_Interface . attemptAvailableBits ( base , oldValue , oldValue | GC_BEING_FORWARDED ) ) ; return oldValue ; }	if ( oldValue . and ( GC_FORWARDING_MASK ) . EQ ( GC_FORWARDED ) ) return oldValue ; } while ( ! VM_Interface . attemptAvailableBits ( base , oldValue , oldValue . or ( GC_BEING_FORWARDED ) ) ) ;
openProjectItemActionPerformed ( evt ) ; <CTX> public void actionPerformed ( java . awt . event . ActionEvent evt ) { openProjectItemActionPerformed ( evt ) ; }	newProjectItemActionPerformed ( evt ) ;
super ( ts ) ; interfaces = new TypedList ( new LinkedList ( ) , ClassType . class , false ) ; methods = new TypedList ( new LinkedList ( ) , MethodTypeInstance . class , false ) ; fields = new TypedList ( new LinkedList ( ) , FieldInstance . class , false ) ; innerClasses = new TypedList ( new LinkedList ( ) , ClassType . class , false ) ; this . containingClass = containingClass ; <CTX> public ParsedClassType ( TypeSystem ts , ClassType containingClass ) { super ( ts ) ; interfaces = new TypedList ( new LinkedList ( ) , ClassType . class , false ) ; methods = new TypedList ( new LinkedList ( ) , MethodTypeInstance . class , false ) ; fields = new TypedList ( new LinkedList ( ) , FieldInstance . class , false ) ; innerClasses = new TypedList ( new LinkedList ( ) , ClassType . class , false ) ; this . containingClass = containingClass ; }	this ( ts , null ) ;
charts . getCodeDistributionChart ( author ) <CTX> public AbstractChart [ ] getCharts ( ) { return new AbstractChart [ ] { charts . getActivityByHourChart ( author ) , charts . getActivityByDayChart ( author ) , charts . getCodeDistributionChart ( author ) } ; }	charts . getDirectorySizesChart ( author )
return exec ( cmd , null , null ) ; <CTX> public Process exec ( String [ ] cmd ) throws IOException { return exec ( cmd , null , null ) ; }	return exec ( cmdline , null , null ) ;
SaveableModelManager saveableModelManager = null ; <CTX> public void hideView ( IViewReference ref ) { / / Sanity check . if ( ref == null ) { return ; } Perspective persp = getActivePerspective ( ) ; if ( persp == null ) { return ; } IViewPart view = ref . getView ( false ) ; if ( view != null ) { if ( ! certifyPart ( view ) ) { return ; } / / Confirm . if ( ! persp . canCloseView ( view ) ) { return ; } } int refCount = getViewFactory ( ) . getReferenceCount ( ref ) ; SaveableModelManager saveableModelManager = null ; Object postCloseInfo = null ; if ( refCount == 1 ) { IWorkbenchPart actualPart = ref . getPart ( false ) ; if ( actualPart != null ) { saveableModelManager = ( SaveableModelManager ) actualPart . getSite ( ) . getService ( ISaveableModelManager . class ) ; postCloseInfo = saveableModelManager . preCloseParts ( Collections . singletonList ( actualPart ) , true , this . getWorkbenchWindow ( ) ) ; if ( postCloseInfo == null ) { / / cancel return ; } } } / / Notify interested listeners before the hide window . firePerspectiveChanged ( this , persp . getDesc ( ) , ref , CHANGE_VIEW_HIDE ) ; PartPane pane = getPane ( ref ) ; pane . setInLayout ( false ) ; updateActivePart ( ) ; / / Hide the part . persp . hideView ( ref ) ; / / Notify interested listeners after the hide window . firePerspectiveChanged ( this , getPerspective ( ) , CHANGE_VIEW_HIDE ) ; if ( saveableModelManager != null ) { saveableModelManager . postClose ( postCloseInfo ) ; } }	SaveablesList saveablesList = null ;
return match . getStartIndex ( group ) ; <CTX> public int start ( int group ) throws IllegalStateException { assertMatchOp ( ) ; return match . getStartIndex ( group ) ; }	return match . getStartIndex ( ) ;
Mode mode = jEdit . getMode ( ctx . rules . getModeName ( ) ) ; <CTX> private List < IndentRule > getIndentRules ( int line ) { TokenMarker . LineContext ctx = lineMgr . getLineContext ( line ) ; Mode mode = jEdit . getMode ( ctx . rules . getModeName ( ) ) ; return mode . getIndentRules ( ) ; } / / } } }	Mode mode ; if ( ctx . rules . getModeName ( ) == null ) mode = jEdit . getMode ( tokenMarker . getMainRuleSet ( ) . getModeName ( ) ) ; else mode = jEdit . getMode ( ctx . rules . getModeName ( ) ) ;
return isRoot ( ) || ( isStatic ( ) && isModuleClass ( ) <CTX> public final boolean isStaticOwner ( ) { return isRoot ( ) || ( isStatic ( ) && isModuleClass ( ) / / ! ! ! remove later ? translation does not work ( yet ? ) && isJava ( ) ) ; }	return isPackageClass ( ) || ( isStatic ( ) && isModuleClass ( )
Qualification qualification = new Qualification ( ) ; qualification . setPerson ( dfaCandidacy . getPerson ( ) ) ; qualification . setMark ( dfaCandidacy . getPrecedentDegreeInformation ( ) . getConclusionGrade ( ) ) ; qualification . setSchool ( dfaCandidacy . getPrecedentDegreeInformation ( ) . getInstitution ( ) . getName ( ) ) ; qualification . setDegree ( dfaCandidacy . getPrecedentDegreeInformation ( ) . getDegreeDesignation ( ) ) ; qualification . setDateYearMonthDay ( new YearMonthDay ( dfaCandidacy . getPrecedentDegreeInformation ( ) . getConclusionYear ( ) , 1 , 1 ) ) ; qualification . setCountry ( dfaCandidacy . getPrecedentDegreeInformation ( ) . getCountry ( ) ) ; <CTX> private void createQualification ( ) { DFACandidacy dfaCandidacy = ( DFACandidacy ) getCandidacy ( ) ; Qualification qualification = new Qualification ( ) ; qualification . setPerson ( dfaCandidacy . getPerson ( ) ) ; qualification . setMark ( dfaCandidacy . getPrecedentDegreeInformation ( ) . getConclusionGrade ( ) ) ; qualification . setSchool ( dfaCandidacy . getPrecedentDegreeInformation ( ) . getInstitution ( ) . getName ( ) ) ; qualification . setDegree ( dfaCandidacy . getPrecedentDegreeInformation ( ) . getDegreeDesignation ( ) ) ; qualification . setDateYearMonthDay ( new YearMonthDay ( dfaCandidacy . getPrecedentDegreeInformation ( ) . getConclusionYear ( ) , 1 , 1 ) ) ; qualification . setCountry ( dfaCandidacy . getPrecedentDegreeInformation ( ) . getCountry ( ) ) ; }	if ( dfaCandidacy . hasPrecedentDegreeInformation ( ) ) { Qualification qualification = new Qualification ( ) ; qualification . setPerson ( dfaCandidacy . getPerson ( ) ) ; qualification . setMark ( dfaCandidacy . getPrecedentDegreeInformation ( ) . getConclusionGrade ( ) ) ; qualification . setSchool ( dfaCandidacy . getPrecedentDegreeInformation ( ) . getInstitutionName ( ) ) ; qualification . setDegree ( dfaCandidacy . getPrecedentDegreeInformation ( ) . getDegreeDesignation ( ) ) ; if ( dfaCandidacy . getPrecedentDegreeInformation ( ) . getConclusionYear ( ) != null ) { qualification . setDateYearMonthDay ( new YearMonthDay ( dfaCandidacy . getPrecedentDegreeInformation ( ) . getConclusionYear ( ) , 1 , 1 ) ) ; } qualification . setCountry ( dfaCandidacy . getPrecedentDegreeInformation ( ) . getCountry ( ) ) ; }
this . localeSpecificDefinitions = new HashMap < Locale , Map > ( ) ; <CTX> public void reset ( ) { this . baseDefinitions = new HashMap < String , ComponentDefinition > ( ) ; this . localeSpecificDefinitions = new HashMap < Locale , Map > ( ) ; }	this . localeSpecificDefinitions = new HashMap < Locale , Map < String , ComponentDefinition >> ( ) ;
void Track ( String name , Measurement measurement ) { measurements . put ( name , measurement ) ; <CTX> void Track ( String name , Measurement measurement ) { measurements . put ( name , measurement ) ; }	void Track ( Measurement measurement ) { Track ( measurement . ShortName ( ) , measurement ) ;
if ( impl == null || closed ) <CTX> public InetAddress getLocalAddress ( ) { if ( impl == null || closed ) return null ; InetAddress localAddr ; try { localAddr = ( InetAddress ) impl . getOption ( SocketOptions . SO_BINDADDR ) ; SecurityManager s = System . getSecurityManager ( ) ; if ( s != null ) s . checkConnect ( localAddr . getHostName ( ) , - 1 ) ; } catch ( SecurityException e ) { localAddr = InetAddress . ANY_IF ; } catch ( SocketException e ) { return null ; } return localAddr ; }	if ( isClosed ( ) )
showAll = null ; <CTX> private void createShowAllGroup ( Composite parent ) { / / Create the group composite Composite composite = new Composite ( parent , SWT . NULL ) ; composite . setFont ( parent . getFont ( ) ) ; composite . setLayout ( new GridLayout ( ) ) ; composite . setLayoutData ( new GridData ( GridData . FILL_HORIZONTAL ) ) ; showAll = new Button ( composite , SWT . CHECK | SWT . LEFT ) ; showAll . setFont ( composite . getFont ( ) ) ; showAll . setText ( ManagedBuilderUIMessages . getResourceString ( SHOWALL_LABEL ) ) ; showAll . addListener ( SWT . Selection , new Listener ( ) { public void handleEvent ( Event e ) { populateTypes ( ) ; platformSelection . select ( 0 ) ; handleTypeSelection ( ) ; } } ) ; showAll . addDisposeListener ( new DisposeListener ( ) { public void widgetDisposed ( DisposeEvent event ) { showAll = null ; } } ) ; }	showAllProjTypes = null ; } } ) ; showAllConfigs = new Button ( composite , SWT . CHECK | SWT . LEFT ) ; showAllConfigs . setFont ( composite . getFont ( ) ) ; showAllConfigs . setText ( ManagedBuilderUIMessages . getResourceString ( SHOWALL_CONFIG_LABEL ) ) ; showAllConfigs . addListener ( SWT . Selection , new Listener ( ) { public void handleEvent ( Event e ) { populateConfigurations ( ) ; } } ) ; showAllConfigs . addDisposeListener ( new DisposeListener ( ) { public void widgetDisposed ( DisposeEvent event ) { showAllConfigs = null ;
byte [ ] [ ] output = new byte [ len ] [ ] ; <CTX> public synchronized byte [ ] [ ] grabAll ( ) { int len = contents . size ( ) ; byte [ ] [ ] output = new byte [ len ] [ ] ; Iterator i = contents . values ( ) . iterator ( ) ; int count = 0 ; while ( i . hasNext ( ) ) { output [ count ++ ] = ( byte [ ] ) i . next ( ) ; } contents . clear ( ) ; maxValue = minValue = - 1 ; return output ; }	LimitedRangeIntByteArrayMapElement [ ] output = new LimitedRangeIntByteArrayMapElement [ len ] ;
JLayeredPane ( ) <CTX> JLayeredPane ( ) { layers = new TreeMap ( ) ; componentToLayer = new Hashtable ( ) ; }	public JLayeredPane ( )
ILayoutContainer container = getContainer ( ) ; if ( container != null && container instanceof LayoutPart ) { LayoutPart parent = ( LayoutPart ) container ; Control parentControl = parent . getControl ( ) ; if ( parentControl != null && ! parentControl . isDisposed ( ) ) { parentControl . traverse ( e . detail ) ; e . doit = false ; } } <CTX> public void keyTraversed ( TraverseEvent e ) { ILayoutContainer container = getContainer ( ) ; if ( container != null && container instanceof LayoutPart ) { LayoutPart parent = ( LayoutPart ) container ; Control parentControl = parent . getControl ( ) ; if ( parentControl != null && ! parentControl . isDisposed ( ) ) { parentControl . traverse ( e . detail ) ; e . doit = false ; } } }	if ( e . detail == SWT . TRAVERSE_PAGE_NEXT || e . detail == SWT . TRAVERSE_PAGE_PREVIOUS ) { ILayoutContainer container = getContainer ( ) ; if ( container != null && container instanceof LayoutPart ) { LayoutPart parent = ( LayoutPart ) container ; Control parentControl = parent . getControl ( ) ; if ( parentControl != null && ! parentControl . isDisposed ( ) ) { parentControl . traverse ( e . detail ) ; e . doit = false ; } } }
if ( ! loadedFeatures . contains ( file ) ) { <CTX> public boolean require ( String file ) { if ( ! loadedFeatures . contains ( file ) ) { if ( load ( file ) ) { loadedFeatures . add ( file ) ; return true ; } } return false ; }	RubyString name = RubyString . newString ( runtime , file ) ; if ( ! loadedFeatures . contains ( name ) ) {
} else { <CTX> protected long doUpdate ( final File root , final SVNUpdateClient client ) throws SVNException { final long rev ; final SvnConfiguration configuration = SvnConfiguration . getInstance ( myVcs . getProject ( ) ) ; final UpdateRootInfo rootInfo = configuration . getUpdateRootInfo ( root , myVcs ) ; if ( rootInfo != null ) { final SVNURL url = rootInfo . getUrl ( ) ; if ( url != null && url . equals ( getSourceUrl ( root ) ) ) { if ( rootInfo . isUpdateToRevision ( ) ) { rev = client . doUpdate ( root , rootInfo . getRevision ( ) , configuration . UPDATE_RECURSIVELY ) ; } else { rev = client . doUpdate ( root , SVNRevision . HEAD , configuration . UPDATE_RECURSIVELY ) ; } } else { rev = client . doSwitch ( root , url , rootInfo . getRevision ( ) , configuration . UPDATE_RECURSIVELY ) ; } } else { rev = client . doUpdate ( root , SVNRevision . HEAD , configuration . UPDATE_RECURSIVELY ) ; } return rev ; }	} else if ( url != null ) {
case NotificationEvent . TEMPLATE_TRANSFORM_EVENT : <CTX> public void elementChanged ( DesignElementHandle focus , NotificationEvent ev ) { switch ( ev . getEventType ( ) ) { case NotificationEvent . CONTENT_EVENT : case NotificationEvent . STYLE_EVENT : { refresh ( ) ; break ; } case NotificationEvent . PROPERTY_EVENT : case NotificationEvent . TEMPLATE_TRANSFORM_EVENT : { refresh ( ) ; this . markDirty ( true ) ; break ; } } }	case NotificationEvent . THEME_EVENT : case NotificationEvent . TEMPLATE_TRANSFORM_EVENT :
if ( commands != null ) { Category category = ( Category ) parentElement ; <CTX> public Object [ ] getChildren ( Object parentElement ) { List children = new ArrayList ( ) ; if ( parentElement instanceof Category ) { if ( commands != null ) { Category category = ( Category ) parentElement ; for ( int i = 0 ; i < commands . size ( ) ; i ++ ) { Command command = ( Command ) commands . get ( i ) ; if ( category . getId ( ) . equals ( command . getCategory ( ) ) ) children . add ( command ) ; } } } else if ( parentElement == null ) { if ( categories != null && commands != null ) { List categories = new ArrayList ( KeyPreferencePage . this . categories ) ; Collections . sort ( categories , Category . nameComparator ( ) ) ; children . addAll ( categories ) ; List commands = new ArrayList ( ) ; for ( int i = 0 ; i < KeyPreferencePage . this . commands . size ( ) ; i ++ ) { Command command = ( Command ) KeyPreferencePage . this . commands . get ( i ) ; if ( command . getCategory ( ) == null ) commands . add ( command ) ; } Collections . sort ( commands , Command . nameComparator ( ) ) ; children . addAll ( commands ) ; } } return children . toArray ( ) ; }	Category category = ( Category ) parentElement ;
if ( recv . getRuntime ( ) . getLoadService ( ) . load ( file . toString ( ) ) ) { return recv . getRuntime ( ) . getTrue ( ) ; } return recv . getRuntime ( ) . getFalse ( ) ; <CTX> public static IRubyObject load ( IRubyObject recv , IRubyObject [ ] args ) { RubyString file = ( RubyString ) args [ 0 ] ; if ( recv . getRuntime ( ) . getLoadService ( ) . load ( file . toString ( ) ) ) { return recv . getRuntime ( ) . getTrue ( ) ; } return recv . getRuntime ( ) . getFalse ( ) ; }	recv . getRuntime ( ) . getLoadService ( ) . load ( file . toString ( ) ) ; return recv . getRuntime ( ) . getTrue ( ) ;
if ( ! deletePerspectives ( ) ) return false ; <CTX> public boolean performOk ( ) { / / Set the default perspective if ( ! Util . equals ( defaultPerspectiveId , perspectiveRegistry . getDefaultPerspective ( ) ) ) { perspectiveRegistry . setDefaultPerspective ( defaultPerspectiveId ) ; } if ( ! deletePerspectives ( ) ) return false ; / / Revert the perspectives perspectiveRegistry . revertPerspectives ( perspToRevert ) ; IPreferenceStore store = getPreferenceStore ( ) ; / / store the open view mode setting store . setValue ( IPreferenceConstants . OPEN_VIEW_MODE , openViewMode ) ; / / store the open perspective mode setting store . setValue ( IPreferenceConstants . OPEN_PERSP_MODE , openPerspMode ) ; / / save both the API prefs and the internal prefs / / the API prefs are modified by / / PerspectiveRegistry . setDefaultPerspective PrefUtil . savePrefs ( ) ; return true ; }	if ( perspectives . size ( ) < perspectiveRegistry . getPerspectives ( ) . length ) perspectiveRegistry . deletePerspectives ( perspToDelete ) ;
return new PrintWriter ( this . output ) ; <CTX> public PrintWriter getWriter ( ) { return new PrintWriter ( this . output ) ; }	return new PrintWriter ( this . outputWriter ) ;
return ( multipleMode ) ; <CTX> allowsMultipleSelections ( ) { return ( multipleMode ) ; }	return multipleMode ;
_ bits = new byte [ ( int ) (_size / 8 ) + (_size % 8 == 0 ? 0 : 1 ) ] ; dis . read (_bits ) ; <CTX> public BitArray ( DataInputStream dis ) throws IOException {_size = dis . readInt ( ) ;_bits = new byte [ ( int ) (_size / 8 ) + (_size % 8 == 0 ? 0 : 1 ) ] ; dis . read (_bits ) ; }	_ bits = new byte [ (_size / 8 ) + (_size % 8 == 0 ? 0 : 1 ) ] ; dis . readFully (_bits ) ;
if ( popup != null ) <CTX> public void setEnabled ( boolean enabled ) { / / If we are disabling it while it s proposing content , close the / / content proposal popup . if ( isEnabled && ! enabled ) { if ( popup != null ) popup . close ( ) ; } isEnabled = enabled ; }	if ( popup != null ) {
env . resolveType ( s . type ) ; env = new EnvForLocals ( env , s ) ; inAnnotation = savedInAnnotation ; isTwoStateContext = false ; <CTX> protected Env checkSkolemConstants ( Env env , boolean allowed ) { for ( int i = 0 ; i < skolemConstants . size ( ) ; i ++ ) { LocalVarDecl s = skolemConstants . elementAt ( i ) ; if ( allowed ) { Assert . notFalse ( ! isTwoStateContext ) ; Assert . notFalse ( ! inAnnotation ) ; boolean savedInAnnotation = inAnnotation ; inAnnotation = true ; isTwoStateContext = true ; env . resolveType ( s . type ) ; env = new EnvForLocals ( env , s ) ; inAnnotation = savedInAnnotation ; isTwoStateContext = false ; } else { errorExpectingLoop ( s . getStartLoc ( ) , TagConstants . SKOLEM_CONSTANT ) ; } } skolemConstants . removeAllElements ( ) ; return env ; }	try { env . resolveType ( s . type ) ; env = new EnvForLocals ( env , s ) ; } finally { inAnnotation = savedInAnnotation ; isTwoStateContext = false ; }
this . parse = in . readBoolean ( ) ? ParseImpl . read ( in ) : null ; <CTX> public final void readFields ( DataInput in ) throws IOException { this . crawlDatum = CrawlDatum . read ( in ) ; this . content = in . readBoolean ( ) ? Content . read ( in ) : null ; this . parse = in . readBoolean ( ) ? ParseImpl . read ( in ) : null ; }	this . parse = in . readBoolean ( ) ? ParseImpl . read ( in , this . nutchConf ) : null ;
return acl . getEncoded ( ) ; <CTX> private char [ ] getAclChars ( BwShareableDbentity ent ) throws CalFacadeException { if ( ent instanceof BwShareableContainedDbentity ) { BwCalendar container ; if ( ent instanceof BwCalendar ) { container = ( BwCalendar ) ent ; } else { container = ( ( BwShareableContainedDbentity ) ent ) . getCalendar ( ) ; } String path = container . getPath ( ) ; PathInfo pi = pathInfoMap . getInfo ( path ) ; if ( pi == null ) { pi = getPathInfo ( container ) ; pathInfoMap . putInfo ( path , pi ) ; } char [ ] aclChars = pi . encoded ; if ( ent instanceof BwCalendar ) { return aclChars ; } / * Create a merged access string from the entity access and the * container access * / String entAccess = ent . getAccess ( ) ; if ( entAccess == null ) { / / Nomerge needed return aclChars ; } try { Acl acl = new Acl ( ) ; acl . decode ( aclChars ) ; acl . merge ( entAccess . toCharArray ( ) ) ; return acl . getEncoded ( ) ; } catch ( Throwable t ) { throw new CalFacadeException ( t ) ; } } / * This is a way of making other objects sort of shareable . * The objects are locations , sponsors and categories . * * We store the default access in the owner principal and manipulate that to give * us some degree of sharing . * * In effect , the owner becomes the container for the object . * / String aclString = null ; String entAccess = ent . getAccess ( ) ; BwUser owner = ent . getOwner ( ) ; if ( ent instanceof BwCategory ) { aclString = owner . getCategoryAccess ( ) ; } else if ( ent instanceof BwLocation ) { aclString = owner . getLocationAccess ( ) ; } else if ( ent instanceof BwSponsor ) { aclString = owner . getSponsorAccess ( ) ; } if ( aclString == null ) { if ( entAccess == null ) { if ( ent . getPublick ( ) ) { return access . getDefaultPublicAccess ( ) . toCharArray ( ) ; } return access . getDefaultPersonalAccess ( ) . toCharArray ( ) ; } return entAccess . toCharArray ( ) ; } if ( entAccess == null ) { return aclString . toCharArray ( ) ; } try { Acl acl = new Acl ( ) ; acl . decode ( aclString . toCharArray ( ) ) ; acl . merge ( entAccess . toCharArray ( ) ) ; return acl . getEncoded ( ) ; } catch ( Throwable t ) { throw new CalFacadeException ( t ) ; } }	return acl . encodeAll ( ) ;
this . patternList = new LinkedList < Pattern > ( ) ; <CTX> public ClassScreener ( ) { this . patternList = new LinkedList < Pattern > ( ) ; }	this . patternList = new LinkedList < Matcher > ( ) ;
hashCodeComputed = true ; <CTX> public int hashCode ( ) { if ( ! hashCodeComputed ) { hashCode = HASH_INITIAL ; hashCode = hashCode * HASH_FACTOR + Util . hashCode ( activityRequirementBindings ) ; hashCode = hashCode * HASH_FACTOR + Util . hashCode ( activityPatternBindings ) ; hashCode = hashCode * HASH_FACTOR + Util . hashCode ( defined ) ; hashCode = hashCode * HASH_FACTOR + Util . hashCode ( enabled ) ; hashCode = hashCode * HASH_FACTOR + Util . hashCode ( id ) ; hashCode = hashCode * HASH_FACTOR + Util . hashCode ( name ) ; hashCodeComputed = true ; } return hashCode ; }	if ( hashCode == HASH_INITIAL ) hashCode ++ ;
if ( isSealed ( ) || doOverwrite ( name , this ) ) { super . delete ( name ) ; <CTX> public void delete ( String name ) { / / Let the super class to throw exceptions for sealed objects if ( isSealed ( ) || doOverwrite ( name , this ) ) { super . delete ( name ) ; } }	Object [ ] data = idMapData ; if ( data != null ) { int id = getId ( name , data ) ; if ( id != 0 ) { if ( ! isSealed ( ) ) { deleteId ( id ) ; return ; } }
_ statement = s ; <CTX> public void setStatement ( JStatement s ) {_statement = s ; }	statement = s ;
Object getValue ( ClassLoader cl , ClassPool cp ) <CTX> Object getValue ( ClassLoader cl , ClassPool cp ) throws ClassNotFoundException { return AnnotationImpl . make ( cl , getType ( cl ) , cp , value ) ; }	Object getValue ( ClassLoader cl , ClassPool cp , Method m )
view . getContainer ( ) . requestFocus ( ) ; <CTX> public void endOverlay ( ) { view . getContainer ( ) . requestFocus ( ) ; if ( editWidget != null ) { editWidget . setVisible ( false ) ; view . getContainer ( ) . remove ( editWidget ) ; Rectangle bounds = editWidget . getBounds ( ) ; view . getContainer ( ) . repaint ( bounds . x , bounds . y , bounds . width , bounds . height ) ; } }	view . getJComponent ( ) . requestFocus ( ) ;
Module getModule ( ) throws Exception ; <CTX> Module getModule ( ) throws Exception ;	Module getModule ( ) ;
else { return new DteDataEngine ( context ) ; } <CTX> public IDataEngine createDataEngine ( ExecutionContext context ) { IReportDocument document = context . getReportDocument ( ) ; if ( document != null ) { IDocumentArchive archive = document . getArchive ( ) ; String name = document . getReportDocumentName ( ) ; if ( context . isInFactory ( ) ) { return new DataGenerationEngine ( context , archive , name ) ; } else { return new DataGenerationEngine ( context , archive , name ) ; } } else { return new DteDataEngine ( context ) ; } }	return new DteDataEngine ( context ) ;
return arg . NUMERATOR ( ) ; <CTX> public LispObject execute ( LispObject arg ) throws ConditionThrowable { return arg . NUMERATOR ( ) ; }	return arg . DENOMINATOR ( ) ;
this . parentModule = runtime . getClasses ( ) . getObjectClass ( ) ; <CTX> protected RubyModule ( Ruby runtime , RubyClass metaClass , RubyClass superClass , RubyModule parentModule , String name ) { super ( runtime , metaClass ) ; this . superClass = superClass ; this . parentModule = parentModule ; setBaseName ( name ) ; / / If no parent is passed in , it is safe to assume Object . if ( this . parentModule == null ) { this . parentModule = runtime . getClasses ( ) . getObjectClass ( ) ; } }	this . parentModule = runtime . getObject ( ) ;
height = area . y + area . height - y ; <CTX> private void redrawTabArea ( int index ) { int x = 0 , y = 0 , width = 0 , height = 0 ; if ( index == - 1 ) { Rectangle area = super . getClientArea ( ) ; if ( area . width == 0 || area . height == 0 ) return ; width = area . x + area . width - BORDER_LEFT - BORDER_RIGHT ; height = getTabHeight ( ) + 1 ; / / + 1 causes top line between content and tabs to be redrawn x = area . x + BORDER_LEFT ; y = area . y + BORDER_TOP ; if ( onBottom ) { y = Math . max ( 0 , area . y + area . height - BORDER_BOTTOM - height ) ; } } else { CTabItem item = items [ index ] ; x = item . x ; y = item . y ; Rectangle area = super . getClientArea ( ) ; width = area . x + area . width - x ; height = area . y + area . height - y ; } redraw ( x , y , width , height , false ) ; }	height = item . height ;
getToolReferences ( ) . add ( toolRef ) ; <CTX> public void addToolReference ( ToolReference toolRef ) { getToolReferences ( ) . add ( toolRef ) ; }	getLocalToolReferences ( ) . add ( toolRef ) ;
if ( workingSet == null ) <CTX> private boolean isEnclosed ( IResource element ) { if ( workingSet == null ) return false ; if ( workingSet . isEmpty ( ) ) return true ; / / Everything is in an empty working set Set workingSetPaths = getWorkingSetAsSetOfPaths ( ) ; return workingSetPaths . contains ( element . getFullPath ( ) . toString ( ) ) ; }	if ( workingSet == null ) {
Hashtable envmt , <CTX> Result getStateToBind ( Object o , Name n , Context c , Hashtable envmt , Attributes a ) throws NamingException ;	Hashtable < ? , ? > envmt ,
boolean scheduleHash ( byte [ ] challenge , byte [ ] verifier , CachedUrlSet urlSet , ProbabilisticTimer timer , Object key ) { <CTX> boolean scheduleHash ( byte [ ] challenge , byte [ ] verifier , CachedUrlSet urlSet , ProbabilisticTimer timer , Object key ) { return true ; }	boolean scheduleHash ( Deadline timer , Object key , HashService . Callback callback ) {
( ( SimpleParticleInfluenceFactory . BasicDrag ) influence ) . setDragCoefficient ( dragCoefficientPanel . getFloatValue ( ) ) ; <CTX> public void stateChanged ( ChangeEvent e ) { ParticleInfluence influence = particleMesh . getInfluences ( ) . get ( influenceList . getSelectedIndex ( ) ) ; ( ( SimpleParticleInfluenceFactory . BasicDrag ) influence ) . setDragCoefficient ( dragCoefficientPanel . getFloatValue ( ) ) ; }	( ( SimpleParticleInfluenceFactory . BasicGravity ) influence ) . setGravityForce ( gravityInfluencePanel . getValue ( ) ) ;
synchronized ( ownedWindows ) <CTX> public void hide ( ) { / / Hide visible owned windows . synchronized ( ownedWindows ) { Iterator e = ownedWindows . iterator ( ) ; while ( e . hasNext ( ) ) { Window w = ( Window ) ( ( ( Reference ) e . next ( ) ) . get ( ) ) ; if ( w != null ) { if ( w . isVisible ( ) && w . getPeer ( ) != null ) w . getPeer ( ) . setVisible ( false ) ; } else e . remove ( ) ; } } super . hide ( ) ; }	synchronized ( getTreeLock ( ) )
hashMap . put ( objMap . keyAt ( i ) , objMap . getAt ( i ) ) ; <CTX> public Map getDefinitions ( ) { CharArrayObjectMap objMap = getRealDefinitions ( ) ; int size = objMap . size ( ) ; Map hashMap = new HashMap ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { hashMap . put ( objMap . keyAt ( i ) , objMap . getAt ( i ) ) ; } return hashMap ; }	hashMap . put ( String . valueOf ( objMap . keyAt ( i ) ) , objMap . getAt ( i ) ) ;
ac = new RMeanAmpConfig ( seis ) ; <CTX> public ParticleMotion ( final DataSetSeismogram hseis , DataSetSeismogram vseis , TimeConfig tc , Color color , String key , boolean horizPlane ) { DataSetSeismogram [ ] seis = { hseis , vseis } ; this . tc = tc ; ac = new RMeanAmpConfig ( seis ) ; tc . addListener ( ac ) ; tc . add ( seis ) ; tc . addListener ( this ) ; ac . addListener ( this ) ; this . hseis = hseis ; hseis . addSeisDataChangeListener ( this ) ; hseis . retrieveData ( this ) ; this . vseis = vseis ; vseis . addSeisDataChangeListener ( this ) ; vseis . retrieveData ( this ) ; this . key = key ; this . horizPlane = horizPlane ; setColor ( color ) ; tc . shaleTime ( 0 , 1 ) ; }	AmpConfig ac = ( AmpConfig ) keysToAmpConfigs . get ( key ) ; if ( ac == null ) { ac = new RMeanAmpConfig ( ) ; keysToAmpConfigs . put ( key , ac ) ; } ac . add ( seis ) ; ac . addListener ( this ) ;
getContinuum ( ) . addBuildDefinitionToProjectGroup ( projectGroupId , getBuildDefinitionFromInput ( ) ) ; <CTX> public String saveToGroup ( ) throws ContinuumException { try { if ( buildDefinitionId == 0 ) { getContinuum ( ) . addBuildDefinitionToProjectGroup ( projectGroupId , getBuildDefinitionFromInput ( ) ) ; } else { getContinuum ( ) . updateBuildDefinitionForProjectGroup ( projectGroupId , getBuildDefinitionFromInput ( ) ) ; } } catch ( ContinuumActionException cae ) { addActionError ( cae . getMessage ( ) ) ; return INPUT ; } return SUCCESS ; }	getContinuum ( ) . addBuildDefinitionToProjectGroup ( projectGroupId , newBuildDef ) ;
if ( dataSet == null ) <CTX> private void updateButtons ( ) { boolean okEnable = true ; if ( dataSet == null ) { okEnable = false ; } else { Iterator iter = inputParameterGroup . getParameters ( ) . iterator ( ) ; if ( ! iter . hasNext ( ) ) { okEnable = false ; } else { int count = 0 ; while ( iter . hasNext ( ) ) { Object obj = iter . next ( ) ; if ( obj instanceof ScalarParameterHandle ) { ScalarParameterHandle param = ( ScalarParameterHandle ) obj ; count ++ ; if ( param . getValueExpr ( ) == null ) { okEnable = false ; break ; } } } okEnable &= ( count != 0 ) ; } } getOkButton ( ) . setEnabled ( okEnable ) ; }	Iterator iter = inputParameterGroup . getParameters ( ) . iterator ( ) ; if ( ! iter . hasNext ( ) )
return m_driverManager . readResources ( m_context , addSiteRoot ( parentPath ) , filter ) ; <CTX> public List readResources ( String parentPath , CmsResourceFilter filter ) throws CmsException { return m_driverManager . readResources ( m_context , addSiteRoot ( parentPath ) , filter ) ; }	return m_driverManager . readResources ( m_context , readResource ( resourcename , CmsResourceFilter . ALL ) , filter ) ;
} if ( ISearchPageScoreComputer . class . equals ( key ) ) { <CTX> public Object getAdapter ( Object element , Class key ) { IJavaElement java = ( IJavaElement ) element ; if ( IPropertySource . class . equals ( key ) ) { return getProperties ( java ) ; } if ( IResource . class . equals ( key ) ) { return getResource ( java ) ; } if ( IProject . class . equals ( key ) ) { return getProject ( java ) ; } if ( ISearchPageScoreComputer . class . equals ( key ) ) { return fSearchPageScoreComputer ; } if ( IWorkbenchAdapter . class . equals ( key ) ) { return fgJavaWorkbenchAdapter ; } if ( IResourceLocator . class . equals ( key ) ) { return fgResourceLocator ; } if ( IPersistableElement . class . equals ( key ) ) { return new PersistableJavaElementFactory ( java ) ; } if ( IContributorResourceAdapter . class . equals ( key ) ) { return this ; } if ( ITaskListResourceAdapter . class . equals ( key ) ) { return fgTaskListAdapter ; } return null ; }	} if ( fSearchPageScoreComputer != null && ISearchPageScoreComputer . class . equals ( key ) ) {
ActionSetPartAssociationsReader assocReader = new ActionSetPartAssociationsReader ( ) ; assocReader . readRegistry ( Platform . getExtensionRegistry ( ) , this ) ; <CTX> public void readFromRegistry ( ) { ActionSetRegistryReader reader = new ActionSetRegistryReader ( ) ; reader . readRegistry ( Platform . getExtensionRegistry ( ) , this ) ; ActionSetPartAssociationsReader assocReader = new ActionSetPartAssociationsReader ( ) ; assocReader . readRegistry ( Platform . getExtensionRegistry ( ) , this ) ; }	extensions = getActionSetPartAssociationExtensionPoint ( ) . getExtensions ( ) ; for ( int i = 0 ; i < extensions . length ; i ++ ) { addActionSetPartAssociations ( PlatformUI . getWorkbench ( ) . getExtensionTracker ( ) , extensions [ i ] ) ; }
synchronized ( this ) { if ( curQueue == null ) { AWTEvent eventToAdd = event ; Object src = event . getSource ( ) ; if ( src instanceof Component ) { Component comp = ( Component ) src ; if ( comp . isCoalescer ( ) ) { AWTEvent relative = comp . getRelativeEvent ( event . getID ( ) ) ; if ( relative != null ) { AWTEvent coalisced = comp . coalesceEvents ( relative , event ) ; if ( coalisced != null ) { events . remove ( relative ) ; comp . removeRelativeEvent ( ) ; eventToAdd = coalisced ; } } comp . addNewEvent ( eventToAdd ) ; } } events . addLast ( eventToAdd ) ; notifyAll ( ) ; } else { curQueue . postEvent ( event ) ; } } if ( systemEventQueue ) { if ( ! isDispatchThread ( ) ) { toolkit . getNativeEventQueue ( ) . awake ( ) ; } else { toolkit . validateShutdownThread ( ) ; } } <CTX> public void postEvent ( AWTEvent event ) { synchronized ( this ) { if ( curQueue == null ) { AWTEvent eventToAdd = event ; Object src = event . getSource ( ) ; if ( src instanceof Component ) { Component comp = ( Component ) src ; if ( comp . isCoalescer ( ) ) { AWTEvent relative = comp . getRelativeEvent ( event . getID ( ) ) ; if ( relative != null ) { AWTEvent coalisced = comp . coalesceEvents ( relative , event ) ; if ( coalisced != null ) { events . remove ( relative ) ; comp . removeRelativeEvent ( ) ; eventToAdd = coalisced ; } } comp . addNewEvent ( eventToAdd ) ; } } events . addLast ( eventToAdd ) ; notifyAll ( ) ; } else { curQueue . postEvent ( event ) ; } } if ( systemEventQueue ) { if ( ! isDispatchThread ( ) ) { toolkit . getNativeEventQueue ( ) . awake ( ) ; } else { toolkit . validateShutdownThread ( ) ; } } }	event . isPosted = true ; getCore ( ) . postEvent ( event ) ;
defineClass ( scope , clazz , false ) ; <CTX> public static void defineClass ( Scriptable scope , Class clazz ) throws IllegalAccessException , InstantiationException , InvocationTargetException { defineClass ( scope , clazz , false ) ; }	defineClass ( scope , clazz , false , false ) ;
stylesheet . bindings . pop ( global ) ; } <CTX> void doApply ( Stylesheet stylesheet , QName mode , Node context , int pos , int len , Node parent , Node nextSibling ) throws TransformerException { boolean apply = global || ! stylesheet . bindings . containsKey ( name , global ) ; if ( apply ) { / / push the variable context stylesheet . bindings . push ( global ) ; / / set the variable Object value = getValue ( stylesheet , mode , context , pos , len ) ; if ( value != null ) { stylesheet . bindings . set ( name , value , global ) ; } } / / variable and param don t process children as such / / all subsequent instructions are processed with that variable context if ( next != null ) { next . apply ( stylesheet , mode , context , pos , len , parent , nextSibling ) ; } if ( apply ) { / / pop the variable context stylesheet . bindings . pop ( global ) ; } }	stylesheet . bindings . pop ( type ) ;
void destroy ( ) throws Exception ; <CTX> void destroy ( ) throws Exception ;	int destroy ( ) throws Exception ;
List < ITestNGMethod > filteredMethods = new ArrayList < ITestNGMethod > ( ) ; String [ ] groups = tm . getGroups ( ) ; Map < String , List < ITestNGMethod >> beforeGroupMap = groupMethods . getBeforeGroupsMap ( ) ; for ( String group : groups ) { List < ITestNGMethod > methods = beforeGroupMap . get ( group ) ; if ( methods != null ) { filteredMethods . addAll ( methods ) ; <CTX> private void invokeBeforeGroupsConfigurations ( ITestClass testClass , ITestNGMethod tm , ConfigurationGroupMethods groupMethods , XmlSuite suite , Map < String , String > params , Object instance ) { List < ITestNGMethod > filteredMethods = new ArrayList < ITestNGMethod > ( ) ; String [ ] groups = tm . getGroups ( ) ; Map < String , List < ITestNGMethod >> beforeGroupMap = groupMethods . getBeforeGroupsMap ( ) ; for ( String group : groups ) { List < ITestNGMethod > methods = beforeGroupMap . get ( group ) ; if ( methods != null ) { filteredMethods . addAll ( methods ) ; } } / / / / Invoke the right groups methods / / ITestNGMethod [ ] beforeMethodsArray = filteredMethods . toArray ( new ITestNGMethod [ filteredMethods . size ( ) ] ) ; invokeConfigurations ( testClass , beforeMethodsArray , suite , params , instance ) ; / / / / Remove them so they don t get run again / / groupMethods . removeBeforeGroups ( groups ) ; }	synchronized ( groupMethods ) { List < ITestNGMethod > filteredMethods = new ArrayList < ITestNGMethod > ( ) ; String [ ] groups = tm . getGroups ( ) ; Map < String , List < ITestNGMethod >> beforeGroupMap = groupMethods . getBeforeGroupsMap ( ) ; for ( String group : groups ) { List < ITestNGMethod > methods = beforeGroupMap . get ( group ) ; if ( methods != null ) { filteredMethods . addAll ( methods ) ; }
QuickFixAction . registerQuickFixAction ( unusedSymbolInfo , new EmptyIntentionAction ( HighlightDisplayKey . getDisplayNameByKey ( HighlightDisplayKey . UNUSED_SYMBOL ) , options ) , options ) ; <CTX> private HighlightInfo processLocalVariable ( PsiLocalVariable variable , final List < IntentionAction > options ) { PsiIdentifier identifier = variable . getNameIdentifier ( ) ; if ( ! myRefCountHolder . isReferenced ( variable ) ) { String message = MessageFormat . format ( LOCAL_VARIABLE_IS_NOT_USED , identifier . getText ( ) ) ; HighlightInfo highlightInfo = createUnusedSymbolInfo ( identifier , message ) ; QuickFixAction . registerQuickFixAction ( highlightInfo , new RemoveUnusedVariableFix ( variable ) , options ) ; return highlightInfo ; } boolean referenced = myRefCountHolder . isReferencedForRead ( variable ) ; if ( ! referenced ) { String message = MessageFormat . format ( LOCAL_VARIABLE_IS_NOT_USED_FOR_READING , identifier . getText ( ) ) ; HighlightInfo highlightInfo = createUnusedSymbolInfo ( identifier , message ) ; QuickFixAction . registerQuickFixAction ( highlightInfo , new RemoveUnusedVariableFix ( variable ) , options ) ; return highlightInfo ; } if ( ! variable . hasInitializer ( ) ) { referenced = myRefCountHolder . isReferencedForWrite ( variable ) ; if ( ! referenced ) { String message = MessageFormat . format ( LOCAL_VARIABLE_IS_NOT_ASSIGNED , identifier . getText ( ) ) ; final HighlightInfo unusedSymbolInfo = createUnusedSymbolInfo ( identifier , message ) ; QuickFixAction . registerQuickFixAction ( unusedSymbolInfo , new EmptyIntentionAction ( HighlightDisplayKey . getDisplayNameByKey ( HighlightDisplayKey . UNUSED_SYMBOL ) , options ) , options ) ; return unusedSymbolInfo ; } } return null ; }	QuickFixAction . registerQuickFixAction ( unusedSymbolInfo , new EmptyIntentionAction ( HighlightDisplayKey . getDisplayNameByKey ( HighlightDisplayKey . UNUSED_SYMBOL ) , options ) , options , displayName ) ;
this . lastUpdateCount = lastUpdateCount ; <CTX> public void setLastUpdateCount ( boolean lastUpdateCount ) { this . lastUpdateCount = lastUpdateCount ; }	this . lastUpdateCount = String . valueOf ( lastUpdateCount ) ;
while ( jType . isArray ( ) || jType . isCollection ( ) ) jType = jType . getComponentType ( ) ; <CTX> public void addParameter ( JParameter parameter ) throws IllegalArgumentException {_signature . addParameter ( parameter ) ; / / -- be considerate and add the class name to the / / -- each declaring class list of imports JType jType = parameter . getType ( ) ; while ( jType . isArray ( ) || jType . isCollection ( ) ) jType = jType . getComponentType ( ) ; if ( ! jType . isPrimitive ( ) ) { JClass jClass = ( JClass ) jType ; for ( int i = 0 ; i <_classes . size ( ) ; i ++ ) { ( ( JClass )_classes . elementAt ( i ) ) . addImport ( jClass . getName ( ) ) ; } } } / / -- addParameter	while ( jType . isArray ( ) || jType . isCollection ( ) ) { jType = jType . getComponentType ( ) ; }
if ( bothAreSets ( lhsValue , rhsValue ) ) <CTX> public Object evaluate ( Context context ) throws JaxenException { Object lhsValue = getLHS ( ) . evaluate ( context ) ; Object rhsValue = getRHS ( ) . evaluate ( context ) ; Navigator nav = context . getNavigator ( ) ; if ( bothAreSets ( lhsValue , rhsValue ) ) { return evaluateSetSet ( ( List ) lhsValue , ( List ) rhsValue , nav ) ; } if ( eitherIsSet ( lhsValue , rhsValue ) ) { if ( isSet ( lhsValue ) ) { if ( isString ( rhsValue ) ) { return evaluateSetString ( ( List ) lhsValue , ( String ) rhsValue , nav ) ; } else if ( isNumber ( rhsValue ) ) { return evaluateSetNumber ( ( List ) lhsValue , ( Number ) rhsValue , nav ) ; } else if ( isBoolean ( rhsValue ) ) { return evaluateSetBoolean ( ( List ) lhsValue , ( Boolean ) rhsValue , nav ) ; } } else { if ( isString ( lhsValue ) ) { return evaluateStringSet ( ( String ) lhsValue , ( List ) rhsValue , nav ) ; } else if ( isNumber ( lhsValue ) ) { return evaluateNumberSet ( ( Number ) lhsValue , ( List ) rhsValue , nav ) ; } else if ( isBoolean ( lhsValue ) ) { return evaluateSetBoolean ( ( List ) rhsValue , ( Boolean ) rhsValue , nav ) ; } } } return evaluateObjectObject ( lhsValue , rhsValue ) ; }	if ( eitherIsSet ( lhsValue , rhsValue ) ) { if ( isSet ( lhsValue ) ) { return evaluateSetSet ( ( List ) lhsValue , convertToList ( rhsValue ) , nav ) ; } else
} ; <CTX> public java . awt . Component getListCellRendererComponent ( javax . swing . JList list , Object value , int index , boolean isSelected , boolean cellHasFocus ) { return super . getListCellRendererComponent ( list , ( ( Locale ) value ) . getDisplayName ( ) , index , isSelected , cellHasFocus ) ; } ;	}
throws InvalidParameterException { return engine . engineGetParameter ( param ) ; } <CTX> public final Object getParameter ( String param ) throws InvalidParameterException { return engine . engineGetParameter ( param ) ; }	throws InvalidParameterException { return engineGetParameter ( param ) ; }
dispatch ( command ) ; <CTX> public boolean iterate ( ) { if ( dispatchQueue . isEmpty ( ) ) { return false ; } else { Command command = ( Command ) dispatchQueue . remove ( 0 ) ; dispatch ( command ) ; return true ; } }	processDispatch ( command ) ;
return null ; <CTX> public ICallable searchMethod ( String name ) { ICallable method = ( ICallable ) getMethods ( ) . get ( name ) ; if ( method == null ) { if ( getSuperClass ( ) != null ) { return getSuperClass ( ) . searchMethod ( name ) ; } else { return null ; } } else { method . setImplementationClass ( this ) ; return method ; } }	return UndefinedMethod . getInstance ( ) ;
runnable . run ( ) ; castedThisPipelineProcessor . addSelfAsParent ( context ) ; <CTX> protected static void executeParents ( PipelineContext context , Runnable runnable ) { Stack parents = ( Stack ) context . getAttribute ( PipelineContext . PARENT_PROCESSORS ) ; PipelineProcessor thisPipelineProcessor = ( PipelineProcessor ) parents . peek ( ) ; / / We cast this here to go arround a javac bug . ProcessorImpl castedThisPipelineProcessor = thisPipelineProcessor ; castedThisPipelineProcessor . removeSelfAsParent ( context ) ; runnable . run ( ) ; castedThisPipelineProcessor . addSelfAsParent ( context ) ; }	try { runnable . run ( ) ; } finally { castedThisPipelineProcessor . addSelfAsParent ( context ) ; }
makeReplacement ( self ) ; <CTX> public void visitFilter ( SIRFilter self , SIRFilterIter iter ) { makeReplacement ( self ) ; }	if ( replacing ) { makeReplacement ( self ) ; }
this ( Arrays . asList ( patterns ) ) ; <CTX> public MetaPattern ( final MetaPattern [ ] patterns ) { this ( Arrays . asList ( patterns ) ) ; }	this . pattern = Pattern . compile ( pattern ) ;
w = windows [ 0 ] ; isClosing = EditorManager . saveAll ( dirtyEditors , ! force , w ) ; <CTX> public void run ( ) { / / Collect dirtyEditors ArrayList dirtyEditors = new ArrayList ( ) ; ArrayList dirtyEditorsInput = new ArrayList ( ) ; IWorkbenchWindow windows [ ] = getWorkbenchWindows ( ) ; for ( int i = 0 ; i < windows . length ; i ++ ) { IWorkbenchPage pages [ ] = windows [ i ] . getPages ( ) ; for ( int j = 0 ; j < pages . length ; j ++ ) { WorkbenchPage page = ( WorkbenchPage ) pages [ j ] ; IEditorPart editors [ ] = page . getDirtyEditors ( ) ; for ( int k = 0 ; k < editors . length ; k ++ ) { IEditorPart editor = editors [ k ] ; if ( editor . isDirty ( ) ) { if ( ! dirtyEditorsInput . contains ( editor . getEditorInput ( ) ) ) { dirtyEditors . add ( editor ) ; dirtyEditorsInput . add ( editor . getEditorInput ( ) ) ; } } } } } if ( dirtyEditors . size ( ) > 0 ) { IWorkbenchWindow w = getActiveWorkbenchWindow ( ) ; if ( w == null ) w = windows [ 0 ] ; isClosing = EditorManager . saveAll ( dirtyEditors , ! force , w ) ; } if ( isClosing || force ) isClosing = windowManager . close ( ) ; }	w = getWorkbenchWindows ( ) [ 0 ] ; isClosing = EditorManager . saveAll ( dirtyEditors , ! force , w ) ;
writeStructureList ( obj , Module . SCRIPTLIBS_PROP ) ; <CTX> public void visitModule ( Module obj ) { if ( markLineNumber ) obj . initLineNoMap ( ) ; writer . attribute ( DesignSchemaConstants . XMLNS_ATTRIB , DEFAULT_NAME_SPACE ) ; writer . attribute ( DesignSchemaConstants . VERSION_ATTRIB , DesignSchemaConstants . REPORT_VERSION ) ; writer . attribute ( DesignSchemaConstants . ID_ATTRIB , new Long ( obj . getID ( ) ) . toString ( ) ) ; property ( obj , Module . AUTHOR_PROP ) ; property ( obj , Module . HELP_GUIDE_PROP ) ; property ( obj , Module . CREATED_BY_PROP ) ; property ( obj , Module . UNITS_PROP ) ; property ( obj , Module . BASE_PROP ) ; property ( obj , Module . INCLUDE_RESOURCE_PROP ) ; resourceKey ( obj , Module . TITLE_ID_PROP , Module . TITLE_PROP ) ; property ( obj , Module . COMMENTS_PROP ) ; resourceKey ( obj , Module . DESCRIPTION_ID_PROP , Module . DESCRIPTION_PROP ) ; writeUserPropertyDefns ( obj ) ; writeUserPropertyValues ( obj ) ; / / write property bindings writeStructureList ( obj , Module . PROPERTY_BINDINGS_PROP ) ; / / write script libs writeStructureList ( obj , Module . SCRIPTLIBS_PROP ) ; }	writeStructureList ( obj , IModuleModel . SCRIPTLIBS_PROP ) ;
else return new CacheResponse ( CacheResponse . SUCCESSFUL , rrset ) ; <CTX> lookupRecords ( Name name , short type , short dclass , byte minCred ) { CacheElement element = ( CacheElement ) findSet ( name , type , dclass ) ; if ( element == null ) return new CacheResponse ( CacheResponse . UNKNOWN ) ; if ( element . expiredTTL ( ) ) { removeSet ( name , type , dclass , element ) ; return new CacheResponse ( CacheResponse . UNKNOWN ) ; } if ( element . credibility >= minCred ) { RRset rrset = element . rrset ; if ( rrset == null ) return new CacheResponse ( CacheResponse . NEGATIVE ) ; if ( type != Type . CNAME && rrset . getType ( ) == Type . CNAME ) { CNAMERecord cname ; cname = ( CNAMERecord ) rrset . rrs ( ) . nextElement ( ) ; CacheResponse cr ; cr = lookupRecords ( cname . getTarget ( ) , type , dclass , minCred ) ; if ( ! cr . isUnknown ( ) ) return cr ; else return new CacheResponse ( CacheResponse . PARTIAL , cname . getTarget ( ) ) ; } else return new CacheResponse ( CacheResponse . SUCCESSFUL , rrset ) ; } else return new CacheResponse ( CacheResponse . UNKNOWN ) ; }	if ( cr == null ) cr = new CacheResponse ( CacheResponse . SUCCESSFUL ) ; cr . add ( rrset ) ;
context . pencil . eofill ( ) ; <CTX> public void execute ( PAContext context ) throws PainterException { context . pencil . eofill ( ) ; }	context . pencil . stroke ( ) ;
int remove = paragraphSize - ( index + 1 ) ; Element [ ] removed = new Element [ remove ] ; <CTX> private void recreateLeaves ( int start , ElementSpec [ ] data ) { BranchElement paragraph = ( BranchElement ) elementStack . peek ( ) ; int index = paragraph . getElementIndex ( start ) ; Element child = paragraph . getElement ( index ) ; AttributeSet atts = child . getAttributes ( ) ; if ( data . length > 1 ) { BranchElement newBranch = ( BranchElement ) createBranchElement ( paragraph , atts ) ; Element newLeaf = createLeafElement ( newBranch , atts , start , child . getEndOffset ( ) ) ; newBranch . replace ( 0 , 0 , new Element [ ] { newLeaf } ) ; BranchElement parent = ( BranchElement ) paragraph . getParentElement ( ) ; int parSize = parent . getElementCount ( ) ; Edit edit = getEditForParagraphAndIndex ( parent , parSize ) ; edit . addAddedElement ( newBranch ) ; int paragraphSize = paragraph . getElementCount ( ) ; int remove = paragraphSize - ( index + 1 ) ; Element [ ] removed = new Element [ remove ] ; int s = 0 ; for ( int j = index + 1 ; j < paragraphSize ; j ++ ) removed [ s ++ ] = paragraph . getElement ( j ) ; edit = getEditForParagraphAndIndex ( paragraph , index ) ; edit . addRemovedElements ( removed ) ; Element [ ] added = recreateAfterFracture ( removed , newBranch , 0 , child . getEndOffset ( ) ) ; edit = getEditForParagraphAndIndex ( newBranch , 1 ) ; edit . addAddedElements ( added ) ; lastFractured = newLeaf ; offset = newBranch . getEndOffset ( ) ; } else { Element newLeaf = createLeafElement ( paragraph , atts , start , child . getEndOffset ( ) ) ; Edit edit = getEditForParagraphAndIndex ( paragraph , index ) ; edit . addAddedElement ( newLeaf ) ; } }	Element [ ] removed = new Element [ paragraphSize - ( index + 1 ) ] ;
if ( ret . outer == null || ! ( ret . outer instanceof SequentialBlock ) ) return ; StructuredBlock pred = ret . outer . getSubBlocks ( ) [ 0 ] ; <CTX> private void removeReturnLocal ( ReturnBlock ret ) { if ( ret . outer == null || ! ( ret . outer instanceof SequentialBlock ) ) return ; StructuredBlock pred = ret . outer . getSubBlocks ( ) [ 0 ] ; if ( ! ( pred instanceof InstructionBlock ) ) return ; Expression instr = ( ( InstructionBlock ) pred ) . getInstruction ( ) ; if ( ! ( instr instanceof StoreInstruction ) ) return ; Expression retInstr = ret . getInstruction ( ) ; if ( ! ( retInstr instanceof LocalLoadOperator && ( ( StoreInstruction ) instr ) . lvalueMatches ( ( LocalLoadOperator ) retInstr ) ) ) return ; Expression rvalue = ( ( StoreInstruction ) instr ) . getSubExpressions ( ) [ 1 ] ; ret . setInstruction ( rvalue ) ; ret . replace ( ret . outer ) ; }	StructuredBlock pred = getPredecessor ( ret ) ;
try { if ( project . isAccessible ( ) && project . hasNature ( CProjectNature . C_NATURE_ID ) ) { <CTX> public boolean visit ( IResource resource ) { if ( resource . getType ( ) == IResource . PROJECT ) { IProject project = ( IProject ) resource ; try { if ( project . isAccessible ( ) && project . hasNature ( CProjectNature . C_NATURE_ID ) ) { getDescriptor ( project ) ; } } catch ( CoreException e ) { CCorePlugin . log ( e ) ; } return false ; } return resource . getType ( ) == IResource . ROOT ; }	try { if ( project . isAccessible ( ) && project . findMember ( CDescriptor . DESCRIPTION_FILE_NAME ) != null ) {
Stack stack = ( Stack ) ht . get ( Thread . currentThread ( ) ) ; <CTX> void clear ( ) { Stack stack = ( Stack ) ht . get ( Thread . currentThread ( ) ) ; if ( stack != null ) stack . setSize ( 0 ) ; }	Stack stack = getCurrentStack ( ) ;
loc = r . nextDouble ( ) ; <CTX> public synchronized void randomize ( RandomSource r ) { loc = r . nextDouble ( ) ; }	setValue ( r . nextDouble ( ) ) ;
this . targetLabel . resetStateForCodeGeneration ( ) ; <CTX> public void resetStateForCodeGeneration ( ) { this . targetLabel . resetStateForCodeGeneration ( ) ; }	if ( this . targetLabel != null ) { this . targetLabel . resetStateForCodeGeneration ( ) ; }
if ( prePage . isDirty ( ) ) { prePage . doSave ( null ) ; <CTX> public boolean onBroughtToTop ( IReportEditorPage prePage ) { if ( this . isMissingParameter ( ) ) { if ( this . parameterDialog != null ) { this . parameterDialog . open ( ) ; } return true ; } if ( getEditorInput ( ) != prePage . getEditorInput ( ) ) { setInput ( prePage . getEditorInput ( ) ) ; } if ( prePage . isDirty ( ) ) { prePage . doSave ( null ) ; } if ( getBrowser ( ) != null ) { display ( ) ; } return true ; }	if ( isMissingParameter ( ) ) { if ( parameterDialog != null ) { parameterDialog . open ( ) ; if ( parameterDialog . getReturnCode ( ) == InputParameterHtmlDialog . RETURN_CODE_BROWSER_CLOSED ) { isDisplay = true ; } }
webArtifactEdit = ( WebArtifactEdit ) ModuleCore . getFirstArtifactEditForRead ( project ) ; <CTX> protected ILibModule [ ] getLibModules ( ) { / / TODO this will throw class cast exception , do we still use ILibModule ? WebArtifactEdit webArtifactEdit = null ; try { webArtifactEdit = ( WebArtifactEdit ) ModuleCore . getFirstArtifactEditForRead ( project ) ; if ( webArtifactEdit != null ) return ( ILibModule [ ] ) webArtifactEdit . getLibModules ( ) ; } finally { if ( webArtifactEdit != null ) webArtifactEdit . dispose ( ) ; } return new ILibModule [ ] { } ; }	webArtifactEdit = ( WebArtifactEdit ) StructureEdit . getFirstArtifactEditForRead ( project ) ;
checkSaveModifiedValue ( descriptor ) ; <CTX> @ Override protected void doOKAction ( ) { if ( myForm . myRbResourceBundle . isSelected ( ) ) { final StringDescriptor descriptor = getDescriptor ( ) ; if ( descriptor != null ) { checkSaveModifiedValue ( descriptor ) ; } } super . doOKAction ( ) ; }	saveModifiedPropertyValue ( myModule , descriptor , myForm . myResourceBundleCard . myTfValue . getText ( ) ) ;
return eval ( source , lineNo , columnNo , funcBody ) ; <CTX> public Object apply ( String source , int lineNo , int columnNo , Object funcBody , Vector paramNames , Vector arguments ) throws BSFException { return eval ( source , lineNo , columnNo , funcBody ) ; }	return eval ( funcBody ) ;
return PDEPlugin . PLUGIN_ID ; <CTX> public String getPlugin ( ) { return PDEPlugin . PLUGIN_ID ; }	return IPDEUIConstants . PLUGIN_ID ;
java . awt . Image [ ] icons ) { <CTX> public ExplicitBeanInfo ( BeanDescriptor beanDescriptor , BeanInfo [ ] additionalBeanInfo , PropertyDescriptor [ ] propertyDescriptors , int defaultPropertyIndex , EventSetDescriptor [ ] eventSetDescriptors , int defaultEventIndex , MethodDescriptor [ ] methodDescriptors , java . awt . Image [ ] icons ) { this . beanDescriptor = beanDescriptor ; this . additionalBeanInfo = additionalBeanInfo ; this . propertyDescriptors = propertyDescriptors ; this . defaultPropertyIndex = defaultPropertyIndex ; this . eventSetDescriptors = eventSetDescriptors ; this . defaultEventIndex = defaultEventIndex ; this . methodDescriptors = methodDescriptors ; this . icons = icons ; }	Image [ ] icons ) {
return m_nodeSysLocn ; <CTX> public String getNodeSysLocn ( ) { return m_nodeSysLocn ; }	return htmlify ( m_nodeSysLocn ) ;
else return otherPressure ; <CTX> public float getOtherPressure ( ) { if ( cachedValueNeeded ( ) ) return cachedOtherPressure ; else return otherPressure ; }	return otherPressure ;
Node . Jump result = new Node . Jump ( Token . LOOP , lineno ) ; result . addChildToBack ( bodyTarget ) ; result . addChildrenToBack ( body ) ; <CTX> private Node createLoop ( int loopType , Node body , Node cond , Node init , Node incr , int lineno ) { Node . Target bodyTarget = new Node . Target ( ) ; Node . Target condTarget = new Node . Target ( ) ; if ( loopType == LOOP_FOR && cond . getType ( ) == Token . EMPTY ) { cond = new Node ( Token . TRUE ) ; } Node . Jump IFEQ = new Node . Jump ( Token . IFEQ , cond ) ; IFEQ . target = bodyTarget ; Node . Target breakTarget = new Node . Target ( ) ; Node . Jump result = new Node . Jump ( Token . LOOP , lineno ) ; result . addChildToBack ( bodyTarget ) ; result . addChildrenToBack ( body ) ; if ( loopType == LOOP_WHILE || loopType == LOOP_FOR ) { / / propagate lineno to condition result . addChildrenToBack ( new Node ( Token . EMPTY , lineno ) ) ; } result . addChildToBack ( condTarget ) ; result . addChildToBack ( IFEQ ) ; result . addChildToBack ( breakTarget ) ; result . target = breakTarget ; Node . Target continueTarget = condTarget ; if ( loopType == LOOP_WHILE || loopType == LOOP_FOR ) { / / Just add a GOTO to the condition in the do . . while Node . Jump GOTO = new Node . Jump ( Token . GOTO ) ; GOTO . target = condTarget ; result . addChildToFront ( GOTO ) ; if ( loopType == LOOP_FOR ) { if ( init . getType ( ) != Token . EMPTY ) { if ( init . getType ( ) != Token . VAR ) { init = new Node ( Token . EXPR_VOID , init ) ; } result . addChildToFront ( init ) ; } Node . Target incrTarget = new Node . Target ( ) ; result . addChildAfter ( incrTarget , body ) ; if ( incr . getType ( ) != Token . EMPTY ) { incr = new Node ( Token . EXPR_VOID , incr ) ; result . addChildAfter ( incr , incrTarget ) ; } continueTarget = incrTarget ; } } result . setContinue ( continueTarget ) ; return result ; }	loop . addChildToBack ( bodyTarget ) ; loop . addChildrenToBack ( body ) ;
byte [ ] bytes = str . getBytes ( ) ; <CTX> public static String base 64_encode ( String str ) { CharBuffer cb = new CharBuffer ( ) ; byte [ ] bytes = str . getBytes ( ) ; Base 64 . encode ( cb , bytes , 0 , bytes . length ) ; return cb . toString ( ) ; }	TempBuffer tb = TempBuffer . allocate ( ) ; byte [ ] buffer = tb . getBuffer ( ) ;
System . arraycopy ( buf , afp - array . length , array , 0 , n ) ; <CTX> public int read ( byte [ ] array ) throws IOException { int status = checkEfficiency ( array . length ) ; int n = 0 ; if ( status == DIS ) { n = dis . read ( array ) ; } else if ( status == ARRAY ) { n = array . length ; if ( ( buf . length - afp + array . length ) < array . length ) { n = buf . length - afp + array . length ; } System . arraycopy ( buf , afp - array . length , array , 0 , n ) ; } else { n = raf . read ( array ) ; } afp += n ; if ( status == DIS ) fp += n ; return n ; }	System . arraycopy ( buf , afp , array , 0 , n ) ;
Selection s = selection [ i ] ; setSelectedText ( s , TextUtilities . tabsToSpaces ( getSelectedText ( s ) , buffer . getTabSize ( ) ) ) ; <CTX> public void tabsToSpaces ( ) { Selection [ ] selection = getSelection ( ) ; if ( ! buffer . isEditable ( ) || selection . length == 0 ) { getToolkit ( ) . beep ( ) ; return ; } buffer . beginCompoundEdit ( ) ; for ( int i = 0 ; i < selection . length ; i ++ ) { Selection s = selection [ i ] ; setSelectedText ( s , TextUtilities . tabsToSpaces ( getSelectedText ( s ) , buffer . getTabSize ( ) ) ) ; } buffer . endCompoundEdit ( ) ; } / / } } }	setText ( TextUtilities . tabsToSpaces ( getText ( ) , buffer . getTabSize ( ) ) ) ; } else { for ( int i = 0 ; i < selection . length ; i ++ ) { Selection s = selection [ i ] ; setSelectedText ( s , TextUtilities . tabsToSpaces ( getSelectedText ( s ) , buffer . getTabSize ( ) ) ) ; }
int length =__ len__ ( ) ; int step = getStep ( s_step ) ; int start = getStart ( s_start , step , length ) ; int stop = getStop ( s_stop , start , step , length ) ; return getslice ( start , stop , step ) ; <CTX> final synchronized PyObject seq___getslice__ ( PyObject s_start , PyObject s_stop , PyObject s_step ) { int length =__ len__ ( ) ; int step = getStep ( s_step ) ; int start = getStart ( s_start , step , length ) ; int stop = getStop ( s_stop , start , step , length ) ; return getslice ( start , stop , step ) ; }	return seq___getslice__ ( s_start , s_stop , null ) ;
if ( jq . Bootstrapping ) { <CTX> public static double getstatic_D ( jq_StaticField f ) { jq . Assert ( f . getType ( ) == jq_Primitive . DOUBLE ) ; if ( jq . Bootstrapping ) { Object o = obj_trav . getStaticFieldValue ( f ) ; if ( o == null ) return 0 L ; return ( ( Double ) o ) . doubleValue ( ) ; } return Double . longBitsToDouble ( getstatic_L ( f ) ) ; }	if ( ! jq . RunningNative ) {
selectedIndex = 0 ; <CTX> protected FilterComboBoxModel ( ) { filters = new FileFilter [ 1 ] ; filters [ 0 ] = getAcceptAllFileFilter ( getFileChooser ( ) ) ; selectedIndex = 0 ; }	selected = filters [ 0 ] ;
CFG cfg = getCFG ( method ) ; <CTX> public DepthFirstSearch getDepthFirstSearch ( Method method ) throws CFGBuilderException { DepthFirstSearch dfs = dfsMap . get ( method ) ; if ( dfs == null ) { CFG cfg = getCFG ( method ) ; dfs = new DepthFirstSearch ( cfg ) ; dfs . search ( ) ; dfsMap . put ( method , dfs ) ; } return dfs ; }	CFG cfg = getRawCFG ( method ) ;
subIterator = ( KeyIterator ) fs . keyIterator ( ) ; <CTX> public Object next ( ) { while ( true ) { / / tail - recurse so we get infinite loop instead of OOM in case of a loop . . . if ( subIterator != null && subIterator . hasNext ( ) ) return subIterator . next ( ) ; if ( subIterator != null ) subIterator = null ; if ( mapIterator . hasNext ( ) ) { String key = ( String ) mapIterator . next ( ) ; Object value = map . get ( key ) ; if ( value instanceof String ) return value ; else { SimpleFieldSet fs = ( SimpleFieldSet ) value ; subIterator = ( KeyIterator ) fs . keyIterator ( ) ; continue ; } } return null ; } }	subIterator = fs . keyIterator ( ( prefix . length ( ) == 0 ) ? key : ( prefix + MULTI_LEVEL_CHAR + key ) ) ;
column . setMinWidth ( columnWidth ) ; column . setMaxWidth ( columnWidth ) ; <CTX> public void initColumnWidths ( JTable table ) { TableColumnModel columns = table . getColumnModel ( ) ; for ( int i = 0 ; i < columns . getColumnCount ( ) - 1 ; ++ i ) { TableColumn column = columns . getColumn ( i ) ; int columnIndex = column . getModelIndex ( ) ; TableCellRenderer renderer = table . getCellRenderer ( 0 , i ) ; Component c = renderer . getTableCellRendererComponent ( table , getPrototypeFor ( columnIndex ) , false , false , 0 , i ) ; final int columnWidth = c . getPreferredSize ( ) . width + columns . getColumnMargin ( ) ; if ( columnWidth >= 0 ) { column . setPreferredWidth ( columnWidth ) ; column . setMinWidth ( columnWidth ) ; column . setMaxWidth ( columnWidth ) ; } } }	} if ( getColumnClass ( columnIndex ) == Boolean . class ) { column . setResizable ( false ) ;
void writeChars ( String s ) throws IOException ; <CTX> void writeChars ( String s ) throws IOException ;	void writeChars ( String value ) throws IOException ;
if ( i != null ) <CTX> private static final int findLocalizedKeyCode ( String token ) { if ( localizedKeyCodes == null ) initLocalizedKeyCodes ( ) ; token = token . toUpperCase ( ) ; Integer i = ( Integer ) localizedKeyCodes . get ( token ) ; if ( i != null ) return i . intValue ( ) ; if ( token . length ( ) == 1 ) return token . charAt ( 0 ) ; return - 1 ; }	if ( i != null ) {
super ( control . getShell ( ) , PopupDialog . INFOPOPUP_SHELLSTYLE , false , false , false , false , null , infoText ) ; <CTX> ContentProposalPopup ( String infoText ) { super ( control . getShell ( ) , PopupDialog . INFOPOPUP_SHELLSTYLE , false , false , false , false , null , infoText ) ; this . proposals = getProposals ( filterText ) ; }	super ( control . getShell ( ) , PopupDialog . INFOPOPUPRESIZE_SHELLSTYLE , false , false , false , false , null , infoText ) ;
restoreItem . setEnabled ( selectingView ) ; <CTX> public void fill ( Menu menu , int index ) { / / TODO Auto - generated method stub super . fill ( menu , index ) ; orientationItem = new MenuItem ( menu , SWT . CASCADE , index ++ ) ; { orientationItem . setText ( WorkbenchMessages . FastViewBar_view_orientation ) ; Menu orientationSwtMenu = new Menu ( orientationItem ) ; RadioMenu orientationMenu = new RadioMenu ( orientationSwtMenu , currentOrientation ) ; orientationMenu . addMenuItem ( WorkbenchMessages . FastViewBar_horizontal , new Integer ( SWT . HORIZONTAL ) ) ; orientationMenu . addMenuItem ( WorkbenchMessages . FastViewBar_vertical , new Integer ( SWT . VERTICAL ) ) ; orientationItem . setMenu ( orientationSwtMenu ) ; } restoreItem = new MenuItem ( menu , SWT . CHECK , index ++ ) ; restoreItem . setSelection ( true ) ; restoreItem . setText ( WorkbenchMessages . ViewPane_fastView ) ; restoreItem . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { bar . restoreView ( selectedView ) ; } } ) ; closeItem = new MenuItem ( menu , SWT . NONE , index ++ ) ; closeItem . setText ( WorkbenchMessages . WorkbenchWindow_close ) ; closeItem . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { if ( selectedView != null ) { WorkbenchPage page = bar . getWindow ( ) . getActiveWorkbenchPage ( ) ; if ( page != null ) { page . hideView ( selectedView ) ; } } } } ) ; new MenuItem ( menu , SWT . SEPARATOR , index ++ ) ; showOn = new MenuItem ( menu , SWT . CASCADE , index ++ ) ; { showOn . setText ( WorkbenchMessages . FastViewBar_dock_on ) ; sidesMenu = new Menu ( showOn ) ; radioButtons = new RadioMenu ( sidesMenu , bar . side ) ; radioButtons . addMenuItem ( WorkbenchMessages . FastViewBar_Left , new Integer ( SWT . LEFT ) ) ; radioButtons . addMenuItem ( WorkbenchMessages . FastViewBar_Right , new Integer ( SWT . RIGHT ) ) ; radioButtons . addMenuItem ( WorkbenchMessages . FastViewBar_Bottom , new Integer ( SWT . BOTTOM ) ) ; showOn . setMenu ( sidesMenu ) ; } boolean selectingView = ( selectedView != null ) ; restoreItem . setEnabled ( selectingView ) ; restoreItem . setSelection ( true ) ; if ( selectingView ) { WorkbenchPage page = bar . getWindow ( ) . getActiveWorkbenchPage ( ) ; closeItem . setEnabled ( page != null && page . isCloseable ( selectedView ) ) ; } else { closeItem . setEnabled ( false ) ; } orientationItem . setEnabled ( selectingView ) ; if ( selectingView ) { / / Set the new orientation , but avoid re - sending the event to our own / / listener currentOrientation . set ( bar . getOrientation ( selectedView ) , orientationChangeListener ) ; } }	WorkbenchPage page = bar . getWindow ( ) . getActiveWorkbenchPage ( ) ; if ( selectingView ) { restoreItem . setEnabled ( page != null && page . isMoveable ( selectedView ) ) ; } else { restoreItem . setEnabled ( false ) ; }
cmbAnchor . select ( nameSet . getSafeNameIndex ( getTrendline ( ) . getLabelAnchor ( ) <CTX> private void populateLists ( ) { / / Set block Anchor property NameSet nameSet = LiteralHelper . anchorSet ; cmbAnchor . setItems ( nameSet . getDisplayNames ( ) ) ; cmbAnchor . select ( nameSet . getSafeNameIndex ( getTrendline ( ) . getLabelAnchor ( ) . getName ( ) ) ) ; / / Set Legend Position property / / nameSet = LiteralHelper . fullPositionSet ; / / cmbPosition . setItems ( nameSet . getDisplayNames ( ) ) ; / / cmbPosition . select ( nameSet . getSafeNameIndex ( getTrendline ( / / ) . getPosition ( ) / / . getName ( ) ) ) ; }	cmbAnchor . select ( nameSet . getSafeNameIndex ( ChartUIUtil . getFlippedAnchor ( getTrendline ( ) . getLabelAnchor ( ) , isFlippedAxes ( ) )
treeEvent . setNewValue ( contentRoots ) ; LOG . assertTrue ( myOldContentRoots != null ) ; treeEvent . setOldValue ( myOldContentRoots ) ; myOldContentRoots = null ; myManager . propertyChanged ( treeEvent ) ; <CTX> public void run ( ) { RepositoryManager repositoryManager = myManager . getRepositoryManager ( ) ; removeInvalidFilesAndDirs ( true ) ; if ( repositoryManager != null ) { repositoryManager . updateByRootsChange ( ) ; } PsiTreeChangeEventImpl treeEvent = new PsiTreeChangeEventImpl ( myManager ) ; treeEvent . setPropertyName ( PsiTreeChangeEvent . PROP_ROOTS ) ; final VirtualFile [ ] contentRoots = myProjectRootManager . getContentRoots ( ) ; treeEvent . setNewValue ( contentRoots ) ; LOG . assertTrue ( myOldContentRoots != null ) ; treeEvent . setOldValue ( myOldContentRoots ) ; myOldContentRoots = null ; myManager . propertyChanged ( treeEvent ) ; }	LOG . assertTrue ( myOldContentRoots == null ) ; myOldContentRoots = contentRoots ; treeEvent . setOldValue ( contentRoots ) ; myManager . beforePropertyChange ( treeEvent ) ;
/ * ( non - Javadoc ) <CTX> public static boolean promptToConfirm ( final Shell shell , final String title , String message , IResourceDelta delta , String [ ] ignoreModelProviderIds , boolean syncExec ) { IStatus status = ResourceChangeValidator . getValidator ( ) . validateChange ( delta , null ) ; if ( status . isOK ( ) ) { return true ; } final IStatus displayStatus ; if ( status . isMultiStatus ( ) ) { List result = new ArrayList ( ) ; IStatus [ ] children = status . getChildren ( ) ; for ( int i = 0 ; i < children . length ; i ++ ) { IStatus child = children [ i ] ; if ( ! isIgnoredStatus ( child , ignoreModelProviderIds ) ) { result . add ( child ) ; } } if ( result . isEmpty ( ) ) { return true ; } if ( result . size ( ) == 1 ) { displayStatus = ( IStatus ) result . get ( 0 ) ; } else { displayStatus = new MultiStatus ( status . getPlugin ( ) , status . getCode ( ) , ( IStatus [ ] ) result . toArray ( new IStatus [ result . size ( ) ] ) , status . getMessage ( ) , status . getException ( ) ) ; } } else { if ( isIgnoredStatus ( status , ignoreModelProviderIds ) ) { return true ; } displayStatus = status ; } if ( message == null ) { message = IDEWorkbenchMessages . IDE_sideEffectWarning ; } final String dialogMessage = NLS . bind ( IDEWorkbenchMessages . IDE_areYouSure , message ) ; final boolean [ ] result = new boolean [ ] { false } ; Runnable runnable = new Runnable ( ) { public void run ( ) { ErrorDialog dialog = new ErrorDialog ( shell , title , dialogMessage , displayStatus , IStatus . ERROR | IStatus . WARNING | IStatus . INFO ) { protected void createButtonsForButtonBar ( Composite parent ) { createButton ( parent , IDialogConstants . YES_ID , IDialogConstants . YES_LABEL , false ) ; createButton ( parent , IDialogConstants . NO_ID , IDialogConstants . NO_LABEL , true ) ; createDetailsButton ( parent ) ; } / * ( non - Javadoc ) * @ see org . eclipse . jface . dialogs . ErrorDialog # buttonPressed ( int ) * / protected void buttonPressed ( int id ) { if ( id == IDialogConstants . YES_ID ) { super . buttonPressed ( IDialogConstants . OK_ID ) ; } else if ( id == IDialogConstants . NO_ID ) { super . buttonPressed ( IDialogConstants . CANCEL_ID ) ; } super . buttonPressed ( id ) ; } } ; int code = dialog . open ( ) ; result [ 0 ] = code == 0 ; } } ; if ( syncExec ) { shell . getDisplay ( ) . syncExec ( runnable ) ; } else { runnable . run ( ) ; } return result [ 0 ] ; }	/ * * ( non - Javadoc ) *
void handleSetChange ( IObservableSet source , SetDiff diff ) ; <CTX> void handleSetChange ( IObservableSet source , SetDiff diff ) ;	void handleSetChange ( SetChangeEvent event ) ;
if ( element instanceof PsiDocToken ) return ( ( PsiDocToken ) element ) . getTokenType ( ) == myType ; else if ( element instanceof XmlToken ) return ( ( XmlToken ) element ) . getTokenType ( ) == myType ; <CTX> public boolean isAcceptable ( Object element , PsiElement context ) { if ( element instanceof PsiDocToken ) return ( ( PsiDocToken ) element ) . getTokenType ( ) == myType ; else if ( element instanceof XmlToken ) return ( ( XmlToken ) element ) . getTokenType ( ) == myType ; return false ; }	if ( element instanceof PsiElement ) { final ASTNode node = ( ( PsiElement ) element ) . getNode ( ) ; return node != null ? node . getElementType ( ) == myType : false ; } else if ( element instanceof ASTNode ) { return ( ( ASTNode ) element ) . getElementType ( ) == myType ; }
return key ; <CTX> public String getKey ( ) { return key ; }	return key . toString ( ) ;
return getAnimatedLengthAttribute ( null , SVG_REF_X_ATTRIBUTE , SVG_MARKER_REF_X_DEFAULT_VALUE , SVGOMAnimatedLength . HORIZONTAL_LENGTH , false ) ; <CTX> public SVGAnimatedLength getRefX ( ) { return getAnimatedLengthAttribute ( null , SVG_REF_X_ATTRIBUTE , SVG_MARKER_REF_X_DEFAULT_VALUE , SVGOMAnimatedLength . HORIZONTAL_LENGTH , false ) ; }	return refX ;
event . getAlarm ( ) . getAlarmid ( ) } ; <CTX> public int persist ( OnmsEvent event ) { Object [ ] parms = new Object [ ] { event . getId ( ) , / / eventID event . getEventUei ( ) , / / eventUei event . getNode ( ) . getId ( ) , / / nodeID event . getEventTime ( ) , / / eventTime event . getEventHost ( ) , / / eventHost event . getEventSource ( ) , / / eventSource event . getIpAddr ( ) , / / ipAddr event . getDistPoller ( ) . getName ( ) , / / eventDpName event . getEventSnmpHost ( ) , / / eventSnmphost event . getService ( ) . getId ( ) , / / serviceID event . getEventSnmp ( ) , / / eventSnmp event . getEventParms ( ) , / / eventParms event . getEventCreateTime ( ) , / / eventCreateTime event . getEventDescr ( ) , / / eventDescr event . getEventLogGroup ( ) , / / eventLoggroup event . getEventLogMsg ( ) , / / eventLogmsg event . getEventSeverity ( ) , / / eventSeverity event . getEventPathOutage ( ) , / / eventPathOutage event . getEventCorrelation ( ) , / / eventCorrelation event . getEventSuppressedCount ( ) , / / eventSuppressedCount event . getEventOperInstruct ( ) , / / eventOperInstruct event . getEventAutoAction ( ) , / / eventAutoAction event . getEventOperAction ( ) , / / eventOperAction event . getEventOperActionMenuText ( ) , / / eventOperActionMenuText event . getEventNotification ( ) , / / eventNotification event . getEventTTicket ( ) , / / eventTticket event . getEventTTicketState ( ) , / / eventTticketState event . getEventForward ( ) , / / eventForward event . getEventMouseOverText ( ) , / / eventMouseOverText event . getEventLog ( ) , / / eventLog event . getEventDisplay ( ) , / / eventDisplay event . getEventAckUser ( ) , / / eventAckUser event . getEventAckTime ( ) , / / eventAckTime event . getAlarm ( ) . getAlarmid ( ) } ; / / alarmID return update ( parms ) ; }	event . getAlarm ( ) . getId ( ) } ;
Object [ ] children = parent . getChildren ( ) ; <CTX> protected WizardCollectionElement getChildWithID ( WizardCollectionElement parent , String id ) { Object [ ] children = parent . getChildren ( ) ; for ( int i = 0 ; i < children . length ; ++ i ) { WizardCollectionElement currentChild = ( WizardCollectionElement ) children [ i ] ; if ( currentChild . getId ( ) . equals ( id ) ) return currentChild ; } return null ; }	Object [ ] children = parent . getChildren ( null ) ;
charsInByteArray ( byte [ ] buf , int offset , int len ) throws CharConversionException ; <CTX> charsInByteArray ( byte [ ] buf , int offset , int len ) throws CharConversionException ;	charsInByteArray ( byte [ ] buf ) throws CharConversionException { return ( charsInByteArray ( buf , 0 , buf . length ) ) ; }
notifier . eAdapters ( ) . addAll ( adapters ) ; <CTX> private void addAdapters ( Notifier notifier ) { if ( adapters != null ) { notifier . eAdapters ( ) . addAll ( adapters ) ; } }	notifier . eAdapters ( ) . addAll ( wizardContext . getModel ( ) . eAdapters ( ) ) ;
String getSummaryHtml ( Connection conn , Timestamp startDate , Timestamp endDate ) ; <CTX> String getSummaryHtml ( Connection conn , Timestamp startDate , Timestamp endDate ) ;	String getSummaryHtml ( Connection conn , Timestamp startDate , Timestamp endDate , Map < String , Object > extraParams ) ;
return current . getSystemFont ( ) ; <CTX> Font defaultFont ( ) { Display current = Display . getCurrent ( ) ; if ( current == null ) { Shell shell = new Shell ( ) ; Font font = shell . getFont ( ) ; shell . dispose ( ) ; return font ; } else return current . getSystemFont ( ) ; }	return new Font ( current , current . getSystemFont ( ) . getFontData ( ) ) ;
myPanel . reset ( ) ; <CTX> public void reset ( ) { myPanel . reset ( ) ; }	if ( myPanel != null ) { myPanel . reset ( ) ; }
buffer = ByteBuffer . allocateDirect ( bufferSize ) ; <CTX> public SocketChannelOutputStream ( SocketChannel channel , int bufferSize ) { this . channel = channel ; buffer = ByteBuffer . allocateDirect ( bufferSize ) ; }	buffer = ByteBuffer . allocate ( 8 ) ;
|| TAG_COMMON_WIZARD . equals ( elementName ) ; <CTX> protected boolean readElement ( IConfigurationElement element ) { String elementName = element . getName ( ) ; / * These are all of the valid root tags that exist * / return TAG_ACTION_PROVIDER . equals ( elementName ) || TAG_NAVIGATOR_CONTENT . equals ( elementName ) || TAG_COMMON_WIZARD . equals ( elementName ) ; }	|| TAG_COMMON_WIZARD . equals ( elementName ) || TAG_COMMON_FILTER . equals ( elementName ) ;
if ( object == null ) return ; <CTX> public void replyMessageReceived ( UniqueID id , SpyEvent spyEvent ) { if ( ! controller . isMonitoring ( ) ) return ; ActiveObject object = findActiveObject ( id ) ; if ( object == null ) return ; if ( ! object . isMonitoringReplySender ( ) ) return ; communicationEventListener . replyMessageReceived ( object , spyEvent ) ; }	if ( object == null ) { return ; }
. getOption ( InputOptions . OPT_IS_MASTER_PAGE_CONTENT ) ; <CTX> public void renderReport ( String docName , String pageRange , InputOptions renderOptions , OutputStream out ) throws ReportServiceException { IReportDocument doc = ReportEngineService . getInstance ( ) . openReportDocument ( getReportDesignName ( renderOptions ) , docName ) ; HttpServletRequest request = ( HttpServletRequest ) renderOptions . getOption ( InputOptions . OPT_REQUEST ) ; Locale locale = ( Locale ) renderOptions . getOption ( InputOptions . OPT_LOCALE ) ; Boolean isMasterPageContent = ( Boolean ) renderOptions . getOption ( InputOptions . OPT_IS_MASTER_PAGE_CONTENT ) ; boolean isMasterPage = isMasterPageContent == null ? false : isMasterPageContent . booleanValue ( ) ; Boolean svgFlag = ( Boolean ) renderOptions . getOption ( InputOptions . OPT_IS_MASTER_PAGE_CONTENT ) ; boolean isSvg = svgFlag == null ? false : svgFlag . booleanValue ( ) ; Boolean isRtl = ( Boolean ) renderOptions . getOption ( InputOptions . OPT_RTL ) ; Long pageNum = null ; if ( pageRange != null && pageRange . trim ( ) . length ( ) >= 0 ) pageNum = Long . valueOf ( pageRange ) ; long page = 1 ; if ( pageNum != null ) page = pageNum . longValue ( ) ; try { ReportEngineService . getInstance ( ) . renderReport ( out , request , doc , page , isMasterPage , isSvg , null , locale , isRtl . booleanValue ( ) ) ; doc . close ( ) ; } catch ( RemoteException e ) { throw new ReportServiceException ( e . getLocalizedMessage ( ) ) ; } }	. getOption ( InputOptions . OPT_SVG_FLAG ) ;
return getLocalProperty ( module , prop ) ; <CTX> public Object getLocalProperty ( Module module , String memberName ) { PropertyDefn prop = ( PropertyDefn ) getDefn ( ) . getMember ( memberName ) ; if ( prop == null ) return null ; return getLocalProperty ( module , prop ) ; }	if ( propDefn . isIntrinsic ( ) ) return getIntrinsicProperty ( propDefn . getName ( ) ) ; return null ;
abstract public Result parse ( Page page , Config cfg , Session session ) throws ParsingException ; <CTX> abstract public Result parse ( Page page , Config cfg , Session session ) throws ParsingException ;	public abstract Result parse ( Page page , Config cfg , Session session ) throws ParsingException ;
if ( sz < MINIMUM_BOTTOM_WIDTH ) { toolBarData . widthHint = MINIMUM_BOTTOM_WIDTH ; <CTX> public void update ( boolean force ) { fastViewBar . update ( force ) ; ToolItem [ ] items = fastViewBar . getControl ( ) . getItems ( ) ; if ( getSide ( ) == SWT . BOTTOM ) { toolBarData . widthHint = SWT . DEFAULT ; int sz = fastViewBar . getControl ( ) . computeSize ( SWT . DEFAULT , SWT . DEFAULT ) . x ; if ( sz < MINIMUM_BOTTOM_WIDTH ) { toolBarData . widthHint = MINIMUM_BOTTOM_WIDTH ; } } else { boolean shouldExpand = items . length > 0 ; if ( shouldExpand != visible ) { getToolBar ( ) . setVisible ( true ) ; if ( ! shouldExpand ) { toolBarData . widthHint = HIDDEN_WIDTH ; } else { toolBarData . widthHint = SWT . DEFAULT ; } visible = shouldExpand ; } } if ( items . length != oldLength ) { control . getParent ( ) . layout ( ) ; oldLength = items . length ; } for ( int idx = 0 ; idx < items . length ; idx ++ ) { IViewReference view = getViewFor ( items [ idx ] ) ; viewOrientation . put ( view . getId ( ) , new Integer ( isHorizontal ( view ) ? SWT . HORIZONTAL : SWT . VERTICAL ) ) ; } }	getToolBar ( ) . setVisible ( true ) ; if ( ! shouldExpand ) { toolBarData . widthHint = HIDDEN_WIDTH ; } else { toolBarData . widthHint = SWT . DEFAULT ;
mConfig . setCatchBlock ( extractBlockOption ( aTo ) ) ; <CTX> public void run ( ) { mConfig . setCatchBlock ( extractBlockOption ( aTo ) ) ; }	mConfig . setTryBlock ( extractBlockOption ( aTo ) ) ;
handleRemovePressed ( ) ; <CTX> public void widgetSelected ( SelectionEvent e ) { handleRemovePressed ( ) ; }	handleRestorePressed ( ) ;
if ( getScopeStack ( ) . hasLocalValues ( ) ) { <CTX> public IRubyObject getBackref ( ) { if ( getScopeStack ( ) . hasLocalValues ( ) ) { return getScopeStack ( ) . getValue ( 1 ) ; } return ruby . getNil ( ) ; }	if ( getScopeStack ( ) . hasLocalVariables ( ) ) {
setEnabled ( Util . isSingleConcreteSelection ( selection ) ) ; } <CTX> public void selectionChanged ( IStructuredSelection selection ) { setEnabled ( Util . isSingleConcreteSelection ( selection ) ) ; }	setEnabled ( Util . allConcreteSelection ( selection ) ) ; }
Battle battle = ( Battle ) iter . next ( ) ; if ( battle . getTerritory ( ) . equals ( t ) && battle . isBombingRun ( ) == bombing ) return battle ; <CTX> public Battle getPendingBattle ( Territory t , boolean bombing ) { Iterator iter = m_pendingBattles . iterator ( ) ; while ( iter . hasNext ( ) ) { Battle battle = ( Battle ) iter . next ( ) ; if ( battle . getTerritory ( ) . equals ( t ) && battle . isBombingRun ( ) == bombing ) return battle ; } return null ; }	Iterator iter = m_pendingBattles . iterator ( ) ; while ( iter . hasNext ( ) ) { Battle battle = ( Battle ) iter . next ( ) ; if ( battle . getTerritory ( ) . equals ( t ) && battle . isBombingRun ( ) == bombing ) return battle ; } return null ;
double oldValue = getDouble ( name ) ; if ( getDefaultDouble ( name ) == value ) getStorePreferences ( ) . remove ( name ) ; else getStorePreferences ( ) . putDouble ( name , value ) ; firePropertyChangeEvent ( name , new Double ( oldValue ) , new Double ( value ) ) ; silentRunning = false ; <CTX> public void setValue ( String name , double value ) { silentRunning = true ; / / Turn off updates from the store double oldValue = getDouble ( name ) ; if ( getDefaultDouble ( name ) == value ) getStorePreferences ( ) . remove ( name ) ; else getStorePreferences ( ) . putDouble ( name , value ) ; firePropertyChangeEvent ( name , new Double ( oldValue ) , new Double ( value ) ) ; silentRunning = false ; / / Restart listening to preferences }	try { double oldValue = getDouble ( name ) ; if ( getDefaultDouble ( name ) == value ) getStorePreferences ( ) . remove ( name ) ; else getStorePreferences ( ) . putDouble ( name , value ) ; if ( oldValue != value ) firePropertyChangeEvent ( name , new Double ( oldValue ) , new Double ( value ) ) ; } finally { silentRunning = false ; }
TableItem row = cursor . getRow ( ) ; if ( row == null ) return ; int rownr = table . indexOf ( row ) ; if ( rownr >= 0 ) <CTX> private void moveRowUp ( boolean edit ) { TableItem row = cursor . getRow ( ) ; if ( row == null ) return ; int rownr = table . indexOf ( row ) ; if ( rownr >= 0 ) { moveRow ( rownr + 1 , rownr ) ; TransAction ta = new TransAction ( ) ; ta . setItemMove ( new int [ ] { rownr + 1 } , new int [ ] { rownr } ) ; addUndo ( ta ) ; if ( edit ) edit ( rownr , 1 ) ; setRowNums ( ) ; } }	if ( activeTableItem == null ) return ; if ( activeTableRow > 0 )
return new RubyFixnum ( ruby , 0 ) ; <CTX> public static RubyObject rmdir ( Ruby ruby , RubyObject recv , RubyString path ) { new File ( path . toString ( ) ) . delete ( ) ; return new RubyFixnum ( ruby , 0 ) ; }	return RubyFixnum . newFixnum ( ruby , 0 ) ;
return channel != null && channel . isOpen ( ) ; <CTX> public boolean valid ( ) { return channel != null && channel . isOpen ( ) ; }	ByteChannel c = channel ; return ( c != null ) && ( c . isOpen ( ) ) ;
IntentionActionWithTextCaching action = new IntentionActionWithTextCaching ( pair . first ) ; <CTX> private IntentionActionWithTextCaching [ ] wrapActions ( List < Pair < IntentionAction , List < IntentionAction >> >> actions ) { IntentionActionWithTextCaching [ ] compositeActions = new IntentionActionWithTextCaching [ actions . size ( ) ] ; int index = 0 ; for ( Pair < IntentionAction , List < IntentionAction >> pair : actions ) { if ( pair . first != null ) { IntentionActionWithTextCaching action = new IntentionActionWithTextCaching ( pair . first ) ; if ( pair . second != null ) { for ( IntentionAction intentionAction : pair . second ) { action . addAction ( intentionAction , myQuickFixes . contains ( intentionAction ) ) ; } } compositeActions [ index ++ ] = action ; } } return compositeActions ; }	IntentionActionWithTextCaching action = new IntentionActionWithTextCaching ( pair . first . first , pair . first . second ) ;
return new Hashtable ( ) ; <CTX> public Hashtable getFileElements ( ) { return new Hashtable ( ) ; }	return fileElements ;
if ( ! Boolean . getBoolean ( PROP_GC ) ) <CTX> IDEIdleHelper ( IWorkbenchConfigurer aConfigurer ) { this . configurer = aConfigurer ; if ( ! Boolean . getBoolean ( PROP_GC ) ) return ; / / init gc interval Integer prop = Integer . getInteger ( PROP_GC_INTERVAL ) ; if ( prop != null && prop . intValue ( ) >= 0 ) minGCInterval = nextGCInterval = prop . intValue ( ) ; / / init max gc interval prop = Integer . getInteger ( PROP_GC_MAX ) ; if ( prop != null ) maxGC = prop . intValue ( ) ; / / hook idle handler final Display display = configurer . getWorkbench ( ) . getDisplay ( ) ; final Runnable handler = new Runnable ( ) { public void run ( ) { if ( ! configurer . getWorkbench ( ) . isClosing ( ) ) display . timerExec ( performGC ( ) , this ) ; } } ; idleListener = new Listener ( ) { public void handleEvent ( Event event ) { display . timerExec ( IDLE_INTERVAL , handler ) ; } } ; display . addFilter ( SWT . KeyUp , idleListener ) ; display . addFilter ( SWT . MouseUp , idleListener ) ; }	String enabled = System . getProperty ( PROP_GC ) ; if ( enabled != null && enabled . equalsIgnoreCase ( Boolean . FALSE . toString ( ) ) )
if ( ! updatesRequired . contains ( project ) ) { updatesRequired . add ( project ) ; <CTX> public void queueUpdateModule ( IProject project ) { synchronized ( this ) { if ( pauseCount > 0 ) { if ( ! updatesRequired . contains ( project ) ) { updatesRequired . add ( project ) ; } return ; } } updateModule ( project ) ; }	if ( ! moduleUpdatesRequired . contains ( project ) ) { moduleUpdatesRequired . add ( project ) ;
if ( chosenFont != null ) fontDialog . setFontList ( chosenFont ) ; <CTX> protected Button getChangeControl ( Composite parent ) { if ( changeFontButton == null ) { changeFontButton = new Button ( parent , SWT . PUSH ) ; if ( changeButtonText != null ) changeFontButton . setText ( changeButtonText ) ; changeFontButton . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent event ) { FontDialog fontDialog = new FontDialog ( changeFontButton . getShell ( ) ) ; if ( chosenFont != null ) fontDialog . setFontList ( chosenFont ) ; FontData font = fontDialog . open ( ) ; if ( font != null ) { FontData [ ] oldFont = chosenFont ; if ( oldFont == null ) oldFont = JFaceResources . getDefaultFont ( ) . getFontData ( ) ; setPresentsDefaultValue ( false ) ; FontData [ ] newData = new FontData [ 1 ] ; newData [ 0 ] = font ; updateFont ( newData ) ; fireValueChanged ( VALUE , oldFont [ 0 ] , font ) ; } } } ) ; changeFontButton . addDisposeListener ( new DisposeListener ( ) { public void widgetDisposed ( DisposeEvent event ) { changeFontButton = null ; } } ) ; changeFontButton . setFont ( parent . getFont ( ) ) ; setButtonLayoutData ( changeFontButton ) ; } else { checkParent ( changeFontButton , parent ) ; } return changeFontButton ; }	if ( chosenFont != null ) { fontDialog . setFontList ( chosenFont ) ; }
return next != null && next !=_tailptr ; <CTX> public final boolean hasNext ( DoublyLinkedList . Item i ) { DoublyLinkedList . Item next = i . getNext ( ) ; return next != null && next !=_tailptr ; }	return ( next != null ) && ( next !=_tailptr ) ;
super ( detailDisplayName , date ) ; date . getTime ( ) ; <CTX> public CalendarDetail ( String detailDisplayName , Calendar date ) { super ( detailDisplayName , date ) ; date . getTime ( ) ; }	super ( detailDisplayName , date ) ;
targetChooser . setText ( ChoiceSetFactory . getDisplayNameFromChoiceSet ( inputHandle . getTargetWindow ( ) , CHOICESET_TARGET ) ) ; <CTX> private void initDisplayArea ( ) { if ( DesignChoiceConstants . ACTION_LINK_TYPE_HYPERLINK . equals ( selectedType ) ) { if ( inputHandle . getURI ( ) != null ) { locationEditor . setText ( inputHandle . getURI ( ) ) ; } if ( inputHandle . getTargetWindow ( ) != null ) { targetChooser . setText ( ChoiceSetFactory . getDisplayNameFromChoiceSet ( inputHandle . getTargetWindow ( ) , CHOICESET_TARGET ) ) ; } else { targetChooser . select ( 0 ) ; } } else if ( DesignChoiceConstants . ACTION_LINK_TYPE_BOOKMARK_LINK . equals ( selectedType ) ) { if ( inputHandle . getTargetBookmark ( ) != null ) { bookmarkEditor . setText ( inputHandle . getTargetBookmark ( ) ) ; } initBookmarkList ( SessionHandleAdapter . getInstance ( ) . getReportDesignHandle ( ) ) ; } else if ( DesignChoiceConstants . ACTION_LINK_TYPE_DRILL_THROUGH . equals ( selectedType ) ) { if ( inputHandle . getTargetBookmark ( ) != null ) { bookmarkEditor . setText ( inputHandle . getTargetBookmark ( ) ) ; } if ( inputHandle . getReportName ( ) != null ) { locationEditor . setText ( inputHandle . getReportName ( ) ) ; } else { initParamterBindings ( ) ; initBookmarkList ( null ) ; } if ( inputHandle . getTargetWindow ( ) != null ) { targetChooser . setText ( ChoiceSetFactory . getDisplayNameFromChoiceSet ( inputHandle . getTargetWindow ( ) , CHOICESET_TARGET ) ) ; } else { targetChooser . select ( 0 ) ; } if ( inputHandle . getFormatType ( ) != null ) { formatChooser . setText ( ChoiceSetFactory . getDisplayNameFromChoiceSet ( inputHandle . getFormatType ( ) , CHOICESET_FORMAT ) ) ; } else { formatChooser . select ( 0 ) ; } } updateButtons ( ) ; }	pdfButton . setSelection ( true ) ;
